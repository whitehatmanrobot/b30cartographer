d,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed GUID.

Arguments:

    pGuid - The GUID to be transformed to printable format.

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.
        The string will be in this format:
        "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.
--*/

{
    //
    // num chars required to hold {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    //

#define NUM_GUID_STRING_CHARS 38

    NTSTATUS Status        = STATUS_UNSUCCESSFUL;

    ResultantString->Length        = NUM_GUID_STRING_CHARS*sizeof(WCHAR);
    ResultantString->MaximumLength = (NUM_GUID_STRING_CHARS+1)*sizeof(WCHAR);

    ResultantString->Buffer =
        LsapAllocateLsaHeap(ResultantString->MaximumLength);
    
    if (!ResultantString->Buffer)
    {
        *FreeWhenDone = FALSE;
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    *FreeWhenDone = TRUE;
    Status = STATUS_SUCCESS;
    
#if DBG
    {
    ULONG   NumChars;
    NumChars =
#endif
    swprintf(ResultantString->Buffer,
             L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
             pGuid->Data1,
             pGuid->Data2,
             pGuid->Data3,
             pGuid->Data4[0],
             pGuid->Data4[1],
             pGuid->Data4[2],
             pGuid->Data4[3],
             pGuid->Data4[4],
             pGuid->Data4[5],
             pGuid->Data4[6],
             pGuid->Data4[7]);
#if DBG
    ASSERT( NumChars == NUM_GUID_STRING_CHARS );
    }
#endif

 Cleanup:
    
    return Status;
}



NTSTATUS
LsapAdtBuildStringListString(
    IN  PLSA_ADT_STRING_LIST pList,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the strings
    in the passed string list.


Arguments:

    pList - The StringList to be transformed to printable format.

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    Other status values can be returned from called functions.

--*/

{
    NTSTATUS        Status      = STATUS_SUCCESS;
    ULONG           Length      = sizeof(WCHAR);    // terminating \0
    ULONG           i;
    PLSA_ADT_STRING_LIST_ENTRY  pEntry;

    *FreeWhenDone = FALSE;


    //
    // Output a dash if the list is empty.
    //

    if (pList == 0 || pList->cStrings == 0)
    {
        RtlInitUnicodeString(ResultantString, L"-");
        goto Cleanup;
    }


    //
    // Figure out how long the string is going to be.
    // Each sid will be displayed as '\n\r\t\tstring'.
    // Thus, we will need 4 + length of string wchars per entry.
    //

    for (
        i = 0, pEntry = pList->Strings;
        i < pList->cStrings;
        i++, pEntry++)
    {
        Length += 4 * sizeof(WCHAR);
        Length += pEntry->String.Length;
    }

    if (Length > 0xFFFF)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    ResultantString->Length         = 0;
    ResultantString->MaximumLength  = (USHORT)Length;
    ResultantString->Buffer         = LsapAllocateLsaHeap(ResultantString->MaximumLength);

    if (ResultantString->Buffer == 0)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    *FreeWhenDone = TRUE;


    //
    // Build the resultant string.
    //

    for (
        i = 0, pEntry = pList->Strings;
        i < pList->cStrings;
        i++, pEntry++)
    {
        Status = RtlAppendUnicodeToString(ResultantString, L"\r\n\t\t");
        ASSERT(NT_SUCCESS(Status));

        Status = RtlAppendUnicodeStringToString(ResultantString, &pEntry->String);
        ASSERT(NT_SUCCESS(Status));
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;
}



NTSTATUS
LsapAdtBuildSidListString(
    IN  PLSA_ADT_SID_LIST pList,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the sids
    in the passed sid list.


Arguments:

    pList - The SidList to be transformed to printable format.

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    Other status values can be returned from called functions.

--*/

{
    NTSTATUS        Status      = STATUS_SUCCESS;
    ULONG           Length      = sizeof(WCHAR);    // terminating \0
    //ULONG           SidLength;
    WCHAR           SidStringBuffer[256];
    UNICODE_STRING  SidString;
    ULONG           i;
    PLSA_ADT_SID_LIST_ENTRY     pEntry;

    *FreeWhenDone = FALSE;


    //
    // Output a dash if the list is empty.
    //

    if (pList == 0 || pList->cSids == 0)
    {
        RtlInitUnicodeString(ResultantString, L"-");
        goto Cleanup;
    }


    //
    // Figure out how long the string is going to be.
    // Each sid will be displayed as '\n\r\t\t%{sid_as_string}'.
    // Thus, we will need 7 + length of sid_as_string wchars per sid.
    //
    // Using the 'official' length for a stringized sid - 256 chars from
    // the above LsapAdtBuildSidString function.
    // Once we can link RtlLengthSidAsUnicodeString again we can use it
    // and not waste so much memory (see below fragment).
    //

    Length = ((7 + 256) * pList->cSids + 1) * sizeof(WCHAR);

/*
    for (
        i = 0, pEntry = pList->Sids;
        i < pList->cSids;
        i++, pEntry++)
    {
        Status = RtlLengthSidAsUnicodeString(
                    pEntry->Sid,
                    &SidLength);

        ASSERT(NT_SUCCESS(Status));

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Length += 7 * sizeof(WCHAR);
        Length += SidLength;
    }
*/
    if (Length > 0xFFFF)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    ResultantString->Length         = 0;
    ResultantString->MaximumLength  = (USHORT)Length;
    ResultantString->Buffer         = LsapAllocateLsaHeap(ResultantString->MaximumLength);

    if (ResultantString->Buffer == 0)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    *FreeWhenDone = TRUE;

    SidString.Length        = 0;
    SidString.MaximumLength = sizeof(SidStringBuffer);
    SidString.Buffer        = SidStringBuffer;


    //
    // Build the resultant string.
    //

    for (
        i = 0, pEntry = pList->Sids;
        i < pList->cSids;
        i++, pEntry++)
    {
        Status = RtlConvertSidToUnicodeString(&SidString, pEntry->Sid, FALSE);

        ASSERT(NT_SUCCESS(Status));

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Status = RtlAppendUnicodeToString(ResultantString, L"\r\n\t\t%{");
        ASSERT(NT_SUCCESS(Status));

        Status = RtlAppendUnicodeStringToString(ResultantString, &SidString);
        ASSERT(NT_SUCCESS(Status));

        Status = RtlAppendUnicodeToString(ResultantString, L"}");
        ASSERT(NT_SUCCESS(Status));
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;
}



NTSTATUS
LsapAdtBuildMessageString(
    IN  ULONG MessageId,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string saying that 'the bitmap
    value has changed, but we are not displaying it'. Currently it is
    only used to support tha SAM LogonHours extended attribute.

Arguments:

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.
        The string will be of this format:
        "%%nnnnnnnnnn"

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.
--*/

{
    NTSTATUS        Status;
    ULONG           Length;
    const ULONG     NumChars    = 12;  // %%nnnnnnnnnn

    *FreeWhenDone = FALSE;

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = (USHORT)((NumChars + 1) * sizeof(WCHAR));
    ResultantString->Buffer        = LsapAllocateLsaHeap(ResultantString->MaximumLength);
    
    if (!ResultantString->Buffer)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    *FreeWhenDone = TRUE;
    
    Length = _snwprintf(
                    ResultantString->Buffer,
                    NumChars + 1,
                    L"%%%%%u",
                    MessageId);

    ASSERT(1 <= Length && Length <= NumChars);

    ResultantString->Length = (USHORT)(Length * sizeof(WCHAR));

    Status = STATUS_SUCCESS;

Cleanup:
    
    return Status;
}

NTSTATUS
LsapAdtBuildIPv4Strings(
    IN  SOCKADDR_IN*    pSockAddr,
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN        FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN        FreeWhenDone2
    )
/*++

Routine Description:

    This function builds unicode strings representing the passed SOCKADDR_IN
    structure. 

Arguments:
    pSockAddr        - address to be converted to string format

    ResultantString1 - receives the IPv4 address

    FreeWhenDone1    - set to TRUE if the caller should free ResultantString1

    ResultantString2 - receives the port number

    FreeWhenDone2    - set to TRUE if the caller should free ResultantString2


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated

    STATUS_SUCCESS - on success
    
--*/

{
    NTSTATUS Status        = STATUS_UNSUCCESSFUL;
    WORD PortNumber = 0;
    

    //
    // the limits are in number of characters
    //
    const USHORT MAX_IP4_ADDR_LEN = 16;
    CONST USHORT MAX_IP4_PORT_LEN = 8;
    
    DWORD dwAddressType;

    
    *FreeWhenDone1 = FALSE;
    *FreeWhenDone2 = FALSE;

    dwAddressType = pSockAddr->sin_family;
    
    //
    // we only handle IPv4 address. check what we have got
    //

    if (dwAddressType != AF_INET)
    {
        Status = STATUS_INVALID_ADDRESS;
        goto Cleanup;
    }

    //
    // format the IP address
    //

    ResultantString1->MaximumLength = MAX_IP4_ADDR_LEN * sizeof(WCHAR);
    ResultantString1->Buffer = LsapAllocateLsaHeap(ResultantString1->MaximumLength);

    if ( !ResultantString1->Buffer )
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    *FreeWhenDone1 = TRUE;
    
    ResultantString1->Length =
        (USHORT) swprintf(ResultantString1->Buffer, L"%d.%d.%d.%d",
                          pSockAddr->sin_addr.S_un.S_un_b.s_b1,
                          pSockAddr->sin_addr.S_un.S_un_b.s_b2,
                          pSockAddr->sin_addr.S_un.S_un_b.s_b3,
                          pSockAddr->sin_addr.S_un.S_un_b.s_b4
                          ) * sizeof(WCHAR);

    //
    // format the port number
    //

    ResultantString2->MaximumLength = MAX_IP4_PORT_LEN * sizeof(WCHAR);
    ResultantString2->Buffer = LsapAllocateLsaHeap(ResultantString2->MaximumLength);
    
    if ( !ResultantString2->Buffer )
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    *FreeWhenDone2 = TRUE;

    PortNumber = pSockAddr->sin_port;

    //
    // The port address is in network order which is big-endian.
    // Convert it to little-endian if we are running on a little-endian machine.
    //

#if BYTE_ORDER == LITTLE_ENDIAN
    PortNumber = ((PortNumber & 0xff) << 8) | ((PortNumber & 0xff00) >> 8);
#endif

    ResultantString2->Length =
        (USHORT) swprintf(ResultantString2->Buffer, L"%d", PortNumber)
                   * sizeof(WCHAR);

    Status = STATUS_SUCCESS;
    
    
 Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (*FreeWhenDone1)
        {
            *FreeWhenDone1 = FALSE;
            LsapFreeLsaHeap( ResultantString1->Buffer );
        }

        if (*FreeWhenDone2)
        {
            *FreeWhenDone2 = FALSE;
            LsapFreeLsaHeap( ResultantString2->Buffer );
        }
    }

    return Status;
}


    
NTSTATUS
LsapAdtBuildIPv6Strings(
    IN  SOCKADDR_IN6*   pSockAddr,
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN        FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN        FreeWhenDone2
    )
/*++

Routine Description:

    This function builds unicode strings representing the passed SOCKADDR_IN6
    structure. 

Arguments:
    pSockAddr        - address to be converted to string format

    ResultantString1 - receives the IPv6 address

    FreeWhenDone1    - set to TRUE if the caller should free ResultantString1

    ResultantString2 - receives the port number

    FreeWhenDone2    - set to TRUE if the caller should free ResultantString2


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated

    STATUS_SUCCESS - on success
    
--*/

{
    NTSTATUS Status        = STATUS_UNSUCCESSFUL;

    //
    // IPv6 address is in the following formats:
    // 
    // hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:hhhh       OR
    // hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:ddd.ddd.ddd.ddd
    //
    // where
    // - hhhh is 1 to 4 digit hex number
    // - ddd is 1 to 3 digit decimal number
    //
    // the limits below are in number of characters
    //
    const USHORT MAX_IP6_ADDR_LEN = (4*8 + 7 + 3*4 + 3 + 1);
    const USHORT MAX_IP6_PORT_LEN = 8;
    
    DWORD dwAddressType;

    
    *FreeWhenDone1 = FALSE;
    *FreeWhenDone2 = FALSE;

    dwAddressType = pSockAddr->sin6_family;
    
    //
    // we only handle IPv6 address. check what we have got
    //

    if (dwAddressType != AF_INET6)
    {
        Status = STATUS_INVALID_ADDRESS;
        goto Cleanup;
    }

    //
    // format the IP address
    //

    ResultantString1->MaximumLength = MAX_IP6_ADDR_LEN * sizeof(WCHAR);
    ResultantString1->Buffer = LsapAllocateLsaHeap(ResultantString1->MaximumLength);

    if ( !ResultantString1->Buffer )
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    *FreeWhenDone1 = TRUE;
    
    ResultantString1->Length =
        (USHORT) MyIp6AddressToString(
                     &pSockAddr->sin6_addr, 
                     ResultantString1->Buffer,
                     ResultantString1->MaximumLength / sizeof(WCHAR)
                     ) * sizeof(WCHAR);
    //
    // format the port number
    //

    ResultantString2->MaximumLength = MAX_IP6_PORT_LEN * sizeof(WCHAR);
    ResultantString2->Buffer = LsapAllocateLsaHeap(ResultantString2->MaximumLength);
    
    if ( !ResultantString2->Buffer )
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    *FreeWhenDone2 = TRUE;
    
    ResultantString2->Length =
        (USHORT) swprintf(ResultantString2->Buffer, L"%d",
                          pSockAddr->sin6_port) * sizeof(WCHAR);

    Status = STATUS_SUCCESS;
    
 Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (*FreeWhenDone1)
        {
            *FreeWhenDone1 = FALSE;
            LsapFreeLsaHeap( ResultantString1->Buffer );
        }

        if (*FreeWhenDone2)
        {
            *FreeWhenDone2 = FALSE;
            LsapFreeLsaHeap( ResultantString2->Buffer );
        }
    }

    return Status;
}
    


NTSTATUS
LsapAdtBuildSockAddrString(
    IN  PSOCKADDR       pSockAddr, 
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN        FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN        FreeWhenDone2
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed
    SOCKADDR_IN/SOCKADDR_IN6 structure. The sin_family member is inspected
    to determine if the passed in pointer is SOCKADDR_IN or SOCKADDR_IN6 type.


Arguments:
    pSockAddr        - address to be converted to string format

    ResultantString1 - receives the IP address

    FreeWhenDone1    - set to TRUE if the caller should free ResultantString1

    ResultantString2 - receives the port number

    FreeWhenDone2    - set to TRUE if the caller should free ResultantString2


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated

    STATUS_SUCCESS - on success
    
--*/

{
    NTSTATUS Status        = STATUS_UNSUCCESSFUL;
    DWORD dwAddressType;

    
    *FreeWhenDone1 = FALSE;
    *FreeWhenDone2 = FALSE;

    dwAddressType = pSockAddr->sa_family;
    
    //
    // we only handle IPv4 and IPv6 addresses. check what we have got
    //

    if (dwAddressType == AF_INET)
    {
        Status = LsapAdtBuildIPv4Strings(
                     (SOCKADDR_IN*) pSockAddr,
                     ResultantString1,
                     FreeWhenDone1,
                     ResultantString2,
                     FreeWhenDone2
                     );
    }
    else if (dwAddressType == AF_INET6)
    {
        Status = LsapAdtBuildIPv6Strings(
                     (SOCKADDR_IN6*) pSockAddr,
                     ResultantString1,
                     FreeWhenDone1,
                     ResultantString2,
                     FreeWhenDone2
                     );
    }
    else
    {
        //
        // either unknown address type or the address is not provided,
        // just use '-' for address/port
        //

        (VOID) LsapAdtBuildDashString( ResultantString1, FreeWhenDone1 );
        (VOID) LsapAdtBuildDashString( ResultantString2, FreeWhenDone2 );

        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

 Cleanup:
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\util.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        util.c
//
// Contents:    General Purpose functions for the security interface
//
// Functions:   SPException         -- Handler for exceptions in packages
//              WLsaControlFunction -- Worker for SecurityPackageControl()
//              LsaControlFunction  -- User mode stub
//              LsaQueryPackage     -- User mode stub
//
//
// History:     14 Aug 92   RichardW    Created
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "sesmgr.h"
}

//+---------------------------------------------------------------------------
//
//  Function:   SpExceptionFilter
//
//  Synopsis:   General Exception filter, invoked by the SP_EXCEPTION macro.
//
//  Arguments:  [pSession]   --
//              [pException] --
//
//
//  History:    8-09-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LONG
SpExceptionFilter(  PVOID                   pSession,
                    EXCEPTION_POINTERS *    pException)
{
    DWORD_PTR CurrentPackage;
    PLSAP_SECURITY_PACKAGE pPackage = NULL;
    UNICODE_STRING LsaString = { 3 * sizeof( WCHAR ), 4 * sizeof( WCHAR ), L"LSA" };

    CurrentPackage = GetCurrentPackageId();

    if (CurrentPackage != SPMGR_ID)
    {
        pPackage = SpmpLocatePackage( CurrentPackage );
    }

    SpmpReportEventU(
        EVENTLOG_ERROR_TYPE,
        SPMEVENT_PACKAGE_FAULT,
        CATEGORY_SPM,
        sizeof(EXCEPTION_RECORD),
        pException->ExceptionRecord,
        1,
        ((CurrentPackage == SPMGR_ID || pPackage == NULL) ? 
           &LsaString :
           &pPackage->Name )
        );

    if (pException->ExceptionRecord->ExceptionCode != STATUS_POSSIBLE_DEADLOCK)
    {
        //
        // Fail new calls (just in case we don't go away immediately)
        //

        ShutdownBegun = TRUE;
    }

    return EXCEPTION_CONTINUE_SEARCH;
}


//+-------------------------------------------------------------------------
//
//  Function:   SPException
//
//  Synopsis:   Handles an exception in a security package.
//
//  Effects:    Varies, but may force an unload of a package.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This routine should, ideally, never be called as
//              SpExceptionFilter should always bubble the exception
//              all the way up to the top-level handler (i.e., the
//              unhandled exception filter), causing the LSA to exit.
//              However, just in case something catches the exception
//              and presses on, we'll disable the package as a
//              token effort.
//
//--------------------------------------------------------------------------
NTSTATUS
SPException(NTSTATUS  scRet,
            ULONG_PTR dwPackageID)
{
    PSession                pSession;
    PLSAP_SECURITY_PACKAGE             pPackage;
#if DBG
    PSpmExceptDbg           pException = (PSpmExceptDbg) TlsGetValue(dwExceptionInfo);
#endif

    pSession = GetCurrentSession();

    DebugLog((DEB_ERROR, "[%x] Exception in a package, code %x\n", pSession->dwProcessID, scRet));

    DebugLog((DEB_ERROR, "[%x] Address was @%x, %s address %x\n",
            pSession->dwProcessID,
            pException->pInstruction,
            (pException->Access ? "write" : "read"),
            pException->pMemory));

    if (dwPackageID == SPMGR_ID)
    {
        DebugLog((DEB_ERROR, "  LSA itself hit a fault, thread %d\n", GetCurrentThreadId()));
        DebugLog((DEB_ERROR, "  (ExceptionInfo @%x)\n", TlsGetValue(dwExceptionInfo)));
#if DBG
        DsysAssertMsg( 0, "exception in LSA" );
#endif
        return(scRet);
    }

    pPackage = SpmpLocatePackage( dwPackageID );

    if (!pPackage)
    {
        DebugLog((DEB_ERROR, "  Invalid package ID passed\n"));
        return(scRet);
    }

    if ((scRet == STATUS_ACCESS_VIOLATION) ||
        (scRet == E_POINTER))
    {
        DebugLog((DEB_ERROR, "  Package %ws created an access violation\n",
                        pPackage->Name.Buffer));

        // Flag package as invalid

        pPackage->fPackage |= SP_INVALID;
    }

    if ((scRet == STATUS_NO_MEMORY) ||
        (scRet == STATUS_INSUFFICIENT_RESOURCES))
    {
        DebugLog((DEB_ERROR, "  Out of memory situation exists\n"));
        DebugLog((DEB_ERROR, "  Further requests may fail unless memory is freed\n"));
    }

    //
    // if the code is a success code, it is probably a WIN32 error so we
    // map it as such

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   WLsaQueryPackage
//
//  Synopsis:   Get info on a package (short enum), copy to client's address
//              space
//
//  Effects:    none
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
WLsaQueryPackageInfo(
    PSECURITY_STRING    pPackageName,
    PSecPkgInfo *       ppInfo
    )
{
    NTSTATUS                scRet;
    PLSAP_SECURITY_PACKAGE  pPackage;
    WCHAR *                 pszString;
    PSession                pSession = GetCurrentSession();
    ULONG                   cbData;
    PSecPkgInfo             pClientInfo = NULL;
    PBYTE                   Where;
    UNICODE_STRING          CommentString;
    UNICODE_STRING          NameString;
    PSecPkgInfo             pLocalInfo = NULL;
    SecPkgInfo              PackageInfo = { 0 };
    LONG_PTR                ClientOffset;
    ULONG                   ulStructureSize = sizeof(SecPkgInfo);

    DebugLog((DEB_TRACE, "QueryPackage\n"));
    *ppInfo = NULL;

    pPackage = SpmpLookupPackage(pPackageName);

    if (!pPackage)
    {
        return(STATUS_NO_SUCH_PACKAGE);
    }

    SetCurrentPackageId(pPackage->dwPackageID);

    StartCallToPackage( pPackage );

    __try
    {
        scRet = pPackage->FunctionTable.GetInfo(&PackageInfo);
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pPackage->dwPackageID);
    }

    EndCallToPackage( pPackage );

    if (FAILED(scRet))
    {
        return(scRet);
    }

    //
    // Marshall the data to copy to the client
    //

    RtlInitUnicodeString(
        &NameString,
        PackageInfo.Name
        );

    RtlInitUnicodeString(
        &CommentString,
        PackageInfo.Comment
        );

    cbData = ulStructureSize +
            NameString.MaximumLength +
            CommentString.MaximumLength;

    SafeAllocaAllocate(pLocalInfo, cbData);

    if (pLocalInfo == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pClientInfo = (PSecPkgInfo) LsapClientAllocate(cbData);
    if (pClientInfo == NULL)
    {
        SafeAllocaFree(pLocalInfo);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    ClientOffset = (LONG_PTR) ((PBYTE) pClientInfo - (PBYTE) pLocalInfo);

    Where = (PBYTE) (pLocalInfo + 1);

    *pLocalInfo = PackageInfo;
    pLocalInfo->Name = (LPWSTR) (Where + ClientOffset);
    RtlCopyMemory(
        Where,
        NameString.Buffer,
        NameString.MaximumLength
        );
    Where += NameString.MaximumLength;

    pLocalInfo->Comment = (LPWSTR) (Where + ClientOffset);
    RtlCopyMemory(
        Where,
        CommentString.Buffer,
        CommentString.MaximumLength
        );
    Where += CommentString.MaximumLength;

    DsysAssert(Where - (PBYTE) pLocalInfo == (LONG) cbData);

    scRet = LsapCopyToClient(
                pLocalInfo,
                pClientInfo,
                cbData);

    SafeAllocaFree(pLocalInfo);

    if (FAILED(scRet))
    {
        LsapClientFree(pClientInfo);
        pClientInfo = NULL;
    }

    *ppInfo = pClientInfo;

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   WLsaGetSecurityUserInfo
//
//  Synopsis:   worker function to get info about a logon session
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
WLsaGetSecurityUserInfo(
    IN PLUID pLogonId,
    IN ULONG fFlags,
    OUT PSECURITY_USER_DATA * pUserInfo
    )
{
    PLSAP_LOGON_SESSION  pSession;
    NTSTATUS             Status;
    PSECURITY_USER_DATA  LocalUserData = NULL;
    PSECURITY_USER_DATA  ClientBuffer = NULL;
    SECPKG_CLIENT_INFO   ClientInfo;
    ULONG BufferSize;
    PUCHAR Where;
    LONG_PTR Offset;
    ULONG                ulStructureSize = sizeof(SECURITY_USER_DATA);

    DebugLog((DEB_TRACE_WAPI,"WLsaGetSecurityUserInfo called\n"));

    //
    // if the logon ID is null, it is for the caller
    // so we know to go to the primary package.
    //

    if (pLogonId == NULL)
    {
        Status = LsapGetClientInfo(&ClientInfo);

        if (!NT_SUCCESS(Status))
        {
            return Status;
        }

        pLogonId = &ClientInfo.LogonId;
    }

    pSession = LsapLocateLogonSession( pLogonId );

    if (!pSession)
    {
        DebugLog((DEB_WARN,"WLsaGetSecurityUserInfo called for non-existent LUID 0x%x:0x%x\n",
                        pLogonId->LowPart,pLogonId->HighPart));

        Status = STATUS_NO_SUCH_LOGON_SESSION;

        goto Cleanup;
    }

    BufferSize = ulStructureSize +
                    pSession->AccountName.Length +
                    pSession->AuthorityName.Length +
                    pSession->LogonServer.Length +
                    RtlLengthSid(pSession->UserSid);

    SafeAllocaAllocate(LocalUserData, BufferSize);

    if (LocalUserData == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ClientBuffer = (PSECURITY_USER_DATA) LsapClientAllocate(BufferSize);

    if (ClientBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Offset = (LONG_PTR) ((PUCHAR) ClientBuffer - (PUCHAR) LocalUserData);

    Where = (PUCHAR) (LocalUserData + 1);

    //
    // Copy in all the fields from the logon session.
    //

    LocalUserData->pSid = (PSID) (Where + Offset);

    RtlCopyMemory(
        Where,
        pSession->UserSid,
        RtlLengthSid(pSession->UserSid)
        );
    Where += RtlLengthSid(pSession->UserSid);

    //
    // Copy in the user name
    //

    LocalUserData->UserName.Length =
    LocalUserData->UserName.MaximumLength = pSession->AccountName.Length;
    LocalUserData->UserName.Buffer = (LPWSTR) (Where + Offset);

    RtlCopyMemory(
        Where,
        pSession->AccountName.Buffer,
        pSession->AccountName.Length
        );
    Where += pSession->AccountName.Length;

    //
    // Copy in the domain name
    //

    LocalUserData->LogonDomainName.Length =
    LocalUserData->LogonDomainName.MaximumLength = pSession->AuthorityName.Length;
    LocalUserData->LogonDomainName.Buffer = (LPWSTR) (Where + Offset);

    RtlCopyMemory(
        Where,
        pSession->AuthorityName.Buffer,
        pSession->AuthorityName.Length
        );
    Where += pSession->AuthorityName.Length;

    //
    // Copy in the logon server
    //

    LocalUserData->LogonServer.Length =
    LocalUserData->LogonServer.MaximumLength = pSession->LogonServer.Length;
    LocalUserData->LogonServer.Buffer = (LPWSTR) (Where + Offset);

    RtlCopyMemory(
        Where,
        pSession->LogonServer.Buffer,
        pSession->LogonServer.Length
        );
    Where += pSession->LogonServer.Length;

    //
    // Copy this to the client
    //

    LsapReleaseLogonSession( pSession );
    pSession = NULL;

    Status = LsapCopyToClient(
                LocalUserData,
                ClientBuffer,
                BufferSize
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *pUserInfo = ClientBuffer;
    ClientBuffer = NULL;

Cleanup:

    SafeAllocaFree(LocalUserData);

    if (ClientBuffer != NULL)
    {
        LsapClientFree(ClientBuffer);
    }

    if (pSession != NULL)
    {
        LsapReleaseLogonSession(pSession);
        pSession = NULL;
    }

    DebugLog((DEB_TRACE_WAPI,"GetUserInfo returned %x\n",Status));
    return(Status);
}


HANDLE  hEventLog = INVALID_HANDLE_VALUE;
DWORD   LoggingLevel = (1 << EVENTLOG_ERROR_TYPE) | (1 << EVENTLOG_WARNING_TYPE) |
                       (1 << EVENTLOG_INFORMATION_TYPE) ;
WCHAR   EventSourceName[] = TEXT("LsaSrv");

#define MAX_EVENT_STRINGS 8

//+---------------------------------------------------------------------------
//
//  Function:   SpmpInitializeEvents
//
//  Synopsis:   Connects to event log service
//
//  Arguments:  (none)
//
//  History:    1-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpInitializeEvents(void)
{
    HKEY    hKey;
    int     err;
    DWORD   disp;

    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                            TEXT("System\\CurrentControlSet\\Services\\EventLog\\System\\LsaSrv"),
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            NULL,
                            &hKey,
                            &disp);

    if (err)
    {
        return(FALSE);
    }

    if (disp == REG_CREATED_NEW_KEY)
    {
        RegSetValueEx(  hKey,
                        TEXT("EventMessageFile"),
                        0,
                        REG_EXPAND_SZ,
                        (PBYTE) TEXT("%SystemRoot%\\system32\\lsasrv.dll"),
                        sizeof(TEXT("%SystemRoot%\\system32\\lsasrv.dll")) );

        RegSetValueEx(  hKey,
                        TEXT("CategoryMessageFile"),
                        0,
                        REG_EXPAND_SZ,
                        (PBYTE) TEXT("%SystemRoot%\\system32\\lsasrv.dll"),
                        sizeof(TEXT("%SystemRoot%\\system32\\lsasrv.dll")) );

        disp = 7;
        RegSetValueEx(  hKey,
                        TEXT("TypesSupported"),
                        0,
                        REG_DWORD,
                        (PBYTE) &disp,
                        sizeof(DWORD) );
        disp = CATEGORY_MAX_CATEGORY - 1;
        RegSetValueEx(  hKey,
                        TEXT("CategoryCount"),
                        0,
                        REG_DWORD,
                        (PBYTE) &disp,
                        sizeof(DWORD) );
    }

    RegCloseKey(hKey);

    hEventLog = RegisterEventSource(NULL, EventSourceName);
    if (hEventLog)
    {
        return(TRUE);
    }

    hEventLog = INVALID_HANDLE_VALUE;

    DebugLog((DEB_ERROR, "Could not open event log, error %d\n", GetLastError()));
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpReportEvent
//
//  Synopsis:   Reports an event to the event log
//
//  Arguments:  [EventType]       -- EventType (ERROR, WARNING, etc.)
//              [EventId]         -- Event ID
//              [SizeOfRawData]   -- Size of raw data
//              [RawData]         -- Raw data
//              [NumberOfStrings] -- number of strings
//              ...               -- PWSTRs to string data
//
//  History:    1-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
SpmpReportEvent(
    IN BOOL Unicode,
    IN WORD EventType,
    IN DWORD EventId,
    IN DWORD Category,
    IN DWORD SizeOfRawData,
    IN PVOID RawData,
    IN DWORD NumberOfStrings,
    ...
    )
{
    va_list arglist;
    ULONG i;
    PWSTR Strings[ MAX_EVENT_STRINGS ];
    PSTR StringsA[ MAX_EVENT_STRINGS ];
    DWORD rv;

    if (hEventLog == INVALID_HANDLE_VALUE)
    {
        if (!SpmpInitializeEvents())
        {
            return((DWORD) -1);
        }
    }

    //
    // We're not supposed to be logging this, so nuke it
    //
    if ((LoggingLevel & (1 << EventType)) == 0)
    {
        return(0);
    }

    //
    // Look at the strings, if they were provided
    //
    va_start( arglist, NumberOfStrings );

    if (NumberOfStrings > MAX_EVENT_STRINGS) {
        NumberOfStrings = MAX_EVENT_STRINGS;
    }

    for (i=0; i<NumberOfStrings; i++) {
        if (Unicode)
        {
            Strings[ i ] = va_arg( arglist, PWSTR );
        }
        else
        {
            StringsA[ i ] = va_arg( arglist, PSTR );
        }
    }

    //
    // Report the event to the eventlog service
    //

    if (Unicode)
    {
        if (!ReportEventW(  hEventLog,
                            EventType,
                            (WORD) Category,
                            EventId,
                            NULL,
                            (WORD)NumberOfStrings,
                            SizeOfRawData,
                            (const WCHAR * *) Strings,
                            RawData) )
        {
            rv = GetLastError();
            DebugLog((DEB_ERROR,  "ReportEvent( %u ) failed - %u\n", EventId, GetLastError() ));

        }
        else
        {
            rv = ERROR_SUCCESS;
        }
    }
    else
    {
        if (!ReportEventA(  hEventLog,
                            EventType,
                            (WORD) Category,
                            EventId,
                            NULL,
                            (WORD)NumberOfStrings,
                            SizeOfRawData,
                            (const char * *) StringsA,
                            RawData) )
        {
            rv = GetLastError();
            DebugLog((DEB_ERROR,  "ReportEvent( %u ) failed - %u\n", EventId, GetLastError() ));
        }
        else
        {
            rv = ERROR_SUCCESS;
        }
    }

    return rv;
}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpReportEventU
//
//  Synopsis:   Reports an event to the event log
//
//  Arguments:  [EventType]       -- EventType (ERROR, WARNING, etc.)
//              [EventId]         -- Event ID
//              [SizeOfRawData]   -- Size of raw data
//              [RawData]         -- Raw data
//              [NumberOfStrings] -- number of strings
//              ...               -- PUNICODE_STRINGs to string data
//
//  Notes:
//
//----------------------------------------------------------------------------

DWORD
SpmpReportEventU(
    IN WORD EventType,
    IN DWORD EventId,
    IN DWORD Category,
    IN DWORD SizeOfRawData,
    IN PVOID RawData,
    IN DWORD NumberOfStrings,
    ...
    )
{
    va_list arglist;
    ULONG i;
    PUNICODE_STRING Strings[ MAX_EVENT_STRINGS ];
    DWORD rv;

    if (hEventLog == INVALID_HANDLE_VALUE) {

        if ( !SpmpInitializeEvents()) {

            return( -1 );
        }
    }

    //
    // We're not supposed to be logging this, so nuke it
    //

    if (( LoggingLevel & ( 1 << EventType )) == 0 ) {

        return( 0 );
    }

    //
    // Look at the strings, if they were provided
    //

    va_start( arglist, NumberOfStrings );

    if ( NumberOfStrings > MAX_EVENT_STRINGS ) {

        NumberOfStrings = MAX_EVENT_STRINGS;
    }

    for ( i = 0 ; i < NumberOfStrings ; i++ ) {

        Strings[ i ] = va_arg( arglist, PUNICODE_STRING );
    }

    //
    // Report the event to the eventlog service
    //

    rv = ElfReportEventW(
             hEventLog,
             EventType,
             ( USHORT )Category,
             EventId,
             NULL,
             ( USHORT )NumberOfStrings,
             SizeOfRawData,
             Strings,
             RawData,
             0,
             NULL,
             NULL
             );

    if ( !NT_SUCCESS( rv )) {

        DebugLog((DEB_ERROR,  "ReportEvent( %u ) failed - %u\n", EventId, rv ));
        goto Cleanup;
    }

    rv = ERROR_SUCCESS;

Cleanup:

    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\thdpool.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       thdpool.c
//
//  Contents:   Home of the SPM thread pool
//
//  Classes:
//
//  Functions:
//
//  History:    6-08-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>

#define POOL_SEM_LIMIT              0x7FFFFFFF
#define MAX_POOL_THREADS_HARD       256

#define MAX_SUBQUEUE_THREADS        (4 * MAX_POOL_THREADS_HARD)

LSAP_TASK_QUEUE   GlobalQueue;

//
// Local Prototypes:
//

typedef enum _LSAP_TASK_STATUS {
    TaskNotQueued,
    TaskQueued,
    TaskUnknown
} LSAP_TASK_STATUS ;

LSAP_TASK_STATUS 
EnqueueThreadTask(
    PLSAP_TASK_QUEUE  pQueue,
    PLSAP_THREAD_TASK pTask,
    BOOLEAN     fUrgent);

#define LockQueue(q)    EnterCriticalSection(&((q)->Lock))
#define UnlockQueue(q)  LeaveCriticalSection(&((q)->Lock))


//+---------------------------------------------------------------------------
//
//  Function:   InitializeTaskQueue
//
//  Synopsis:   Initialize a Queue Structure
//
//  Arguments:  [pQueue] --
//              [Type]   --
//
//  History:    11-10-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
InitializeTaskQueue(
    PLSAP_TASK_QUEUE      pQueue,
    LSAP_TASK_QUEUE_TYPE  Type
    )
{
    OBJECT_HANDLE_FLAG_INFORMATION FlagInfo ;

    RtlZeroMemory( pQueue, sizeof(LSAP_TASK_QUEUE) );

    InitializeListHead(
        &pQueue->pTasks
        );

    pQueue->Type = Type;

    pQueue->hSemaphore = CreateSemaphore(NULL, 0, POOL_SEM_LIMIT, NULL);

    if (!pQueue->hSemaphore)
    {
        return FALSE;
    }

    if ( FALSE == InitializeCriticalSectionAndSpinCount(
                                &pQueue->Lock,
                                LsaTuningParameters.CritSecSpinCount
                                ))
    {
        NtClose( pQueue->hSemaphore );
        pQueue->hSemaphore = NULL ;
        return FALSE;
    }
    
    FlagInfo.Inherit = FALSE ;
    FlagInfo.ProtectFromClose = TRUE ;

    NtSetInformationObject(
        pQueue->hSemaphore,
        ObjectHandleFlagInformation,
        &FlagInfo,
        sizeof( FlagInfo ) );

    pQueue->StartSync = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( pQueue->StartSync == NULL )
    {
        DebugLog(( DEB_ERROR, "Could not create start sync event\n" ));

        NtClose( pQueue->hSemaphore );
        pQueue->hSemaphore = NULL;

        DeleteCriticalSection( &pQueue->Lock );

        return FALSE ;
    }

    return( TRUE );
}


//+---------------------------------------------------------------------------
//
//  Function:   InitializeThreadPool
//
//  Synopsis:   Initializes necessary data for the thread pool
//
//  Arguments:  (none)
//
//  History:    7-13-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
InitializeThreadPool(void)
{
    if (!InitializeTaskQueue(&GlobalQueue, QueueShared))
    {
        return( FALSE );
    }

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   QueueAssociateThread
//
//  Synopsis:   Associates the thread with the queue
//
//  Arguments:  [pQueue] --
//
//  History:    11-09-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
QueueAssociateThread(
    PLSAP_TASK_QUEUE  pQueue)
{
    PSession    pSession;

    LockQueue( pQueue );

    pQueue->TotalThreads++  ;

    //
    // Update the statistics:
    //

    if ( pQueue->MaxThreads < pQueue->TotalThreads )
    {
        pQueue->MaxThreads = pQueue->TotalThreads ;
    }

    UnlockQueue( pQueue );
}


//+---------------------------------------------------------------------------
//
//  Function:   QueueDisassociateThread
//
//  Synopsis:   Disconnects a thread and a queue
//
//  Arguments:  [pQueue]      --
//              [pLastThread] -- OPTIONAL flag indicating last thread of queue
//
//  History:    11-09-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
QueueDisassociateThread(
    PLSAP_TASK_QUEUE  pQueue,
    BOOLEAN *   pLastThread)
{
    PSession    pSession;

    LockQueue( pQueue );

    DsysAssert(pQueue->TotalThreads > 0);

    if ( pQueue->TotalThreads == 1 )
    {
        if ( pLastThread )
        {
            *pLastThread = TRUE ;

            //
            // If the queue is being run down, set the 
            // event since we are the last thread
            //

            if ( pQueue->Type == QueueZombie )
            {
                SetEvent( pQueue->StartSync );
            }
        }

        if ( pQueue->Tasks )
        {
            //
            // Make sure that we never have more tasks queued
            // to a zombie
            //

            DsysAssert( pQueue->Type != QueueZombie );

            UnlockQueue( pQueue );

            return FALSE ;
        }
    }

    pQueue->TotalThreads--;

    UnlockQueue( pQueue );

    return TRUE ;
}


//+---------------------------------------------------------------------------
//
//  Function:   DequeueAnyTask
//
//  Synopsis:   Returns a task from this queue or any shared, if available
//
//  Arguments:  [pQueue] --
//
//  Requires:   pQueue must be locked!
//
//  History:    11-09-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PLSAP_THREAD_TASK
DequeueAnyTask(
    PLSAP_TASK_QUEUE      pQueue)
{
    PLSAP_THREAD_TASK pTask;
    PLSAP_TASK_QUEUE  pShared;

    if ( !IsListEmpty(&pQueue->pTasks) )
    {
        pTask = (PLSAP_THREAD_TASK) RemoveHeadList(&pQueue->pTasks);

        pQueue->Tasks --;

        pQueue->TaskCounter++;

        //
        // Reset the pointers.  This is required by the recovery logic
        // in the Enqueue function below.
        //

        pTask->Next.Flink = NULL ;
        pTask->Next.Blink = NULL ;

        return( pTask );
    }

    //
    // No pending on primary queue.  Check secondaries:
    //

    if (pQueue->Type == QueueShared)
    {
        pShared = pQueue->pShared;

        while ( pShared )
        {
            PLSAP_TASK_QUEUE  pPrev;
            DWORD WaitStatus;

            //
            // We need to wait now to change the semaphore count
            //

            WaitStatus = WaitForSingleObject(pShared->hSemaphore, 0);

            LockQueue( pShared );

            if ((WaitStatus == WAIT_OBJECT_0) && !IsListEmpty(&pShared->pTasks) )
            {
                pTask = (PLSAP_THREAD_TASK) RemoveHeadList(&pShared->pTasks);

                pShared->Tasks--;

                pShared->TaskCounter++;

                UnlockQueue( pShared );     // Unlock shared queue

                return( pTask );
            }

            pPrev = pShared;

            pShared = pShared->pNext;

            UnlockQueue( pPrev );
        }
    }

    return( NULL );
}


//+---------------------------------------------------------------------------
//
//  Function:   WaitForThreadTask
//
//  Synopsis:   Function called by queue waiters
//
//  Arguments:  [pQueue]  -- Queue to wait on
//              [TimeOut] -- timeout in seconds
//
//  History:    11-10-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PLSAP_THREAD_TASK
WaitForThreadTask(
    PLSAP_TASK_QUEUE      pQueue,
    DWORD           TimeOut)
{
    PLSAP_THREAD_TASK pTask;
    DWORD WaitResult;

    LockQueue( pQueue );

    pTask = DequeueAnyTask( pQueue );

    if (pTask)
    {
        UnlockQueue( pQueue );

        return( pTask );
    }

    //
    // No pending anywhere.
    //

    if (TimeOut == 0)
    {
        UnlockQueue( pQueue );

        return( NULL );
    }

    //
    // Principal of the loop:  We do this loop so long as we were awakened
    // by the semaphore being released.  If there was no task to pick up, then
    // we go back and wait again.  We return NULL only after a timeout, or an
    // error.
    //

    do
    {
        pQueue->IdleThreads++;

        UnlockQueue( pQueue );

        WaitResult = WaitForSingleObject( pQueue->hSemaphore, TimeOut );

        LockQueue( pQueue );

        //
        // In between the wait returning and the lock succeeding, another
        // thread might have queued up a request.

        DsysAssert(pQueue->IdleThreads > 0);
        pQueue->IdleThreads--;

        //
        // In between the wait returning and the lock succeeding, another
        // thread might have queued up a request, so don't blindly 
        // bail out.  Check the pending count, and skip over this
        // exit path if something is there
        //

        if ( pQueue->Tasks == 0 )
        {
            if (WaitResult != WAIT_OBJECT_0)
            {
                UnlockQueue( pQueue );
                if ( WaitResult == WAIT_FAILED )
                {
                    DebugLog((DEB_ERROR, "Error on waiting for semaphore, %d\n", GetLastError()));
                }
                return( NULL );
            }
        }

        //
        // If the queue type is reset to Zombie, then this queue is
        // being killed.  Return NULL immediately.  If we're the last
        // thread, set the event so the thread deleting the queue will
        // wake up in a timely fashion.
        //

        if ( pQueue->Type == QueueZombie )
        {
            UnlockQueue( pQueue );

            return NULL ;
        }

        pTask = DequeueAnyTask( pQueue );

        if (pTask)
        {
            UnlockQueue( pQueue );

            return( pTask );
        }

        //
        // Track number of times we woke up but didn't have anything to do
        //

        pQueue->MissedTasks ++ ;

    } while ( WaitResult != WAIT_TIMEOUT );

    UnlockQueue( pQueue );

    return( NULL );
}


//+---------------------------------------------------------------------------
//
//  Function:   SpmPoolThreadBase
//
//  Synopsis:   New Pool Thread Base
//
//  Arguments:  [pvQueue] -- OPTIONAL queue to use
//
//  History:    11-09-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DWORD
SpmPoolThreadBase(
    PVOID   pvSession)
{
    PLSAP_THREAD_TASK pTask;
    PLSAP_TASK_QUEUE  pQueue;
    PSession    pSession;
    BOOLEAN     ShrinkWS = FALSE;
    DWORD       dwResult;
    DWORD       Timeout;
    PSession    ThreadSession ;
    PSession    OriginalSession ;

    OriginalSession = GetCurrentSession();

    if ( pvSession )
    {
        ThreadSession = (PSession) pvSession ;

        SpmpReferenceSession( ThreadSession );

        SetCurrentSession( ThreadSession );
    }
    else
    {
        ThreadSession = OriginalSession ;

        SpmpReferenceSession( ThreadSession );
    }

    pQueue = ThreadSession->SharedData->pQueue ;

    if (!pQueue)
    {
        pQueue = &GlobalQueue;
    }

    QueueAssociateThread( pQueue );

    //
    // Share pool threads have short lifespans.  Dedicated single, or
    // single read threads have infinite life span.
    //

    if (pQueue->Type == QueueShared)
    {
        Timeout = LsaTuningParameters.ThreadLifespan * 1000;
    }
    else
    {
        //
        // If we are the dedicated thread for this queue, the timeout
        // is infinite.  If we are a temporary thread, the timeout is
        // the subqueue
        //

        if ( ThreadSession->ThreadId != GetCurrentThreadId() )
        {
            Timeout = LsaTuningParameters.SubQueueLifespan ;
        }
        else
        {
            Timeout = INFINITE ;
        }
    }

    if ( pQueue->StartSync )
    {
        DebugLog(( DEB_TRACE, "ThreadPool:  Signaling start event\n" ));
        //
        // If a queue was passed in, the caller of CreateXxxQueue is blocked
        // waiting for us to strobe the start sync event.
        //

        SetEvent( pQueue->StartSync );
    }

    while ( TRUE )
    {
        pTask = WaitForThreadTask( pQueue, Timeout );

        if ( pTask )
        {
            SetCurrentSession( pTask->pSession );

            dwResult = pTask->pFunction(pTask->pvParameter);

#if DBG
            RtlCheckForOrphanedCriticalSections( NtCurrentThread() );
#endif 

            SetCurrentSession( ThreadSession );

            //
            // The session in this task was referenced during the AssignThread call.
            // This dereference cleans that up.
            //

            SpmpDereferenceSession(pTask->pSession);

            LsapFreePrivateHeap( pTask );
        }
        else
        {

            //
            // We can never leave the queue empty of threads if
            // there are still tasks pending.  QueueDisassociateThread
            // will fail if there are tasks pending.  In that case,
            // skip up to the top of the loop again.
            //

            if ( !QueueDisassociateThread( pQueue, &ShrinkWS ) )
            {
                continue;
            }
            
            //
            // Now that we are not part of that queue, reset our thread session
            //

            SpmpDereferenceSession( ThreadSession );

            SetCurrentSession( OriginalSession );

            if ( LsaTuningParameters.Options & TUNE_TRIM_WORKING_SET )
            {
                if (ShrinkWS)
                {
                    SetProcessWorkingSetSize(   GetCurrentProcess(),
                                                (SIZE_T)(-1),
                                                (SIZE_T)(-1) );
                }
            }

            DebugLog(( DEB_TRACE,
                        "No tasks pending on queue %x, thread exiting\n",
                        pQueue ));

            return( 0 );
        }
    }

    return( 0 );
}


//+---------------------------------------------------------------------------
//
//  Function:   EnqueueThreadTask
//
//  Synopsis:   Enqueue a task, update counts, etc.
//
//  Arguments:  [pTask] -- Task to add
//
//  History:    7-13-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

LSAP_TASK_STATUS
EnqueueThreadTask(
    PLSAP_TASK_QUEUE  pQueue,
    PLSAP_THREAD_TASK pTask,
    BOOLEAN     fUrgent)
{
    BOOLEAN NeedMoreThreads = FALSE;
    HANDLE hQueueSem ;
    HANDLE hParentSem = NULL ;
    PLSAP_TASK_QUEUE pThreadQueue = NULL;
    PSession pSession = NULL;

    LockQueue(pQueue);

    if ( pQueue->Type == QueueZombie )
    {
        UnlockQueue( pQueue );

        return TaskNotQueued ;
    }

    if (fUrgent)
    {
        InsertHeadList(
            &pQueue->pTasks,
            &pTask->Next
            );
    }
    else
    {
        InsertTailList(
            &pQueue->pTasks,
            &pTask->Next
            );
    }

    pQueue->Tasks++;
    pQueue->QueuedCounter++;

    if ( pQueue->Tasks > pQueue->TaskHighWater )
    {
        pQueue->TaskHighWater = pQueue->Tasks ;
    }

    if (pQueue->Type == QueueShared)
    {
        if ((pQueue->Tasks > pQueue->IdleThreads) &&
            (pQueue->TotalThreads < MAX_POOL_THREADS_HARD))
        {
            NeedMoreThreads = TRUE;
            pThreadQueue = pQueue;
        }

        hParentSem = NULL ;
    }
    else if (pQueue->Type == QueueShareRead )
    {
        DsysAssert( pQueue->pOriginal );

        //
        // Here's the race potential.  If the queue we have has no idle thread,
        // then make sure there is an idle thread at the parent queue, otherwise
        // we can deadlock (e.g. this call is in response to the job being executed
        // by the dedicated thread.  Of course, this can also be a problem correctly
        // determining the parent queue's status, since locks should always flow down,
        // not up.  So, if the number of jobs that we have pending exceeds the number
        // of idle threads, *always*, regardless of the other queue's real state or
        // total threads, queue up another thread.
        //

        if ( pQueue->Tasks > pQueue->IdleThreads )
        {
            NeedMoreThreads = TRUE ;

            pSession = pTask->pSession ;

            if ( pQueue->TotalThreads < MAX_SUBQUEUE_THREADS )
            {
                pThreadQueue = pQueue ;
            }
            else
            {
                pThreadQueue = pQueue->pOriginal;
            }
        }

        //
        // This is a safe read.  The semaphore is not subject to change after creation,
        // and the worst that can happen is a bad handle.
        //

        hParentSem = pQueue->pOriginal->hSemaphore ;
    }

    hQueueSem = pQueue->hSemaphore ;

    UnlockQueue( pQueue );

    //
    // Kick our semaphore.
    //

    ReleaseSemaphore( hQueueSem, 1, NULL );

    //
    // Kick the parent semaphore
    //

    if ( hParentSem )
    {
        ReleaseSemaphore( hParentSem, 1, NULL );
    }

    if (NeedMoreThreads)
    {
        HANDLE hThread;
        DWORD tid;

        DebugLog((DEB_TRACE_QUEUE, "Queue %x needs more threads\n", pQueue));

        //
        // Increment the number of threads now so we don't create more threads
        // while we wait for the first one to be created.
        //

        InterlockedIncrement( &pThreadQueue->ReqThread );

        //
        // If the queue is a dedicated queue, supply the session from the task.
        // if the queue is a shared (global) queue, pass in NULL:
        //

        hThread = LsapCreateThread(  NULL, 0,
                                    SpmPoolThreadBase,

                                    (pThreadQueue->Type == QueueShareRead ?
                                        pThreadQueue->OwnerSession : NULL ),

                                    0, &tid);

        //
        // Check for failure
        //

        if (hThread == NULL)
        {
            //
            // This is extremely painful.  The thread creation attempt
            // failed, but because of the nature of the queue, we don't
            // know if it was picked up and executed, or it was dropped,
            // or anything about it.
            //

            return TaskUnknown ;
        }
        else
        {
            NtClose(hThread);
        }
    }

    return TaskQueued ;
}


//+---------------------------------------------------------------------------
//
//  Function:   SpmAssignThread
//
//  Synopsis:   Assigns a task to a thread pool thread.
//
//  Arguments:  [pFunction]   -- Function to execute
//              [pvParameter] -- Parameter to function
//              [pSession]    -- Session to execute as
//
//  History:    11-24-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PVOID
LsapAssignThread(
    LPTHREAD_START_ROUTINE pFunction,
    PVOID                   pvParameter,
    PSession                pSession,
    BOOLEAN                 fUrgent)
{
    PLSAP_THREAD_TASK pTask;
    PLSAP_TASK_QUEUE  pQueue;
    LSAP_TASK_STATUS TaskStatus ;

    pTask = (PLSAP_THREAD_TASK) LsapAllocatePrivateHeap( sizeof( LSAP_THREAD_TASK ) );

    if (!pTask)
    {
        return( NULL );
    }

    pTask->pFunction = pFunction;
    pTask->pvParameter = pvParameter;
    pTask->pSession = pSession;

    if ( pSession->SharedData->pQueue )
    {
        LockSession(pSession);
        if( pSession->SharedData->pQueue )
        {
            pQueue = pSession->SharedData->pQueue;
        } else
        {
            pQueue = &GlobalQueue;
        }
        UnlockSession(pSession);
    }
    else
    {
        pQueue = &GlobalQueue;
    }

    //
    // Reference the session so that it will never go away while a thread
    // is working on this task.  The worker function will deref the session.
    //

    SpmpReferenceSession( pSession );

    TaskStatus = EnqueueThreadTask( pQueue,
                                    pTask,
                                    fUrgent );

    if ( ( TaskStatus == TaskQueued ) ||
         ( TaskStatus == TaskUnknown ) )
    {
        return pTask ;
    }

    if ( TaskStatus == TaskNotQueued )
    {
        //
        // Failed, therefore deref this session.
        //
        SpmpDereferenceSession( pSession );
        LsapFreePrivateHeap( pTask );
    }

    return NULL ;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateSubordinateQueue
//
//  Synopsis:   Create a Queue hanging off an original queue.
//
//  Arguments:  [pQueue]         --
//              [pOriginalQueue] --
//
//  History:    11-17-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CreateSubordinateQueue(
    PSession          pSession,
    PLSAP_TASK_QUEUE  pOriginalQueue
    )
{
    HANDLE  hThread;
    DWORD   tid;
    PLSAP_TASK_QUEUE pQueue ;

    pQueue = (LSAP_TASK_QUEUE *) LsapAllocatePrivateHeap( sizeof( LSAP_TASK_QUEUE ) );

    if ( !pQueue )
    {
        return FALSE ;
    }

    DebugLog(( DEB_TRACE_QUEUE, "Creating sub queue %x\n", pQueue ));

    if (InitializeTaskQueue( pQueue, QueueShareRead ))
    {
        hThread = LsapCreateThread(NULL,
                                   0,
                                   SpmPoolThreadBase,
                                   pSession,
                                   CREATE_SUSPENDED,
                                   &pSession->ThreadId);

        if (hThread == NULL)
        {
            NtClose( pQueue->StartSync );
            NtClose( pQueue->hSemaphore );
            RtlDeleteCriticalSection( &pQueue->Lock );
            LsapFreePrivateHeap( pQueue );
            pQueue = NULL;

            return FALSE;
        }
        else
        {
            LockQueue( pQueue );
            LockQueue( pOriginalQueue );

            pQueue->pNext = pOriginalQueue->pShared;

            pOriginalQueue->pShared = pQueue;

            pQueue->pOriginal = pOriginalQueue;
            pQueue->OwnerSession = pSession ;

            UnlockQueue( pOriginalQueue );
            UnlockQueue( pQueue );

            pSession->SharedData->pQueue = pQueue ;

            ResumeThread( hThread );
            NtClose( hThread );

            //
            // Wait for the thread to signal the event, so that
            // we know it's ready
            //

            WaitForSingleObject( pQueue->StartSync, INFINITE );

            NtClose( pQueue->StartSync );
            pQueue->StartSync = NULL ;

            return TRUE;
        }
    }

    LsapFreePrivateHeap( pQueue );
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteSubordinateQueue
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pQueue] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-05-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
DeleteSubordinateQueue(
    PLSAP_TASK_QUEUE  pQueue,
    ULONG Flags)
{
    PLSAP_TASK_QUEUE  pOriginal;
    PLSAP_THREAD_TASK pTask ;
    DWORD dwResult ;
    PLIST_ENTRY List ;
    PSession ThreadSession = GetCurrentSession();
    OBJECT_HANDLE_FLAG_INFORMATION FlagInfo ;

    //
    // Lock it
    //

    DebugLog(( DEB_TRACE, "Deleting queue %x\n", pQueue ));

    LockQueue( pQueue );

    if ( pQueue->pShared )
    {
        pOriginal = pQueue->pOriginal ;

        LockQueue( pOriginal );

        //
        // Unlink Queue from parent:
        //

        if ( pOriginal->pShared != pQueue )
        {
            PLSAP_TASK_QUEUE  pScan = pOriginal->pShared;

            LockQueue( pScan );

            while ( pScan->pNext && (pScan->pNext != pQueue) )
            {
                pScan = pScan->pNext;
            }

            if ( pScan->pNext )
            {
                pScan->pNext = pQueue->pNext ;
            }

            UnlockQueue( pScan );
        }
        else
        {
            pOriginal->pShared = pQueue->pNext;
        }

        pQueue->pNext = NULL ;

        //
        // Done with parent
        //

        UnlockQueue( pOriginal );

    }

    //
    // Drain queue by removing all the tasks.
    //

    while ( !IsListEmpty( &pQueue->pTasks ) )
    {
        List = RemoveHeadList( &pQueue->pTasks );

        pQueue->Tasks-- ;

        pTask = CONTAINING_RECORD( List, LSAP_THREAD_TASK, Next );

        //
        // A synchronous drain will have this thread execute
        // all remaining tasks.
        //

        if ( Flags & DELETEQ_SYNC_DRAIN )
        {
            SpmpReferenceSession(pTask->pSession);

            SetCurrentSession( pTask->pSession );

            dwResult = pTask->pFunction(pTask->pvParameter);

            SetCurrentSession( ThreadSession );

            SpmpDereferenceSession(pTask->pSession);

            LsapFreePrivateHeap( pTask );
        }
        else 
        {
            //
            // Otherwise, send them to the global queue to be 
            // executed by other threads
            //

            EnqueueThreadTask(
                &GlobalQueue,
                pTask,
                FALSE );
        }
    }

    //
    // Now, kill off all the threads
    //

    pQueue->Type = QueueZombie ;

    //
    // We might be executing on our own worker thread.  If there are
    // more than one thread associated with this queue, we also
    // need to do the sync.
    //

    if ( ( pQueue->OwnerSession != ThreadSession ) ||
         ( pQueue->TotalThreads > 1 ) )
         
    {
        //
        // We are not a worker thread.  Sync with the other
        // threads to clean up:
        //

        pQueue->StartSync = CreateEvent( NULL, FALSE, FALSE, NULL );

        //
        // Kick the semaphore for all the threads that need it 
        // (all of them if we aren't a worker thread, or n-1 if
        // we are:
        //

        ReleaseSemaphore( 
                pQueue->hSemaphore, 
                (pQueue->OwnerSession == ThreadSession ? 
                        pQueue->TotalThreads - 1 :
                        pQueue->TotalThreads), 
                NULL );

        UnlockQueue( pQueue );

        //
        // if we failed to create an event, then we may cause an invalid handle
        // problem in the client threads.  Sleep a little to let the other threads
        // go (hopefully), then close the semaphore and let the error handling
        // in the threads deal with it.
        //

        if ( pQueue->StartSync )
        {
            WaitForSingleObjectEx( pQueue->StartSync, INFINITE, FALSE );

            //
            // Synchronize with the last thread to own the queue:
            //

            LockQueue( pQueue );

            NtClose( pQueue->StartSync );
            pQueue->StartSync = NULL ;
        }
        else
        {
            //
            // kludge up a retry loop:
            //
            int i = 50 ;

            while ( i && pQueue->TotalThreads )
            {
                Sleep( 100 );
                i-- ;
            }

            //
            // If they're still there, forget it.  Return FALSE.  Leak.
            //
            if ( pQueue->TotalThreads )
            {
                return FALSE ;
            }
        }
    }

    //
    // At this point, we close the queue down:
    //

    FlagInfo.Inherit = FALSE ;
    FlagInfo.ProtectFromClose = FALSE ;

    NtSetInformationObject(
            pQueue->hSemaphore,
            ObjectHandleFlagInformation,
            &FlagInfo,
            sizeof( FlagInfo ) );

    NtClose( pQueue->hSemaphore );

    UnlockQueue( pQueue );

    RtlDeleteCriticalSection( &pQueue->Lock );

    LsapFreePrivateHeap( pQueue );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtgenp.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T G E N P . C
//
// Contents:    definitions of types/functions required for 
//              generating generic audits.
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------


#include <lsapch2.h>
#pragma hdrstop

#include "adtp.h"
#include "adtgen.h"
#include "adtgenp.h"

// temp - gregjohn 5/17/02 - to be removed as soon as base changes to msaudite.h migrate to lab03
#ifndef SE_AUDITID_REPLICA_LINGERING_OBJECT_REMOVAL
#define SE_AUDITID_REPLICA_LINGERING_OBJECT_REMOVAL ((ULONG)0x00000349L)
#endif

// ----------------------------------------------------------------------
//
// globals
//

//
// critsec that guards access to 
// LsapAdtContextList and LsapAdtContextListCount
//

RTL_CRITICAL_SECTION LsapAdtContextListLock;

//
// linked list of audit contexts. see comment in fn LsapAdtAddAuditContext
//

LIST_ENTRY LsapAdtContextList;

//
// number of elements in the context list
//

ULONG LsapAdtContextListCount=0;


// ----------------------------------------------------------------------
//
// helper macros
//

#define LockAuditContextList()   RtlEnterCriticalSection(&LsapAdtContextListLock)


#define UnLockAuditContextList() RtlLeaveCriticalSection(&LsapAdtContextListLock)


//
// convert a context handle to a context pointer
//

#define AdtpContextPtrFromHandle(h) ((AUDIT_CONTEXT*) (h))
#define AdtpContextHandleFromptr(p) ((AUDIT_HANDLE) (p))


// ----------------------------------------------------------------------
//
// internal routines
//

NTSTATUS
LsapAdtIsValidAuditInfo(
    IN PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType
    );

NTSTATUS
LsapAdtIsValidAuditContext(
    IN AUDIT_HANDLE hAudit
    );

NTSTATUS
LsapAdtIsContextInList(
    IN AUDIT_HANDLE hAudit
    );

NTSTATUS
LsapGetAuditEventParams(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT PAUDIT_CONTEXT pAuditContext
    );

NTSTATUS
LsapAdtAddAuditContext(
    IN AUDIT_HANDLE hAudit
    );

NTSTATUS 
LsapAdtDeleteAuditContext(
    IN AUDIT_HANDLE hAudit
    );

NTSTATUS
LsapAdtFreeAuditContext(
    AUDIT_HANDLE hAudit
    );

BOOLEAN
LsapAdtIsValidAuthzAuditId(
    IN USHORT AuditId
    );

// ----------------------------------------------------------------------


NTSTATUS
LsapAdtInitGenericAudits( VOID )
/*++

Routine Description:

    Initialize the generic audit functionality.
    

Arguments:
    None

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    InitializeListHead( &LsapAdtContextList );
    LsapAdtContextListCount = 0;
    
    Status = RtlInitializeCriticalSection(&LsapAdtContextListLock);

    return Status;
}


NTSTATUS
LsapRegisterAuditEvent(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT AUDIT_HANDLE* phAudit
    )
/*++

Routine Description:
    Register the specified event;
    generate and return an audit context. 
    

Arguments:

    pAuditEventType - pointer to audit event info. This param describes
                      the type of event to be registered.

    phAudit         - pointer to audit context returned
                      this handle must be freed by calling
                      LsaUnregisterAuditEvent when no longer needed.

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:
    Note that this function does NOT register the schema of an event. It is
    assumed that the schema has been registered *before* calling
    this function.

    The generated context is stored in LsapAdtContextList.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAUDIT_CONTEXT pAuditContext=NULL;
    UINT RpcTransportType;
    RPC_STATUS RpcStatus;
    
    *phAudit = NULL;

    //
    // find out the transport over which we are receiving this call
    //

    RpcStatus = I_RpcBindingInqTransportType ( NULL, &RpcTransportType );

    if ( RpcStatus != RPC_S_OK )
    {
        Status = I_RpcMapWin32Status( RpcStatus );
        goto Cleanup;
    }

    //
    // if the transport is anything other than LPC, error out
    // we want to support only LPC for audit calls
    //

    if ( RpcTransportType != TRANSPORT_TYPE_LPC )
    {
        Status = RPC_NT_PROTSEQ_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // do a sanity check on the audit-info supplied
    //

    Status = LsapAdtIsValidAuditInfo( pAuditEventType );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    //
    // make sure that the caller has audit privilege
    // (LsapAdtCheckAuditPrivilege calls RpcImpersonateClient)
    //
#ifndef SE_ADT_NO_AUDIT_PRIVILEGE_CHECK
    Status = LsapAdtCheckAuditPrivilege();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
#endif
    
    pAuditContext =
      (PAUDIT_CONTEXT) LsapAllocateLsaHeap( sizeof(AUDIT_CONTEXT) );

    if (pAuditContext)
    {
        //
        // store the parameters for this audit into the
        // generated context.
        //

        Status = LsapGetAuditEventParams(pAuditEventType, pAuditContext);

        if (NT_SUCCESS(Status))
        {
            //
            // add to context list
            //

            Status = LsapAdtAddAuditContext(
                AdtpContextHandleFromptr( pAuditContext ) );

            if (NT_SUCCESS(Status))
            {
                *phAudit = AdtpContextHandleFromptr( pAuditContext );
            }
        }
    }
    else
    {
        Status = STATUS_NO_MEMORY;
    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        LsapFreeLsaHeap(pAuditContext);
    }
    
    return Status;
}


NTSTATUS
LsapGenAuditEvent(
    IN AUDIT_HANDLE  hAudit,
    IN DWORD         dwFlags,
    IN PAUDIT_PARAMS pAuditParams,
    IN PVOID         pReserved
    )
/*++

Routine Description:
    Publish the specified audit event.
    

Arguments:

    hAudit        - handle of audit-context previously obtained
                    by calling LsaRegisterAuditEvent

    dwFlags       - TBD

    pAuditParams  - pointer to event parameters. This structure should
                    be initialized using AuthzInitAuditParams.
                    Please see detailed comment on that function
                    in adtutil.c on usage of this parameter.

    pReserved     - reserved

Return Value:

    STATUS_SUCCESS           -- on success
    STATUS_INVALID_PARAMETER -- if one or more params are invalid
    STATUS_AUDITING_DISABLED -- if the event being generated is not
                                being audited because the policy setting
                                is disabled.

Notes:

--*/
{
    NTSTATUS         Status = STATUS_SUCCESS;
    PAUDIT_CONTEXT  pAuditContext;
    SE_ADT_PARAMETER_ARRAY SeAuditParameters = { 0 };
    UNICODE_STRING  Strings[SE_MAX_AUDIT_PARAM_STRINGS] = { 0 };
    BOOLEAN bAudit;
    SE_ADT_OBJECT_TYPE ObjectTypes[MAX_OBJECT_TYPES];
    PSE_ADT_OBJECT_TYPE pObjectTypes = ObjectTypes;
    UINT AuditEventType;
    
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(pReserved);

    DsysAssertMsg( pAuditParams != NULL, "LsapGenAuditEvent" );

    //
    // make sure that the context is in our list
    //

    Status = LsapAdtIsContextInList( hAudit );
    
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // verify that the context is not invalid
    //

    Status = LsapAdtIsValidAuditContext( hAudit );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    pAuditContext = AdtpContextPtrFromHandle( hAudit );

    //
    // return error if the context and the passed parameters
    // do not agree on the number of parameters
    //

    if ( pAuditContext->ParameterCount != pAuditParams->Count )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( pAuditParams->Flags & APF_AuditSuccess )
    {
        AuditEventType = EVENTLOG_AUDIT_SUCCESS;
    }
    else
    {
        AuditEventType = EVENTLOG_AUDIT_FAILURE;
    }

    //
    // check if auditing is enabled for that category
    //

    Status = LsapAdtAuditingEnabledBySid(
                 LsapAdtEventTypeFromCategoryId(pAuditContext->CategoryId),
                 (PSID)pAuditParams->Parameters[0].Data0,
                 AuditEventType,
                 &bAudit
                 );

    if (NT_SUCCESS(Status) && bAudit)
    {
        SeAuditParameters.Type           = (USHORT) AuditEventType;
        SeAuditParameters.CategoryId     = pAuditContext->CategoryId;
        SeAuditParameters.AuditId        = pAuditContext->AuditId;
        SeAuditParameters.ParameterCount = pAuditParams->Count;

        //
        // Map AUDIT_PARAMS structure to SE_ADT_PARAMETER_ARRAY structure
        //

        Status = LsapAdtMapAuditParams( pAuditParams,
                                        &SeAuditParameters,
                                        (PUNICODE_STRING) Strings,
                                        &pObjectTypes );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // write the params to eventlog
        //
        
        Status = LsapAdtWriteLog( &SeAuditParameters );
    }

    
Cleanup:

    if (!NT_SUCCESS(Status))
    {
        //
        // crash on failure if specified by the security policy
        //
        // But do not crash on documented errors
        //

        if ( ( Status != STATUS_INVALID_PARAMETER ) &&
             ( Status != STATUS_AUDITING_DISABLED ) &&
             ( Status != STATUS_NOT_FOUND ) )
        {
            LsapAuditFailed( Status );
        }
    }

    //
    // to save the cost of heap alloc/dealloc each time for
    // the object types. we use a fixed array of size MAX_OBJECT_TYPES
    // If this size is not enough, LsapAdtMapAuditParams will allocate
    // a bigger array, in this case the following condition
    // becomes true and we free the allocated array.
    //

    if ( pObjectTypes && ( pObjectTypes != ObjectTypes ))
    {
        LsapFreeLsaHeap( pObjectTypes );
    }

    return Status;
}


NTSTATUS
LsapUnregisterAuditEvent(
    IN OUT AUDIT_HANDLE* phAudit
    )
/*++

Routine Description:

    Unregister the specified context and free up any resources.

Arguments:

    hAudit - handle of audit context to unregister
             This is set to NULL when the call returns.

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    //
    // remove it from the list and free up resources
    //

    if ( phAudit )
    {
        Status = LsapAdtDeleteAuditContext( *phAudit );

        *phAudit = NULL;
    }
    
    return Status;
}


NTSTATUS
LsapGetAuditEventParams(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT PAUDIT_CONTEXT pAuditContext
    )
/*++

Routine Description:

    Initialize the audit context using information in the
    passed pAuditEventType

Arguments:

    pAuditEventType - pointer to audit event info

    pAuditContext   - pointer to audit context to be initialzed

Return Value:

    STATUS_SUCCESS            if params are ok
    STATUS_INVALID_PARAMETER  otherwise

Notes:

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    USHORT CategoryId;
    USHORT AuditId;
    USHORT ParameterCount;
    ULONG  ProcessId = 0xffffffff;
    LUID   LinkId;
    RPC_STATUS RpcStatus;
    UINT ClientIsLocal = 0;
    
    DsysAssertMsg( pAuditContext != NULL, "LsapGetAuditEventParams" );
    
    if (pAuditEventType &&
        (pAuditEventType->Version == AUDIT_TYPE_LEGACY))
    {
        CategoryId     = pAuditEventType->u.Legacy.CategoryId;
        AuditId        = pAuditEventType->u.Legacy.AuditId;
        ParameterCount = pAuditEventType->u.Legacy.ParameterCount;
        LinkId         = pAuditEventType->LinkId;

        RpcStatus = I_RpcBindingIsClientLocal( 0, &ClientIsLocal );

        if ( ( RpcStatus == RPC_S_OK ) && ClientIsLocal )
        {
            RpcStatus = I_RpcBindingInqLocalClientPID( NULL, &ProcessId );

#if DBG
            if ( RpcStatus != RPC_S_OK )
            {
                DbgPrint("LsapGetAuditEventParams: I_RpcBindingInqLocalClientPID: %lx\n", RpcStatus);
            }
#endif
        
            //
            // for now, do not let events to be published under other categories
            //

            Status = STATUS_SUCCESS;
        
            //
            // currently we support only the legacy audits
            //

            pAuditContext->Flags          = ACF_LegacyAudit;
            pAuditContext->CategoryId     = CategoryId;
            pAuditContext->AuditId        = AuditId;
            pAuditContext->ParameterCount = ParameterCount;
            pAuditContext->LinkId         = LinkId;
            pAuditContext->ProcessId      = ProcessId;
        }
        else
        {
            Status = STATUS_INVALID_PARAMETER;
        }
    }
    
    return Status;
}
    


NTSTATUS 
LsapAdtIsContextInList(
    IN AUDIT_HANDLE hAudit
    )
/*++

Routine Description:

    Lookup the specified context in our list

Arguments:

    hAudit - handle of audit context to lookup

Return Value:

    NTSTATUS - Standard Nt Result Code

    STATUS_SUCCESS   if found
    STATUS_NOT_FOUND if not found

Notes:

--*/
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    PAUDIT_CONTEXT pAuditContext, pContext;
    PLIST_ENTRY    Scan;
#if DBG
    LONG ContextCount = (LONG) LsapAdtContextListCount;
#endif
    
    pAuditContext = AdtpContextPtrFromHandle( hAudit );

    Status = LockAuditContextList();

    if (NT_SUCCESS(Status))
    {
        Scan = LsapAdtContextList.Flink;

        while ( Scan != &LsapAdtContextList )
        {
#if DBG
            //
            // make sure that the ContextCount does not become <= 0
            // before the list runs out.
            //

            DsysAssertMsg( ContextCount > 0, "LsapAdtIsContextInList: list may be corrupt!" );
            ContextCount--;
#endif
            
            pContext = CONTAINING_RECORD( Scan, AUDIT_CONTEXT, Link );

            if ( pAuditContext == pContext )
            {
                Status = STATUS_SUCCESS;
                break;
            }
            Scan = Scan->Flink;
        }
#if DBG
        //
        // if we didnt find the item then we must have traversed
        // the whole list. in this case, make sure that the
        // LsapAdtContextListCount is in sync with the list
        //

        if ( Status == STATUS_NOT_FOUND )
        {
            DsysAssertMsg( ContextCount == 0, "LsapAdtIsContextInList: list may be corrupt!" );
        }
#endif
        UnLockAuditContextList();
    }
    
    return Status;
}


NTSTATUS 
LsapAdtAddAuditContext(
    IN AUDIT_HANDLE hAudit
    )
/*++

Routine Description:

    Insert the specified context in our list

Arguments:

    hAudit - handle of audit context to insert

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:
    
    Currently we store the audit contexts in a linked list.
    This is ok since we do not expect more than 5 to 10 contexts
    in the list. Later on when the generic audit interface is
    to be published, we can change this to a more efficient storage.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAUDIT_CONTEXT pAuditContext;

    DsysAssertMsg( LsapAdtIsValidAuditContext( hAudit ) == STATUS_SUCCESS,
                   "LsapAdtAddAuditContext" );

    pAuditContext = AdtpContextPtrFromHandle( hAudit );

    Status = LockAuditContextList();
    if (NT_SUCCESS(Status))
    {
        LsapAdtContextListCount++;
        InsertTailList(&LsapAdtContextList, &pAuditContext->Link);

        UnLockAuditContextList();
    }
    
    return Status;
}


NTSTATUS 
LsapAdtDeleteAuditContext(
    IN AUDIT_HANDLE hAudit
    )
/*++

Routine Description:

    Remove a context from our list and free resources.

Arguments:

    hAudit - handle of audit context to remove

Return Value:

    NTSTATUS - Standard Nt Result Code

    STATUS_SUCCESS   on success
    STATUS_NOT_FOUND if context is not found

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAUDIT_CONTEXT pAuditContext;

    DsysAssertMsg( LsapAdtIsValidAuditContext( hAudit ) == STATUS_SUCCESS,
                   "LsapAdtDeleteAuditContext" );

    Status = LockAuditContextList();

    if (NT_SUCCESS(Status))
    {
        Status = LsapAdtIsContextInList( hAudit );

        DsysAssertMsg( Status != STATUS_NOT_FOUND,
                       "LsapAdtDeleteAuditContext: trying to del unknown context" );

        if (NT_SUCCESS(Status))
        {
            pAuditContext = AdtpContextPtrFromHandle( hAudit );

            RemoveEntryList( &pAuditContext->Link );
            LsapAdtContextListCount--;

            DsysAssertMsg(((LONG) LsapAdtContextListCount) >= 0,
                          "LsapAdtContextListCount should never be negative!");
        }

        UnLockAuditContextList();

        (VOID) LsapAdtFreeAuditContext( hAudit );
    }


    return Status;
}


NTSTATUS
LsapAdtIsValidAuditInfo(
    IN PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType
    )
/*++

Routine Description:

    Verify AUTHZ_AUDIT_EVENT_INFO structure members

Arguments:

    pAuditEventType - pointer to AUTHZ_AUDIT_EVENT_TYPE_OLD

Return Value:

    STATUS_SUCCESS           if info is within acceptable values
    STATUS_INVALID_PARAMETER if not

Notes:

    Currently the validity of the parameters is judged using
    the boundaries defined in msaudite.mc file.

    This function will need to be amended when we allow third party
    apps to supply audit events.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if ( ( pAuditEventType->Version == AUDIT_TYPE_LEGACY )                  &&
         IsValidCategoryId( pAuditEventType->u.Legacy.CategoryId )          &&
         IsValidAuditId( pAuditEventType->u.Legacy.AuditId )                &&
         LsapAdtIsValidAuthzAuditId( pAuditEventType->u.Legacy.AuditId )    &&
         IsValidParameterCount( pAuditEventType->u.Legacy.ParameterCount ) )
    {
        Status = STATUS_SUCCESS;
    }
    
    return Status;
}


BOOLEAN
LsapAdtIsValidAuthzAuditId(
    IN USHORT AuditId
    )

/**

Routine Description
    This examines the audit id and determines if authz should be generating this type
    of audit.

Arguments
    AuditId - the audit to query.

Return Value
    Boolean.
    
**/

{
    static ULONG ValidAuthzAuditIdArray[] = {

        //
        // generated by all users of AuthzAccessCheck
        //
        SE_AUDITID_OBJECT_OPERATION,

        //
        // Generic audit
        //
        SE_AUDITID_GENERIC_AUDIT_EVENT,

        //
        // generated by cert server
        //
        SE_AUDITID_CERTSRV_DENYREQUEST,
        SE_AUDITID_CERTSRV_RESUBMITREQUEST,
        SE_AUDITID_CERTSRV_REVOKECERT,
        SE_AUDITID_CERTSRV_PUBLISHCRL,         
        SE_AUDITID_CERTSRV_AUTOPUBLISHCRL,     
        SE_AUDITID_CERTSRV_SETEXTENSION,       
        SE_AUDITID_CERTSRV_SETATTRIBUTES,      
        SE_AUDITID_CERTSRV_SHUTDOWN,           
        SE_AUDITID_CERTSRV_BACKUPSTART,        
        SE_AUDITID_CERTSRV_BACKUPEND,          
        SE_AUDITID_CERTSRV_RESTORESTART,       
        SE_AUDITID_CERTSRV_RESTOREEND,         
        SE_AUDITID_CERTSRV_SERVICESTART,       
        SE_AUDITID_CERTSRV_SERVICESTOP,        
        SE_AUDITID_CERTSRV_SETSECURITY,        
        SE_AUDITID_CERTSRV_GETARCHIVEDKEY,     
        SE_AUDITID_CERTSRV_IMPORTCERT,         
        SE_AUDITID_CERTSRV_SETAUDITFILTER,     
        SE_AUDITID_CERTSRV_NEWREQUEST,         
        SE_AUDITID_CERTSRV_REQUESTAPPROVED,    
        SE_AUDITID_CERTSRV_REQUESTDENIED,      
        SE_AUDITID_CERTSRV_REQUESTPENDING,     
        SE_AUDITID_CERTSRV_SETOFFICERRIGHTS,   
        SE_AUDITID_CERTSRV_SETCONFIGENTRY,     
        SE_AUDITID_CERTSRV_SETCAPROPERTY,      
        SE_AUDITID_CERTSRV_KEYARCHIVED,        
        SE_AUDITID_CERTSRV_IMPORTKEY,          
        SE_AUDITID_CERTSRV_PUBLISHCACERT,
        SE_AUDITID_CERTSRV_DELETEROW,
        SE_AUDITID_CERTSRV_ROLESEPARATIONSTATE,

        //
        // generated by termsrv
        //
        SE_AUDITID_SESSION_RECONNECTED,
        SE_AUDITID_SESSION_DISCONNECTED,

        //
        // generated by winlogon
        //
        SE_AUDITID_BEGIN_LOGOFF,

        //
        // generated by scm
        //
        SE_AUDITID_SERVICE_INSTALL,

        // 
        // generated by AzManager
        //
        SE_AUDITID_AZ_APPLICATION_INITIALIZATION,
        SE_AUDITID_AZ_CLIENTCONTEXT_CREATION,
        SE_AUDITID_AZ_CLIENTCONTEXT_DELETION,
        SE_AUDITID_AZ_ACCESSCHECK,

        //
        // generated by task scheduler
        //
        SE_AUDITID_JOB_CREATED,

	//
	// generated by AD replication
	//
	SE_AUDITID_REPLICA_DEST_NC_MODIFIED,
	SE_AUDITID_REPLICA_OBJ_ATTR_REPLICATION,
	SE_AUDITID_REPLICA_SOURCE_NC_ESTABLISHED,
	SE_AUDITID_REPLICA_SOURCE_NC_MODIFIED,
	SE_AUDITID_REPLICA_SOURCE_NC_REMOVED,
	SE_AUDITID_REPLICA_SOURCE_NC_SYNC_BEGINS,
	SE_AUDITID_REPLICA_SOURCE_NC_SYNC_ENDS,
	SE_AUDITID_REPLICA_FAILURE_EVENT_BEGIN,
	SE_AUDITID_REPLICA_FAILURE_EVENT_END,
	SE_AUDITID_REPLICA_LINGERING_OBJECT_REMOVAL

    };

    ULONG ValidAuditIdCount = sizeof(ValidAuthzAuditIdArray) / sizeof(ULONG);
    ULONG i;

    //
    // This is a hack: we know that TS generates a shutdown audit when they
    // shouldn't.  However, we don't want to assert since they are not fixing
    // their code until LongHorn.
    //

    if (AuditId == SE_AUDITID_SYSTEM_SHUTDOWN)
    {
        return FALSE;
    }

    for (i = 0; i < ValidAuditIdCount; i++) 
    {
        if (ValidAuthzAuditIdArray[i] == AuditId)
        {
            return TRUE;
        }
    }

    ASSERT(L"Authz has attempted to generate a disallowed audit." && FALSE);
    return FALSE;
}


NTSTATUS 
LsapAdtIsValidAuditContext(
    IN AUDIT_HANDLE hAudit
    )
/*++

Routine Description:

    Verify that the specified context has valid info

Arguments:

    hAudit - handle of context to verify

Return Value:

    STATUS_SUCCESS           if info is within acceptable values
    STATUS_INVALID_PARAMETER if not

Notes:

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PAUDIT_CONTEXT pAuditContext;

    pAuditContext = AdtpContextPtrFromHandle( hAudit );
    
    if ( pAuditContext                                          &&
         ( pAuditContext->Flags & ACF_LegacyAudit )             &&
        !( pAuditContext->Flags & ~ACF_ValidFlags )             &&
         IsValidCategoryId( pAuditContext->CategoryId )         &&
         IsValidAuditId( pAuditContext->AuditId )               &&
         IsValidParameterCount( pAuditContext->ParameterCount ) )
    {
        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
LsapAdtMapAuditParams(
    IN  PAUDIT_PARAMS pAuditParams,
    OUT PSE_ADT_PARAMETER_ARRAY pSeAuditParameters,
    OUT PUNICODE_STRING pString,
    OUT PSE_ADT_OBJECT_TYPE* ppObjectTypeList
    )
/*++

Routine Description:

    Map AUDIT_PARAMS structure to SE_ADT_PARAMETER_ARRAY structure.

Arguments:

    pAuditParams       - pointer to input audit params

    pSeAuditParameters - pointer to output audit params to be initialized.
                         The max allowed size of Parameters member of
                         this structure is determined by the value of
                         SE_MAX_AUDIT_PARAMETERS.
                         Caller needs to allocate memory for this param.
                         
    pString            - pointer to temp strings used in the mapping.
                         The max size of this structure is limited by
                         value of SE_MAX_AUDIT_PARAM_STRINGS.
                         Caller needs to allocate memory for this param.

    ppObjectTypeList   - pointer to object type list.
                         This function assumes that the size of this param
                         is MAX_OBJECT_TYPES upon entry. If more object types
                         are to be mapped, this function will alloc memory
                         using LsapAllocateLsaHeap. When this function
                         returns, the caller needs to check if the value of
                         this param is different from that when called.
                         If so, it should free this using LsapFreeLsaHeap.
                         

Return Value:

    STATUS_SUCCESS            on success
    STATUS_INVALID_PARAMETER  if one or more params are invalid
    STATUS_BUFFER_OVERFLOW    if the number of strings generated exceeds
                              SE_MAX_AUDIT_PARAM_STRINGS
    STATUS_NO_MEMORY          if out of memory

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UINT i=0;
    USHORT j=0;
    AUDIT_PARAM* pInParam;
    SE_ADT_PARAMETER_ARRAY_ENTRY* pOutParam;
    USHORT IndexMap[SE_MAX_AUDIT_PARAMETERS];
    USHORT ObjectTypeIndex;
    LUID LogonId;
    FILETIME FileTime;
    ULONGLONG Qword;
    AUDIT_OBJECT_TYPES* pInObjectTypes;
    USHORT NumObjectTypes;
    USHORT NumStringsUsed=0;
    BOOL fObjectTypeListAllocated=FALSE;
    
    DsysAssertMsg(!(pAuditParams->Flags & (~APF_ValidFlags)),
                  "LsapAdtMapAuditParams");
    DsysAssertMsg(pAuditParams->Count <= SE_MAX_AUDIT_PARAMETERS,
                  "LsapAdtMapAuditParams");
    DsysAssertMsg(pAuditParams->Parameters != NULL, "LsapAdtMapAuditParams");
    DsysAssertMsg(pString != NULL, "LsapAdtMapAuditParams");
    DsysAssertMsg(ppObjectTypeList != NULL, "LsapAdtMapAuditParams");

    pInParam  = pAuditParams->Parameters;
    pOutParam = pSeAuditParameters->Parameters;


    for (i=0; i < pAuditParams->Count; i++, j++, pInParam++, pOutParam++ )
    {
        //
        // the index-map maps input parameters to the corresponding
        // output parameters. currently there is only 1-1 mapping
        // thus (i == j) is always true.
        //
        
        IndexMap[i] = j;
        
        switch(pInParam->Type)
        {
        default:
        case APT_None:
            Status = STATUS_INVALID_PARAMETER;
            break;

            //
            // the input params have null-terminated string
            // convert it to UNICODE_STRING. Use the passed
            // pString array to hold the converted strings.
            // A string is either just a string or a file spec.
            //

        case APT_String:
            DsysAssertMsg( pInParam->Data0, "APT_String" );

            if (pInParam->Flags & AP_Filespec)
            {
                pOutParam->Type = SeAdtParmTypeFileSpec;
            }
            else
            {
                pOutParam->Type = SeAdtParmTypeString;
            }

            RtlInitUnicodeString( pString, (PCWSTR) pInParam->Data0 );
            pOutParam->Length  = sizeof(UNICODE_STRING) + pString->Length;
            pOutParam->Address = pString++;
            NumStringsUsed++;

            //
            // the passed array has limited size
            //

            if ( NumStringsUsed >= SE_MAX_AUDIT_PARAM_STRINGS )
            {
                Status = STATUS_BUFFER_OVERFLOW;
            }
            break;

            //
            // Convert a Ulong. It can be mapped to
            // any one of the following:
            // - access-mask
            // - decimal ulong
            // - hex ulong
            //

        case APT_Ulong:
            pOutParam->Data[0] = pInParam->Data0;
            pOutParam->Length  = sizeof(ULONG);
            if ( pInParam->Flags & AP_AccessMask )
            {
                pOutParam->Type    = SeAdtParmTypeAccessMask;
                ObjectTypeIndex = (USHORT) pInParam->Data1;

                //
                // the index cannot be greater than the current item
                //

                if (ObjectTypeIndex >= i)
                {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }
                ObjectTypeIndex = IndexMap[ObjectTypeIndex];
                pOutParam->Data[1] = ObjectTypeIndex;
            }
            else
            {
                if ( pInParam->Flags & AP_FormatHex )
                {
                    pOutParam->Type = SeAdtParmTypeHexUlong;
                }
                else
                {
                    pOutParam->Type = SeAdtParmTypeUlong;
                }
            }
            break;
                
        case APT_Sid:
            {
                PSID pSid;
                
                DsysAssertMsg( pInParam->Data0, "APT_Sid" );
            
                pOutParam->Type    = SeAdtParmTypeSid;
                pSid               = (PSID) pInParam->Data0;

                if ( !RtlValidSid( pSid ) )
                {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                pOutParam->Address = pSid;
                pOutParam->Length  = RtlLengthSid( pSid );
            }
            break;

        case APT_Guid:
            DsysAssertMsg( pInParam->Data0, "APT_Guid" );

            if ( !pInParam->Data0 )
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pOutParam->Type    = SeAdtParmTypeGuid;
            pOutParam->Address = (PVOID) pInParam->Data0;
            pOutParam->Length  = sizeof(GUID);
            break;

        case APT_LogonId:
            pOutParam->Type    = SeAdtParmTypeLogonId;
            LogonId.LowPart    = (ULONG) pInParam->Data0;
            LogonId.HighPart   = ( LONG) pInParam->Data1;
            *((LUID*) pOutParam->Data) = LogonId;
            pOutParam->Length  = sizeof(LUID);
            break;

        case APT_Luid:
            pOutParam->Type    = SeAdtParmTypeLuid;
            LogonId.LowPart    = (ULONG) pInParam->Data0;
            LogonId.HighPart   = ( LONG) pInParam->Data1;
            *((LUID*) pOutParam->Data) = LogonId;
            pOutParam->Length  = sizeof(LUID);
            break;

        case APT_Pointer:
            pOutParam->Type    = SeAdtParmTypePtr;
            pOutParam->Data[0] = pInParam->Data0;
            pOutParam->Length  = sizeof(PVOID);
            break;

        case APT_ObjectTypeList:
            pInObjectTypes     = (AUDIT_OBJECT_TYPES*) pInParam->Data0;
            NumObjectTypes     = pInObjectTypes->Count;

            DsysAssertMsg( pInObjectTypes, "APT_ObjectTypeList" );
            DsysAssertMsg( NumObjectTypes, "APT_ObjectTypeList" );
            
            if ( !pInObjectTypes )
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            if ( !NumObjectTypes )
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // get the type of the objects from Data1
            //

            ObjectTypeIndex    = (USHORT) pInParam->Data1;

            //
            // the index cannot be greater than the current item
            //

            if (ObjectTypeIndex >= i)
            {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            ObjectTypeIndex = IndexMap[ObjectTypeIndex];

            pOutParam->Type    = SeAdtParmTypeObjectTypes;
            pOutParam->Length  = NumObjectTypes * sizeof(SE_ADT_OBJECT_TYPE);

            //
            // the caller passes us a fixed sized object-type array
            // if that is not big enough, allocate a new one
            //

            if ( NumObjectTypes > MAX_OBJECT_TYPES )
            {
                *ppObjectTypeList = LsapAllocateLsaHeap( pOutParam->Length );
                fObjectTypeListAllocated = TRUE;
            }

            if ( *ppObjectTypeList == NULL )
            {
                Status = STATUS_NO_MEMORY;
                break;
            }
            pOutParam->Address = *ppObjectTypeList;
            pOutParam->Data[1] = ObjectTypeIndex;

            //
            // the structure of each element is identical
            // therefore just copy them all in one shot
            //

            RtlCopyMemory( *ppObjectTypeList,
                            pInObjectTypes->pObjectTypes,
                            pOutParam->Length );
            (*ppObjectTypeList)[0].Flags = SE_ADT_OBJECT_ONLY;
            break;

        case APT_Time:
            pOutParam->Type         = SeAdtParmTypeTime;
            FileTime.dwLowDateTime  = (DWORD) pInParam->Data0;
            FileTime.dwHighDateTime = (DWORD) pInParam->Data1;
            *((FILETIME*) pOutParam->Data) = FileTime;
            pOutParam->Length = sizeof(FILETIME);
            break;

        case APT_Int64:
            pOutParam->Type = SeAdtParmTypeHexInt64;
            Qword   = pInParam->Data1;
            Qword <<= 32;
            Qword  |= pInParam->Data0;
            *((PULONGLONG) pOutParam->Data) = Qword;
            pOutParam->Length = sizeof(ULONGLONG);
            break;
        }

        if (!NT_SUCCESS(Status))
        {
            break;
        }

    }
    
//Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if ( fObjectTypeListAllocated )
        {
            LsapFreeLsaHeap( *ppObjectTypeList );
            *ppObjectTypeList = NULL;
        }
    }
    
    return Status;
}


NTSTATUS 
LsapAdtFreeAuditContext(
    AUDIT_HANDLE hAudit
    )
/*++

Routine Description:

    Free resources allocated for the specified audit context

Arguments:

    hAudit - handle to audit context to free

Return Value:

    STATUS_SUCCESS

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAUDIT_CONTEXT pAuditContext;

    pAuditContext = AdtpContextPtrFromHandle( hAudit );
    
    DsysAssertMsg(pAuditContext, "LsapAdtFreeAuditContext" );
    
    DsysAssertMsg( LsapAdtIsValidAuditContext( hAudit ) == STATUS_SUCCESS,
                  "LsapAdtFreeAuditContext: audit context may be corrupt");
    
    LsapFreeLsaHeap( pAuditContext );
    
    return Status;
}


NTSTATUS 
LsapAdtCheckAuditPrivilege()
/*++

Routine Description:

    Check if the rpc client has SeAuditPrivilege.

Arguments:
    None

Return Value:

    STATUS_SUCCESS            if privilege held
    STATUS_PRIVILEGE_NOT_HELD if privilege not held
    error codes returned by NtOpenThreadToken, NtQueryInformationToken

Notes:
    

--*/
{
    NTSTATUS Status = STATUS_PRIVILEGE_NOT_HELD;
    HANDLE hToken = NULL;
    PRIVILEGE_SET PrivilegeSet = { 0 };
    BOOLEAN fHasAuditPrivilege = FALSE;
    BOOL fImpersonated = FALSE;

#if DBG
    //
    // make sure that we are not already impersonating
    //

    Status = NtOpenThreadToken( NtCurrentThread(), TOKEN_QUERY, TRUE, &hToken );

    DsysAssertMsg( Status == STATUS_NO_TOKEN, "LsapAdtCheckAuditPrivilege" );
    
    if ( NT_SUCCESS(Status) )
    {
        NtClose( hToken );
    }
#endif
    //
    // impersonate rpc caller
    //

    Status = I_RpcMapWin32Status(RpcImpersonateClient( NULL ));

    if (NT_SUCCESS(Status))
    {
        fImpersonated = TRUE;
        Status = NtOpenThreadToken( NtCurrentThread(), TOKEN_QUERY,
                                    TRUE, &hToken );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    PrivilegeSet.PrivilegeCount          = 1;
    PrivilegeSet.Control                 = PRIVILEGE_SET_ALL_NECESSARY;
    PrivilegeSet.Privilege[0].Luid       = AuditPrivilege;
    PrivilegeSet.Privilege[0].Attributes = 0;

    Status = NtPrivilegeCheck( hToken, &PrivilegeSet, &fHasAuditPrivilege );

    if ( NT_SUCCESS(Status) && !fHasAuditPrivilege )
    {
        Status = STATUS_PRIVILEGE_NOT_HELD;
    }
    
    
Cleanup:
    if ( hToken )
    {
        NtClose( hToken );
    }

    if ( fImpersonated )
    {
        NTSTATUS RevertStatus;
        RevertStatus = I_RpcMapWin32Status(RpcRevertToSelf());        
#if DBG
        ASSERT(NT_SUCCESS(RevertStatus) && "Revert did not succeed.");
#endif
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtgenp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T G E N P . H
//
// Contents:    private definitions of types/functions required for 
//              generating generic audits.
//
//              These definitions are not exposed to the client side code.
//              Any change to these definitions must not affect client
//              side code.
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------


#ifndef _ADTGENP_H
#define _ADTGENP_H

#define ACF_LegacyAudit      0x00000001L

#define ACF_ValidFlags       (ACF_LegacyAudit)

//
// audit context for legacy audits
//
typedef struct _AUDIT_CONTEXT
{
    //
    // List management
    //
    LIST_ENTRY Link;

    //
    // Flags TBD
    //
    DWORD      Flags;

    //
    // PID of the process owning this context
    //
    DWORD      ProcessId;

    //
    // Client supplied unique ID
    // This allows us to link this context with the client side
    // audit event type handle
    //
    LUID       LinkId;

    //
    // for further enhancement
    //
    PVOID      Reserved;

    //
    // Audit category ID
    //
    USHORT     CategoryId;

    //
    // Audit event ID
    //
    USHORT     AuditId;

    //
    // Expected parameter count
    //
    USHORT     ParameterCount;

} AUDIT_CONTEXT, *PAUDIT_CONTEXT;



EXTERN_C
NTSTATUS
LsapAdtInitGenericAudits( VOID );

EXTERN_C
NTSTATUS
LsapRegisterAuditEvent(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT PHANDLE phAuditContext
    );

EXTERN_C
NTSTATUS
LsapUnregisterAuditEvent(
    IN OUT PHANDLE phAuditContext
    );


EXTERN_C
NTSTATUS
LsapGenAuditEvent(
    IN HANDLE        hAuditContext,
    IN DWORD         Flags,
    IN PAUDIT_PARAMS pAuditParams,
    IN PVOID         Reserved
    );

NTSTATUS
LsapAdtMapAuditParams(
    IN  PAUDIT_PARAMS pAuditParams,
    OUT PSE_ADT_PARAMETER_ARRAY pSeAuditParameters,
    OUT PUNICODE_STRING pString,
    OUT PSE_ADT_OBJECT_TYPE* pObjectTypeList
    );

NTSTATUS 
LsapAdtCheckAuditPrivilege( 
    VOID 
    );

NTSTATUS 
LsapAdtRundownSecurityEventSource(
    IN DWORD dwFlags,
    IN DWORD dwCallerProcessId,
    IN OUT SECURITY_SOURCE_HANDLE * phEventSource
    );

typedef struct _LSAP_SECURITY_EVENT_SOURCE
{
    LIST_ENTRY List;
    DWORD dwFlags;
    PWSTR szEventSourceName;
    DWORD dwProcessId;
    LUID Identifier;
    DWORD dwRefCount;
} LSAP_SECURITY_EVENT_SOURCE, *PLSAP_SECURITY_EVENT_SOURCE;

EXTERN_C
NTSTATUS
LsapAdtRegisterSecurityEventSource(
    IN DWORD dwFlags,
    IN PCWSTR szEventSourceName,
    OUT AUDIT_HANDLE *phEventSource
    );

EXTERN_C
NTSTATUS 
LsapAdtUnregisterSecurityEventSource(
    IN DWORD dwFlags,
    IN AUDIT_HANDLE hEventSource
    );

EXTERN_C
NTSTATUS
LsapAdtReportSecurityEvent(
    DWORD dwFlags,        
    PLSAP_SECURITY_EVENT_SOURCE pSource,
    DWORD dwAuditId,
    PSID pSid,
    PAUDIT_PARAMS pParams 
    );

#endif //_ADTGENP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtext.c ===
#include <lsapch2.h>
#pragma hdrstop

#include "adtp.h"
#include "adtgen.h"
#include "adtgenp.h"

//
// These variables describe and protect the list of registered
// event sources.
//

LIST_ENTRY           LsapAdtEventSourceList     = {0};
RTL_CRITICAL_SECTION LsapAdtEventSourceListLock = {0};
DWORD                LsapAdtEventSourceCount    = 0;

#define MAX_EVENT_SOURCE_NAME_LENGTH 256

#define LsapAdtLockEventSourceList()   RtlEnterCriticalSection(&LsapAdtEventSourceListLock)
#define LsapAdtUnlockEventSourceList() RtlLeaveCriticalSection(&LsapAdtEventSourceListLock)

//
// The number of parameters which need to be prepended internally to an AUDIT_PARAMS so that
// extensible auditing can function properly.  The parameters are the pSid, the string "Security",
// the actual source string, and the actual source audit ID.
// 

#define EXTENSIBLE_AUDIT_PREPEND_COUNT 4

//
// Our registry key name.
//

#define SECURITY_KEY_NAME L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Security"

#define DEBUG_AUTHZ 0

#define VERIFY_PID 0x1

NTSTATUS
LsapAdtValidateExtensibleAuditingCaller(
    OUT PDWORD pdwCallerProcessId,
    IN  BOOL   bPrivCheck
    );

PLSAP_SECURITY_EVENT_SOURCE
LsapAdtLocateSecurityEventSourceByName(
    IN PCWSTR szEventSourceName
    );

PLSAP_SECURITY_EVENT_SOURCE
LsapAdtLocateSecurityEventSourceByIdentifier(
    IN PLUID pIdentifier
    );

PLSAP_SECURITY_EVENT_SOURCE
LsapAdtLocateSecurityEventSourceBySource(
    IN PLSAP_SECURITY_EVENT_SOURCE pSource
    );

LONG
LsapAdtReferenceSecurityEventSource(
    IN OUT PLSAP_SECURITY_EVENT_SOURCE pSource
    );

LONG
LsapAdtDereferenceSecurityEventSource(
    IN OUT PLSAP_SECURITY_EVENT_SOURCE pSource
    );

VOID
LsapAdtDeleteSecurityEventSource(
    IN OUT PLSAP_SECURITY_EVENT_SOURCE pSource
    );

NTSTATUS
LsapAdtCreateSourceAuditParams(
    IN  DWORD                       dwFlags,
    IN  PSID                        pSid,
    IN  PLSAP_SECURITY_EVENT_SOURCE pSource,
    IN  DWORD                       dwAuditId,
    IN  PAUDIT_PARAMS               pOldParams,
    OUT PAUDIT_PARAMS               pNewParams
    );
    
NTSTATUS
LsapAdtVerifySecurityEventSource(
    IN     LPCWSTR szEventSourceName,
    IN     PUNICODE_STRING pImageName,
    IN OUT PDWORD  pdwInstalledSourceFlags
    );

NTSTATUS
LsapAdtAuditSecuritySource(
    IN USHORT                      AuditEventType,
    IN PLSAP_SECURITY_EVENT_SOURCE pEventSource,
    IN BOOL                        bRegistration
    );


LONG
LsapAdtReferenceSecurityEventSource(
    IN OUT PLSAP_SECURITY_EVENT_SOURCE pSource
    )

/**

Routine Description:

    Adds one reference to pSource.  This assumes that all locks on the source
    list are held.
    
Arguments:

    pSource - pointer to LSAP_SECURITY_EVENT_SOURCE.
    
Return Value:

    The number of references remaining on the pSource.
    
**/

{
    LONG l = InterlockedIncrement(&pSource->dwRefCount);

#if DEBUG_AUTHZ
    DbgPrint("Source 0x%x +refcount = %d\n", pSource, pSource->dwRefCount);
#endif
        
    return l;
}


LONG
LsapAdtDereferenceSecurityEventSource(
    IN OUT PLSAP_SECURITY_EVENT_SOURCE pSource
    )

/**

Routine Description:

    Removes a reference from pSource and deletes the source if the refcount
    has reached 0.
    
    This assumes that all necessary locks are held on the source list, so that
    if deletion is necessary no list corruption will result.
    
Arguments:

    pSource - pointer to LSAP_SECURITY_EVENT_SOURCE.
    
Return Value:

    The number of references remaining on the pSource.
    
**/

{
    LONG l = InterlockedDecrement(&pSource->dwRefCount);

#if DEBUG_AUTHZ
    DbgPrint("Source 0x%x %S -refcount = %d\n", pSource, pSource->szEventSourceName, pSource->dwRefCount);
#endif

     if (l == 0)
     {
         LsapAdtAuditSecuritySource(
             EVENTLOG_AUDIT_SUCCESS,
             pSource,
             FALSE
             );

         LsapAdtDeleteSecurityEventSource(pSource);
     }
     
     return l;
}


VOID
LsapAdtDeleteSecurityEventSource(
    PLSAP_SECURITY_EVENT_SOURCE pSource
    )

/**

Routine Description:

    Deletes pSource from the global source list.  This assumes that
    all locks necessary are held.
    
Arguments:

    pSource - pointer to LSAP_SECURITY_EVENT_SOURCE.
    
Return Value:

    None.
    
**/

{
    RemoveEntryList(
        &pSource->List
        );

#if DEBUG_AUTHZ
    DbgPrint("Source 0x%x %S deleted.  List size = %d\n", pSource, pSource->szEventSourceName, LsapAdtEventSourceCount);
#endif
    LsapFreeLsaHeap(pSource);
    ASSERT(LsapAdtEventSourceCount > 0);
    LsapAdtEventSourceCount--;

}                            


NTSTATUS
LsapAdtInitializeExtensibleAuditing(
    )

/**

Routine Description:

    Initializes necessary data structures for extensible 
    auditing support.
    
Arguments:

    None.
    
Return Value:

    NTSTATUS.
    
**/

{
    NTSTATUS Status;

    InitializeListHead(
        &LsapAdtEventSourceList
        );

    LsapAdtEventSourceCount = 0;

    Status = RtlInitializeCriticalSection(
                 &LsapAdtEventSourceListLock
                 );

    return Status;
}


NTSTATUS
LsapAdtRegisterSecurityEventSource(
    IN  DWORD                    dwFlags,
    IN  PCWSTR                   szEventSourceName,
    OUT SECURITY_SOURCE_HANDLE * phEventSource
    )

/**

Routine Description:

    This is the routine that allows a client to register a new security
    source with the LSA.  It adds the source to the global list and returns
    a handle to the client for future reference to the new security event 
    source.
    
Arguments:

    dwFlags - TBD.
    
    szEventSourceName - the name to describe the new source.
    
    phEventSource - pointer to handle which receives the new source allocation.
    
Return Value:

    NTSTATUS.
    
**/

{
    NTSTATUS                    Status;
    DWORD                       dwCallerProcessId;
    BOOL                        b;
    USHORT                      AuditEventType;
    DWORD                       dwInstalledSourceFlags = 0;
    PLSAP_SECURITY_EVENT_SOURCE pEventSource           = NULL;
    BOOL                        bLock                  = FALSE;
    DWORD                       dwNameLength;
    HANDLE                      hProcess               = NULL;
    UCHAR                       ProcBuffer[80];
    PUNICODE_STRING             pProcessName           = (PUNICODE_STRING) ProcBuffer;
    DWORD                       dwLength               = 0;

    if (NULL == szEventSourceName || NULL == phEventSource)
    {
        return STATUS_INVALID_PARAMETER;
    }

    dwNameLength = wcslen(szEventSourceName);

    if (dwNameLength > MAX_EVENT_SOURCE_NAME_LENGTH || dwNameLength == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure the caller has the Audit privilege.
    //

    Status = LsapAdtValidateExtensibleAuditingCaller(
                 &dwCallerProcessId,
                 TRUE
                 );

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }
    
    //
    // Make sure this process has the name that was registered.
    // Open the process and query the image name.
    //

    hProcess = OpenProcess(
                   PROCESS_QUERY_INFORMATION,
                   FALSE,
                   dwCallerProcessId
                   );

    if (hProcess == NULL)
    {
        Status = LsapWinerrorToNtStatus(GetLastError());
        goto Cleanup;
    }

    Status = NtQueryInformationProcess(
                 hProcess,
                 ProcessImageFileName,
                 pProcessName,
                 sizeof(ProcBuffer),
                 &dwLength
                 );

    if (Status == STATUS_INFO_LENGTH_MISMATCH)
    {
        pProcessName = LsapAllocateLsaHeap(dwLength + sizeof(WCHAR));

        if (NULL == pProcessName)
        {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        Status = NtQueryInformationProcess(
                     hProcess,
                     ProcessImageFileName,
                     pProcessName,
                     dwLength,
                     &dwLength
                     );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    LsapAdtSubstituteDriveLetter(pProcessName);

    //
    // Verify the existence of this source in the registry.  The source
    // must have been installed in order for it to be registered at 
    // runtime.
    //

    Status = LsapAdtVerifySecurityEventSource(
                   szEventSourceName,
                   pProcessName,
                   &dwInstalledSourceFlags
                   );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Build the LSAP_EVENT_SOURCE.  Allocate space for the structure and the embedded name string.
    //

    pEventSource = LsapAllocateLsaHeap(
                       sizeof(LSAP_SECURITY_EVENT_SOURCE) + (sizeof(WCHAR) * (dwNameLength + 1))
                       );

    if (NULL == pEventSource)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(
        pEventSource,
        sizeof(LSAP_SECURITY_EVENT_SOURCE) + (sizeof(WCHAR) * (dwNameLength + 1))
        );

    pEventSource->szEventSourceName = (PWSTR)((PUCHAR)pEventSource + sizeof(LSAP_SECURITY_EVENT_SOURCE));
    
    wcsncpy(
        pEventSource->szEventSourceName, 
        szEventSourceName, 
        dwNameLength
        );

    pEventSource->dwProcessId = dwCallerProcessId;

    b = AllocateLocallyUniqueId(&pEventSource->Identifier);

    if (!b)
    {
        Status = LsapWinerrorToNtStatus(GetLastError());
        goto Cleanup;
    }

    //
    // Now make sure no other source has registered with the same name.
    // Hold the lock for this operation and the insertion to avoid
    // a race condition for registering identical names.
    //

    Status = LsapAdtLockEventSourceList();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    bLock = TRUE;
    
    //
    // Don't bother with this check if the installed source flags allows
    // multiple instances of the same provider name.  If the Locate 
    // function returns NULL then no source already is registered with
    // this name.
    //

    if ((dwInstalledSourceFlags & AUTHZ_ALLOW_MULTIPLE_SOURCE_INSTANCES) || 
         NULL == LsapAdtLocateSecurityEventSourceByName(szEventSourceName))
    {
        //
        // Take out an initial reference on this source.
        //

        LsapAdtReferenceSecurityEventSource(pEventSource);
        
        //
        // Add the entry to the list.
        //

        LsapAdtEventSourceCount++;

        InsertTailList(
            &LsapAdtEventSourceList,
            &pEventSource->List
            );

#if DEBUG_AUTHZ
    DbgPrint("Source 0x%x %S created.  List size = %d\n", pEventSource, pEventSource->szEventSourceName, LsapAdtEventSourceCount);
#endif

    }
    else
    {
        //
        // The name is already taken.
        //

        Status = STATUS_OBJECT_NAME_EXISTS;
        goto Cleanup;
    }

Cleanup:

    if (hProcess)
    {
        CloseHandle(hProcess);
    }

    if (pProcessName != NULL && pProcessName != (PUNICODE_STRING) ProcBuffer)
    {
        LsapFreeLsaHeap(pProcessName);
    }

    if (bLock)
    {
        NTSTATUS TempStatus;
        TempStatus = LsapAdtUnlockEventSourceList();
        ASSERT(NT_SUCCESS(TempStatus));
    }

    if (NT_SUCCESS(Status))
    {
        *phEventSource = (SECURITY_SOURCE_HANDLE)pEventSource;
        AuditEventType = EVENTLOG_AUDIT_SUCCESS;
    }
    else
    {
        AuditEventType = EVENTLOG_AUDIT_FAILURE;
    }

    //
    // Audit the registration.
    //

    (VOID) LsapAdtAuditSecuritySource(
               AuditEventType,
               pEventSource,
               TRUE
               );
    
    if (!NT_SUCCESS(Status))
    {
        if (pEventSource)
        {
            LsapFreeLsaHeap(pEventSource);
        }
    }

    return Status;
}


NTSTATUS
LsapAdtReportSecurityEvent(
    IN DWORD                       dwFlags,        
    IN PLSAP_SECURITY_EVENT_SOURCE pSource,
    IN DWORD                       dwAuditId,      
    IN PSID                        pSid,
    IN PAUDIT_PARAMS               pParams 
    )

/**

Routine Description:

    This routine generates an audit / security event for a registered source.
    
Arguments:

    dwFlags - APF_AuditSuccess, APF_AuditFailure
    
    pSource - pointer to the source which is generating the event.
    
    dwAuditId - the ID of the audit.
    
    pSid - the caller's sid to be placed into the audit.
    
    pParams - the parameters of the audit.  Note that extensible auditing 
            differs from the rest of the system in that the first 2 parameters
            are not supposed to be the SID and the string "Security."  We prepend
            this data to the audit internally.  The pParams passed in should contain
            only the data of the audit.  We take care of all modifications that 
            are necessary for the eventviewer to properly parse the audit.
    
Return Value:

    NTSTATUS.

**/

{
    BOOLEAN                bAudit;
    UINT                   AuditEventType;
    SE_ADT_OBJECT_TYPE     ObjectTypes[MAX_OBJECT_TYPES];
    LONG                   Refs;
    NTSTATUS               Status                              = STATUS_SUCCESS;
    SE_ADT_PARAMETER_ARRAY SeAuditParameters                   = {0};
    UNICODE_STRING         Strings[SE_MAX_AUDIT_PARAM_STRINGS] = {0};
    PSE_ADT_OBJECT_TYPE    pObjectTypes                        = ObjectTypes;
    AUDIT_PARAMS           NewParams                           = {0};
    AUDIT_PARAM            ParamArray[SE_MAX_AUDIT_PARAMETERS] = {0};
    BOOLEAN                bRef                                = FALSE;
    BOOLEAN                bLock                               = FALSE;

    if (pParams->Count < 0 || pParams->Count > (SE_MAX_AUDIT_PARAM_STRINGS - EXTENSIBLE_AUDIT_PREPEND_COUNT))
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (!RtlValidSid(pSid))
    {
        return STATUS_INVALID_PARAMETER;
    }

    Status = LsapAdtLockEventSourceList();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    bLock = TRUE;

    //
    // Make certain that the source is registered.
    //

    if (LsapAdtLocateSecurityEventSourceBySource(pSource) == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    } 
    else
    {
        Refs = LsapAdtReferenceSecurityEventSource(pSource);
        bRef = TRUE;

        //
        // There should always be one other reference on a source that is 
        // generating an audit (the initial reference should still be present).
        //

        ASSERT(Refs > 1);
    }

    //
    // We have protected the pSource pointer; we can safely unlock the list.
    //

    (VOID) LsapAdtUnlockEventSourceList();
    bLock = FALSE;

    if ( pParams->Flags & APF_AuditSuccess )
    {
        AuditEventType = EVENTLOG_AUDIT_SUCCESS;
    }
    else
    {
        AuditEventType = EVENTLOG_AUDIT_FAILURE;
    }

    //
    // Check if auditing is enabled for ObjectAccess and this user.  All
    // third party audits fall under the policy of the object access category.
    //

    Status = LsapAdtAuditingEnabledBySid(
                 AuditCategoryObjectAccess,
                 pSid,
                 AuditEventType,
                 &bAudit
                 );

    if (NT_SUCCESS(Status) && bAudit)
    {
        //
        // Construct a legacy style audit params from the data.
        // Utilize the SE_AUDITID_GENERIC_AUDIT_EVENT type to 
        // allow eventvwr to parse the audit properly.
        //

        NewParams.Parameters = ParamArray;

        Status = LsapAdtCreateSourceAuditParams(
                     dwFlags,
                     pSid,
                     pSource,
                     dwAuditId,
                     pParams,
                     &NewParams
                     );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        SeAuditParameters.Type           = (USHORT) AuditEventType;
        SeAuditParameters.CategoryId     = SE_CATEGID_OBJECT_ACCESS;
        SeAuditParameters.AuditId        = SE_AUDITID_GENERIC_AUDIT_EVENT;
        SeAuditParameters.ParameterCount = NewParams.Count;

        //
        // Map AUDIT_PARAMS structure to SE_ADT_PARAMETER_ARRAY structure
        //

        Status = LsapAdtMapAuditParams( &NewParams,
                                        &SeAuditParameters,
                                        (PUNICODE_STRING) Strings,
                                        &pObjectTypes );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // write the params to eventlog
        //
        
        Status = LsapAdtWriteLog(&SeAuditParameters);
        
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else
    {
        goto Cleanup;
    }

    
Cleanup:

    if (bRef)
    {
        LsapAdtDereferenceSecurityEventSource(pSource);
    }
    
    if (bLock)
    {
        LsapAdtUnlockEventSourceList();
    }

    if (!NT_SUCCESS(Status))
    {
        //
        // crash on failure if specified by the security policy
        //
        // But do not crash on documented errors
        //

        if ( ( Status != STATUS_INVALID_PARAMETER ) &&
             ( Status != STATUS_AUDITING_DISABLED ) &&
             ( Status != STATUS_NOT_FOUND ) )
        {
            LsapAuditFailed(Status);
        }
    }

    //
    // Free pObjectTypes if we are not using the stack buffer.
    //

    if (pObjectTypes && (pObjectTypes != ObjectTypes))
    {
        LsapFreeLsaHeap(pObjectTypes);
    }

    return Status;
}


NTSTATUS 
LsapAdtUnregisterSecurityEventSource(
    IN     DWORD                    dwFlags,
    IN OUT SECURITY_SOURCE_HANDLE * phEventSource
    )

/**

Routine Description:

    This frees (dereferences once) the LSAP_EVENT_SOURCE that was created via LsapRegisterSecurityEventSource.  
    
Arguments:

    dwFlags - TBD
    
    phEventSource - pointer to a SECURITY_SOURCE_HANDLE (pointer to an event source)

Return Value:

    NTSTATUS.
    
**/

{
    NTSTATUS Status;
    DWORD    dwCallerProcessId;

    if (NULL == phEventSource)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // we don't care if the caller has the privilege enabled at this time.
    //

    Status = LsapAdtValidateExtensibleAuditingCaller(
                 &dwCallerProcessId,
                 FALSE
                 );
    
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsapAdtRundownSecurityEventSource(
                 VERIFY_PID,
                 dwCallerProcessId,
                 phEventSource
                 );

Cleanup:
    
    return Status;
}


NTSTATUS 
LsapAdtRundownSecurityEventSource(
    IN     DWORD                    dwFlags,
    IN     DWORD                    dwCallerProcessId,
    IN OUT SECURITY_SOURCE_HANDLE * phEventSource
    )

/**

Routine Description:

    This frees (dereferences once) the LSAP_EVENT_SOURCE that was created via LsapRegisterSecurityEventSource.  
    
Arguments:

    dwFlags - VERIFY_PID - verify that the process which installed the source is the 
        one deleting it.
    
    dwCallerProcessId - the PID of the process which initiated the call.
                  
    phEventSource - pointer to a SECURITY_SOURCE_HANDLE (pointer to an event source)

Return Value:

    NTSTATUS.
    
**/

{
    NTSTATUS                    Status;
    BOOL                        bLock              = FALSE;
    PLSAP_SECURITY_EVENT_SOURCE pEventSource       = NULL;

    if (NULL == phEventSource)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    pEventSource = (PLSAP_SECURITY_EVENT_SOURCE) *phEventSource;

    Status = LsapAdtLockEventSourceList();
    
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    bLock = TRUE;

    if (LsapAdtLocateSecurityEventSourceBySource(pEventSource))
    {
        //
        // If we are asked to verify the pid then make sure that the current
        // process has the same ID as the one who registered the source.
        //

        if ((dwFlags & VERIFY_PID) && (pEventSource->dwProcessId != dwCallerProcessId))
        {
            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }

        LsapAdtDereferenceSecurityEventSource(pEventSource);
    }
    else
    {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }
    
Cleanup:

    if (bLock)
    {
        NTSTATUS TempStatus;
        TempStatus = LsapAdtUnlockEventSourceList();
        ASSERT(NT_SUCCESS(TempStatus));
    }

    if (NT_SUCCESS(Status))
    {
        *phEventSource = NULL;
    }
    
    return Status;
}


PLSAP_SECURITY_EVENT_SOURCE
LsapAdtLocateSecurityEventSourceByName(
    IN PCWSTR szEventSourceName
    )

/**

Routine Description:

    This returns the event source associated with the source name.
    The caller is responsible for locking the list.
    
Arguments:

    szEventSourceName - source name to look up.
    
Return Value:

    Either a valid pointer to the source associated with the szEventSourceName, or NULL
    if the name is not registered.
    
**/

{
    PLIST_ENTRY                 pList;
    PLSAP_SECURITY_EVENT_SOURCE pListEventSource;
    DWORD                       dwNameLength;
    DWORD                       dwCount = 0;

    dwNameLength = wcslen(szEventSourceName);
    pList        = LsapAdtEventSourceList.Flink;

    ASSERT(pList != NULL);

    if (pList == NULL)
    {
        return NULL;
    }

    while (pList != &LsapAdtEventSourceList)
    {
        if (dwCount > LsapAdtEventSourceCount)
        {
            break;
        }

        pListEventSource = CONTAINING_RECORD(
                               pList, 
                               LSAP_SECURITY_EVENT_SOURCE, 
                               List
                               );

        if (dwNameLength == wcslen(pListEventSource->szEventSourceName) &&
            0 == wcsncmp(
                     szEventSourceName, 
                     pListEventSource->szEventSourceName, 
                     dwNameLength
                     ))
        {
            return pListEventSource;
        }

        pList = pList->Flink;
        dwCount++;
    }
    
    return NULL;
}


PLSAP_SECURITY_EVENT_SOURCE
LsapAdtLocateSecurityEventSourceByIdentifier(
    IN PLUID pIdentifier
    )

/**

Routine Description:

    This returns the event source associated with the source identifier.
    The caller is responsible for locking the list.
    
Arguments:

    pIdentifier - pointer to LUID associated with an event source.
    
Return Value:

    A valid pointer if the passed LUID is associated with a source, or NULL if
    not.

**/

{
    PLIST_ENTRY                 pList;
    PLSAP_SECURITY_EVENT_SOURCE pListEventSource;
    DWORD                       dwCount = 0;

    pList = LsapAdtEventSourceList.Flink;

    ASSERT(pList != NULL);

    if (pList == NULL)
    {
        return NULL;
    }

    while (pList != &LsapAdtEventSourceList)
    {
        if (dwCount > LsapAdtEventSourceCount)
        {
            break;
        }
        pListEventSource = CONTAINING_RECORD(
                               pList, 
                               LSAP_SECURITY_EVENT_SOURCE, 
                               List
                               );

        if (RtlEqualLuid(&pListEventSource->Identifier, pIdentifier))
        {
            return pListEventSource;
        }

        pList = pList->Flink;
        dwCount++;
    }
    
    return NULL;
}


PLSAP_SECURITY_EVENT_SOURCE
LsapAdtLocateSecurityEventSourceBySource(
    PLSAP_SECURITY_EVENT_SOURCE pSource
    )

/**

Routine Description:

    This routine returns either a pointer to the source, or NULL if the
    source is not registered.
    
Arguments:

    pSource - a pointer to a source.  
    
Return Value:

    Either a valid pointer (which will be equal to the pSource argument) or NULL if
    the passed pSource value is not a registered source.
    
**/

{
    PLIST_ENTRY                 pList;
    PLSAP_SECURITY_EVENT_SOURCE pListEventSource;
    DWORD                       dwCount = 0;

    pList = LsapAdtEventSourceList.Flink;

    ASSERT(pList != NULL);

    if (pList == NULL)
    {
        return NULL;
    }

    while (pList != &LsapAdtEventSourceList)
    {
        if (dwCount > LsapAdtEventSourceCount)
        {
            break;
        }

        pListEventSource = CONTAINING_RECORD(
                               pList, 
                               LSAP_SECURITY_EVENT_SOURCE, 
                               List
                               );

        if (pListEventSource == pSource)
        {
            return pListEventSource;
        }

        pList = pList->Flink;
        dwCount++;
    }
    return NULL;
}


NTSTATUS
LsapAdtValidateExtensibleAuditingCaller(
    IN OUT PDWORD pdwCallerProcessId,
    IN     BOOL   bPrivCheck
    )

/**

Routine Description:

    This verifies that the caller is on the local box and that 
    the client also possesses the necessary privilege (SeAuditPrivilege).
    
Arguments:

    pdwCallerProcessId - pointer to DWORD which returns the caller's
        PID.

    bPrivCheck - boolean indicating if a privilege check should be performed.

Return Value:

    NTSTATUS.
    
**/

{
    NTSTATUS Status;
    DWORD    dwRpcTransportType;
    DWORD    dwLocalClient;

    //
    // Find out the transport over which we are receiving this call.
    //

    Status = I_RpcBindingInqTransportType( 
                 NULL, 
                 &dwRpcTransportType 
                 );

    if (RPC_S_OK != Status)
    {
        Status = I_RpcMapWin32Status(
                     Status 
                     );

        goto Cleanup;
    }

    //
    // If the transport is anything other than LPC, error out.
    // We want to support only LPC for audit calls.
    //

    if (dwRpcTransportType != TRANSPORT_TYPE_LPC)
    {
        Status = RPC_NT_PROTSEQ_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // The callers are forced to be local.
    //

    Status = I_RpcBindingIsClientLocal( 
                 NULL, 
                 &dwLocalClient
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!dwLocalClient)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Get the PID of the caller.
    //

    Status = I_RpcBindingInqLocalClientPID( 
                 NULL, 
                 pdwCallerProcessId 
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    if (bPrivCheck)
    {
        //
        // Make sure that the caller has audit privilege.
        // (LsapAdtCheckAuditPrivilege calls RpcImpersonateClient)
        //
    
        Status = LsapAdtCheckAuditPrivilege();

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

Cleanup:

    return Status;
}


NTSTATUS
LsapAdtCreateSourceAuditParams(
    IN     DWORD                       dwFlags,
    IN     PSID                        pSid,
    IN     PLSAP_SECURITY_EVENT_SOURCE pSource,
    IN     DWORD                       dwAuditId,
    IN     PAUDIT_PARAMS               pOldParams,
    IN OUT PAUDIT_PARAMS               pNewParams
    )

/**

Routine Description:

    This is an internal routine which constructs an AUDIT_PARAMS for eventlog
    to properly display -- with params 0 and 1 being the pSid and the string "Security",
    and strings 2 and 3 being the actual source name and the actual source AuditId.
    
Arguments:

    dwFlags - AUTHZ_AUDIT_INSTANCE_INFORMATION - prepends audit with source name, identifier,
        and PID.
    
    pSid - the Sid to be displayed in eventlog as the user.
    
    pSource - the source generating the audit.
    
    dwAuditId - the AuditId to be generated.
    
    pOldParams - an AUDIT_PARAMS that contains only the data for the audit as passed from
        the client, without any ot the internal (above mentioned) data that eventlog uses
        to parse and display the data.
    
    pNewParams - an AUDIT_PARAMS that is suitable for passing to event log.
        
Return Value:

    NTSTATUS.

**/

{
    PAUDIT_PARAM pOldParam;
    PAUDIT_PARAM pNewParam;
    DWORD        i;

    pNewParams->Count  = 0;
    pNewParams->Flags  = pOldParams->Flags;
    pNewParams->Length = pOldParams->Length;

    pNewParam = pNewParams->Parameters;
    pOldParam = pOldParams->Parameters;

    //
    // First set up the 4 initial parameters, so that the eventlog can
    // digest this audit and present it with the correct source and 
    // audit id.
    //

    pNewParam->Type  = APT_Sid;
    pNewParam->Data0 = (ULONG_PTR) pSid;
    pNewParams->Count++;
    pNewParam++;

    pNewParam->Type  = APT_String;
    pNewParam->Data0 = (ULONG_PTR) L"Security";
    pNewParams->Count++;
    pNewParam++;

    pNewParam->Type  = APT_String;
    pNewParam->Data0 = (ULONG_PTR) pSource->szEventSourceName;
    pNewParams->Count++;
    pNewParam++;

    pNewParam->Type  = APT_Ulong;
    pNewParam->Data0 = (ULONG_PTR) dwAuditId;
    pNewParams->Count++;
    pNewParam++;

//     //
//     // Now stick in the LUID identifier as a parameter.
//     //
//
//     pNewParam->Type  = APT_Luid;
//     pNewParam->Data0 = (ULONG_PTR) pSource->Identifier;
//     pNewParams->Count++;
//     pNewParam++;

    //
    // If the flags specify that the caller would like to have source
    // information automatically added to the audit, then do so.
    //

    if (dwFlags & AUTHZ_AUDIT_INSTANCE_INFORMATION)
    {
        pNewParam->Type  = APT_Luid;
        pNewParam->Data0 = (ULONG_PTR) pSource->Identifier.LowPart;
        pNewParam->Data1 = (ULONG_PTR) pSource->Identifier.HighPart;
        pNewParams->Count++;
        pNewParam++;

        pNewParam->Type  = APT_Ulong;
        pNewParam->Data0 = (ULONG_PTR) pSource->dwProcessId;
        pNewParams->Count++;
        pNewParam++;
    }

    if ((pNewParams->Count + pOldParams->Count) > SE_MAX_AUDIT_PARAM_STRINGS)
    {
        return STATUS_INVALID_PARAMETER;
    }

    for (i = 0; i < pOldParams->Count; i++)
    {
        *pNewParam = *pOldParam;
        pNewParams->Count++;
        pNewParam++;
        pOldParam++;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
LsapAdtVerifySecurityEventSource(
    IN     LPCWSTR         szEventSourceName,
    IN     PUNICODE_STRING pImageName,
    IN OUT PDWORD          pdwInstalledSourceFlags 
    )

/**

Routine Description:

    This verifies that the event source has been properly installed in the registry.
    
Arguments:

    pdwInstalledSourceFlags - pointer to a DWORD that returns any flags used when 
        installing the event source.

    szEventSourceName - the name of the source to verify.
    
Return Value:

    NTSTATUS.
    
**/

{
    DWORD    dwType;
    NTSTATUS Status     = STATUS_SUCCESS;
    DWORD    dwError    = ERROR_SUCCESS;
    HKEY     hkSecurity = NULL;
    HKEY     hkSource   = NULL;
    DWORD    dwSize     = sizeof(DWORD);
    WCHAR    NameBuffer[80];
    PWSTR    pName      = NameBuffer;

    *pdwInstalledSourceFlags = 0;

    dwError = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  SECURITY_KEY_NAME,
                  0,
                  KEY_READ,
                  &hkSecurity
                  );

    if (ERROR_SUCCESS != dwError)
    {
        goto Cleanup;
    }

    dwError = RegOpenKeyEx(
                  hkSecurity,
                  szEventSourceName,
                  0,
                  KEY_READ,
                  &hkSource
                  );

    if (ERROR_SUCCESS != dwError)
    {
        goto Cleanup;
    }

    dwError = RegQueryValueEx(
                  hkSource,
                  L"EventSourceFlags",
                  NULL,
                  &dwType,
                  (LPBYTE)pdwInstalledSourceFlags,
                  &dwSize
                  );

    if (ERROR_SUCCESS != dwError)
    {
        goto Cleanup;
    }

    ASSERT(dwType == REG_DWORD);

    dwSize = sizeof(NameBuffer);

    dwError = RegQueryValueEx(
                  hkSource,
                  L"ExecutableImagePath",
                  NULL,
                  &dwType,
                  (LPBYTE)pName,
                  &dwSize
                  );

    if (ERROR_INSUFFICIENT_BUFFER == dwError)
    {
        pName = LsapAllocateLsaHeap(dwSize);

        if (pName == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        dwError = RegQueryValueEx(
                      hkSource,
                      L"ExecutableImagePath",
                      NULL,
                      &dwType,
                      (LPBYTE)pName,
                      &dwSize
                      );
    }

    //
    // If an ExecutableImagePath was not specified, then the provider
    // had decided at installation time to not take advantage of the 
    // image spoofproof feature.  Let the call pass through successfully.
    //

    if (dwError == ERROR_FILE_NOT_FOUND)
    {
        dwError = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // Deal with all other errors now.
    //

    if (ERROR_SUCCESS != dwError)
    {
        goto Cleanup;
    }

    ASSERT(dwType == REG_MULTI_SZ);

    //
    // Make sure that the process registered is the same as the calling process.
    //

    if (0 != _wcsnicmp(pName, pImageName->Buffer, pImageName->Length / sizeof(WCHAR)))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

Cleanup:

    if (hkSource)
    {
        RegCloseKey(hkSource);
    }
    if (hkSecurity)
    {
        RegCloseKey(hkSecurity);
    }
    if (dwError != ERROR_SUCCESS)
    {
        Status = LsapWinerrorToNtStatus(dwError);
    }
    
    if (pName != NameBuffer && pName != NULL)
    {
        LsapFreeLsaHeap(pName);
    }
    return Status;
}


NTSTATUS
LsapAdtAuditSecuritySource(
    IN USHORT                      AuditEventType,
    IN PLSAP_SECURITY_EVENT_SOURCE pEventSource,
    IN BOOL                        bRegistration
    )

/**

Routine Description:

    This audits the attempt of a client to register a security event source.
    
Arguments:

    AuditEventType - either EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE.
    
    pEventSource - the source to audit.
    
    bRegistration - TRUE if this is a registration audit, FALSE if it is
        an unregistration.
               
Return Value:

    NTSTATUS.
    
**/

{
    LUID                   ClientAuthenticationId;
    BOOLEAN                bAudit;
    NTSTATUS               Status;
    PTOKEN_USER            TokenUserInformation    = NULL;
    DWORD                  dwPid                   = 0;
    LUID                   Luid                    = {0};
    SE_ADT_PARAMETER_ARRAY AuditParameters         = {0};
    UNICODE_STRING         SourceString            = {0};

    //
    // If this is a success audit then the pEventSource is complete and 
    // we can trust the pointer to dereference its various fields.
    //

    if (AuditEventType == EVENTLOG_AUDIT_SUCCESS)
    {
        Luid = pEventSource->Identifier;

        RtlInitUnicodeString(
            &SourceString,
            pEventSource->szEventSourceName
            );

        dwPid = pEventSource->dwProcessId;

    } else if (pEventSource != NULL)
    {
        Luid = pEventSource->Identifier;
        dwPid = pEventSource->dwProcessId;

        if (pEventSource->szEventSourceName)
        {
            RtlInitUnicodeString(
                &SourceString,
                pEventSource->szEventSourceName
                );
        }
    }
    
    Status = LsapQueryClientInfo(
                 &TokenUserInformation,
                 &ClientAuthenticationId
                 );

    if (!NT_SUCCESS(Status)) 
    {
        goto Cleanup;
    }

    Status = LsapAdtAuditingEnabledByLogonId(
                 AuditCategoryPolicyChange,
                 &ClientAuthenticationId,
                 AuditEventType,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit)
    {
        goto Cleanup;
    }

    Status = LsapAdtInitParametersArray(
                 &AuditParameters,
                 SE_CATEGID_POLICY_CHANGE,
                 bRegistration ? SE_AUDITID_SECURITY_EVENT_SOURCE_REGISTERED : SE_AUDITID_SECURITY_EVENT_SOURCE_UNREGISTERED,
                 AuditEventType,
                 7,

                 //
                 // User Sid
                 //
                 SeAdtParmTypeSid, TokenUserInformation->User.Sid,

                 //
                 // Subsystem name 
                 //
                 SeAdtParmTypeString, &LsapSubsystemName,

                 //
                 // Primary Authentication information
                 //
                 SeAdtParmTypeLogonId, LsapSystemLogonId,

                 //
                 // Clients's Authentication information
                 //
                 SeAdtParmTypeLogonId, ClientAuthenticationId,

                 //
                 // Source Name
                 //
                 SeAdtParmTypeString, &SourceString,
        
                 //
                 // PID
                 //
                 SeAdtParmTypeUlong, dwPid,

                 //
                 // Identifier
                 //
                 SeAdtParmTypeLuid, Luid
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    (VOID) LsapAdtWriteLog(&AuditParameters);

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed(Status);
    }

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap(TokenUserInformation);
    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtgens.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T G E N S . C
//
// Contents:    RPC server stubs
//
//
// History:     
//   07-January-2000  kumarp        created
//
// Notes:
// - for help on Lsar* function/parameter usage, please see
//   the corresponding Lsap* function in file adtgenp.c
// 
//------------------------------------------------------------------------

#include <lsapch2.h>
#include "adtp.h"

#include "adtgen.h"
#include "adtgenp.h"

NTSTATUS
LsarRegisterAuditEvent(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT PHANDLE phAuditContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    Status = LsapRegisterAuditEvent( pAuditEventType, phAuditContext );

    return Status;
}

NTSTATUS
LsarGenAuditEvent(
    IN  HANDLE        hAuditContext,
    IN  DWORD         Flags,
    OUT PAUDIT_PARAMS pAuditParams
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = LsapGenAuditEvent( hAuditContext, Flags, pAuditParams, NULL );

    return Status;
}

NTSTATUS
LsarUnregisterAuditEvent(
    IN OUT PHANDLE phAuditContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    Status = LsapUnregisterAuditEvent( phAuditContext );

    return Status;
}


NTSTATUS
LsarAdtRegisterSecurityEventSource(
    IN  DWORD dwFlags,
    IN  PSECURITY_SOURCE_NAME szEventSourceName,
    OUT PSECURITY_SOURCE_HANDLE phSecuritySource
    )
{
    NTSTATUS Status;
    
    Status = LsapAdtRegisterSecurityEventSource(
                 dwFlags,
                 szEventSourceName,
                 phSecuritySource
                 );

    return Status;
}

NTSTATUS
LsarAdtUnregisterSecurityEventSource(
    IN DWORD dwFlags,
    IN OUT PSECURITY_SOURCE_HANDLE phSecuritySource
    )
{
    NTSTATUS Status;
    
    Status = LsapAdtUnregisterSecurityEventSource(
                 dwFlags,
                 phSecuritySource
                 );

    return Status;
}

NTSTATUS
LsarAdtReportSecurityEvent(
    DWORD dwFlags,       
    SECURITY_SOURCE_HANDLE hSource,
    DWORD dwAuditId,
    SID* pSid,
    PAUDIT_PARAMS pParams 
    )
{
    NTSTATUS Status;

    Status = LsapAdtReportSecurityEvent(
                 dwFlags,
                 hSource,
                 dwAuditId,
                 pSid,
                 pParams
                 );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtifn.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtifn.c

Abstract:

    This file has functions exported to other trusted modules in LSA.
    (LsaIAudit* functions)

Author:

    16-August-2000  kumarp

--*/

#include <lsapch2.h>
#include "adtp.h"
#include "adtutil.h"
#include <md5.h>
#include <msobjs.h>


//
// local helper routines for filling in audit params
// from SAM's extended attributes.
//

VOID
LsapAdtAppendDomainAttrValues(
    IN OUT PSE_ADT_PARAMETER_ARRAY pParameters,
    IN     PLSAP_AUDIT_DOMAIN_ATTR_VALUES pAttributes OPTIONAL
    );

VOID
LsapAdtAppendUserAttrValues(
    IN OUT PSE_ADT_PARAMETER_ARRAY pParameters,
    IN     PLSAP_AUDIT_USER_ATTR_VALUES pAttributes OPTIONAL,
    IN     BOOL MachineAudit
    );

VOID
LsapAdtAppendGroupAttrValues(
    IN OUT PSE_ADT_PARAMETER_ARRAY pParameters,
    IN     PLSAP_AUDIT_GROUP_ATTR_VALUES pAttributes OPTIONAL
    );


//
// LSA interface functions.
//

NTSTATUS
LsaIGetLogonGuid(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain,
    IN PBYTE pBuffer,
    IN UINT BufferSize,
    OUT LPGUID pLogonGuid
    )
/*++

Routine Description:

    Concatenate pUserName->Buffer, pUserDomain->Buffer and pBuffer
    into a single binary buffer. Get a MD5 hash of this concatenated
    buffer and return it in the form of a GUID.

Arguments:

    pUserName   - name of user

    pUserDomain - name of user domain 

    pBuffer     - pointer to KERB_TIME structure. The caller casts this to 
                  PBYTE and passes this to us. This allows us to keep KERB_TIME
                  structure private to kerberos and offer future extensibility,
                  should we decide to use another field from the ticket.

    BufferSize  - size of buffer (currently sizeof(KERB_TIME))

    pLogonGuid  - pointer to returned logon GUID

Return Value:

    NTSTATUS    - Standard Nt Result Code

Notes:

    The generated GUID is recorded in the audit log in the form of
    'Logon GUID' field in the following events:
    * On client machine
      -- SE_AUDITID_LOGON_USING_EXPLICIT_CREDENTIALS

    * On KDC
      -- SE_AUDITID_TGS_TICKET_REQUEST

    * On target server
      -- SE_AUDITID_NETWORK_LOGON
      -- SE_AUDITID_SUCCESSFUL_LOGON

    This allows us to correlate these events to aid in intrusion detection.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UINT TempBufferLength=0;
    //
    // LSAI_TEMP_MD5_BUFFER_SIZE == UNLEN + DNS_MAX_NAME_LENGTH + sizeof(KERB_TIME) + padding
    //
#define LSAI_TEMP_MD5_BUFFER_SIZE    (256+256+16)
    BYTE TempBuffer[LSAI_TEMP_MD5_BUFFER_SIZE];
    MD5_CTX MD5Context = { 0 };
        
    ASSERT( LsapIsValidUnicodeString( pUserName ) );
    ASSERT( LsapIsValidUnicodeString( pUserDomain ) );
    ASSERT( pBuffer && BufferSize );
    
#if DBG
//      DbgPrint("LsaIGetLogonGuid: user: %wZ\\%wZ, buf: %I64x\n",
//               pUserDomain, pUserName, *((ULONGLONG *) pBuffer));
#endif

    TempBufferLength = pUserName->Length + pUserDomain->Length + BufferSize;

    if ( TempBufferLength < LSAI_TEMP_MD5_BUFFER_SIZE )
    {
        //
        // first concatenate user+domain+buffer and treat that as
        // a contiguous buffer.
        //
        RtlCopyMemory( TempBuffer, pUserName->Buffer, pUserName->Length );
        TempBufferLength = pUserName->Length;
        
        RtlCopyMemory( TempBuffer + TempBufferLength,
                       pUserDomain->Buffer, pUserDomain->Length );
        TempBufferLength += pUserDomain->Length;

        RtlCopyMemory( TempBuffer + TempBufferLength,
                       pBuffer, BufferSize );
        TempBufferLength += BufferSize;

        //
        // get MD5 hash of the concatenated buffer
        //
        MD5Init( &MD5Context );
        MD5Update( &MD5Context, TempBuffer, TempBufferLength );
        MD5Final( &MD5Context );

        //
        // return the hash as a GUID
        //
        RtlCopyMemory( pLogonGuid, MD5Context.digest, 16 );

        Status = STATUS_SUCCESS;
    }
    else
    {
        ASSERT( FALSE && "LsaIGetLogonGuid: TempBuffer overflow");
        Status = STATUS_BUFFER_OVERFLOW;
    }

    return Status;
}


VOID
LsaIAuditKerberosLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId,
    IN LPGUID LogonGuid,
    IN PLSA_ADT_STRING_LIST TransittedServices
    )
/*++

Routine Description/Arguments/Return value

    See header comment for LsapAuditLogonHelper

Notes:
    A new field (logon GUID) was added to this audit event.
    In order to send this new field to LSA, we had two options:
      1) add new function (AuditLogonEx) to LSA dispatch table
      2) define a private (LsaI) function to do the job

    option#2 was chosen because the logon GUID is a Kerberos only feature.
    
--*/
{
    LsapAuditLogonHelper(
        LogonStatus,
        LogonSubStatus,
        AccountName,
        AuthenticatingAuthority,
        WorkstationName,
        UserSid,
        LogonType,
        TokenSource,
        LogonId,
        LogonGuid,
        NULL,                   // caller logon-ID
        NULL,                   // caller process-ID
        TransittedServices
        );
}


NTSTATUS
LsaIAuditLogonUsingExplicitCreds(
    IN USHORT          AuditEventType,
    IN PLUID           pUser1LogonId,
    IN LPGUID          pUser1LogonGuid,  OPTIONAL
    IN HANDLE          User1ProcessId,
    IN PUNICODE_STRING pUser2Name,
    IN PUNICODE_STRING pUser2Domain,
    IN LPGUID          pUser2LogonGuid,
    IN PUNICODE_STRING pTargetName,      OPTIONAL
    IN PUNICODE_STRING pTargetInfo       OPTIONAL
    )
/*++

Routine Description:

    This event is generated by Kerberos package when a logged on user
    (pUser1*) supplies explicit credentials of another user (pUser2*) and
    creates a new logon session either locally or on a remote machine.

Parmeters:

    AuditEventType   - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    pUser1LogonId    - logon-id of user1

    pUser1LogonGuid  - logon GUID of user1
                       This is NULL if user1 logged on using NTLM.
                       (NTLM does not support logon GUID)

    pUser2Name       - name of user2
                       NULL ==> ANONYMOUS

    pUser2Domain     - domain of user2

    pUser2LogonGuid  - logon-id of user2

    pTargetName      - name of the logon target machine

    pTargetInfo      - additional info (such as SPN) of the target

Return Value:

    NTSTATUS    - Standard Nt Result Code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    BOOLEAN bAudit;
    PSID pUser1Sid = NULL;
    PUNICODE_STRING pUser1Name = NULL;
    PUNICODE_STRING pUser1Domain = NULL;
    UNICODE_STRING usUser2Name = {0};
    UNICODE_STRING usUser2Domain = {0};
    PLSAP_LOGON_SESSION pUser1LogonSession = NULL;
    GUID NullGuid = { 0 };
    LUID LocalSystemLuid = SYSTEM_LUID;
    LUID AnonymousLuid = ANONYMOUS_LOGON_LUID;
    PLSA_CALL_INFO  pCallInfo;
    SOCKADDR* pSockAddr = NULL;

    //
    // get the IP address/port of the caller
    //

    pCallInfo = LsapGetCurrentCall();
    DsysAssertMsg( pCallInfo != NULL, "LsapAuditLogon" );

    pSockAddr = (SOCKADDR*) pCallInfo->IpAddress;
    

    ASSERT( pUser1LogonId );

    if ( pTargetName )
    {
        ASSERT( pTargetName->Buffer   && pTargetName->Length );
    }

    if ( pTargetInfo )
    {
        ASSERT( pTargetInfo->Buffer   && pTargetInfo->Length );
    }

    //
    // if policy is not enabled then return quickly.
    //

    Status = LsapAdtAuditingEnabledByLogonId( 
                 AuditCategoryLogon, 
                 pUser1LogonId, 
                 AuditEventType, 
                 &bAudit);
    
    if (!NT_SUCCESS(Status) || !bAudit) 
    {
        goto Cleanup;
    }

    //
    // Sanity check the strings we got passed since they might come from
    // NTLM and not be validated yet.
    //

    if (pUser2Name)
    {
        usUser2Name = *pUser2Name;
        usUser2Name.Length =
            (USHORT)LsapSafeWcslen(usUser2Name.Buffer,
                                   usUser2Name.MaximumLength);
    }
    pUser2Name = &usUser2Name;

    if (pUser2Domain)
    {
        usUser2Domain = *pUser2Domain;
        usUser2Domain.Length =
            (USHORT)LsapSafeWcslen(usUser2Domain.Buffer,
                                   usUser2Domain.MaximumLength);
    }
    pUser2Domain = &usUser2Domain;

    //
    // Locate the logon-session of user1 so that we can obtain
    // name/domain/sid info from it.
    //

    pUser1LogonSession = LsapLocateLogonSession( pUser1LogonId );

    if ( pUser1LogonSession )
    {
        pUser1Sid    = pUser1LogonSession->UserSid;
        pUser1Name   = &pUser1LogonSession->AccountName;
        pUser1Domain = &pUser1LogonSession->AuthorityName;

        //
        // We have implicit credentials if:
        //  1) UserName and DomainName are NULL
        //  2) and logon type is not NewCredentials
        //

        if (!pUser2Name->Buffer && !pUser2Domain->Buffer)
        {
            if (pUser1LogonSession->LogonType == NewCredentials)
            {
                pUser2Name = &pUser1LogonSession->NewAccountName;
                pUser2Domain = &pUser1LogonSession->NewAuthorityName;
            }
            else
            {
                // not an explict cred
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }
        }

        //
        // Handle ambiguous credentials where NTLM supplies NULL username or
        // domain name.
        //

        if (!pUser2Name->Buffer) 
        {
            pUser2Name = &pUser1LogonSession->AccountName;
        }

        if (!pUser2Domain->Buffer) 
        {
            pUser2Domain = &pUser1LogonSession->AuthorityName;
        }

        //
        // This is an additional check to see whether we are dealing with implicit creds.
        // It works well for NTLM but might not catch all instances with Kerberos where
        // DNS names are preferred.
        //

        if (RtlEqualUnicodeString(pUser2Name, &pUser1LogonSession->AccountName, TRUE) 
            && RtlEqualUnicodeString(pUser2Domain, &pUser1LogonSession->AuthorityName, TRUE)) 
        {
            // not an explict cred
            Status = STATUS_SUCCESS;
            goto Cleanup;           
        }

        if ( pUser1LogonGuid &&
             memcmp( pUser1LogonGuid, &NullGuid, sizeof(GUID)) )
        {
            //
            // if the logon GUID in the logon session is null and
            // if the passed logon GUID is not null
            // update its value using what is passed to this function
            //

            if ( !memcmp( &pUser1LogonSession->LogonGuid, &NullGuid, sizeof(GUID)))
            {
                Status = LsaISetLogonGuidInLogonSession(
                             pUser1LogonId,
                             pUser1LogonGuid
                             );
            }
        }
        else
        {
            pUser1LogonGuid = &pUser1LogonSession->LogonGuid;
        }
    }


    //
    // skip the audits for local-system changing to local/network service
    //

    if ( RtlEqualLuid( pUser1LogonId, &LocalSystemLuid ) &&
         LsapIsLocalOrNetworkService( pUser2Name, pUser2Domain ) )
    {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // skip the audits for anonymous changing to anonymous
    //
    // for anonymous user, the passed name/domain is null/empty
    // 

    if ( RtlEqualLuid( pUser1LogonId, &AnonymousLuid ) )
    {
        if  (((!pUser2Name || !pUser2Name->Length) && (!pUser2Domain || !pUser2Domain->Length)) ||
            LsapIsAnonymous(pUser2Name, pUser2Domain))
        {
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }
    }
    
    Status =
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_LOGON,
        SE_AUDITID_LOGON_USING_EXPLICIT_CREDENTIALS,
        AuditEventType,
        11,                     // there are 11 params to init

        //
        //    User Sid
        //    
        SeAdtParmTypeSid,        pUser1Sid ? pUser1Sid : LsapLocalSystemSid,

        //
        //    Subsystem name
        //
        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    current user logon id
        //
        SeAdtParmTypeLogonId,    *pUser1LogonId,

        //
        //    user1 logon GUID
        //
        SeAdtParmTypeGuid,       pUser1LogonGuid,

        //
        //    user2 name
        //
        SeAdtParmTypeString,     pUser2Name,

        //
        //    user2 domain name
        //
        SeAdtParmTypeString,     pUser2Domain,

        //
        //    user2 logon GUID
        //
        SeAdtParmTypeGuid,       pUser2LogonGuid,

        //
        //    target server name
        //
        SeAdtParmTypeString,     pTargetName,

        //
        //    target server info (such as SPN)
        //
        SeAdtParmTypeString,     pTargetInfo,

        //
        //    Caller Process ID
        //                   
        SeAdtParmTypePtr,        User1ProcessId,

        //
        //    IP address/port info
        //
        SeAdtParmTypeSockAddr,   pSockAddr

        );
    
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    ( VOID ) LsapAdtWriteLog( &AuditParameters );

    
Cleanup:

    if ( pUser1LogonSession )
    {
        LsapReleaseLogonSession( pUser1LogonSession );
    }

    if (!NT_SUCCESS(Status)) {

        LsapAuditFailed( Status );
    }

    return Status;
}


NTSTATUS
LsaIAdtAuditingEnabledByCategory(
    IN  POLICY_AUDIT_EVENT_TYPE Category,
    IN  USHORT                  AuditEventType,
    IN  PSID                    pUserSid        OPTIONAL,
    IN  PLUID                   pLogonId        OPTIONAL,
    OUT PBOOLEAN                pbAudit
    )
/*++

Routine Description:

    Returns whether auditing is enabled for the given category - event
    type - user combination. The user can be supplied as sid or logon id.
    If none is supplied, the general settings (not user specific) are returned.
    If both are supplied, the sid takes precedence and the logon id is ignored.

Parmeters:

    Category         - Category to be queried

    AuditEventType   - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    pUserSid         - sid of user

    pLogonId         - logon-id of user

    pbAudit          - returns whether auditing is enabled for the requested parameters

Return Value:

    NTSTATUS    - Standard Nt Result Code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (pUserSid)
    {
        Status = LsapAdtAuditingEnabledBySid(
                     Category,
                     pUserSid,
                     AuditEventType,
                     pbAudit
                     );
    }
    else if (pLogonId)
    {
        Status = LsapAdtAuditingEnabledByLogonId(
                     Category,
                     pLogonId,
                     AuditEventType,
                     pbAudit
                     );
    }
    else
    {
        *pbAudit = LsapAdtAuditingEnabledByCategory(
                     Category,
                     AuditEventType
                     );
    }

    return Status;
}


NTSTATUS
LsaIAuditKdcEvent(
    IN ULONG                 AuditId,
    IN PUNICODE_STRING       ClientName,
    IN PUNICODE_STRING       ClientDomain,
    IN PSID                  ClientSid,
    IN PUNICODE_STRING       ServiceName,
    IN PSID                  ServiceSid,
    IN PULONG                KdcOptions,
    IN PULONG                KerbStatus,
    IN PULONG                EncryptionType,
    IN PULONG                PreauthType,
    IN PBYTE                 ClientAddress,
    IN LPGUID                LogonGuid           OPTIONAL,
    IN PLSA_ADT_STRING_LIST  TransittedServices  OPTIONAL,
    IN PUNICODE_STRING       CertIssuerName      OPTIONAL,
    IN PUNICODE_STRING       CertSerialNumber    OPTIONAL,
    IN PUNICODE_STRING       CertThumbprint      OPTIONAL
    )

/*++

Abstract:

    This routine produces an audit record representing a KDC
    operation.

    This routine goes through the list of parameters and adds a string
    representation of each (in order) to an audit message.  Note that
    the full complement of account audit message formats is achieved by
    selecting which optional parameters to include in this call.

    In addition to any parameters passed below, this routine will ALWAYS
    add the impersonation client's user name, domain, and logon ID as
    the LAST parameters in the audit message.


Parmeters:

    AuditId - Specifies the message ID of the audit being generated.

    ClientName -

    ClientDomain -

    ClientSid -

    ServiceName -

    ServiceSid -

    KdcOptions -

    KerbStatus -

    EncryptionType -

    PreauthType -

    ClientAddress -

    LogonGuid -

    TransittedServices -

    CertIssuerName -

    CertSerialNumber -

    CertThumbprint -

--*/

{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    UNICODE_STRING AddressString;
    WCHAR AddressBuffer[3*4+4];         // space for a dotted-quad IP address
    NTSTATUS Status;
    BOOLEAN bAudit;

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_ACCOUNT_LOGON;
    AuditParameters.AuditId = AuditId;
    AuditParameters.Type = ((ARGUMENT_PRESENT(KerbStatus) &&
                            (*KerbStatus != 0)) ?
                                EVENTLOG_AUDIT_FAILURE :
                                EVENTLOG_AUDIT_SUCCESS );

    Status = LsapAdtAuditingEnabledBySid(
                  AuditCategoryAccountLogon,
                 ClientSid ? ClientSid : LsapLocalSystemSid,
                 AuditParameters.Type,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit) 
    {
        goto Cleanup;
    }

    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid );

    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );

    AuditParameters.ParameterCount++;

    if (ARGUMENT_PRESENT(ClientName)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, ClientName );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(ClientDomain)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, ClientDomain );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(ClientSid)) {

        //
        // Add a SID to the audit message
        //

        LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, ClientSid );

        AuditParameters.ParameterCount++;

    } else if (AuditId == SE_AUDITID_AS_TICKET) {

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(ServiceName)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, ServiceName );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(ServiceSid)) {

        //
        // Add a SID to the audit message
        //

        LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, ServiceSid );

        AuditParameters.ParameterCount++;

    } else if (AuditId == SE_AUDITID_AS_TICKET || AuditId == SE_AUDITID_TGS_TICKET_REQUEST) {

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(KdcOptions)) {

        //
        // Add a ULONG to the audit message
        //

        LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, *KdcOptions );

        AuditParameters.ParameterCount++;

    }

    //
    // Failure code is the last parameter for SE_AUDITID_TGS_TICKET_REQUEST
    //

    if (AuditId != SE_AUDITID_TGS_TICKET_REQUEST)
    {
        if (ARGUMENT_PRESENT(KerbStatus)) {

            //
            // Add a ULONG to the audit message
            //

            LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, *KerbStatus );

            AuditParameters.ParameterCount++;

        } else if (AuditId == SE_AUDITID_AS_TICKET) {

            AuditParameters.ParameterCount++;

        }
    }

    if (ARGUMENT_PRESENT(EncryptionType)) {

        //
        // Add a ULONG to the audit message
        //

        LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, *EncryptionType );

        AuditParameters.ParameterCount++;

    } else if (AuditId == SE_AUDITID_AS_TICKET || AuditId == SE_AUDITID_TGS_TICKET_REQUEST) {

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(PreauthType)) {

        //
        // Add a ULONG to the audit message
        //

        LsapSetParmTypeUlong( AuditParameters, AuditParameters.ParameterCount, *PreauthType );

        AuditParameters.ParameterCount++;

    } else if (AuditId == SE_AUDITID_AS_TICKET) {

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(ClientAddress)) {

        AddressBuffer[0] = L'\0';
        swprintf(AddressBuffer,L"%d.%d.%d.%d",
            ClientAddress[0],
            (ULONG) ClientAddress[1],
            (ULONG) ClientAddress[2],
            (ULONG) ClientAddress[3]
            );
        RtlInitUnicodeString(
            &AddressString,
            AddressBuffer
            );

        //
        // IP address
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &AddressString );

        AuditParameters.ParameterCount++;

    }

    //
    // Transitted Services is the last parameter for SE_AUDITID_TGS_TICKET_REQUEST
    //

    if (AuditId == SE_AUDITID_TGS_TICKET_REQUEST)
    {
        if (ARGUMENT_PRESENT(KerbStatus)) {

            //
            // Add a ULONG to the audit message
            //

            LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, *KerbStatus );

            AuditParameters.ParameterCount++;

        } else {

            AuditParameters.ParameterCount++;

        }

        if (ARGUMENT_PRESENT(LogonGuid)) {

            //
            // Add the globally unique logon-id to the audit message
            //

            LsapSetParmTypeGuid( AuditParameters, AuditParameters.ParameterCount, LogonGuid );

            AuditParameters.ParameterCount++;

        }
        else {

            if (( AuditParameters.Type == EVENTLOG_AUDIT_SUCCESS ) &&
                ( AuditId == SE_AUDITID_TGS_TICKET_REQUEST )) {

                ASSERT( FALSE && L"LsaIAuditKdcEvent: UniqueID not supplied to successful SE_AUDITID_TGS_TICKET_REQUEST  audit event" );
            }

            AuditParameters.ParameterCount++;

        }

        if (ARGUMENT_PRESENT(TransittedServices)) {

            //
            // Transitted Services
            //

            LsapSetParmTypeStringList( AuditParameters, AuditParameters.ParameterCount, TransittedServices );
        }

        AuditParameters.ParameterCount++;

    } else if (AuditId == SE_AUDITID_AS_TICKET) {

        if (ARGUMENT_PRESENT(CertIssuerName)) {

            //
            // Certificate Issuer Name
            //

            LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, CertIssuerName );
        }

        AuditParameters.ParameterCount++;


        if (ARGUMENT_PRESENT(CertSerialNumber)) {

            //
            // Certificate Serial Number
            //

            LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, CertSerialNumber );
        }

        AuditParameters.ParameterCount++;


        if (ARGUMENT_PRESENT(CertThumbprint)) {

            //
            // Certificate Thumbprint
            //

            LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, CertThumbprint );
        }

        AuditParameters.ParameterCount++;
    }


    //
    // Now write out the audit record to the audit log
    //

    ( VOID ) LsapAdtWriteLog( &AuditParameters );

Cleanup:

    if (!NT_SUCCESS(Status)) {
        LsapAuditFailed(Status);
    }

    return Status;
}




NTSTATUS
LsaIAuditAccountLogon(
    IN ULONG                AuditId,
    IN BOOLEAN              Successful,
    IN PUNICODE_STRING      Source,
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      MappedName,
    IN NTSTATUS             LogonStatus
    )
{
    return LsaIAuditAccountLogonEx(
               AuditId,
               Successful,
               Source,
               ClientName,
               MappedName,
               LogonStatus,
               NULL             // client SID
               );
               
}



NTSTATUS
LsaIAuditAccountLogonEx(
    IN ULONG                AuditId,
    IN BOOLEAN              Successful,
    IN PUNICODE_STRING      Source,
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      MappedName,
    IN NTSTATUS             LogonStatus,
    IN PSID                 ClientSid
    )
/*++

Abstract:

    This routine produces an audit record representing the mapping of a
    foreign principal name onto an NT account.

    This routine goes through the list of parameters and adds a string
    representation of each (in order) to an audit message.  Note that
    the full complement of account audit message formats is achieved by
    selecting which optional parameters to include in this call.


Parmeters:

    AuditId    - Specifies the message ID of the audit being generated.

    Successful - Indicates the code should generate a success audit

    Source     - Source module generating audit, such as SCHANNEL or KDC

    ClientName - Name being mapped.

    MappedName - Name of NT account to which the client name was mapped.

    LogonStatus- NT Status code for any failures.

    ClientSid  - SID of the client


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN bAudit = FALSE;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    UNICODE_STRING LocalClientName;
    UNICODE_STRING LocalMappedName;
        
    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_ACCOUNT_LOGON;
    AuditParameters.AuditId = AuditId;
    AuditParameters.Type = Successful ?
                                EVENTLOG_AUDIT_SUCCESS :
                                EVENTLOG_AUDIT_FAILURE ;

    if ( ClientSid )
    {
        //
        // if the client SID is specified use it for checking pua policy
        //

        Status = LsapAdtAuditingEnabledBySid(
                     AuditCategoryAccountLogon,
                     ClientSid,
                     AuditParameters.Type,
                     &bAudit
                     );

        if (!NT_SUCCESS(Status) || !bAudit) 
        {
            goto Cleanup;
        }
        
    }
    else
    {
        //
        // if the client SID is not supplied, check the global policy
        //

        if (AuditParameters.Type == EVENTLOG_AUDIT_SUCCESS) {
            if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategoryAccountLogon] & POLICY_AUDIT_EVENT_SUCCESS)) {
                return( STATUS_SUCCESS );
            }
        } else {
            if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategoryAccountLogon] & POLICY_AUDIT_EVENT_FAILURE)) {
                return( STATUS_SUCCESS );
            }
        }
    }
    

    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, ClientSid ? ClientSid : LsapLocalSystemSid );

    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );

    AuditParameters.ParameterCount++;

    if (ARGUMENT_PRESENT(Source)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, Source );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(ClientName)) {

        //
        // Add a UNICODE_STRING to the audit message
        //


        LocalClientName = *ClientName;

        if ( !Successful ) {

            //
            // For failed logons the client name can be invalid (for example,
            // with embedded NULLs). This causes the
            // eventlog to reject the string and we drop the audit.
            //
            // To avoid this, adjust the length parameter if necessary.
            //

            LocalClientName.Length =
                (USHORT) LsapSafeWcslen( LocalClientName.Buffer,
                                         LocalClientName.MaximumLength );
        
        }

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LocalClientName );

        AuditParameters.ParameterCount++;

    }


    if (ARGUMENT_PRESENT(MappedName)) {

        //
        // Add MappedName to the audit message
        //
        // This is somewhat overloaded. For SE_AUDITID_ACCOUNT_LOGON, the
        // caller passes the workstation name in this param.
        //
        // The workstation name can be invalid (for example,
        // with embedded NULLs). This causes the
        // eventlog to reject the string and we drop the audit.
        //
        // To avoid this, adjust the length parameter if necessary.
        //


        LocalMappedName = *MappedName;

        LocalMappedName.Length =
            (USHORT) LsapSafeWcslen( LocalMappedName.Buffer,
                                     LocalMappedName.MaximumLength );
        

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LocalMappedName );

        AuditParameters.ParameterCount++;

    }

    //
    // Add a ULONG to the audit message
    //

    LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, LogonStatus );

    AuditParameters.ParameterCount++;


    //
    // Now write out the audit record to the audit log
    //

    ( VOID ) LsapAdtWriteLog( &AuditParameters );

 Cleanup:

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed(Status);
    }
    
    return Status;

}


NTSTATUS NTAPI
LsaIAuditDPAPIEvent(
    IN ULONG                AuditId,
    IN PSID                 UserSid,
    IN PUNICODE_STRING      MasterKeyID,
    IN PUNICODE_STRING      RecoveryServer,
    IN PULONG               Reason,
    IN PUNICODE_STRING      RecoverykeyID,
    IN PULONG               FailureReason
    )
/*++

Abstract:

    This routine produces an audit record representing a DPAPI
    operation.

    This routine goes through the list of parameters and adds a string
    representation of each (in order) to an audit message.  Note that
    the full complement of account audit message formats is achieved by
    selecting which optional parameters to include in this call.

    In addition to any parameters passed below, this routine will ALWAYS
    add the impersonation client's user name, domain, and logon ID as
    the LAST parameters in the audit message.


Parmeters:

    AuditId - Specifies the message ID of the audit being generated.


    MasterKeyID -

    RecoveryServer -

    Reason -

    RecoverykeyID -

    FailureReason -


--*/

{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    NTSTATUS Status;
    BOOLEAN bAudit;

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_DETAILED_TRACKING;
    AuditParameters.AuditId = AuditId;
    AuditParameters.Type = ((ARGUMENT_PRESENT(FailureReason) &&
                            (*FailureReason != 0)) ?
                                EVENTLOG_AUDIT_FAILURE :
                                EVENTLOG_AUDIT_SUCCESS );

    Status = LsapAdtAuditingEnabledBySid(
                 AuditCategoryDetailedTracking,
                 UserSid,
                 AuditParameters.Type,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit) 
    {
        goto Cleanup;
    }

    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid ? UserSid : LsapLocalSystemSid );

    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );

    AuditParameters.ParameterCount++;

    if (ARGUMENT_PRESENT(MasterKeyID)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, MasterKeyID );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(RecoveryServer)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, RecoveryServer );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(Reason)) {

        //
        // Add a ULONG to the audit message
        //

        LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, *Reason );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(RecoverykeyID)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, RecoverykeyID );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(FailureReason)) {

        //
        // Add a ULONG to the audit message
        //

        LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, *FailureReason );

        AuditParameters.ParameterCount++;

    }

    //
    // Now write out the audit record to the audit log
    //

    ( VOID ) LsapAdtWriteLog( &AuditParameters );
    
Cleanup:
    
    if (!NT_SUCCESS(Status)) 
    {
        LsapAuditFailed(Status);
    }
    
    return Status;

}



NTSTATUS
LsaIWriteAuditEvent(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters,
    IN ULONG Options
    )
/*++

Abstract:

    This routine writes an audit record to the log. 


Parmeters:

    AuditParameters - The audit record
    Options         - must be zero

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN bAudit  = FALSE;
    POLICY_AUDIT_EVENT_TYPE CategoryId;
    
    if ( !ARGUMENT_PRESENT(AuditParameters) ||
         (Options != 0)                     ||
         !IsValidCategoryId( AuditParameters->CategoryId ) ||
         !IsValidAuditId( AuditParameters->AuditId )       ||
         !IsValidParameterCount( AuditParameters->ParameterCount ) ||
         (AuditParameters->Parameters[0].Type != SeAdtParmTypeSid) ||
         (AuditParameters->Parameters[1].Type != SeAdtParmTypeString))
    {
        return STATUS_INVALID_PARAMETER;
    }
    

    //
    // LsapAdtEventsInformation.EventAuditingOptions needs to be indexed
    // by one of enum POLICY_AUDIT_EVENT_TYPE values whereas the value
    // of SE_ADT_PARAMETER_ARRAY.CategoryId must be one of SE_CATEGID_*
    // values. The value of corresponding elements in the two types differ by 1. 
    // Subtract 1 from AuditParameters->CategoryId to get the right
    // AuditCategory* value.
    //

    CategoryId = AuditParameters->CategoryId - 1;

    Status = LsapAdtAuditingEnabledBySid(
                 CategoryId,
                 (PSID) AuditParameters->Parameters[0].Address,
                 AuditParameters->Type,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit) {

        goto Cleanup;
    }

    //
    // Audit the event
    //

    Status = LsapAdtWriteLog( AuditParameters );

 Cleanup:

    return Status;
}



NTSTATUS
LsaIAuditNotifyPackageLoad(
    PUNICODE_STRING PackageFileName
    )

/*++

Routine Description:

    Audits the loading of an notification package.

Arguments:

    PackageFileName - The name of the package being loaded.

Return Value:

    NTSTATUS.

--*/

{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    NTSTATUS Status;
    BOOLEAN bAudit;

    Status = LsapAdtAuditingEnabledBySid(
                 AuditCategorySystem,
                 LsapLocalSystemSid,
                 EVENTLOG_AUDIT_SUCCESS,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit) {
        goto Cleanup;
    }

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_SYSTEM;
    AuditParameters.AuditId = SE_AUDITID_NOTIFY_PACKAGE_LOAD;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, PackageFileName );
    AuditParameters.ParameterCount++;

    ( VOID ) LsapAdtWriteLog( &AuditParameters );

Cleanup:
    
    if (!NT_SUCCESS(Status)) {
        LsapAuditFailed(Status);
    }
    return Status;
}


NTSTATUS
LsaIAuditSamEvent(
    IN NTSTATUS             PassedStatus,
    IN ULONG                AuditId,
    IN PSID                 DomainSid,
    IN PUNICODE_STRING      AdditionalInfo    OPTIONAL,
    IN PULONG               MemberRid         OPTIONAL,
    IN PSID                 MemberSid         OPTIONAL,
    IN PUNICODE_STRING      AccountName       OPTIONAL,
    IN PUNICODE_STRING      DomainName,
    IN PULONG               AccountRid        OPTIONAL,
    IN PPRIVILEGE_SET       Privileges        OPTIONAL,
    IN PVOID                ExtendedInfo      OPTIONAL
    )
/*++

Abstract:

    This routine produces an audit record representing an account
    operation.

    This routine goes through the list of parameters and adds a string
    representation of each (in order) to an audit message.  Note that
    the full complement of account audit message formats is achieved by
    selecting which optional parameters to include in this call.

    In addition to any parameters passed below, this routine will ALWAYS
    add the impersonation client's user name, domain, and logon ID as
    the LAST parameters in the audit message.


Parmeters:

    AuditId - Specifies the message ID of the audit being generated.

    DomainSid - This parameter results in a SID string being generated
        ONLY if neither the MemberRid nor AccountRid parameters are
        passed.  If either of those parameters are passed, this parameter
        is used as a prefix of a SID.

    AdditionalInfo - This optional parameter, if present, is used to
        produce any additional inforamtion the caller wants to add.
        Used by SE_AUDITID_USER_CHANGE and SE_AUDITID_GROUP_TYPE_CHANGE.
        for user change, the additional info states the nature of the
        change, such as Account Disable, unlocked or account Name Changed.
        For Group type change, this parameter should state the group type
        has been change from AAA to BBB.

    MemberRid - This optional parameter, if present, is added to the end of
        the DomainSid parameter to produce a "Member" sid.  The resultant
        member SID is then used to build a sid-string which is added to the
        audit message following all preceeding parameters.
        This parameter supports global group membership change audits, where
        member IDs are always relative to a local domain.

    MemberSid - This optional parameter, if present, is converted to a
        SID string and added following preceeding parameters.  This parameter
        is generally used for describing local group (alias) members, where
        the member IDs are not relative to a local domain.

    AccountName - This optional parameter, if present, is added to the audit
        message without change following any preceeding parameters.
        This parameter is needed for almost all account audits and does not
        need localization.

    DomainName - This optional parameter, if present, is added to the audit
        message without change following any preceeding parameters.
        This parameter is needed for almost all account audits and does not
        need localization.


    AccountRid - This optional parameter, if present, is added to the end of
        the DomainSid parameter to produce an "Account" sid.  The resultant
        Account SID is then used to build a sid-string which is added to the
        audit message following all preceeding parameters.
        This parameter supports audits that include "New account ID" or
        "Target Account ID" fields.

    Privileges - The privileges passed via this optional parameter,
        if present, will be converted to string format and added to the
        audit message following any preceeding parameters.  NOTE: the
        caller is responsible for freeing the privilege_set (in fact,
        it may be on the stack).  ALSO NOTE: The privilege set will be
        destroyed by this call (due to use of the routine used to
        convert the privilege values to privilege names).

    ExtendedInfo - Pointer to an optional parameter containing extended
        information about attributes of sam objects. This parameter gets typecast
        to a structure describing the attributes, depending on the audit id.

--*/

{

    NTSTATUS Status;
    LUID LogonId = SYSTEM_LUID;
    PSID NewAccountSid = NULL;
    PSID NewMemberSid = NULL;
    PSID SidPointer;
    PSID ClientSid = NULL;
    PTOKEN_USER TokenUserInformation = NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    UCHAR AccountSidBuffer[256];
    UCHAR MemberSidBuffer[256];
    UCHAR SubAuthorityCount;
    ULONG LengthRequired;
    BOOLEAN bAudit;

    if ( AuditId == SE_AUDITID_ACCOUNT_AUTO_LOCKED )
    {
        
        //
        // In this case use LogonID as SYSTEM, SID is SYSTEM.
        //

        ClientSid = LsapLocalSystemSid;

    } else {

        Status = LsapQueryClientInfo(
                     &TokenUserInformation,
                     &LogonId
                     );

        if ( !NT_SUCCESS( Status )) {
            goto Cleanup;
        }

        ClientSid = TokenUserInformation->User.Sid;
    }

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_ACCOUNT_MANAGEMENT;
    AuditParameters.AuditId = AuditId;
    AuditParameters.Type = (NT_SUCCESS(PassedStatus) ? EVENTLOG_AUDIT_SUCCESS : EVENTLOG_AUDIT_FAILURE );
    AuditParameters.ParameterCount = 0;

    Status = LsapAdtAuditingEnabledByLogonId(
                 AuditCategoryAccountManagement,
                 &LogonId,
                 AuditParameters.Type,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit)
    {
        goto Cleanup;
    }
                 
    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, ClientSid );

    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );

    AuditParameters.ParameterCount++;

    if (ARGUMENT_PRESENT(AdditionalInfo))
    {
        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, AdditionalInfo );

        AuditParameters.ParameterCount++;
    }

    if (ARGUMENT_PRESENT(MemberRid)) {

        //
        // Add a member SID string to the audit message
        //
        //  Domain Sid + Member Rid = Final SID.

        SubAuthorityCount = *RtlSubAuthorityCountSid( DomainSid );

        if ( (LengthRequired = RtlLengthRequiredSid( SubAuthorityCount + 1 )) > 256 ) {

            NewMemberSid = LsapAllocateLsaHeap( LengthRequired );

            if ( NewMemberSid == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            SidPointer = NewMemberSid;

        } else {

            SidPointer = (PSID)MemberSidBuffer;
        }

        Status = RtlCopySid (
                     LengthRequired,
                     SidPointer,
                     DomainSid
                     );

        ASSERT( NT_SUCCESS( Status ));

        *(RtlSubAuthoritySid( SidPointer, SubAuthorityCount )) = *MemberRid;
        *RtlSubAuthorityCountSid( SidPointer ) = SubAuthorityCount + 1;

        LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, SidPointer );

        AuditParameters.ParameterCount++;
    }

    if (ARGUMENT_PRESENT(MemberSid)) {

        //
        // Add a member SID string to the audit message
        //

        LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, MemberSid );

        AuditParameters.ParameterCount++;

    } else {

        if (SE_AUDITID_ADD_SID_HISTORY == AuditId) {
    
            //
            // Add dash ( - ) string to the audit message (SeAdtParmTypeNone)
            // by calling LsapSetParmTypeSid with NULL as third parameter
            //
    
            LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, NULL );
    
            AuditParameters.ParameterCount++;
        }
    }


    if (ARGUMENT_PRESENT(AccountName)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, AccountName );

        AuditParameters.ParameterCount++;
    }


    if (ARGUMENT_PRESENT(DomainName)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, DomainName );

        AuditParameters.ParameterCount++;
    }




    if (ARGUMENT_PRESENT(DomainSid) &&
        !(ARGUMENT_PRESENT(MemberRid) || ARGUMENT_PRESENT(AccountRid))
       ) {

        //
        // Add the domain SID as a SID string to the audit message
        //
        // Just the domain SID.
        //

        LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, DomainSid );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(AccountRid)) {

        //
        // Add a member SID string to the audit message
        // Domain Sid + account Rid = final sid
        //

        SubAuthorityCount = *RtlSubAuthorityCountSid( DomainSid );

        if ( (LengthRequired = RtlLengthRequiredSid( SubAuthorityCount + 1 )) > 256 ) {

            NewAccountSid = LsapAllocateLsaHeap( LengthRequired );

            if ( NewAccountSid == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            SidPointer = NewAccountSid;

        } else {

            SidPointer = (PSID)AccountSidBuffer;
        }


        Status = RtlCopySid (
                     LengthRequired,
                     SidPointer,
                     DomainSid
                     );

        ASSERT( NT_SUCCESS( Status ));

        *(RtlSubAuthoritySid( SidPointer, SubAuthorityCount )) = *AccountRid;
        *RtlSubAuthorityCountSid( SidPointer ) = SubAuthorityCount + 1;

        LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, SidPointer );

        AuditParameters.ParameterCount++;
    }

    //
    // Now add the caller information
    //
    //      Caller name
    //      Caller domain
    //      Caller logon ID
    //


    LsapSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, LogonId );

    AuditParameters.ParameterCount++;

    //
    // Add any privileges
    //

    if (ARGUMENT_PRESENT(Privileges)) {

        LsapSetParmTypePrivileges( AuditParameters, AuditParameters.ParameterCount, Privileges );
    }

    AuditParameters.ParameterCount++;


    //
    // Take care of the extended info.
    //

    switch (AuditId)
    {
    case SE_AUDITID_ADD_SID_HISTORY:

        if (ExtendedInfo)
        {
            LsapSetParmTypeStringList(
                AuditParameters,
                AuditParameters.ParameterCount,
                (PLSA_ADT_STRING_LIST)ExtendedInfo);
        }

        AuditParameters.ParameterCount++;

        break;


    case SE_AUDITID_DOMAIN_POLICY_CHANGE:

        LsapAdtAppendDomainAttrValues(
            &AuditParameters,
            (PLSAP_AUDIT_DOMAIN_ATTR_VALUES)ExtendedInfo);

        break;


    case SE_AUDITID_COMPUTER_CREATED:
    case SE_AUDITID_COMPUTER_CHANGE:

        LsapAdtAppendUserAttrValues(
            &AuditParameters,
            (PLSAP_AUDIT_USER_ATTR_VALUES)ExtendedInfo,
            TRUE);

        break;


    case SE_AUDITID_USER_CREATED:
    case SE_AUDITID_USER_CHANGE:

        LsapAdtAppendUserAttrValues(
            &AuditParameters,
            (PLSAP_AUDIT_USER_ATTR_VALUES)ExtendedInfo,
            FALSE);

        break;


    case SE_AUDITID_LOCAL_GROUP_CREATED:
    case SE_AUDITID_LOCAL_GROUP_CHANGE:
    case SE_AUDITID_GLOBAL_GROUP_CREATED:
    case SE_AUDITID_GLOBAL_GROUP_CHANGE:
    case SE_AUDITID_SECURITY_ENABLED_UNIVERSAL_GROUP_CREATED:
    case SE_AUDITID_SECURITY_ENABLED_UNIVERSAL_GROUP_CHANGE:
    case SE_AUDITID_SECURITY_DISABLED_LOCAL_GROUP_CREATED:
    case SE_AUDITID_SECURITY_DISABLED_LOCAL_GROUP_CHANGE:
    case SE_AUDITID_SECURITY_DISABLED_GLOBAL_GROUP_CREATED:
    case SE_AUDITID_SECURITY_DISABLED_GLOBAL_GROUP_CHANGE:
    case SE_AUDITID_SECURITY_DISABLED_UNIVERSAL_GROUP_CREATED:
    case SE_AUDITID_SECURITY_DISABLED_UNIVERSAL_GROUP_CHANGE:
    case SE_AUDITID_APP_BASIC_GROUP_CREATED:
    case SE_AUDITID_APP_BASIC_GROUP_CHANGE:
    case SE_AUDITID_APP_QUERY_GROUP_CREATED:
    case SE_AUDITID_APP_QUERY_GROUP_CHANGE:

        LsapAdtAppendGroupAttrValues(
            &AuditParameters,
            (PLSAP_AUDIT_GROUP_ATTR_VALUES)ExtendedInfo);

        break;


    case SE_AUDITID_PASSWORD_POLICY_API_CALLED: 
        {
            PUNICODE_STRING *Information = ( PUNICODE_STRING *) ExtendedInfo;
            ULONG i;

            //
            // Parameter count was moved in advance, move
            //  it to its original place.
            //

            AuditParameters.ParameterCount--;

            //
            // Add workstation ip and provided account name if present
            //
            
            for( i = 0; i < 2; ++i ) {
                
                if( Information[i]->Length != 0 ) {

                    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, Information[i] );
                    
                } else {
                
                    AuditParameters.Parameters[AuditParameters.ParameterCount].Type = SeAdtParmTypeNone;
                    AuditParameters.Parameters[AuditParameters.ParameterCount].Length = 0;
                    AuditParameters.Parameters[AuditParameters.ParameterCount].Address = NULL;
                }
                
                AuditParameters.ParameterCount++;
            }

            //
            // Add the status code
            //
            
            LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, PassedStatus );
            AuditParameters.ParameterCount++;

            ASSERTMSG( "There must be 6 parameters! Not more, not less", AuditParameters.ParameterCount == 6 );
        }
        break;

        case SE_AUDITID_DSRM_PASSWORD_SET:
        {
            PUNICODE_STRING String = ( PUNICODE_STRING ) ExtendedInfo;
            
            //
            // Parameter count was moved in advance, move
            //  it to its original place.
            //

            AuditParameters.ParameterCount--;
            if( String->Length != 0 ) {

                LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, String );
                
            } else {
            
                AuditParameters.Parameters[AuditParameters.ParameterCount].Type = SeAdtParmTypeNone;
                AuditParameters.Parameters[AuditParameters.ParameterCount].Length = 0;
                AuditParameters.Parameters[AuditParameters.ParameterCount].Address = NULL;
            }
            AuditParameters.ParameterCount++;

            //
            // Add the status code
            //
            
            LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, PassedStatus );
            AuditParameters.ParameterCount++;
        }
        break;      
        
    }


    //
    // Now write out the audit record to the audit log
    //

    ( VOID ) LsapAdtWriteLog( &AuditParameters );

    //
    // And clean up any allocated memory
    //

    Status = STATUS_SUCCESS;

Cleanup:

    if ( !NT_SUCCESS(Status) ) {
        LsapAuditFailed(Status);
    }

    if ( NewMemberSid != NULL ) {
        LsapFreeLsaHeap( NewMemberSid );
    }

    if ( NewAccountSid != NULL ) {
        LsapFreeLsaHeap( NewAccountSid );
    }

    if ( TokenUserInformation != NULL ) {
        LsapFreeLsaHeap( TokenUserInformation );
    }
    return Status;

    UNREFERENCED_PARAMETER(ExtendedInfo);
}

NTSTATUS
LsaIAuditPasswordAccessEvent(
    IN USHORT EventType,
    IN PCWSTR pszTargetUserName,
    IN PCWSTR pszTargetUserDomain
    )

/*++

Routine Description:

    Generate SE_AUDITID_PASSWORD_HASH_ACCESS event. This is generated when
    user password hash is retrieved by the ADMT password filter DLL.
    This typically happens during ADMT password migration.
        

Arguments:

    EventType - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    pszTargetUserName - name of user whose password is being retrieved

    pszTargetUserDomain - domain of user whose password is being retrieved

Return Value:

    NTSTATUS - Standard NT Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };
    UNICODE_STRING TargetUser;
    UNICODE_STRING TargetDomain;
    BOOLEAN bAudit;
    
    if ( !((EventType == EVENTLOG_AUDIT_SUCCESS) ||
           (EventType == EVENTLOG_AUDIT_FAILURE))   ||
         !pszTargetUserName  || !pszTargetUserDomain ||
         !*pszTargetUserName || !*pszTargetUserDomain )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // get caller info from the thread token
    //

    Status = LsapQueryClientInfo( &TokenUserInformation, &ClientAuthenticationId );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    //
    //  if auditing is not enabled, return asap
    //

    Status = LsapAdtAuditingEnabledByLogonId( 
                 AuditCategoryAccountManagement,
                 &ClientAuthenticationId,
                 EventType,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit)
    {
        goto Cleanup;
    }

    RtlInitUnicodeString( &TargetUser,   pszTargetUserName );
    RtlInitUnicodeString( &TargetDomain, pszTargetUserDomain );

    Status =
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_ACCOUNT_MANAGEMENT,
        SE_AUDITID_PASSWORD_HASH_ACCESS,
        EventType,
        5,                     // there are 5 params to init

        //
        //    User Sid
        //

        SeAdtParmTypeSid,        TokenUserInformation->User.Sid,

        //
        //    Subsystem name
        //

        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    target user name
        //

        SeAdtParmTypeString,      &TargetUser,

        //
        //    target user domain name
        //

        SeAdtParmTypeString,      &TargetDomain,

        //
        //    client auth-id
        //

        SeAdtParmTypeLogonId,     ClientAuthenticationId
        );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    Status = LsapAdtWriteLog( &AuditParameters );
        
Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
}


VOID
LsaIAuditFailed(
    NTSTATUS AuditStatus
    )

/*++

Routine Description:

    Components must call this function if they encounter any problem
    that prevent them from generating any audit.

Arguments:

    AuditStatus : failure code

Return Value:

    none.

--*/

{
    //
    // make sure that we are not called for success case
    //
    ASSERT(!NT_SUCCESS(AuditStatus));
    
    LsapAuditFailed( AuditStatus );
}


VOID
LsapAdtAppendDomainAttrValues(
    IN OUT PSE_ADT_PARAMETER_ARRAY pParameters,
    IN     PLSAP_AUDIT_DOMAIN_ATTR_VALUES pAttributes OPTIONAL
    )

/*++

Routine Description:

    Helper function to insert the domain attributes
    into the audit parameter array.

Arguments:

    pParameters : audit parameter array

    pAttributes : pointer to structure containing the
                  attributes to insert

Return Value:

    none.

--*/

{
    ULONG                           Index;
    PLSAP_SAM_AUDIT_ATTR_DELTA_TYPE pDelta;

    DsysAssertMsg(
        pParameters->ParameterCount + LSAP_DOMAIN_ATTR_COUNT <= SE_MAX_AUDIT_PARAMETERS,
        "LsapAdtAppendDomainAttrValues: Insuffient audit param slots");

    if (pAttributes == 0)
    {
        pParameters->ParameterCount += LSAP_DOMAIN_ATTR_COUNT;
        return;
    }


    //
    // Initialize our 'loop' vars.
    //

    Index = pParameters->ParameterCount;
    pDelta = pAttributes->AttrDeltaType;


    //
    // Min Password Age
    //

    if (pAttributes->MinPasswordAge &&
        *pDelta == LsapAuditSamAttrNewValue &&
        !(pAttributes->MinPasswordAge->LowPart  == 0 &&
          pAttributes->MinPasswordAge->HighPart == MINLONG))
    {
        LsapSetParmTypeDuration(
            *pParameters,
            Index,
            *pAttributes->MinPasswordAge);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Max Password Age
    //

    if (pAttributes->MaxPasswordAge &&
        *pDelta == LsapAuditSamAttrNewValue &&
        !(pAttributes->MaxPasswordAge->LowPart  == 0 &&
          pAttributes->MaxPasswordAge->HighPart == MINLONG))
    {
        LsapSetParmTypeDuration(
            *pParameters,
            Index,
            *pAttributes->MaxPasswordAge);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Force Logoff
    //

    if (pAttributes->ForceLogoff &&
        *pDelta == LsapAuditSamAttrNewValue &&
        !(pAttributes->ForceLogoff->LowPart  == 0 &&
          pAttributes->ForceLogoff->HighPart == MINLONG))
    {
        LsapSetParmTypeDuration(
            *pParameters,
            Index,
            *pAttributes->ForceLogoff);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Lockout Threshold
    //

    if (pAttributes->LockoutThreshold &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeUlong(
            *pParameters,
            Index,
            (ULONG)(*pAttributes->LockoutThreshold));
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Lockout Observation Window
    //

    if (pAttributes->LockoutObservationWindow &&
        *pDelta == LsapAuditSamAttrNewValue &&
        !(pAttributes->LockoutObservationWindow->LowPart  == 0 &&
          pAttributes->LockoutObservationWindow->HighPart == MINLONG))
    {
        LsapSetParmTypeDuration(
            *pParameters,
            Index,
            *pAttributes->LockoutObservationWindow);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Lockout Duration
    //

    if (pAttributes->LockoutDuration &&
        *pDelta == LsapAuditSamAttrNewValue &&
        !(pAttributes->LockoutDuration->LowPart  == 0 &&
          pAttributes->LockoutDuration->HighPart == MINLONG))
    {
        LsapSetParmTypeDuration(
            *pParameters,
            Index,
            *pAttributes->LockoutDuration);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Password Properties
    //

    if (pAttributes->PasswordProperties &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeUlong(
            *pParameters,
            Index,
            *pAttributes->PasswordProperties);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Min Password Length
    //

    if (pAttributes->MinPasswordLength &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeUlong(
            *pParameters,
            Index,
            (ULONG)(*pAttributes->MinPasswordLength));
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Password History Length
    //

    if (pAttributes->PasswordHistoryLength &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeUlong(
            *pParameters,
            Index,
            (ULONG)(*pAttributes->PasswordHistoryLength));
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Machine Account Quota
    //

    if (pAttributes->MachineAccountQuota &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeUlong(
            *pParameters,
            Index,
            *pAttributes->MachineAccountQuota);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Mixed Domain Mode
    //

    if (pAttributes->MixedDomainMode &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeUlong(
            *pParameters,
            Index,
            *pAttributes->MixedDomainMode);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Domain Behavior Version
    //

    if (pAttributes->DomainBehaviorVersion &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeUlong(
            *pParameters,
            Index,
            *pAttributes->DomainBehaviorVersion);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Oem Information
    //

    if (pAttributes->OemInformation &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeString(
            *pParameters,
            Index,
            pAttributes->OemInformation);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Verify we added the right number of params and fixup the param count.
    //

    DsysAssertMsg(
        Index - pParameters->ParameterCount == LSAP_DOMAIN_ATTR_COUNT,
        "LsapAdtAppendDomainAttrValues: Wrong param count");

    pParameters->ParameterCount = Index;
}


VOID
LsapAdtAppendUserAttrValues(
    IN OUT PSE_ADT_PARAMETER_ARRAY pParameters,
    IN     PLSAP_AUDIT_USER_ATTR_VALUES pAttributes OPTIONAL,
    IN     BOOL MachineAudit
    )

/*++

Routine Description:

    Helper function to insert the user attributes
    into the audit parameter array. We are only going
    to insert values that have changed.

Arguments:

    pParameters : audit parameter array

    pAttributes : pointer to structure containing the
                  attributes to insert

Return Value:

    none.

--*/

{
    ULONG                           Index;
    ULONG                           AttrCount = LSAP_USER_ATTR_COUNT;
    PLSAP_SAM_AUDIT_ATTR_DELTA_TYPE pDelta;
    LARGE_INTEGER                   FileTime;

    if (!MachineAudit)
    {
        //
        // User audits don't have the last two attributes.
        //

        AttrCount -= 2;
    }

    DsysAssertMsg(
        pParameters->ParameterCount + AttrCount <= SE_MAX_AUDIT_PARAMETERS,
        "LsapAdtAppendUserAttrValues: Insuffient audit param slots");

    if (pAttributes == 0)
    {
        //
        // The user account control param actually produces 3 strings,
        // so we have to increase the parameter count by 2 to make up for it.
        // We also have to check/assert whether we hit the max param limit.
        //

        AttrCount += 2;

        pParameters->ParameterCount += AttrCount;

        if (pParameters->ParameterCount > SE_MAX_AUDIT_PARAMETERS)
        {
            DsysAssertMsg(
                pParameters->ParameterCount <= SE_MAX_AUDIT_PARAMETERS,
                "LsapAdtAppendUserAttrValues: Insuffient audit param slots");


            //
            // It is better to have one or two %xx entries in the log
            // than av'ing or dropping the audit...
            //

            pParameters->ParameterCount = SE_MAX_AUDIT_PARAMETERS;
        }

        return;
    }


    //
    // Initialize our 'loop' vars.
    //

    Index = pParameters->ParameterCount;
    pDelta = pAttributes->AttrDeltaType;


    //
    // Sam Account Name
    //

    if (pAttributes->SamAccountName &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeString(
            *pParameters,
            Index,
            pAttributes->SamAccountName);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Display Name
    //

    if (pAttributes->DisplayName &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeString(
            *pParameters,
            Index,
            pAttributes->DisplayName);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // User Principal Name
    //

    if (pAttributes->UserPrincipalName &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeString(
            *pParameters,
            Index,
            pAttributes->UserPrincipalName);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Home Directory
    //

    if (pAttributes->HomeDirectory &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeString(
            *pParameters,
            Index,
            pAttributes->HomeDirectory);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Home Drive
    //

    if (pAttributes->HomeDrive &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeString(
            *pParameters,
            Index,
            pAttributes->HomeDrive);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Script Path
    //

    if (pAttributes->ScriptPath &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeString(
            *pParameters,
            Index,
            pAttributes->ScriptPath);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Profile Path
    //

    if (pAttributes->ProfilePath &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeString(
            *pParameters,
            Index,
            pAttributes->ProfilePath);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // User WorkStations
    //

    if (pAttributes->UserWorkStations &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeString(
            *pParameters,
            Index,
            pAttributes->UserWorkStations);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Password Last Set
    //

    if (pAttributes->PasswordLastSet &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        FileTime.LowPart  = pAttributes->PasswordLastSet->dwLowDateTime;
        FileTime.HighPart = pAttributes->PasswordLastSet->dwHighDateTime; 

        if ((FileTime.LowPart == MAXULONG && FileTime.HighPart == MAXLONG) || // SampWillNeverTime
            (FileTime.LowPart == 0        && FileTime.HighPart == 0))         // SampHasNeverTime
        {
            LsapSetParmTypeMessage(
                *pParameters,
                Index,
                SE_ADT_TIME_NEVER);
        }
        else
        {
            LsapSetParmTypeDateTime(
                *pParameters,
                Index,
                FileTime);
        }
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }
    else
    {
        FileTime.LowPart  = 0;
        FileTime.HighPart = 0; 

        LsapSetParmTypeDateTime(
            *pParameters,
            Index,
            FileTime);
    }

    pDelta++;
    Index++;


    //
    // Account Expires
    //

    if (pAttributes->AccountExpires &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        FileTime.LowPart  = pAttributes->AccountExpires->dwLowDateTime;
        FileTime.HighPart = pAttributes->AccountExpires->dwHighDateTime; 

        if ((FileTime.LowPart == MAXULONG && FileTime.HighPart == MAXLONG) || // SampWillNeverTime
            (FileTime.LowPart == 0        && FileTime.HighPart == 0))         // SampHasNeverTime
        {
            LsapSetParmTypeMessage(
                *pParameters,
                Index,
                SE_ADT_TIME_NEVER);
        }
        else
        {
            LsapSetParmTypeDateTime(
                *pParameters,
                Index,
                FileTime);
        }
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }
    else
    {
        FileTime.LowPart  = 0;
        FileTime.HighPart = 0; 

        LsapSetParmTypeDateTime(
            *pParameters,
            Index,
            FileTime);
    }

    pDelta++;
    Index++;


    //
    // Primary Group Id
    //

    if (pAttributes->PrimaryGroupId &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeUlong(
            *pParameters,
            Index,
            *pAttributes->PrimaryGroupId);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;
    

    //
    // Allowed To Delegate To
    //

    if (pAttributes->AllowedToDelegateTo &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeStringList(
            *pParameters,
            Index,
            pAttributes->AllowedToDelegateTo);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // User Account Control
    //

    if (pAttributes->UserAccountControl &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeUac(
            *pParameters,
            Index,
            *pAttributes->PrevUserAccountControl,
            *pAttributes->UserAccountControl);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }
    else
    {
        LsapSetParmTypeNoUac(
            *pParameters,
            Index);
    }

    pDelta++;
    Index++;


    //
    // User Parameters
    // This value is special since it never gets displayed. Instead, we
    // display only a string indicating that the value has changed.
    //

    if (*pDelta == LsapAuditSamAttrNewValue ||
        *pDelta == LsapAuditSamAttrSecret)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_DISPLAYED);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Sid History
    //

    if (pAttributes->SidHistory &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeSidList(
            *pParameters,
            Index,
            pAttributes->SidHistory);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Logon Hours (display not yet supported)
    //

    if (pAttributes->LogonHours &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_DISPLAYED);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // DnsHostName and SCPs are available for computer audits only.
    //

    if (MachineAudit)
    {
        //
        // Dns Host Name
        //

        if (pAttributes->DnsHostName &&
            *pDelta == LsapAuditSamAttrNewValue)
        {
            LsapSetParmTypeString(
                *pParameters,
                Index,
                pAttributes->DnsHostName);
        }
        else if (*pDelta == LsapAuditSamAttrNoValue)
        {
            LsapSetParmTypeMessage(
                *pParameters,
                Index,
                SE_ADT_VALUE_NOT_SET);
        }

        pDelta++;
        Index++;


        //
        // Service Principal Names
        //

        if (pAttributes->ServicePrincipalNames &&
            *pDelta == LsapAuditSamAttrNewValue)
        {
            LsapSetParmTypeStringList(
                *pParameters,
                Index,
                pAttributes->ServicePrincipalNames);
        }
        else if (*pDelta == LsapAuditSamAttrNoValue)
        {
            LsapSetParmTypeMessage(
                *pParameters,
                Index,
                SE_ADT_VALUE_NOT_SET);
        }

        pDelta++;
        Index++;
    }


    //
    // Verify we added the right number of params and fixup the param count.
    //

    DsysAssertMsg(
        Index - pParameters->ParameterCount == AttrCount,
        "LsapAdtAppendGroupAttrValues: Wrong param count");

    pParameters->ParameterCount = Index;
}


VOID
LsapAdtAppendGroupAttrValues(
    IN OUT PSE_ADT_PARAMETER_ARRAY pParameters,
    IN     PLSAP_AUDIT_GROUP_ATTR_VALUES pAttributes OPTIONAL
    )

/*++

Routine Description:

    Helper function to insert the group attributes
    into the audit parameter array.

Arguments:

    pParameters : audit parameter array

    pAttributes : pointer to structure containing the
                  attributes to insert

Return Value:

    none.

--*/

{
    ULONG                           Index;
    PLSAP_SAM_AUDIT_ATTR_DELTA_TYPE pDelta;

    DsysAssertMsg(
        pParameters->ParameterCount + LSAP_GROUP_ATTR_COUNT <= SE_MAX_AUDIT_PARAMETERS,
        "LsapAdtAppendGroupAttrValues: Insuffient audit param slots");

    if (pAttributes == 0)
    {
        pParameters->ParameterCount += LSAP_GROUP_ATTR_COUNT;
        return;
    }


    //
    // Initialize our 'loop' vars.
    //

    Index = pParameters->ParameterCount;
    pDelta = pAttributes->AttrDeltaType;


    //
    // Sam Account Name
    //

    if (pAttributes->SamAccountName &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeString(
            *pParameters,
            Index,
            pAttributes->SamAccountName);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Sid History
    //

    if (pAttributes->SidHistory &&
        *pDelta == LsapAuditSamAttrNewValue)
    {
        LsapSetParmTypeSidList(
            *pParameters,
            Index,
            pAttributes->SidHistory);
    }
    else if (*pDelta == LsapAuditSamAttrNoValue)
    {
        LsapSetParmTypeMessage(
            *pParameters,
            Index,
            SE_ADT_VALUE_NOT_SET);
    }

    pDelta++;
    Index++;


    //
    // Verify we added the right number of params and fixup the param count.
    //

    DsysAssertMsg(
        Index - pParameters->ParameterCount == LSAP_GROUP_ATTR_COUNT,
        "LsapAdtAppendGroupAttrValues: Wrong param count");

    pParameters->ParameterCount = Index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtinit.c

Abstract:

    Local Security Authority - Auditing Initialization

Author:

    Scott Birrell       (ScottBi)      November 20, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "adtp.h"

NTSTATUS LsapAdtInitializeCrashOnFail( VOID );

//
// Array of drive letter to device mappings for generating path strings.
//

DRIVE_MAPPING DriveMappingArray[MAX_DRIVE_MAPPING];

//
// Name that will be used as the default subsystem name for LSA generated events
//

UNICODE_STRING LsapSubsystemName;


//
// Name that will be passed in for SubsystemName for some audits generated
// by LSA for LSA objects.
//

UNICODE_STRING LsapLsaName;


//
// Special privilege values which are not normally audited,
// but generate audits when assigned to a user.  See
// LsapAdtAuditSpecialPrivileges.
//

LUID ChangeNotifyPrivilege;
LUID AuditPrivilege;
LUID CreateTokenPrivilege;
LUID AssignPrimaryTokenPrivilege;
LUID BackupPrivilege;
LUID RestorePrivilege;
LUID DebugPrivilege;


//
// Global variable indicating whether or not we are supposed
// to crash when an audit fails.
//

BOOLEAN LsapCrashOnAuditFail = FALSE;
BOOLEAN LsapAllowAdminLogonsOnly = FALSE;



NTSTATUS
LsapAdtInitialize(
    )

/*++

Routine Description:

    This function performs initialization of auditing within the LSA, and
    it also issues commands to the Reference Monitor to enable it to
    complete any initialization of auditing variables that is dependent
    on the content of the LSA Database.  At time of call, the main
    System Init thread is in the Reference Monitor awaiting completion
    of all LSA initialization, and the Reference Monitor Command
    Server thread is waiting for commands.

    The following steps are performed:

    o Read the Audit Event and Audit Log information from the LSA
      Database.
    o Call the Event Logging function to open the Audit Log
    o Issue a Reference Monitor command to write the Audit Event Info
      to the Reference-Monitor's in-memory database.

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code.

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AuditLogInfoLength = sizeof (POLICY_AUDIT_LOG_INFO);
    ULONG AuditEventInfoLength = sizeof (LSARM_POLICY_AUDIT_EVENTS_INFO);
    UNICODE_STRING UnicodeString;
    PUNICODE_STRING Strings;
    LSARM_POLICY_AUDIT_EVENTS_INFO AuditEventsInfo;

    Strings = &UnicodeString;

    RtlInitUnicodeString( Strings, L"System Restart");

    RtlInitUnicodeString( &LsapSubsystemName, L"Security" );

    RtlInitUnicodeString( &LsapLsaName, L"LSA" );

    //
    // initialize debug helper support. this function
    // does nothing for free builds
    //

    LsapAdtInitDebug();
    
    //
    // init LsapCrashOnAuditFail global var so that we can crash
    // if any of the following initialization fails
    //

    (VOID) LsapAdtInitializeCrashOnFail();

    Status = LsapAdtInitGenericAudits();

    if (!NT_SUCCESS(Status)) {

        goto AuditInitError;
    }
    
    Status = LsapAdtInitializeExtensibleAuditing();

    if (!NT_SUCCESS(Status)) {

        goto AuditInitError;
    }
    
    Status = LsapAdtInitializeLogQueue();

    if (!NT_SUCCESS(Status)) {

        goto AuditInitError;
    }

    Status = LsapAdtInitializePerUserAuditing();

    if (!NT_SUCCESS(Status)) {

        LsapLogError("LsapAdtInitialize: LsapAdtInitializePerUserAuditing() returned 0x%lx\n", 
            Status);
        goto AuditInitError;
    }

    //
    // Read the Audit Log Information from the PolAdtLg attribute of the Lsa
    // Database object.
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[PolAdtLg],
                 &LsapAdtLogInformation,
                 &AuditLogInfoLength
                 );

    if (!NT_SUCCESS(Status)) {

        LsapLogError(
            "LsapAdtInitialize: Read Audit Log Info returned 0x%lx\n",
            Status
            );

        goto AuditInitError;
    }


    //
    // Read the Audit Event Information from the AdtEvent attribute of the Lsa
    // Database object.  The information consists of the Auditing Mode and
    // the Auditing Options for each Audit Event Type.
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[PolAdtEv],
                 &AuditEventsInfo,
                 &AuditEventInfoLength
                 );

    if (!NT_SUCCESS(Status)) {

        //
        // This section of code is temporary and allows an old
        // Policy Database to work with the new Audit Event Categories
        // without the need to re-install.  The Audit Event Information
        // is overwritten with the new format and all auditing is turned
        // off.
        //

        if (Status == STATUS_BUFFER_OVERFLOW) {

            KdPrint(("LsapAdtInitialize: Old Audit Event Info detected\n"
                    "Replacing with new format, all auditing disabled\n"));

            //
            // Initialize Default Event Auditing Options.  No auditing is specified
            // for any event type.
            //

            Status = LsapAdtInitializeDefaultAuditing(
                         LSAP_DB_UPDATE_POLICY_DATABASE,
                         &AuditEventsInfo
                         );

            if (!NT_SUCCESS(Status)) {

                goto AuditInitError;
            }

        } else {

            LsapLogError(
                "LsapAdtInitialize: Read Audit Event Info returned 0x%lx\n",
                Status
                );
            goto AuditInitError;
        }
    }

    //
    // update the LSA global var that holds audit policy
    //

    RtlCopyMemory(
        &LsapAdtEventsInformation,
        &AuditEventsInfo,
        sizeof(LSARM_POLICY_AUDIT_EVENTS_INFO)
        );
        
    //
    // generate SE_AUDITID_SYSTEM_RESTART
    //

    LsapAdtSystemRestart( &AuditEventsInfo );

    //
    // Send a command to the Reference Monitor to write the Auditing
    // State to its in-memory data.
    //

    Status = LsapCallRm(
                 RmAuditSetCommand,
                 &AuditEventsInfo,
                 sizeof (LSARM_POLICY_AUDIT_EVENTS_INFO),
                 NULL,
                 0
                 );

    if (!NT_SUCCESS(Status)) {

        LsapLogError("LsapAdtInitialize: LsapCallRm returned 0x%lx\n", Status);
        goto AuditInitError;
    }

    Status = LsapAdtInitializeDriveLetters();

    if (!NT_SUCCESS(Status)) {

        LsapLogError("LsapAdtInitialize: LsapAdtInitializeDriveLetters() returned 0x%lx\n", 
            Status);
        goto AuditInitError;
    }

    //
    // Initialize privilege values we need
    //

    ChangeNotifyPrivilege       = RtlConvertLongToLuid( SE_CHANGE_NOTIFY_PRIVILEGE      );
    AuditPrivilege              = RtlConvertLongToLuid( SE_AUDIT_PRIVILEGE              );
    CreateTokenPrivilege        = RtlConvertLongToLuid( SE_CREATE_TOKEN_PRIVILEGE       );
    AssignPrimaryTokenPrivilege = RtlConvertLongToLuid( SE_ASSIGNPRIMARYTOKEN_PRIVILEGE );
    BackupPrivilege             = RtlConvertLongToLuid( SE_BACKUP_PRIVILEGE             );
    RestorePrivilege            = RtlConvertLongToLuid( SE_RESTORE_PRIVILEGE            );
    DebugPrivilege              = RtlConvertLongToLuid( SE_DEBUG_PRIVILEGE              );


AuditInitFinish:

    return(Status);

AuditInitError:

    //
    // raise harderror if LsapCrashOnAuditFail is TRUE
    //

    LsapAuditFailed( Status );

    goto AuditInitFinish;
}


NTSTATUS
LsapAdtInitializeDefaultAuditing(
    IN ULONG Options,
    OUT PLSARM_POLICY_AUDIT_EVENTS_INFO AuditEventsInformation
    )

/*++

Routine Description:

    This routine sets an initial default Auditing State in which auditing
    is turned off.  It is called only during initialization of the LSA
    or during the installation of its Policy Database.  The initial
    auditing state may also optionally be written to the Lsa Policy
    Database provided that the Policy Object has been created and its
    internal handle is available.

Arguments:

    Options - Specifies optional actions to be taken

        LSAP_DB_UPDATE_POLICY_DATABASE - Update the corresponding information
            in the Policy Database.  This option must only be specified
            where it is known that the Policy Object exists.

    AuditEventsInformation - Pointer to structure that will receive the Audit Event
        Information

Return Values:

    None.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_ATTRIBUTE AuditEventsAttribute;
    BOOLEAN ObjectReferenced = FALSE;

    ULONG EventAuditingOptionsLength =
        (POLICY_AUDIT_EVENT_TYPE_COUNT * sizeof(POLICY_AUDIT_EVENT_OPTIONS));

    //
    // Turn off auditing and set the count of Audit Event Types (Categories)
    //

    AuditEventsInformation->AuditingMode = FALSE;
    AuditEventsInformation->MaximumAuditEventCount = POLICY_AUDIT_EVENT_TYPE_COUNT;

    //
    // Turn off auditing for all events.
    //

    RtlZeroMemory(AuditEventsInformation->EventAuditingOptions, EventAuditingOptionsLength);


    if (Options & LSAP_DB_UPDATE_POLICY_DATABASE) {

        ASSERT(LsapPolicyHandle != NULL);

        //
        // Start a transaction on the Policy Object
        //

        Status = LsapDbReferenceObject(
                     LsapPolicyHandle,
                     (ACCESS_MASK) 0,
                     PolicyObject,
                     PolicyObject,
                     LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION
                     );

        if (!NT_SUCCESS(Status)) {

            goto InitializeDefaultAuditingError;
        }

        ObjectReferenced = TRUE;

        LsapDbInitializeAttribute(
            &AuditEventsAttribute,
            &LsapDbNames[PolAdtEv],
            AuditEventsInformation,
            sizeof (LSARM_POLICY_AUDIT_EVENTS_INFO),
            FALSE
            );

        Status = LsapDbWriteAttributesObject(
                     LsapPolicyHandle,
                     &AuditEventsAttribute,
                     (ULONG) 1
                     );

        if (!NT_SUCCESS(Status)) {

            goto InitializeDefaultAuditingError;
        }
    }

InitializeDefaultAuditingFinish:

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     LsapPolicyHandle,
                     PolicyObject,
                     PolicyObject,
                     LSAP_DB_LOCK | LSAP_DB_FINISH_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );

        ObjectReferenced = FALSE;
    }

    return(Status);

InitializeDefaultAuditingError:

    goto InitializeDefaultAuditingFinish;
}


NTSTATUS
LsapAdtInitializePerUserAuditing(
    VOID
    )
/*++

Routine Description:

    Initializes the per user auditing hash table and reads data from the
    registry.

Arguments:

    None.

Return Value:

    NTSTATUS 

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    BOOLEAN     bSuccess;
    BOOLEAN     bLock  = FALSE;
    PVOID       pNotificationItem = NULL;

    RtlInitializeResource(&LsapAdtPerUserPolicyTableResource);
    RtlInitializeResource(&LsapAdtPerUserLuidTableResource);

    LsapAdtPerUserKeyEvent = CreateEvent(
                                 NULL,
                                 FALSE,
                                 FALSE,
                                 NULL
                                 );

    ASSERT(LsapAdtPerUserKeyEvent);
    
    if (!LsapAdtPerUserKeyEvent)
    {
        Status = LsapWinerrorToNtStatus(GetLastError());
        goto Cleanup;
    }             

    LsapAdtPerUserKeyTimer = CreateWaitableTimer(
                                 NULL,
                                 FALSE,
                                 NULL
                                 );

    ASSERT(LsapAdtPerUserKeyTimer);
    
    if (!LsapAdtPerUserKeyTimer)
    {
        Status = LsapWinerrorToNtStatus(GetLastError());
        goto Cleanup;
    }             

    bSuccess = LsapAdtAcquirePerUserPolicyTableWriteLock();
    ASSERT(bSuccess);
    
    if (!bSuccess) 
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    bLock  = TRUE;
    Status = LsapAdtConstructTablePerUserAuditing();

    if (!NT_SUCCESS(Status))
    {
        ASSERT(L"Failed to construct per user auditing table." && FALSE);
        goto Cleanup;
    }

    //
    // Now register for changes to the key, so that we can rebuild the
    // table to reflect current policy.  The event is signalled by
    // registry change.  The timer is set by the NotifyStub routine.
    //

    pNotificationItem =
        LsaIRegisterNotification( 
            (LPTHREAD_START_ROUTINE)LsapAdtKeyNotifyStubPerUserAuditing,
            0,
            NOTIFIER_TYPE_HANDLE_WAIT,
            0,
            0,
            0,
            LsapAdtPerUserKeyEvent
            );

    if ( !pNotificationItem )
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    pNotificationItem = 
        LsaIRegisterNotification( 
            (LPTHREAD_START_ROUTINE)LsapAdtKeyNotifyFirePerUserAuditing,
            0,
            NOTIFIER_TYPE_HANDLE_WAIT,
            0,
            0,
            0,
            LsapAdtPerUserKeyTimer 
            );

    if ( !pNotificationItem )
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

Cleanup:

    if (bLock)
    {
        LsapAdtReleasePerUserPolicyTableLock();
    }

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed(Status);
    }

    return Status;
}


NTSTATUS
LsapAdtInitializeDriveLetters(
    VOID
    )
/*++

Routine Description:

    Initializes an array of symbolic link to drive letter mappings
    for use by auditing code.


Arguments:

    None.

Return Value:

    NTSTATUS - currently either STATUS_SUCCESS or STATUS_NO_MEMORY.

--*/
{
    UNICODE_STRING LinkName;
    PUNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES Obja;
    HANDLE LinkHandle;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;
    PWCHAR p;
    PWCHAR DeviceNameBuffer;
    ULONG MappingIndex = 0;

    WCHAR wszDosDevices[sizeof(L"\\DosDevices\\A:") + 1];

    wcscpy(wszDosDevices, L"\\DosDevices\\A:");

    RtlInitUnicodeString(&LinkName, wszDosDevices);

    p = (PWCHAR)LinkName.Buffer;

    //
    // Make p point to the drive letter in the LinkName string
    //

    p = p+12;

    for( i=0 ; i<26 ; i++ ){

        *p = (WCHAR)'A' + (WCHAR)i;

        InitializeObjectAttributes(
            &Obja,
            &LinkName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtOpenSymbolicLinkObject(
                    &LinkHandle,
                    SYMBOLIC_LINK_QUERY,
                    &Obja
                    );
        
        if (NT_SUCCESS( Status )) {

            //
            // Open succeeded, Now get the link value
            //

            DriveMappingArray[MappingIndex].DriveLetter = *p;
            DeviceName = &DriveMappingArray[MappingIndex].DeviceName;

            DeviceNameBuffer = LsapAllocateLsaHeap( MAXIMUM_FILENAME_LENGTH );

            //
            // if LsapAllocateLsaHeap can't get any memory then return
            //

            if (DeviceNameBuffer != NULL) {

                DeviceName->Length = 0;
                DeviceName->MaximumLength = MAXIMUM_FILENAME_LENGTH;
                DeviceName->Buffer = DeviceNameBuffer;

                Status = NtQuerySymbolicLinkObject(
                            LinkHandle,
                            DeviceName,
                            NULL
                            );

                NtClose(LinkHandle);
    
                if ( NT_SUCCESS(Status) ) {
    
                    MappingIndex++;
    
                } else {

                    LsapFreeLsaHeap( DeviceNameBuffer );
                    RtlInitUnicodeString( DeviceName, NULL );

                }

            } else {

                Status = STATUS_NO_MEMORY;
                break; // since couldn't alloc mem, get out of the for loop and return

            }
        }
    }

    //
    // Now we know all drive letters that map to devices.  However, at this point, 
    // some of the 'devices' that the letters link to may themselves be symbolic 
    // links (ie nested symbolic links).  We must check for this and find the actual
    // underlying object.  Only perform the nested symlink search if we did not run
    // out of memory above.
    //

    if (Status != STATUS_NO_MEMORY) {
        
        BOOLEAN bLinkIsNested = FALSE;
        NTSTATUS NestedSearchStatus = STATUS_SUCCESS;

        i = 0;

        while (i < MappingIndex) {
            
            bLinkIsNested = FALSE;
            DeviceName = &DriveMappingArray[i].DeviceName;

            InitializeObjectAttributes(
                &Obja,
                DeviceName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );

            NestedSearchStatus = NtOpenSymbolicLinkObject(
                                     &LinkHandle,
                                     SYMBOLIC_LINK_QUERY,
                                     &Obja
                                     );

            if (NT_SUCCESS( NestedSearchStatus )) {
                
                //
                // The open succeeded, so DeviceName was actually a nested symbolic link.
                //

                NestedSearchStatus = NtQuerySymbolicLinkObject(
                                         LinkHandle,
                                         DeviceName,
                                         NULL
                                         );

                if (NT_SUCCESS( NestedSearchStatus )) {
                
                    bLinkIsNested = TRUE;

                } else {
                 
                    //
                    // If the query fails, then free the buffer and move on.
                    //

                    LsapFreeLsaHeap( DeviceName->Buffer );
                    RtlInitUnicodeString( DeviceName, NULL );
                
                }

                NtClose(LinkHandle);

            } else if (NestedSearchStatus == STATUS_OBJECT_TYPE_MISMATCH) {
                
                //
                // NtOpenSymbolicLinkObject failed with object type mismatch.  Good.  We
                // have reached the actual device in the nested links.
                //
            
            } else {
#if DBG
                DbgPrint("NtQuerySymbolicLinkObject on handle 0x%x returned 0x%x\n", LinkHandle, NestedSearchStatus);
#endif            
                ASSERT("NtQuerySymbolicLinkObject failed with unexpected status." && FALSE);
            }

            if (!bLinkIsNested) {

                //
                // Move on to the next drive letter.
                //

                i++;

            }

        }
    }

    // 
    // one of two values should be return. STATUS_NO_MEMORY should be returned
    // if LsapAllocateLsaHeap() fails; STATUS_SUCCESS returns in all other
    // cases.  this test must be made because Status may contain a different
    // value after the return of NtOpenSymbolicLinkObject() or
    // NtQuerySymbolicLinkObject().  if either of those functions fail,
    // LsapAdtInitializeDriveLetters() should still return STATUS_SUCCESS.
    //

    if (Status == STATUS_NO_MEMORY) {

        return Status;

    }

    return STATUS_SUCCESS;
}


NTSTATUS
LsapAdtInitializeCrashOnFail(
    VOID
    )

/*++

Routine Description:

    Reads the registry to see if the user has told us to crash if an audit fails.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--*/

{
    HANDLE KeyHandle;
    NTSTATUS Status;
    NTSTATUS TmpStatus;
    OBJECT_ATTRIBUTES Obja;
    ULONG ResultLength;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    CHAR KeyInfo[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(BOOLEAN)];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;

    //
    // Check the value of the CrashOnAudit key.
    //

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa");

    InitializeObjectAttributes( &Obja,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );

    Status = NtOpenKey(
                 &KeyHandle,
                 KEY_QUERY_VALUE | KEY_SET_VALUE,
                 &Obja
                 );


    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        LsapCrashOnAuditFail = FALSE;
        return( STATUS_SUCCESS );
    }

    RtlInitUnicodeString( &ValueName, CRASH_ON_AUDIT_FAIL_VALUE );

    Status = NtQueryValueKey(
                 KeyHandle,
                 &ValueName,
                 KeyValuePartialInformation,
                 KeyInfo,
                 sizeof(KeyInfo),
                 &ResultLength
                 );

    TmpStatus = NtClose(KeyHandle);
    ASSERT(NT_SUCCESS(TmpStatus));

    //
    // If it's not found, don't enable CrashOnFail.
    //

    if (!NT_SUCCESS( Status )) {

        LsapCrashOnAuditFail = FALSE;

    } else {

        //
        // Check the value of the CrashOnFail value. If it is 1, we
        // crash on audit fail. If it is two, we only allow admins to
        // logon.
        //

        pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfo;
        if (*(pKeyInfo->Data) == LSAP_CRASH_ON_AUDIT_FAIL) {
            LsapCrashOnAuditFail = TRUE;
        } else if (*(pKeyInfo->Data) == LSAP_ALLOW_ADIMIN_LOGONS_ONLY) {
            LsapAllowAdminLogonsOnly = TRUE;
        }

    }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtlog.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtlog.c

Abstract:

    Local Security Authority - Audit Log Management

    Functions in this module access the Audit Log via the Event Logging
    interface.

Author:

    Scott Birrell       (ScottBi)      November 20, 1991
    Robert Reichel      (RobertRe)     April 4, 1992

Environment:

Revision History:

--*/
#include <lsapch2.h>
#include "adtp.h"
#include "adtlq.h"
#include "adtutil.h"

///////////////////////////////////////////////////////////////////////////
//                                                                       //
// Private data for Audit Logs and Events                                //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

//
// Audit Log Information.  This must be kept in sync with the information
// in the Lsa Database.
//

POLICY_AUDIT_LOG_INFO LsapAdtLogInformation;

//
// Audit Log Handle (returned by Event Logger).
//

HANDLE LsapAdtLogHandle = NULL;


//
// Number of audits discarded since last
// 'discarded - audit'.
//

ULONG LsapAuditQueueEventsDiscarded = 0;

//
// Handle for dequeuing thread.
//

HANDLE LsapAdtQueueThread = 0;

//
// Number of consecutive errors while dequeuing audits
// or writing them to the log.
//

ULONG LsapAdtErrorCount = 0;

//
// Number of audits successfully written to the log.
// Used for dbg purposes.
//

ULONG LsapAdtSuccessCount = 0;


//
// Constants
//

//
// After c_MaxAuditErrorCount consecutive audit failures
// we will flush the queue and reset the error count.
//

CONST ULONG     c_MaxAuditErrorCount = 5;

//
// Private prototypes
//

NTSTATUS
LsapAdtAuditDiscardedAudits(
    ULONG NumberOfEventsDiscarded
    );

VOID
LsapAdtHandleDequeueError(
    IN NTSTATUS Status
    );

//////////////////////////////////////////////////////////

NTSTATUS
LsapAdtWriteLogWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    This function handles a command, received from the Reference Monitor via
    the LPC link, to write a record to the Audit Log.  It is a wrapper which
    deals with any LPC unmarshalling.

Arguments:

    CommandMessage - Pointer to structure containing LSA command message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command number (LsapWriteAuditMessageCommand).  This command
        contains an Audit Message Packet (TBS) as a parameter.

    ReplyMessage - Pointer to structure containing LSA reply message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command ReturnedStatus field in which a status code from the
        command will be returned.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        Currently, all other errors from called routines are suppressed.
--*/

{
    NTSTATUS Status;

    PSE_ADT_PARAMETER_ARRAY AuditRecord = NULL;

    //
    // Strict check that command is correct.
    //

    ASSERT( CommandMessage->CommandNumber == LsapWriteAuditMessageCommand );

    //
    // Obtain a pointer to the Audit Record.  The Audit Record is
    // either stored as immediate data within the Command Message,
    // or it is stored as a buffer.  In the former case, the Audit Record
    // begins at CommandMessage->CommandParams and in the latter case,
    // it is stored at the address located at CommandMessage->CommandParams.
    //

    if (CommandMessage->CommandParamsMemoryType == SepRmImmediateMemory) {

        AuditRecord = (PSE_ADT_PARAMETER_ARRAY) CommandMessage->CommandParams;

    } else {

        AuditRecord = *((PSE_ADT_PARAMETER_ARRAY *) CommandMessage->CommandParams);
    }

    //
    // Call worker to queue Audit Record for writing to the log.
    //

    Status = LsapAdtWriteLog(AuditRecord);

    UNREFERENCED_PARAMETER(ReplyMessage); // Intentionally not referenced

    //
    // The status value returned from LsapAdtWriteLog() is intentionally
    // ignored, since there is no meaningful action that the client
    // (i.e. kernel) if this LPC call can take.  If an error occurs in
    // trying to append an Audit Record to the log, the LSA handles the
    // error.
    //

    return(STATUS_SUCCESS);
}


NTSTATUS
LsapAdtImpersonateSelfWithPrivilege(
    OUT PHANDLE ClientToken
    )
/*++

Routine Description:

    This function copies away the current thread token and impersonates
    the LSAs process token, and then enables the security privilege. The
    current thread token is returned in the ClientToken parameter

Arguments:

    ClientToken - recevies the thread token if there was one, or NULL.

Return Value:

    None.  Any error occurring within this routine is an internal error.

--*/
{
    NTSTATUS Status;
    HANDLE CurrentToken = NULL;
    BOOLEAN ImpersonatingSelf = FALSE;
    BOOLEAN WasEnabled = FALSE;

    *ClientToken = NULL;

    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_IMPERSONATE,
                FALSE,                  // not as self
                &CurrentToken
                );

    if (!NT_SUCCESS(Status) && (Status != STATUS_NO_TOKEN)) {

        return(Status);
    }

    Status = RtlImpersonateSelf( SecurityImpersonation );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    ImpersonatingSelf = TRUE;

    //
    // Now enable the privilege
    //

    Status = RtlAdjustPrivilege(
                SE_SECURITY_PRIVILEGE,
                TRUE,                   // enable
                TRUE,                   // do it on the thread token
                &WasEnabled
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    *ClientToken = CurrentToken;
    CurrentToken = NULL;

Cleanup:

    if (!NT_SUCCESS(Status)) {

        if (ImpersonatingSelf) {

            NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                &CurrentToken,
                sizeof(HANDLE)
                );
        }
    }

    if (CurrentToken != NULL) {

        NtClose(CurrentToken);
    }

    return(Status);

}


NTSTATUS
LsapAdtOpenLog(
    OUT PHANDLE AuditLogHandle
    )

/*++

Routine Description:

    This function opens the Audit Log.

Arguments:

    AuditLogHandle - Receives the Handle to the Audit Log.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        All result codes are generated by called routines.
--*/

{
    NTSTATUS Status;
    UNICODE_STRING ModuleName;
    HANDLE OldToken = NULL;

    RtlInitUnicodeString( &ModuleName, L"Security");

    Status = LsapAdtImpersonateSelfWithPrivilege( &OldToken );

    if (NT_SUCCESS(Status)) {

        Status = ElfRegisterEventSourceW (
                    NULL,
                    &ModuleName,
                    AuditLogHandle
                    );

        NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &OldToken,
            sizeof(HANDLE)
            );

        if (OldToken != NULL) {
            NtClose( OldToken );
        }
    }


    if (!NT_SUCCESS(Status)) {

        goto OpenLogError;
    }


OpenLogFinish:

    return(Status);

OpenLogError:

    //
    // Check for Log Full and signal the condition.
    //

    if (Status != STATUS_LOG_FILE_FULL) {

        goto OpenLogFinish;
    }

    goto OpenLogFinish;
}


NTSTATUS
LsapAdtQueueRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    )

/*++

Routine Description:

    Puts passed audit record on the queue to be logged.

    This routine will convert the passed AuditParameters structure
    into self-relative form if it is not already.  It will then
    allocate a buffer out of the local heap and copy the audit
    information into the buffer and put it on the audit queue.

    The buffer will be freed when the queue is cleared.

Arguments:

    AuditRecord - Contains the information to be audited.

Return Value:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to allocate a buffer to contain the record.
--*/

{
    ULONG AuditRecordLength;
    PLSAP_ADT_QUEUED_RECORD QueuedAuditRecord = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AllocationSize;
    PSE_ADT_PARAMETER_ARRAY MarshalledAuditParameters;
    BOOLEAN FreeWhenDone = FALSE;

    //
    // Gather up all of the passed information into a single
    // block that can be placed on the queue.
    //

    if (AuditParameters->Flags & SE_ADT_PARAMETERS_SELF_RELATIVE)
    {
        MarshalledAuditParameters = AuditParameters;
    }
    else
    {
        Status = LsapAdtMarshallAuditRecord(
                     AuditParameters,
                     &MarshalledAuditParameters
                     );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        else
        {
            //
            // Indicate that we're to free this structure when we're
            // finished
            //

            FreeWhenDone = TRUE;
        }
    }


    //
    // Copy the now self-relative audit record into a buffer
    // that can be placed on the queue.
    //

    AuditRecordLength = MarshalledAuditParameters->Length;
    AllocationSize = AuditRecordLength + sizeof(LSAP_ADT_QUEUED_RECORD);

    QueuedAuditRecord = (PLSAP_ADT_QUEUED_RECORD)LsapAllocateLsaHeap(AllocationSize);

    if (QueuedAuditRecord == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

    RtlCopyMemory(
        &QueuedAuditRecord->Buffer,
        MarshalledAuditParameters,
        AuditRecordLength);


    //
    // We are finished with the marshalled audit record, free it.
    //

    if (FreeWhenDone)
    {
        LsapFreeLsaHeap(MarshalledAuditParameters);
        FreeWhenDone = FALSE;
    }

    Status = LsapAdtAddToQueue(QueuedAuditRecord);

    if (!NT_SUCCESS(Status))
    {
        //
        // Check to see if the list is above the maximum length.
        // If it gets this high, it is more than likely that the
        // eventlog service is not going to start at all, so
        // start tossing audits.
        //
        // Don't do this if crash on audit fail is set.
        //

        if (!LsapCrashOnAuditFail)
        {
            LsapAuditQueueEventsDiscarded++;
            Status = STATUS_SUCCESS;
        }

        goto Cleanup;
    }

    return STATUS_SUCCESS;


Cleanup:

    if (FreeWhenDone)
    {
        LsapFreeLsaHeap(MarshalledAuditParameters);
    }

    if (QueuedAuditRecord)
    {
        LsapFreeLsaHeap(QueuedAuditRecord);
    }

    return Status;
}



NTSTATUS
LsapAdtWriteLog(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    )
/*++

Routine Description:

    This function appends the audit to the audit queue.

Arguments:

    AuditRecord - Pointer to an Audit Record to be written to
        the Audit Log.  The record will first be added to the existing
        queue of records waiting to be written to the log.

Return Value:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;


    //
    // Add the audit to the audit queue.
    //

    Status = LsapAdtQueueRecord(AuditParameters);

    if (!NT_SUCCESS(Status))
    {
        //
        // Take whatever action we're supposed to take when an audit attempt fails.
        //

        LsapAuditFailed(Status);
    }

    return Status;
}



ULONG
WINAPI
LsapAdtDequeueThreadWorker(
    LPVOID pParameter
    )
/*++

Routine Description:

    This function tries to write out the audits in the queue to the
    Security log.  If the log is not already open (during startup),
    the function tries to open the log first.

Arguments:

    pParameter - Unused.

Return Value:

    ULONG - the function should never return.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSE_ADT_PARAMETER_ARRAY AuditParameters;
    PLSAP_ADT_QUEUED_RECORD pAuditRecord = NULL;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;


    //
    // Set the timeout to some seconds while the log is not opened.
    // As soon as the log is open we will set it to infinite and
    // will only wake up when an audit comes along.
    //

    TimeOut.QuadPart = 5 * 1000 * -10000i64;      // 5s
    pTimeOut = &TimeOut;

    while (1)
    {
        Status = NtWaitForSingleObject(
                     LsapAdtQueueRemoveEvent,
                     FALSE,
                     pTimeOut);

        if (Status != STATUS_SUCCESS &&
            Status != STATUS_TIMEOUT)
        {
            DsysAssertMsg(
                FALSE,
                "LsapAdtDequeueThreadWorker: NtWaitForSingleObject failed");

            if (LsapAdtLogHandle &&
                LsapAdtQueueLength)
            {
                LsapAdtHandleDequeueError(Status);
            }

            Sleep(1000);

            continue;
        }


        //
        // If the Audit Log is not already open, attempt to open it.
        // If this open is unsuccessful because the EventLog service
        // has not started, try again next time.
        //

        if (LsapAdtLogHandle == NULL)
        {
            Status = LsapAdtOpenLog(&LsapAdtLogHandle);

            if (!NT_SUCCESS(Status))
            {
                //
                // Try to open the log the next time around.
                //

                continue;
            }


            //
            // Since the log is now open we can set the timeout of
            // the wait function to infinite.
            //

            pTimeOut = NULL;
        }


        //
        // Write out all the records in the Audit Log Queue to
        // the SecurityLog.
        // If we are here we assume that the log is opened.
        //

        while (1)
        {
            Status = LsapAdtGetQueueHead(&pAuditRecord);

            if (Status == STATUS_NOT_FOUND)
            {
                //
                // Break out of the while (1) loop since the 
                // queue is now empty.
                //

                break;
            }

            if (NT_SUCCESS(Status))
            {
                AuditParameters = &pAuditRecord->Buffer;


                //
                // If the caller has marshalled the data, normalize it now.
                //

                LsapAdtNormalizeAuditInfo(AuditParameters);


                //
                // Note that LsapAdtDemarshallAuditInfo in addition to
                // de-marshalling the data also writes it to the eventlog.
                //
                // Note also that the queuing functions rely on the fact
                // that the queue gets completely drained before waiting
                // on the remove event again. This means we should not
                // leave this loop until the queue is empty.
                //

                Status = LsapAdtDemarshallAuditInfo(AuditParameters);

                if (NT_SUCCESS(Status))
                {
                    LsapAdtErrorCount = 0;
                }
                else
                {
                    ++LsapAuditQueueEventsDiscarded;

                    LsapAdtHandleDequeueError(Status);
                }
            }
            else
            {
                LsapAdtHandleDequeueError(Status);
            }

            if (pAuditRecord)
            {
                LsapFreeLsaHeap(pAuditRecord);
                pAuditRecord = NULL;
            }
        }
    }

    UNREFERENCED_PARAMETER(pParameter);

    return 0;
}



VOID
LsapAdtHandleDequeueError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    The function calls LsapAuditFailed and keeps track of consecutive
    errors.

Arguments:

    Status - Status of last failure.

--*/

{
    //
    // Take whatever action we're supposed to take when an
    // audit attempt fails.
    //

    LsapAuditFailed(Status);


    //
    // Check if we have reached the error limit.
    //

    if (++LsapAdtErrorCount >= c_MaxAuditErrorCount)
    {
        LsapAdtErrorCount = 0;


        //
        // Add the number of events that are still in the
        // queue to the discarded - count.
        //

        LsapAuditQueueEventsDiscarded += LsapAdtQueueLength;

        LsapAdtFlushQueue();
    }


    //
    // Check if there are discarded audits.
    //

    if (LsapAuditQueueEventsDiscarded > 0)
    {
        //
        // We discarded some audits.
        // Generate an audit so the user knows.
        //

        Status = LsapAdtAuditDiscardedAudits(LsapAuditQueueEventsDiscarded);

        if (NT_SUCCESS(Status))
        {
            //
            // If successful, reset the count back to 0
            //

            LsapAuditQueueEventsDiscarded = 0;
        }
    }
}



NTSTATUS
LsapAdtAuditDiscardedAudits(
    ULONG NumberOfEventsDiscarded
    )
/*++

Routine Description:

    Audits the fact that we discarded some audits.

Arguments:

    NumberOfEventsDiscarded - The number of events discarded.

    Note: This function does not use the regular LsapAdtWriteLog interface
    Instead it tries to write the audit to the log synchronously, without
    going through the queue. This is to prevent us from deadlocking on the
    queue lock.

Return Value:

    None.

--*/
{
    SE_ADT_PARAMETER_ARRAY  AuditParameters;
    NTSTATUS                Status;
    BOOLEAN                 bAudit;

    Status = LsapAdtAuditingEnabledBySid(
                 AuditCategorySystem,
                 LsapLocalSystemSid,
                 EVENTLOG_AUDIT_SUCCESS,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit)
    {
        goto Cleanup;
    }

    RtlZeroMemory((PVOID)&AuditParameters, sizeof(AuditParameters));

    AuditParameters.CategoryId     = SE_CATEGID_SYSTEM;
    AuditParameters.AuditId        = SE_AUDITID_AUDITS_DISCARDED;
    AuditParameters.Type           = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid(AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid);
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString(AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName);
    AuditParameters.ParameterCount++;

    LsapSetParmTypeUlong(AuditParameters, AuditParameters.ParameterCount, NumberOfEventsDiscarded);
    AuditParameters.ParameterCount++;

    Status = LsapAdtDemarshallAuditInfo(&AuditParameters);

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed(Status);
    }

    return Status;
}



NTSTATUS
LsarClearAuditLog(
    IN LSAPR_HANDLE PolicyHandle
    )
/*++

Routine Description:

    This function used to clear the Audit Log but has been superseded
    by the Event Viewer functionality provided for this purpose.  To
    preserve compatibility with existing RPC interfaces, this server
    stub is retained.

Arguments:

    PolicyHandle - Handle to an open Policy Object.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_NOT_IMPLEMENTED - This routine is not implemented.
--*/

{
    UNREFERENCED_PARAMETER( PolicyHandle );
    return(STATUS_NOT_IMPLEMENTED);
}


NTSTATUS
LsapFlushSecurityLog( )
/*++

Routine Description:

    Flush the security log. This ensures that everything that was
    sent to eventlog is completely written to disk. This function
    is called immediately after generating the crash-on-audit
    fail event (SE_AUDITID_UNABLE_TO_LOG_EVENTS).

Arguments:

    none.

Return Values:

    NTSTATUS - Standard Nt Result Code.

--*/
{
    return ElfFlushEventLog( LsapAdtLogHandle ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtevent.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtevent.c

Abstract:

    Functions that implement audits generated by LSA itself.

Author:

    Scott Birrell       (ScottBi)      January 19, 1993

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "adtp.h"
#include "adtutil.h"
#include "adtdebug.h"
#include "msobjs.h"

//
// Forwards
//
NTSTATUS
LsapAdtGetDbAttributesChangeString(
    IN LSAP_DB_ATTRIBUTE* OldAttributes,
    IN LSAP_DB_ATTRIBUTE* NewAttributes,
    IN ULONG AttributeCount,
    OUT LPWSTR* AttributeChangeString
    );


NTSTATUS
LsapAdtGenerateObjectOperationAuditEvent(
    IN LSAPR_HANDLE ObjectHandle,
    IN USHORT AuditEventType,
    IN OBJECT_OPERATION_TYPE OperationType
    )
/*++

Routine Description:

    Generates an audit entry when an operation on the object
    represented by ObjectHandle succeeds/fails and if this type of
    auditing is enabled.

Arguments:

    ObjectHandle - Handle of the object being accessed

    AuditEventType - The type of audit event to be generated.
        EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    OperationType - Type of operation performed on the object
        represented by ObjectHandle.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    UNICODE_STRING OperationTypeName;
    LSAP_DB_HANDLE InternalHandle;
    UNICODE_STRING ObjectName;
    LUID SystemAuthId = SYSTEM_LUID;
    BOOLEAN bAudit;
    
    static LPCWSTR ObjectOperationNames[ObjectOperationDummyLast] = {
        L"None",
        L"Query"
    };

    LsapEnterFunc("LsapAdtGenerateObjectAcessAuditEvent");

    InternalHandle = (LSAP_DB_HANDLE) ObjectHandle;
    
    Status = LsapQueryClientInfo(
                 &TokenUserInformation,
                 &ClientAuthenticationId
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    if ( RtlEqualLuid( &ClientAuthenticationId, &SystemAuthId )) {

        //
        // do not audit secret queries by the system
        //

        goto Cleanup;
    }
    
    Status = LsapAdtAuditingEnabledByLogonId(  
                 AuditCategoryObjectAccess,
                 &ClientAuthenticationId,
                 AuditEventType,
                 &bAudit
                 );
    
    if (!NT_SUCCESS(Status) || !bAudit)
    {
        goto Cleanup;
    }

    //
    // LsarQuerySecret sometimes passes us a secret whose name will
    // be rejected by ElfReportEventW because the length parameter
    // includes the terminating NULL.
    // 
    // For example,
    //   name.Buffer        = "foo\0"
    //   name.Length        = 8
    //   name.MaximumLength = 8
    //   
    // We cannot change the input param or change the LSA code to
    // not do this, therfore we make a local copy, fix it
    // and use that instead
    //

    ObjectName = InternalHandle->PhysicalNameU;
    ObjectName.Length = (USHORT) LsapSafeWcslen( ObjectName.Buffer,
                                                 ObjectName.MaximumLength );
    
    //
    // Build an audit parameters structure.
    //
    RtlInitUnicodeString( &OperationTypeName, ObjectOperationNames[OperationType] );

    Status =
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_OBJECT_ACCESS,
        SE_AUDITID_OBJECT_OPERATION,
        AuditEventType,
        13,                     // there are 13 params to init

        //
        //    User Sid
        //
        SeAdtParmTypeSid,        TokenUserInformation->User.Sid,

        //
        //    Subsystem name
        //
        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    Object server
        //
        SeAdtParmTypeString,     &LsapLsaName,

        //
        //    Operation Type
        //
        SeAdtParmTypeString,     &OperationTypeName,

        //
        //    Object Type : index of this is 4, used later
        //
        SeAdtParmTypeString,     &LsapDbObjectTypeNames[InternalHandle->
                                                       ObjectTypeId],

        //
        //    Object Name
        //
        SeAdtParmTypeString,     &ObjectName,

        //
        //    Object Handle ID
        //
        SeAdtParmTypePtr,      ObjectHandle,

        //
        // Primary Authentication information
        //
        SeAdtParmTypeLogonId,    LsapSystemLogonId,

        //
        // Clients's Authentication information
        //
        SeAdtParmTypeLogonId,    ClientAuthenticationId,

        //
        // Requested access : 4 is the index of ObjectType parameter
        //
        SeAdtParmTypeAccessMask, InternalHandle->RequestedAccess, 4,

        //
        // there are no object properties (object-type list)
        //
        SeAdtParmTypeNone,

        //
        // no additional information
        //
        SeAdtParmTypeNone,

        //
        // Access Mask (hex)
        //
        SeAdtParmTypeHexUlong, InternalHandle->RequestedAccess
        
        );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    

    ( VOID ) LsapAdtWriteLog( &AuditParameters );

Cleanup:
    
    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if (!NT_SUCCESS(Status)) {

        LsapAuditFailed( Status );
    }

    LsapExitFunc("LsapAdtGenerateObjectAcessAuditEvent", Status);

    return Status;
}


NTSTATUS
LsapAdtGenerateLsaAuditEvent(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG AuditEventCategory,
    IN ULONG AuditEventId,
    IN PPRIVILEGE_SET Privileges,
    IN ULONG SidCount,
    IN PSID *Sids OPTIONAL,
    IN ULONG UnicodeStringCount,
    IN PUNICODE_STRING UnicodeStrings OPTIONAL,
    IN PLSARM_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo OPTIONAL
    )

/*++

Routine Description:

    This function generates an Lsa-originated Audit Event.  Audit Events
    of this kind are generated as a result of Local Security Policy changes
    such as assigning/removing user rights to an account.

Arguments:

    ObjectHandle - Specifies the handle of an object in the Lsa Policy
        Database.  For global changes to policy, a handle to the
        Lsa Policy object is passed.

    AuditEventCategory - Specifies the Id of the Audit Event Category
        to which this Audit Event belongs.

    AuditEventId - Specifies the Id of the Audit Event being generated.

    Privileges - set of privileges to be recorded

    SidCount - Count of Sids being passed via the Sids parameter.  If no
        Sids are passed, this parameter must be set to 0.

    Sids - Pointer to array of SidCount Sids.  If 0 is passed for the
        SidCount parameter, this parameter is ignored and NULL may be
        specified.

    UnicodeStringCount - Count of Unicode Strings being passed via the
        UnicodeStrings parameter.  If no Unicode Strings are passed, this
        parameter must be set to 0.

    UnicodeStrings - Pointer to array of UnicodeStringCount strings.  If 0 is
        passed for the SidCount parameter, this parameter is ignored and NULL
        may be specified.

    PolicyAuditEventsInfo - Pointer to Auditing Events information structure
        containing the AuditingMode and the array of Policy Audit Event
        Information entries.  This parameter must be non-NULL if and only if
        the AuditEventCategory parameter is SE_AUDIT_POLICY_CHANGE.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation = NULL;
    PSID ClientSid;
    BOOLEAN bAudit;

    UNREFERENCED_PARAMETER( ObjectHandle );

    if (Privileges && !IsValidPrivilegeCount(Privileges->PrivilegeCount)) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
        
    }
    
    Status = LsapQueryClientInfo(
                 &TokenUserInformation,
                 &ClientAuthenticationId
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    ClientSid = TokenUserInformation->User.Sid;

    if (AuditEventId != SE_AUDITID_POLICY_CHANGE) {

        Status = LsapAdtAuditingEnabledByLogonId(
                    LsapAdtEventTypeFromCategoryId(AuditEventCategory),
                    &ClientAuthenticationId,
                    EVENTLOG_AUDIT_SUCCESS,
                    &bAudit
                    );

        if (!NT_SUCCESS(Status) || !bAudit) {

            goto Cleanup;
        }
    }

    Status = LsapAdtGenerateLsaAuditEventWithClientSid( AuditEventCategory,
                                                        AuditEventId,
                                                        ClientSid,
                                                        ClientAuthenticationId,
                                                        Privileges,
                                                        SidCount,
                                                        Sids,
                                                        UnicodeStringCount,
                                                        UnicodeStrings,
                                                        PolicyAuditEventsInfo );



Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if ( !NT_SUCCESS( Status )) {

        LsapAuditFailed( Status );
    }
    
    return(Status);
}


NTSTATUS
LsapAdtGenerateLsaAuditEventWithClientSid(
    IN ULONG AuditEventCategory,
    IN ULONG AuditEventId,
    IN PSID ClientSid,
    IN LUID ClientAuthenticationId,
    IN PPRIVILEGE_SET Privileges,
    IN ULONG SidCount,
    IN PSID *Sids OPTIONAL,
    IN ULONG UnicodeStringCount,
    IN PUNICODE_STRING UnicodeStrings OPTIONAL,
    IN PLSARM_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo OPTIONAL
    )

/*++

Routine Description:

    This function generates an Lsa-originated Audit Event.  Audit Events
    of this kind are generated as a result of Local Security Policy changes
    such as assigning/removing user rights to an account.

    
    The decision to generate these audits is made in LsapAdtGenerateLsaAuditEvent.

Arguments:

    ObjectHandle - Specifies the handle of an object in the Lsa Policy
        Database.  For global changes to policy, a handle to the
        Lsa Policy object is passed.

    AuditEventCategory - Specifies the Id of the Audit Event Category
        to which this Audit Event belongs.

    AuditEventId - Specifies the Id of the Audit Event being generated.

    Privileges - set of privileges to be recorded
    
    SidCount - Count of Sids being passed via the Sids parameter.  If no
        Sids are passed, this parameter must be set to 0.

    Sids - Pointer to array of SidCount Sids.  If 0 is passed for the
        SidCount parameter, this parameter is ignored and NULL may be
        specified.

    UnicodeStringCount - Count of Unicode Strings being passed via the
        UnicodeStrings parameter.  If no Unicode Strings are passed, this
        parameter must be set to 0.

    UnicodeStrings - Pointer to array of UnicodeStringCount strings.  If 0 is
        passed for the SidCount parameter, this parameter is ignored and NULL
        may be specified.

    PolicyAuditEventsInfo - Pointer to Auditing Events information structure
        containing the AuditingMode and the array of Policy Audit Event
        Information entries.  This parameter must be non-NULL if and only if
        the AuditEventCategory parameter is SE_AUDIT_POLICY_CHANGE.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING NullString = {0};

    if (NULL == UnicodeStrings)
    {
        UnicodeStrings = &NullString;
    }

    UNREFERENCED_PARAMETER( UnicodeStringCount );
    UNREFERENCED_PARAMETER( SidCount );
    
    switch ( AuditEventCategory ) {
        case SE_CATEGID_POLICY_CHANGE:
            {
                switch ( AuditEventId ) {

                    default:
                        DsysAssertMsg(FALSE, "LsapAdtGenerateLsaAuditEventWithClientSid: invalid AuditEventId");
                        break;
                        
                    case SE_AUDITID_POLICY_CHANGE:
                        {
                            LsapAdtPolicyChange(
                                (USHORT)AuditEventCategory,
                                AuditEventId,
                                EVENTLOG_AUDIT_SUCCESS,
                                ClientSid,
                                ClientAuthenticationId,
                                PolicyAuditEventsInfo
                                );
                            break;
                        }

                    case SE_AUDITID_USER_RIGHT_ASSIGNED:
                    case SE_AUDITID_USER_RIGHT_REMOVED:
                        {
                            DsysAssertMsg( SidCount == 1,
                                           "LsapAdtGenerateLsaAuditEventWithClientSid" );
                            LsapAdtUserRightAssigned(
                                (USHORT)AuditEventCategory,
                                AuditEventId,
                                EVENTLOG_AUDIT_SUCCESS,
                                ClientSid,
                                ClientAuthenticationId,
                                Sids[0],
                                Privileges
                                );
                            break;
                        }
                }


            break;

            }

        default:
            {
                DsysAssertMsg( FALSE, "LsapAdtGenerateLsaAuditEventWithClientSid: unsupported audit category" );
                return( STATUS_SUCCESS );
            }
    }


    return(Status);
}


VOID
LsapAdtUserRightAssigned(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID ClientSid,
    IN LUID CallerAuthenticationId,
    IN PSID TargetSid,
    IN PPRIVILEGE_SET Privileges
    )
/*++

Routine Description:

    Generates an audit for a user right being either assigned or removed.

    The decision to generate this audit is made in LsapAdtGenerateLsaAuditEvent.

Arguments:

    ISSUE-2002/03/11-kumarp : add desc


Return Value:

    None.

--*/
{
    SE_ADT_PARAMETER_ARRAY AuditParameters;

    //
    // if no privileges are being assigned/removed, dont generate the audit
    //

    if (!(Privileges && Privileges->PrivilegeCount))
    {
        return;
    }

    //
    // Build an audit parameters structure.
    //

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = EventCategory;
    AuditParameters.AuditId = EventID;
    AuditParameters.Type = EventType;
    AuditParameters.ParameterCount = 0;

    //
    //    User Sid
    //

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, ClientSid );
    AuditParameters.ParameterCount++;

    //
    //    Subsystem name (if available)
    //

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    //
    // Rights
    //

    LsapSetParmTypePrivileges( AuditParameters, AuditParameters.ParameterCount, Privileges );
    AuditParameters.ParameterCount++;

    //
    // Target Sid
    //

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, TargetSid );
    AuditParameters.ParameterCount++;

    //
    // Caller's Authentication information
    //

    LsapSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, CallerAuthenticationId );
    AuditParameters.ParameterCount++;


    ( VOID ) LsapAdtWriteLog( &AuditParameters );

    return;
}


VOID
LsapAdtGenerateLsaAuditSystemAccessChange(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID ClientSid,
    IN LUID CallerAuthenticationId,
    IN PSID TargetSid,
    IN PCWSTR szSystemAccess
    )

/*++

Routine Description:

    Generates an audit for System Security Access changes.
    
    The decision to generate this audit is made in LsapSetSystemAccessAccount.

Arguments:

    EventCategory  - The category of this event
    EventID        - specific ID of event
    EventType      - success or failure
    ClientSid      - sid of client
    CallerAuthenticationID - Logon ID of caller
    TargetSid      - receives access change
    szSystemAccess - string describing which access changed

Return Value:

    None.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    UNICODE_STRING SystemAccessString;

    //
    // Build an audit parameters structure.
    //

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    RtlInitUnicodeString( &SystemAccessString, szSystemAccess );

    Status =
    LsapAdtInitParametersArray( &AuditParameters, 
                                EventCategory, 
                                EventID, 
                                EventType, 
                                5, 
                                SeAdtParmTypeSid,         ClientSid,
                                SeAdtParmTypeString,      &LsapSubsystemName,
                                SeAdtParmTypeLogonId,     CallerAuthenticationId,
                                SeAdtParmTypeString,      &SystemAccessString,
                                SeAdtParmTypeSid,         TargetSid
                                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    (VOID) LsapAdtWriteLog( &AuditParameters );

 Cleanup:

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }

}




NTSTATUS
LsapAdtTrustedDomainAdd(
    IN USHORT          EventType,
    IN PUNICODE_STRING pName,
    IN PSID            pSid,
    IN ULONG           Type,
    IN ULONG           Direction,
    IN ULONG           Attributes
    )
/*++

Routine Description:

    Generate an audit event when a trusted domain object (TDO) is created.

Arguments:

    EventType    - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    pName        - name of the domain

    pSid         - domain SID

    Type         - TDO type

    Direction    - TDO direction

    Attributes   - TDO attributes

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };
    BOOLEAN bAudit = FALSE;

    Status = LsapQueryClientInfo( &TokenUserInformation, &ClientAuthenticationId );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    Status = LsapAdtAuditingEnabledByLogonId(
                 AuditCategoryPolicyChange,
                 &ClientAuthenticationId,
                 EventType,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit)
    {
        goto Cleanup;
    }

    //
    // Build an audit parameters structure.
    //

    Status = 
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_TRUSTED_DOMAIN_ADD,
        EventType,
        9,                     // there are 9 params to init

        //
        //    User Sid
        //

        SeAdtParmTypeSid,        TokenUserInformation->User.Sid,

        //
        //    Subsystem name (if available)
        //

        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    domain name
        //

        SeAdtParmTypeString,      pName,

        //
        //    domain id 
        //

        SeAdtParmTypeSid,         pSid,

        //
        //    client auth-id
        //

        SeAdtParmTypeLogonId,     ClientAuthenticationId,
        
        //
        //    TDO type
        //

        SeAdtParmTypeUlong,       Type,

        //
        //    TDO direction
        //

        SeAdtParmTypeUlong,       Direction,

        //
        //    TDO attributes
        //

        SeAdtParmTypeUlong,       Attributes,

        //
        //    TDO: attribute quarantined spelled out
        //

        SeAdtParmTypeMessage,     (Attributes & TRUST_ATTRIBUTE_QUARANTINED_DOMAIN) ? SE_ADT_MSG_ENABLED : SE_ADT_MSG_DISABLED

        );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    Status = LsapAdtWriteLog( &AuditParameters );
        
Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
}


NTSTATUS
LsapAdtTrustedDomainRem(
    IN USHORT          EventType,
    IN PUNICODE_STRING pName,
    IN PSID            pSid,
    IN PSID            pClientSid,
    IN PLUID           pClientAuthId
    )
/*++

Routine Description:

    Generate an audit event when a trusted domain object (TDO) is deleted.

Arguments:

    EventType    - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    pName        - name of the domain

    pSid         - domain SID

    pClientSid   - SID of the client who deleted the TDO
                   if NULL, it is determined from the thread token

    pClientAuthId- auth-id of the client who deleted the TDO
                   if NULL, it is determined from the thread token

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };
    BOOLEAN bAudit = FALSE;

    if ( pClientSid == NULL )
    {
        DsysAssertMsg( pClientAuthId == NULL, "LsapAdtTrustedDomainRem" );
        
        Status = LsapQueryClientInfo( &TokenUserInformation,
                                      &ClientAuthenticationId );

        if ( !NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }

        pClientSid    = TokenUserInformation->User.Sid;
        pClientAuthId = &ClientAuthenticationId;
    }
#if DBG
    else
    {
        DsysAssertMsg( pClientAuthId != NULL, "LsapAdtTrustedDomainRem" );
    }
#endif

    Status = LsapAdtAuditingEnabledByLogonId(
                 AuditCategoryPolicyChange,
                 pClientAuthId,
                 EventType,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit)
    {   
        goto Cleanup;
    }

    //
    // Build an audit parameters structure.
    //

    Status =
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_TRUSTED_DOMAIN_REM,
        EventType,
        5,                     // there are 5 params to init

        //
        //    User Sid
        //

        SeAdtParmTypeSid,        pClientSid,

        //
        //    Subsystem name (if available)
        //

        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    domain name
        //

        SeAdtParmTypeString,      pName,

        //
        //    domain id (SID of the root domain)
        //

        SeAdtParmTypeSid,         pSid,

        //
        //    client auth-id
        //

        SeAdtParmTypeLogonId,     *pClientAuthId
        
        );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    Status = LsapAdtWriteLog( &AuditParameters );
        
Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
}



NTSTATUS
LsapAdtTrustedDomainMod(
    IN USHORT          EventType,
    IN PSID            pDomainSid,

    IN PUNICODE_STRING pOldName,
    IN ULONG           OldType,
    IN ULONG           OldDirection,
    IN ULONG           OldAttributes,

    IN PUNICODE_STRING pNewName,
    IN ULONG           NewType,
    IN ULONG           NewDirection,
    IN ULONG           NewAttributes
    )
/*++

Routine Description:

    Generate an audit event when a trusted domain object (TDO) is modified.
    the unmodified fields are represented by a '-' in the audit log.

Arguments:

    EventType       - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    pOldName        - old name of the domain

    pOldSid         - old domain SID

    OldType         - old TDO type

    OldDirection    - old TDO direction

    OldAttributes   - old TDO attributes

    pNewName        - new name of the domain

    pNewSid         - new domain SID

    NewType         - new TDO type

    NewDirection    - new TDO direction

    NewAttributes   - new TDO attributes

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };
    BOOLEAN bAudit = FALSE;

    Status = LsapQueryClientInfo( &TokenUserInformation, &ClientAuthenticationId );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    //
    //  if auditing is not enabled, return asap
    //

    Status = LsapAdtAuditingEnabledByLogonId(
                 AuditCategoryPolicyChange,
                 &ClientAuthenticationId,
                 EventType,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit)
    {
        goto Cleanup;
    }

    AuditParameters.CategoryId     = SE_CATEGID_POLICY_CHANGE;
    AuditParameters.AuditId        = SE_AUDITID_TRUSTED_DOMAIN_MOD;
    AuditParameters.Type           = EventType;
    AuditParameters.ParameterCount = 9;

    //
    //    User Sid
    //

    LsapSetParmTypeSid( AuditParameters, 0, TokenUserInformation->User.Sid );

    //
    //    Subsystem name (if available)
    //

    LsapSetParmTypeString( AuditParameters, 1, &LsapSubsystemName );


    //
    // for all subsequent fields (except the domain SID),
    // output a value only if it changed.
    //

    //
    //    domain name
    //

    if ( pOldName && pNewName &&
         !RtlEqualUnicodeString( pOldName, pNewName, TRUE ) )
    {
        LsapSetParmTypeString( AuditParameters, 2, pNewName );
    }

    //
    //    domain id
    //

    LsapSetParmTypeSid( AuditParameters, 3, pDomainSid );

    //
    //    client auth-id
    //

    LsapSetParmTypeLogonId( AuditParameters, 4, ClientAuthenticationId );

    //
    //    TDO type
    //

    if ( OldType != NewType )
    {
        LsapSetParmTypeUlong( AuditParameters, 5, NewType );
    }

    //
    //    TDO direction
    //

    if ( OldDirection != NewDirection )
    {
        LsapSetParmTypeUlong( AuditParameters, 6, NewDirection );
    }

    //
    //    TDO attributes
    //

    if ( OldAttributes != NewAttributes )
    {
        LsapSetParmTypeUlong( AuditParameters, 7, NewAttributes );
    }

    //
    //    TDO attributes
    //

    if ( OldAttributes != NewAttributes )
    {
        LsapSetParmTypeMessage( AuditParameters, 8, (NewAttributes & TRUST_ATTRIBUTE_QUARANTINED_DOMAIN) ? SE_ADT_MSG_ENABLED : SE_ADT_MSG_DISABLED );
    }

    Status = LsapAdtWriteLog( &AuditParameters );
        
Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }
    
    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
}


NTSTATUS
LsapAdtTrustedForestNamespaceCollision(
    IN LSA_FOREST_TRUST_COLLISION_RECORD_TYPE CollisionTargetType,
    IN PUNICODE_STRING pCollisionTargetName,
    IN PUNICODE_STRING pForestRootDomainName,
    IN PUNICODE_STRING pTopLevelName,
    IN PUNICODE_STRING pDnsName,
    IN PUNICODE_STRING pNetbiosName,
    IN PSID            pSid,
    IN ULONG           NewFlags
    )
/*++

Routine Description:

    This function generates the audit event that represents
    a namespace element collision.


Arguments:

    CollisionTargetType  - type of the collision target
        CollisionTdo  : indicates a collision with a namespace element of
                        another forest
        CollisionXref : indicates a collision with a domain in our forest 

    pCollisionTargetName -
        name of the collision target (TDO name or Xref name)

    pForestRootDomainName - name of other forest

    pTopLevelName - top level name  (NULL == not in conflict)

    pDnsName      - DNS domain name (this is NULL if TLN is non-NULL)

    pNetbiosName  - NetBIOS name    (NULL == not in conflict)

    pSid          - SID of domain   (NULL == not in conflict)

    NewFlags      - the new value of flags

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

    This event is generated only in the success case.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };
    BOOLEAN bAudit;
#if DBG
    HANDLE hToken;
#endif
    DsysAssert(( CollisionTargetType == CollisionTdo ) ||
               ( CollisionTargetType == CollisionXref));
    DsysAssert( pCollisionTargetName != NULL );
    DsysAssert( pForestRootDomainName != NULL );

#if DBG
    if ( pTopLevelName )
    {
        DsysAssert( pDnsName     == NULL );
        DsysAssert( pNetbiosName == NULL );
        DsysAssert( pSid         == NULL );
    }
    else
    {
        DsysAssert( pDnsName != NULL );

        if ( pNetbiosName != NULL )
        {
            DsysAssert( pSid == NULL );
        }

        if ( pSid != NULL )
        {
            DsysAssert( pNetbiosName == NULL );
        }
    }
#endif

    //
    //  if auditing is not enabled, return asap
    //

    Status = LsapAdtAuditingEnabledBySid(
                 AuditCategoryPolicyChange,
                 LsapLocalSystemSid,
                 EVENTLOG_AUDIT_SUCCESS,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit)
    {
        goto Cleanup;
    }

#if DBG
    //
    // make sure that this is called in the system context
    //

    Status = NtOpenThreadToken( NtCurrentThread(), TOKEN_QUERY, TRUE, &hToken );

    DsysAssertMsg( Status == STATUS_NO_TOKEN, "LsapAdtTrustedForestNamespaceCollision" );

    if ( NT_SUCCESS(Status) )
    {
        NtClose( hToken );
    }
    else
    {
        Status = STATUS_SUCCESS;
    }
    
#endif

    //
    // Build an audit parameters structure.
    //

    Status =
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_NAMESPACE_COLLISION,
        EVENTLOG_AUDIT_SUCCESS,

        //
        // number of params to follow 
        //

        10,

        //
        //    User Sid
        //

        SeAdtParmTypeSid,        LsapLocalSystemSid,

        //
        //    Subsystem name (if available)
        //
        
        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    collision target type
        //    
        //    0 == CollisionTdo
        //    1 == CollisionXref
        //    

        SeAdtParmTypeUlong,      CollisionTargetType,

        //
        //    collision target name
        //
        //    name of a TDO or cross-ref
        //    

        SeAdtParmTypeString,     pCollisionTargetName,
        
        //
        //    Name of forest involved in the collision
        //

        SeAdtParmTypeString,     pForestRootDomainName,

        //
        //    top level name
        //

        SeAdtParmTypeString,     pTopLevelName,

        //
        //    DNS name
        //

        SeAdtParmTypeString,     pDnsName,

        //
        //    NetBIOS name
        //

        SeAdtParmTypeString,     pNetbiosName,

        //
        //    SID
        //

        SeAdtParmTypeSid,        pSid,

        //
        //    new flags value
        //

        SeAdtParmTypeUlong,      NewFlags
        
        );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    Status = LsapAdtWriteLog( &AuditParameters );

Cleanup:    
    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
}


NTSTATUS
LsapAdtTrustedForestInfoEntryAddRemHelper(
    IN ULONG           EventId,
    IN USHORT          EventType,
    IN PUNICODE_STRING ForestName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
    IN ULONG           Flags,
    IN PUNICODE_STRING TopLevelName,
    IN PUNICODE_STRING DnsName,
    IN PUNICODE_STRING NetbiosName,
    IN PSID            pSid
    )
/*++

Routine Description:

    Helper function for generating audit event when a namespace
    element has been added to / removed from forest trust info.
    If multiple entries get added, deleted or modified
    in a single update of the forest trust information, all the generated
    audit events will have a single unique identifier called OperationID.
    This allows one to determine that the multiple generated audits are
    the result of a single operation.

Arguments:

    EventId              - SE_AUDITID_TRUSTED_FOREST_INFO_ENTRY_ADD/REM

    EventType            - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    ForestName           - name of the forest

    pForestRootDomainSid - SID of the forest

    pOperationId         - operation id (see description above)

    EntryType            - type of entry ( TLN | TLN excl. | domain info )

    Flags                - flags associated with the entry ( see ntlsa.h )

    TopLevelName         - TopLevel name
                   
    DnsName              - Dns name
                   
    NetbiosName          - Netbios name

    pSid                 - domain sid

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };
    BOOLEAN bAudit;

    Status = LsapQueryClientInfo( &TokenUserInformation, &ClientAuthenticationId );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    //
    //  if auditing is not enabled, return asap
    //

    Status = LsapAdtAuditingEnabledByLogonId( 
                 AuditCategoryPolicyChange,
                 &ClientAuthenticationId,
                 EventType,
                 &bAudit);
    
    if (!NT_SUCCESS(Status) || !bAudit)
    {
        goto Cleanup;
    }

    //
    // Build an audit parameters structure.
    //

    Status =
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_POLICY_CHANGE,
        EventId,
        EventType,

        //
        // number of params to follow 
        //

        13,

        //
        //    User Sid
        //

        SeAdtParmTypeSid,        TokenUserInformation->User.Sid,

        //
        //    Subsystem name (if available)
        //

        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    Forest name
        //

        SeAdtParmTypeString,     ForestName,

        //
        //    Forest SID
        //

        SeAdtParmTypeSid,        pForestRootDomainSid,

        //
        //    Operation ID
        //

        SeAdtParmTypeUlong,      pOperationId->HighPart,
        SeAdtParmTypeUlong,      pOperationId->LowPart,

        //
        //    Entry Type
        //

        SeAdtParmTypeUlong,      EntryType,

        //
        //    Flags
        //

        SeAdtParmTypeUlong,      Flags,

        //
        //    top level name
        //

        SeAdtParmTypeString,     TopLevelName,

        //
        //    DNS domain name
        //

        SeAdtParmTypeString,     DnsName,

        //
        //    NetBIOS domain name
        //

        SeAdtParmTypeString,     NetbiosName,

        //
        //    domain SID
        //

        SeAdtParmTypeSid,        pSid,

        //
        //    user info
        //

        SeAdtParmTypeLogonId,    ClientAuthenticationId
        );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    Status = LsapAdtWriteLog( &AuditParameters );
        
Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }
    
    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
}


NTSTATUS
LsapAdtTrustedForestInfoEntryAdd(
    IN PUNICODE_STRING pForestRootDomainName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
    IN ULONG           Flags,
    IN PUNICODE_STRING TopLevelName,
    IN PUNICODE_STRING DnsName,
    IN PUNICODE_STRING NetbiosName,
    IN PSID            pSid
    )
{
    return LsapAdtTrustedForestInfoEntryAddRemHelper(
        SE_AUDITID_TRUSTED_FOREST_INFO_ENTRY_ADD,
        EVENTLOG_AUDIT_SUCCESS,
        pForestRootDomainName,
        pForestRootDomainSid,
        pOperationId,
        EntryType,
        Flags,
        TopLevelName,
        DnsName,
        NetbiosName,
        pSid
        );
}
     

NTSTATUS
LsapAdtTrustedForestInfoEntryRem(
    IN PUNICODE_STRING pForestRootDomainName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
    IN ULONG           Flags,
    IN PUNICODE_STRING TopLevelName,
    IN PUNICODE_STRING DnsName,
    IN PUNICODE_STRING NetbiosName,
    IN PSID            pSid
    )
{
    return LsapAdtTrustedForestInfoEntryAddRemHelper(
        SE_AUDITID_TRUSTED_FOREST_INFO_ENTRY_REM,
        EVENTLOG_AUDIT_SUCCESS,
        pForestRootDomainName,
        pForestRootDomainSid,
        pOperationId,
        EntryType,
        Flags,
        TopLevelName,
        DnsName,
        NetbiosName,
        pSid
        );
}
     

NTSTATUS
LsapAdtTrustedForestInfoEntryMod(
    IN PUNICODE_STRING pForestRootDomainName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
                                    
    IN ULONG           OldFlags,
    IN PUNICODE_STRING pOldTopLevelName,
    IN PUNICODE_STRING pOldDnsName,
    IN PUNICODE_STRING pOldNetbiosName,
    IN PSID            pOldSid,
                       
    IN ULONG           NewFlags,
    IN PUNICODE_STRING pNewTopLevelName,
    IN PUNICODE_STRING pNewDnsName,
    IN PUNICODE_STRING pNewNetbiosName,
    IN PSID            pNewSid
    )
/*++

Routine Description:

    Helper function for generating audit event when a namespace
    element in forest trust info has been modified.
    If multiple entries get added, deleted or modified
    in a single update of the forest trust information, all the generated
    audit events will have a single unique identifier called OperationID.
    This allows one to determine that the multiple generated audits are
    the result of a single operation.

Arguments:

    EventType            - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    ForestName           - name of the forest

    pForestRootDomainSid - SID of the forest

    pOperationId         - operation id (see description above)

    EntryType            - type of entry ( TLN | TLN excl. | domain info )

    OldFlags             - old flags associated with the entry ( see ntlsa.h )

    pOldTopLevelName     - old TopLevel name
                   
    pOldDnsName          - old Dns name
                   
    pOldNetbiosName      - old Netbios name

    pOldSid              - old domain sid

    NewFlags             - new flags associated with the entry ( see ntlsa.h )

    pNewTopLevelName     - new TopLevel name
                   
    pNewDnsName          - new Dns name
                   
    pNewNetbiosName      - new Netbios name

    pNewSid              - new domain sid

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

    The unmodified fields are represented by a '-' in the audit log.


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };
    BOOLEAN bAudit;

    Status = LsapQueryClientInfo( &TokenUserInformation, &ClientAuthenticationId );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    //
    //  if auditing is not enabled, return asap
    //

    Status = LsapAdtAuditingEnabledByLogonId( 
                 AuditCategoryPolicyChange,
                 &ClientAuthenticationId,
                 EVENTLOG_AUDIT_SUCCESS,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit)
    {
        goto Cleanup;
    }

    AuditParameters.CategoryId     = SE_CATEGID_POLICY_CHANGE;
    AuditParameters.AuditId        = SE_AUDITID_TRUSTED_FOREST_INFO_ENTRY_MOD;
    AuditParameters.Type           = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 13;

    //
    //    User Sid
    //

    LsapSetParmTypeSid( AuditParameters, 0, TokenUserInformation->User.Sid );

    //
    //    Subsystem name (if available)
    //

    LsapSetParmTypeString( AuditParameters, 1, &LsapSubsystemName );


    //
    //    forest name
    //

    LsapSetParmTypeString( AuditParameters, 2, pForestRootDomainName );

    //
    //    forest id (SID of the root domain)
    //

    LsapSetParmTypeSid( AuditParameters, 3, pForestRootDomainSid );

    //
    //    Operation ID
    //

    LsapSetParmTypeUlong( AuditParameters, 4, pOperationId->HighPart );
    LsapSetParmTypeUlong( AuditParameters, 5, pOperationId->LowPart );

    //
    //    entry type
    //

    LsapSetParmTypeUlong( AuditParameters, 6, EntryType );

    //
    // for all subsequent types, output a value only if it changed.
    //

    //
    //    Flags
    //

    if ( OldFlags != NewFlags )
    {
        LsapSetParmTypeUlong( AuditParameters, 7, NewFlags );
    }

    //
    //    top level name
    //

    if ( pOldTopLevelName && pNewTopLevelName &&
         !RtlEqualUnicodeString( pOldTopLevelName, pNewTopLevelName, TRUE ) )
    {
        LsapSetParmTypeString( AuditParameters, 8, pNewTopLevelName );
    }

    //
    //    DNS domain name
    //

    if ( pOldDnsName && pNewDnsName &&
         !RtlEqualUnicodeString( pOldDnsName, pNewDnsName, TRUE ) )
    {
        LsapSetParmTypeString( AuditParameters, 9, pNewDnsName );
    }

    //
    //    NetBIOS domain name
    //

    if ( pOldNetbiosName && pNewNetbiosName &&
         !RtlEqualUnicodeString( pOldNetbiosName, pNewNetbiosName, TRUE ) )
    {
        LsapSetParmTypeString( AuditParameters, 10, pNewNetbiosName );
    }

    //
    //    domain SID
    //

    if ( pOldSid && pNewSid && !RtlEqualSid( pOldSid, pNewSid ) )
    {
        LsapSetParmTypeSid( AuditParameters, 11, pNewSid );
    }
    
    //
    //    client auth-id
    //

    LsapSetParmTypeLogonId( AuditParameters, 12, ClientAuthenticationId );

    
    Status = LsapAdtWriteLog( &AuditParameters );
        
Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }
    
    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
    
}



VOID
LsapAdtPolicyChange(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID ClientSid,
    IN LUID CallerAuthenticationId,
    IN PLSARM_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo
    )
/*++

Routine Description:

    Generates an audit for a policy change event.

    The decision to generate this audit is made in LsapAdtGenerateLsaAuditEvent.

Arguments:

    EventCategory - The category of this audit.

    EventID - The event we are auditing.

    EventType - Whether the audit is success or failure.

    ClientSid - The SID of the user performing the policy change.

    CallerAuthenticationId - The Authentication id of the user.

    PolicyAuditEventsInfo - The information to audit.


Return Value:

    None.

Note:
--*/
{
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    UNICODE_STRING Enabled;
    UNICODE_STRING Disabled;
    ULONG i;

    RtlInitUnicodeString( &Enabled, L"+" );
    RtlInitUnicodeString( &Disabled, L"-" );
    EventAuditingOptions = PolicyAuditEventsInfo->EventAuditingOptions;

    //
    // Build an audit parameters structure.
    //

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = EventCategory;
    AuditParameters.AuditId = EventID;
    AuditParameters.Type = EventType;
    AuditParameters.ParameterCount = 0;

    //
    //    User Sid
    //

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, ClientSid );
    AuditParameters.ParameterCount++;

    //
    //    Subsystem name (if available)
    //

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    //
    // If auditing is disabled, mark all options as disabled. Otherwise
    // mark them as the appropriate
    //

    for ( i=0; i<POLICY_AUDIT_EVENT_TYPE_COUNT; i++ ) {

        LsapSetParmTypeString(
            AuditParameters,
            AuditParameters.ParameterCount,
            (EventAuditingOptions[i] & POLICY_AUDIT_EVENT_SUCCESS ? &Enabled : &Disabled)
            );

        AuditParameters.ParameterCount++;

        LsapSetParmTypeString(
            AuditParameters,
            AuditParameters.ParameterCount,
            (EventAuditingOptions[i] & POLICY_AUDIT_EVENT_FAILURE ? &Enabled : &Disabled)
            );

        AuditParameters.ParameterCount++;
    }

    //
    // Caller's Authentication information
    //

    LsapSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, CallerAuthenticationId );
    AuditParameters.ParameterCount++;


    ( VOID ) LsapAdtWriteLog( &AuditParameters );

    return;
}



NTSTATUS
LsapAdtGenerateDomainPolicyChangeAuditEvent(
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN USHORT AuditEventType,
    IN LSAP_DB_ATTRIBUTE* OldAttributes,
    IN LSAP_DB_ATTRIBUTE* NewAttributes,
    IN ULONG AttributeCount
    )
/*++

Routine Description:

    Generate an audit event when any of the following policies changes:
    - PolicyDomainEfsInformation
    - PolicyDomainKerberosTicketInformation

Arguments:

    InformationClass - type of policy that changed

    AuditEventType - The type of audit event to be generated.
        EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    OldAttributes - pointer to array of old attributes

    NewAttributes - pointer to array of new attributes

    AttributeCount - number of attributes

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status=STATUS_SUCCESS;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    ULONG AuditId;
    LPWSTR AttributeChanges=NULL;
    UNICODE_STRING ChangesToAttributes;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    BOOLEAN bAudit;

    Status = LsapQueryClientInfo(
                 &TokenUserInformation,
                 &ClientAuthenticationId
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    Status = LsapAdtAuditingEnabledByLogonId(
                 AuditCategoryPolicyChange,
                 &ClientAuthenticationId,
                 AuditEventType,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit)
    {
        goto Cleanup;
    }

    switch (InformationClass) {
        default:
            ASSERT(FALSE);
            goto Cleanup;
            break;
            
        case PolicyDomainEfsInformation:
            AuditId = SE_AUDITID_EFS_POLICY_CHANGE;
            break;
        
        case PolicyDomainKerberosTicketInformation:
            AuditId = SE_AUDITID_KERBEROS_POLICY_CHANGE;
            break;
    }

    Status = LsapAdtGetDbAttributesChangeString( OldAttributes,
                                                 NewAttributes,
                                                 AttributeCount,
                                                 &AttributeChanges );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    RtlInitUnicodeString(&ChangesToAttributes, AttributeChanges);

    Status =
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_POLICY_CHANGE,
        AuditId,
        AuditEventType,
        4,
        //
        //    User Sid
        //
        SeAdtParmTypeSid,     TokenUserInformation->User.Sid,

        //
        //    Subsystem name (if available)
        //
        SeAdtParmTypeString,  &LsapSubsystemName,

        //
        //    Caller's Authentication information
        //
        SeAdtParmTypeLogonId, ClientAuthenticationId,

        //
        //    Changes to attributes
        //
        SeAdtParmTypeString,  &ChangesToAttributes);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    ( VOID ) LsapAdtWriteLog( &AuditParameters );

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed(Status);
    }

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }
    
    LsapFreeLsaHeap( AttributeChanges );
    
    return Status;
}


VOID 
LsapAdtGetAttributeValueString(
    IN  LSAP_DB_ATTRIBUTE* Attribute,
    OUT LPWSTR ValueString   OPTIONAL,
    IN OUT PULONG RequiredLength
    )
/*++

Routine Description:

    Generate a string representation of the value of an attribute

Arguments:

    Attribute - pointer to attribute

    ValueString - receives a string representation of the value of Attribute

    RequiredLength - pointer to length of ValueString

Return Value:

    None

Notes:

--*/
{
    WCHAR Buffer[32];
    ULONG Length;

    if (Attribute->AttributeValue) {
        
        switch (Attribute->DbNameIndex) {

            default:
                lstrcpy(Buffer, L"unknown");
                break;

            // binary blob
            case PolEfDat:
                lstrcpy(Buffer, L"<binary data>");
                break;

                // ULONG
            case KerOpts:
                swprintf(Buffer, L"0x%x", *((ULONG*) Attribute->AttributeValue));
                break;

                // LARGE_INTEGER
            case KerMinT:
            case KerMaxT:
            case KerMaxR:
            case KerProxy:
            case KerLogoff:
                swprintf(Buffer, L"0x%I64x",
                         *((ULONGLONG*) Attribute->AttributeValue));
                break;
        }
    } else {
        lstrcpy(Buffer, L"none");
    }

    Length = lstrlen(Buffer);

    if (ValueString && Length <= *RequiredLength)
    {
        CopyMemory(
            ValueString,
            Buffer,
            Length * sizeof(WCHAR));
    }

    *RequiredLength = Length;
}


VOID
LsapAdtGetDbAttributeChangeString(
    IN LSAP_DB_ATTRIBUTE* OldAttribute,
    IN LSAP_DB_ATTRIBUTE* NewAttribute,
    OUT LPWSTR AttributeChangeString,   OPTIONAL
    IN OUT PULONG RequiredLength
    )
/*++

Routine Description:

    Given an old attribute and a new attribute, return 
    a string representation of the difference between the two.

    If there are no changes, RequiredLength is returned as 0
    and AttributeChangeString is left unchanged;
    otherwise if AttributeChangeString is non-NULL, the change is
    written to it as:
    <ParameterName>: <new value> (<old value>)

Arguments:

    OldAttribute - pointer to old attribute

    NewAttribute - pointer to new attribute

    AttributeChangeString - if non-NULL, receives the string representation
        of the difference between OldAttribute and NewAttribute

    RequiredLength - pointer to length of AttributeChangeString

Return Value:

    None

Notes:

--*/
{
    PWSTR TmpString;
    ULONG ChangeStringLength = 0;
    ULONG ValueLength;

    //
    // do the processing only if there is a change in value
    //
    if ((OldAttribute->AttributeValue && NewAttribute->AttributeValue &&
         (0 != memcmp(OldAttribute->AttributeValue,
                      NewAttribute->AttributeValue,
                      OldAttribute->AttributeValueLength))) ||
        (OldAttribute->AttributeValue  && !NewAttribute->AttributeValue) ||
        (!OldAttribute->AttributeValue &&  NewAttribute->AttributeValue))
    {
        ChangeStringLength += OldAttribute->AttributeName->Length / sizeof(WCHAR);
        ChangeStringLength += 2;    // ": "
        LsapAdtGetAttributeValueString(NewAttribute, 0, &ValueLength);
        ChangeStringLength += ValueLength;
        ChangeStringLength += 2;    // " ("
        LsapAdtGetAttributeValueString(OldAttribute, 0, &ValueLength);
        ChangeStringLength += ValueLength;
        ChangeStringLength += 4;    // ");  "

        if (AttributeChangeString && ChangeStringLength <= *RequiredLength)
        {
            //
            // Parameter Name
            //
            lstrcpy(AttributeChangeString, OldAttribute->AttributeName->Buffer);
            ChangeStringLength = OldAttribute->AttributeName->Length / sizeof(WCHAR);
            TmpString = AttributeChangeString + ChangeStringLength;

            lstrcpy(TmpString, L": ");
            ChangeStringLength += 2;
            TmpString = AttributeChangeString + ChangeStringLength;

            //
            // Old value
            //
            ValueLength = *RequiredLength - ChangeStringLength;
            LsapAdtGetAttributeValueString( NewAttribute, TmpString, &ValueLength );
            ChangeStringLength += ValueLength;
            TmpString = AttributeChangeString + ChangeStringLength;
        
            //
            // New value
            //
            lstrcpy(TmpString, L" (");
            ChangeStringLength += 2;
            TmpString = AttributeChangeString + ChangeStringLength;

            ValueLength = *RequiredLength - ChangeStringLength;
            LsapAdtGetAttributeValueString( OldAttribute, TmpString, &ValueLength );
            ChangeStringLength += ValueLength;
            TmpString = AttributeChangeString + ChangeStringLength;

            //
            // Don't copy the terminating '\0' in order to avoid a BO !
            //
            CopyMemory(TmpString, L");  ", 4 * sizeof(WCHAR));
            ChangeStringLength += 4;
        }
    }

    *RequiredLength = ChangeStringLength;
}

NTSTATUS
LsapAdtGetDbAttributesChangeString(
    IN LSAP_DB_ATTRIBUTE* OldAttributes,
    IN LSAP_DB_ATTRIBUTE* NewAttributes,
    IN ULONG AttributeCount,
    OUT LPWSTR* AttributeChangeString
    )
/*++

Routine Description:

    Given old attributes and new attributes, return a string representation
    of the difference between old and new attributes.

    If there are no changes, "--" is returned,
    otherwise each change is written to the string as:
    <ParameterName>: <new value> (<old value>)

    This function is used for writing information about
    changes to certain policies to the audit log.
    
Arguments:

    OldAttributes - pointer to array of old attributes

    NewAttributes - pointer to array of new attributes

    AttributeCount - Number of attributes. 

    AttributeChangeString - pointer to string that receives the diff.

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

    Memory allocated for AttributeChangeString must be freed by the
    caller using LsapFreeLsaHeap.

--*/
{
    NTSTATUS Status=STATUS_SUCCESS;
    LSAP_DB_ATTRIBUTE* OldAttribute;
    LSAP_DB_ATTRIBUTE* NewAttribute;
    ULONG TmpStringLength;
    ULONG TotalRequiredLength;
    LPWSTR TmpString;
    UINT AttributeNumber;
    USHORT n=1;
        
    OldAttribute = OldAttributes;
    NewAttribute = NewAttributes;

    TotalRequiredLength = 0;

    //
    // first find out the size of the buffer required
    //
    for (AttributeNumber = 0; AttributeNumber < AttributeCount; AttributeNumber++) {

        LsapAdtGetDbAttributeChangeString( OldAttribute, NewAttribute,
                                           NULL, &TmpStringLength );
        OldAttribute++;
        NewAttribute++;
        TotalRequiredLength += TmpStringLength;
    }

    //
    // reserve space for '--'
    //

    if (!TotalRequiredLength) {
        n += 2;
    }

    *AttributeChangeString = TmpString =
        LsapAllocateLsaHeap((TotalRequiredLength+n)*sizeof(WCHAR));
    
    if ( TmpString ) {

        if (TotalRequiredLength) {
            
            //
            // Now get the actual string
            //
            OldAttribute = OldAttributes;
            NewAttribute = NewAttributes;

            for (AttributeNumber = 0;
                 AttributeNumber < AttributeCount;
                 AttributeNumber++) {

                TmpStringLength = TotalRequiredLength;
                LsapAdtGetDbAttributeChangeString( OldAttribute, NewAttribute,
                                                   TmpString, &TmpStringLength );
                TmpString += TmpStringLength;
                OldAttribute++;
                NewAttribute++;
            }

            *TmpString = L'\0';
        } else {
            lstrcpy(TmpString, L"--");
        }
    } else {
        Status = STATUS_NO_MEMORY;
    }

    return Status;
}


PLUID LsaFilterPrivileges[] =
    {
        &ChangeNotifyPrivilege,
        &AuditPrivilege,
        &CreateTokenPrivilege,
        &AssignPrimaryTokenPrivilege,
        &BackupPrivilege,
        &RestorePrivilege,
        &DebugPrivilege,
        NULL
    };


VOID
LsapAdtAuditSpecialPrivileges(
    PPRIVILEGE_SET Privileges,
    LUID LogonId,
    PSID UserSid
    )
/*++

Routine Description:

    Audits the assignment of special privileges at logon time.

Arguments:

    Privileges - List of privileges being assigned.

Return Value:

    None.

--*/
{
    PPRIVILEGE_SET Buffer = NULL;
    PLUID *FilterPrivilege = NULL;
    ULONG i;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    BOOLEAN bAuditPrivUse = FALSE;
    BOOLEAN bAuditLogon   = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    if ( (Privileges == NULL) || (Privileges->PrivilegeCount == 0) ) {
        goto Cleanup;
    }

    //
    // allow this audit to be generated when either the logon/logoff
    // or the priv-use category is enabled
    //

    Status = LsapAdtAuditingEnabledByLogonId(
                 AuditCategoryPrivilegeUse,
                 &LogonId,
                 EVENTLOG_AUDIT_SUCCESS,
                 &bAuditPrivUse
                 );

    if (!NT_SUCCESS(Status)) {
        
        goto Cleanup;
    }

    Status = LsapAdtAuditingEnabledByLogonId(
                 AuditCategoryLogon,
                 &LogonId,
                 EVENTLOG_AUDIT_SUCCESS,
                 &bAuditLogon
                 );

    if (!NT_SUCCESS(Status)) {
        
        goto Cleanup;
    }

    //
    // if neither category is set, return quickly
    //

    if ( !bAuditPrivUse && !bAuditLogon ) {

        goto Cleanup;
        
    }

    DsysAssertMsg( IsValidPrivilegeCount(Privileges->PrivilegeCount),
                   "LsapAdtAuditSpecialPrivileges" );


    //
    // We can't need any more space than what's being passed in.
    //

    Buffer = (PPRIVILEGE_SET)LsapAllocateLsaHeap( LsapPrivilegeSetSize( Privileges ) );

    if ( Buffer == NULL ) {
        
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Buffer->PrivilegeCount = 0;

    //
    // For each privilege in the privilege set, see if it's in the filter
    // list.
    //

    for ( i=0; i<Privileges->PrivilegeCount; i++) {

        FilterPrivilege = LsaFilterPrivileges;

        do {

            if ( RtlEqualLuid( &Privileges->Privilege[i].Luid, *FilterPrivilege )) {

                Buffer->Privilege[Buffer->PrivilegeCount].Luid = **FilterPrivilege;
                Buffer->PrivilegeCount++;
            }

        } while ( *++FilterPrivilege != NULL  );
    }

    if ( Buffer->PrivilegeCount == 0 ) {
        goto Cleanup;
    }

    //
    // We matched on at least one, generate an audit.
    //

    RtlZeroMemory ((PVOID) &AuditParameters, sizeof( AuditParameters ));

    AuditParameters.CategoryId     = SE_CATEGID_PRIVILEGE_USE;
    AuditParameters.AuditId        = SE_AUDITID_ASSIGN_SPECIAL_PRIV;
    AuditParameters.Type           = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, LogonId );
    AuditParameters.ParameterCount++;

    LsapSetParmTypePrivileges( AuditParameters, AuditParameters.ParameterCount, Buffer );
    AuditParameters.ParameterCount++;

    ( VOID ) LsapAdtWriteLog( &AuditParameters );

Cleanup:

    if (!NT_SUCCESS(Status)) {

        LsapAuditFailed(Status);
    }

    if (Buffer != NULL) {
        
        LsapFreeLsaHeap( Buffer );
    }

    return;
}




VOID
LsapAdtAuditPackageLoad(
    PUNICODE_STRING PackageFileName
    )

/*++

Routine Description:

    Audits the loading of an authentication package.

Arguments:

    PackageFileName - The name of the package being loaded.

Return Value:

    None.

--*/

{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    NTSTATUS Status;
    BOOLEAN bAudit;

    Status = LsapAdtAuditingEnabledBySid(
                 AuditCategorySystem,
                 LsapLocalSystemSid,
                 EVENTLOG_AUDIT_SUCCESS,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit) {
        goto Cleanup;
    }

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_SYSTEM;
    AuditParameters.AuditId = SE_AUDITID_AUTH_PACKAGE_LOAD;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, PackageFileName );
    AuditParameters.ParameterCount++;

    ( VOID ) LsapAdtWriteLog( &AuditParameters );

Cleanup:

    if (!NT_SUCCESS(Status)) {

        LsapAuditFailed(Status);
    }
    return;
}


VOID
LsapAdtAuditLogonProcessRegistration(
    IN PLSAP_AU_REGISTER_CONNECT_INFO_EX ConnectInfo
    )

/*++

Routine Description:

    Audits the registration of a logon process

Arguments:

    ConnectInfo - Supplies the connection information for the new
        logon process.


Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING Unicode = {0};
    PSZ LogonProcessNameBuffer = NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    BOOLEAN bAudit;

    Status = LsapAdtAuditingEnabledBySid(
                 AuditCategorySystem,
                 LsapLocalSystemSid,
                 EVENTLOG_AUDIT_SUCCESS,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit) {
        goto Cleanup;
    }

    //
    // Turn the name text in the ConnectInfo structure into
    // something we can work with.
    //

    LogonProcessNameBuffer = (PSZ)LsapAllocateLsaHeap( ConnectInfo->LogonProcessNameLength+1 );

    if ( LogonProcessNameBuffer == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory(
        LogonProcessNameBuffer,
        ConnectInfo->LogonProcessName,
        ConnectInfo->LogonProcessNameLength
        );

    LogonProcessNameBuffer[ConnectInfo->LogonProcessNameLength] = 0;
    RtlInitAnsiString( &AnsiString, LogonProcessNameBuffer );

    Status = RtlAnsiStringToUnicodeString( &Unicode, &AnsiString, TRUE );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_SYSTEM;
    AuditParameters.AuditId = SE_AUDITID_SYSTEM_LOGON_PROC_REGISTER;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &Unicode );
    AuditParameters.ParameterCount++;

    ( VOID ) LsapAdtWriteLog( &AuditParameters );

Cleanup:

    if (!NT_SUCCESS(Status)) {
        LsapAuditFailed(Status);
    }
    LsapFreeLsaHeap( LogonProcessNameBuffer );
    RtlFreeUnicodeString( &Unicode );

    return;
}




VOID
LsapAdtSystemRestart(
    PLSARM_POLICY_AUDIT_EVENTS_INFO AuditEventsInfo
    )

/*++

Routine Description:

    This function is called during LSA initialization to generate
    a system restart event.

Arguments:

    AuditEventsInfo - Auditing data.


Return Value:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    BOOLEAN bAudit;

    Status = LsapAdtAuditingEnabledBySid(
                 AuditCategorySystem,
                 LsapLocalSystemSid,
                 EVENTLOG_AUDIT_SUCCESS,
                 &bAudit
                 );

    if (!NT_SUCCESS(Status) || !bAudit) {
        
        goto Cleanup;
    }

    //
    // Construct an audit parameters array
    // for the restart event.
    //

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_SYSTEM;
    AuditParameters.AuditId = SE_AUDITID_SYSTEM_RESTART;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 0;

    //
    //    User Sid
    //

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid );

    AuditParameters.ParameterCount++;

    //
    //    Subsystem name
    //

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );

    AuditParameters.ParameterCount++;

    ( VOID ) LsapAdtWriteLog( &AuditParameters );

Cleanup:

    if (!NT_SUCCESS(Status)) {
        
        LsapAuditFailed(Status);
    }
    
    return;
}


VOID
LsapAdtAuditLogon(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING Source,
    IN PUNICODE_STRING PackageName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PSID UserSid,
    IN LUID AuthenticationId,
    IN PUNICODE_STRING WorkstationName,
    IN NTSTATUS LogonStatus,
    IN NTSTATUS SubStatus,
    IN LPGUID LogonGuid,                        OPTIONAL
    IN PLUID  CallerLogonId,                    OPTIONAL
    IN PHANDLE CallerProcessID,                 OPTIONAL
    IN PLSA_ADT_STRING_LIST TransittedServices, OPTIONAL
    IN SOCKADDR* pSockAddr                      OPTIONAL
    )

/*++

Routine Description:

    Generates an audit of a logon event as appropriate.

Arguments:



Return Value:

    None.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING AuthenticationIdString = { 0 };
    BOOLEAN FreeWhenDone = FALSE;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    BOOL AuditingSuccess;
    BOOL AuditingFailure;
    PSID pSid;
    PLSAP_LOGON_SESSION pLogonSession = NULL;
    BOOLEAN bAudit = FALSE;
    UNICODE_STRING LocalAccountName;
    UNICODE_STRING LocalAuthenticatingAuthority;
    UNICODE_STRING LocalWorkstationName;
    
    //
    // Get the system Audit settings
    //
    
    AuditingFailure = (EventType == EVENTLOG_AUDIT_FAILURE) && LsapAdtAuditingEnabledByCategory(AuditCategoryLogon, EVENTLOG_AUDIT_FAILURE);
    AuditingSuccess = (EventType == EVENTLOG_AUDIT_SUCCESS) && LsapAdtAuditingEnabledByCategory(AuditCategoryLogon, EVENTLOG_AUDIT_SUCCESS);

    //
    // If this is a success audit then we have a real user sid.  Check if there 
    // exist per user audit settings for the user which may override system
    // settings.
    //
    // In case of failed logons, the auth packages do not pass us the
    // user SID therefore we cannot check pua policy here
    // 

    if (AuditingSuccess)
    {
        Status = LsapAdtAuditingEnabledByLogonId(
                     AuditCategoryLogon,
                     &AuthenticationId,
                     EVENTLOG_AUDIT_SUCCESS,
                     &bAudit
                     );

        if (!NT_SUCCESS(Status) || !bAudit)
        {
            goto Finish;
        }
    }

    //
    // return quickly if auditing is not enabled
    //
    if ( !(AuditingFailure || AuditingSuccess || bAudit) )
    {
        return;
    }
    
    //
    // Build an audit parameters structure.
    //

    RtlZeroMemory ( (PVOID) &AuditParameters, sizeof( AuditParameters ) );

    AuditParameters.CategoryId = EventCategory;
    AuditParameters.AuditId = EventID;
    AuditParameters.Type = EventType;
    AuditParameters.ParameterCount = 0;

    //
    // If this is a successful logon audit event and the caller did not
    // supply a logon GUID, extract it from the logon session.
    //
    if ( AuditingSuccess && !LogonGuid &&
         ( EventType == EVENTLOG_AUDIT_SUCCESS ) )
    {
        pLogonSession = LsapLocateLogonSession( &AuthenticationId );

        ASSERT( pLogonSession && L"LsapAdtAuditLogon: logon session not found" );
        
        if ( pLogonSession )
        {
            LogonGuid = &pLogonSession->LogonGuid;
        }
    }

#if DBG
    if ( AuditingSuccess )
    {
        DsysAssert( EventID != SE_AUDITID_DOMAIN_TRUST_INCONSISTENT );
    }
#endif
    //
    //    User Sid
    //

    pSid = AuditingSuccess ? UserSid : LsapLocalSystemSid;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, pSid );

    AuditParameters.ParameterCount++;

    //
    //    Subsystem name
    //

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

        //
        //    Account name
        //

    if ( ARGUMENT_PRESENT( AccountName ) ) {


        LocalAccountName = *AccountName;

        if ( EventID == SE_AUDITID_UNKNOWN_USER_OR_PWD ) {

            //
            // For failed logons of type SE_AUDITID_UNKNOWN_USER_OR_PWD
            // the user name can be invalid (for example,
            // with embedded NULLs). This causes the
            // eventlog to reject the string and we drop the audit.
            //
            // To avoid this, adjust the length parameter if necessary.
            //

            LocalAccountName.Length =
                (USHORT) LsapSafeWcslen( LocalAccountName.Buffer,
                                         LocalAccountName.MaximumLength );
        
        }

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LocalAccountName );
        
    } 

    AuditParameters.ParameterCount++;

        //
        //    Authenticating Authority (domain name)
        //

    if ( ARGUMENT_PRESENT( AuthenticatingAuthority ) ) {


        LocalAuthenticatingAuthority = *AuthenticatingAuthority;

        //
        // The domain name is used by NTLM as unauthenticated hint
        // thus it can be invalid (for example,
        // with embedded NULLs). This causes the
        // eventlog to reject the string and we drop the audit.
        //
        // To avoid this, adjust the length parameter if necessary.
        //

        LocalAuthenticatingAuthority.Length =
            (USHORT) LsapSafeWcslen( LocalAuthenticatingAuthority.Buffer,
                                     LocalAuthenticatingAuthority.MaximumLength );
        

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LocalAuthenticatingAuthority );

    } 

    AuditParameters.ParameterCount++;

    if ( AuditingSuccess ) {

        //
        //    Logon Id (as a string)
        //

        Status = LsapAdtBuildLuidString(
                     &AuthenticationId,
                     &AuthenticationIdString,
                     &FreeWhenDone
                     );

        if ( NT_SUCCESS( Status )) {

            LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &AuthenticationIdString );

        } else {

            goto Finish;
        }

        AuditParameters.ParameterCount++;
    } 

    //
    //    Logon Type
    //

    LsapSetParmTypeUlong( AuditParameters, AuditParameters.ParameterCount, LogonType );
    AuditParameters.ParameterCount++;

        //
        //    Source
        //

    if ( ARGUMENT_PRESENT( Source )) {

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, Source );

    } else {

        //
        // No need to do anything here, since an empty entry will turn
        // into a '-' in the output
        //

    }

    AuditParameters.ParameterCount++;

        //
        // Authentication Package
        //

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, PackageName );
    AuditParameters.ParameterCount++;

        //
        // Workstation Name
        //

    if ( ARGUMENT_PRESENT( WorkstationName )) {


        LocalWorkstationName = *WorkstationName;

        //
        // NTLM accepts wks name from clients. A client can supply
        // invalid name (for example, with embedded NULLs). This causes
        // eventlog to reject the string and we drop the audit.
        //
        // To avoid this, adjust the length parameter if necessary.
        //

        LocalWorkstationName.Length =
            (USHORT) LsapSafeWcslen( LocalWorkstationName.Buffer,
                                     LocalWorkstationName.MaximumLength );
        
        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LocalWorkstationName );
    }

    AuditParameters.ParameterCount++;

    if ( EventID == SE_AUDITID_UNSUCCESSFUL_LOGON ) {

        //
        // we need to supply the logon status for this event,
        // so that some information can be gleened from the log.
        //

        LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, LogonStatus );
        AuditParameters.ParameterCount++;
        LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, SubStatus );
        AuditParameters.ParameterCount++;
    }

    //
    // Logon GUID
    //

    if ( ARGUMENT_PRESENT( LogonGuid )) {

        LsapSetParmTypeGuid( AuditParameters, AuditParameters.ParameterCount, LogonGuid );
        AuditParameters.ParameterCount++;
    }

    //
    //    Caller Logon-ID
    //

    if ( ARGUMENT_PRESENT( CallerLogonId )) {

        LsapSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, *CallerLogonId );
    } else {

        LsapSetParmTypeNoLogon( AuditParameters, AuditParameters.ParameterCount );
    }

    AuditParameters.ParameterCount++;
    
    //
    //    Caller Process-ID
    //                   

    if ( ARGUMENT_PRESENT( CallerProcessID )) {

        LsapSetParmTypePtr( AuditParameters, AuditParameters.ParameterCount, *CallerProcessID );
    }

    AuditParameters.ParameterCount++;

    //
    //    Transitted Services (Kerberos only)
    //                   

    if ( ARGUMENT_PRESENT( TransittedServices )) {

        LsapSetParmTypeStringList( AuditParameters, AuditParameters.ParameterCount, TransittedServices );
    }

    AuditParameters.ParameterCount++;

    //
    //    IP address/port of caller
    //
    if ( ARGUMENT_PRESENT( pSockAddr )) {

        LsapSetParmTypeSockAddr( AuditParameters, AuditParameters.ParameterCount, pSockAddr );
    }

    AuditParameters.ParameterCount++;

    ( VOID ) LsapAdtWriteLog( &AuditParameters );

 Finish:
    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }

    if ( FreeWhenDone ) {
        LsapFreeLsaHeap( AuthenticationIdString.Buffer );
    }

    if ( pLogonSession != NULL )
    {
        LsapReleaseLogonSession( pLogonSession );
    }
}




VOID
LsapAuditLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId
    )
/*++

Routine Description/Arguments/Return value

    See header comment for LsapAuditLogonHelper

--*/
{
    LsapAuditLogonHelper(
        LogonStatus,
        LogonSubStatus,
        AccountName,
        AuthenticatingAuthority,
        WorkstationName,
        UserSid,
        LogonType,
        TokenSource,
        LogonId,
        NULL,                   // no logon guid
        NULL,                   // caller logon-id
        NULL,                   // caller process-id
        NULL                    // no transitted services
        );
}




VOID
LsapAuditLogonHelper(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId,
    IN LPGUID LogonGuid,                        OPTIONAL
    IN PLUID  CallerLogonId,                    OPTIONAL
    IN PHANDLE CallerProcessID,                 OPTIONAL
    IN PLSA_ADT_STRING_LIST TransittedServices  OPTIONAL
    )
/*++

Routine Description:

    Helper routine for security packages to generate a logon audit

Arguments:
    LogonStatus             - Status code for the logon.

    LogonSubStatus          - more detailed Status code for the logon.

    AccountName             - Name of principal attempting logon.

    AuthenticatingAuthority - Authority validating the logon.

    Workstation             - Machine from which the logon was attempted.
                              For a network logon, this is the client machine.

    UserSid                 - Sid for the logged on account.

    LogonType               - Type of logon, such as Network, Interactive, etc.

    TokenSource             - Source for the token.

    LogonId                 - If the logon was successful,
                              the logon ID for the logon session.

    LogonGuid               - globally unique ID for a logon.
                              This is supported only by the kerberos package.

    CallerLogonId           - Logon-ID of the caller.
                              For example, if foo calls LsaLogonUser to create
                              a logon session for bar. This will be the logon-ID
                              of foo.

    CallerProcessID         - Process ID of the calling process.

Return Value:

    None.

--*/
{
    ANSI_STRING AnsiSourceContext;
    CHAR AnsiBuffer[TOKEN_SOURCE_LENGTH + 2];
    UNICODE_STRING UnicodeSourceContext;
    WCHAR UnicodeBuffer[TOKEN_SOURCE_LENGTH + 2];
    NTSTATUS Status;
    USHORT EventType;
    USHORT EventCategory;
    ULONG  EventID;
    PLSAP_SECURITY_PACKAGE SecurityPackage;
    ULONG_PTR PackageId;
    PLSA_CALL_INFO  pCallInfo;
    SOCKADDR* pSockAddr = NULL;
    SOCKADDR  EmptySockAddr = {0};

    //
    // get the IP address/port of the caller
    //

    pCallInfo = LsapGetCurrentCall();

    if ( pCallInfo == NULL ) {

        //
        // If we cannot get the call info then use the 0.0.0.0:0 address.
        //
        pSockAddr = &EmptySockAddr;
        pSockAddr->sa_family = AF_INET;
    } else {
        pSockAddr = (SOCKADDR*) pCallInfo->IpAddress;
    }
    
    PackageId = GetCurrentPackageId();
    DsysAssertMsg( PackageId != SPMGR_ID, "LsapAuditLogon" );
    
    SecurityPackage = SpmpLocatePackage( PackageId );
    DsysAssertMsg( SecurityPackage != NULL, "LsapAuditLogon" );


    //
    // Audit the logon attempt.  The event type and logged information
    // will depend to some extent on the whether we failed and why.
    //

    //
    // Turn the SourceContext into something we can
    // work with.
    //

    AnsiSourceContext.Buffer = AnsiBuffer;
    AnsiSourceContext.Length = TOKEN_SOURCE_LENGTH * sizeof( CHAR );
    AnsiSourceContext.MaximumLength = (TOKEN_SOURCE_LENGTH + 2) * sizeof( CHAR );

    UnicodeSourceContext.Buffer = UnicodeBuffer;
    UnicodeSourceContext.MaximumLength = (TOKEN_SOURCE_LENGTH + 2) * sizeof( WCHAR );

    RtlCopyMemory(
        AnsiBuffer,
        TokenSource->SourceName,
        TOKEN_SOURCE_LENGTH * sizeof( CHAR )
        );

    Status = RtlAnsiStringToUnicodeString(
                 &UnicodeSourceContext,
                 &AnsiSourceContext,
                 FALSE
                 );

    if ( NT_SUCCESS( Status )) {
        
        UnicodeSourceContext.Length =
            (USHORT) LsapSafeWcslen( UnicodeSourceContext.Buffer,
                                     UnicodeSourceContext.MaximumLength );
        
    } else {

        UnicodeSourceContext.Buffer = NULL;

        //
        // we cannot fail the audit because of this but catch the
        // internal clients who supply bad source contexts
        //
        DsysAssertMsg( FALSE, "LsapAuditLogon: could not convert AnsiSourceContext to unicode" );
    }

    //
    // Assume the logon failed, reset if necessary.
    //

    EventCategory = SE_CATEGID_LOGON;
    EventType     = EVENTLOG_AUDIT_FAILURE;


    switch ( LogonStatus )
    {
        case STATUS_SUCCESS:
            {
                //
                // Use a separate event for network logons
                //

                if (( LogonType == Network ) ||
                    ( LogonType == NetworkCleartext ))
                {
                    EventID = SE_AUDITID_NETWORK_LOGON;
                }
                else
                {
                    EventID = SE_AUDITID_SUCCESSFUL_LOGON;
                }

                EventType = EVENTLOG_AUDIT_SUCCESS;
                break;
            }

        case STATUS_BAD_VALIDATION_CLASS:
            EventID = SE_AUDITID_UNSUCCESSFUL_LOGON;
            break;

        case STATUS_ACCOUNT_EXPIRED:
            EventID = SE_AUDITID_ACCOUNT_EXPIRED;
            break;

        case STATUS_NETLOGON_NOT_STARTED:
            EventID = SE_AUDITID_NETLOGON_NOT_STARTED;
            break;

        case STATUS_ACCOUNT_LOCKED_OUT:
            EventID = SE_AUDITID_ACCOUNT_LOCKED;
            break;

        case STATUS_LOGON_TYPE_NOT_GRANTED:
            EventID = SE_AUDITID_LOGON_TYPE_RESTR;
            break;

        case STATUS_PASSWORD_MUST_CHANGE:
            EventID = SE_AUDITID_PASSWORD_EXPIRED;
            break;


        case STATUS_ACCOUNT_RESTRICTION:
            {

                switch ( LogonSubStatus )
                {
                    case STATUS_PASSWORD_EXPIRED:
                        EventID = SE_AUDITID_PASSWORD_EXPIRED;
                        break;

                    case STATUS_ACCOUNT_DISABLED:
                        EventID = SE_AUDITID_ACCOUNT_DISABLED;
                        break;

                    case STATUS_INVALID_LOGON_HOURS:
                        EventID = SE_AUDITID_ACCOUNT_TIME_RESTR;
                        break;

                    case STATUS_INVALID_WORKSTATION:
                        EventID = SE_AUDITID_WORKSTATION_RESTR;
                        break;

                    default:
                        EventID = SE_AUDITID_UNKNOWN_USER_OR_PWD;
                        break;
                }
                break;
            }

        case STATUS_LOGON_FAILURE:
            {
                if ( ( LogonSubStatus == STATUS_WRONG_PASSWORD ) ||
                     ( LogonSubStatus == STATUS_NO_SUCH_USER   ) )
                {
                    EventID = SE_AUDITID_UNKNOWN_USER_OR_PWD;

                }
                else if ( LogonSubStatus == STATUS_DOMAIN_TRUST_INCONSISTENT )
                {
                    EventID = SE_AUDITID_DOMAIN_TRUST_INCONSISTENT;
                }
                else
                {
                    EventID = SE_AUDITID_UNSUCCESSFUL_LOGON;
                }
                break;
            }

        default:
            EventID = SE_AUDITID_UNSUCCESSFUL_LOGON;
            break;
    }

    LsapAdtAuditLogon( EventCategory,
                       EventID,
                       EventType,
                       AccountName,
                       AuthenticatingAuthority,
                       &UnicodeSourceContext,
                       &SecurityPackage->Name,
                       LogonType,
                       UserSid,
                       *LogonId,
                       WorkstationName,
                       LogonStatus,
                       LogonSubStatus,
                       LogonGuid,
                       CallerLogonId,
                       CallerProcessID,
                       TransittedServices,
                       pSockAddr
                       );

}


VOID
LsapAdtAuditLogoff(
    PLSAP_LOGON_SESSION Session
    )
/*++

Routine Description:

    Generates a logoff audit.  The caller is responsible for determining
    if logoff auditing is enabled.

Arguments:

    Session - Points to the logon session being removed.

Return Value:

    None.

--*/
{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    NTSTATUS Status;
    UNICODE_STRING usLogonId;
    BOOLEAN fFreeLogonId=FALSE;

    RtlZeroMemory ( &usLogonId, sizeof(UNICODE_STRING) );

    //
    // normally we would simply store the logon-id to be audited
    // as SeAdtParmTypeLogonId. But in this case, the logon session
    // will have gone away by the time we try to convert it
    // to a string representation in LsapAdtDemarshallAuditInfo.
    // using LsapGetLogonSessionAccountInfo.
    //
    // To avoid this, we pre-convert the logon-id here
    //

    Status = LsapAdtBuildLuidString( &Session->LogonId,
                                     &usLogonId, &fFreeLogonId );

    if ( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }

    Status =
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_LOGON,
        SE_AUDITID_LOGOFF,
        EVENTLOG_AUDIT_SUCCESS,
        6,                       // there are 6 params to init

        //
        //    User Sid
        //
        SeAdtParmTypeSid,        Session->UserSid,

        //
        //    Subsystem name (if available)
        //
        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    User
        //
        SeAdtParmTypeString,     &Session->AccountName,

        //
        //    Domain
        //
        SeAdtParmTypeString,     &Session->AuthorityName,

        //
        //    LogonId
        //
        SeAdtParmTypeString,     &usLogonId,

        //
        //    Logon Type
        //
        SeAdtParmTypeUlong,      Session->LogonType

        );


    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    ( VOID ) LsapAdtWriteLog( &AuditParameters );

Cleanup:
    if (fFreeLogonId)
    {
        LsapFreeLsaHeap(usLogonId.Buffer);
    }
}



VOID
LsapAdtAuditPerUserTableCreation(
    BOOLEAN bSuccess
    )

/*++

Routine Description:

    Generates an audit to report that the per user table was regenerated. The 
    table should be locked for read access during this call.  
    
    This routine will generate a single audit to indicate that the table
    has been created.  It will then generate individual audits for each 
    user that has an element in the per user audit table.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    NTSTATUS Status;
    BOOLEAN bAudit;
    ULONG i;
    ULONG j;
    PPER_USER_AUDITING_ELEMENT pElement = NULL;
    LUID TableId;
    ULONG AuditSettings[POLICY_AUDIT_EVENT_TYPE_COUNT];

    if (!AllocateLocallyUniqueId(&TableId))
    {
        Status = LsapWinerrorToNtStatus(GetLastError());
        goto Cleanup;
    }

    //
    // First log an audit to indicate that the table is being 
    // created.
    //

    Status = LsapAdtAuditingEnabledBySid(
                 AuditCategoryPolicyChange,
                 LsapLocalSystemSid,
                 EVENTLOG_AUDIT_SUCCESS,
                 &bAudit
                 );

    if (!NT_SUCCESS( Status )) 
    {
        goto Cleanup;
    }

    if (bAudit)
    {
        Status =
        LsapAdtInitParametersArray(
            &AuditParameters,
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_PER_USER_AUDIT_TABLE_CREATION,
            bSuccess ? EVENTLOG_AUDIT_SUCCESS : EVENTLOG_AUDIT_FAILURE,
            4,          

            //
            // User Sid
            //
            SeAdtParmTypeSid, LsapLocalSystemSid,

            //
            // Subsystem name (if available)
            //
            SeAdtParmTypeString, &LsapSubsystemName,

            //
            // Number of users in the per user table
            //
            SeAdtParmTypeUlong, bSuccess ? LsapAdtPerUserAuditUserCount : 0,

            //
            // Table ID
            //
            SeAdtParmTypeLuid, TableId
            );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        (VOID)LsapAdtWriteLog(&AuditParameters);

        //
        // If this is a failure audit, then exit now.
        //

        if (!bSuccess)
        {
            return;
        }
    }

    //
    // Now log audits for the individual records in the table.
    //

    for (i = 0; i < PER_USER_AUDITING_POLICY_TABLE_SIZE; i++)
    {
        pElement = LsapAdtPerUserAuditingTable[i];

        while (pElement)
        {
            RtlZeroMemory(
                AuditSettings,
                sizeof(AuditSettings)
                );

            for (j = 0; j < pElement->TokenAuditPolicy.PolicyCount; j++)
            {
                AuditSettings[pElement->TokenAuditPolicy.Policy[j].Category] = pElement->TokenAuditPolicy.Policy[j].PolicyMask;
            }

            Status =
            LsapAdtInitParametersArray(
                &AuditParameters,
                SE_CATEGID_POLICY_CHANGE,
                SE_AUDITID_PER_USER_AUDIT_TABLE_ELEMENT_CREATION,
                EVENTLOG_AUDIT_SUCCESS,
                13,

                //
                // User Sid
                //
                SeAdtParmTypeSid, LsapLocalSystemSid,

                //
                // Subsystem name (if available)
                //
                SeAdtParmTypeString, &LsapSubsystemName,

                //
                // User Sid
                //
                SeAdtParmTypeSid, pElement->pSid,

                //
                // Table Id
                //
                SeAdtParmTypeLuid, TableId,

                //
                // System
                //
                SeAdtParmTypeHexUlong, AuditSettings[AuditCategorySystem],

                //
                // Logon
                //
                SeAdtParmTypeHexUlong, AuditSettings[AuditCategoryLogon],

                //
                // Object Access
                //
                SeAdtParmTypeHexUlong, AuditSettings[AuditCategoryObjectAccess],

                //
                // Privilege Use
                //
                SeAdtParmTypeHexUlong, AuditSettings[AuditCategoryPrivilegeUse],

                //
                // Detailed Tracking
                //
                SeAdtParmTypeHexUlong, AuditSettings[AuditCategoryDetailedTracking],

                //
                // Policy Change
                //
                SeAdtParmTypeHexUlong, AuditSettings[AuditCategoryPolicyChange],

                //
                // Account Management
                //
                SeAdtParmTypeHexUlong, AuditSettings[AuditCategoryAccountManagement],

                //
                // DS Access
                //
                SeAdtParmTypeHexUlong, AuditSettings[AuditCategoryDirectoryServiceAccess],

                //
                // Account Logon
                //
                SeAdtParmTypeHexUlong, AuditSettings[AuditCategoryAccountLogon]
                );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            (VOID)LsapAdtWriteLog(&AuditParameters);
            pElement = pElement->Next;
        }
    }

Cleanup:

    if (!NT_SUCCESS( Status ))
    {
        LsapAuditFailed( Status );
    }
}


VOID
LsapAdtLogAuditFailureEvent(
    NTSTATUS AuditStatus
    )
/*++

Routine Description:

    Generates SE_AUDITID_UNABLE_TO_LOG_EVENTS event

Arguments:

    AuditStatus : failure code

Return Value:

    None.

--*/
{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CrashOnAuditFailState;

    //
    // determine the CrashOnAuditFailState value
    //

    if ( LsapCrashOnAuditFail )
    {
        CrashOnAuditFailState = 1;
    }
    else if ( LsapAllowAdminLogonsOnly )
    {
        CrashOnAuditFailState = 2;
    }
    else
    {
        CrashOnAuditFailState = 0;
    }

    Status =
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_SYSTEM,
        SE_AUDITID_UNABLE_TO_LOG_EVENTS,
        EVENTLOG_AUDIT_SUCCESS,
        4,                       // there are 4 params to init

        //
        //    User Sid
        //
        SeAdtParmTypeSid,        LsapLocalSystemSid,

        //
        //    Subsystem name (if available)
        //
        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    Audit failure code
        //
        SeAdtParmTypeHexUlong,   AuditStatus,

        //
        //    value of CrashOnAuditFail
        //
        SeAdtParmTypeUlong,      CrashOnAuditFailState
        );

    AdtAssert(NT_SUCCESS(Status), ("LsapAdtLogAuditFailureEvent: LsapAdtInitParametersArray failed: %x", Status));

    //
    // note: we do not call LsapAuditFailed here because this function
    //       itself gets called by LsapAuditFailed. We just hope
    //       for the best.
    //

    //
    // call LsapAdtDemarshallAuditInfo directly so that the audit event
    // will bypass the queue and go directly to the eventlog.
    //

    Status = LsapAdtDemarshallAuditInfo( &AuditParameters );

    AdtAssert(NT_SUCCESS(Status), ("LsapAdtLogAuditFailureEvent: LsapAdtDemarshallAuditInfo failed: %x", Status));
    

    //
    // now flush the eventlog
    //

    Status = LsapFlushSecurityLog();

    AdtAssert(NT_SUCCESS(Status), ("LsapAdtLogAuditFailureEvent: ElfFlushEventLog failed: %x", Status));
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtlq.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T L Q . C
//
// Contents:    definitions of types/functions required for 
//              managing audit queue
//
//
// History:     
//   23-May-2000  kumarp        created
//
//------------------------------------------------------------------------



#ifndef _ADTLQ_H_
#define _ADTLQ_H_

#define MAX_AUDIT_QUEUE_LENGTH  800
#define AUDIT_QUEUE_LOW_WATER_MARK (((MAX_AUDIT_QUEUE_LENGTH) * 3) / 4)

EXTERN_C ULONG LsapAdtQueueLength;
EXTERN_C HANDLE LsapAdtQueueRemoveEvent;
EXTERN_C HANDLE LsapAdtLogHandle;

NTSTATUS
LsapAdtAcquireLogQueueLock();

VOID
LsapAdtReleaseLogQueueLock();

NTSTATUS
LsapAdtInitializeLogQueue(
    );

NTSTATUS 
LsapAdtAddToQueue(
    IN PLSAP_ADT_QUEUED_RECORD pAuditRecord
    );

NTSTATUS 
LsapAdtGetQueueHead(
    OUT PLSAP_ADT_QUEUED_RECORD *ppRecord
    );

ULONG
WINAPI
LsapAdtDequeueThreadWorker(
    LPVOID pParameter
    );

NTSTATUS
LsapAdtFlushQueue( );

#endif // _ADTLQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtobjs.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtobjs.c

Abstract:

    Local Security Authority - Auditing object parameter file services.

Author:

    Jim Kelly   (JimK)      20-Oct-1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include <msaudite.h>
#include <msobjs.h>
#include "adtp.h"



//
// This is the maximum length of standard access type names.
// This is used to build an array.
//

#define ADTP_MAX_ACC_NAME_LENGTH        (12)


//
//
// This module builds a list of event source module descriptors.
// The source modules are identified by name (kept in the descriptor).
//
//
// For each source module a list of objects exported by that module is
// linked to the source module's descriptor.  Each entry in this list
// is an object descriptor containing a name and a base event offset
// for specific access types.
//
//
// The chicken-wire data structure for source module and object descriptors
// looks like:
//
// LsapAdtSourceModules --+
//                        |
//     +------------------+
//     |
//     |
//     |    +-----------+                             +-----------+
//     +--->|  Next ----|---------------------------->|  Next ----|--->...
//          |           |                             |           |
//          |-----------|                             |-----------|
//          |  Name     |                             |  Name     |
//          |           |                             |           |
//          |-----------|                             |-----------|
//          |  Objects  |                             |  Objects  |
//          |    o      |                             |    o      |
//          +-----o-----+                             +-----o-----+
//                 o     +-------+  +-------+                o
//                  o    | Next--|->| Next--|->...            o
//                   ooo>|-------|  |-------|                  oooooo> ...
//                       | Name  |  | Name  |
//                       |-------|  |-------|
//                       | Base  |  | Base  |
//                       | Offset|  | Offset|
//                       +-------+  +-------+
//
// The specific access type names are expected to have contiguous message IDs
// starting at the base offset value.  For example, the access type name for
// specific access bit 0 for the framitz object might have message ID 2132
// (and bit 0 serves as the base offset).  So, specific access bit 4 would be
// message ID (2132+4).
//
// The valid mask defines the set of specific accesses defined by each object
// type.  If there are gaps in the valid mask, the arithmetic above must still
// be ensured.  That is, the message ID of the specific access related to
// bit n is message ID (BaseOffset + bit position).  So, for example, if
// bits 0, 1, 4 and 5 are valid (and 2 & 3 are not), be sure to leave unused
// message IDs where bits 2 and 3 would normally be.
//



////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Data types used within this module                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////


#define LSAP_ADT_ACCESS_NAME_FORMATTING L"\r\n\t\t\t"
#define LSAP_ADT_ACCESS_NAME_FORMATTING_TAB L"\t"
#define LSAP_ADT_ACCESS_NAME_FORMATTING_NL L"\r\n"


#define LsapAdtSourceModuleLock()    (RtlEnterCriticalSection(&LsapAdtSourceModuleLock))
#define LsapAdtSourceModuleUnlock()  (RtlLeaveCriticalSection(&LsapAdtSourceModuleLock))



//
// Each event source is represented by a source module descriptor.
// These are kept on a linked list (LsapAdtSourceModules).
//

typedef struct _LSAP_ADT_OBJECT {

    //
    // Pointer to next source module descriptor
    // This is assumed to be the first field in the structure.
    //

    struct _LSAP_ADT_OBJECT *Next;

    //
    // Name of object
    //

    UNICODE_STRING Name;

    //
    // Base offset of specific access types
    //

    ULONG BaseOffset;

} LSAP_ADT_OBJECT, *PLSAP_ADT_OBJECT;




//
// Each event source is represented by a source module descriptor.
// These are kept on a linked list (LsapAdtSourceModules).
//

typedef struct _LSAP_ADT_SOURCE {

    //
    // Pointer to next source module descriptor
    // This is assumed to be the first field in the structure.
    //

    struct _LSAP_ADT_SOURCE *Next;

    //
    // Name of source module
    //

    UNICODE_STRING Name;

    //
    // list of objects
    //

    PLSAP_ADT_OBJECT Objects;

} LSAP_ADT_SOURCE, *PLSAP_ADT_SOURCE;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Variables global within this module                               //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// List head for source modules, and lock protecting references
// or modifications of the links in that list.
//
// Once a module's or object's name and value are established, they
// are never changed.  So, this lock only needs to be held while
// links are being referenced or changed.  You don't need to retain
// it just so you can reference, for example, the name or BaseOffset
// of an object.
//

PLSAP_ADT_SOURCE LsapAdtSourceModules;
RTL_CRITICAL_SECTION LsapAdtSourceModuleLock;




//
// This is used to house well-known access ID strings.
// Each string name may be up to ADTP_MAX_ACC_NAME_LENGTH WCHARs long.
// There are 16 specific names, and 7 well known event ID strings.
//

WCHAR LsapAdtAccessIdsStringBuffer[ADTP_MAX_ACC_NAME_LENGTH * 23];   // max wchars in each of 23 strings




UNICODE_STRING          LsapAdtEventIdStringDelete,
                        LsapAdtEventIdStringReadControl,
                        LsapAdtEventIdStringWriteDac,
                        LsapAdtEventIdStringWriteOwner,
                        LsapAdtEventIdStringSynchronize,
                        LsapAdtEventIdStringAccessSysSec,
                        LsapAdtEventIdStringMaxAllowed,
                        LsapAdtEventIdStringSpecific[16];




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Services exported by this module.                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
LsapAdtObjsInitialize(
    )

/*++

Routine Description:

    This function reads the object parameter file information from the
    registry.

    This service should be called in pass 1.


Arguments:

    None.

Return Value:


    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                        Status,
                                    IgnoreStatus;

    OBJECT_ATTRIBUTES               ObjectAttributes;

    HANDLE                          AuditKey,
                                    ModuleKey,
                                    ObjectNamesKey = NULL ;

    ULONG                           i,
                                    ModuleIndex,
                                    ObjectIndex,
                                    RequiredLength;

    UNICODE_STRING                  AuditKeyName,
                                    TmpString;

    PLSAP_ADT_SOURCE                NextModule = NULL;

    PKEY_BASIC_INFORMATION          KeyInformation;



    PLSAP_ADT_OBJECT                NextObject;

    PKEY_VALUE_FULL_INFORMATION     KeyValueInformation;

    PULONG                          ObjectData;

    BOOLEAN                         ModuleHasObjects = TRUE;





    //
    // Initialize module-global variables, including strings we will need
    //



    //
    // List of source modules and objects.  These lists are constantly
    // being adjusted to try to improve performance.  Access to these
    // lists is protected by a critical section.
    //

    LsapAdtSourceModules = NULL;

    Status = RtlInitializeCriticalSection(&LsapAdtSourceModuleLock);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }


    //
    // we need a number of strings.
    //

    i = 0;
    LsapAdtEventIdStringDelete.Length = 0;
    LsapAdtEventIdStringDelete.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringDelete.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_DELETE,
                                         10,        //Base
                                         &LsapAdtEventIdStringDelete
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    i += ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringReadControl.Length = 0;
    LsapAdtEventIdStringReadControl.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringReadControl.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_READ_CONTROL,
                                         10,        //Base
                                         &LsapAdtEventIdStringReadControl
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    i += ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringWriteDac.Length = 0;
    LsapAdtEventIdStringWriteDac.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringWriteDac.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_WRITE_DAC,
                                         10,        //Base
                                         &LsapAdtEventIdStringWriteDac
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    i += ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringWriteOwner.Length = 0;
    LsapAdtEventIdStringWriteOwner.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringWriteOwner.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_WRITE_OWNER,
                                         10,        //Base
                                         &LsapAdtEventIdStringWriteOwner
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    i += ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSynchronize.Length = 0;
    LsapAdtEventIdStringSynchronize.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSynchronize.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SYNCHRONIZE,
                                         10,        //Base
                                         &LsapAdtEventIdStringSynchronize
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i += ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringAccessSysSec.Length = 0;
    LsapAdtEventIdStringAccessSysSec.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringAccessSysSec.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_ACCESS_SYS_SEC,
                                         10,        //Base
                                         &LsapAdtEventIdStringAccessSysSec
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringMaxAllowed.Length = 0;
    LsapAdtEventIdStringMaxAllowed.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringMaxAllowed.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_MAXIMUM_ALLOWED,
                                         10,        //Base
                                         &LsapAdtEventIdStringMaxAllowed
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }




    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[0].Length = 0;
    LsapAdtEventIdStringSpecific[0].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[0].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_0,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[0]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[1].Length = 0;
    LsapAdtEventIdStringSpecific[1].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[1].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_1,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[1]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[2].Length = 0;
    LsapAdtEventIdStringSpecific[2].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[2].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_2,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[2]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[3].Length = 0;
    LsapAdtEventIdStringSpecific[3].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[3].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_3,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[3]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[4].Length = 0;
    LsapAdtEventIdStringSpecific[4].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[4].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_4,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[4]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[5].Length = 0;
    LsapAdtEventIdStringSpecific[5].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[5].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_5,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[5]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[6].Length = 0;
    LsapAdtEventIdStringSpecific[6].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[6].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_6,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[6]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[7].Length = 0;
    LsapAdtEventIdStringSpecific[7].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[7].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_7,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[7]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[8].Length = 0;
    LsapAdtEventIdStringSpecific[8].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[8].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_8,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[8]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[9].Length = 0;
    LsapAdtEventIdStringSpecific[9].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[9].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_9,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[9]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[10].Length = 0;
    LsapAdtEventIdStringSpecific[10].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[10].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_10,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[10]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[11].Length = 0;
    LsapAdtEventIdStringSpecific[11].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[11].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_11,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[11]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[12].Length = 0;
    LsapAdtEventIdStringSpecific[12].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[12].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_12,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[12]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[13].Length = 0;
    LsapAdtEventIdStringSpecific[13].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[13].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_13,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[13]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[14].Length = 0;
    LsapAdtEventIdStringSpecific[14].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[14].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_14,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[14]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[15].Length = 0;
    LsapAdtEventIdStringSpecific[15].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[15].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_15,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[15]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    //
    // The modules and their objects are listed in the registry
    // under the key called LSAP_ADT_AUDIT_MODULES_KEY_NAME.
    // Open that key.
    //

    RtlInitUnicodeString( &AuditKeyName, LSAP_ADT_AUDIT_MODULES_KEY_NAME );
    InitializeObjectAttributes( &ObjectAttributes, &AuditKeyName, OBJ_CASE_INSENSITIVE, 0, NULL );

    Status = NtOpenKey( &AuditKey, KEY_READ, &ObjectAttributes ); // AuditKey is open handle to top of security modules registry

    for (ModuleIndex = 0; NT_SUCCESS(Status); ModuleIndex ++)
    {
        //
        // Enumerate the subkeys under AuditKey, storing their names in KeyInformation.  First calculate the buffer size needed to
        // store the key name.
        //

        KeyInformation = NULL;
        Status = NtEnumerateKey( AuditKey, ModuleIndex, KeyBasicInformation, (PVOID)KeyInformation, 0, &RequiredLength );
        if (Status == STATUS_BUFFER_TOO_SMALL) // must test this, in case the NtEnumerateKey fails for some other reason
        {
            KeyInformation = RtlAllocateHeap( RtlProcessHeap(), 0, RequiredLength );

            if (KeyInformation == NULL)
            {
               return(STATUS_NO_MEMORY);
            }

            Status = NtEnumerateKey( AuditKey, ModuleIndex, KeyBasicInformation, (PVOID) KeyInformation, RequiredLength, &RequiredLength );

            if (NT_SUCCESS(Status))
            {

                //
                // Build a source module descriptor (LSAP_ADT_SOURCE) for the subkey of AuditKey (aka KeyInformation)
                //

                NextModule = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(LSAP_ADT_SOURCE) );
                if (NextModule == NULL) {
                    return(STATUS_NO_MEMORY);
                }

                NextModule->Next = LsapAdtSourceModules;
                LsapAdtSourceModules = NextModule;
                NextModule->Objects = NULL;
                NextModule->Name.Length = (USHORT)KeyInformation->NameLength;
                NextModule->Name.MaximumLength = NextModule->Name.Length + 2;
                NextModule->Name.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, NextModule->Name.MaximumLength );
                if (NextModule->Name.Buffer == NULL)
                {
                    return(STATUS_NO_MEMORY);
                }

                TmpString.Length = (USHORT)KeyInformation->NameLength;
                TmpString.MaximumLength = TmpString.Length;
                TmpString.Buffer = &KeyInformation->Name[0];
                RtlCopyUnicodeString( &NextModule->Name, &TmpString );
                RtlFreeHeap( RtlProcessHeap(), 0, KeyInformation );

                //
                // open the module subkey to which KeyInformation refers.  call it "ModuleKey".
                //

                InitializeObjectAttributes( &ObjectAttributes, &NextModule->Name, OBJ_CASE_INSENSITIVE, AuditKey, NULL );

                Status = NtOpenKey( &ModuleKey, KEY_READ, &ObjectAttributes );

                DebugLog((DEB_TRACE_AUDIT, "LsapAdtObjsInitialize() :: opening ModuleKey %S returned 0x%x\n", 
                          NextModule->Name.Buffer, Status));

                if (!NT_SUCCESS(Status))
                {
                    return(Status);
                }

                //
                // Open the source module's "\ObjectNames" subkey as the handle "ObjectNamesKey";
                //

                RtlInitUnicodeString( &TmpString, LSAP_ADT_OBJECT_NAMES_KEY_NAME );
                InitializeObjectAttributes( &ObjectAttributes, &TmpString, OBJ_CASE_INSENSITIVE, ModuleKey, NULL );

                Status = NtOpenKey( &ObjectNamesKey, KEY_READ, &ObjectAttributes );

                IgnoreStatus = NtClose( ModuleKey );
                ASSERT(NT_SUCCESS(IgnoreStatus));

                // DbgPrint("LsapAdtObjsInitialize() :: opening ObjectNamesKey returned 0x%x\n", Status);

                ModuleHasObjects = TRUE;
                if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
                {
                    ModuleHasObjects = FALSE;
                    Status = STATUS_SUCCESS;
                }

            }
        }

        //
        // At this point we have either:
        //
        //      1) Found a source module with objects under it
        //         that need to be retrieved.
        //         This is indicated by successful status value and
        //         (ModuleHasObjects == TRUE).
        //
        //      2) found a source module with no objects under it,
        //         This is indicated by (ModuleHasObjects == FALSE)
        //
        //      3) exhausted our source modules enumeration,
        //
        //      4) hit another type of error, or
        //
        // (3) and (4) are indicatd by non-successful status values.
        //
        // In the case of (1) or (2) , NextModule points to the module we
        // are working on.  For case (1), ObjectNamesKey is the handle to
        // the \ObjectNames registry key for the source module.
        //


        for (ObjectIndex = 0; (NT_SUCCESS(Status)) && (ModuleHasObjects == TRUE); ObjectIndex ++)
        {

            //
            // Now enumerate the objects (i.e. values under \...\ObjectNames\ ) of this
            // source module.
            //

            // first calculate size of the ObjectIndex'th key.  Store in KeyValueInformation.

            KeyValueInformation = NULL;
            Status = NtEnumerateValueKey( ObjectNamesKey, ObjectIndex, KeyValueFullInformation, KeyValueInformation, 0, &RequiredLength );

            if (Status == STATUS_BUFFER_TOO_SMALL)
            {

                KeyValueInformation = RtlAllocateHeap( RtlProcessHeap(), 0, RequiredLength );
                if (KeyValueInformation == NULL)
                {
                  return(STATUS_NO_MEMORY);
                }

                Status = NtEnumerateValueKey( ObjectNamesKey, ObjectIndex, KeyValueFullInformation, KeyValueInformation, RequiredLength, &RequiredLength );


                if (NT_SUCCESS(Status))
                {

                    //
                    // Build an object descriptor for the object represented
                    // by this object.
                    //

                    NextObject = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(LSAP_ADT_OBJECT) );
                    if (NextObject == NULL)
                    {
                        return(STATUS_NO_MEMORY);
                    }

                    NextObject->Next = NextModule->Objects;
                    NextModule->Objects = NextObject;
                    NextObject->Name.Length = (USHORT)KeyValueInformation->NameLength;
                    NextObject->Name.MaximumLength = NextObject->Name.Length + 2;
                    NextObject->Name.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, NextObject->Name.MaximumLength );
                    if (NextObject->Name.Buffer == NULL)
                    {
                        return(STATUS_NO_MEMORY);
                    }

                    TmpString.Length = (USHORT)KeyValueInformation->NameLength;
                    TmpString.MaximumLength = TmpString.Length;
                    TmpString.Buffer = &KeyValueInformation->Name[0];
                    RtlCopyUnicodeString( &NextObject->Name, &TmpString );

                    if (KeyValueInformation->DataLength < sizeof(ULONG))
                    {
                        NextObject->BaseOffset = SE_ACCESS_NAME_SPECIFIC_0;
                    }
                    else
                    {

                        ObjectData = (PVOID)(((PUCHAR)KeyValueInformation) + KeyValueInformation->DataOffset);
                        NextObject->BaseOffset = (*ObjectData);
                    }
                    // DbgPrint("LsapAdtObjsInitialize() :: opening key %S with BaseOffset %d\n", NextObject->Name.Buffer, NextObject->BaseOffset);

                } //end_if (NT_SUCCESS on enumeration)

                RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInformation );
            } // end if buffer_too_small

            //
            // if we run out of values in the enumeration of this module, then we want to break
            // into the enumeration of the next
            //

            if (Status == STATUS_NO_MORE_ENTRIES)
            {
                Status = STATUS_SUCCESS;
                ModuleHasObjects = FALSE;
            }

        } // end for (ObjectIndex ... ) {} (enumerating values)


        if ( (Status == STATUS_SUCCESS) && (ModuleHasObjects == FALSE) )
        {
            IgnoreStatus = NtClose( ObjectNamesKey );
        }


    } // end for (Module... ){} (enumerating modules)

    IgnoreStatus = NtClose( AuditKey );
    ASSERT(NT_SUCCESS(IgnoreStatus));


    //
    // If we were successful, then we will probably have a
    // current completion status of STATUS_NO_MORE_ENTRIES
    // (indicating our enumerations above were run).  Change
    // this to success.
    //

    if (Status == STATUS_NO_MORE_ENTRIES)
    {
        Status = STATUS_SUCCESS;
    }

    return(Status);

}


NTSTATUS
LsapGuidToString(
    IN GUID *ObjectType,
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine converts a GUID to its text form.

Arguments:

    ObjectType - Specifies the GUID to translate.

    UnicodeString - Returns the text string.

Return Values:

    STATUS_SUCCESS - Operation was successful.
    STATUS_NO_MEMORY - Not enough memory to allocate string.

--*/

{
    NTSTATUS Status;
    RPC_STATUS RpcStatus;
    LPWSTR GuidString = NULL;
    ULONG GuidStringSize;
    LPWSTR LocalGuidString;

    //
    // Convert the GUID to text
    //

    RpcStatus = UuidToStringW( ObjectType,
                               &GuidString );

    if ( RpcStatus != RPC_S_OK ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    GuidStringSize = (ULONG) ((wcslen( GuidString ) + 1) * sizeof(WCHAR));

    LocalGuidString = LsapAllocateLsaHeap( GuidStringSize );

    if ( LocalGuidString == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( LocalGuidString, GuidString, GuidStringSize );
    RtlInitUnicodeString( UnicodeString, LocalGuidString );

    Status = STATUS_SUCCESS;

Cleanup:
    if ( GuidString != NULL ) {
        RpcStringFreeW( &GuidString );
    }
    return Status;
}


NTSTATUS
LsapDsGuidToString(
    IN GUID *ObjectType,
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine converts a GUID to a string.  The GUID is one of the following:

        Class Guid indicating the class of an object.
        Property Set Guid identifying a property set.
        Property Guid identifying a property.

    In each case, the routine returns a text string naming the object/property
    set or property.

    If the passed in GUID is cannot be found in the schema,
    the GUID will simply be converted to a text string.


Arguments:

    ObjectType - Specifies the GUID to translate.

    UnicodeString - Returns the text string.

Return Values:

    STATUS_NO_MEMORY - Not enough memory to allocate string.


--*/

{
    NTSTATUS Status;
    RPC_STATUS RpcStatus;
    LPWSTR GuidString = NULL;
    ULONG GuidStringSize;
    ULONG GuidStringLen;
    LPWSTR LocalGuidString;

    //
    // Convert the GUID to text
    //

    RpcStatus = UuidToStringW( ObjectType,
                               &GuidString );

    if ( RpcStatus != RPC_S_OK ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    GuidStringLen = (ULONG) wcslen( GuidString );
    GuidStringSize = (GuidStringLen + 4) * sizeof(WCHAR);

    LocalGuidString = LsapAllocateLsaHeap( GuidStringSize );

    if ( LocalGuidString == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    LocalGuidString[0] = L'%';
    LocalGuidString[1] = L'{';
    RtlCopyMemory( &LocalGuidString[2], GuidString, GuidStringLen*sizeof(WCHAR) );
    LocalGuidString[GuidStringLen+2] = L'}';
    LocalGuidString[GuidStringLen+3] = L'\0';
    RtlInitUnicodeString( UnicodeString, LocalGuidString );

    Status = STATUS_SUCCESS;

Cleanup:
    if ( GuidString != NULL ) {
        RpcStringFreeW( &GuidString );
    }
    return Status;
}


NTSTATUS
LsapAdtAppendString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    IN PUNICODE_STRING StringToAppend,
    IN PULONG StringIndex
    )

/*++

Routine Description:

    This function appends a string to the next available of the LSAP_ADT_OBJECT_TYPE_STRINGS unicode
    output strings.


Arguments:

    ResultantString - Points to an array of LSAP_ADT_OBJECT_TYPE_STRINGS unicode string headers.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.

    StringToAppend - String to be appended to ResultantString.

    StringIndex - Index to the current ResultantString to be used.
        Passes in an index to the resultant string to use.
        Passes out the index to the resultant string being used.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING SourceString;
    ULONG Index;
// Must be multiple of sizeof(WCHAR)
#define ADT_MAX_STRING 0xFFFE

    //
    // Initialization.
    //

    SourceString = *StringToAppend;
    Index = *StringIndex;

    //
    // If all of the strings are already full,
    //  early out.
    //

    if ( Index >= LSAP_ADT_OBJECT_TYPE_STRINGS ) {
        return STATUS_SUCCESS;
    }

    //
    // Loop until the source string is completely appended.
    //

    while ( SourceString.Length ) {

        //
        // If the destination string has room,
        //  append to it.
        //

        if ( FreeWhenDone[Index] && ResultantString[Index].Length != ADT_MAX_STRING ){
            UNICODE_STRING SubString;
            USHORT RoomLeft;

            //
            // If the Source String is a replacement string,
            //  make sure we don't split it across a ResultantString boundary
            //

            RoomLeft = ResultantString[Index].MaximumLength -
                       ResultantString[Index].Length;

            if ( SourceString.Buffer[0] != L'%' ||
                 RoomLeft >= SourceString.Length ) {

                //
                // Compute the substring that fits.
                //

                SubString.Length = min( RoomLeft, SourceString.Length );
                SubString.Buffer = SourceString.Buffer;

                SourceString.Length = SourceString.Length - SubString.Length;
                SourceString.Buffer = (LPWSTR)(((LPBYTE)SourceString.Buffer) + SubString.Length);


                //
                // Append the substring onto the destination.
                //

                Status = RtlAppendUnicodeStringToString(
                                    &ResultantString[Index],
                                    &SubString );

                ASSERT(NT_SUCCESS(Status));

            }



        }

        //
        // If there's more to copy,
        //  grow the buffer.
        //

        if ( SourceString.Length ) {
            ULONG NewSize;
            LPWSTR NewBuffer;

            //
            // If the current buffer is full,
            //  move to the next buffer.
            //

            if ( ResultantString[Index].Length >= ADT_MAX_STRING ) {

                //
                // If the buffer is full,
                // silently return to the caller.
                //
                
                *StringIndex = Index;
                return STATUS_SUCCESS;
            }

            //
            // Allocate a buffer suitable for both the old string and the new one.
            //
            // Allocate the buffer at least large enough for the new string.
            // Always grow the buffer in 1Kb chunks.
            // Don't allocate larger than the maximum allowed size.
            //

            NewSize = max( ResultantString[Index].MaximumLength + 1024,
                           SourceString.Length );
            NewSize = min( NewSize, ADT_MAX_STRING );

            NewBuffer = LsapAllocateLsaHeap( NewSize );

            if ( NewBuffer == NULL ) {
                *StringIndex = Index;
                return STATUS_NO_MEMORY;
            }

            //
            // Copy the old buffer into the new buffer.
            //

            if ( ResultantString[Index].Buffer != NULL ) {
                RtlCopyMemory( NewBuffer,
                               ResultantString[Index].Buffer,
                               ResultantString[Index].Length );

                if ( FreeWhenDone[Index] ) {
                    LsapFreeLsaHeap( ResultantString[Index].Buffer );
                }
            }

            ResultantString[Index].Buffer = NewBuffer;
            ResultantString[Index].MaximumLength = (USHORT) NewSize;
            FreeWhenDone[Index] = TRUE;

        }
    }

    *StringIndex = Index;
    return STATUS_SUCCESS;

}


NTSTATUS
LsapAdtAppendZString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    IN LPWSTR StringToAppend,
    IN PULONG StringIndex
    )

/*++

Routine Description:

    Same as LsapAdpAppendString but takes a zero terminated string.

Arguments:

    Same as LsapAdpAppendString but takes a zero terminated string.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, StringToAppend );

    return LsapAdtAppendString( ResultantString,
                                FreeWhenDone,
                                &UnicodeString,
                                StringIndex );
}


int
__cdecl
CompareObjectTypes(
    const void * Param1,
    const void * Param2
    )

/*++

Routine Description:

    Qsort comparison routine for sorting an object type array by access mask.

--*/
{
    const SE_ADT_OBJECT_TYPE *ObjectType1 = Param1;
    const SE_ADT_OBJECT_TYPE *ObjectType2 = Param2;

    return ObjectType1->AccessMask - ObjectType2->AccessMask;
}


NTSTATUS
LsapAdtBuildObjectTypeStrings(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN PSE_ADT_OBJECT_TYPE ObjectTypeList,
    IN ULONG ObjectTypeCount,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    OUT PUNICODE_STRING NewObjectTypeName
    )

/*++

Routine Description:

    This function builds a LSAP_ADT_OBJECT_TYPE_STRINGS unicode strings containing parameter
    file replacement parameters (e.g. %%1043) and Object GUIDs separated by carriage
    return and tab characters suitable for display via the event viewer.


    The buffers returned by this routine must be deallocated when no
    longer needed if FreeWhenDone is true.


Arguments:

    SourceModule - The module (ala event viewer modules) defining the
        object type.

    ObjectTypeName - The type of object to which the access mask applies.

    ObjectTypeList - List of objects being granted access.

    ObjectTypeCount - Number of objects in ObjectTypeList.

    ResultantString - Points to an array of LSAP_ADT_OBJECT_TYPE_STRINGS unicode string headers.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.


    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.

    NewObjectTypeName - Returns a new name for the object type if one is
        available.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING LocalString;
    BOOLEAN LocalFreeWhenDone;
    ULONG ResultantStringIndex = 0;
    ULONG i;
    ACCESS_MASK PreviousAccessMask;
    ULONG Index;
    USHORT IndentLevel;

    static LPWSTR Tabs[] =
    {
        L"\t",
        L"\t\t",
        L"\t\t\t",
        L"\t\t\t\t"
    };
    USHORT cTabs = sizeof(Tabs) / sizeof(LPWSTR);

    //
    // Initialize all LSAP_ADT_OBJECT_TYPE_STRINGS buffers to empty strings
    //

    for ( i=0; i<LSAP_ADT_OBJECT_TYPE_STRINGS; i++ ) {
        RtlInitUnicodeString( &ResultantString[i], L"" );
        FreeWhenDone[i] = FALSE;
    }

    //
    // If there are no objects,
    //  we're done.
    //

    if ( ObjectTypeCount == 0 ) {
        return STATUS_SUCCESS;
    }

    //
    // Group the objects with like access masks together.
    //  (Simply sort them).
    //

    qsort( ObjectTypeList,
           ObjectTypeCount,
           sizeof(SE_ADT_OBJECT_TYPE),
           CompareObjectTypes );

    //
    // Loop through the objects outputting a line for each one.
    //

    PreviousAccessMask = ObjectTypeList[0].AccessMask -1;
    for ( Index=0; Index<ObjectTypeCount; Index++ ) {

        //
        // If this access mask is different than the one for the previous
        //  object,
        //  output a new copy of the access mask.
        //

        if ( ObjectTypeList[Index].AccessMask != PreviousAccessMask ) {

            PreviousAccessMask = ObjectTypeList[Index].AccessMask;

            if ( ObjectTypeList[Index].AccessMask == 0 ) {
                RtlInitUnicodeString( &LocalString,
                                      L"---" LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
                LocalFreeWhenDone = FALSE;
            } else {

                //
                // Build a string with the access mask in it.
                //

                Status = LsapAdtBuildAccessesString(
                                  SourceModule,
                                  ObjectTypeName,
                                  ObjectTypeList[Index].AccessMask,
                                  FALSE,
                                  &LocalString,
                                  &LocalFreeWhenDone );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }
            }

            //
            // Append it to the output string.
            //

            Status = LsapAdtAppendString(
                        ResultantString,
                        FreeWhenDone,
                        &LocalString,
                        &ResultantStringIndex );

            if ( LocalFreeWhenDone ) {
                LsapFreeLsaHeap( LocalString.Buffer );
            }

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }
        }

        IndentLevel = ObjectTypeList[Index].Level;

        if (IndentLevel >= cTabs) {
            IndentLevel = cTabs-1;
        }

        //
        // Indent the GUID.
        //

        Status = LsapAdtAppendZString(
            ResultantString,
            FreeWhenDone,
            Tabs[IndentLevel],
            &ResultantStringIndex );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // If this is the DS,
        //  convert the GUID to a name from the schema.
        //

        Status = LsapDsGuidToString( &ObjectTypeList[Index].ObjectType,
                                     &LocalString );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Append the GUID string to the output strings.
        //

        Status = LsapAdtAppendString(
                    ResultantString,
                    FreeWhenDone,
                    &LocalString,
                    &ResultantStringIndex );

        LsapFreeLsaHeap( LocalString.Buffer );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Put the GUID on a line by itself.
        //

        Status = LsapAdtAppendZString(
                    ResultantString,
                    FreeWhenDone,
                    LSAP_ADT_ACCESS_NAME_FORMATTING_NL,
                    &ResultantStringIndex );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

    }

    Status = STATUS_SUCCESS;
Cleanup:
    return Status;
}


#define LSAP_ADT_OBJECT_TYPE_NAME_LENGTH  (39*sizeof(WCHAR))


NTSTATUS
LsapAdtBuildAccessesString(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN ACCESS_MASK Accesses,
    IN BOOLEAN Indent,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string containing parameter
    file replacement parameters (e.g. %%1043) separated by carriage
    return and tab characters suitable for display via the event viewer.


    The buffer returned by this routine must be deallocated when no
    longer needed if FreeWhenDone is true.


    NOTE: To enhance performance, each time a target source module
          descriptor is found, it is moved to the beginning of the
          source module list.  This ensures frequently accessed source
          modules are always near the front of the list.

          Similarly, target object descriptors are moved to the front
          of their lists when found.  This further ensures high performance
          by quicly locating



Arguments:

    SourceModule - The module (ala event viewer modules) defining the
        object type.

    ObjectTypeName - The type of object to which the access mask applies.

    Accesses - The access mask to be used in building the display string.

    Indent - Access Mask should be indented.

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.


    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AccessCount = 0;
    ULONG BaseOffset;
    ULONG i;
    ACCESS_MASK Mask;
    PLSAP_ADT_SOURCE Source;
    PLSAP_ADT_SOURCE FoundSource = NULL;
    PLSAP_ADT_OBJECT Object;
    PLSAP_ADT_OBJECT FoundObject = NULL;
    BOOLEAN Found;
    BOOLEAN IsDs = FALSE;
    UNICODE_STRING DsSourceName;
    UNICODE_STRING DsObjectTypeName;

#ifdef LSAP_ADT_TEST_DUMP_SOURCES
    printf("Module:\t%wS\n", SourceModule);
    printf("\t   Object:\t%wS\n", ObjectTypeName);
    printf("\t Accesses:\t0x%lx\n", Accesses);
#endif

    //
    // If we have no accesses, return "-"
    //

    if (Accesses == 0) {

        RtlInitUnicodeString( ResultantString, L"-" );
        (*FreeWhenDone) = FALSE;
        return(STATUS_SUCCESS);
    }

    //
    // First figure out how large a buffer we need
    //
    Mask = Accesses;

    //
    // Count the number of set bits in the
    // passed access mask.
    //

    while ( Mask != 0 ) {
        Mask = Mask & (Mask - 1);
        AccessCount++;
    }


#ifdef LSAP_ADT_TEST_DUMP_SOURCES
    printf("\t          \t%d bits set in mask.\n", AccessCount);
#endif


    //
    // We have accesses, allocate a string large enough to deal
    // with them all.  Strings will be of the format:
    //
    //      %%nnnnnnnnnn\n\r\t\t%%nnnnnnnnnn\n\r\t\t ... %nnnnnnnnnn\n\r\t\t
    //
    // where nnnnnnnnnn - is a decimal number 10 digits long or less.
    //
    // So, a typical string will look like:
    //
    //      %%601\n\r\t\t%%1604\n\r\t\t%%1608\n
    //
    // Since each such access may use at most:
    //
    //          10  (for the nnnnnnnnnn digit)
    //        +  2  (for %%)
    //        +  8  (for \n\t\t)
    //        --------------------------------
    //          20  wide characters
    //
    // The total length of the output string will be:
    //
    //           AccessCount    (number of accesses)
    //         x          20    (size of each entry)
    //         -------------------------------------
    //                          wchars
    //
    // Throw in 1 more WCHAR for null termination, and we are all set.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = (USHORT)AccessCount * (20 * sizeof(WCHAR)) +
                                 sizeof(WCHAR);  //for the null termination

#ifdef LSAP_ADT_TEST_DUMP_SOURCES
    printf("\t          \t%d byte buffer allocated.\n", ResultantString->MaximumLength);
#endif
    ResultantString->Buffer = LsapAllocateLsaHeap( ResultantString->MaximumLength );


    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }

    (*FreeWhenDone) = TRUE;

    //
    // Special case standard and special access types.
    // Walk the lists for specific access types.
    //

    if (Accesses & STANDARD_RIGHTS_ALL) {

        if (Accesses & DELETE) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringDelete);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));

        }


        if (Accesses & READ_CONTROL) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringReadControl);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }


        if (Accesses & WRITE_DAC) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringWriteDac);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }


        if (Accesses & WRITE_OWNER) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringWriteOwner);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }

        if (Accesses & SYNCHRONIZE) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringSynchronize);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }
    }


    if (Accesses & ACCESS_SYSTEM_SECURITY) {

        Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
        ASSERT( NT_SUCCESS( Status ));

        Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringAccessSysSec);
        ASSERT( NT_SUCCESS( Status ));

        if ( Indent ) {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
        } else {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
        }
        ASSERT( NT_SUCCESS( Status ));
    }

    if (Accesses & MAXIMUM_ALLOWED) {

        Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
        ASSERT( NT_SUCCESS( Status ));

        Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringMaxAllowed);
        ASSERT( NT_SUCCESS( Status ));

        if ( Indent ) {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
        } else {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
        }
        ASSERT( NT_SUCCESS( Status ));
    }


    //
    // If there are any specific access bits set, then get
    // the appropriate source module and object type base
    // message ID offset.  If there is no module-specific
    // object definition, then use SE_ACCESS_NAME_SPECIFIC_0
    // as the base.
    //

    if ((Accesses & SPECIFIC_RIGHTS_ALL) == 0) {
        return(Status);
    }

    LsapAdtSourceModuleLock();

    Source = (PLSAP_ADT_SOURCE)&LsapAdtSourceModules;
    Found  = FALSE;

    while ((Source->Next != NULL) && !Found) {

        if (RtlEqualUnicodeString(&Source->Next->Name, SourceModule, TRUE)) {

            Found = TRUE;
            FoundSource = Source->Next;

            //
            // Move to front of list of source modules.
            //

            Source->Next = FoundSource->Next;    // Remove from list
            FoundSource->Next = LsapAdtSourceModules; // point to first element
            LsapAdtSourceModules = FoundSource;       // Make it the first element

#ifdef LSAP_ADT_TEST_DUMP_SOURCES
printf("\t          \tModule Found.\n");
#endif

        } else {

            Source = Source->Next;
        }
    }


    if (Found == TRUE) {

        //
        // Find the object
        //

        Object = (PLSAP_ADT_OBJECT)&(FoundSource->Objects);
        Found  = FALSE;

        //
        // Initialize Ds string
        //
        RtlInitUnicodeString( &DsSourceName, ACCESS_DS_SOURCE_W );

        //
        // Determine if this is DS Object
	// ObjectTypeName GUID follows this format: %{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} 
        //
        IsDs = RtlEqualUnicodeString( SourceModule, &DsSourceName, TRUE ) && 
	       LSAP_ADT_OBJECT_TYPE_NAME_LENGTH == ObjectTypeName->Length &&
	       L'%' == ObjectTypeName->Buffer[0] &&
	       L'{' == ObjectTypeName->Buffer[1] &&
	       L'}' == ObjectTypeName->Buffer[(LSAP_ADT_OBJECT_TYPE_NAME_LENGTH / sizeof(WCHAR)) - 1];

	//
	// Initialize DS Object string
	//
        RtlInitUnicodeString( &DsObjectTypeName, ACCESS_DS_OBJECT_TYPE_NAME_W );

        while ((Object->Next != NULL) && !Found) {

            if ( (IsDs && RtlEqualUnicodeString(&Object->Next->Name, &DsObjectTypeName, TRUE)) || 
		    RtlEqualUnicodeString(&Object->Next->Name, ObjectTypeName, TRUE) ) {

                Found = TRUE;
                FoundObject = Object->Next;

                //
                // Move to front of list of soure modules.
                //

                Object->Next = FoundObject->Next;          // Remove from list
                FoundObject->Next = FoundSource->Objects;  // point to first element
                FoundSource->Objects = FoundObject;        // Make it the first element

            } else {

                Object = Object->Next;
            }
        }
    }


    //
    // We are done playing with link fields of the source modules
    // and objects.  Free the lock.
    //

    LsapAdtSourceModuleUnlock();

    //
    // If we have found an object, use it as our base message
    // ID.  Otherwise, use SE_ACCESS_NAME_SPECIFIC_0.
    //

    if (Found) {

        BaseOffset = FoundObject->BaseOffset;
#ifdef LSAP_ADT_TEST_DUMP_SOURCES
printf("\t          \tObject Found.  Base Offset: 0x%lx\n", BaseOffset);
#endif

    } else {

        BaseOffset = SE_ACCESS_NAME_SPECIFIC_0;
#ifdef LSAP_ADT_TEST_DUMP_SOURCES
printf("\t          \tObject NOT Found.  Base Offset: 0x%lx\n", BaseOffset);
#endif
    }


    //
    // At this point, we have a base offset (even if we had to use our
    // default).
    //
    // Now cycle through the specific access bits and see which ones need
    // to be added to ResultantString.
    //

    {
        UNICODE_STRING  IntegerString;
        WCHAR           IntegerStringBuffer[10]; //must be 10 wchar bytes long
        ULONG           NextBit;

        IntegerString.Buffer = (PWSTR)IntegerStringBuffer;
        IntegerString.MaximumLength = 10*sizeof(WCHAR);
        IntegerString.Length = 0;

        for ( i=0, NextBit=1  ; i<16 ;  i++, NextBit <<= 1 ) {

            //
            // specific access flags are in the low-order bits of the mask
            //

            if ((NextBit & Accesses) != 0) {

                //
                // Found one  -  add it to ResultantString
                //

                Status = RtlIntegerToUnicodeString (
                             (BaseOffset + i),
                             10,        //Base
                             &IntegerString
                             );

                if (NT_SUCCESS(Status)) {

                    Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
                    ASSERT( NT_SUCCESS( Status ));

                    Status = RtlAppendUnicodeStringToString( ResultantString, &IntegerString);
                    ASSERT( NT_SUCCESS( Status ));

                    if ( Indent ) {
                        Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
                    } else {
                        Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
                    }
                    ASSERT( NT_SUCCESS( Status ));
                }
            }
        }
    }

    return(Status);


//ErrorAfterAlloc:
//
//    LsapFreeLsaHeap( ResultantString->Buffer );
//    ResultantString->Buffer = NULL;
//    (*FreeWhenDone) = FALSE;
//    return(Status);
}



NTSTATUS
LsapAdtBuildUserAccountControlString(
    IN  ULONG UserAccountControlOld,
    IN  ULONG UserAccountControlNew,
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN FreeWhenDone2,
    OUT PUNICODE_STRING ResultantString3,
    OUT PBOOLEAN FreeWhenDone3
    )

/*++

Routine Description:

    This function builds a unicode string containing parameter
    file replacement parameters (e.g. %%1043) separated by carriage
    return and tab characters suitable for display via the event viewer.


    The buffer returned by this routine must be deallocated when no
    longer needed if FreeWhenDone is true.


Arguments:

    UserAccountControl - 

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.
--*/

{
    NTSTATUS        Status = STATUS_SUCCESS;
    UNICODE_STRING  IntegerString;
    WCHAR           IntegerStringBuffer[10]; //must be 10 wchar bytes long
    ULONG           ChangedMask;
    ULONG           Mask;
    ULONG           BitCount = 0;
    ULONG           i;
    ULONG           BaseOffset;
    const ULONG     BaseOffsetOff = SE_ADT_FLAG_UAC_ACCOUNT_DISABLED_OFF;
    const ULONG     BaseOffsetOn  = SE_ADT_FLAG_UAC_ACCOUNT_DISABLED_ON;

    *FreeWhenDone1 = FALSE;
    *FreeWhenDone2 = FALSE;
    *FreeWhenDone3 = FALSE;

    IntegerString.Buffer = IntegerStringBuffer;
    IntegerString.MaximumLength = 10 * sizeof(WCHAR);
    IntegerString.Length = 0;


    //
    // Allocate memory for the first two strings (old and new
    // UserAccountControl in hex).
    // Both strings look like '0xBADCAB1E'
    //

    ResultantString1->Length        = 0;
    ResultantString1->MaximumLength = (10 + 1) * sizeof(WCHAR);
    ResultantString1->Buffer        = LsapAllocateLsaHeap(
                                          ResultantString1->MaximumLength);

    if (ResultantString1->Buffer == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    *FreeWhenDone1 = TRUE;

    ResultantString2->Length        = 0;
    ResultantString2->MaximumLength = (10 + 1) * sizeof(WCHAR);
    ResultantString2->Buffer        = LsapAllocateLsaHeap(
                                          ResultantString2->MaximumLength);

    if (ResultantString2->Buffer == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    *FreeWhenDone2 = TRUE;


    //
    // First string: the old value.
    //

    Status = RtlAppendUnicodeToString(ResultantString1, L"0x");
    ASSERT(NT_SUCCESS(Status));

    Status = RtlIntegerToUnicodeString(
                    UserAccountControlOld,
                    16,        // Base
                    &IntegerString
                    );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlAppendUnicodeStringToString(ResultantString1, &IntegerString);
    ASSERT(NT_SUCCESS(Status));


    //
    // Second string: the new value.
    //

    Status = RtlAppendUnicodeToString(ResultantString2, L"0x");
    ASSERT(NT_SUCCESS(Status));

    Status = RtlIntegerToUnicodeString(
                    UserAccountControlNew,
                    16,        // Base
                    &IntegerString
                    );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlAppendUnicodeStringToString(ResultantString2, &IntegerString);
    ASSERT(NT_SUCCESS(Status));


    //
    // Compute the bits that have changed by xor'ing old and new.
    //

    ChangedMask = UserAccountControlOld ^ UserAccountControlNew;


    //
    // If no bits have changed, return "-" for the third string.
    //

    if (ChangedMask == 0)
    {
        RtlInitUnicodeString(ResultantString3, L"-");
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }


    //
    // Figure out how large a buffer we need.
    // Count the number of 1 - bits in ChangedMask.
    //

    for (Mask = 1; Mask; Mask <<= 1)
    {
        if (ChangedMask & Mask)
        {
            BitCount++;
        }
    }


    //
    // Allocate a string large enough to deal with all bits set.
    // Strings will be of the format:
    //
    //      \n\r\t\t%%nnnnnnnnnn\n\r\t\t%%nnnnnnnnnn\n\r\t\t ... %nnnnnnnnnn
    //
    // where nnnnnnnnnn - is a decimal number 10 digits long or less.
    // The first two lines in the string display the old and new hex value of UserAccountControl.
    //
    // So, a typical string will look like:
    //
    //      \n\r\t\t%%601\n\r\t\t%%1604\n\r\t\t%%1608
    //
    // Since each such bit may use at most:
    //
    //           6  (for \n\r\t\t%%)
    //        + 10  (for the nnnnnnnnnn digits)
    //        --------------------------------
    //          16  wide characters
    //
    // The total length of the output string for the bits will be:
    //
    //              BitCount    (number of bits set)
    //         x          16    (size of each entry)
    //         -------------------------------------
    //         BitCount x 16    wchars
    //
    // Throw in 1 more WCHAR for null termination, and we are all set.
    //

    ResultantString3->Length        = 0;
    ResultantString3->MaximumLength = ((USHORT)BitCount * 16 + 1) * sizeof(WCHAR);
    ResultantString3->Buffer        = LsapAllocateLsaHeap(
                                          ResultantString3->MaximumLength);

    if (ResultantString3->Buffer == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    *FreeWhenDone3 = TRUE;


    //
    // Third string: Build a line for each bit that has changed.
    //

    for (i = 0, Mask = 1; i < 32 && Mask; i++, Mask <<= 1)
    {
        if (Mask & ChangedMask)
        {
            //
            // Found one  -  add it to ResultantString3
            //

            BaseOffset = (Mask & UserAccountControlNew) ? BaseOffsetOn : BaseOffsetOff;

            Status = RtlIntegerToUnicodeString(
                            (BaseOffset + i),
                            10,        // Base
                            &IntegerString
                            );
            ASSERT(NT_SUCCESS(Status));

            if (NT_SUCCESS(Status))
            {
                Status = RtlAppendUnicodeToString(ResultantString3, L"\r\n\t\t%%");
                ASSERT(NT_SUCCESS(Status));

                Status = RtlAppendUnicodeStringToString(ResultantString3, &IntegerString);
                ASSERT(NT_SUCCESS(Status));
            }
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtpol.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtpol.c

Abstract:

    This file has functions related to audit policy.

Author:

    16-August-2000  kumarp

--*/

#include <lsapch2.h>
#include "adtp.h"


//
// Audit Events Information.
//

LSARM_POLICY_AUDIT_EVENTS_INFO LsapAdtEventsInformation;


POLICY_AUDIT_EVENT_TYPE
LsapAdtEventTypeFromCategoryId(
    IN ULONG CategoryId
    )

/**

Routine Description:

    This function translates a Category ID to an POLICY_AUDIT_EVENT_TYPE.
    For example SE_CATEGID_SYSTEM is translated to AuditCategorySystem.

Arguments:

    CategoryId - category as defined in msaudite.h

Return Value:

    POLICY_AUDIT_EVENT_TYPE.

**/

{
    ASSERT(SE_ADT_MIN_CATEGORY_ID <= CategoryId && CategoryId <= SE_ADT_MAX_CATEGORY_ID);

    return (POLICY_AUDIT_EVENT_TYPE)(CategoryId - 1);
}


BOOLEAN
LsapAdtAuditingEnabledByCategory(
    IN POLICY_AUDIT_EVENT_TYPE Category,
    IN UINT AuditEventType
    )

/**

Routine Description:

    This function returns the system audit settings for a given category
    and event type.  This does not consider any per user settings.
    
Arguments:

    Category - category to query
    
    AuditEventType - either EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE.
    
Return Value:

    Boolean.
    
**/

{
    if (AuditEventType == EVENTLOG_AUDIT_SUCCESS)
    {
        return (BOOLEAN)(LsapAdtEventsInformation.EventAuditingOptions[Category] & POLICY_AUDIT_EVENT_SUCCESS);
    } 
    else if (AuditEventType == EVENTLOG_AUDIT_FAILURE)
    {
        return (BOOLEAN)(LsapAdtEventsInformation.EventAuditingOptions[Category] & POLICY_AUDIT_EVENT_FAILURE);
    }

    //
    // Should not reach this point.
    //
    
    ASSERT(FALSE);
    return FALSE;
}


NTSTATUS
LsapAdtAuditingEnabledByLogonId(
    IN POLICY_AUDIT_EVENT_TYPE Category,
    IN PLUID LogonId,
    IN UINT AuditEventType,
    OUT PBOOLEAN bAudit
    )

/**

Routine Description:

    Returns whether or not an audit should be generated for a given logon id.
    
Arguments:

    Category - category to query.
    
    LogonId - LogonId of a user.
    
    AuditEventType - either EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE.
    
    bAudit - address of boolean to receive audit settings.
    
Return Value:

    Appropriate NTSTATUS value.
    
**/

{
    UCHAR               Buffer[PER_USER_AUDITING_MAX_POLICY_SIZE];
    PTOKEN_AUDIT_POLICY pPolicy = (PTOKEN_AUDIT_POLICY) Buffer;
    ULONG               Length = sizeof(Buffer);
    NTSTATUS            Status = STATUS_SUCCESS;
    BOOLEAN             bFound = FALSE;
    
    ASSERT((AuditEventType == EVENTLOG_AUDIT_SUCCESS) ||
           (AuditEventType == EVENTLOG_AUDIT_FAILURE));

    if (0 == LsapAdtEventsInformation.EventAuditingOptions[Category] &&
        0 == LsapAdtPerUserPolicyCategoryCount[Category])
    {
        *bAudit = FALSE;
        goto Cleanup;
    }
        
    //
    // Get system settings first.
    //

    *bAudit = LsapAdtAuditingEnabledByCategory(
                  Category, 
                  AuditEventType
                  );

    //
    // Now get the per user settings.
    //

    Status = LsapAdtQueryPolicyByLuidPerUserAuditing(
                 LogonId,
                 pPolicy,
                 &Length,
                 &bFound
                 );
    
    if (!NT_SUCCESS(Status) || !bFound) 
    {
        goto Cleanup;
    }

    Status = LsapAdtAuditingEnabledByPolicy(
                 Category,
                 pPolicy,
                 AuditEventType,
                 bAudit
                 );

Cleanup:

    if (!NT_SUCCESS(Status)) 
    {
        LsapAuditFailed(Status);
    }
    return Status;
}


NTSTATUS
LsapAdtAuditingEnabledBySid(
    IN POLICY_AUDIT_EVENT_TYPE Category,
    IN PSID UserSid,
    IN UINT AuditEventType,
    OUT PBOOLEAN bAudit
    )

/**

Routine Description:

    Returns whether or not an audit should be generated for a given Sid.
    
Arguments:

    Category - category to query.
    
    Sid - Sid of a user.
    
    AuditEventType - either EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE.
    
    bAudit - address of boolean to receive audit settings.
    
Return Value:

    Appropriate NTSTATUS value.
    
**/

{
    UCHAR               Buffer[PER_USER_AUDITING_MAX_POLICY_SIZE];
    PTOKEN_AUDIT_POLICY pPolicy = (PTOKEN_AUDIT_POLICY) Buffer;
    ULONG               Length = sizeof(Buffer);
    NTSTATUS            Status = STATUS_SUCCESS;
    BOOLEAN             bFound = FALSE;

    ASSERT((AuditEventType == EVENTLOG_AUDIT_SUCCESS) ||
           (AuditEventType == EVENTLOG_AUDIT_FAILURE));

    if (0 == LsapAdtEventsInformation.EventAuditingOptions[Category] &&
        0 == LsapAdtPerUserPolicyCategoryCount[Category]) 
    {
        *bAudit = FALSE;
        goto Cleanup;
    }

    //
    // Get system settings first.
    //

    *bAudit = LsapAdtAuditingEnabledByCategory(
                  Category, 
                  AuditEventType
                  );

    //
    // Now get the per user settings.
    //

    Status = LsapAdtQueryPerUserAuditing(
                 UserSid,
                 pPolicy,
                 &Length,
                 &bFound
                 );

    if (!NT_SUCCESS(Status) || !bFound) 
    {
        goto Cleanup;
    }

    Status = LsapAdtAuditingEnabledByPolicy(
                 Category,
                 pPolicy,
                 AuditEventType,
                 bAudit
                 );

Cleanup:

    if (!NT_SUCCESS(Status)) 
    {
        LsapAuditFailed(Status);
    }
    return Status;
}


NTSTATUS
LsapAdtAuditingEnabledByPolicy(
    IN POLICY_AUDIT_EVENT_TYPE Category,
    IN PTOKEN_AUDIT_POLICY pPolicy,
    IN UINT AuditEventType,
    OUT PBOOLEAN bAudit
    )

/*++

Routine Description

    This routine will indicate whether or not an audit should be generated.  It must return
    an NT_SUCCESS value, and *bAudit == TRUE to indicate that an audit should be generated.
    
Arguments
    
    Category - which category to query
    
    pPolicy - policy to read.

    AuditEventType - either success or failure.

    bAudit - address of a boolean which will indicate if we should audit.
    
Return Value

    Appropriate NTSTATUS value.
    
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    i;
    ULONG    Mask = 0;
    BOOLEAN  bSuccess;
    
    //
    // Set the returns to reflect the system settings.
    //
    
    bSuccess = (AuditEventType == EVENTLOG_AUDIT_SUCCESS) ? TRUE : FALSE;
    *bAudit  = LsapAdtAuditingEnabledByCategory(Category, AuditEventType);

    //
    // Locate the policy element in the user's Policy that contains information for the 
    // specified category.
    //
    // When we go to per event policy this must be modified to use a better search.
    //

    for (i = 0; i < pPolicy->PolicyCount; i++) 
    {
        if (pPolicy->Policy[i].Category == Category)
        {
            Mask = pPolicy->Policy[i].PolicyMask;
            break;
        }
    }

    //
    // Now decide if we should override system policy based upon 
    // the audit policy of this user.
    //

    if (Mask) 
    {
        //
        // If granted and the token is marked for success_include OR
        // if not granted and token is marked for failure_include then
        // audit the event.
        //

        if ((bSuccess && (Mask & TOKEN_AUDIT_SUCCESS_INCLUDE)) ||
            (!bSuccess && (Mask & TOKEN_AUDIT_FAILURE_INCLUDE))) 
        {
            *bAudit = TRUE;
        }

        //
        // If granted and the token is marked for success_exclude OR
        // if not granted and token is marked for failure_exclude then
        // do not audit the event.
        //

        else if ((bSuccess && (Mask & TOKEN_AUDIT_SUCCESS_EXCLUDE)) ||
                 (!bSuccess && (Mask & TOKEN_AUDIT_FAILURE_EXCLUDE))) 
        {
            *bAudit = FALSE;
        } 
    }
    return Status;
}


BOOLEAN
LsapAdtAuditingEnabledHint(
    IN POLICY_AUDIT_EVENT_TYPE AuditCategory,
    IN UINT AuditEventType
    )

/**

Routine Description

    This is a hinting version of LsapAdtAuditingEnabledBy*.  It can be called to quickly determine
    if an audit codepath may need to be executed.  
    
Arguments

    AuditCategory - the category to query
    
    AuditEventType - either a success or failure audit
    
Return Value

    Appropriate NTSTATUS value.
    
**/

{
    BOOLEAN AuditingEnabled;
    POLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    
    ASSERT((AuditEventType == EVENTLOG_AUDIT_SUCCESS) ||
           (AuditEventType == EVENTLOG_AUDIT_FAILURE));
    
    AuditingEnabled = FALSE;
    
    EventAuditingOptions = LsapAdtEventsInformation.EventAuditingOptions[AuditCategory];
    
    //
    // If there are users with this category active in their per user settings, then flip 
    // both success and fail into the EventAuditingOptions.
    //

    if (LsapAdtPerUserAuditHint[AuditCategory]) 
    {
        EventAuditingOptions |= (POLICY_AUDIT_EVENT_SUCCESS | POLICY_AUDIT_EVENT_FAILURE);
    }

    AuditingEnabled =
        (AuditEventType == EVENTLOG_AUDIT_SUCCESS) ?
        (BOOLEAN) (EventAuditingOptions & POLICY_AUDIT_EVENT_SUCCESS) :
        (BOOLEAN) (EventAuditingOptions & POLICY_AUDIT_EVENT_FAILURE);

    return AuditingEnabled;
}


VOID
LsapAuditFailed(
    IN NTSTATUS AuditStatus
    )

/*++

Routine Description:

    Implements current policy of how to deal with a failed audit.

Arguments:

    None.

Return Value:

    None.

--*/

{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE KeyHandle;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    DWORD NewValue;
    ULONG Response;
    ULONG_PTR HardErrorParam;
    BOOLEAN PrivWasEnabled;
    
    if (LsapCrashOnAuditFail) {

        //
        // Turn off flag in the registry that controls crashing on audit failure
        //

        RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa");

        InitializeObjectAttributes( &Obja,
                                    &KeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                    );
        do {

            Status = NtOpenKey(
                         &KeyHandle,
                         KEY_SET_VALUE,
                         &Obja
                         );

        } while ((Status == STATUS_INSUFFICIENT_RESOURCES) || (Status == STATUS_NO_MEMORY));

        //
        // If the LSA key isn't there, he's got big problems.  But don't crash.
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            LsapCrashOnAuditFail = FALSE;
            return;
        }

        if (!NT_SUCCESS( Status )) {
            goto bugcheck;
        }

        RtlInitUnicodeString( &ValueName, CRASH_ON_AUDIT_FAIL_VALUE );

        NewValue = LSAP_ALLOW_ADIMIN_LOGONS_ONLY;

        do {

            Status = NtSetValueKey( KeyHandle,
                                    &ValueName,
                                    0,
                                    REG_DWORD,
                                    &NewValue,
                                    sizeof(NewValue)
                                    );

        } while ((Status == STATUS_INSUFFICIENT_RESOURCES) || (Status == STATUS_NO_MEMORY));
        ASSERT(NT_SUCCESS(Status));

        if (!NT_SUCCESS( Status )) {
            goto bugcheck;
        }

        do {

            Status = NtFlushKey( KeyHandle );

        } while ((Status == STATUS_INSUFFICIENT_RESOURCES) || (Status == STATUS_NO_MEMORY));
        ASSERT(NT_SUCCESS(Status));

    //
    // go boom.
    //

bugcheck:

        //
        // Write the audit-failed event to the security log and
        // flush the log.
        //

        LsapAdtLogAuditFailureEvent( AuditStatus );
        
        HardErrorParam = AuditStatus;

        //
        // stop impersonating
        //
 
        Status = NtSetInformationThread(
                     NtCurrentThread(),
                     ThreadImpersonationToken,
                     NULL,
                     (ULONG) sizeof(HANDLE)
                     );

        DsysAssertMsg( NT_SUCCESS(Status), "LsapAuditFailed: NtSetInformationThread" );
        
        
        //
        // enable the shutdown privilege so that we can bugcheck
        // 

        Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE, TRUE, FALSE, &PrivWasEnabled );

        DsysAssertMsg( NT_SUCCESS(Status), "LsapAuditFailed: RtlAdjustPrivilege" );
        
        Status = NtRaiseHardError(
                     STATUS_AUDIT_FAILED,
                     1,
                     0,
                     &HardErrorParam,
                     OptionShutdownSystem,
                     &Response
                     );

        //
        // if the bugcheck succeeds, we should not really come here
        //

        DsysAssertMsg( FALSE, "LsapAuditFailed: we should have bugchecked on the prior line!!" );
    }
#if DBG
    else
    {
       DbgPrint("LsapAuditFailed: auditing failed with 0x%x\n", AuditStatus);
       if (AuditStatus != RPC_NT_NO_CONTEXT_AVAILABLE && 
           AuditStatus != RPC_NT_NO_CALL_ACTIVE       &&
           LsapAdtNeedToAssert( AuditStatus ))
       {
           ASSERT(FALSE && "LsapAuditFailed: auditing failed.");
       }
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtutil.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adtutil.h

Abstract:

    Misc helper functions

Author:

    15-August-2000   kumarp

--*/

ULONG
LsapSafeWcslen(
    UNALIGNED WCHAR *p,
    LONG            MaxLength
    );


BOOL
LsapIsValidUnicodeString(
    IN PUNICODE_STRING pUString
    );


BOOL
LsapIsLocalOrNetworkService(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain
    );

BOOL
LsapIsAnonymous(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtpup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtpup.c

Abstract:

    This file has functions related to per user auditing.

Author:

    20-August-2001 jhamblin

--*/

#include <lsapch2.h>
#include "adtp.h"
#include <sddl.h>

#define LsapAdtLuidIndexPerUserAuditing(L) ((L)->LowPart % PER_USER_AUDITING_LUID_TABLE_SIZE)

ULONG LsapAdtDebugPup = 0;

//
// Hash table of Per User policies and the LUID table.
//

PPER_USER_AUDITING_ELEMENT LsapAdtPerUserAuditingTable[PER_USER_AUDITING_POLICY_TABLE_SIZE];
PPER_USER_AUDITING_LUID_QUERY_ELEMENT LsapAdtPerUserAuditingLuidTable[PER_USER_AUDITING_LUID_TABLE_SIZE];

//
// Locks to protect the tables.
//

RTL_RESOURCE LsapAdtPerUserPolicyTableResource;
RTL_RESOURCE LsapAdtPerUserLuidTableResource;

//
// Counter for the number of users with registered per user audit policies.
//

LONG LsapAdtPerUserAuditUserCount;

//
// Counter for the number of active logon sessions in the system with per user settings
// active in the token.
//

LONG LsapAdtPerUserAuditLogonCount;

//
// Handle for the registry key
//

HKEY LsapAdtPerUserKey;

//
// Handle to the event which is signalled when the registry key is changed.
//

HANDLE LsapAdtPerUserKeyEvent;

// 
// Timer which is set by the NotifyStub routine.  When the timer fires 
// then NotifyFire is called and the per user table is rebuilt.
//

HANDLE LsapAdtPerUserKeyTimer;

//
// Hint array - counts the number of tokens that exist with settings for 
// each category.
//

LONG LsapAdtPerUserAuditHint[POLICY_AUDIT_EVENT_TYPE_COUNT];

//
// Array storing the number of users which have each category enabled in
// their per user settings.
//

LONG LsapAdtPerUserPolicyCategoryCount[POLICY_AUDIT_EVENT_TYPE_COUNT];


NTSTATUS
LsapAdtConstructTablePerUserAuditing(
    VOID
    )

/*++

Routine Description
    
    This routine creates the Per User policy table from data found under the 
    LsapAdtPerUserKey.  
    
Arguments

    None.
    
Return Value

    Appropriate NTSTATUS value.

--*/

{
#define STACK_BUFFER_VALUE_NAME_INFO_SIZE 256
    UCHAR                       KeyInfo[sizeof(KEY_VALUE_FULL_INFORMATION) + STACK_BUFFER_VALUE_NAME_INFO_SIZE];
    NTSTATUS                    Status;
    ULONG                       ResultLength;
    ULONG                       i;
    ULONG                       j;
    ULONG                       HashValue;
    ULONG                       NewElementSize;
    PPER_USER_AUDITING_ELEMENT  pNewElement;
    PPER_USER_AUDITING_ELEMENT  pTempElement;
    ULONG                       TokenPolicyLength;
    PSID                        pSid               = NULL;
    PKEY_VALUE_FULL_INFORMATION pKeyInfo           = NULL;
    UCHAR                       StringBuffer[80];
    PWSTR                       pSidString         = (PWSTR) StringBuffer;
    BOOLEAN                     b;
    static DWORD                dwRetryCount = 0;
#define RETRY_COUNT_MAX 3

    //
    // Close and then reopen the key.  This remedies the case where key may have 
    // been deleted or renamed.
    //

    if (LsapAdtPerUserKey)
    {
        NtClose(LsapAdtPerUserKey);
        LsapAdtPerUserKey = NULL;
    }

    Status = LsapAdtOpenPerUserAuditingKey();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // LsapAdtOpenPerUserAuditingKey can return success and not open the key
    // (the simple case where the key does not exist)
    //

    if (NULL == LsapAdtPerUserKey)
    {
        goto Cleanup;
    } 

    //
    // Zero the table array as we may be rebuilding it and cannot
    // be certain it is already zeroed.  
    //

    RtlZeroMemory(
        LsapAdtPerUserAuditingTable, 
        sizeof(LsapAdtPerUserAuditingTable)
        );

    //
    // Loop through all the values under the key (sids)
    //

    for (i = 0, Status = STATUS_SUCCESS; NT_SUCCESS(Status); i++) 
    {
        pKeyInfo = (PKEY_VALUE_FULL_INFORMATION) KeyInfo;
        
        Status = NtEnumerateValueKey(
                     LsapAdtPerUserKey,
                     i,
                     KeyValueFullInformation,
                     pKeyInfo,
                     sizeof(KeyInfo),
                     &ResultLength
                     );

        //
        // If we failed because the buffer was too small...
        //

        if (STATUS_BUFFER_TOO_SMALL == Status) 
        {
            //
            // Include space for the NULL in case we are debugging and want to
            // dbgprint the key name.
            //

            pKeyInfo = LsapAllocateLsaHeap( ResultLength + sizeof(WCHAR));
            
            if (pKeyInfo) 
            {
                Status = NtEnumerateValueKey(
                             LsapAdtPerUserKey,
                             i,
                             KeyValueFullInformation,
                             pKeyInfo,
                             ResultLength,
                             &ResultLength
                             );
                
                if (!NT_SUCCESS(Status)) 
                {
                    goto Cleanup;
                }
            } 
            else 
            {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }
        }

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // We have the value information, either in the stack buffer or in the heap
        // allocation.
        //

        //
        // Copy the string into another buffer so we can null terminate it.
        //

        if (pKeyInfo->NameLength < sizeof(StringBuffer))
        {
            pSidString = (PWSTR) StringBuffer;
            RtlCopyMemory(pSidString, pKeyInfo->Name, pKeyInfo->NameLength);
        }
        else
        {
            pSidString = LsapAllocateLsaHeap(
                             pKeyInfo->NameLength + sizeof(WCHAR)
                             );
            if (pSidString)
            {
                RtlCopyMemory(pSidString, pKeyInfo->Name, pKeyInfo->NameLength);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }
        }

        pSidString[pKeyInfo->NameLength / sizeof(WCHAR)] = L'\0';

#if DBG
        if (LsapAdtDebugPup)
        {
            DbgPrint("pKeyInfo (PKEY_VALUE_FULL_INFORMATION) = 0x%x Name = %S Value = 0x%x\n", 
                     pKeyInfo, pSidString, *((PUCHAR)pKeyInfo + pKeyInfo->DataOffset));
        }
#endif
        //
        // Convert the string SID to a binary SID.
        //

        b = (BOOLEAN) ConvertStringSidToSid(
                          pSidString,
                          &pSid
                          );

        if (pSidString != (PWSTR) StringBuffer)
        {
            LsapFreeLsaHeap(pSidString);
        }

        if (!b)
        {
            //
            // Ignore failures from ConvertStringSidToSid.  If a malformed Sid is
            // present in the registry, we don't want to fail the PUA table 
            // construction.
            //

            ASSERT(L"ConvertStringSidToSid failed" && FALSE);
        }
        else
        {
            //
            // Hash the SID.
            //

            HashValue = LsapAdtHashPerUserAuditing(
                            pSid
                            );
        
            //
            // The size of the element is the base structure + RtlLengthSid(pSid).
            //
        
            NewElementSize = sizeof(PER_USER_AUDITING_ELEMENT) + RtlLengthSid(pSid);
            pNewElement    = LsapAllocateLsaHeap(NewElementSize);

            //
            // Initialize the element for this SID.  Put it in the table.
            //

            if (pNewElement) 
            {
                //
                // copy raw policy.
                // (this will not work on a big-endian machine)
                //

                RtlCopyMemory(
                    &pNewElement->RawPolicy, 
                    ((PUCHAR) pKeyInfo) + pKeyInfo->DataOffset, 
                    min(pKeyInfo->DataLength, sizeof(pNewElement->RawPolicy))
                    );

                //
                // Assert if the reg key contains too much information to be a valid
                // policy.
                //

                ASSERT(pKeyInfo->DataLength <= sizeof(pNewElement->RawPolicy));

                //
                // Copy in the binary SID.
                //

                pNewElement->pSid = ((PUCHAR)pNewElement) + sizeof(PER_USER_AUDITING_ELEMENT);
                
                RtlCopyMemory(
                    pNewElement->pSid,
                    pSid,
                    RtlLengthSid(pSid)
                    );

                //
                // Calculate the amount of space in pNewElement for the TokenAuditPolicy
                //

                TokenPolicyLength = sizeof(pNewElement->TokenAuditPolicy) + sizeof(pNewElement->PolicyArray);

                //
                // Build the policy into a form suitable for passing to NtSetTokenInformation.
                //

                Status = LsapAdtConstructPolicyPerUserAuditing(
                             pNewElement->RawPolicy,
                             &pNewElement->TokenAuditPolicy,
                             &TokenPolicyLength
                             );

                if (!NT_SUCCESS(Status)) 
                {
                    ASSERT("Failed to LsapAdtConstructPolicyPerUserAuditing in LsapAdtInitializePerUserAuditing" && FALSE);
                    LsapFreeLsaHeap(pNewElement);
                    goto Cleanup;
                } 
                    
                //
                // Place the element into the table, at the head of the correct hash bucket.
                //

                pNewElement->Next = LsapAdtPerUserAuditingTable[HashValue];
                LsapAdtPerUserAuditingTable[HashValue] = pNewElement;
                
                //
                // Increment the counter for the number of elements in the table.  
                //
                
                InterlockedIncrement(&LsapAdtPerUserAuditUserCount);

                //
                // Increment the user / category counter if the policy has include audit bits set.
                //

                for (j = 0; j < pNewElement->TokenAuditPolicy.PolicyCount; j++) 
                {
                    if (pNewElement->TokenAuditPolicy.Policy[j].PolicyMask & (TOKEN_AUDIT_SUCCESS_INCLUDE | TOKEN_AUDIT_FAILURE_INCLUDE))
                    {
                        InterlockedIncrement(&LsapAdtPerUserPolicyCategoryCount[pNewElement->TokenAuditPolicy.Policy[j].Category]);
                    }
                }
#if DBG
                if (LsapAdtDebugPup)
                {
                    DbgPrint("PUP added element 0x%x for %S\n", pNewElement, pKeyInfo->Name);
                }
#endif
            } 
            else 
            {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            LocalFree(pSid);
            pSid = NULL;

        }
        
        //
        // If we allocated heap for the key information then free it now.
        //

        if (pKeyInfo != (PKEY_VALUE_FULL_INFORMATION)KeyInfo) 
        {
            LsapFreeLsaHeap(pKeyInfo);
            pKeyInfo = NULL;
        }
    }

Cleanup:
    
    if (pSid)
    {
        LocalFree(pSid);
    }

    //
    // If we broke out of the loop because we have read all values then
    // set the status to success.
    //

    if (Status == STATUS_NO_MORE_ENTRIES) {
        Status = STATUS_SUCCESS;
    }

#if DBG
    if (LsapAdtDebugPup)
    {
        DbgPrint("LsapAdtConstructTablePerUserAuditing: Complete with status 0x%x. Count = %d\n", Status, LsapAdtPerUserAuditUserCount);
    }
#endif
    
    if (pKeyInfo != NULL && pKeyInfo != (PKEY_VALUE_FULL_INFORMATION)KeyInfo)
    {
        LsapFreeLsaHeap(pKeyInfo);
        pKeyInfo = NULL;
    }

    //
    // If failure, call the table free routine, in case some table elements were successfully allocated.
    //

    if (!NT_SUCCESS(Status))
    {
        (VOID) LsapAdtFreeTablePerUserAuditing();

        //
        // If one of the registry routines failed because keys were still being
        // modified, then reschedule table creation to occur in 5 seconds.
        // For example, if status is STATUS_INTERNAL_ERROR it often means that a new value 
        // was being added under the key at the time NtEnumerateValueKey was called.
        // We do not want to constantly retry if something is wrong, however, so only
        // retry 3 times without success.
        //

        if (++dwRetryCount < RETRY_COUNT_MAX)
        {
            DWORD dwError;
            dwError = LsapAdtKeyNotifyStubPerUserAuditing(
                          NULL
                          );

            //
            // If NotifyStub failed then the table will not be constructed again in 5 seconds.
            // The best we can do here is recursively call ourself immediately.  Note that the
            // recursion will stop, as we already incremented dwRetryCount.
            //

            if (dwError != ERROR_SUCCESS)
            {
                (VOID) LsapAdtKeyNotifyStubPerUserAuditing(
                           NULL
                           );
            }
        }
        else
        {
            LsapAdtAuditPerUserTableCreation(FALSE);
            LsapAuditFailed( Status );
        }
    }
    else 
    {
        LsapAdtAuditPerUserTableCreation(TRUE);
        dwRetryCount = 0;
    }
    return Status;
}


NTSTATUS 
LsapAdtOpenPerUserAuditingKey(
    )

/*++

Routine Description:

    Opens the per user auditing registry key, creating the key if necessary.
    Then we register for notification upon change to the key.
    
Arguments:

    None.
    
Return Value:
    
    Appropriate NTSTATUS value.
    
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD dwError;
    DWORD Disposition;

#define PER_USER_AUDIT_KEY_COMPLETE L"System\\CurrentControlSet\\Control\\Lsa\\Audit\\PerUserAuditing\\System"

    //
    // The key should be NULL, otherwise we will leak a handle.
    //

    ASSERT(LsapAdtPerUserKey == NULL);
    
    //
    // These handles should not be NULL, else nothing will work.
    //

    ASSERT(LsapAdtPerUserKeyEvent != NULL);
    ASSERT(LsapAdtPerUserKeyTimer != NULL);
        
    //
    // Get the key for the per user audit settings.
    //

    dwError = RegCreateKeyEx(
                  HKEY_LOCAL_MACHINE,
                  PER_USER_AUDIT_KEY_COMPLETE,
                  0,
                  NULL,
                  0,
                  KEY_QUERY_VALUE | KEY_NOTIFY,
                  NULL,
                  &LsapAdtPerUserKey,
                  &Disposition
                  );

    if (ERROR_SUCCESS == dwError)
    {
        //
        // Ask to be notified when the key changes.
        //

        dwError = RegNotifyChangeKeyValue(
                      LsapAdtPerUserKey,
                      TRUE,
                      REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                      LsapAdtPerUserKeyEvent,
                      TRUE
                      );
        
        ASSERT(ERROR_SUCCESS == dwError);
        
        if (ERROR_SUCCESS != dwError)
        {
            Status = LsapWinerrorToNtStatus(dwError);
        }
        
        goto Cleanup;
    }
    else 
    {
        Status = LsapWinerrorToNtStatus(dwError);
        ASSERT(L"Failed to open per user auditing key." && FALSE);
        goto Cleanup;
    }

Cleanup:
        
    return Status;
}


VOID
LsapAdtFreeTablePerUserAuditing(
    VOID
    )

/*++

Routine Description

    This routine frees all heap associated with the elements of the Per User Policy table.
    
Arguments

    None.
    
Return Value

    Appropriate NTSTATUS value.
    
--*/

{
    PPER_USER_AUDITING_ELEMENT pElement;
    PPER_USER_AUDITING_ELEMENT pNextElement;
    LONG                       i;

    for (i = 0; i < PER_USER_AUDITING_POLICY_TABLE_SIZE; i++) 
    {
        pElement = LsapAdtPerUserAuditingTable[i];
        
        while (pElement) 
        {
            pNextElement = pElement->Next;
            LsapFreeLsaHeap(pElement);
            pElement     = pNextElement;
            InterlockedDecrement(&LsapAdtPerUserAuditUserCount);
        }    
        
        LsapAdtPerUserAuditingTable[i] = NULL;
    }
    
    ASSERT(LsapAdtPerUserAuditUserCount == 0);
    
    RtlZeroMemory(
        LsapAdtPerUserPolicyCategoryCount,
        sizeof(LsapAdtPerUserPolicyCategoryCount)
        );
}


ULONG
LsapAdtHashPerUserAuditing(
    IN PSID pSid
    )

/*++

Routine Description

    This performs a simple hash on the passed in sid.
    
Arguments

    pSid - The sid to hash.
    
Return Value

    ULONG hash value.
    
--*/

{
    ULONG HashValue = 0;
    ULONG i;
    ULONG Length = RtlLengthSid(pSid);
    
    for (i = 0; i < Length; i++) 
    {
        HashValue += ((PUCHAR)pSid)[i];
    }
    
    HashValue %= PER_USER_AUDITING_POLICY_TABLE_SIZE;
    return HashValue;
}


NTSTATUS
LsapAdtQueryPerUserAuditing(
    IN     PSID                pInputSid,
    OUT    PTOKEN_AUDIT_POLICY pPolicy,
    IN OUT PULONG              pLength,
    OUT    PBOOLEAN            bFound   
    )

/*++

Routine Description

    This routine returns a copy of the current policy active for the
    passed in SID.  
    
Arguments

    pInputSid - the sid to query
    
    pPolicy - pointer to memory that will be filled in with the policy setting.

    pLength - Specifies the size of the passed buffer.  Will be filled in with the
              needed length in case of insufficient buffer.
    
    bFound - boolean indicating if the InputSid has a policy in the table
    
Return Value

    Appropriate NTSTATUS value.
    
--*/

{
    ULONG                      HashValue;
    NTSTATUS                   Status         = STATUS_SUCCESS;
    BOOLEAN                    bSuccess;
    PPER_USER_AUDITING_ELEMENT pTableElement;
    BOOLEAN                    bLock          = FALSE;

    *bFound = FALSE;

    bSuccess = LsapAdtAcquirePerUserPolicyTableReadLock();

    ASSERT(bSuccess);

    if (!bSuccess) 
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
    
    bLock = TRUE;
    
    if (0 == LsapAdtPerUserAuditUserCount)
    {
        goto Cleanup;
    }

    HashValue     = LsapAdtHashPerUserAuditing(pInputSid);
    pTableElement = LsapAdtPerUserAuditingTable[HashValue];

    while (pTableElement) 
    {
        if (RtlEqualSid(
                pInputSid, 
                pTableElement->pSid
                )) 
        {
            //
            // We have found the desired element in the policy table.
            //

            if (*pLength < PER_USER_AUDITING_POLICY_SIZE(&pTableElement->TokenAuditPolicy))
            {
                *pLength = PER_USER_AUDITING_POLICY_SIZE(&pTableElement->TokenAuditPolicy);
                Status   = STATUS_BUFFER_TOO_SMALL;
                goto Cleanup;
            }

            *pLength = PER_USER_AUDITING_POLICY_SIZE(&pTableElement->TokenAuditPolicy);

            RtlCopyMemory(
                pPolicy, 
                &pTableElement->TokenAuditPolicy, 
                *pLength
                );

            *bFound = TRUE;
            goto Cleanup;
        } 
        else
        {
            pTableElement = pTableElement->Next;
        }
#if DBG
        //
        // Simple test for a loop in the linked list.
        //

        if (pTableElement == LsapAdtPerUserAuditingTable[HashValue])
        {
            ASSERT(L"LsapAdtPerUserAuditingTable is messed up." && FALSE);
        }
#endif
    }

Cleanup:

    if (bLock)
    {
        LsapAdtReleasePerUserPolicyTableLock();
    }

    return Status;
}


NTSTATUS
LsapAdtFilterAdminPerUserAuditing(
    IN     HANDLE              hToken,
    IN OUT PTOKEN_AUDIT_POLICY pPolicy
    )

/*++

Routine Description

    This routine decides if the registered policy for the (administrator) user is legitimate.
    An administrator cannot have a policy which excludes him from auditing.  This routine
    verifies that the policy does not do this.
    
Arguments

    hToken - handle to the user's token.
    
    pPolicy - a copy of the policy that will be set on the token.
    
Return Value

    Appropriate NTSTATUS value.
    
--*/

{
    BOOL     bMember;
    BOOL     b;
    ULONG    i;
    HANDLE   hDupToken = NULL;
    NTSTATUS Status    = STATUS_SUCCESS;

    ASSERT(hToken && "hToken should not be NULL here.\n");

    //
    // hToken is a PrimaryToken; to call CheckTokenMembership we need
    // an impersonation token.
    //

    b = DuplicateTokenEx(
            hToken,
            TOKEN_QUERY | TOKEN_IMPERSONATE,
            NULL,
            SecurityImpersonation,
            TokenImpersonation,
            &hDupToken
            );

    if (!b)
    {
        ASSERT(L"DuplicateTokenEx failed in LsapAdtFilterAdminPerUserAuditing" && FALSE);
        Status = LsapWinerrorToNtStatus(GetLastError());
        goto Cleanup;
    }

    b = CheckTokenMembership(
            hDupToken, 
            WellKnownSids[LsapAliasAdminsSidIndex].Sid, 
            &bMember
            );

    if (!b) 
    {
        ASSERT(L"CheckTokenMembership failed in LsapAdtFilterAdminPerUserAuditing" && FALSE);
        Status = LsapWinerrorToNtStatus(GetLastError());
        goto Cleanup;
    }

    // 
    // If the token is an administrator then strip out all exclude bits.  
    //
    
    if (bMember) 
    {
        for (i = 0; i < pPolicy->PolicyCount; i++) 
        {
            pPolicy->Policy[i].PolicyMask &= ~(TOKEN_AUDIT_SUCCESS_EXCLUDE | TOKEN_AUDIT_FAILURE_EXCLUDE);
        }
    }

Cleanup:

    if (hDupToken)
    {
        NtClose(hDupToken);
    }
    return Status; 
}


NTSTATUS
LsapAdtConstructPolicyPerUserAuditing(
    IN     ULONGLONG           RawPolicy,
    OUT    PTOKEN_AUDIT_POLICY pTokenPolicy,
    IN OUT PULONG              TokenPolicyLength
    )

/*++

Routine Description

    This constructs a policy appropriate for passing to NtSetTokenInformation. 
    It converts the raw registry policy into a TOKEN_AUDIT_POLICY.
    
Arguments

    RawPolicy - a 64 bit quantity describing a user's audit policy settings.
    
    pTokenPolicy - points to memory that receives a more presentable form of the RawPolicy.
    
    TokenPolicyLength - The length of the pTokenPolicy buffer.  Receives the necessary length
                        in the case that the buffer is insufficient.

Return Value

    Appropriate NTSTATUS value.

--*/

{
    ULONG i;
    ULONG j;
    ULONG PolicyBits;
    ULONG CategoryCount;
    ULONG LengthNeeded;

    //
    // First calculate the number of category settings in the RawPolicy
    // This will reveal if we have enough space to construct the pTokenPolicy.
    //

    for (CategoryCount = 0, i = 0; i < POLICY_AUDIT_EVENT_TYPE_COUNT; i++) 
    {
        if ((RawPolicy >> (4 * i)) & VALID_AUDIT_POLICY_BITS) 
        {
            CategoryCount++;
        }
#if DBG
    if (LsapAdtDebugPup)
    {
        DbgPrint("0x%I64x >> %d & 0x%x == 0x%x\n", RawPolicy, 4*i, VALID_AUDIT_POLICY_BITS, 
                 (RawPolicy >> (4 * i)) & VALID_AUDIT_POLICY_BITS);
    }
#endif
    }

    LengthNeeded = PER_USER_AUDITING_POLICY_SIZE_BY_COUNT(CategoryCount);

    //
    // Check if the passed buffer is large enough.
    //

    if (*TokenPolicyLength < LengthNeeded)
    {
        ASSERT(L"The buffer should always be big enough!" && FALSE);
        *TokenPolicyLength = LengthNeeded;
        return STATUS_BUFFER_TOO_SMALL;
    }

    *TokenPolicyLength = LengthNeeded;

    //
    // Build the policy.
    //

    pTokenPolicy->PolicyCount = CategoryCount;

    for (j = 0, i = 0; i < POLICY_AUDIT_EVENT_TYPE_COUNT; i++) 
    {
        PolicyBits = (ULONG)((RawPolicy >> (4 * i)) & VALID_AUDIT_POLICY_BITS);
        
        if (PolicyBits) 
        {
            pTokenPolicy->Policy[j].Category   = i;
            pTokenPolicy->Policy[j].PolicyMask = PolicyBits;
            j++;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
LsapAdtStorePolicyByLuidPerUserAuditing(
    IN PLUID pLogonId,
    IN PTOKEN_AUDIT_POLICY pPolicy
    )

/*++

Routine Description

    This routine stores a copy of the user's audit policy in a table
    referenced by the LogonId.
    
Arguments

    pLogonId - the user's logon id.  This will be used as the key for 
        subsequent lookups of the policy.
    
    pPolicy - a pointer to the policy to store.
    
Return Value

    Appropriate NTSTATUS value.
    
--*/

{
    ULONG                                 Index;
    NTSTATUS                              Status       = STATUS_SUCCESS;
    BOOLEAN                               bSuccess;
    BOOLEAN                               bLock        = FALSE;
    PPER_USER_AUDITING_LUID_QUERY_ELEMENT pLuidElement = NULL;

    bSuccess = LsapAdtAcquirePerUserLuidTableWriteLock();

    ASSERT(bSuccess);

    if (!bSuccess) 
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    bLock        = TRUE;
    Index        = LsapAdtLuidIndexPerUserAuditing(pLogonId);
    pLuidElement = LsapAllocateLsaHeap(sizeof(PER_USER_AUDITING_LUID_QUERY_ELEMENT));

    if (NULL == pLuidElement) 
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize the LuidElement.
    //

    RtlCopyLuid(
        &pLuidElement->Luid,
        pLogonId
        );

    RtlCopyMemory(
        &pLuidElement->Policy,
        pPolicy,
        PER_USER_AUDITING_POLICY_SIZE(pPolicy)
        );

    //
    // Place it in the table.
    //

    pLuidElement->Next = LsapAdtPerUserAuditingLuidTable[Index];
    LsapAdtPerUserAuditingLuidTable[Index] = pLuidElement;
    
Cleanup:

    if (bLock)
    {
        LsapAdtReleasePerUserLuidTableLock();
    }

    if (!NT_SUCCESS(Status) && pLuidElement)
    {
        LsapFreeLsaHeap(pLuidElement);
    }

    return Status;
}


NTSTATUS
LsapAdtQueryPolicyByLuidPerUserAuditing(
    IN     PLUID               pLogonId,
    OUT    PTOKEN_AUDIT_POLICY pPolicy,
    IN OUT PULONG              pLength,
    OUT    PBOOLEAN            bFound
    )

/*++

Routine Description

    This finds the policy associated with the passed LogonId.

Arguments

    pLogonId - the key for the policy query.

    pPolicy - memory that receives the policy.

    pLength - Specifies the size of the passed buffer.  Will be filled in with the
              needed length in case of insufficient buffer.

    bFound - boolean return indicating if policy is present.

Return Value

    Appropriate NTSTATUS value.

--*/

{
    ULONG                                 Index;
    ULONG                                 PolicySize;
    NTSTATUS                              Status        = STATUS_SUCCESS;
    BOOLEAN                               bSuccess;
    BOOLEAN                               bLock         = FALSE;
    PPER_USER_AUDITING_LUID_QUERY_ELEMENT pLuidElement;

    *bFound = FALSE;

    bSuccess = LsapAdtAcquirePerUserLuidTableReadLock();

    ASSERT(bSuccess);

    if (!bSuccess) 
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    bLock        = TRUE;
    Index        = LsapAdtLuidIndexPerUserAuditing(pLogonId);
    pLuidElement = LsapAdtPerUserAuditingLuidTable[Index];

    while (pLuidElement) 
    {
        if (RtlEqualLuid(
                &pLuidElement->Luid, 
                pLogonId
                )) 
        {
            if (*pLength < PER_USER_AUDITING_POLICY_SIZE(&pLuidElement->Policy))
            {
                *pLength = PER_USER_AUDITING_POLICY_SIZE(&pLuidElement->Policy);
                Status   = STATUS_BUFFER_TOO_SMALL;
                goto Cleanup;
            }

            *pLength = PER_USER_AUDITING_POLICY_SIZE(&pLuidElement->Policy);

            RtlCopyMemory(
                pPolicy,
                &pLuidElement->Policy,
                *pLength
                );

            *bFound = TRUE;
            Status  = STATUS_SUCCESS;
            goto Cleanup;
        }
        pLuidElement = pLuidElement->Next;
    }

Cleanup:

    if (bLock)
    {
        LsapAdtReleasePerUserLuidTableLock();
    }

    return Status;
}


NTSTATUS
LsapAdtRemoveLuidQueryPerUserAuditing(
    IN PLUID pLogonId
    )

/*++

Routine Description

    Remove a LUID query element from the LUID table.

Arguments

    pLogonId - key to the element to remove.
    
Return Value

    Appropriate NTSTATUS value.
    
--*/

{
    ULONG                                   Index;
    NTSTATUS                                Status = STATUS_SUCCESS;
    BOOLEAN                                 bSuccess;
    PPER_USER_AUDITING_LUID_QUERY_ELEMENT   pElement;
    PPER_USER_AUDITING_LUID_QUERY_ELEMENT * pPrevious;
    BOOLEAN                                 bLock  = FALSE;
    BOOLEAN                                 bFound = FALSE;

    bSuccess = LsapAdtAcquirePerUserLuidTableWriteLock();
    
    ASSERT(bSuccess);

    if (!bSuccess) 
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    Index     = LsapAdtLuidIndexPerUserAuditing(pLogonId);
    pPrevious = &LsapAdtPerUserAuditingLuidTable[Index];
    pElement  = *pPrevious;


    bLock = TRUE;

    while (pElement) 
    {
        if (RtlEqualLuid(
                &pElement->Luid,
                pLogonId
                )) 
        {
            bFound = TRUE;
            *pPrevious = pElement->Next;
            LsapFreeLsaHeap(pElement);
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }
        pPrevious = &pElement->Next;
        pElement  = *pPrevious;
    }

    if (!bFound)
    {
        Status = STATUS_NOT_FOUND;
    }

Cleanup:

    if (bLock)
    {
        LsapAdtReleasePerUserLuidTableLock();
    }

    return Status;
}


DWORD 
LsapAdtKeyNotifyStubPerUserAuditing(
    LPVOID Ignore
    )

/*++

Routine Description:

    This routine is called when the LsapAdtPerUserKeyEvent is signalled.  This happens
    when LsapAdtPerUserKey is changed.  This routine will set the LsapAdtPerUserKeyTimer
    to signal in 5 seconds.
    
Arguments:

    None.
    
Return Value:

    Appropriate WINERROR value.
    
--*/

{
    LARGE_INTEGER Time = {0};
    BOOL b;
    DWORD dwError = ERROR_SUCCESS;

    //
    // Set timer for 5 seconds from now.
    //

    Time.QuadPart = -50000000;
    
    b = SetWaitableTimer(
            LsapAdtPerUserKeyTimer, 
            &Time, 
            0, 
            NULL, 
            NULL, 
            0);

    if (!b)
    {
        ASSERT("SetWaitableTimer failed" && FALSE);
        dwError = GetLastError();
    }

    return dwError;
}


DWORD
LsapAdtKeyNotifyFirePerUserAuditing(
    LPVOID Ignore
    )

/*+

Routine Description:

    This function is called to rebuild the per user table.
    
Arguments:

    None.
    
Return Value:

    Appropriate DWORD error.
    
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN bLock = FALSE;
    BOOLEAN bSuccess;
    DWORD dwError = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(Ignore);

#if DBG
    if (LsapAdtDebugPup)
    {
        DbgPrint("LsapAdtPerUserKey modified.  LsapAdtKeyNotifyFirePerUserAuditing is rebuilding Table.\n");
    }
#endif    

    bSuccess = LsapAdtAcquirePerUserPolicyTableWriteLock();

    ASSERT(bSuccess);

    if (!bSuccess) 
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    bLock = TRUE;

    //
    // Free the pup table, then call Init to reconstruct it.
    //

    LsapAdtFreeTablePerUserAuditing();

    Status = LsapAdtConstructTablePerUserAuditing();

    ASSERT(NT_SUCCESS(Status));

Cleanup:

    if (bLock)
    {
        LsapAdtReleasePerUserPolicyTableLock();
    }

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed(Status);
    }

    return RtlNtStatusToDosError(Status);
}


NTSTATUS
LsapAdtLogonPerUserAuditing(
    PSID pSid,
    PLUID pLogonId,
    HANDLE hToken
    )

/*++

Routine Description:

    This code should be called when a user is logged on. It sets the per 
    user auditing policy onto the newly logged on user's token and stores
    the logon into the LUID table.

Arguments:

    pSid - Sid of user.
    pLogonId - Logon ID of user.
    hToken - handle to token of user.

Return Value:

    Appropriate NTSTATUS value.

--*/

{

    ULONG i;
    PPER_USER_AUDITING_ELEMENT pPerUserAuditingPolicy = NULL;
    UCHAR PolicyBuffer[PER_USER_AUDITING_MAX_POLICY_SIZE];
    ULONG PolicyLength = sizeof(PolicyBuffer);
    PTOKEN_AUDIT_POLICY pPolicy = (PTOKEN_AUDIT_POLICY) PolicyBuffer;
    BOOLEAN bFound = FALSE;
    NTSTATUS Status;
    TOKEN_AUDIT_POLICY EmptyPolicy = {0};

    //
    // If it is a local system logon then bail out early.  Per user
    // settings cannot exist for local system.
    //

    if (RtlEqualSid(
            pSid,
            LsapLocalSystemSid
            ))
    {
        return STATUS_SUCCESS;
    }

    Status = LsapAdtQueryPerUserAuditing(
                 pSid,
                 pPolicy,
                 &PolicyLength,
                 &bFound
                 );

    ASSERT(NT_SUCCESS(Status));

    if (NT_SUCCESS(Status))
    {
        if (bFound)
        {
            //
            // Filter out any exclude bits if this user is an administrator.
            //

            Status = LsapAdtFilterAdminPerUserAuditing(
                         hToken,
                         pPolicy
                         );

            ASSERT(L"LsapAdtFilterAdminPerUserAuditing failed." && NT_SUCCESS(Status));
        }
        else
        {
            //
            // If there is no policy settings for the user then apply
            // a blank policy.  This is required so that no policy may
            // be applied to this token in the future.
            //

            pPolicy = &EmptyPolicy;
            PolicyLength = sizeof(EmptyPolicy);
        }

        if (NT_SUCCESS(Status)) 
        {
            Status = NtSetInformationToken(
                         hToken,
                         TokenAuditPolicy,
                         pPolicy,
                         PolicyLength
                         );

            ASSERT(L"NtSetInformationToken failed" && NT_SUCCESS(Status));
            
            //
            // Only store the policy in the LUID table if it is the nonempty policy.
            //

            if (NT_SUCCESS(Status) && bFound) 
            {
                LsapAdtLogonCountersPerUserAuditing(pPolicy);

                Status = LsapAdtStorePolicyByLuidPerUserAuditing(
                             pLogonId,
                             pPolicy
                             );

                ASSERT(L"LsapAdtStorePolicyByLuidPerUserAuditing failed." && NT_SUCCESS(Status));
            }
        }
    }

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed(Status);
    }

    return Status;
}


VOID
LsapAdtLogonCountersPerUserAuditing(
    PTOKEN_AUDIT_POLICY pPolicy
    )

/*++

Routine Description:

    This helper routine updates counters when a user is logged on with per user settings.
    
Arguments:

    pPolicy - the policy applied to the new logon.
    
Return Value:

    None.
    
--*/

{
    ULONG i;

    if (pPolicy->PolicyCount)
    {
        InterlockedIncrement(&LsapAdtPerUserAuditLogonCount);
    }
    
    for (i = 0; i < pPolicy->PolicyCount; i++) 
    {
        //
        // for the hint array only increment if the policy causes an inclusion of some audit
        // category.
        //

        if (pPolicy->Policy[i].PolicyMask & (TOKEN_AUDIT_SUCCESS_INCLUDE | TOKEN_AUDIT_FAILURE_INCLUDE))
        {
            InterlockedIncrement(&LsapAdtPerUserAuditHint[pPolicy->Policy[i].Category]);
        }
    }
}


VOID
LsapAdtLogoffCountersPerUserAuditing(
    PTOKEN_AUDIT_POLICY pPolicy
    )

/*++

Routine Description:

    This modifies the per user counters to reflect a user logoff.
    
Arguments:

    pPolicy - the policy that was applied to the logged off user.
    
Return Value:

    None.

--*/

{
    ULONG i;

    if (pPolicy->PolicyCount)
    {
        InterlockedDecrement(&LsapAdtPerUserAuditLogonCount);
    }

    for (i = 0; i < pPolicy->PolicyCount; i++) 
    {
        if (pPolicy->Policy[i].PolicyMask & (TOKEN_AUDIT_SUCCESS_INCLUDE | TOKEN_AUDIT_FAILURE_INCLUDE))
        {
            InterlockedDecrement(&LsapAdtPerUserAuditHint[pPolicy->Policy[i].Category]);
        }
    }
}

NTSTATUS
LsapAdtLogoffPerUserAuditing(
    PLUID pLogonId
    )

/**

Routine Description:

    This code frees up any memory and adjusts counters for when a user has 
    logged off the machine.

Arguments:

    pLogonId - the logon id of the user

Return Value:

    NTSTATUS.

**/

{
    UCHAR Buffer[PER_USER_AUDITING_MAX_POLICY_SIZE];
    ULONG Length = sizeof(Buffer);
    PTOKEN_AUDIT_POLICY pPolicy = (PTOKEN_AUDIT_POLICY) Buffer;
    BOOLEAN bFound = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // This code is necessary to maintain an accurate count of the sessions with per user audit settings
    // that are active in the system.
    //

    if (LsapAdtPerUserAuditLogonCount) 
    {

        Status = LsapAdtQueryPolicyByLuidPerUserAuditing(
                     pLogonId,
                     pPolicy,
                     &Length,
                     &bFound
                     );

        if (NT_SUCCESS(Status) && bFound) 
        {

            LsapAdtLogoffCountersPerUserAuditing(
                pPolicy
                );

            Status = LsapAdtRemoveLuidQueryPerUserAuditing(
                         pLogonId
                         );

            ASSERT(NT_SUCCESS(Status));
        }
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtmarshal.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtmarshal.c

Abstract:

    Functions (de)marshalling of audit parameters

Author:

    16-August-2000  kumarp

--*/

#include <lsapch2.h>
#include "adtp.h"
#include "adtutil.h"
#include "adtdebug.h"

extern HANDLE LsapAdtLogHandle;
extern ULONG LsapAdtSuccessCount;


NTSTATUS
LsapAdtDemarshallAuditInfo(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    )

/*++

Routine Description:

    This routine will walk down a marshalled audit parameter
    array and unpack it so that its information may be passed
    into the event logging service.

    Three parallel data structures are maintained:

    StringArray - Array of Unicode string structures.  This array
    is used primarily as temporary storage for returned string
    structures.

    StringPointerArray - Array of pointers to Unicode string structures.

    FreeWhenDone - Array of booleans describing how to dispose of each
    of the strings pointed to by the StringPointerArray.


    Note that entries in the StringPointerArray are contiguous, but that
    there may be gaps in the StringArray structure.  For each entry in the
    StringPointerArray there will be a corresponding entry in the FreeWhenDone
    array.  If the entry for a particular string is TRUE, the storage for
    the string buffer will be released to the process heap.



      StringArray
                                       Other strings
    +----------------+
    |                |<-----------+  +----------------+
    |                |            |  |                |<-------------------+
    +----------------+            |  |                |                    |
    |    UNUSED      |            |  +----------------+                    |
    |                |            |                                        |
    +----------------+            |                                        |
    |                |<------+    |  +----------------+                    |
    |                |       |    |  |                |<-----------+       |
    +----------------+       |    |  |                |            |       |
    |    UNUSED      |       |    |  +----------------+            |       |
    |                |       |    |                                |       |
    +----------------+       |    |                                |       |
    |                |<--+   |    |                                |       |
    |                |   |   |    |                                |       |
    +----------------+   |   |    |                                |       |
    |                |   |   |    |                                |       |
    |                |   |   |    |     StringPointerArray         |       |
          ....           |   |    |                                |       |
                         |   |    |     +----------------+         |       |
                         |   |    +-----|                |         |       |
                         |   |          +----------------+         |       |
                         |   |          |                |---------+       |
                         |   |          +----------------+                 |
                         |   +----------|                |                 |
                         |              +----------------+                 |
                         |              |                |-----------------+
                         |              +----------------+
                         +--------------|                |
                                        +----------------+
                                        |                |
                                        +----------------+
                                        |                |
                                        +----------------+
                                        |                |
                                              ....


Arguments:

    AuditParameters - Receives a pointer to an audit
        parameters array in self-relative form.

Return Value:


--*/

{

    ULONG ParameterCount;
    USHORT i;
    PUNICODE_STRING StringPointerArray[SE_MAX_AUDIT_PARAM_STRINGS];
    UNICODE_STRING NewObjectTypeName;
    ULONG NewObjectTypeStringIndex = 0;
    BOOLEAN FreeWhenDone[SE_MAX_AUDIT_PARAM_STRINGS];
    UNICODE_STRING StringArray[SE_MAX_AUDIT_PARAM_STRINGS];
    USHORT StringIndexArray[SE_MAX_AUDIT_PARAM_STRINGS];
    USHORT StringIndex = 0;
    UNICODE_STRING DashString;
    BOOLEAN FreeDash;
    NTSTATUS Status;
    PUNICODE_STRING SourceModule;
    PSID UserSid;
    ULONG AuditId;
    GUID NullGuid = { 0 };

    AuditId = AuditParameters->AuditId;

    //
    // In w2k several events were introduced as explicit sucess/failure
    // cases. In whistler, we corrected this by folding each these event
    // pairs into a single event. We have retained the old failure event
    // schema so that anybody viewing w2k events from a whistler
    // machine can view them correctly.
    //
    // However, assert that we are not generating these events.
    //
    ASSERT((AuditId != SE_AUDITID_ADD_SID_HISTORY_FAILURE) &&
           (AuditId != SE_AUDITID_AS_TICKET_FAILURE)       &&
           (AuditId != SE_AUDITID_ACCOUNT_LOGON_FAILURE)   &&
           (AuditId != SE_AUDITID_ACCOUNT_NOT_MAPPED)      &&
           (AuditId != SE_AUDITID_TGS_TICKET_FAILURE));

    //
    // Initialization.
    //

    RtlZeroMemory( StringPointerArray, sizeof(StringPointerArray) );
    RtlZeroMemory( StringIndexArray, sizeof(StringIndexArray) );
    RtlZeroMemory( StringArray, sizeof(StringArray) );
    RtlZeroMemory( FreeWhenDone, sizeof(FreeWhenDone) );

    RtlInitUnicodeString( &NewObjectTypeName, NULL );

    Status = LsapAdtBuildDashString(
                 &DashString,
                 &FreeDash
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    ParameterCount = AuditParameters->ParameterCount;

    //
    // Parameter 0 will always be the user SID.  Convert the
    // offset to the SID into a pointer.
    //

    ASSERT( AuditParameters->Parameters[0].Type == SeAdtParmTypeSid );



    UserSid =      (PSID)AuditParameters->Parameters[0].Address;



    //
    // Parameter 1 will always be the Source Module (or Subsystem Name).
    // Unpack this now.
    //

    ASSERT( AuditParameters->Parameters[1].Type == SeAdtParmTypeString );



    SourceModule = (PUNICODE_STRING)AuditParameters->Parameters[1].Address;


    for (i=2; i<ParameterCount; i++) {
        StringIndexArray[i] = StringIndex;

        switch ( AuditParameters->Parameters[i].Type ) {
            //
            // guard against somebody adding a new param type and not
            // adding appropriate code here.
            //
            default:
                ASSERT( FALSE && L"LsapAdtDemarshallAuditInfo: unknown param type");
                break;
                
            case SeAdtParmTypeNone:
                {
                    StringPointerArray[StringIndex] = &DashString;

                    FreeWhenDone[StringIndex] = FALSE;

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeString:
                {
                    StringPointerArray[StringIndex] =
                        (PUNICODE_STRING)AuditParameters->Parameters[i].Address;

                    FreeWhenDone[StringIndex] = FALSE;

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeFileSpec:
                {
                    //
                    // Same as a string, except we must attempt to replace
                    // device information with a drive letter.
                    //

                    StringPointerArray[StringIndex] =
                        (PUNICODE_STRING)AuditParameters->Parameters[i].Address;


                    //
                    // This may not do anything, in which case just audit what
                    // we have.
                    //

                    LsapAdtSubstituteDriveLetter( StringPointerArray[StringIndex] );

                    FreeWhenDone[StringIndex] = FALSE;

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeUlong:
                {
                    ULONG Data;

                    Data = (ULONG) AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildUlongString(
                                 Data,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeHexUlong:
                {
                    ULONG Data;

                    Data = (ULONG) AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildHexUlongString(
                                 Data,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeSid:
                {
                    PSID Sid;

                    Sid = (PSID)AuditParameters->Parameters[i].Address;

                    Status = LsapAdtBuildSidString(
                                 Sid,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];

                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;


                    break;
                }

            case SeAdtParmTypeLuid:
                {
                    PLUID Luid;

                    Luid = (PLUID)(&AuditParameters->Parameters[i].Data[0]);
                    
                    Status = LsapAdtBuildLuidString( 
                                 Luid, 
                                 &StringArray[ StringIndex ], 
                                 &FreeWhenDone[ StringIndex ]
                                 );

                    if ( NT_SUCCESS( Status )) {

                            StringPointerArray[StringIndex] = &StringArray[StringIndex];
                            StringIndex++;
                    } else {

                        goto Cleanup;
                    }

                    //
                    // Finished, break out to surrounding loop.
                    //

                    break;
                }

            case SeAdtParmTypeLogonId:
                {
                    PLUID LogonId;
                    ULONG j;

                    LogonId = (PLUID)(&AuditParameters->Parameters[i].Data[0]);

                    Status = LsapAdtBuildLogonIdStrings(
                                 LogonId,
                                 &StringArray [ StringIndex     ],
                                 &FreeWhenDone[ StringIndex     ],
                                 &StringArray [ StringIndex + 1 ],
                                 &FreeWhenDone[ StringIndex + 1 ],
                                 &StringArray [ StringIndex + 2 ],
                                 &FreeWhenDone[ StringIndex + 2 ]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        for (j=0; j<3; j++) {

                            StringPointerArray[StringIndex] = &StringArray[StringIndex];
                            StringIndex++;
                        }

                        //
                        // Finished, break out to surrounding loop.
                        //

                        break;

                    } else {

                        goto Cleanup;
                    }
                    break;
                }
            case SeAdtParmTypeNoLogonId:
                {
                    ULONG j;
                    //
                    // Create three "-" strings.
                    //

                    for (j=0; j<3; j++) {

                        StringPointerArray[ StringIndex ] = &DashString;
                        FreeWhenDone[ StringIndex ] = FALSE;
                        StringIndex++;
                    }

                    break;
                }
            case SeAdtParmTypeAccessMask:
                { 
                    PUNICODE_STRING ObjectTypeName;
                    ULONG ObjectTypeNameIndex;
                    ACCESS_MASK Accesses;

                    ObjectTypeNameIndex = (ULONG) AuditParameters->Parameters[i].Data[1];

                    //
                    // the parameter that denotes the object's type must
                    // have been specified earlier and must be a string.
                    //

                    if ((ObjectTypeNameIndex >= i) ||
                        (AuditParameters->Parameters[ObjectTypeNameIndex].Type !=
                        SeAdtParmTypeString)) {

                        Status = STATUS_INVALID_PARAMETER;
                        goto Cleanup;
                    }
                    
                    ObjectTypeName = AuditParameters->Parameters[ObjectTypeNameIndex].Address;
                    Accesses = (ACCESS_MASK) AuditParameters->Parameters[i].Data[0];

                    //
                    // We can determine the index to the ObjectTypeName
                    // parameter since it was stored away in the Data[1]
                    // field of this parameter.
                    //

                    Status = LsapAdtBuildAccessesString(
                                SourceModule,
                                ObjectTypeName,
                                Accesses,
                                TRUE,
                                &StringArray [ StringIndex ],
                                &FreeWhenDone[ StringIndex ]
                                );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[ StringIndex ] = &StringArray[ StringIndex ];

                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypePrivs:
                {

                    PPRIVILEGE_SET Privileges = (PPRIVILEGE_SET)AuditParameters->Parameters[i].Address;

                    Status = LsapBuildPrivilegeAuditString(
                                 Privileges,
                                 &StringArray [ StringIndex ],
                                 &FreeWhenDone[ StringIndex ]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[ StringIndex ] = &StringArray[ StringIndex ];

                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeTime:
                {
                    PLARGE_INTEGER pTime;

                    pTime = (PLARGE_INTEGER) &AuditParameters->Parameters[i].Data[0];

                    //
                    // First build a date string.
                    //

                    Status = LsapAdtBuildDateString(
                                 pTime,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    //
                    // Now build a time string.
                    //

                    Status = LsapAdtBuildTimeString(
                                 pTime,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeDuration:
                {
                    PLARGE_INTEGER pDuration;

                    pDuration = (PLARGE_INTEGER) &AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildDurationString(
                                 pDuration,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status ))
                    {
                        StringPointerArray[StringIndex] = &StringArray[StringIndex];
                    }
                    else
                    {
                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeObjectTypes:
                {
                    PUNICODE_STRING ObjectTypeName;
                    ULONG ObjectTypeNameIndex;
                    PSE_ADT_OBJECT_TYPE ObjectTypeList;
                    ULONG ObjectTypeCount;
                    ULONG j;

                    ObjectTypeNameIndex = (ULONG) AuditParameters->Parameters[i].Data[1];
                    //
                    // the parameter that denotes the object's type must
                    // have been specified earlier and must be a string.
                    //

                    if ((ObjectTypeNameIndex >= i) ||
                        (AuditParameters->Parameters[ObjectTypeNameIndex].Type !=
                         SeAdtParmTypeString)) {

                        Status = STATUS_INVALID_PARAMETER;
                        goto Cleanup;
                    }
                    
                    NewObjectTypeStringIndex = StringIndexArray[ObjectTypeNameIndex];
                    ObjectTypeName = AuditParameters->Parameters[ObjectTypeNameIndex].Address;
                    ObjectTypeList = AuditParameters->Parameters[i].Address;
                    ObjectTypeCount = AuditParameters->Parameters[i].Length / sizeof(SE_ADT_OBJECT_TYPE);

                    //
                    // Will Fill in 10 entries.
                    //

                    (VOID) LsapAdtBuildObjectTypeStrings(
                               SourceModule,
                               ObjectTypeName,
                               ObjectTypeList,
                               ObjectTypeCount,
                               &StringArray [ StringIndex ],
                               &FreeWhenDone[ StringIndex ],
                               &NewObjectTypeName
                               );

                    for (j=0; j < LSAP_ADT_OBJECT_TYPE_STRINGS; j++) {
                        StringPointerArray[StringIndex] = &StringArray[StringIndex];
                        StringIndex++;
                    }


                    //
                    //
                    // &StringArray [ StringIndexArray[ObjectTypeNameIndex]],
                    // &FreeWhenDone[ StringIndexArray[ObjectTypeNameIndex]],

                    //
                    // Finished, break out to surrounding loop.
                    //

                    break;
                }
            case SeAdtParmTypePtr:
                {
                    PVOID Data;

                    Data = (PVOID) AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildPtrString(
                                 Data,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeGuid:
                {
                    LPGUID pGuid;

                    pGuid = (LPGUID)AuditParameters->Parameters[i].Address;

                    //
                    // check for NULL guid
                    //

                    if ( pGuid && memcmp( pGuid, &NullGuid, sizeof(GUID)))
                    {
                        //
                        // generate a string GUID only for non-NULL guids
                        //

                        Status = LsapAdtBuildGuidString(
                                     pGuid,
                                     &StringArray[StringIndex],
                                     &FreeWhenDone[StringIndex]
                                     );

                        if ( NT_SUCCESS( Status )) {

                            StringPointerArray[StringIndex] = &StringArray[StringIndex];

                        } else {

                            goto Cleanup;
                        }
                    }
                    else
                    {
                        //
                        // for NULL guids, display a '-' string
                        //

                        StringPointerArray[StringIndex] = &DashString;
                        FreeWhenDone[StringIndex] = FALSE;
                    }

                    StringIndex++;
                    break;
                }
            case SeAdtParmTypeHexInt64:
                {
                    PULONGLONG pData;

                    pData = (PULONGLONG) AuditParameters->Parameters[i].Data;

                    Status = LsapAdtBuildHexInt64String(
                                 pData,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if (NT_SUCCESS(Status))
                    {
                        StringPointerArray[StringIndex] = &StringArray[StringIndex];
                    }
                    else
                    {
                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeStringList:
                {
                    PLSA_ADT_STRING_LIST pList = (PLSA_ADT_STRING_LIST)AuditParameters->Parameters[i].Address;

                    Status = LsapAdtBuildStringListString(
                                 pList,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if (NT_SUCCESS(Status))
                    {
                        StringPointerArray[StringIndex] = &StringArray[StringIndex];
                    }
                    else
                    {
                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeSidList:
                {
                    PLSA_ADT_SID_LIST pList = (PLSA_ADT_SID_LIST)AuditParameters->Parameters[i].Address;

                    Status = LsapAdtBuildSidListString(
                                 pList,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if (NT_SUCCESS(Status))
                    {
                        StringPointerArray[StringIndex] = &StringArray[StringIndex];
                    }
                    else
                    {
                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeUserAccountControl:
                {
                    ULONG j;

                    Status = LsapAdtBuildUserAccountControlString(
                                (ULONG)(AuditParameters->Parameters[i].Data[0]),    // old uac value
                                (ULONG)(AuditParameters->Parameters[i].Data[1]),    // new uac value
                                 &StringArray [ StringIndex     ],
                                 &FreeWhenDone[ StringIndex     ],
                                 &StringArray [ StringIndex + 1 ],
                                 &FreeWhenDone[ StringIndex + 1 ],
                                 &StringArray [ StringIndex + 2 ],
                                 &FreeWhenDone[ StringIndex + 2 ]
                                 );

                    if (NT_SUCCESS(Status))
                    {
                        for (j=0;j < 3;j++)
                        {
                            StringPointerArray[StringIndex] = &StringArray[StringIndex];
                            StringIndex++;
                        }
                    }
                    else
                    {
                        goto Cleanup;
                    }

                    break;
                }
            case SeAdtParmTypeNoUac:
                {
                    ULONG j;

                    for (j=0;j < 3;j++)
                    {
                        StringPointerArray[ StringIndex ] = &DashString;
                        FreeWhenDone[ StringIndex ] = FALSE;
                        StringIndex++;
                    }

                    break;
                }
            case SeAdtParmTypeMessage:
                {
                    ULONG MessageId = (ULONG)AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildMessageString(
                                MessageId,
                                &StringArray[StringIndex],
                                &FreeWhenDone[StringIndex]
                                );

                    if (NT_SUCCESS(Status))
                    {
                        StringPointerArray[StringIndex] = &StringArray[StringIndex];
                    }
                    else
                    {
                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeDateTime:
                {
                    PLARGE_INTEGER pTime;

                    pTime = (PLARGE_INTEGER)&AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildDateTimeString(
                                 pTime,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if (NT_SUCCESS(Status))
                    {
                        StringPointerArray[StringIndex] = &StringArray[StringIndex];
                    }
                    else
                    {
                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }

            case SeAdtParmTypeSockAddr:
                {
                    PSOCKADDR pSockAddr;

                    pSockAddr = (PSOCKADDR) AuditParameters->Parameters[i].Address;

                    Status = LsapAdtBuildSockAddrString(
                                 pSockAddr,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex],
                                 &StringArray[StringIndex+1],
                                 &FreeWhenDone[StringIndex+1]
                                 );
                    

                    if (NT_SUCCESS(Status))
                    {
                        StringPointerArray[StringIndex] = &StringArray[StringIndex];
                        StringIndex++;

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];
                        StringIndex++;
                    }
                    else
                    {
                        goto Cleanup;
                    }

                    break;
                }
        }
    }

    //
    // If the generic object type name has been converted to something
    //  specific to this audit,
    //  substitute it now.
    //

    if ( NewObjectTypeName.Length != 0 ) {

        //
        // Free the previous object type name.
        //
        if ( FreeWhenDone[NewObjectTypeStringIndex] ) {
            LsapFreeLsaHeap( StringPointerArray[NewObjectTypeStringIndex]->Buffer );
        }

        //
        // Save the new object type name.
        //

        FreeWhenDone[NewObjectTypeStringIndex] = TRUE;
        StringPointerArray[NewObjectTypeStringIndex] = &NewObjectTypeName;

    }

#if DBG

    AdtDebugOut((DEB_AUDIT_STRS, "Cat: %d, Event: %d, %s, UserSid: %p\n",
                 AuditParameters->CategoryId, AuditId,
                 AuditParameters->Type == EVENTLOG_AUDIT_SUCCESS ? "S" : "F",
                 UserSid));
                 
    //
    // do some sanity check on the strings that we pass to ElfReportEventW.
    // If we dont do it here, it will be caught by ElfReportEventW and
    // it will involve more steps in debugger to determine the string
    // at fault. Checking it here saves us that trouble.
    //

    for (i=0; i<StringIndex; i++) {

        PUNICODE_STRING TempString;
        
        TempString = StringPointerArray[i];

        if ( !TempString )
        {
            DbgPrint( "LsapAdtDemarshallAuditInfo: string %d is NULL\n", i );
        }
        else if (!LsapIsValidUnicodeString( TempString ))
        {
            DbgPrint( "LsapAdtDemarshallAuditInfo: invalid string: %d @ %p ('%wZ' [%d / %d])\n",
                      i, TempString,
                      TempString, TempString->Length, TempString->MaximumLength);
            ASSERT( L"LsapAdtDemarshallAuditInfo: invalid string" && FALSE );
        }
        else
        {
            AdtDebugOut((DEB_AUDIT_STRS, "%02d] @ %p ([%d / %d] '%wZ')\n",
                         i, TempString, 
                         TempString->Length, TempString->MaximumLength,
                         TempString));
        }
    }
#endif

    //
    // Probably have to do this from somewhere else eventually, but for now
    // do it from here.
    //

    Status = ElfReportEventW (
                 LsapAdtLogHandle,
                 AuditParameters->Type,
                 (USHORT)AuditParameters->CategoryId,
                 AuditId,
                 UserSid,
                 StringIndex,
                 0,
                 StringPointerArray,
                 NULL,
                 0,
                 NULL,
                 NULL
                 );

    if (NT_SUCCESS(Status))
    {
        //
        // Increment the number of audits successfully
        // written to the log.
        //

        ++LsapAdtSuccessCount;
    }

    //
    // If we are shutting down and we got an expected error back from the
    // eventlog, don't worry about it. This prevents bugchecking from an
    // audit failure while shutting down.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) || (Status == STATUS_UNSUCCESSFUL))
    {
#if DBG
        //
        // During shutdown, sometimes eventlog stops before LSA has a chance
        // to set LsapState.SystemShutdownPending. This causes the assert below.
        // In debug builds, sleep for some time to see if this state
        // variable gets set. This reduces the chance of the assert
        // showing up during shutdown.
        //

        {
            ULONG RetryCount;

            RetryCount = 0;

            //
            // wait upto 60 sec to see if we are shutting down.
            //
 
            while ( !LsapState.SystemShutdownPending && (RetryCount < 60))
            {
                Sleep(1000);
                RetryCount++;
            }
        }
#endif

        if ( LsapState.SystemShutdownPending )
        {
            Status = STATUS_SUCCESS;
        }
    }

 Cleanup:
    
    if ( !NT_SUCCESS(Status) )
    {
#if DBG
        //
        // we do not assert if Status is one of the noisy codes
        // see the macro LsapAdtNeedToAssert for a complete list of codes.
        //

        if (LsapAdtNeedToAssert( Status ))
        {
            DbgPrint( "LsapAdtDemarshallAuditInfo: failed: %x\n", Status );
            DsysAssertMsg( FALSE, "LsapAdtDemarshallAuditInfo: failed" );
        }
#endif

        //
        // If we couldn't log the audit and we are trying to write
        // an 'audit failed' audit, report success to avoid an infinite loop.
        //

        if ( AuditParameters->AuditId == SE_AUDITID_UNABLE_TO_LOG_EVENTS )
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            LsapAuditFailed( Status );
        }
    }
    
    for (i=0; i<StringIndex; i++) {

        if (FreeWhenDone[i]) {
            LsapFreeLsaHeap( StringPointerArray[i]->Buffer );
        }
    }

    return( Status );
}




VOID
LsapAdtNormalizeAuditInfo(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    )

/*++

Routine Description:

    This routine will walk down a marshalled audit parameter
    array and turn it into an Absolute format data structure.


Arguments:

    AuditParameters - Receives a pointer to an audit
        parameters array in self-relative form.

Return Value:

    TRUE on success, FALSE on failure.

--*/

{
    ULONG ParameterCount;
    ULONG i;
    PUNICODE_STRING Unicode;


    if ( !(AuditParameters->Flags & SE_ADT_PARAMETERS_SELF_RELATIVE)) {

        return;
    }

    ParameterCount = AuditParameters->ParameterCount;

    for (i=0; i<ParameterCount; i++) {

        switch ( AuditParameters->Parameters[i].Type ) {
            //
            // guard against somebody adding a new param type and not
            // adding appropriate code here.
            //
            default:
                ASSERT( FALSE && L"LsapAdtNormalizeAuditInfo: unknown param type");
                break;
                
            case SeAdtParmTypeNone:
            case SeAdtParmTypeUlong:
            case SeAdtParmTypeHexUlong:
            case SeAdtParmTypeHexInt64:
            case SeAdtParmTypeTime:
            case SeAdtParmTypeDuration:
            case SeAdtParmTypeLogonId:
            case SeAdtParmTypeNoLogonId:
            case SeAdtParmTypeAccessMask:
            case SeAdtParmTypePtr:
            case SeAdtParmTypeLuid:
            case SeAdtParmTypeUserAccountControl:
            case SeAdtParmTypeNoUac:
            case SeAdtParmTypeMessage:
            case SeAdtParmTypeDateTime:
                {

                    break;
                }
            case SeAdtParmTypeGuid:
            case SeAdtParmTypeSid:
            case SeAdtParmTypePrivs:
            case SeAdtParmTypeObjectTypes:
            case SeAdtParmTypeString:
            case SeAdtParmTypeFileSpec:
            case SeAdtParmTypeSockAddr:
                {
                    PUCHAR Fixup;

                    Fixup = ((PUCHAR) AuditParameters ) +
                                (ULONG_PTR) AuditParameters->Parameters[i].Address ;

                    AuditParameters->Parameters[i].Address = (PVOID) Fixup;

                    if ( (AuditParameters->Parameters[i].Type == SeAdtParmTypeString) ||
                         (AuditParameters->Parameters[i].Type == SeAdtParmTypeFileSpec ) )
                    {
                        //
                        // For the string types, also fix up the buffer pointer
                        // in the UNICODE_STRING
                        //

                        Unicode = (PUNICODE_STRING) Fixup ;
                        Unicode->Buffer = (PWSTR)((PCHAR)Unicode->Buffer + (ULONG_PTR)AuditParameters);
                    }

                    break;
                }

            case SeAdtParmTypeStringList:
                {
                    PCHAR                       pFixup;
                    ULONG                       e;
                    ULONG_PTR                   Delta = (ULONG_PTR)AuditParameters;
                    PLSA_ADT_STRING_LIST        pList;
                    PLSA_ADT_STRING_LIST_ENTRY  pEntry;

                    pFixup = (PCHAR)AuditParameters->Parameters[i].Address;
                    pFixup += Delta;
                    AuditParameters->Parameters[i].Address = (PVOID)pFixup;

                    pList = (PLSA_ADT_STRING_LIST)AuditParameters->Parameters[i].Address;

                    if (pList->cStrings)
                    {
                        pFixup = (PCHAR)pList->Strings;
                        pFixup += Delta;
                        pList->Strings = (PLSA_ADT_STRING_LIST_ENTRY)pFixup;

                        for (
                            e = 0, pEntry = pList->Strings;
                            e < pList->cStrings;
                            e++, pEntry++)
                        {
                            pFixup = (PCHAR)pEntry->String.Buffer;
                            pFixup += Delta;
                            pEntry->String.Buffer = (PWSTR)pFixup;
                        }
                    }
                    else
                    {
                        pList->Strings = 0;
                    }

                    break;
                }

            case SeAdtParmTypeSidList:
                {
                    PCHAR                       pFixup;
                    ULONG                       e;
                    ULONG_PTR                   Delta = (ULONG_PTR)AuditParameters;
                    PLSA_ADT_SID_LIST           pList;
                    PLSA_ADT_SID_LIST_ENTRY     pEntry;

                    pFixup = (PCHAR)AuditParameters->Parameters[i].Address;
                    pFixup += Delta;
                    AuditParameters->Parameters[i].Address = (PVOID)pFixup;

                    pList = (PLSA_ADT_SID_LIST)AuditParameters->Parameters[i].Address;

                    if (pList->cSids)
                    {
                        pFixup = (PCHAR)pList->Sids;
                        pFixup += Delta;
                        pList->Sids = (PLSA_ADT_SID_LIST_ENTRY)pFixup;

                        for (
                            e = 0, pEntry = pList->Sids;
                            e < pList->cSids;
                            e++, pEntry++)
                        {
                            pFixup = (PCHAR)pEntry->Sid;
                            pFixup += Delta;
                            pEntry->Sid = (PSID)pFixup;
                        }
                    }
                    else
                    {
                        pList->Sids = 0;
                    }

                    break;
                }
        }
    }
}




NTSTATUS
LsapAdtMarshallAuditRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters,
    OUT PSE_ADT_PARAMETER_ARRAY *MarshalledAuditParameters
    )

/*++

Routine Description:

    This routine will take an AuditParamters structure and create
    a new AuditParameters structure that is suitable for placing
    to LSA queue.  It will be in self-relative form and allocated as
    a single chunk of memory.

Arguments:


    AuditParameters - A filled in set of AuditParameters to be marshalled.

    MarshalledAuditParameters - Returns a pointer to a block of heap memory
        containing the passed AuditParameters in self-relative form suitable
        for passing to LSA.


Return Value:

    None.

--*/

{
    ULONG i;
    ULONG TotalSize = sizeof( SE_ADT_PARAMETER_ARRAY );
    PUNICODE_STRING TargetString;
    PCHAR Base;
    ULONG BaseIncr;
    ULONG Size;
    PSE_ADT_PARAMETER_ARRAY_ENTRY pInParam, pOutParam;
    NTSTATUS Status = STATUS_SUCCESS;
        


    //
    // Calculate the total size required for the passed AuditParameters
    // block.  This calculation will probably be an overestimate of the
    // amount of space needed, because data smaller that 2 dwords will
    // be stored directly in the parameters structure, but their length
    // will be counted here anyway.  The overestimate can't be more than
    // 24 dwords, and will never even approach that amount, so it isn't
    // worth the time it would take to avoid it.
    //

    for (i=0; i<AuditParameters->ParameterCount; i++) {
        Size = AuditParameters->Parameters[i].Length;
        TotalSize += PtrAlignSize( Size );
    }

    //
    // Allocate a big enough block of memory to hold everything.
    // If it fails, quietly abort, since there isn't much else we
    // can do.
    //

    *MarshalledAuditParameters = LsapAllocateLsaHeap( TotalSize );

    if (*MarshalledAuditParameters == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory (
       *MarshalledAuditParameters,
       AuditParameters,
       sizeof( SE_ADT_PARAMETER_ARRAY )
       );

    (*MarshalledAuditParameters)->Length = TotalSize;
    (*MarshalledAuditParameters)->Flags  = SE_ADT_PARAMETERS_SELF_RELATIVE;

    pInParam  = &AuditParameters->Parameters[0];
    pOutParam = &((*MarshalledAuditParameters)->Parameters[0]);
   
    //
    // Start walking down the list of parameters and marshall them
    // into the target buffer.
    //

    Base = (PCHAR) ((PCHAR)(*MarshalledAuditParameters) + sizeof( SE_ADT_PARAMETER_ARRAY ));

    for (i=0; i<AuditParameters->ParameterCount; i++, pInParam++, pOutParam++) {


        switch (pInParam->Type) {
            //
            // guard against somebody adding a new param type and not
            // adding appropriate code here.
            //
            default:
                ASSERT( FALSE && L"LsapAdtMarshallAuditRecord: unknown param type");
                break;
                
            case SeAdtParmTypeNone:
            case SeAdtParmTypeUlong:
            case SeAdtParmTypeHexUlong:
            case SeAdtParmTypeHexInt64:
            case SeAdtParmTypeLogonId:
            case SeAdtParmTypeLuid:
            case SeAdtParmTypeNoLogonId:
            case SeAdtParmTypeAccessMask:
            case SeAdtParmTypePtr:
            case SeAdtParmTypeTime:
            case SeAdtParmTypeDuration:
            case SeAdtParmTypeUserAccountControl:
            case SeAdtParmTypeNoUac:
            case SeAdtParmTypeMessage:
            case SeAdtParmTypeDateTime:
                {
                    //
                    // Nothing to do for this
                    //

                    break;
                }

            case SeAdtParmTypeFileSpec:
            case SeAdtParmTypeString:
                {
                    PUNICODE_STRING SourceString;

                    //
                    // We must copy the body of the unicode string
                    // and then copy the body of the string.  Pointers
                    // must be turned into offsets.

                    TargetString = (PUNICODE_STRING)Base;

                    SourceString = pInParam->Address;

                    *TargetString = *SourceString;

                    //
                    // Reset the data pointer in the output parameters to
                    // 'point' to the new string structure.
                    //

                    pOutParam->Address = Base - (ULONG_PTR)(*MarshalledAuditParameters);

                    Base += sizeof( UNICODE_STRING );

                    RtlCopyMemory( Base, SourceString->Buffer, SourceString->Length );

                    //
                    // Make the string buffer in the target string point to where we
                    // just copied the data.
                    //

                    TargetString->Buffer = (PWSTR)(Base - (ULONG_PTR)(*MarshalledAuditParameters));

                    BaseIncr = PtrAlignSize(SourceString->Length);

                    Base += BaseIncr;

                    ASSERT( (ULONG_PTR)Base <= (ULONG_PTR)(*MarshalledAuditParameters) + TotalSize );

                    break;
                }

            case SeAdtParmTypeGuid:
            case SeAdtParmTypeSid:
            case SeAdtParmTypePrivs:
            case SeAdtParmTypeObjectTypes:
            case SeAdtParmTypeSockAddr:
                {
#if DBG
                    switch (pInParam->Type)
                    {
                        case SeAdtParmTypeSid:
                            DsysAssertMsg( pInParam->Length >= RtlLengthSid(pInParam->Address),
                                           "LsapAdtMarshallAuditRecord" );
                            if (!RtlValidSid((PSID) pInParam->Address))
                            {
                                Status = STATUS_INVALID_SID;
                                goto Cleanup;
                            }
                            break;
                            
                        case SeAdtParmTypePrivs:
                            DsysAssertMsg( pInParam->Length >= LsapPrivilegeSetSize( (PPRIVILEGE_SET) pInParam->Address ),
                                           "LsapAdtMarshallAuditRecord" );
                            if (!IsValidPrivilegeCount(((PPRIVILEGE_SET) pInParam->Address)->PrivilegeCount))
                            {
                                Status = STATUS_INVALID_PARAMETER;
                                goto Cleanup;
                            }
                            break;

                        case SeAdtParmTypeGuid:
                            DsysAssertMsg( pInParam->Length == sizeof(GUID),
                                           "LsapAdtMarshallAuditRecord" );
                            break;

                        case SeAdtParmTypeSockAddr:
                            DsysAssertMsg((pInParam->Length == sizeof(SOCKADDR_IN)) ||
                                          (pInParam->Length == sizeof(SOCKADDR_IN6)) ||
                                          (pInParam->Length == sizeof(SOCKADDR)),
                                           "LsapAdtMarshallAuditRecord" );
                            break;
                            
                        default:
                            break;
                        
                    }
#endif
                    //
                    // Copy the data into the output buffer
                    //

                    RtlCopyMemory( Base, pInParam->Address, pInParam->Length );

                    //
                    // Reset the 'address' of the data to be its offset in the
                    // buffer.
                    //

                    pOutParam->Address = Base - (ULONG_PTR)(*MarshalledAuditParameters);

                    Base +=  PtrAlignSize( pInParam->Length );

                    ASSERT( (ULONG_PTR)Base <= (ULONG_PTR)(*MarshalledAuditParameters) + TotalSize );

                    break;
                }

            case SeAdtParmTypeStringList:
                {
                    PLSA_ADT_STRING_LIST        pSourceList = (PLSA_ADT_STRING_LIST)pInParam->Address;
                    PLSA_ADT_STRING_LIST        pTargetList = (PLSA_ADT_STRING_LIST)Base;
                    PLSA_ADT_STRING_LIST_ENTRY  pSourceEntry;
                    PLSA_ADT_STRING_LIST_ENTRY  pTargetEntry;
                    PCHAR                       pBuffer;
                    ULONG                       e;


                    ASSERT(pSourceList);


                    //
                    // Let the data pointer in the output parameter
                    // 'point' to the new string structure.
                    //

                    pOutParam->Address = Base - (ULONG_PTR)(*MarshalledAuditParameters);

                   
                    pTargetList->cStrings = pSourceList->cStrings;

                    Base += sizeof(LSA_ADT_STRING_LIST);


                    if (pSourceList->cStrings)
                    {
                        //
                        // Put the current offset into the Strings field.
                        //

                        pTargetList->Strings = (PLSA_ADT_STRING_LIST_ENTRY)(Base - (ULONG_PTR)(*MarshalledAuditParameters));


                        //
                        // Let pBuffer point to the area where we are
                        // going to store the string data.
                        //

                        pBuffer = Base + pSourceList->cStrings * sizeof(LSA_ADT_STRING_LIST_ENTRY);


                        //
                        // Walk through all the string entries and copy them.
                        //

                        for (
                            e = 0, pSourceEntry = pSourceList->Strings, pTargetEntry = (PLSA_ADT_STRING_LIST_ENTRY)Base;
                            e < pSourceList->cStrings;
                            e++, pSourceEntry++, pTargetEntry++)
                        {
                            //
                            // Copy the entry itself.
                            //

                            *pTargetEntry = *pSourceEntry;


                            //
                            // Fixup the Buffer field of the unicode string.
                            //

                            pTargetEntry->String.Buffer = (PWSTR)(pBuffer - (ULONG_PTR)(*MarshalledAuditParameters));


                            //
                            // Copy the string buffer.
                            //

                            RtlCopyMemory(
                                pBuffer,
                                pSourceEntry->String.Buffer,
                                pSourceEntry->String.Length);


                            //
                            // Adjust pBuffer to point past the buffer just copied.
                            //

                            pBuffer += PtrAlignSize(pSourceEntry->String.Length);
                        }


                        //
                        // pBuffer now points past the end of the last string buffer.
                        // Use it to init Base for the next parameter.
                        //

                        Base = pBuffer;
                    }

                    ASSERT((ULONG_PTR)Base <= (ULONG_PTR)pTargetList + pInParam->Length);
                    ASSERT((ULONG_PTR)Base <= (ULONG_PTR)(*MarshalledAuditParameters) + TotalSize);

                    break;
                }

            case SeAdtParmTypeSidList:
                {
                    PLSA_ADT_SID_LIST           pSourceList = (PLSA_ADT_SID_LIST)pInParam->Address;
                    PLSA_ADT_SID_LIST           pTargetList = (PLSA_ADT_SID_LIST)Base;
                    PLSA_ADT_SID_LIST_ENTRY     pSourceEntry;
                    PLSA_ADT_SID_LIST_ENTRY     pTargetEntry;
                    PCHAR                       pBuffer;
                    ULONG                       Length;
                    ULONG                       e;

                    ASSERT(pSourceList);


                    //
                    // Let the data pointer in the output parameter
                    // 'point' to the new string structure.
                    //

                    pOutParam->Address = Base - (ULONG_PTR)(*MarshalledAuditParameters);

                    pTargetList->cSids = pSourceList->cSids;

                    Base += sizeof(LSA_ADT_SID_LIST);


                    if (pSourceList->cSids)
                    {
                        //
                        // Put the current offset into the Sids field.
                        //

                        pTargetList->Sids = (PLSA_ADT_SID_LIST_ENTRY)(Base - (ULONG_PTR)(*MarshalledAuditParameters));


                        //
                        // Let pBuffer point to the area where we are
                        // going to store the sid data.
                        //

                        pBuffer = Base + pSourceList->cSids * sizeof(LSA_ADT_SID_LIST_ENTRY);


                        //
                        // Walk through all the sid entries and copy them.
                        //

                        for (
                            e = 0, pSourceEntry = pSourceList->Sids, pTargetEntry = (PLSA_ADT_SID_LIST_ENTRY)Base;
                            e < pSourceList->cSids;
                            e++, pSourceEntry++, pTargetEntry++)
                        {
                            //
                            // Copy the flags field.
                            //

                            pTargetEntry->Flags = pSourceEntry->Flags;


                            //
                            // Fixup the pointer to the sid.
                            //

                            pTargetEntry->Sid = (PSID)(pBuffer - (ULONG_PTR)(*MarshalledAuditParameters));


                            //
                            // Get the length of the sid.
                            //

                            Length = RtlLengthSid(pSourceEntry->Sid);


                            //
                            // Copy the sid.
                            //

                            RtlCopyMemory(
                                pBuffer,
                                pSourceEntry->Sid,
                                Length);


                            //
                            // Adjust pBuffer to point past the sid just copied.
                            //

                            pBuffer += PtrAlignSize(Length);
                        }


                        //
                        // pBuffer now points past the end of the last sid.
                        // Use it to init Base for the next parameter.
                        //

                        Base = pBuffer;
                    }

                    ASSERT((ULONG_PTR)Base <= (ULONG_PTR)pTargetList + pInParam->Length);
                    ASSERT((ULONG_PTR)Base <= (ULONG_PTR)(*MarshalledAuditParameters) + TotalSize);

                    break;
                }
        }
    }

 Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if ( *MarshalledAuditParameters )
        {
            LsapFreeLsaHeap( *MarshalledAuditParameters );
        }
    }

    return( Status );
}




NTSTATUS
LsapAdtInitParametersArray(
    IN SE_ADT_PARAMETER_ARRAY* AuditParameters,
    IN ULONG AuditCategoryId,
    IN ULONG AuditId,
    IN USHORT AuditEventType,
    IN USHORT ParameterCount,
    ...)
/*++

Routine Description:

    This function initializes AuditParameters array in the format
    required by the LsapAdtWriteLog function.

Arguments:

    AuditParameters - pointer to audit parameters struct to be initialized

    AuditCategoryId - audit category id
        e.g. SE_CATEGID_OBJECT_ACCESS

    AuditId - sub-type of audit
        e.g. SE_AUDITID_OBJECT_OPERATION

    AuditEventType - The type of audit event to be generated.
        EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    ParameterCount - number of parameter pairs after this parameter
        Each pair is in the form
        <parameter type>, <parameter value>
        e.g. SeAdtParmTypeString, <addr. of unicode string>

        The only exception is for SeAdtParmTypeAccessMask which is
        followed by <mask-value> and <index-to-object-type-entry>.
        Refer to LsapAdtGenerateObjectOperationAuditEvent for an example.
        

Return Value:

    None

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    va_list arglist;
    UINT i;
    
    PSE_ADT_PARAMETER_ARRAY_ENTRY Parameter;
    SE_ADT_PARAMETER_TYPE ParameterType;
    LUID Luid;
    LARGE_INTEGER LargeInteger;
    ULONGLONG Qword;
    PPRIVILEGE_SET Privileges;
    PUNICODE_STRING String;
    PSID Sid;
    LPGUID pGuid;
    GUID NullGuid = { 0 };
    USHORT ObjectTypeIndex;
    PSOCKADDR pSockAddr = NULL;
    
    
    RtlZeroMemory ( (PVOID) AuditParameters,
                    sizeof(SE_ADT_PARAMETER_ARRAY) );

    AuditParameters->CategoryId     = AuditCategoryId;
    AuditParameters->AuditId        = AuditId;
    AuditParameters->Type           = AuditEventType;
    AuditParameters->ParameterCount = ParameterCount;

    Parameter = AuditParameters->Parameters;

    DsysAssertMsg( ParameterCount <= SE_MAX_AUDIT_PARAMETERS, "LsapAdtInitParametersArray" );

    va_start (arglist, ParameterCount);

    for (i=0; i<ParameterCount; i++) {

        ParameterType = va_arg(arglist, SE_ADT_PARAMETER_TYPE);
        
        Parameter->Type = ParameterType;
        
        switch(ParameterType) {

            //
            // guard against somebody adding a new param type and not
            // adding appropriate code here.
            //
            default:
                ASSERT(FALSE && L"LsapAdtInitParametersArray: unknown param type");
                break;
                
            case SeAdtParmTypeNone:
                break;
                
            case SeAdtParmTypeFileSpec:
            case SeAdtParmTypeString:
                String = va_arg(arglist, PUNICODE_STRING);

                if ( String )
                {
                    Parameter->Length = sizeof(UNICODE_STRING)+String->Length;
                    Parameter->Address = String;
                }
                else
                {
                    //
                    // if the caller passed NULL, make type == none
                    // so that a '-' will be emitted in the eventlog
                    //

                    Parameter->Type = SeAdtParmTypeNone;
                }
                break;
                
            case SeAdtParmTypeUserAccountControl:
                Parameter->Length = 2 * sizeof(ULONG);
                Parameter->Data[0] = va_arg(arglist, ULONG);
                Parameter->Data[1] = va_arg(arglist, ULONG);
                break;

            case SeAdtParmTypeNoUac:
                // no additional setting
                break;

            case SeAdtParmTypeHexUlong:
            case SeAdtParmTypeUlong:
            case SeAdtParmTypeMessage:
                Parameter->Length = sizeof(ULONG);
                Parameter->Data[0] = va_arg(arglist, ULONG);
                break;
                
            case SeAdtParmTypePtr:
                Parameter->Length = sizeof(ULONG_PTR);
                Parameter->Data[0] = va_arg(arglist, ULONG_PTR);
                break;
                
            case SeAdtParmTypeSid:
                Sid = va_arg(arglist, PSID);

                if ( Sid )
                {
                    if ( !RtlValidSid( Sid ))
                    {
                        Status = STATUS_INVALID_SID;
                        goto Cleanup;
                    }
                    Parameter->Length = RtlLengthSid(Sid);
                    Parameter->Address = Sid;
                }
                else
                {
                    //
                    // if the caller passed NULL, make type == none
                    // so that a '-' will be emitted in the eventlog
                    //

                    Parameter->Type = SeAdtParmTypeNone;
                }
                break;
                
            case SeAdtParmTypeGuid:
                pGuid = va_arg(arglist, LPGUID);

                //
                // if the GUID is supplied and is not NULL-GUID store
                // it as a GUID, otherwise mark as SeAdtParmTypeNone
                // so that it will produce '-' in the formatted audit event.
                //
                if ( pGuid && memcmp( pGuid, &NullGuid, sizeof(GUID)))
                {
                    Parameter->Length  = sizeof(GUID);
                    Parameter->Address = pGuid;
                }
                else
                {
                    //
                    // if the caller passed NULL, make type == none
                    // so that a '-' will be emitted in the eventlog
                    //

                    Parameter->Type = SeAdtParmTypeNone;
                }
                break;
                
            case SeAdtParmTypeSockAddr:
                pSockAddr = va_arg(arglist, PSOCKADDR);

                Parameter->Address = pSockAddr;

                //
                // currently we only support IPv4 and IPv6. for anything else
                // the following will break
                //

                if ( pSockAddr )
                {
                    if ( pSockAddr->sa_family == AF_INET6 )
                    {
                        Parameter->Length = sizeof(SOCKADDR_IN6);
                    }
                    else if ( pSockAddr->sa_family == AF_INET )
                    {
                        Parameter->Length = sizeof(SOCKADDR_IN);
                    }
                    else
                    {
                        Parameter->Length = sizeof(SOCKADDR);

                        //
                        // sa_family == 0 is a valid way of specifying that
                        // the sock addr is not specified.
                        //

                        if ( pSockAddr->sa_family != 0 )
                        {
                            AdtAssert(FALSE, ("LsapAdtInitParametersArray: invalid sa_family: %d", pSockAddr->sa_family));
                        }
                    }
                }
                break;
                
            case SeAdtParmTypeLogonId:
            case SeAdtParmTypeLuid:
                Luid = va_arg(arglist, LUID);
                Parameter->Length = sizeof(LUID);
                *((LUID*) Parameter->Data) = Luid;
                break;

            case SeAdtParmTypeTime:
            case SeAdtParmTypeDuration:
            case SeAdtParmTypeDateTime:
                LargeInteger = va_arg(arglist, LARGE_INTEGER);
                Parameter->Length = sizeof(LARGE_INTEGER);
                *((PLARGE_INTEGER) Parameter->Data) = LargeInteger;
                break;
                
            case SeAdtParmTypeHexInt64:
                Qword = va_arg(arglist, ULONGLONG);
                Parameter->Length = sizeof(ULONGLONG);
                *((PULONGLONG) Parameter->Data) = Qword;
                break;
                
            case SeAdtParmTypeNoLogonId:
                // no additional setting
                break;
                
            case SeAdtParmTypeAccessMask:
                Parameter->Length = sizeof(ACCESS_MASK);
                Parameter->Data[0] = va_arg(arglist, ACCESS_MASK);
                ObjectTypeIndex    = va_arg(arglist, USHORT);
                DsysAssertMsg((ObjectTypeIndex < i), "LsapAdtInitParametersArray");
                Parameter->Data[1] = ObjectTypeIndex;
                break;
                
            case SeAdtParmTypePrivs:
                Privileges = va_arg(arglist, PPRIVILEGE_SET);

                if (!IsValidPrivilegeCount(Privileges->PrivilegeCount))
                {
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }
                Parameter->Length = LsapPrivilegeSetSize(Privileges);
                break;
                
            case SeAdtParmTypeObjectTypes:
                {
                    ULONG ObjectTypeCount;
                    
                    Parameter->Address = va_arg(arglist, PSE_ADT_OBJECT_TYPE);
                    ObjectTypeCount    = va_arg(arglist, ULONG);
                    Parameter->Length  = sizeof(SE_ADT_OBJECT_TYPE)*ObjectTypeCount;
                    Parameter->Data[1] = va_arg(arglist, ULONG);
                }
                break;

            case SeAdtParmTypeStringList:
                {
                    PLSA_ADT_STRING_LIST    pList;

                    pList = va_arg(arglist, PLSA_ADT_STRING_LIST);

                    if (pList)
                    {
                        Parameter->Address = pList;
                        Parameter->Length = LsapStringListSize(pList);
                    }
                    else
                    {
                        //
                        // if the caller passed NULL, make type == none
                        // so that a '-' will be emitted in the eventlog
                        //

                        Parameter->Type = SeAdtParmTypeNone;
                    }
                }
                break;

            case SeAdtParmTypeSidList:
                {
                    PLSA_ADT_SID_LIST       pList;

                    pList = va_arg(arglist, PLSA_ADT_SID_LIST);

                    if (pList)
                    {
                        Parameter->Address = pList;
                        Parameter->Length = LsapSidListSize(pList);
                    }
                    else
                    {
                        //
                        // if the caller passed NULL, make type == none
                        // so that a '-' will be emitted in the eventlog
                        //

                        Parameter->Type = SeAdtParmTypeNone;
                    }
                }
                break;

        }
        Parameter++;
    }
    
    va_end(arglist);

 Cleanup:

    return Status;
}



ULONG
LsapStringListSize(
    IN  PLSA_ADT_STRING_LIST pStringList
    )
/*++

Routine Description:

    This function returns the total number of bytes needed to store
    a string list as a blob when marshalling it.

Arguments:

    pStringList - pointer to the string list

Return Value:

    Number of bytes needed

Notes:

--*/
{
    ULONG                       Size    = 0;
    ULONG                       i;
    PLSA_ADT_STRING_LIST_ENTRY  pEntry;

    if (pStringList)
    {
        Size += sizeof(LSA_ADT_STRING_LIST);

        Size += pStringList->cStrings * sizeof(LSA_ADT_STRING_LIST_ENTRY);

        for (i=0,pEntry=pStringList->Strings;i < pStringList->cStrings;i++,pEntry++)
        {
            Size += PtrAlignSize(pEntry->String.Length);
        }
    }

    return Size;
}



ULONG
LsapSidListSize(
    IN  PLSA_ADT_SID_LIST pSidList
    )
/*++

Routine Description:

    This function returns the total number of bytes needed to store
    a sid list as a blob when marshalling it.

Arguments:

    pSidList - pointer to the sid list

Return Value:

    Number of bytes needed

Notes:

--*/
{
    ULONG                       Size    = 0;
    ULONG                       i;
    PLSA_ADT_SID_LIST_ENTRY     pEntry;

    if (pSidList)
    {
        Size += sizeof(LSA_ADT_SID_LIST);

        Size += pSidList->cSids * sizeof(LSA_ADT_SID_LIST_ENTRY);

        for (i=0,pEntry=pSidList->Sids;i < pSidList->cSids;i++,pEntry++)
        {
            ASSERT(RtlValidSid(pEntry->Sid));

            Size += PtrAlignSize(RtlLengthSid(pEntry->Sid));
        }
    }

    return Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtlq.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T L Q . C
//
// Contents:    definitions of types/functions required for 
//              managing audit queue
//
//
// History:     
//   23-May-2000  kumarp        created
//
//------------------------------------------------------------------------


#include <lsapch2.h>
#pragma hdrstop

#include "adtp.h"
#include "adtlq.h"

ULONG LsapAdtQueueLength;
LIST_ENTRY LsapAdtLogQueue;

//
// critsec to guard LsapAdtLogQueue and LsapAdtQueueLength
//

RTL_CRITICAL_SECTION LsapAdtQueueLock;

//
// critsec to guard log full policy
//

RTL_CRITICAL_SECTION LsapAdtLogFullLock;

//
// event to wake up LsapAdtAddToQueue
//

HANDLE LsapAdtQueueInsertEvent;

//
// event to wake up LsapAdtDequeueThreadWorker
//

HANDLE LsapAdtQueueRemoveEvent;

//
// thread that writes queue entries to the log
//

HANDLE LsapAdtQueueThread;




NTSTATUS
LsapAdtInitializeLogQueue(
    )

/*++

Routine Description:

    This function initializes the Audit Log Queue.

Arguments:

    None.

Return Values:

    NTSTATUS - Standard NT Result Code

Note:

    The caller calls LsapAuditFailed()

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES obja;

    InitializeObjectAttributes(
        &obja,
        NULL,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    InitializeListHead(&LsapAdtLogQueue);

    LsapAdtQueueLength = 0;

    Status = NtCreateEvent(
                &LsapAdtQueueInsertEvent,
                EVENT_ALL_ACCESS,
                &obja,
                NotificationEvent,
                TRUE
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = NtCreateEvent(
                &LsapAdtQueueRemoveEvent,
                EVENT_ALL_ACCESS,
                &obja,
                SynchronizationEvent,
                FALSE
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = RtlInitializeCriticalSection(&LsapAdtQueueLock);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = RtlInitializeCriticalSection(&LsapAdtLogFullLock);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    LsapAdtQueueThread = LsapCreateThread(
                             0,
                             0,
                             LsapAdtDequeueThreadWorker,
                             0,
                             0,
                             0
                             );

    if (LsapAdtQueueThread == 0)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

Cleanup:

    return Status;
}



NTSTATUS 
LsapAdtAddToQueue(
    IN PLSAP_ADT_QUEUED_RECORD pAuditRecord
    )
/*++

Routine Description:

    Insert the specified record in the audit queue

Arguments:

    pAuditRecord - record to insert

Return Value:

    NTSTATUS - Standard NT Result Code

Notes:
    
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN bRetry = FALSE;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    static BOOLEAN bEventSet = TRUE;

    TimeOut.QuadPart = 10 * 1000 * -10000i64;      // 10s
    pTimeOut = &TimeOut;

    do
    {
        bRetry = FALSE;

        Status = LsapAdtAcquireLogQueueLock();

        if (NT_SUCCESS(Status))
        {
            if (LsapAdtQueueLength < MAX_AUDIT_QUEUE_LENGTH)
            {
                InsertTailList(&LsapAdtLogQueue, &pAuditRecord->Link);

                LsapAdtQueueLength++;

                if (LsapAdtQueueLength == 1 || !bEventSet)
                {
                    //
                    // We only need to set the remove event if
                    // the queue was empty before.
                    //

                    Status = NtSetEvent(LsapAdtQueueRemoveEvent, 0);

                    if (NT_SUCCESS(Status))
                    {
                        bEventSet = TRUE;
                    }
                    else
                    {
                        DsysAssertMsg(
                            FALSE,
                            "LsapAdtAddToQueue: Remove event could not be set");

                        bEventSet = FALSE;
                        Status = STATUS_SUCCESS;
                    }
                }
                else if (LsapAdtQueueLength == MAX_AUDIT_QUEUE_LENGTH)
                {
                    //
                    // Reset the insert event since the queue is now full.
                    //

                    Status = NtResetEvent(LsapAdtQueueInsertEvent, 0);

                    DsysAssertMsg(
                        NT_SUCCESS(Status),
                        "LsapAdtAddToQueue: Insert event could not be reset and queue is full");
                }
            }
            else
            {
                bRetry = TRUE;
            }

            LsapAdtReleaseLogQueueLock();
        }

        if (bRetry)
        {
            //
            // We could not insert into the queue because it is full.
            // There can be two reasons for that:
            //
            // 1 - Event log is not open yet. We will just
            //     wait for some time - the log might get opened
            //     and the insert event get signalled.
            //
            // 2 - Incoming audit rate is high. We will wait
            //     until the insert event gets signaled.
            //

            if (LsapAdtLogHandle == NULL)
            {
                //
                // timeout when EventLog is not yet open
                //

                pTimeOut = &TimeOut;
            }
            else
            {
                //
                // infinite timeout
                //

                pTimeOut = NULL;
            }

            Status = NtWaitForSingleObject(
                         LsapAdtQueueInsertEvent,
                         FALSE,                     // wait non - alertable
                         pTimeOut);

            //
            // STATUS_SUCCESS means the insert event is now signalled, so there should
            // be room in the queue for our audit. Just try inserting it again.
            //
            // STATUS_TIMEOUT means we still cannot write to the log.
            // Instead of holding up the caller any longer, just return
            // the status.
            //
            // All other status codes are not expected and lower level failures.
            // Return them to the caller.
            // We are NOT expecting STATUS_ALERTED or STATUS_USER_APC since our
            // wait is non - alertable.
            //

            if (Status != STATUS_SUCCESS)
            {
                ASSERT(Status != STATUS_ALERTED && Status != STATUS_USER_APC);

                bRetry = FALSE;
            }
        }
    }
    while (bRetry);

    return Status;
}



NTSTATUS 
LsapAdtGetQueueHead(
    OUT PLSAP_ADT_QUEUED_RECORD *ppRecord
    )
/*++

Routine Description:

    Remove and return audit record at the head of the queue

Arguments:

    ppRecord - receives a pointer to the record removed

Return Value:

    STATUS_SUCCESS   on success
    STATUS_NOT_FOUND if the queue is empty

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_ADT_QUEUED_RECORD pRecordAtHead;
    static BOOLEAN bEventSet = TRUE;

    *ppRecord = NULL;

    if (LsapAdtQueueLength > 0)
    {
        Status = LsapAdtAcquireLogQueueLock();

        if (NT_SUCCESS(Status))
        {
            pRecordAtHead = (PLSAP_ADT_QUEUED_RECORD)RemoveHeadList(
                                                         &LsapAdtLogQueue);

            DsysAssertMsg(
                pRecordAtHead != NULL,
                "LsapAdtGetQueueHead: LsapAdtQueueLength > 0 but pRecordAtHead is NULL");

            LsapAdtQueueLength--;

            if (LsapAdtQueueLength == AUDIT_QUEUE_LOW_WATER_MARK || !bEventSet)
            {
                //
                // Set the insert event so clients can start
                // inserting again.
                //

                Status = NtSetEvent(LsapAdtQueueInsertEvent, 0);

                if (NT_SUCCESS(Status))
                {
                    bEventSet = TRUE;
                }
                else
                {
                    DsysAssertMsg(
                        LsapAdtQueueLength,
                        "LsapAdtGetQueueHead: Insert event could not be set and queue is empty");


                    //
                    // The event could not be set, so the inserting clients
                    // are still blocked. Try to set it the next time.
                    // Also set Status to success since we dequeued an audit.
                    //

                    bEventSet = FALSE;
                    Status = STATUS_SUCCESS;
                }
            }

            *ppRecord = pRecordAtHead;

            LsapAdtReleaseLogQueueLock();
        }
    }
    else
    {
        Status = STATUS_NOT_FOUND;
    }

    return Status;
}



BOOL
LsapAdtIsValidQueue( )
/*++

Routine Description:

    Check if the audit queue looks valid    

Arguments:
    None

Return Value:

    TRUE if queue is valid, FALSE otherwise

Notes:

--*/
{
    BOOL fIsValid;
    
    if ( LsapAdtQueueLength > 0 )
    {
        fIsValid =
            (LsapAdtLogQueue.Flink != NULL) &&
            (LsapAdtLogQueue.Blink != NULL);
    }
    else
    {
        fIsValid =
            (LsapAdtLogQueue.Flink == &LsapAdtLogQueue) &&
            (LsapAdtLogQueue.Blink == &LsapAdtLogQueue);
        
    }

    return fIsValid;
}



NTSTATUS
LsapAdtFlushQueue( )
/*++

Routine Description:

    Remove and free each record from the queue    

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_ADT_QUEUED_RECORD pAuditRecord;
    
    //
    // Flush out the queue, if there is one.
    //

    DsysAssertMsg(LsapAdtIsValidQueue(), "LsapAdtFlushQueue");

    Status = LsapAdtAcquireLogQueueLock();

    if (NT_SUCCESS(Status))
    {
        do
        {
            Status = LsapAdtGetQueueHead(&pAuditRecord);

            if (NT_SUCCESS(Status))
            {
                LsapFreeLsaHeap( pAuditRecord );
            }
        }
        while (NT_SUCCESS(Status));

        if (Status == STATUS_NOT_FOUND)
        {
            Status = STATUS_SUCCESS;
        }

        DsysAssertMsg(LsapAdtQueueLength == 0, "LsapAdtFlushQueue: LsapAuditQueueLength not 0 after queue flush");

        LsapAdtReleaseLogQueueLock();
    }

    return Status;
}



NTSTATUS
LsapAdtAcquireLogQueueLock(
    )

/*++

Routine Description:

    This function acquires the LSA Audit Log Queue Lock.  This lock serializes
    all updates to the Audit Log Queue.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    return RtlEnterCriticalSection(&LsapAdtQueueLock);
}



VOID
LsapAdtReleaseLogQueueLock(
    VOID
    )

/*++

Routine Description:

    This function releases the LSA Audit Log Queue Lock.  This lock serializes
    updates to the Audit Log Queue.

Arguments:

    None.

Return Value:

    None.  Any error occurring within this routine is an internal error.

--*/

{
    RtlLeaveCriticalSection(&LsapAdtQueueLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\adtutil.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adtutil.c

Abstract:

    Misc helper functions

Author:

    15-August-2000   kumarp

--*/
 

#include <lsapch2.h>
#include "adtp.h"


NTSTATUS
ImpersonateAnyClient(); // from ntdsa

VOID
UnImpersonateAnyClient(); // from ntdsa



ULONG
LsapSafeWcslen(
    UNALIGNED WCHAR *p,
    LONG            MaxLength
    )
/*++

    Safewcslen - Strlen that won't exceed MaxLength

Routine Description:

    This routine is called to determine the size of a UNICODE_STRING
    (taken from elfapi.c)

Arguments:
    p         - The string to count.
    MaxLength - The maximum length to look at.


Return Value:

    Number of bytes in the string (or MaxLength)

--*/
{
    ULONG Count = 0;

    if (p)
    {
        while ((MaxLength > 0) && (*p++ != UNICODE_NULL))
        {
            MaxLength -= sizeof(WCHAR);
            Count     += sizeof(WCHAR);
        }
    }

    return Count;
}


BOOL
LsapIsValidUnicodeString(
    IN PUNICODE_STRING pUString
    )

/*++

Routine Description:

    Verify the unicode string. The string is invalid if:
        The UNICODE_STRING structure ptr is NULL.
        The MaximumLength field is invalid (too small).
        The Length field is incorrect.
    (taken from elfapi.c)

Arguments:

    pUString    - String to verify.

Return Value:

    TRUE   if the string is valid
    FALSE  otherwise

--*/
{
    return !(!pUString ||
             (pUString->MaximumLength < pUString->Length) ||
             (pUString->Length != LsapSafeWcslen(pUString->Buffer,
                                                 pUString->Length)));
}



BOOLEAN
LsapAdtLookupDriveLetter(
    IN PUNICODE_STRING FileName,
    OUT PUSHORT DeviceNameLength,
    OUT PWCHAR DriveLetter
    )

/*++

Routine Description:

    This routine will take a file name and compare it to the
    list of device names obtained during LSA initialization.
    If one of the device names matches the prefix of the file
    name the corresponding drive letter will be returned.

Arguments:

    FileName - Supplies a unicode string containing the file
        name obtained from the file system.

    DeviceNameLength - If successful, returns the length of
        the device name.

    DriveLetter - If successful, returns the drive letter
        corresponding to the device object.

Return Value:

    Returns TRUE of a mapping is found, FALSE otherwise.

--*/

{
    LONG i = 0;
    PUNICODE_STRING DeviceName;
    USHORT OldLength;


    for (i = MAX_DRIVE_MAPPING - 1; i >= 0; i--)
    {
    
        if (DriveMappingArray[i].DeviceName.Buffer != NULL ) {

            DeviceName = &DriveMappingArray[i].DeviceName;

            //
            // If the device name is longer than the passed file name,
            // it can't be a match.
            //

            if ( DeviceName->Length > FileName->Length ) {
                continue;
            }

            //
            // Temporarily truncate the file name to be the same
            // length as the device name by adjusting the length field
            // in its unicode string structure.  Then compare them and
            // see if they match.
            //
            // The test above ensures that this is a safe thing to
            // do.
            //

            OldLength = FileName->Length;
            FileName->Length = DeviceName->Length;


            if ( RtlEqualUnicodeString( FileName, DeviceName, TRUE ) ) {

                //
                // We've got a match.
                //

                FileName->Length = OldLength;
                *DriveLetter = DriveMappingArray[i].DriveLetter;
                *DeviceNameLength = DeviceName->Length;
                return( TRUE );

            }

            FileName->Length = OldLength;
        }
    }

    return( FALSE );
}



VOID
LsapAdtSubstituteDriveLetter(
    IN OUT PUNICODE_STRING FileName
    )

/*++

Routine Description:

    Takes a filename and replaces the device name part with a
    drive letter, if possible.

    The string will be edited directly in place, which means that
    the Length field will be adjusted, and the Buffer contents will
    be moved so that the drive letter is at the beginning of the
    buffer.  No memory will be allocated or freed.

Arguments:

    FileName - Supplies a pointer to a unicode string containing
        a filename.

Return Value:

    None.

--*/

{

    WCHAR DriveLetter;
    USHORT DeviceNameLength;
    PWCHAR p;
    PWCHAR FilePart;
    USHORT FilePartLength;

    if ( LsapAdtLookupDriveLetter( FileName, &DeviceNameLength, &DriveLetter )) {

        p = FileName->Buffer;
        FilePart = (PWCHAR)((PCHAR)(FileName->Buffer) + DeviceNameLength);
        FilePartLength = FileName->Length - DeviceNameLength;


        *p = DriveLetter;
        *++p = L':';

        //
        // THIS IS AN OVERLAPPED COPY!  DO NOT USE RTLCOPYMEMORY!
        //

        RtlMoveMemory( ++p, FilePart, FilePartLength );

        FileName->Length = FilePartLength + 2 * sizeof( WCHAR );
    }
}



NTSTATUS
LsapQueryClientInfo(
    PTOKEN_USER *UserSid,
    PLUID AuthenticationId
    )

/*++

Routine Description:

    This routine impersonates our client, opens the thread token, and
    extracts the User Sid.  It puts the Sid in memory allocated via
    LsapAllocateLsaHeap, which must be freed by the caller.

Arguments:

    None.

Return Value:

    Returns a pointer to heap memory containing a copy of the Sid, or
    NULL.

--*/

{
    NTSTATUS Status;
    HANDLE TokenHandle;
    ULONG ReturnLength;
    TOKEN_STATISTICS TokenStats;
    BOOLEAN bImpersonatingAnonymous = FALSE;

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY,
                 TRUE,                    // OpenAsSelf
                 &TokenHandle
                 );

    if (!NT_SUCCESS(Status))
    {
        if (Status != STATUS_NO_TOKEN)
        {
            return Status;
        }

        if (LsaDsStateInfo.DsInitializedAndRunning)
        {
            Status = I_RpcMapWin32Status(ImpersonateAnyClient());
        }
        else
        {
            Status = I_RpcMapWin32Status(RpcImpersonateClient(NULL));
        }

        if (Status == RPC_NT_CANNOT_SUPPORT)
        {
            Status = NtImpersonateAnonymousToken(NtCurrentThread());
            
            bImpersonatingAnonymous = TRUE;
        }

        if (NT_SUCCESS(Status))
        {
            NTSTATUS DbgStatus;

            Status = NtOpenThreadToken(
                         NtCurrentThread(),
                         TOKEN_QUERY,
                         TRUE,                    // OpenAsSelf
                         &TokenHandle
                         );

            if (bImpersonatingAnonymous)
            {
                HANDLE NewTokenHandle = NULL;

                DbgStatus = NtSetInformationThread(
                                NtCurrentThread(),
                                ThreadImpersonationToken,
                                (PVOID)&NewTokenHandle,
                                (ULONG)sizeof(HANDLE)
                                );

                ASSERT(NT_SUCCESS(DbgStatus));
            }
            else
            {
                if (LsaDsStateInfo.DsInitializedAndRunning)
                {
                    UnImpersonateAnyClient();
                }
                else
                {
                    DbgStatus = I_RpcMapWin32Status(RpcRevertToSelf());

                    ASSERT(NT_SUCCESS(DbgStatus));
                }
            }

            if (!NT_SUCCESS(Status))
            {
                return Status;
            }
        }
        else if (Status == RPC_NT_NO_CALL_ACTIVE)
        {
            Status = NtOpenProcessToken(
                         NtCurrentProcess(),
                         TOKEN_QUERY,
                         &TokenHandle
                         );

            if (!NT_SUCCESS(Status))
            {
                return Status;
            }
        }
        else
        {
            return Status;
        }
    }

    Status = NtQueryInformationToken(
                 TokenHandle,
                 TokenUser,
                 NULL,
                 0,
                 &ReturnLength
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL)
    {
        NtClose(TokenHandle);
        return Status;
    }

    *UserSid = LsapAllocateLsaHeap(ReturnLength);

    if (*UserSid == NULL)
    {
        NtClose(TokenHandle);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = NtQueryInformationToken(
                 TokenHandle,
                 TokenUser,
                 *UserSid,
                 ReturnLength,
                 &ReturnLength
                 );

    if (!NT_SUCCESS(Status))
    {
        NtClose(TokenHandle);
        LsapFreeLsaHeap(*UserSid);
        *UserSid = NULL;
        return Status;
    }

    Status = NtQueryInformationToken(
                 TokenHandle,
                 TokenStatistics,
                 (PVOID)&TokenStats,
                 sizeof(TOKEN_STATISTICS),
                 &ReturnLength
                 );

    NtClose(TokenHandle);

    if (!NT_SUCCESS(Status))
    {
        LsapFreeLsaHeap(*UserSid);
        *UserSid = NULL;
        return Status;
    }

    *AuthenticationId = TokenStats.AuthenticationId;

    return STATUS_SUCCESS;
}

BOOL
LsapIsLocalOrNetworkService(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain
    )

/*++

Routine Description:

    This routine checks to see if the passed account name represents
    a local or network service

Arguments:

    pUserName - unicode user name
    
    pUserDomain - unicode domain name

Return Value:

    TRUE  if the passed account name represents a local or network service
    FALSE otherwise

--*/
{
#define  LOCALSERVICE_NAME    L"LocalService"
#define  NETWORKSERVICE_NAME  L"NetworkService"
#define  NTAUTHORITY_NAME     L"NT AUTHORITY"

    static UNICODE_STRING  LocalServiceName = { sizeof(LOCALSERVICE_NAME) - sizeof(WCHAR),
                                                sizeof(LOCALSERVICE_NAME),
                                                LOCALSERVICE_NAME };

    static UNICODE_STRING  NetworkServiceName = { sizeof(NETWORKSERVICE_NAME) - sizeof(WCHAR),
                                                  sizeof(NETWORKSERVICE_NAME),
                                                  NETWORKSERVICE_NAME };

    static UNICODE_STRING  NTAuthorityName = { sizeof(NTAUTHORITY_NAME) - sizeof(WCHAR),
                                               sizeof(NTAUTHORITY_NAME),
                                               NTAUTHORITY_NAME };

    PUNICODE_STRING pLocalServiceName;
    PUNICODE_STRING pNetworkServiceName;
    PUNICODE_STRING pLocalDomainName;

    if ( !pUserName || !pUserDomain )
    {
        return FALSE;
    }

    //
    // Hardcoded english strings for LocalService and NetworkService
    // since the account names may come from the registry (which isn't
    // localized).
    //
    
    pLocalDomainName    = &WellKnownSids[LsapLocalServiceSidIndex].DomainName;
    pNetworkServiceName = &WellKnownSids[LsapNetworkServiceSidIndex].Name;
    pLocalServiceName   = &WellKnownSids[LsapLocalServiceSidIndex].Name;

    //
    // check both hardcode and localized names
    //

    if (((RtlCompareUnicodeString(&NTAuthorityName,     pUserDomain, TRUE) == 0) &&
         ((RtlCompareUnicodeString(&LocalServiceName,   pUserName, TRUE) == 0) ||
          (RtlCompareUnicodeString(&NetworkServiceName, pUserName, TRUE) == 0))) ||

        ((RtlCompareUnicodeString(pLocalDomainName,     pUserDomain, TRUE) == 0) &&
         ((RtlCompareUnicodeString(pLocalServiceName,   pUserName, TRUE) == 0) ||
          (RtlCompareUnicodeString(pNetworkServiceName, pUserName, TRUE) == 0))))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
        
}


BOOL
LsapIsAnonymous(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain
    )

/*++

Routine Description:

    This routine checks to see if the passed account name represents
    an anonymous logon.

Arguments:

    pUserName - unicode user name
    
    pUserDomain - unicode domain name

Return Value:

    TRUE  if the passed account name represents the anonymous logon.
    FALSE otherwise

--*/
{
#define  ANONYMOUS_NAME       L"ANONYMOUS LOGON"
#define  NTAUTHORITY_NAME     L"NT AUTHORITY"

    static UNICODE_STRING  AnonymousName = { sizeof(ANONYMOUS_NAME) - sizeof(WCHAR),
                                             sizeof(ANONYMOUS_NAME),
                                             ANONYMOUS_NAME };
    
    static UNICODE_STRING  NTAuthorityName = { sizeof(NTAUTHORITY_NAME) - sizeof(WCHAR),
                                               sizeof(NTAUTHORITY_NAME),
                                               NTAUTHORITY_NAME };

    PUNICODE_STRING pLocalDomainName = &WellKnownSids[LsapLocalServiceSidIndex].DomainName;
    PUNICODE_STRING pAnonymousName   = &WellKnownSids[LsapAnonymousSidIndex].Name;
    
    if ( !pUserName || !pUserDomain )
    {
        return FALSE;
    }

    //
    // check both hardcode and localized names
    //

    if (((RtlCompareUnicodeString(&NTAuthorityName, pUserDomain, TRUE) == 0) &&
         (RtlCompareUnicodeString(&AnonymousName, pUserName, TRUE) == 0)) ||

        ((RtlCompareUnicodeString(pLocalDomainName, pUserDomain, TRUE) == 0) &&
         (RtlCompareUnicodeString(pAnonymousName, pUserName, TRUE) == 0)))
    {
        return TRUE;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\auinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    auinit.c

Abstract:

    This module performs initialization of the authentication aspects
    of the lsa.

Author:

    Jim Kelly (JimK) 26-February-1991

Revision History:

--*/

#include <lsapch2.h>

#include <string.h>



BOOLEAN
LsapAuInit(
    VOID
    )

/*++

Routine Description:

    This function initializes the LSA authentication services.

Arguments:

    None.

Return Value:

    None.

--*/

{
    LUID SystemLuid = SYSTEM_LUID;
    LUID AnonymousLuid = ANONYMOUS_LOGON_LUID;

    LsapSystemLogonId = SystemLuid;
    LsapZeroLogonId.LowPart = 0;
    LsapZeroLogonId.HighPart = 0;
    LsapAnonymousLogonId = AnonymousLuid;

    //
    // Strings needed for auditing.
    //

    RtlInitUnicodeString( &LsapLsaAuName, L"NT Local Security Authority / Authentication Service" );
    RtlInitUnicodeString( &LsapRegisterLogonServiceName, L"LsaRegisterLogonProcess()" );

    if (!LsapEnableCreateTokenPrivilege() ) {
        return FALSE;
    }



    return TRUE;

}



BOOLEAN
LsapEnableCreateTokenPrivilege(
    VOID
    )

/*++

Routine Description:

    This function enabled the SeCreateTokenPrivilege privilege.

Arguments:

    None.

Return Value:

    TRUE  if privilege successfully enabled.
    FALSE if not successfully enabled.

--*/
{

    NTSTATUS Status;
    HANDLE Token;
    LUID CreateTokenPrivilege;
    PTOKEN_PRIVILEGES NewState;
    ULONG ReturnLength;


    //
    // Open our own token
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_ADJUST_PRIVILEGES,
                 &Token
                 );
    ASSERTMSG( "LSA/AU Cant open own process token.", NT_SUCCESS(Status) );


    //
    // Initialize the adjustment structure
    //

    CreateTokenPrivilege =
        RtlConvertLongToLuid(SE_CREATE_TOKEN_PRIVILEGE);

    ASSERT( (sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)) < 100);
    NewState = LsapAllocateLsaHeap( 100 );

    if ( NewState == NULL )
    {
        NtClose( Token );
        return FALSE ;
    }

    NewState->PrivilegeCount = 1;
    NewState->Privileges[0].Luid = CreateTokenPrivilege;
    NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;


    //
    // Set the state of the privilege to ENABLED.
    //

    Status = NtAdjustPrivilegesToken(
                 Token,                            // TokenHandle
                 FALSE,                            // DisableAllPrivileges
                 NewState,                         // NewState
                 0,                                // BufferLength
                 NULL,                             // PreviousState (OPTIONAL)
                 &ReturnLength                     // ReturnLength
                 );
    ASSERTMSG("LSA/AU Cant enable CreateTokenPrivilege.", NT_SUCCESS(Status) );


    //
    // Clean up some stuff before returning
    //

    LsapFreeLsaHeap( NewState );
    Status = NtClose( Token );
    ASSERTMSG("LSA/AU Cant close process token.", NT_SUCCESS(Status) );


    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\aufilter.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    aufilter.c

Abstract:

    This module contains the famous LSA logon Filter/Augmentor logic.

Author:

    Jim Kelly (JimK) 11-Mar-1992

Revision History:

--*/

#include <lsapch2.h>
#include <adtp.h>
//#define LSAP_DONT_ASSIGN_DEFAULT_DACL

#define LSAP_CONTEXT_SID_USER_INDEX          0
#define LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX 1
#define LSAP_FIXED_POSITION_SID_COUNT        2
#define LSAP_MAX_STANDARD_IDS                7  // user, group, world, logontype, terminal server, authuser, organization

#define ALIGN_SIZEOF(_u,_v)                  FIELD_OFFSET( struct { _u _test1; _v  _test2; }, _test2 )
#define OFFSET_ALIGN(_p,_t)                  (_t *)(((INT_PTR)(((PBYTE)(_p))+TYPE_ALIGNMENT(_t) - 1)) & ~(TYPE_ALIGNMENT(_t)-1))


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Module local macros                                                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define LsapFreeSampUlongArray( A )                 \
{                                                   \
        if ((A)->Element != NULL) {                 \
            MIDL_user_free((A)->Element);           \
        }                                           \
}

#define IsTerminalServer() (BOOLEAN)(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer))


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Module-wide global variables                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//
// Indicates whether we have already opened SAM handles and initialized
// corresponding variables.
//

ULONG LsapAuSamOpened = FALSE;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Module local routine definitions                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

VOID
LsapAuSetLogonPrivilegeStates(
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES Privileges
    );

NTSTATUS
LsapAuSetPassedIds(
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN PVOID                      TokenInformation,
    IN PTOKEN_GROUPS              LocalGroups,
    IN ULONG                      FinalIdLimit,
    OUT PULONG                    FinalIdCount,
    OUT PSID_AND_ATTRIBUTES       FinalIds
    );

NTSTATUS
LsapSetDefaultDacl(
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN PVOID TokenInformation,
    OUT    PLSA_TOKEN_INFORMATION_V2 TokenInfo
    );

NTSTATUS
LsapAuAddStandardIds(
    IN SECURITY_LOGON_TYPE LogonType,
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN BOOLEAN fNullSessionRestricted,
    IN OPTIONAL PSID UserSid,
    IN ULONG FinalIdLimit,
    IN OUT PULONG FinalIdCount,
    IN OUT PSID_AND_ATTRIBUTES FinalIds
    );

NTSTATUS
LsapAuBuildTokenInfoAndAddLocalAliases(
    IN     LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN     PVOID               OldTokenInformation,
    IN     ULONG               HighRateIdCount,
    IN     ULONG               FinalIdCount,
    IN     PSID_AND_ATTRIBUTES FinalIds,
    OUT    PLSA_TOKEN_INFORMATION_V2 *TokenInfo,
    OUT    PULONG              TokenSize,
    IN     BOOL                RecoveryMode
    );

NTSTATUS
LsapGetAccountDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    );

NTSTATUS
LsapAuVerifyLogonType(
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG SystemAccess
    );

NTSTATUS
LsapAuSetTokenInformation(
    IN OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN OUT PVOID *TokenInformation,
    IN ULONG FinalIdCount,
    IN PSID_AND_ATTRIBUTES FinalIds,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN ULONG NewTokenInfoSize,
    IN OUT PLSA_TOKEN_INFORMATION_V2 *NewTokenInfo

    );

NTSTATUS
LsapAuDuplicateSid(
    PSID *Target,
    PSID Source
    );

BOOLEAN
LsapIsSidLogonSid(
    PSID Sid
    );

BOOL
LsapIsAdministratorRecoveryMode(
    IN PSID UserSid
    );

BOOLEAN
CheckNullSessionAccess(
    VOID
    );

BOOL
IsTerminalServerRA(
    VOID
    );

BOOLEAN
IsTSUSerSidEnabled(
   VOID
   );

BOOLEAN
CheckAdminOwnerSetting(
    VOID
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Routines                                                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

NTSTATUS
LsapAuUserLogonPolicyFilter(
    IN SECURITY_LOGON_TYPE          LogonType,
    IN PLSA_TOKEN_INFORMATION_TYPE  TokenInformationType,
    IN PVOID                       *TokenInformation,
    IN PTOKEN_GROUPS                LocalGroups,
    OUT PQUOTA_LIMITS               QuotaLimits,
    OUT PPRIVILEGE_SET             *PrivilegesAssigned,
    IN BOOL                         RecoveryMode
    )

/*++

Routine Description:

    This routine performs per-logon filtering and augmentation to
    implement local system security policies.  These policies include
    assignment of local aliases, privileges, and quotas.

    The basic logic flow of the filter augmentor is:

         1) Receive a set of user and group IDs that have already
            been assigned as a result of authentication.  Presumably
            these IDs have been provided by the authenticating
            security authority.


         2) Based upon the LogonType, add a set of standard IDs to the
            list.  This will include WORLD and an ID representing the
            logon type (e.g., INTERACTIVE, NETWORK, SERVICE).


         3) Call SAM to retrieve additional ALIAS IDs assigned by the
            local ACCOUNTS domain.


         4) Call SAM to retrieve additional ALIAS IDs assigned by the
            local BUILTIN domain.


         5) Retrieve any privileges and or quotas assigned to the resultant
            set of IDs.  This also informs us whether or not the specific
            type of logon is to be allowed.  Enable privs for network logons.


         6) If a default DACL has not already been established, assign
            one.


         7) Shuffle all high-use-rate IDs to preceed those that aren't
            high-use-rate to obtain maximum performance.

Arguments:

    LogonType - Specifies the type of logon being requested (e.g.,
        Interactive, network, et cetera).

    TokenInformationType - Indicates what format the provided set of
        token information is in.

    TokenInformation - Provides the set of user and group IDs.  This
        structure will be modified as necessary to incorporate local
        security policy (e.g., SIDs added or removed, privileges added
        or removed).

    QuotaLimits - Quotas assigned to the user logging on.

    RecoveryMode - if TRUE, this is an admin logon in recovery mode
                   and we already established that the administrator is a member
                   of way too many groups, so only minimal membership info
                   is returned.

                   Outside callers must ALWAYS set this parameter to FALSE

Return Value:

    STATUS_SUCCESS - The service has completed successfully.

    STATUS_INSUFFICIENT_RESOURCES - heap could not be allocated to house
        the combination of the existing and new groups.

    STATUS_INVALID_LOGON_TYPE - The value specified for LogonType is not
        a valid value.

    STATUS_LOGON_TYPE_NOT_GRANTED - Indicates the user has not been granted
        the requested type of logon by local security policy.  Logon should
        be rejected.
--*/

{
    NTSTATUS Status;

    BOOLEAN fNullSessionRestricted = FALSE;
    ULONG i;
    ULONG FinalIdCount = 0, FinalPrivilegeCount = 0;
    ULONG FinalIdLimit;
    PRIVILEGE_SET *FinalPrivileges = NULL;
    PTOKEN_PRIVILEGES pPrivs = NULL;
    LSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO AccountInfo;
    PSID  UserSid = NULL;

    SID_AND_ATTRIBUTES *FinalIds = NULL;
    PLSA_TOKEN_INFORMATION_V2  TokenInfo = NULL;
    ULONG TokenInfoSize = 0;

    //
    // Validate the Logon Type.
    //

    if ( (LogonType != Interactive) &&
         (LogonType != Network)     &&
         (LogonType != Service)     &&
         (LogonType != Batch)       &&
         (LogonType != NetworkCleartext) &&
         (LogonType != NewCredentials ) &&
         (LogonType != CachedInteractive) &&
         (LogonType != RemoteInteractive ) ) {

        Status = STATUS_INVALID_LOGON_TYPE;
        goto UserLogonPolicyFilterError;
    }

    //
    // Estimate the number of Final IDs
    //

    FinalIdLimit = LSAP_MAX_STANDARD_IDS;

    if ( *TokenInformationType == LsaTokenInformationNull ) {

        fNullSessionRestricted = CheckNullSessionAccess();

        if ( !fNullSessionRestricted ) {

            FinalIdLimit += 1;
        }

        if ((( PLSA_TOKEN_INFORMATION_NULL )( *TokenInformation ))->Groups ) {

            FinalIdLimit += (( PLSA_TOKEN_INFORMATION_NULL )( *TokenInformation ))->Groups->GroupCount;
        }

    } else if ( *TokenInformationType == LsaTokenInformationV1 ||
                *TokenInformationType == LsaTokenInformationV2 ) {

        //
        // Figure out the user's SID
        //

        UserSid = ((PLSA_TOKEN_INFORMATION_V2)( *TokenInformation ))->User.User.Sid;

        if ((( PLSA_TOKEN_INFORMATION_V2 )( *TokenInformation ))->Groups ) {

            FinalIdLimit += (( PLSA_TOKEN_INFORMATION_V2 )( *TokenInformation ))->Groups->GroupCount;
        }

        //
        // Get a local pointer to the privileges -- it'll be used below
        //

        pPrivs = ((PLSA_TOKEN_INFORMATION_V2) (*TokenInformation))->Privileges;

    } else {

        //
        // Unknown token information type
        //

        ASSERT( FALSE );
        Status = STATUS_INVALID_PARAMETER;
        goto UserLogonPolicyFilterError;
    }

    if ( LocalGroups ) {

        FinalIdLimit += LocalGroups->GroupCount;

        if ( RecoveryMode &&
             FinalIdLimit > LSAI_CONTEXT_SID_LIMIT )
        {
            //
            // If in recovery mode, trim the local group list as necessary
            //

            LocalGroups->GroupCount -= ( FinalIdLimit - LSAI_CONTEXT_SID_LIMIT );
            FinalIdLimit = LSAI_CONTEXT_SID_LIMIT;
        }
    }

    SafeAllocaAllocate(
        FinalIds,
        FinalIdLimit * sizeof( SID_AND_ATTRIBUTES )
        );

    if ( FinalIds == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto UserLogonPolicyFilterError;
    }

    //////////////////////////////////////////////////////////////////////////
    //                                                                      //
    // Build up a list of IDs and privileges to return                      //
    // This list is initialized to contain the set of IDs                   //
    // passed in.                                                           //
    //                                                                      //
    //////////////////////////////////////////////////////////////////////////

    // Leave room for SIDs that have a fixed position in the array.
    FinalIdCount = LSAP_FIXED_POSITION_SID_COUNT;

    //////////////////////////////////////////////////////////////////////////
    //                                                                      //
    // Build a list of low rate ID's from standard list                     //
    //                                                                      //
    //////////////////////////////////////////////////////////////////////////

    Status = LsapAuAddStandardIds(
                 LogonType,
                 (*TokenInformationType),
                 fNullSessionRestricted,
                 UserSid,
                 FinalIdLimit,
                 &FinalIdCount,
                 FinalIds
                 );

    if (!NT_SUCCESS(Status)) {

        goto UserLogonPolicyFilterError;
    }

    Status = LsapAuSetPassedIds(
                 (*TokenInformationType),
                 (*TokenInformation),
                 LocalGroups,
                 FinalIdLimit,
                 &FinalIdCount,
                 FinalIds
                 );

    if (!NT_SUCCESS(Status)) {

        goto UserLogonPolicyFilterError;
    }

    if ( FinalIdCount > LSAI_CONTEXT_SID_LIMIT ) {

        goto TooManyContextIds;
    }

    //////////////////////////////////////////////////////////////////////////
    //                                                                      //
    // Copy in aliases from the local domains (BUILT-IN and ACCOUNT)        //
    //                                                                      //
    //////////////////////////////////////////////////////////////////////////

    Status = LsapAuBuildTokenInfoAndAddLocalAliases(
                 (*TokenInformationType),
                 (*TokenInformation),
                 LSAP_FIXED_POSITION_SID_COUNT + (fNullSessionRestricted?0:1),
                 FinalIdCount,
                 FinalIds,
                 &TokenInfo,
                 &TokenInfoSize,
                 RecoveryMode
                 );

    if (!NT_SUCCESS(Status)) {

        goto UserLogonPolicyFilterError;
    }

    //////////////////////////////////////////////////////////////////////////
    //                                                                      //
    // Retrieve Privileges And Quotas                                       //
    //                                                                      //
    //////////////////////////////////////////////////////////////////////////

    //
    // Get the union of all Privileges, Quotas and System Accesses assigned
    // to the user's list of ids from the LSA Policy Database.
    //

    if ( TokenInfo->Groups->GroupCount + 1 > LSAI_CONTEXT_SID_LIMIT ) {

        goto TooManyContextIds;

    } else if ( TokenInfo->Groups->GroupCount + 1 > FinalIdLimit ) {

        SafeAllocaFree( FinalIds );
        FinalIdLimit = TokenInfo->Groups->GroupCount + 1;
        SafeAllocaAllocate( FinalIds, sizeof( SID_AND_ATTRIBUTES ) * FinalIdLimit );

        if ( FinalIds == NULL ) {

            Status = STATUS_NO_MEMORY;
            goto UserLogonPolicyFilterError;
        }
    }

    FinalIds[0] = TokenInfo->User.User;
    FinalIdCount = 1;

    for(i=0; i < TokenInfo->Groups->GroupCount; i++)
    {
        FinalIds[FinalIdCount] = TokenInfo->Groups->Groups[i];
        FinalIdCount++;
    }

    FinalPrivilegeCount = 0;

    Status = LsapDbQueryAllInformationAccounts(
                 (LSAPR_HANDLE) LsapPolicyHandle,
                 FinalIdCount,
                 FinalIds,
                 &AccountInfo
                 );

    if (!NT_SUCCESS(Status))
    {
        goto UserLogonPolicyFilterError;
    }

    //
    // Verify that we have the necessary System Access for our logon type.
    // We omit this check if we are using the NULL session.  Override the
    // privileges supplied by policy if they're explicitly set in the
    // token info (i.e., in the case where we've cloned an existing logon
    // session for a LOGON32_LOGON_NEW_CREDENTIALS logon).
    //

    if (pPrivs != NULL)
    {
        FinalPrivileges = (PPRIVILEGE_SET) MIDL_user_allocate(sizeof(PRIVILEGE_SET)
                                            + (pPrivs->PrivilegeCount - 1) * sizeof(LUID_AND_ATTRIBUTES));

        if (FinalPrivileges == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto UserLogonPolicyFilterError;
        }

        FinalPrivileges->PrivilegeCount = FinalPrivilegeCount = pPrivs->PrivilegeCount;
        FinalPrivileges->Control        = 0;

        RtlCopyMemory(FinalPrivileges->Privilege,
                      pPrivs->Privileges,
                      pPrivs->PrivilegeCount * sizeof(LUID_AND_ATTRIBUTES));

        MIDL_user_free( AccountInfo.PrivilegeSet );
    }
    else if (AccountInfo.PrivilegeSet != NULL)
    {
        FinalPrivileges = AccountInfo.PrivilegeSet;
        FinalPrivilegeCount = AccountInfo.PrivilegeSet->PrivilegeCount;
    }

    AccountInfo.PrivilegeSet = NULL;

    if (UserSid != NULL)
    {
        if (RtlEqualSid(UserSid, LsapLocalSystemSid))
        {
            AccountInfo.SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON |
                                       SECURITY_ACCESS_NETWORK_LOGON |
                                       SECURITY_ACCESS_BATCH_LOGON |
                                       SECURITY_ACCESS_SERVICE_LOGON |
                                       SECURITY_ACCESS_PROXY_LOGON |
                                       SECURITY_ACCESS_REMOTE_INTERACTIVE_LOGON ;
        }
        else if (RtlEqualSid(UserSid, LsapLocalServiceSid))
        {
            AccountInfo.SystemAccess = SECURITY_ACCESS_SERVICE_LOGON;
        }
        else if (RtlEqualSid(UserSid, LsapNetworkServiceSid))
        {
            AccountInfo.SystemAccess = SECURITY_ACCESS_SERVICE_LOGON;
        }
    }

    if (*TokenInformationType != LsaTokenInformationNull) {

        Status = LsapAuVerifyLogonType( LogonType, AccountInfo.SystemAccess );

        if (!NT_SUCCESS(Status)) {

            goto UserLogonPolicyFilterError;
        }
    }

    if (FinalPrivilegeCount > SEP_MAX_PRIVILEGE_COUNT)
    {
        ASSERT( FALSE ); // can't have more than the maximum defined number of privileges!
        Status = STATUS_INTERNAL_ERROR;
        goto UserLogonPolicyFilterError;
    }

#ifndef LSAP_DONT_ASSIGN_DEFAULT_DACL

    Status = LsapSetDefaultDacl( (*TokenInformationType),
                                 (*TokenInformation),
                                 TokenInfo
                                 );
    if (!NT_SUCCESS(Status)) {

        goto UserLogonPolicyFilterError;
    }

#endif //LSAP_DONT_ASSIGN_DEFAULT_DACL

    //
    // Now update the TokenInformation structure.
    // This causes all allocated IDs and privileges to be
    // freed (even if unsuccessful).
    //

    Status = LsapAuSetTokenInformation(
                 TokenInformationType,
                 TokenInformation,
                 FinalIdCount,
                 FinalIds,
                 FinalPrivilegeCount,
                 FinalPrivileges->Privilege,
                 TokenInfoSize,
                 &TokenInfo
                 );

    if (!NT_SUCCESS(Status)) {

        goto UserLogonPolicyFilterError;
    }

    //
    // Enable or Disable privileges according to our logon type
    // This is necessary until we get dynamic security tracking.
    //
    // ISSUE:  Skip this for NULL tokens?
    //

    if (pPrivs == NULL)
    {
        LsapAuSetLogonPrivilegeStates(
            LogonType,
            ((PLSA_TOKEN_INFORMATION_V2)(*TokenInformation))->Privileges->PrivilegeCount,
            ((PLSA_TOKEN_INFORMATION_V2)(*TokenInformation))->Privileges->Privileges
            );
    }

    //
    // Return these so they can be audited.  Data
    // will be freed in the caller.
    //

    *QuotaLimits = AccountInfo.QuotaLimits;
    *PrivilegesAssigned = FinalPrivileges;

UserLogonPolicyFilterFinish:

    if ( FinalIds )
    {
        SafeAllocaFree(FinalIds);
    }

    if(TokenInfo)
    {
        LsapFreeTokenInformationV2(TokenInfo);
    }

    return(Status);

UserLogonPolicyFilterError:

    //
    // If necessary, clean up Privileges buffer
    //

    if (FinalPrivileges != NULL) {

        MIDL_user_free( FinalPrivileges );
        FinalPrivileges = NULL;
    }

    goto UserLogonPolicyFilterFinish;

TooManyContextIds:

    if (( *TokenInformationType != LsaTokenInformationV1 &&
          *TokenInformationType != LsaTokenInformationV2 ) ||
         !LsapIsAdministratorRecoveryMode( UserSid )) {

        CHAR * UserSidText = NULL;

        Status = STATUS_TOO_MANY_CONTEXT_IDS;

        if ( UserSid ) {

            SafeAllocaAllocate( UserSidText, LsapDbGetSizeTextSid( UserSid ));
        }

        if ( UserSidText == NULL ||
             !NT_SUCCESS( LsapDbSidToTextSid( UserSid, UserSidText ))) {

            UserSidText = "<NULL>";
        }

        //
        // Log an event describing the problem and possible solutions
        //

        SpmpReportEvent(
            FALSE, // not UNICODE
            EVENTLOG_WARNING_TYPE,
            LSA_TOO_MANY_CONTEXT_IDS,
            0,
            0,
            NULL,
            1,
            UserSidText
            );

        if ( UserSid ) {

            SafeAllocaFree( UserSidText );
        }

        goto UserLogonPolicyFilterError;

    } else if ( RecoveryMode ) {

        //
        // Must never get to this point in recovery mode, or infinite recursion will result
        //

        ASSERT( FALSE );
        Status = STATUS_UNSUCCESSFUL;
        goto UserLogonPolicyFilterError;

    } else {

        LSA_TOKEN_INFORMATION_TYPE   TokenInformationTypeMin;
        PLSA_TOKEN_INFORMATION_V2    TokenInformationMin;
        QUOTA_LIMITS                 QuotaLimitsMin = {0};
        PPRIVILEGE_SET               PrivilegesAssignedMin = NULL;

        PLSA_TOKEN_INFORMATION_V2    TI = ( PLSA_TOKEN_INFORMATION_V2 )( *TokenInformation );

        ULONG MinimalGroupRidsDs[] = {
            DOMAIN_GROUP_RID_ADMINS,            // Domain admins
            };
        ULONG MinimalGroupCountDs = sizeof( MinimalGroupRidsDs ) / sizeof( MinimalGroupRidsDs[0] );

        ULONG MinimalGroupRidsNoDs[] = {
            DOMAIN_GROUP_RID_USERS,             // Domain users
            };
        ULONG MinimalGroupCountNoDs = sizeof( MinimalGroupRidsNoDs ) / sizeof( MinimalGroupRidsNoDs[0] );

        ULONG * MinimalGroupRids;
        ULONG MinimalGroupCount;
        ULONG MinimalLocalGroupCount;

        ULONG UserSidLen = RtlLengthSid( UserSid );

        PTOKEN_GROUPS NewLocalGroups = NULL;
        ULONG SwapLoc = 0;

        TokenInformationTypeMin = *TokenInformationType;

        TokenInformationMin = ( PLSA_TOKEN_INFORMATION_V2 )LsapAllocateLsaHeap( sizeof( LSA_TOKEN_INFORMATION_V2));

        if ( TokenInformationMin == NULL ) {

            Status = STATUS_NO_MEMORY;
            goto UserLogonPolicyFilterError;
        }

        //
        // ExpirationTime
        //

        TokenInformationMin->ExpirationTime = TI->ExpirationTime;

        //
        // User
        //

        TokenInformationMin->User.User.Attributes = TI->User.User.Attributes;

        if ( TI->User.User.Sid ) {

            Status = LsapAuDuplicateSid(
                         &TokenInformationMin->User.User.Sid,
                         TI->User.User.Sid
                         );

            if ( !NT_SUCCESS( Status )) {

                goto UserLogonPolicyFilterError;
            }

        } else {

            ASSERT( FALSE ); // don't believe this is possible
            TokenInformationMin->User.User.Sid = NULL;
        }

        //
        // Groups
        //
        //  If DS is not running, add DOMAIN_GROUP_RID_USERS only
        //  If DS is running, add DOMAIN_GROUP_RID_ADMINS
        //

        if ( LsapDsIsRunning ) {

            MinimalGroupRids = MinimalGroupRidsDs;
            MinimalGroupCount = MinimalGroupCountDs;

        } else {

            MinimalGroupRids = MinimalGroupRidsNoDs;
            MinimalGroupCount = MinimalGroupCountNoDs;
        }

        TokenInformationMin->Groups = ( PTOKEN_GROUPS )LsapAllocateLsaHeap( sizeof( TOKEN_GROUPS ) + ( MinimalGroupCount - 1 ) * sizeof( SID_AND_ATTRIBUTES ));

        if ( TokenInformationMin->Groups == NULL ) {

            Status = STATUS_NO_MEMORY;
            goto UserLogonPolicyFilterError;
        }

        TokenInformationMin->Groups->GroupCount = 0;

        for ( i = 0 ; i < MinimalGroupCount ; i++ ) {

            SID * Sid;

            Sid = ( SID * )LsapAllocateLsaHeap( UserSidLen );

            if ( Sid == NULL ) {

                Status = STATUS_NO_MEMORY;
                goto UserLogonPolicyFilterError;
            }

            RtlCopySid( UserSidLen, Sid, UserSid );

            Sid->SubAuthority[Sid->SubAuthorityCount-1] = MinimalGroupRids[i];

            TokenInformationMin->Groups->Groups[i].Attributes = SE_GROUP_MANDATORY |
                                                                SE_GROUP_ENABLED_BY_DEFAULT |
                                                                SE_GROUP_ENABLED;
            TokenInformationMin->Groups->Groups[i].Sid = ( PSID )Sid;
            TokenInformationMin->Groups->GroupCount++;
        }

        //
        // PrimaryGroup
        //

        if ( TI->PrimaryGroup.PrimaryGroup ) {

            Status = LsapAuDuplicateSid(
                         &TokenInformationMin->PrimaryGroup.PrimaryGroup,
                         TI->PrimaryGroup.PrimaryGroup
                         );

            if ( !NT_SUCCESS( Status )) {

                goto UserLogonPolicyFilterError;
            }

        } else {

            TokenInformationMin->PrimaryGroup.PrimaryGroup = NULL;
        }

        //
        // Privileges
        //

        TokenInformationMin->Privileges = NULL;

        //
        // Owner
        //

        if ( TI->Owner.Owner ) {

            Status = LsapAuDuplicateSid(
                         &TokenInformationMin->Owner.Owner,
                         TI->Owner.Owner
                         );

            if ( !NT_SUCCESS( Status )) {

                goto UserLogonPolicyFilterError;
            }

        } else {

            TokenInformationMin->Owner.Owner = NULL;
        }

        //
        // DefaultDacl
        //

        TokenInformationMin->DefaultDacl.DefaultDacl = NULL;

        if ( LocalGroups ) {

            //
            // Rearrange the local groups to put the logon groups first -
            // in case the list might have to be trimmed during the recursion pass
            //

            NewLocalGroups = (PTOKEN_GROUPS)LsapAllocateLsaHeap( sizeof( TOKEN_GROUPS ) + ( LocalGroups->GroupCount - ANYSIZE_ARRAY ) * sizeof( SID_AND_ATTRIBUTES ));

            if ( NewLocalGroups == NULL )
            {
                Status = STATUS_NO_MEMORY;
                goto UserLogonPolicyFilterError;
            }

            NewLocalGroups->GroupCount = LocalGroups->GroupCount;

            RtlCopyMemory(
                NewLocalGroups->Groups,
                LocalGroups->Groups,
                LocalGroups->GroupCount * sizeof( SID_AND_ATTRIBUTES ));

            for ( i = 1; i < NewLocalGroups->GroupCount; i++ )
            {
                SID_AND_ATTRIBUTES Temp;

                if ( NewLocalGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID )
                {
                    Temp = NewLocalGroups->Groups[SwapLoc];
                    NewLocalGroups->Groups[SwapLoc] = NewLocalGroups->Groups[i];
                    NewLocalGroups->Groups[i] = Temp;
                    SwapLoc += 1;
                }
            }
        }

        //
        // Ok, the minimal information has been built, we're off to the races
        // Call ourselves recursively and steal the results
        //

        Status = LsapAuUserLogonPolicyFilter(
                     LogonType,
                     &TokenInformationTypeMin,
                     &TokenInformationMin,
                     NewLocalGroups,
                     &QuotaLimitsMin,
                     &PrivilegesAssignedMin,
                     TRUE
                     );

        *TokenInformationType = TokenInformationTypeMin;
        *TokenInformation = TokenInformationMin;
        *QuotaLimits = QuotaLimitsMin;
        *PrivilegesAssigned = PrivilegesAssignedMin;

        LsapFreeLsaHeap( NewLocalGroups );

        //
        // We're prepared for anything but this, as it would
        // put us into a recursive loop without end!
        //

        if ( Status == STATUS_TOO_MANY_CONTEXT_IDS ) {

            //
            // This must NEVER happen, as this is a sure recipe for
            // infinite recursion.  Assert in CHK, clear the error
            // code and replace with something else in FRE
            //

            ASSERT( FALSE ); // we'll never get here, right?
            Status = STATUS_UNSUCCESSFUL;
        }

        if ( !NT_SUCCESS( Status )) {

            goto UserLogonPolicyFilterError;

        } else {

            goto UserLogonPolicyFilterFinish;
        }
    }
}


NTSTATUS
LsapAuVerifyLogonType(
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG SystemAccess
    )

/*++

Routine Description:

    This function verifies that a User has the system access granted necessary
    for the speicifed logon type.

Arguments

    LogonType - Specifies the type of logon being requested (e.g.,
        Interactive, network, et cetera).

    SystemAccess - Specifies the System Access granted to the User.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The user has the necessary system access.

        STATUS_LOGON_TYPE_NOT_GRANTED - Indicates the specified type of logon
            has not been granted to any of the IDs in the passed set.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Determine if the specified Logon Type is granted by any of the
    // groups or aliases specified.
    //

    switch (LogonType) {

    case Interactive:
    case CachedInteractive:

        if (!(SystemAccess & SECURITY_ACCESS_INTERACTIVE_LOGON) ||
            (SystemAccess & SECURITY_ACCESS_DENY_INTERACTIVE_LOGON)) {

            Status = STATUS_LOGON_TYPE_NOT_GRANTED;
        }

        break;

    case NewCredentials:

        //
        // NewCredentials does not require a logon type, since this is a dup
        // of someone who has logged on already somewhere else.
        //

        NOTHING;

        break;

    case Network:
    case NetworkCleartext:

        if (!(SystemAccess & SECURITY_ACCESS_NETWORK_LOGON)||
            (SystemAccess & SECURITY_ACCESS_DENY_NETWORK_LOGON)) {

            Status = STATUS_LOGON_TYPE_NOT_GRANTED;
        }

        break;

    case Batch:

        if ((SystemAccess & SECURITY_ACCESS_DENY_BATCH_LOGON) ||
            !(SystemAccess & SECURITY_ACCESS_BATCH_LOGON)) {

            Status = STATUS_LOGON_TYPE_NOT_GRANTED;
        }

        break;

    case Service:

        if ((SystemAccess & SECURITY_ACCESS_DENY_SERVICE_LOGON) ||
            !(SystemAccess & SECURITY_ACCESS_SERVICE_LOGON)) {

            Status = STATUS_LOGON_TYPE_NOT_GRANTED;
        }

        break;

    case RemoteInteractive:
        if ( ( SystemAccess & SECURITY_ACCESS_DENY_REMOTE_INTERACTIVE_LOGON ) ||
             ! ( SystemAccess & SECURITY_ACCESS_REMOTE_INTERACTIVE_LOGON ) ) {

            Status = STATUS_LOGON_TYPE_NOT_GRANTED ;
        }
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    return(Status);
}


NTSTATUS
LsapAuSetPassedIds(
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN PVOID                      TokenInformation,
    IN PTOKEN_GROUPS              LocalGroups,
    IN ULONG                      FinalIdLimit,
    OUT PULONG                    FinalIdCount,
    OUT PSID_AND_ATTRIBUTES       FinalIds
    )

/*++

Routine Description:

    This routine initializes the FinalIds array.

Arguments:

    TokenInformationType - Indicates what format the provided set of
        token information is in.

    TokenInformation - Provides the initial set of user and group IDs.

    FinalIdCount - Will be set to contain the number of IDs passed.

    FinalIds - will contain the set of IDs passed in.

    IdProperties - Will be set to indicate none of the initial
        IDs were locally allocated.  It will also identify the
        first two ids (if there are two ids) to be HIGH_RATE.

Return Value:

    STATUS_SUCCESS - Succeeded.

--*/

{
    ULONG i, j;
    PTOKEN_USER   User;
    PTOKEN_GROUPS Groups;
    PTOKEN_PRIMARY_GROUP PrimaryGroup;
    PSID PrimaryGroupSid = NULL;
    PULONG PrimaryGroupAttributes = NULL;
    ULONG CurrentId = 0;
    ULONG ThisOrgIndex;
    PTOKEN_GROUPS GroupsArray[2];
    ULONG GroupsArraySize = 0;

    //
    // Get the passed ids
    //

    ASSERT(  (TokenInformationType == LsaTokenInformationNull ) ||
             (TokenInformationType == LsaTokenInformationV1) ||
             (TokenInformationType == LsaTokenInformationV2));

    if (TokenInformationType == LsaTokenInformationNull) {
        User = NULL;
        Groups = ((PLSA_TOKEN_INFORMATION_NULL)(TokenInformation))->Groups;
        PrimaryGroup = NULL;
    } else {
        User = &((PLSA_TOKEN_INFORMATION_V2)TokenInformation)->User;
        Groups = ((PLSA_TOKEN_INFORMATION_V2)TokenInformation)->Groups;
        PrimaryGroup = &((PLSA_TOKEN_INFORMATION_V2)TokenInformation)->PrimaryGroup;
    }

    if (User != NULL) {

        //
        // TokenInformation included a user ID.
        //

        FinalIds[LSAP_CONTEXT_SID_USER_INDEX] = User->User;

    }
    else
    {
        // Set the user as anonymous

        FinalIds[LSAP_CONTEXT_SID_USER_INDEX].Sid = LsapAnonymousSid;
        FinalIds[LSAP_CONTEXT_SID_USER_INDEX].Attributes = (SE_GROUP_MANDATORY   |
                                                            SE_GROUP_ENABLED_BY_DEFAULT |
                                                            SE_GROUP_ENABLED
                                                           );
    }

    if ( PrimaryGroup != NULL )
    {
        //
        // TokenInformation included a primary group ID.
        //

        FinalIds[LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX].Sid = PrimaryGroup->PrimaryGroup;
        FinalIds[LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX].Attributes = (SE_GROUP_MANDATORY   |
                                                            SE_GROUP_ENABLED_BY_DEFAULT |
                                                            SE_GROUP_ENABLED
                                                            );

        //
        // Store a pointer to the attributes and the sid so we can later
        // fill in the attributes from the rest of the group memebership.
        //

        PrimaryGroupAttributes = &FinalIds[LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX].Attributes;
        PrimaryGroupSid = PrimaryGroup->PrimaryGroup;
    }
    else
    {
        FinalIds[LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX].Sid = LsapNullSid;
        FinalIds[LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX].Attributes = 0;
    }

    if ( LocalGroups ) {

        GroupsArray[GroupsArraySize++] = LocalGroups;
    }

    if ( Groups ) {

        GroupsArray[GroupsArraySize++] = Groups;
    }

    CurrentId = (*FinalIdCount);

    //
    // Assume "this organization".  If this assumption proves incorrect,
    // the SID will be overwritten later.
    //

    ASSERT( CurrentId < FinalIdLimit );
    FinalIds[CurrentId].Sid = LsapThisOrganizationSid;
    FinalIds[CurrentId].Attributes = SE_GROUP_MANDATORY |
                                     SE_GROUP_ENABLED_BY_DEFAULT |
                                     SE_GROUP_ENABLED;
    ThisOrgIndex = CurrentId;
    CurrentId++;

    for ( j = 0; j < GroupsArraySize; j++ ) {

        PTOKEN_GROUPS CurrentGroups = GroupsArray[j];

        for ( i = 0; i < CurrentGroups->GroupCount; i++ ) {

            //
            // If the "other org" sid was passed,
            //  replace the "this org" sid and attributes with the one passed.
            //

            if ( RtlEqualSid(
                     LsapOtherOrganizationSid,
                     CurrentGroups->Groups[i].Sid )) {

                FinalIds[ThisOrgIndex] = CurrentGroups->Groups[i];


            } else if ( PrimaryGroupSid != NULL &&
                        RtlEqualSid(
                            PrimaryGroupSid,
                            CurrentGroups->Groups[i].Sid )) {

                //
                // If this sid is the primary group, it is already in the list
                // of final IDs but we need to add the attribute
                //

                *PrimaryGroupAttributes = CurrentGroups->Groups[i].Attributes;

            } else {

                ASSERT( CurrentId < FinalIdLimit );

                //
                // Ownership of the SID remains with the LocalGroups structure, which
                // will be freed by the caller
                //

                FinalIds[CurrentId] = CurrentGroups->Groups[i];

                //
                // if this SID is a logon SID, then set the SE_GROUP_LOGON_ID
                // attribute
                //

                if (LsapIsSidLogonSid(FinalIds[CurrentId].Sid) == TRUE)  {

                    FinalIds[CurrentId].Attributes |= SE_GROUP_LOGON_ID;
                }

                CurrentId++;
            }
        }
    }

    (*FinalIdCount) = CurrentId;

    return STATUS_SUCCESS;
}



NTSTATUS
LsapSetDefaultDacl(
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN PVOID TokenInformation,
    IN OUT PLSA_TOKEN_INFORMATION_V2 TokenInfo
    )

/*++

Routine Description:

    This routine produces a default DACL if the existing TokenInformation
    does not already have one.  NULL logon types don't have default DACLs
    and so this routine simply returns success for those logon types.


    The default DACL will be:

            SYSTEM: ALL Access
            Owner:  ALL Access

            !! IMPORTANT  !! IMPORTANT  !! IMPORTANT  !! IMPORTANT  !!

                NOTE: The FinalOwnerIndex should not be changed after
                      calling this routine.

            !! IMPORTANT  !! IMPORTANT  !! IMPORTANT  !! IMPORTANT  !!

Arguments:

    TokenInformationType - Indicates what format the provided set of
        token information is in.

    TokenInformation - Points to token information which has the current
        default DACL.

Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_NO_MEMORY - Indicates there was not enough heap memory available
        to allocate the default DACL.

--*/

{
    NTSTATUS Status;
    PACL Acl;
    ULONG Length;
    PLSA_TOKEN_INFORMATION_V2 CastTokenInformation;
    PSID OwnerSid = NULL;

    //
    // NULL token information?? (has no default dacl)
    //

    if (TokenInformationType == LsaTokenInformationNull) {

        return(STATUS_SUCCESS);
    }

    ASSERT((TokenInformationType == LsaTokenInformationV1) ||
           (TokenInformationType == LsaTokenInformationV2));

    CastTokenInformation = (PLSA_TOKEN_INFORMATION_V2)TokenInformation;

    //
    // Already have a default DACL?
    //

    Acl = CastTokenInformation->DefaultDacl.DefaultDacl;

    if (Acl != NULL) {

        ACL_SIZE_INFORMATION AclSize;

        Status = RtlQueryInformationAcl(Acl,
                                        &AclSize,
                                        sizeof(AclSize),
                                        AclSizeInformation);

        if (!NT_SUCCESS(Status)) {

            return Status;
        }

        RtlCopyMemory(TokenInfo->DefaultDacl.DefaultDacl, Acl,AclSize.AclBytesFree +  AclSize.AclBytesInUse);

        return(STATUS_SUCCESS);
    }

    Acl = TokenInfo->DefaultDacl.DefaultDacl;

    OwnerSid = TokenInfo->Owner.Owner?TokenInfo->Owner.Owner:TokenInfo->User.User.Sid;

    Length      =  sizeof(ACL) +
                (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) +
                RtlLengthSid(OwnerSid)  +
                RtlLengthSid( LsapLocalSystemSid );

    Status = RtlCreateAcl( Acl, Length, ACL_REVISION2);

    if(!NT_SUCCESS(Status) )
    {
        goto error;
    }

    //
    // OWNER access - put this one first for performance sake
    //

    Status = RtlAddAccessAllowedAce (
                 Acl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 OwnerSid
                 );

    if(!NT_SUCCESS(Status) )
    {
        goto error;
    }

    //
    // SYSTEM access
    //

    Status = RtlAddAccessAllowedAce (
                 Acl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 LsapLocalSystemSid
                 );
error:

    return(Status);
}


NTSTATUS
LsapAuAddStandardIds(
    IN SECURITY_LOGON_TYPE LogonType,
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN BOOLEAN fNullSessionRestricted,
    IN OPTIONAL PSID UserSid,
    IN ULONG FinalIdLimit,
    IN OUT PULONG FinalIdCount,
    IN OUT PSID_AND_ATTRIBUTES FinalIds
    )

/*++

Routine Description:

    This routine adds standard IDs to the FinalIds array.

    This causes the WORLD id to be added and an ID representing
    logon type to be added.

    For anonymous logons, it will also add the ANONYMOUS id.


Arguments:


    LogonType - Specifies the type of logon being requested (e.g.,
        Interactive, network, et cetera).

    TokenInformationType - The token information type returned by
        the authentication package.  The set of IDs added is dependent
        upon the type of logon.

    FinalIdCount - Will be incremented to reflect newly added IDs.

    FinalIds - will have new IDs added to it.

    IdProperties - Will be set to indicate that these IDs must be
        copied and that WORLD is a high-hit-rate id.


Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_TOO_MANY_CONTEXT_IDS - There are too many IDs in the context.

--*/

{
    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT( LSAP_MAX_STANDARD_IDS <= FinalIdLimit );
    ASSERT( *FinalIdCount < FinalIdLimit );

    i = (*FinalIdCount);

    if( !fNullSessionRestricted ) {

        // This is a high rate id, so add it to the front of the array
        FinalIds[i].Sid = LsapWorldSid;
        FinalIds[i].Attributes = (SE_GROUP_MANDATORY          |
                                  SE_GROUP_ENABLED_BY_DEFAULT |
                                  SE_GROUP_ENABLED
                                  );
        i++;
    }

    //
    // Add Logon type SID
    //

    switch ( LogonType ) {
    case Interactive:
    case NewCredentials:
    case CachedInteractive:

        FinalIds[i].Sid = LsapInteractiveSid;
        break;

    case RemoteInteractive:
        FinalIds[i].Sid = LsapRemoteInteractiveSid;
        break;

    case Network:
    case NetworkCleartext:
        FinalIds[i].Sid = LsapNetworkSid;
        break;

    case Batch:
        FinalIds[i].Sid = LsapBatchSid;
        break;

    case Service:
        FinalIds[i].Sid = LsapServiceSid;
        break;

    default:
        ASSERT("Unknown new logon type in LsapAuAddStandardIds" && FALSE);
    }


    if ( FinalIds[ i ].Sid )
    {
        FinalIds[i].Attributes = (SE_GROUP_MANDATORY          |
                                  SE_GROUP_ENABLED_BY_DEFAULT |
                                  SE_GROUP_ENABLED
                                  );
        i++;
    }

    //
    // Add SIDs that are required when TS is running.
    //
    if ( IsTerminalServer() )
    {
        switch ( LogonType )
        {
        case RemoteInteractive:

            //
            // check to see if we are suppose to add the INTERACTIVE SID to the remote session
            // for console level app compatability.
            //

            FinalIds[i].Sid = LsapInteractiveSid;
            FinalIds[i].Attributes = (SE_GROUP_MANDATORY          |
                                      SE_GROUP_ENABLED_BY_DEFAULT |
                                      SE_GROUP_ENABLED
                                      );
            i++;

            //
            // fall thru
            //

        case Interactive :
        case NewCredentials:
        case CachedInteractive:

            // check to see if we are suppose to add the TSUSER SID to the session. This
            // is for TS4-app-compatability security mode.

            if ( IsTSUSerSidEnabled() )
            {
                //
                // Don't add TSUSER sid for GUEST logon
                //
                if ( ( TokenInformationType != LsaTokenInformationNull ) &&
                     ( UserSid ) &&
                     ( *RtlSubAuthorityCountSid( UserSid ) > 0 ) &&
                     ( *RtlSubAuthoritySid( UserSid,
                               (ULONG) (*RtlSubAuthorityCountSid( UserSid ) ) - 1) != DOMAIN_USER_RID_GUEST ) )
                {
                    FinalIds[i].Sid = LsapTerminalServerSid;
                    FinalIds[i].Attributes = (SE_GROUP_MANDATORY          |
                                               SE_GROUP_ENABLED_BY_DEFAULT |
                                               SE_GROUP_ENABLED
                                               );
                    i++;
                }
            }
        }   // logon type switch for TS SIDs
    } // if TS test

    //
    // If this is a not a null logon, and not a GUEST logon,
    // then add in the AUTHENTICATED USER SID.
    //

    if ( ( TokenInformationType != LsaTokenInformationNull ) &&
         ( UserSid ) &&
         ( *RtlSubAuthorityCountSid( UserSid ) > 0 ) &&
         ( *RtlSubAuthoritySid( UserSid,
                   (ULONG) (*RtlSubAuthorityCountSid( UserSid ) ) - 1) != DOMAIN_USER_RID_GUEST ) )
    {
        FinalIds[i].Sid = LsapAuthenticatedUserSid;         //Use the global SID
        FinalIds[i].Attributes = (SE_GROUP_MANDATORY          |
                                  SE_GROUP_ENABLED_BY_DEFAULT |
                                  SE_GROUP_ENABLED
                                  );
        i++;
    }

    (*FinalIdCount) = i;

    ASSERT( *FinalIdCount <= FinalIdLimit );

    return(Status);
}


NTSTATUS
LsapAuBuildTokenInfoAndAddLocalAliases(
    IN     LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN     PVOID               OldTokenInformation,
    IN     ULONG               HighRateIdCount,
    IN     ULONG               FinalIdCount,
    IN     PSID_AND_ATTRIBUTES FinalIds,
    OUT    PLSA_TOKEN_INFORMATION_V2 *TokenInfo,
    OUT    PULONG              TokenInfoSize,
    IN     BOOL                RecoveryMode
    )

/*++

Routine Description:

    This routine adds aliases assigned to the IDs in FinalIds.

    This will look in both the BUILT-IN and ACCOUNT domains locally.


        1) Adds aliases assigned to the user via the local ACCOUNTS
           domain.

        2) Adds aliases assigned to the user via the local BUILT-IN
           domain.

        3) If the ADMINISTRATORS alias is assigned to the user, then it
           is made the user's default owner.


    NOTE:  Aliases, by their nature, are expected to be high-use-rate
           IDs.

Arguments:


    FinalIdCount - Will be incremented to reflect any newly added IDs.

    FinalIds - will have any assigned alias IDs added to it.

    IdProperties - Will be set to indicate that any aliases added were
        allocated by this routine.

    RecoveryMode - if TRUE, this is an admin logon in recovery mode
                   and we already established that the administrator is a member
                   of way too many groups, so only minimal membership info
                   is returned.

Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_TOO_MANY_CONTEXT_IDS - There are too many IDs in the context.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS, SuccessExpected;
    ULONG i;
    SAMPR_SID_INFORMATION *SidArray = NULL;
    SAMPR_ULONG_ARRAY AccountMembership, BuiltinMembership;
    SAMPR_PSID_ARRAY SamprSidArray;

    ULONG                       TokenSize = 0;
    PLSA_TOKEN_INFORMATION_V2   NewTokenInfo = NULL;
    PSID_AND_ATTRIBUTES         GroupArray = NULL;

    PBYTE                       CurrentSid = NULL;
    ULONG                       CurrentSidLength = 0;
    ULONG                       CurrentGroup = 0;

    PLSA_TOKEN_INFORMATION_V2   OldTokenInfo = NULL;
    ULONG                       DefaultDaclSize = 0;

    PSID                        SidPackage[1] = { NULL };   // room for only one
    BYTE                        SidPackageBuffer[ SECURITY_MAX_SID_SIZE ];
    ULONG                       SidPackageCount = 0;

    if((TokenInformationType == LsaTokenInformationV1) ||
       (TokenInformationType == LsaTokenInformationV2))
    {
        OldTokenInfo = (PLSA_TOKEN_INFORMATION_V2)OldTokenInformation;
    }

    //
    // Make sure SAM has been opened.  We'll get hadnles to both of the
    // SAM Local Domains.
    //

    Status = LsapAuOpenSam( FALSE );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    SafeAllocaAllocate( SidArray, (FinalIdCount * sizeof(SAMPR_SID_INFORMATION)) );
    if( SidArray == NULL )
    {
        return STATUS_NO_MEMORY;
    }

    for ( i=0; i<FinalIdCount; i++) {

        SidArray[i].SidPointer = (PRPC_SID)FinalIds[i].Sid;
    }

    SamprSidArray.Count = FinalIdCount;
    SamprSidArray.Sids  = &SidArray[0];

    //
    // For the given set of Sids, obtain their collective membership of
    // Aliases in the Accounts domain
    //

    AccountMembership.Count = 0;
    AccountMembership.Element = NULL;

    Status = SamIGetAliasMembership( LsapAccountDomainHandle,
                                     &SamprSidArray,
                                     &AccountMembership
                                     );

    if (!NT_SUCCESS(Status)) {

        SafeAllocaFree( SidArray );
        SidArray = NULL;
        return(Status);

    } else if ( RecoveryMode ) {

        //
        // Only leave built-in RIDs in the array
        //

        for ( i = AccountMembership.Count; i > 0; i-- ) {

            if ( AccountMembership.Element[i-1] > SAMI_RESTRICTED_ACCOUNT_COUNT ) {

                AccountMembership.Element[i-1] = AccountMembership.Element[AccountMembership.Count-1];
                AccountMembership.Count -= 1;
            }
        }
    }

    //
    // For the given set of Sids, obtain their collective membership of
    // Aliases in the Built-In domain
    //

    BuiltinMembership.Count = 0;
    BuiltinMembership.Element = NULL;
    Status = SamIGetAliasMembership( LsapBuiltinDomainHandle,
                                     &SamprSidArray,
                                     &BuiltinMembership
                                     );

    if (!NT_SUCCESS(Status)) {

        LsapFreeSampUlongArray( &AccountMembership );
        SafeAllocaFree( SidArray );
        SidArray = NULL;

        return(Status);

    } else if ( RecoveryMode ) {

        //
        // Only leave built-in RIDs in the array
        //

        for ( i = BuiltinMembership.Count; i > 0; i-- ) {

            if ( BuiltinMembership.Element[i-1] > SAMI_RESTRICTED_ACCOUNT_COUNT ) {

                BuiltinMembership.Element[i-1] = BuiltinMembership.Element[BuiltinMembership.Count-1];
                BuiltinMembership.Count -= 1;
            }
        }
    }

    //
    // check for a package sid.
    //

    {
        ULONG_PTR PackageId = GetCurrentPackageId();
        DWORD dwRPCID;

        if( PackageId )
        {
            dwRPCID = SpmpGetRpcPackageId( PackageId );

            //
            // if there was a valid package, craft a sid for it.
            // don't do so for Kerberos at this time, as, cross-protocol
            // delegation needs to be addressed.
            //

            if( (dwRPCID != 0) &&
                (dwRPCID != SECPKG_ID_NONE) &&
                (dwRPCID != RPC_C_AUTHN_GSS_KERBEROS)
                )
            {
                SID_IDENTIFIER_AUTHORITY PackageSidAuthority = SECURITY_NT_AUTHORITY;

                SidPackage[0] = (PSID)SidPackageBuffer;

                RtlInitializeSid(SidPackage[0], &PackageSidAuthority, 2);
                *(RtlSubAuthoritySid(SidPackage[0], 0)) = SECURITY_PACKAGE_BASE_RID;
                *(RtlSubAuthoritySid(SidPackage[0], 1)) = dwRPCID;

                SidPackageCount = 1;
            }
        }
    }

    //
    // Allocate memory to build the tokeninfo
    //

    // Calculate size of resulting tokeninfo

    CurrentSidLength = RtlLengthSid( FinalIds[0].Sid);

    // Size the base structure and group array
    TokenSize = ALIGN_SIZEOF(LSA_TOKEN_INFORMATION_V2, TOKEN_GROUPS) +
                sizeof(TOKEN_GROUPS) +
                (AccountMembership.Count +
                 BuiltinMembership.Count +
                 SidPackageCount +
                 FinalIdCount - 1 - ANYSIZE_ARRAY) * sizeof(SID_AND_ATTRIBUTES); // Do not include the User SID in this array


    // Sids are ULONG aligned, whereas the SID_AND_ATTRIBUTES should be ULONG or greater aligned
    TokenSize += CurrentSidLength +
                 LsapAccountDomainMemberSidLength*AccountMembership.Count +
                 LsapBuiltinDomainMemberSidLength*BuiltinMembership.Count;

    // Add in size of all passed in/standard sids
    for(i=1; i < FinalIdCount; i++)
    {
        TokenSize += RtlLengthSid( FinalIds[i].Sid);
    }

    for(i=0; i < SidPackageCount ;i++)
    {
        TokenSize += RtlLengthSid( SidPackage[i] );
    }

    // Add the size for the DACL
    if(OldTokenInfo)
    {
        if(OldTokenInfo->DefaultDacl.DefaultDacl)
        {
            ACL_SIZE_INFORMATION AclSize;

            Status = RtlQueryInformationAcl(OldTokenInfo->DefaultDacl.DefaultDacl,
                                            &AclSize,
                                            sizeof(AclSize),
                                            AclSizeInformation);

            if (!NT_SUCCESS(Status)) {

                goto Cleanup;
            }
            DefaultDaclSize = AclSize.AclBytesFree + AclSize.AclBytesInUse;
        }
        else
        {

         DefaultDaclSize =  sizeof(ACL) +                                          // Default ACL
                (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) +
                max(CurrentSidLength, LsapBuiltinDomainMemberSidLength) +
                RtlLengthSid( LsapLocalSystemSid );
        }
        TokenSize = PtrToUlong(OFFSET_ALIGN((ULONG_PTR)TokenSize, ACL)) + DefaultDaclSize;
    }

    // Add the privilege estimate
    TokenSize = PtrToUlong(
                    (PVOID) ((INT_PTR) OFFSET_ALIGN((ULONG_PTR)TokenSize, TOKEN_PRIVILEGES) +
                             sizeof(TOKEN_PRIVILEGES) +                  // Prealloc some room for privileges
                             (sizeof(LUID_AND_ATTRIBUTES) * (SEP_MAX_PRIVILEGE_COUNT - ANYSIZE_ARRAY))));



    NewTokenInfo = (PLSA_TOKEN_INFORMATION_V2)LsapAllocateLsaHeap(TokenSize);
    if(NULL == NewTokenInfo)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(NewTokenInfo, TokenSize);

    // Fixup pointers
    NewTokenInfo->Groups = (PTOKEN_GROUPS)OFFSET_ALIGN((NewTokenInfo + 1), TOKEN_GROUPS);
    NewTokenInfo->Groups->GroupCount = AccountMembership.Count +
                                       BuiltinMembership.Count +
                                       SidPackageCount +
                                       FinalIdCount - 1;

    CurrentSid = (PBYTE)(&NewTokenInfo->Groups->Groups[NewTokenInfo->Groups->GroupCount]);

    // Copy user sid
    SuccessExpected = RtlCopySid(CurrentSidLength, CurrentSid, FinalIds[0].Sid);
    ASSERT( NT_SUCCESS( SuccessExpected ));
    NewTokenInfo->User.User.Sid  = (PSID)CurrentSid;
    NewTokenInfo->User.User.Attributes = FinalIds[0].Attributes;
    CurrentSid += CurrentSidLength;

    GroupArray = NewTokenInfo->Groups->Groups;

    // Copy high rate sids to array (they are static globals, so they don't need to be copied into buffer)
    for(i=1; i < HighRateIdCount; i++)
    {
        CurrentSidLength = RtlLengthSid( FinalIds[i].Sid);
        SuccessExpected = RtlCopySid(CurrentSidLength, CurrentSid, FinalIds[i].Sid);
        ASSERT( NT_SUCCESS( SuccessExpected ));
        GroupArray[CurrentGroup].Sid = CurrentSid;
        GroupArray[CurrentGroup].Attributes = FinalIds[i].Attributes;
        CurrentGroup++;
        CurrentSid += CurrentSidLength;
    }

    NewTokenInfo->PrimaryGroup.PrimaryGroup = GroupArray[LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX-1].Sid;

    //
    // Copy Account Aliases
    //

    for ( i=0; i<AccountMembership.Count; i++) {

        SuccessExpected = RtlCopySid( LsapAccountDomainMemberSidLength,
                                      CurrentSid,
                                      LsapAccountDomainMemberSid
                                      );

        ASSERT(NT_SUCCESS(SuccessExpected));

        (*RtlSubAuthoritySid( CurrentSid, LsapAccountDomainSubCount-1)) =
            AccountMembership.Element[i];
        GroupArray[CurrentGroup].Sid = (PSID)CurrentSid;

        GroupArray[CurrentGroup].Attributes = (SE_GROUP_MANDATORY          |
                                               SE_GROUP_ENABLED_BY_DEFAULT |
                                               SE_GROUP_ENABLED);

        CurrentSid += LsapAccountDomainMemberSidLength;
        CurrentGroup++;

    }

    // Copy Builtin Aliases

    for ( i=0; i<BuiltinMembership.Count; i++) {
        SuccessExpected = RtlCopySid( LsapBuiltinDomainMemberSidLength,
                                      CurrentSid,
                                      LsapBuiltinDomainMemberSid
                                      );
        ASSERT(NT_SUCCESS(SuccessExpected));

        (*RtlSubAuthoritySid( CurrentSid, LsapBuiltinDomainSubCount-1)) =
            BuiltinMembership.Element[i];

        GroupArray[CurrentGroup].Sid = (PSID)CurrentSid;
        GroupArray[CurrentGroup].Attributes = (SE_GROUP_MANDATORY          |
                                               SE_GROUP_ENABLED_BY_DEFAULT |
                                               SE_GROUP_ENABLED);

        if (BuiltinMembership.Element[i] == DOMAIN_ALIAS_RID_ADMINS) {

            //
            // ADMINISTRATORS alias member - set it up as the default owner
            //
            GroupArray[CurrentGroup].Attributes |= (SE_GROUP_OWNER);

            if ( CheckAdminOwnerSetting() )
            {
                NewTokenInfo->Owner.Owner = (PSID)CurrentSid;
            }
        }
        CurrentSid += LsapBuiltinDomainMemberSidLength;
        CurrentGroup++;
    }

    // Finish up with the low rate
    // Copy high rate sids to array (they are static globals, so they don't need to be copied into buffer)
    for(i=HighRateIdCount; i < FinalIdCount; i++)
    {
        CurrentSidLength = RtlLengthSid( FinalIds[i].Sid);
        SuccessExpected = RtlCopySid(CurrentSidLength, CurrentSid, FinalIds[i].Sid);
        ASSERT( NT_SUCCESS( SuccessExpected ));
        GroupArray[CurrentGroup].Sid = CurrentSid;
        GroupArray[CurrentGroup].Attributes = FinalIds[i].Attributes;
        CurrentGroup++;
        CurrentSid += CurrentSidLength;
    }

    for(i=0; i < SidPackageCount ;i++)
    {
        CurrentSidLength = RtlLengthSid( SidPackage[i] );
        SuccessExpected = RtlCopySid(CurrentSidLength, CurrentSid, SidPackage[i]);
        ASSERT( NT_SUCCESS( SuccessExpected ));
        GroupArray[CurrentGroup].Sid = CurrentSid;
        GroupArray[CurrentGroup].Attributes = (SE_GROUP_MANDATORY          |
                                               SE_GROUP_ENABLED_BY_DEFAULT |
                                               SE_GROUP_ENABLED);
        CurrentGroup++;
        CurrentSid += CurrentSidLength;
    }


    if(OldTokenInfo)
    {
        CurrentSid = (PSID)OFFSET_ALIGN(CurrentSid, ACL);
        NewTokenInfo->DefaultDacl.DefaultDacl = (PACL)CurrentSid;
        CurrentSid += DefaultDaclSize;
    }

    CurrentSid = (PSID) OFFSET_ALIGN(CurrentSid, TOKEN_PRIVILEGES);
    NewTokenInfo->Privileges = (PTOKEN_PRIVILEGES)CurrentSid;
    NewTokenInfo->Privileges->PrivilegeCount = 0;

    LsapDsDebugOut((DEB_TRACE, "NewTokenInfo : %lx\n", NewTokenInfo));
    LsapDsDebugOut((DEB_TRACE, "TokenSize : %lx\n", TokenSize));
    LsapDsDebugOut((DEB_TRACE, "CurrentSid : %lx\n", CurrentSid));

    ASSERT((PBYTE)NewTokenInfo + TokenSize == CurrentSid + sizeof(TOKEN_PRIVILEGES) +
                                                          sizeof(LUID_AND_ATTRIBUTES) * (SEP_MAX_PRIVILEGE_COUNT -
                                                          ANYSIZE_ARRAY));


    (*TokenInfo) = NewTokenInfo;
    NewTokenInfo = NULL;
    (*TokenInfoSize) = TokenSize;

Cleanup:

    if( SidArray != NULL )
    {
        SafeAllocaFree( SidArray );
    }

    if(NewTokenInfo)
    {
        LsapFreeLsaHeap(NewTokenInfo);
    }

    LsapFreeSampUlongArray( &AccountMembership );
    LsapFreeSampUlongArray( &BuiltinMembership );

    return(Status);

}



NTSTATUS
LsapAuSetTokenInformation(
    IN OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN PVOID *TokenInformation,
    IN ULONG FinalIdCount,
    IN PSID_AND_ATTRIBUTES FinalIds,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN ULONG NewTokenInfoSize,
    IN OUT PLSA_TOKEN_INFORMATION_V2 *NewTokenInfo
    )

/*++

Routine Description:

    This routine takes the information from the current TokenInformation,
    the FinalIds array, and the Privileges and incorporates them into a
    single TokenInformation structure.  It may be necessary to free some
    or all of the original TokenInformation.  It may even be necessary to
    produce a different TokenInformationType to accomplish this task.


Arguments:


    TokenInformationType - Indicates what format the provided set of
        token information is in.

    TokenInformation - The information in this structure will be superceded
        by the information in the FinalIDs parameter and the Privileges
        parameter.

    FinalIdCount - Indicates the number of IDs (user, group, and alias)
        to be incorporated in the final TokenInformation.

    FinalIds - Points to an array of SIDs and their corresponding
        attributes to be incorporated into the final TokenInformation.

    IdProperties - Points to an array of properties relating to the FinalIds.


    PrivilegeCount - Indicates the number of privileges to be incorporated
        into the final TokenInformation.

    Privileges -  Points to an array of privileges that are to be
        incorporated into the TokenInformation.  This array will be
        used directly in the resultant TokenInformation.

Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_NO_MEMORY - Indicates there was not enough heap memory available
        to produce the final TokenInformation structure.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;

    PLSA_TOKEN_INFORMATION_V2 OldV2;
    PLSA_TOKEN_INFORMATION_NULL OldNull;

    ASSERT(( *TokenInformationType == LsaTokenInformationV1) ||
            (*TokenInformationType == LsaTokenInformationNull) ||
            ( *TokenInformationType == LsaTokenInformationV2));

    if(*TokenInformationType == LsaTokenInformationNull)
    {
        OldNull = (PLSA_TOKEN_INFORMATION_NULL)(*TokenInformation);
        (*NewTokenInfo)->ExpirationTime = OldNull->ExpirationTime;
    }
    else
    {
        OldV2 = (PLSA_TOKEN_INFORMATION_V2)(*TokenInformation);
        (*NewTokenInfo)->ExpirationTime = OldV2->ExpirationTime;
    }

    ////////////////////////////////////////////////////////////////////////
    //                                                                    //
    // Set the Privileges, if any                                         //
    //                                                                    //
    ////////////////////////////////////////////////////////////////////////


    (*NewTokenInfo)->Privileges->PrivilegeCount = PrivilegeCount;

    ASSERT((PBYTE)&(*NewTokenInfo)->Privileges->Privileges[PrivilegeCount] <=
             ((PBYTE)(*NewTokenInfo)) + NewTokenInfoSize);

    for ( i=0; i<PrivilegeCount; i++) {
        (*NewTokenInfo)->Privileges->Privileges[i] = Privileges[i];
    }


    ////////////////////////////////////////////////////////////////////////
    //                                                                    //
    // Free the old TokenInformation and set the new                      //
    //                                                                    //
    ////////////////////////////////////////////////////////////////////////


    if (NT_SUCCESS(Status)) {

        switch ( (*TokenInformationType) ) {
        case LsaTokenInformationNull:
            LsapFreeTokenInformationNull(
                (PLSA_TOKEN_INFORMATION_NULL)(*TokenInformation));
            break;

        case LsaTokenInformationV1:
            LsapFreeTokenInformationV1(
                (PLSA_TOKEN_INFORMATION_V1)(*TokenInformation));
            break;

        case LsaTokenInformationV2:
            LsapFreeTokenInformationV2(
                (PLSA_TOKEN_INFORMATION_V2)(*TokenInformation));
            break;
        }


        //
        // Set the new TokenInformation
        //

        (*TokenInformationType) = LsaTokenInformationV2;
        (*TokenInformation) = (*NewTokenInfo);
        (*NewTokenInfo) = NULL;
    }

    return(Status);
}


NTSTATUS
LsapAuDuplicateSid(
    PSID *Target,
    PSID Source
    )

/*++

Routine Description:

    Duplicate a SID.


Arguments:

    Target - Recieves a pointer to the SID copy.

    Source - points to the SID to be copied.


Return Value:

    STATUS_SUCCESS - The copy was successful.

    STATUS_NO_MEMORY - memory could not be allocated to perform the copy.

--*/

{
    ULONG Length;

    //
    // The SID needs to be copied ...
    //

    Length = RtlLengthSid( Source );
    (*Target) = LsapAllocateLsaHeap( Length );
    if ((*Target == NULL)) {
        return(STATUS_NO_MEMORY);
    }

    RtlMoveMemory( (*Target), Source, Length );

    return(STATUS_SUCCESS);

}


NTSTATUS
LsapAuOpenSam(
    BOOLEAN DuringStartup
    )

/*++

Routine Description:

    This routine opens SAM for use during authentication.  It
    opens a handle to both the BUILTIN domain and the ACCOUNT domain.

Arguments:

    DuringStartup - TRUE if this is the call made during startup.  In that case,
        there is no need to wait on the SAM_STARTED_EVENT since the caller ensures
        that SAM is started before the call is made.

Return Value:

    STATUS_SUCCESS - Succeeded.
--*/

{
    NTSTATUS Status, IgnoreStatus;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;


    if (LsapAuSamOpened == TRUE) {
        return(STATUS_SUCCESS);
    }

    Status = LsapOpenSamEx( DuringStartup );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    //
    // Set up the Built-In Domain Member Sid Information.
    //

    LsapBuiltinDomainSubCount = (*RtlSubAuthorityCountSid(LsapBuiltInDomainSid) + 1);
    LsapBuiltinDomainMemberSidLength = RtlLengthRequiredSid( LsapBuiltinDomainSubCount );

    //
    // Get the member Sid information for the account domain
    // and set the global variables related to this information.
    //

    Status = LsapGetAccountDomainInfo( &PolicyAccountDomainInfo );

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    LsapAccountDomainSubCount =
        (*(RtlSubAuthorityCountSid( PolicyAccountDomainInfo->DomainSid ))) +
        (UCHAR)(1);
    LsapAccountDomainMemberSidLength =
        RtlLengthRequiredSid( (ULONG)LsapAccountDomainSubCount );

    //
    // Build typical SIDs for members of the BUILTIN and ACCOUNT domains.
    // These are used to build SIDs when API return only RIDs.
    // Don't bother setting the last RID to any particular value.
    // It is always changed before use.
    //

    LsapAccountDomainMemberSid = LsapAllocateLsaHeap( LsapAccountDomainMemberSidLength );
    if (LsapAccountDomainMemberSid != NULL) {
        LsapBuiltinDomainMemberSid = LsapAllocateLsaHeap( LsapBuiltinDomainMemberSidLength );
        if (LsapBuiltinDomainMemberSid == NULL) {

            LsapFreeLsaHeap( LsapAccountDomainMemberSid );

            LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyAccountDomainInformation,
                (PLSAPR_POLICY_INFORMATION) PolicyAccountDomainInfo );

            return STATUS_NO_MEMORY ;
        }
    }
    else
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyAccountDomainInformation,
            (PLSAPR_POLICY_INFORMATION) PolicyAccountDomainInfo );

        return STATUS_NO_MEMORY ;
    }

    IgnoreStatus = RtlCopySid( LsapAccountDomainMemberSidLength,
                                LsapAccountDomainMemberSid,
                                PolicyAccountDomainInfo->DomainSid);
    ASSERT(NT_SUCCESS(IgnoreStatus));
    (*RtlSubAuthorityCountSid(LsapAccountDomainMemberSid))++;

    IgnoreStatus = RtlCopySid( LsapBuiltinDomainMemberSidLength,
                                LsapBuiltinDomainMemberSid,
                                LsapBuiltInDomainSid);
    ASSERT(NT_SUCCESS(IgnoreStatus));
    (*RtlSubAuthorityCountSid(LsapBuiltinDomainMemberSid))++;


    //
    // Free the ACCOUNT domain information
    //

    LsaIFree_LSAPR_POLICY_INFORMATION(
        PolicyAccountDomainInformation,
        (PLSAPR_POLICY_INFORMATION) PolicyAccountDomainInfo );

    if (NT_SUCCESS(Status)) {
        LsapAuSamOpened = TRUE;
    }

    return(Status);
}




BOOLEAN
LsapIsSidLogonSid(
    PSID Sid
    )
/*++

Routine Description:

    Test to see if the provided sid is a LOGON_ID.
    Such sids start with S-1-5-5 (see ntseapi.h for more on logon sids).



Arguments:

    Sid - Pointer to SID to test.  The SID is assumed to be a valid SID.


Return Value:

    TRUE - Sid is a logon sid.

    FALSE - Sid is not a logon sid.

--*/
{
    SID *ISid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    ISid = Sid;


    //
    // if the identifier authority is SECURITY_NT_AUTHORITY and
    // there are SECURITY_LOGON_IDS_RID_COUNT sub-authorities
    // and the first sub-authority is SECURITY_LOGON_IDS_RID
    // then this is a logon id.
    //


    if (ISid->SubAuthorityCount == SECURITY_LOGON_IDS_RID_COUNT) {
        if (ISid->SubAuthority[0] == SECURITY_LOGON_IDS_RID) {
            if (
              (ISid->IdentifierAuthority.Value[0] == NtAuthority.Value[0]) &&
              (ISid->IdentifierAuthority.Value[1] == NtAuthority.Value[1]) &&
              (ISid->IdentifierAuthority.Value[2] == NtAuthority.Value[2]) &&
              (ISid->IdentifierAuthority.Value[3] == NtAuthority.Value[3]) &&
              (ISid->IdentifierAuthority.Value[4] == NtAuthority.Value[4]) &&
              (ISid->IdentifierAuthority.Value[5] == NtAuthority.Value[5])
                ) {

                return(TRUE);
            }
        }
    }

    return(FALSE);

}


VOID
LsapAuSetLogonPrivilegeStates(
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES Privileges
    )
/*++

Routine Description:

    This is an interesting routine.  Its purpose is to establish the
    intial state (enabled/disabled) of privileges.  This information
    comes from LSA, but we need to over-ride that information for the
    time being based upon logon type.

    Basically, without dynamic context tracking supported across the
    network, network logons have no way to enable privileges.  Therefore,
    we will enable all privileges for network logons.

    For interactive, service, and batch logons, the programs or utilities
    used are able to enable privileges when needed.  Therefore, privileges
    for these logon types will be disabled.

    Despite the rules above, the SeChangeNotifyPrivilege will ALWAYS
    be enabled if granted to a user (even for interactive, service, and
    batch logons).


Arguments:

    PrivilegeCount - The number of privileges being assigned for this
        logon.

    Privileges - The privileges, and their attributes, being assigned
        for this logon.


Return Value:

    None.

--*/
{


    ULONG
        i,
        NewAttributes;

    LUID ChangeNotify;
    LUID Impersonate;
    LUID CreateXSession ;

    //
    // Enable or disable all privileges according to logon type
    //

    if ((LogonType == Network) ||
        (LogonType == NetworkCleartext)) {
        NewAttributes = (SE_PRIVILEGE_ENABLED_BY_DEFAULT |
                         SE_PRIVILEGE_ENABLED);
    } else {
        NewAttributes = 0;
    }


    for (i=0; i<PrivilegeCount; i++) {
        Privileges[i].Attributes = NewAttributes;
    }



    //
    // Interactive, Service, and Batch need to have the
    // SeChangeNotifyPrivilege enabled.  Network already
    // has it enabled.
    //

    if ((LogonType == Network) ||
        (LogonType == NetworkCleartext)) {
        return;
    }


    ChangeNotify = RtlConvertLongToLuid(SE_CHANGE_NOTIFY_PRIVILEGE);
    Impersonate = RtlConvertLongToLuid(SE_IMPERSONATE_PRIVILEGE);
    CreateXSession = RtlConvertLongToLuid(SE_CREATE_GLOBAL_PRIVILEGE);

    for ( i=0; i<PrivilegeCount; i++) {
        if (RtlEqualLuid(&Privileges[i].Luid, &ChangeNotify) == TRUE) {
            Privileges[i].Attributes = (SE_PRIVILEGE_ENABLED_BY_DEFAULT |
                                        SE_PRIVILEGE_ENABLED);
        } else if ( RtlEqualLuid( &Privileges[i].Luid, &Impersonate) == TRUE ) {
            Privileges[i].Attributes = (SE_PRIVILEGE_ENABLED_BY_DEFAULT | 
                                        SE_PRIVILEGE_ENABLED );
            
        } else if ( RtlEqualLuid( &Privileges[i].Luid, &CreateXSession) == TRUE ) {
            Privileges[i].Attributes = (SE_PRIVILEGE_ENABLED_BY_DEFAULT |
                                        SE_PRIVILEGE_ENABLED );
            
        }
    }

    return;

}

BOOLEAN
CheckNullSessionAccess(
    VOID
    )
/*++

Routine Description:

    This routine checks to see if we should restict null session access.
    in the registry under system\currentcontrolset\Control\Lsa\
    AnonymousIncludesEveryone indicating whether or not to restrict access.
    If the value is zero (or doesn't exist), we restrict anonymous by
    preventing Everyone and Network from entering the groups.

Arguments:

    none.

Return Value:

    TRUE - NullSession access is restricted.
    FALSE - NullSession access is not restricted.

--*/
{
    return LsapGlobalRestrictNullSessions ? TRUE : FALSE;
}

BOOL
IsTerminalServerRA(
    VOID
    )
{
    OSVERSIONINFOEX osVersionInfo;
    ULONGLONG ConditionMask = 0;

    ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));

    ConditionMask = VerSetConditionMask(ConditionMask, VER_SUITENAME, VER_AND);

    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;

    return VerifyVersionInfo(
                  &osVersionInfo,
                  VER_SUITENAME,
                  ConditionMask);
}


BOOLEAN
IsTSUSerSidEnabled(
   VOID
   )
{
   NTSTATUS NtStatus;
   UNICODE_STRING KeyName;
   OBJECT_ATTRIBUTES ObjectAttributes;
   HANDLE KeyHandle;
   UCHAR Buffer[100];
   PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
   ULONG KeyValueLength = 100;
   ULONG ResultLength;
   PULONG Flag;


   BOOLEAN fIsTSUSerSidEnabled = FALSE;


   //
   // We don't add TSUserSid for Remote Admin mode of TS
   //
   if (IsTerminalServerRA() == TRUE) {
      return FALSE;
   }


   //
   // Check in the registry if TSUserSid should be added to
   // to the token
   //

   //
   // Open the Terminal Server key in the registry
   //

   RtlInitUnicodeString(
       &KeyName,
       L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Terminal Server"
       );

   InitializeObjectAttributes(
       &ObjectAttributes,
       &KeyName,
       OBJ_CASE_INSENSITIVE,
       0,
       NULL
       );

   NtStatus = NtOpenKey(
               &KeyHandle,
               KEY_READ,
               &ObjectAttributes
               );

   if (!NT_SUCCESS(NtStatus)) {
       goto Cleanup;
   }


   RtlInitUnicodeString(
       &KeyName,
       L"TSUserEnabled"
       );

   NtStatus = NtQueryValueKey(
                   KeyHandle,
                   &KeyName,
                   KeyValuePartialInformation,
                   KeyValueInformation,
                   KeyValueLength,
                   &ResultLength
                   );


   if (NT_SUCCESS(NtStatus)) {

       //
       // Check that the data is the correct size and type - a ULONG.
       //

       if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
           (KeyValueInformation->Type == REG_DWORD)) {


           Flag = (PULONG) KeyValueInformation->Data;

           if (*Flag == 1) {
               fIsTSUSerSidEnabled = TRUE;
           }
       }

   }
   NtClose(KeyHandle);

Cleanup:

    return fIsTSUSerSidEnabled;

}

BOOLEAN
CheckAdminOwnerSetting(
    VOID
    )
/*++

Routine Description:

    This routine checks to see if we should set the default owner to the
    ADMINISTRATORS alias.  If the value is zero (or doesn't exist), then
    the ADMINISTRATORS alias will be set as the default owner (if present).
    Otherwise, no default owner is set.

Arguments:

    none.

Return Value:

    TRUE - If the ADMINISTRATORS alias is present, make it the default owner.
    FALSE - Do not set a default owner.

--*/
{
    return LsapGlobalSetAdminOwner ? TRUE : FALSE;
}

BOOL
LsapIsAdministratorRecoveryMode(
    IN PSID UserSid
    )
/*++

Routine description:

    This routine will return true if UserSid is the administrator's SID
    and the machine is currently in safe mode.

    Once the fact is established, the value is assigned to a static variable.

Parameters:

    UserSid - SID of the user logging on

Returns:

    TRUE or FALSE

--*/
{
    static LONG AdministratorRecoveryMode = -1L;
    HKEY hKey;
    DWORD dwType, dwSize;
    DWORD SafeBootMode = 0;

    if ( UserSid == NULL ||
         !IsWellKnownSid( UserSid, WinAccountAdministratorSid )) {

        return FALSE;

    } else if ( AdministratorRecoveryMode != -1L ) {

        return AdministratorRecoveryMode ? TRUE : FALSE;
    }

    //
    // get the safeboot mode
    //

    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("system\\currentcontrolset\\control\\safeboot\\option"),
            0,
            KEY_READ,
            & hKey
            ) == ERROR_SUCCESS) {

        dwSize = sizeof(DWORD);

        RegQueryValueEx (
                hKey,
                TEXT("OptionValue"),
                NULL,
                &dwType,
                (LPBYTE) &SafeBootMode,
                &dwSize
                );

        RegCloseKey( hKey );

    } else {

        return FALSE;
    }

    if ( SafeBootMode ) {

        AdministratorRecoveryMode = TRUE;

    } else {

        AdministratorRecoveryMode = FALSE;
    }

    return AdministratorRecoveryMode ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\aucred.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    aucred.c

Abstract:

    This module provides credential management services within the
    LSA subsystem.  Some of these services are indirectly available for use
    by authentication packages.

Author:

    Jim Kelly (JimK) 27-February-1991

Revision History:

--*/

#include <lsapch2.h>

RTL_RESOURCE                AuCredLock ;

#define AuReadLockCreds()   RtlAcquireResourceShared( &AuCredLock, TRUE );
#define AuWriteLockCreds()  RtlAcquireResourceExclusive( &AuCredLock, TRUE );
#define AuUnlockCreds()     RtlReleaseResource( &AuCredLock );

NTSTATUS
LsapInitializeCredentials(
    VOID
    )
{
    __try {
        RtlInitializeResource( &AuCredLock );
        return STATUS_SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
}


NTSTATUS
LsapAddCredential(
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN PSTRING PrimaryKeyValue,
    IN PSTRING Credentials
    )

/*++

Routine Description:

    This service is used by authentication packages to add credentials to a
    logon session.  These credentials may later be referenced using
    GetCredentials().

    This service acquires the AuLock.

Arguments:

    LogonId - The session ID of logon session to add credentials to.

    AuthenticationPackage - The authentication package ID of the
        calling authentication package.  This was received in the
        InitializePackage() call during DLL initialization.

    PrimaryKeyValue - Points to a string containing a value that the
        authentication package will later want to reference as a
        primary key of the credential data.  This may be used, for
        example, to keep the name of the domain or server the
        credentials are related to.  The format and meaning of this
        string are authentication package-specific.  Note that the
        string value does not have to be unique, even for the
        specified logon session.  For example, there could be two
        passwords for the same domain, each with the passwords stored
        as credentials and the domain name stored as the primary key.

    Credentials - Points to a string containing  data representing
        user credentials.  The format and meaning of this string are
        authentication package-specific.

Return Status:

    STATUS_SUCCESS - The credentials were successfully added.

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session could
        not be found.

--*/

{
    PLSAP_LOGON_SESSION LogonSession;
    PLSAP_PACKAGE_CREDENTIALS Package;
    PLSAP_CREDENTIALS NewCredentials = NULL;
    USHORT MaxPrimary;
    USHORT MaxCredentials;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Get a pointer to the logon session
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {

        return STATUS_NO_SUCH_LOGON_SESSION;
    }

    //
    // Allocate blocks needed to represent this credential
    // and copy the primary key and credential strings.
    //

    MaxPrimary = ROUND_UP_COUNT((PrimaryKeyValue->Length+sizeof(CHAR)), ALIGN_WORST);
    MaxCredentials = ROUND_UP_COUNT((Credentials->Length+sizeof(CHAR)), ALIGN_WORST);

    NewCredentials = LsapAllocatePrivateHeap( (ULONG)sizeof(LSAP_CREDENTIALS) +
                                          MaxPrimary +
                                          MaxCredentials
                                          );

    if ( NewCredentials == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    
    NewCredentials->PrimaryKey.MaximumLength = MaxPrimary;
    NewCredentials->PrimaryKey.Buffer = (PSTR)(NewCredentials+1);
    
    NewCredentials->Credentials.MaximumLength = MaxCredentials;
    NewCredentials->Credentials.Buffer = NewCredentials->PrimaryKey.Buffer +
                                         NewCredentials->PrimaryKey.MaximumLength;
    RtlCopyString( &NewCredentials->PrimaryKey, PrimaryKeyValue );
    RtlCopyString( &NewCredentials->Credentials, Credentials );

    //
    // Now get a pointer to the Package's credentials
    // (create one if necessary)
    //

    AuWriteLockCreds();

    Package = LsapGetPackageCredentials(
                  LogonSession,
                  AuthenticationPackage,
                  TRUE
                  );

    if ( !Package )
    {
        AuUnlockCreds();
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // insert new credentials in list.
    //

    NewCredentials->NextCredentials = Package->Credentials;

    Package->Credentials = NewCredentials;

    AuUnlockCreds();
    LsapReleaseLogonSession( LogonSession );

    return STATUS_SUCCESS;

Cleanup:

    LsapReleaseLogonSession( LogonSession );

    if ( NewCredentials )
    {
        if ( NewCredentials->PrimaryKey.Buffer )
        {
            ZeroMemory( NewCredentials->PrimaryKey.Buffer,
                        NewCredentials->PrimaryKey.Length );
        }

        if ( NewCredentials->Credentials.Buffer )
        {
            ZeroMemory( NewCredentials->Credentials.Buffer,
                        NewCredentials->Credentials.Length );
        }

        LsapFreePrivateHeap( NewCredentials );
    }

    return Status;
}


NTSTATUS
LsapGetCredentials(
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN OUT PULONG QueryContext,
    IN BOOLEAN RetrieveAllCredentials,
    IN PSTRING PrimaryKeyValue,
    OUT PULONG PrimaryKeyLength,
    IN PSTRING Credentials
    )

/*++

Routine Description:

    This service is used by authentication packages to retrieve credentials
    associated with a logon session.  It is expected that each authentication
    package will provide its own version of this service to its "clients".
    For example, the MSV1_0 authentication package will provide services for
    the LM Redirector to retrieve credentials (and probably establish them)
    for remote accesses.  These authentication package level services may be
    implemented using the LsaCallAuthenticationPackage() API.

    This service acquires the AuLock.

Arguments:

    LogonId - The session ID of logon session from which credentials
        are to be retrieved.

    AuthenticationPackage - The authentication package ID of the
        calling authentication package.  Authentication packages
        should only retrieve their own credentials.

    QueryContext - A context value used across successive calls to
        retrieve multiple credentials.  The first time this service
        is used, the value pointed to by this argument should be
        zero.  Thereafter, this value will be updated to allow
        retrieval to continue where it left off.  This value should,
        therefore, not be changed until all credentials of a given
        query operation have been retrieved.

    RetrieveAllCredentials - A boolean value indicating whether all
        credentials for the specified logon session should be
        retrieved (TRUE), or only those matching the specified
        PrimaryKeyValue (FALSE).

    PrimaryKeyValue - This parameter serves two purposes.  If the
        RetrieveAllCredentials argument is FALSE, then this string
        contains the value to use as a primary key lookup value.  In
        this case, only credentials whose primary key matches this
        one (and belonging to the correct logon session) will be
        retrieved.  If, however, the RetrieveAllCredentials argument
        is FALSE, then the value of this string are ignored.  In this
        case, the primary key value of each retrieved credential will
        be returned in this string.

    PrimaryKeyLength - If the RetrieveAllCredentials argument value
        is FALSE, then this argument receives the length needed to
        store the PrimaryKeyValue.  If this value is larger than the
        length of the PrimaryKeyValue string, then
        STATUS_BUFFER_OVERFLOW is returned and no data is retrieved.

    Credentials - Points to a string whose buffer is to be set to
        contain the retrieved credential.

Return Status:

    STATUS_MORE_ENTRIES - Credentials were successfully retrieved,
        and there are more available.

    STATUS_SUCCESS - Credentials were successfully retrieved and
        there are no more available.

    STATUS_UNSUCCESSFUL - No more credentials are available.  If
        returned on the first call, then there are no credentials
        matching the selection criteria.

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session could
        not be found.

    STATUS_BUFFER_OVERFLOW - Indicates the string provided to receive
        the PrimaryKeyValue was not large enough to hold the data.
        In this case, no data was retrieved. However, the length value
        is returned so that appropriately sized buffer can be passed in
        a successive call.


--*/

{
    //
    // NOTE: The QueryContext value is an index of the last retrieved
    //       credential matching the selection criteria.  To continue
    //       a search for successive credentials, skip QueryContext
    //       number of entries first.
    //
    //       This has the problem of changes between calls screwing
    //       up the result of successive calls.  That's tough.
    //

    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_LOGON_SESSION LogonSession;
    PLSAP_PACKAGE_CREDENTIALS Package;
    PLSAP_CREDENTIALS NextCredentials;
    ULONG i;
    BOOLEAN SelectionMatch;

    //
    // Get a pointer to the logon session
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {

        return STATUS_NO_SUCH_LOGON_SESSION;
    }

    AuReadLockCreds();

    //
    // Now get a pointer to the Package's credentials
    //

    Package = LsapGetPackageCredentials(
                  LogonSession,
                  AuthenticationPackage,
                  FALSE
                  );

    if ( Package == NULL ) {

        AuUnlockCreds();

        LsapReleaseLogonSession( LogonSession );

        return STATUS_UNSUCCESSFUL;
    }

    //
    // skip the credentials already evaluated in previous calls...
    //

    i = (*QueryContext);
    NextCredentials = Package->Credentials;
    while ( i > 0 ) {

        //
        // See if we have reached the end of the list
        //

        if (NextCredentials == NULL) {

            AuUnlockCreds();

            LsapReleaseLogonSession( LogonSession );

            return STATUS_UNSUCCESSFUL;
        }

        //
        // Nope, skip the next one...
        //

        NextCredentials = NextCredentials->NextCredentials;
        i -= 1;
    }

    //
    // Start evaluating each credential for a criteria match.
    //

    SelectionMatch = FALSE;
    while ( NextCredentials != NULL && !SelectionMatch ) {

        (*QueryContext) += 1;

        if (RetrieveAllCredentials) {

            SelectionMatch = TRUE;
            Status = LsapReturnCredential(
                         NextCredentials,
                         Credentials,
                         TRUE,
                         PrimaryKeyValue,
                         PrimaryKeyLength
                         );
        }

        //
        // Only retrieving credentials that match the specified primary
        // key.
        //

        if ( RtlEqualString( &NextCredentials->PrimaryKey, PrimaryKeyValue, FALSE) ) {

            SelectionMatch = TRUE;
            Status = LsapReturnCredential(
                         NextCredentials,
                         Credentials,
                         FALSE,
                         NULL,
                         NULL
                         );
        }

        NextCredentials = NextCredentials->NextCredentials;
    }

    AuUnlockCreds();

    LsapReleaseLogonSession( LogonSession );

    //
    // Figure out what return value to send.
    //

    if (SelectionMatch) {

        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            (*QueryContext) -= 1;
            return STATUS_BUFFER_OVERFLOW;
        }

        if ( Status == STATUS_SUCCESS) {
            if ( NextCredentials == NULL ) {
                return STATUS_SUCCESS;
            } else {
                return STATUS_MORE_ENTRIES;
            }
        }

    } else {

        //
        // didn't find a credential matching the selection criteria.
        //

        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_UNSUCCESSFUL ;
}


NTSTATUS
LsapReturnCredential(
    IN PLSAP_CREDENTIALS SourceCredentials,
    IN PSTRING TargetCredentials,
    IN BOOLEAN ReturnPrimaryKey,
    IN PSTRING PrimaryKeyValue OPTIONAL,
    OUT PULONG PrimaryKeyLength OPTIONAL
    )

/*++

Routine Description:

    This routine returns a copy of the credentials in the specified
    credential record.  It also, optionally, returns a copy of the
    primary key value.

Arguments:

    SourceCredentials - Points to a credential record whose credential
        string and, optionally, primary key are to be copied.

    TargetCredentials - Points to a string whose buffer is to be set to
        contain a copy of the credential.  This copy will be allocated
        using LsapAllocateLsaHeap().

    ReturnPrimaryKey - A boolean indicating whether or not to return
        a copy of the primary key.  TRUE indicates a copy should be
        returned.  FALSE indicates a copy should not be returned.

    PrimaryKeyValue - Points to a string whose buffer is to be set to
        contain a copy of the primary key.  This copy will be allocated
        using LsapAllocateLsaHeap().  This parameter is ignored if the
        ReturnPrimaryKey argument value is FALSE.


    PrimaryKeyLength - Points to a value which will receive the
        length of the primary key value.  If this value is larger than the
        length of the PrimaryKeyValue string, then STATUS_BUFFER_OVERFLOW
        is returned and no data is retrieved.



Return Status:

    STATUS_SUCCESS - Credentials were successfully returned.

    STATUS_BUFFER_OVERFLOW - Indicates the string provided to receive
        the PrimaryKeyValue was not large enough to hold the data.
        In this case, no data was retrieved. However, the length value
        is returned so that appropriately sized buffer can be passed in
        a successive call.

--*/

{
    ULONG Length;

    //
    // First try to return the primary key value, since we can encounter
    // a buffer overflow situation in doing so that would prevent us from
    // returning a copy of the credential string.
    //

    if (ReturnPrimaryKey) {
        (*PrimaryKeyLength) = SourceCredentials->PrimaryKey.Length + 1;
        if ( (*PrimaryKeyLength) > PrimaryKeyValue->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
        }

        //
        // It fits
        //

        RtlCopyString( PrimaryKeyValue, &SourceCredentials->PrimaryKey );
    }

    //
    // Now allocate and copy the credential string copy.
    //

    TargetCredentials->MaximumLength = SourceCredentials->Credentials.Length
                                       + (USHORT)1;

    Length = (ULONG)TargetCredentials->MaximumLength;

    TargetCredentials->Buffer = (PCHAR)LsapAllocateLsaHeap( Length );

    if ( TargetCredentials->Buffer )
    {
        RtlCopyString( TargetCredentials, &SourceCredentials->Credentials );

        return STATUS_SUCCESS ;
    }
    else
    {
        return STATUS_NO_MEMORY ;
    }

}


NTSTATUS
LsapDeleteCredential(
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN PSTRING PrimaryKeyValue
    )

/*++

Routine Description:

    This service is used to delete an existing credential.  This service
    deletes the first credential it finds with a matching logon session,
    authentication package ID, and primary key value.  If thee are
    multiple credentials that match this criteria, only one of them is
    deleted.

    This status acquires the AuLock.

Arguments:

    LogonId - The session ID of logon session whose credentials are to be
        deleted.

    AuthenticationPackage - The authentication package ID of the
        calling authentication package.  This was received in the
        InitializePackage() call during DLL initialization.

    PrimaryKeyValue - Points to string containing the primary key value
        of the credential to be deleted.

Return Status:

    STATUS_SUCCESS - The credentials were successfully deleted.

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session could
        not be found.

    STATUS_UNSUCCESSFUL - No such credential could be found.

--*/

{
    PLSAP_LOGON_SESSION LogonSession;
    PLSAP_PACKAGE_CREDENTIALS Package;
    PLSAP_CREDENTIALS *NextCredentials, GoodByeCredentials;

    //
    // Get a pointer to the logon session
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {

        return STATUS_NO_SUCH_LOGON_SESSION;
    }

    AuWriteLockCreds();

    //
    // Now get a pointer to the Package's credentials
    //

    Package = LsapGetPackageCredentials(
                  LogonSession,
                  AuthenticationPackage,
                  FALSE
                  );

    if ( Package == NULL ) {

        AuUnlockCreds();

        LsapReleaseLogonSession( LogonSession );

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Start evaluating each credential for a primary key value match.
    //

    NextCredentials = &Package->Credentials;
    while ( (*NextCredentials) != NULL ) {

        if ( RtlEqualString(
                 &(*NextCredentials)->PrimaryKey,
                 PrimaryKeyValue,
                 FALSE)
           ) {

            //
            // remove it from the list
            //

            GoodByeCredentials = (*NextCredentials);
            (*NextCredentials) = GoodByeCredentials->NextCredentials;

            AuUnlockCreds();

            LsapReleaseLogonSession( LogonSession );

            //
            // Zero the contents of the credential record.
            //

            if( GoodByeCredentials->PrimaryKey.Buffer != NULL )
            {
                SecureZeroMemory( GoodByeCredentials->PrimaryKey.Buffer,
                            GoodByeCredentials->PrimaryKey.Length );
            }
            
            if( GoodByeCredentials->Credentials.Buffer != NULL )
            {
                SecureZeroMemory( GoodByeCredentials->Credentials.Buffer,
                            GoodByeCredentials->Credentials.Length );
            }

            //
            // Free the credential record itself.
            //

            LsapFreePrivateHeap( GoodByeCredentials );

            return STATUS_SUCCESS;
        }

        NextCredentials = &(*NextCredentials)->NextCredentials;
    }

    AuUnlockCreds();

    LsapReleaseLogonSession( LogonSession );

    //
    // Nothing matched
    //

    return STATUS_UNSUCCESSFUL;
}


PLSAP_PACKAGE_CREDENTIALS
LsapGetPackageCredentials(
    IN PLSAP_LOGON_SESSION LogonSession,
    IN ULONG PackageId,
    IN BOOLEAN CreateIfNecessary
    )


/*++

Routine Description:

    This service returns a pointer to a specified package's credential
    record.  If no such record exists, one will optionally be created.

    It is assumed that either the LogonSession record is not currently
    in the logon session record list, or, if it is, that the AuLock
    is currently held.

Arguments:

    LogonSession - Pointer to a logon session record within which to
        work.

    PackageId - The authentication package ID to look for.

    CreateIfNecessary - A boolean indicating whether or not the package
        record is to be created if one does not already exist.  TRUE
        indicates the package is to be created if necessary, FALSE indicates
        the record should not be created.


Return Status:

    non-NULL - A pointer to the specified package record.

    NULL - The specified package record does not exist (and one was not
        created automatically).

--*/

{
    PLSAP_PACKAGE_CREDENTIALS *NextPackage, TargetPackage;

    //
    // See if the session exists
    //

    NextPackage = &LogonSession->Packages;

    while ( (*NextPackage) != NULL) {

        if ( (*NextPackage)->PackageId == PackageId ) {

            //
            // Found it
            //

            TargetPackage = (*NextPackage);

            return TargetPackage;
        }

        //
        // Move on to next package.
        //

        NextPackage = &(*NextPackage)->NextPackage;
    }

    //
    // No such package exists yet.
    // Create one if necessary.

    if ( !CreateIfNecessary ) {

        return NULL;
    }

    TargetPackage = LsapAllocateLsaHeap( (ULONG)sizeof(LSAP_PACKAGE_CREDENTIALS) );

    if ( TargetPackage )
    {
        TargetPackage->PackageId = PackageId;
        TargetPackage->Credentials = NULL;
        TargetPackage->NextPackage = LogonSession->Packages;
        LogonSession->Packages = TargetPackage;
    }

    return TargetPackage;
}


VOID
LsapFreePackageCredentialList(
    IN PLSAP_PACKAGE_CREDENTIALS PackageCredentialList
    )

/*++

Routine Description:

    This service frees a list of packge credential records.  This service
    is not expected to be exposed to authentication packages.

    This service expects not to have to acquire the AuLock.  This may be
    because it is already held, or because the credentials being freed
    are no longer accessible via the global variables.

Arguments:

    PackageCredentialList - Is a pointer to a list of LSA_PACKAGE_CREDENTIALS
        data structures.


Return Status:

    None.

--*/

{
    PLSAP_PACKAGE_CREDENTIALS NextPackage, GoodByePackage;

    //
    // Get rid of each PACKAGE_CREDENTIAL record.
    //

    NextPackage = PackageCredentialList;
    while ( NextPackage != NULL ) {

        //
        // Save a pointer to the next package
        //

        GoodByePackage = NextPackage;
        NextPackage = GoodByePackage->NextPackage;

        LsapFreeCredentialList( GoodByePackage->Credentials );

        //
        // Free the package record itself.
        //

        LsapFreeLsaHeap( GoodByePackage );
    }

    return;
}


VOID
LsapFreeCredentialList(
    IN PLSAP_CREDENTIALS CredentialList
    )

/*++

Routine Description:

    This service frees a list of credential records.  This service is not
    expected to be exposed to authentication packages.

    This service expects not to have to acquire the AuLock.  This may be
    because it is already held, or because the credentials being freed
    are no longer accessible via the global variables.

Arguments:

    CredentialList - Is a pointer to a list of LSA_CREDENTIALS data
        structures.


Return Status:


--*/

{

    PLSAP_CREDENTIALS NextCredentials, GoodByeCredentials;

    //
    // Get rid of each PACKAGE_CREDENTIAL record.
    //

    NextCredentials = CredentialList;
    while ( NextCredentials != NULL ) {

        //
        // Save a pointer to the next credential
        //

        GoodByeCredentials = NextCredentials;
        NextCredentials = GoodByeCredentials->NextCredentials;

        //
        // Zero the contents of this credential record.
        //

        if( GoodByeCredentials->PrimaryKey.Buffer != NULL )
        {
            SecureZeroMemory( GoodByeCredentials->PrimaryKey.Buffer,
                        GoodByeCredentials->PrimaryKey.Length );
        }

        if( GoodByeCredentials->Credentials.Buffer != NULL )
        {
            SecureZeroMemory( GoodByeCredentials->Credentials.Buffer,
                        GoodByeCredentials->Credentials.Length );
        }

        //
        // Free the credential record itself.
        //

        LsapFreePrivateHeap( GoodByeCredentials );

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\aupckg.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    aupckg.c

Abstract:

    This module provides code that initializes authentication packages.

    It also provides the dispatch code for LsaLookupPackage() and
    LsaCallPackage().

Author:

    Jim Kelly (JimK) 27-February-1991

Revision History:

--*/

#include "lsapch2.h"


NTSTATUS
LsapAuApiDispatchCallPackage(
    IN OUT PLSAP_CLIENT_REQUEST ClientRequest
    )

/*++

Routine Description:

    This function is the dispatch routine for LsaCallPackage().

Arguments:

    Request - Represents the client's LPC request message and context.
        The request message contains a LSAP_CALL_PACKAGE_ARGS message
        block.

Return Value:

    In addition to the status values that an authentication package
    might return, this routine will return the following:

    STATUS_QUOTA_EXCEEDED -  This error indicates that the call could
        not be completed because the client does not have sufficient
        quota to allocate the return buffer.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

--*/

{
    NTSTATUS Status;
    PLSAP_CALL_PACKAGE_ARGS Arguments;
    PVOID LocalProtocolSubmitBuffer;    // Receives a copy of protocol submit buffer
    PLSAP_SECURITY_PACKAGE AuthPackage;
    SECPKG_CLIENT_INFO ClientInfo;

    Status = LsapGetClientInfo(
                &ClientInfo
                );

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    Arguments = &ClientRequest->Request->Arguments.CallPackage;

    if ( Arguments->SubmitBufferLength > LSAP_MAX_LPC_BUFFER_LENGTH ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Get the address of the package to call
    //

    AuthPackage = SpmpValidRequest(
                    Arguments->AuthenticationPackage,
                    SP_ORDINAL_CALLPACKAGE
                    );

    if ( AuthPackage == NULL ) {

        return STATUS_NO_SUCH_PACKAGE;
    }

    //
    // Fetch a copy of the profile buffer from the client's
    // address space.
    //

    if (Arguments->SubmitBufferLength != 0) {

        LocalProtocolSubmitBuffer =
            LsapAllocateLsaHeap( Arguments->SubmitBufferLength );

        if (LocalProtocolSubmitBuffer == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            Status = LsapCopyFromClientBuffer (
                         (PLSA_CLIENT_REQUEST)ClientRequest,
                         Arguments->SubmitBufferLength,
                         LocalProtocolSubmitBuffer,
                         Arguments->ProtocolSubmitBuffer
                         );

            if ( !NT_SUCCESS(Status) ) {
                LsapFreeLsaHeap( LocalProtocolSubmitBuffer );
                DbgPrint("LSA/CallPackage(): Failed to retrieve submit buffer %lx\n",Status);
                return Status;
            }
        }

    } else {

        LocalProtocolSubmitBuffer = NULL;
    }

    if (NT_SUCCESS(Status)) {
        
        SetCurrentPackageId(AuthPackage->dwPackageID);

        StartCallToPackage(AuthPackage);

        DebugLog(( DEB_TRACE, "CallPackage(%ws, %d)\n",
                  AuthPackage->Name.Buffer,
                  *(DWORD *)LocalProtocolSubmitBuffer ));
        __try {

            //
            // Now call the package. For trusted clients, call the normal
            // CallPackage API.  For untrusted clients, use the untrusted version.
            //

            if (ClientInfo.HasTcbPrivilege) {
                Status = (AuthPackage->FunctionTable.CallPackage)(
                                          (PLSA_CLIENT_REQUEST)ClientRequest,
                                          LocalProtocolSubmitBuffer,
                                          Arguments->ProtocolSubmitBuffer,
                                          Arguments->SubmitBufferLength,
                                          &Arguments->ProtocolReturnBuffer,
                                          &Arguments->ReturnBufferLength,
                                          &Arguments->ProtocolStatus
                                          );

            } else if (AuthPackage->FunctionTable.CallPackageUntrusted != NULL) {
                Status = (AuthPackage->FunctionTable.CallPackageUntrusted)(
                                          (PLSA_CLIENT_REQUEST)ClientRequest,
                                          LocalProtocolSubmitBuffer,
                                          Arguments->ProtocolSubmitBuffer,
                                          Arguments->SubmitBufferLength,
                                          &Arguments->ProtocolReturnBuffer,
                                          &Arguments->ReturnBufferLength,
                                          &Arguments->ProtocolStatus
                                          );

            } else {
                Status = STATUS_NOT_SUPPORTED;
            }
        }
        __except(SP_EXCEPTION)
        {
            Status = GetExceptionCode();
            Status = SPException(Status, AuthPackage->dwPackageID);
        }

        EndCallToPackage(AuthPackage);
    }

    //
    // Free the local copy of the protocol submit buffer
    //

    if (LocalProtocolSubmitBuffer != NULL) {

        LsapFreeLsaHeap( LocalProtocolSubmitBuffer );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\aulogon.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    aulogon.c

Abstract:

    This module provides the dispatch code for LsaLogonUser() and
    related logon support routines.

    This file does NOT include the LSA Filter/Augmentor logic.

Author:

    Jim Kelly (JimK) 11-Mar-1992

Revision History:

--*/

#include <lsapch2.h>
#include <msaudite.h>
#include <ntmsv1_0.h>
#include <limits.h>    // ULONG_MAX
#include "adtp.h"
#include "ntlsapi.h"

//
// Pointer to license server routines in ntlsapi.dll
//
PNT_LICENSE_REQUEST_W LsaNtLicenseRequestW = NULL;
PNT_LS_FREE_HANDLE LsaNtLsFreeHandle = NULL;

// #define LOGON_SESSION_TRACK 1

VOID LogonSessionLogWrite( PCHAR Format, ... );

#ifdef LOGON_SESSION_TRACK
#define LSLog( x )  LogonSessionLogWrite x
#else
#define LSLog( x )
#endif

//
// Cleanup flags for LsapAuApiDispatchLogonUser
//

#define LOGONUSER_CLEANUP_LOGON_SESSION    0x00000001
#define LOGONUSER_CLEANUP_TOKEN_GROUPS     0x00000002

NTSTATUS
LsaCallLicenseServer(
    IN PWCHAR LogonProcessName,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName OPTIONAL,
    IN BOOLEAN IsAdmin,
    OUT HANDLE *LicenseHandle
    )

/*++

Routine Description:

    This function loads the license server DLL and calls it to indicate the
    specified logon process has successfully authenticated the specified user.

Arguments:

    LogonProcessName - Name of the process authenticating the user.

    AccountName - Name of the account authenticated.

    DomainName - Name of the domain containing AccountName

    IsAdmin - TRUE if the logged on user is an administrator

    LicenseHandle - Returns a handle to the LicenseServer that must be
        closed when the session goes away.  INVALID_HANDLE_VALUE is returned
        if the handle need not be closed.

Return Value:

    None.


--*/

{
    NTSTATUS Status;

    NT_LS_DATA NtLsData;
    ULONG BufferSize;
    LPWSTR Name;
    LS_STATUS_CODE LsStatus;
    LS_HANDLE LsHandle;

    static enum {
            FirstCall,
            DllMissing,
            DllLoaded } DllState = FirstCall ;

    HINSTANCE DllHandle;

    //
    // Initialization
    //

    NtLsData.DataType = NT_LS_USER_NAME;
    NtLsData.Data = NULL;
    NtLsData.IsAdmin = IsAdmin;
    *LicenseHandle = INVALID_HANDLE_VALUE;

    //
    // Load the license server DLL if this is the first call to this routine.
    //

    if ( DllState == FirstCall ) {

        //
        // Load the DLL
        //

        DllHandle = LoadLibraryA( "ntlsapi" );

        if ( DllHandle == NULL ) {
            DllState = DllMissing;
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        //
        // Find the License routine
        //

        LsaNtLicenseRequestW = (PNT_LICENSE_REQUEST_W)
            GetProcAddress(DllHandle, "NtLicenseRequestW");

        if ( LsaNtLicenseRequestW == NULL ) {
            DllState = DllMissing;
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        //
        // Find the License handle free routine
        //

        LsaNtLsFreeHandle = (PNT_LS_FREE_HANDLE)
            GetProcAddress(DllHandle, "NtLSFreeHandle");

        if ( LsaNtLsFreeHandle == NULL ) {
            DllState = DllMissing;
            LsaNtLicenseRequestW = NULL;
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        DllState = DllLoaded;

    //
    // Ensure the Dll was loaded on a previous call
    //
    } else if ( DllState != DllLoaded ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Allocate a buffer for the combined DomainName\UserName
    //

    BufferSize = AccountName->Length + sizeof(WCHAR);

    if ( DomainName != NULL && DomainName->Length != 0 ) {
        BufferSize += DomainName->Length + sizeof(WCHAR);
    }

    NtLsData.Data = LsapAllocateLsaHeap( BufferSize );

    if ( NtLsData.Data == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Fill in the DomainName\UserName
    //

    Name = (LPWSTR)(NtLsData.Data);

    if ( DomainName != NULL && DomainName->Length != 0 ) {
        RtlCopyMemory( Name,
                       DomainName->Buffer,
                       DomainName->Length );
        Name += DomainName->Length / sizeof(WCHAR);
        *Name = L'\\';
        Name++;
    }

    RtlCopyMemory( Name,
                   AccountName->Buffer,
                   AccountName->Length );
    Name += AccountName->Length / sizeof(WCHAR);
    *Name = L'\0';

    //
    // Call the license server.
    //

    LsStatus = (*LsaNtLicenseRequestW)(
                    LogonProcessName,
                    NULL,
                    &LsHandle,
                    &NtLsData );

    switch (LsStatus) {
    case LS_SUCCESS:
        Status = STATUS_SUCCESS;
        *LicenseHandle = (HANDLE) LsHandle;
        break;

    case LS_INSUFFICIENT_UNITS:
        Status = STATUS_LICENSE_QUOTA_EXCEEDED;
        break;

    case LS_RESOURCES_UNAVAILABLE:
        Status = STATUS_NO_MEMORY;
        break;

    default:
        //
        // Unavailability of the license server isn't fatal.
        //
        Status = STATUS_SUCCESS;
        break;
    }

    //
    // Cleanup and return.
    //

Cleanup:

    if ( NtLsData.Data != NULL ) {
        LsapFreeLsaHeap( NtLsData.Data );
    }

    return Status;
}


VOID
LsaFreeLicenseHandle(
    IN HANDLE LicenseHandle
    )

/*++

Routine Description:

    Free a handle returned by LsaCallLicenseServer.

Arguments:

    LicenseHandle - Handle returned to license for this logon session.

Return Value:

    None.

--*/

{
    if ( LsaNtLsFreeHandle != NULL && LicenseHandle != INVALID_HANDLE_VALUE ) {
        LS_HANDLE LsHandle;
        LsHandle = (LS_HANDLE) LicenseHandle;
        (*LsaNtLsFreeHandle)( LsHandle );
    }
}



BOOLEAN
LsapSidPresentInGroups(
    IN PTOKEN_GROUPS TokenGroups,
    IN SID * Sid
    )
/*++

Purpose:

    Determines whether the given SID is present in the given groups

Parameters:

    TokenGroups    groups to check
    Sid            SID to look for

Returns:

    TRUE if yes
    FALSE if no

--*/
{
    ULONG i;

    if ( Sid == NULL ||
         TokenGroups == NULL ) {

        return FALSE;
    }

    for ( i = 0; i < TokenGroups->GroupCount; i++ ) {

        if ( RtlEqualSid(
                 Sid,
                 TokenGroups->Groups[i].Sid)) {

            return (BOOLEAN) ( 0 != ( TokenGroups->Groups[i].Attributes & SE_GROUP_ENABLED ));
        }
    }

    return FALSE;
}


VOID
LsapUpdateNamesAndCredentials(
    IN SECURITY_LOGON_TYPE ActiveLogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials
    )
{
    PLSAP_LOGON_SESSION  LogonSession    = NULL;
    PLSAP_DS_NAME_MAP    pUpnMap         = NULL;
    PLSAP_DS_NAME_MAP    pDnsMap         = NULL;
    UNICODE_STRING       OldUpn          = PrimaryCredentials->Upn;
    UNICODE_STRING       OldDnsName      = PrimaryCredentials->DnsDomainName;
    NTSTATUS             Status;

    //
    // Stuff the UPN and DnsDomainName into the PrimaryCredentials if necessary
    // so they're available to the packages.
    //

    if (OldDnsName.Length == 0 || OldUpn.Length == 0)
    {
        LogonSession = LsapLocateLogonSession(&PrimaryCredentials->LogonId);

        if (LogonSession == NULL)
        {
            ASSERT(LogonSession != NULL);
            return;
        }

        if (OldDnsName.Length == 0)
        {
            Status = LsapGetNameForLogonSession(LogonSession,
                                                NameDnsDomain,
                                                &pDnsMap,
                                                TRUE);

            if (NT_SUCCESS(Status))
            {
                PrimaryCredentials->DnsDomainName = pDnsMap->Name;
            }
        }

        if (OldUpn.Length == 0)
        {
            Status = LsapGetNameForLogonSession(LogonSession,
                                                NameUserPrincipal,
                                                &pUpnMap,
                                                TRUE);

            if (NT_SUCCESS(Status))
            {
                PrimaryCredentials->Upn = pUpnMap->Name;
            }
        }

        LsapReleaseLogonSession(LogonSession);
        LogonSession = NULL;
    }

    LsapUpdateCredentialsWorker(ActiveLogonType,
                                AccountName,
                                PrimaryCredentials,
                                Credentials);

    PrimaryCredentials->DnsDomainName = OldDnsName;
    PrimaryCredentials->Upn           = OldUpn;

    ASSERT(LogonSession == NULL);

    if (pDnsMap != NULL)
    {
        LsapDerefDsNameMap(pDnsMap);
    }

    if (pUpnMap != NULL)
    {
        LsapDerefDsNameMap(pUpnMap);
    }
}
//+---------------------------------------------------------------------------
//
//  Function:   LsapUpdateOriginInfo
//
//  Synopsis:   Updates the token's origin information based on the creator 
//              of the logon
//
//  Arguments:  [Token] -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

VOID
LsapUpdateOriginInfo(
    HANDLE Token
    )
{
    NTSTATUS Status ;
    HANDLE ClientToken ;
    TOKEN_STATISTICS Stats ;
    ULONG Size ;
    TOKEN_ORIGIN Origin ;


    Status = LsapImpersonateClient();

    if ( NT_SUCCESS( Status ) )
    {
        if ( OpenThreadToken( NtCurrentThread(), TOKEN_QUERY, TRUE, &ClientToken ) )
        {
            RevertToSelf();

            if ( GetTokenInformation( ClientToken, TokenStatistics, &Stats, sizeof( Stats ), &Size ) )
            {
                Origin.OriginatingLogonSession = Stats.AuthenticationId ;

                NtSetInformationToken( Token, TokenOrigin, &Origin, sizeof( Origin ) );

            }

            NtClose( ClientToken );
            
        }
        else 
        {
            RevertToSelf();
        }
        
    }


}

NTSTATUS
LsapAuGenerateLogonAudits(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PSECPKG_CLIENT_INFO pClientInfo,
    IN PLUID pNewUserLogonId,
    IN SECURITY_LOGON_TYPE NewUserLogonType,
    IN PUNICODE_STRING pNewUserName,
    IN PUNICODE_STRING pNewUserDomain,
    IN PSID pNewUserSid,
    IN PUNICODE_STRING pWorkstationName,
    IN PTOKEN_SOURCE pTokenSource
    )
/*++

Routine Description:

    This function generates the regular logon audit event and the
    audit event for logon using explicit creds

Arguments:

    LogonStatus         - status of logon attempt

    LogonSubStatus      - sub-status of logon attempt

    pCurrentUserLogonId - logon ID of the user making call to LsaLogonUser

    pNewUserLogonId     - logon ID of the new logon session

    NewUserLogonType    - type of new logon

    pNewUserName        - name of new user

    pNewUserDomain      - domain of new user

    pNewUserSid         - sid of new user

    pWorkstationName    - name of workstation from which logon request came

    pTokenSource        - token source

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS AuditStatus = STATUS_SUCCESS;
    LPGUID pNewUserLogonGuid = NULL;
    LPGUID pCurrentUserLogonGuid = NULL;
    PLSAP_LOGON_SESSION pCurrentUserLogonSession = NULL;
    PLSAP_LOGON_SESSION pNewUserLogonSession = NULL;
    PSID pCurrentUserSid = NULL;
    PLUID pCurrentUserLogonId;

    pCurrentUserLogonId = &pClientInfo->LogonId;

    //
    // locate logon session so that we can extract the required info
    //

    pCurrentUserLogonSession = LsapLocateLogonSession( pCurrentUserLogonId );

    ASSERT( pCurrentUserLogonSession && L"LsapAuGenerateLogonAudits: this must not be NULL!" );

    if ( pCurrentUserLogonSession )
    {
        pCurrentUserLogonGuid = &pCurrentUserLogonSession->LogonGuid;
        pCurrentUserSid       = pCurrentUserLogonSession->UserSid;
    }

    //
    // locate logon session so that we can extract the required info
    //

    pNewUserLogonSession = LsapLocateLogonSession( pNewUserLogonId );

    if ( pNewUserLogonSession )
    {
        pNewUserLogonGuid = &pNewUserLogonSession->LogonGuid;
    }

    //
    // generate the explicit-cred logon audit event for a successful logon
    //

    if ( NT_SUCCESS( LogonStatus ) )
    {
        UNICODE_STRING Target;
        RtlInitUnicodeString( &Target, L"localhost" );

        Status = LsaIAuditLogonUsingExplicitCreds(
                     EVENTLOG_AUDIT_SUCCESS,
                     pCurrentUserLogonId,
                     pCurrentUserLogonGuid,
                     (HANDLE) (ULONG_PTR) pClientInfo->ProcessID,
                     pNewUserName,
                     pNewUserDomain,
                     pNewUserLogonGuid,
                     &Target,
                     &Target
                     );
    }

    //
    // generate the regular logon audit event
    //

    LsapAuditLogonHelper(
        LogonStatus,
        LogonSubStatus,
        pNewUserName,
        pNewUserDomain,
        pWorkstationName,
        pNewUserSid,
        NewUserLogonType,
        pTokenSource,
        pNewUserLogonId,
        NULL,
        pCurrentUserLogonId,
        (PHANDLE) &pClientInfo->ProcessID,
        NULL                        // no transitted services
        );

    //
    // cleanup
    //

    if ( pCurrentUserLogonSession )
    {
        LsapReleaseLogonSession( pCurrentUserLogonSession );
    }

    if ( pNewUserLogonSession )
    {
        LsapReleaseLogonSession( pNewUserLogonSession );
    }

    return Status;
}


NTSTATUS
LsapAuApiDispatchLogonUser(
    IN OUT PLSAP_CLIENT_REQUEST ClientRequest
    )

/*++

Routine Description:

    This function is the dispatch routine for LsaLogonUser().

Arguments:

    Request - Represents the client's LPC request message and context.
        The request message contains a LSAP_LOGON_USER_ARGS message
        block.

Return Value:

    In addition to the status values that an authentication package
    might return, this routine will return the following:

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.


--*/

{
    NTSTATUS Status, TmpStatus, IgnoreStatus;
    PLSAP_LOGON_USER_ARGS Arguments;
    PVOID LocalAuthenticationInformation;    // Receives a copy of authentication information
    PTOKEN_GROUPS ClientTokenGroups;
    PVOID TokenInformation = NULL ;
    LSA_TOKEN_INFORMATION_TYPE TokenInformationType = 0;
    LSA_TOKEN_INFORMATION_TYPE OriginalTokenType = LsaTokenInformationNull;
    PLSA_TOKEN_INFORMATION_V2 TokenInformationV2;
    PLSA_TOKEN_INFORMATION_NULL TokenInformationNull;
    HANDLE Token = INVALID_HANDLE_VALUE ;
    PUNICODE_STRING AccountName = NULL;
    PUNICODE_STRING AuthenticatingAuthority = NULL;
    PUNICODE_STRING WorkstationName = NULL;
    PSID UserSid = NULL;
    LUID AuthenticationId;
    PPRIVILEGE_SET PrivilegesAssigned = NULL;
    BOOLEAN CallLicenseServer;
    PSession Session = GetCurrentSession();
    PLSAP_SECURITY_PACKAGE AuthPackage;
    PLSAP_SECURITY_PACKAGE SupplementalPackage;
    ULONG LogonOrdinal;
    SECPKG_CLIENT_INFO ClientInfo;
    SECPKG_PRIMARY_CRED PrimaryCredentials;
    PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials = NULL;
    SECURITY_LOGON_TYPE ActiveLogonType;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES Obja;
    PROCESS_SESSION_INFORMATION SessionInfo;
    HANDLE hClientProcess;
    BOOLEAN fUsedSubAuthEx = FALSE;
    QUOTA_LIMITS QuotaLimits;
    BOOLEAN fHasTcbPrivilege;
    BOOLEAN UseIdentify = FALSE;
    LUID LocalServiceLuid   = LOCALSERVICE_LUID;
    LUID NetworkServiceLuid = NETWORKSERVICE_LUID;
    ULONG_PTR RealLogonPackageId = 0;
    PLSAP_LOGON_SESSION LogonSession = NULL;
    DWORD dwProgress = 0;

#if _WIN64

    SECPKG_CALL_INFO  CallInfo;

#endif  // _WIN64


    //
    // allow untrusted clients to call this API in a limited fashion.
    // save the untrusted indicator for later use.
    //
    // sfield TODO: switch to GetCallInfo, and then store (and use) away
    // default process LogonId in session record to use for audit generation below.
    //

    Status = LsapGetClientInfo(
                &ClientInfo
                );

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // if the client died, bail now.
    //

    if( (ClientInfo.ClientFlags & SECPKG_CLIENT_THREAD_TERMINATED) ||
        (ClientInfo.ClientFlags & SECPKG_CLIENT_PROCESS_TERMINATED) )
    {
        return STATUS_ACCESS_DENIED;
    }


    //
    // client is not required to hold SeTcbPrivilege if supplemental groups
    // not supplied.
    //

    fHasTcbPrivilege = ClientInfo.HasTcbPrivilege;

    //
    // sfield TODO: look at using cached SessionId.
    //

#if 1
    //
    // MultiUser NT(HYDRA). Query the Client Process's SessionID
    //

    InitializeObjectAttributes(
        &Obja,
        NULL,
        0,
        NULL,
        NULL
        );

    ClientId.UniqueProcess = (HANDLE)LongToHandle(ClientInfo.ProcessID);
    ClientId.UniqueThread = (HANDLE)NULL;

    Status = NtOpenProcess(
                 &hClientProcess,
                 (ACCESS_MASK)PROCESS_QUERY_INFORMATION,
                 &Obja,
                 &ClientId
                 );

    if( !NT_SUCCESS(Status) ) {
       ASSERT( NT_SUCCESS(Status) );
       return Status;
    }


    Status = NtQueryInformationProcess(
                 hClientProcess,
                 ProcessSessionInformation,
                 &SessionInfo,
                 sizeof(SessionInfo),
                 NULL
                 );

    NtClose(hClientProcess);

    if (!NT_SUCCESS(Status)) {
       ASSERT( NT_SUCCESS(Status) );
       return(Status);
    }
#else

    SessionInfo.SessionId = Session->SessionId;

#endif


    RtlZeroMemory(
        &PrimaryCredentials,
        sizeof(SECPKG_PRIMARY_CRED)
        );

    Arguments = &ClientRequest->Request->Arguments.LogonUser;

    Arguments->ProfileBuffer = NULL;

    if ( Arguments->AuthenticationInformationLength > LSAP_MAX_LPC_BUFFER_LENGTH )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Determine if the LicenseServer should be called.
    //  Turn off the flag to prevent confusing any other logic below.
    //

    if ( Arguments->AuthenticationPackage & LSA_CALL_LICENSE_SERVER ) {
        Arguments->AuthenticationPackage &= ~LSA_CALL_LICENSE_SERVER ;
        CallLicenseServer = TRUE;
    } else {
        CallLicenseServer = FALSE;
    }


    //
    // Map logons
    //

    ActiveLogonType = Arguments->LogonType;
    if (ActiveLogonType == Unlock) {
        ActiveLogonType = Interactive;
    } else if (ActiveLogonType == CachedRemoteInteractive) {
        ActiveLogonType = RemoteInteractive;
    }

    //
    // Get the address of the package to call
    //

    LogonOrdinal = SP_ORDINAL_LOGONUSEREX2;
    AuthPackage = SpmpValidRequest(
                    Arguments->AuthenticationPackage,
                    LogonOrdinal
                    );

    if (AuthPackage == NULL)
    {
        LogonOrdinal = SP_ORDINAL_LOGONUSEREX;
        AuthPackage = SpmpValidRequest(
                        Arguments->AuthenticationPackage,
                        LogonOrdinal
                        );
        if (AuthPackage == NULL)
        {
            LogonOrdinal = SP_ORDINAL_LOGONUSER;
            AuthPackage = SpmpValidRequest(
                            Arguments->AuthenticationPackage,
                            LogonOrdinal
                            );

            if (AuthPackage == NULL) {
                return( STATUS_NOT_SUPPORTED );
            }
        }

    }

    SetCurrentPackageId(AuthPackage->dwPackageID);


    //
    // Fetch a copy of the authentication information from the client's
    // address space.
    //

    if (Arguments->AuthenticationInformationLength != 0)
    {
        LocalAuthenticationInformation = LsapAllocateLsaHeap(Arguments->AuthenticationInformationLength);

        if (LocalAuthenticationInformation == NULL)
        {
            return(STATUS_NO_MEMORY);
        }

        Status = LsapCopyFromClientBuffer (
                     (PLSA_CLIENT_REQUEST)ClientRequest,
                     Arguments->AuthenticationInformationLength,
                     LocalAuthenticationInformation,
                     Arguments->AuthenticationInformation
                     );

        if ( !NT_SUCCESS(Status) )
        {
            LsapFreeLsaHeap( LocalAuthenticationInformation );

            DebugLog((DEB_ERROR, "LSA/LogonUser(): Failed to retrieve Auth. Info. %lx\n",Status));

            return Status;
        }
    }
    else
    {
        LocalAuthenticationInformation = NULL;
    }


    //
    // Capture the local groups ( a rather complicated task ).
    //

    ClientTokenGroups = Arguments->LocalGroups; // Save so we can restore it later
    Arguments->LocalGroups = NULL;


    if( ClientTokenGroups != NULL )
    {
        if( fHasTcbPrivilege )
        {
            Status = LsapCaptureClientTokenGroups(
                         ClientRequest,
                         Arguments->LocalGroupsCount,
                         ClientTokenGroups,
                         (PTOKEN_GROUPS *)&Arguments->LocalGroups
                         );
        }
        else
        {
            //
            // callers that don't hold SeTcbPrivilege cannot supply additional
            // groups.
            //

            Status = STATUS_ACCESS_DENIED;
        }
    }
    else
    {
        //
        // build the Logon and Local Sid.
        //

        Status = LsapBuildDefaultTokenGroups(
                        Arguments
                        );
    }

    if ( !NT_SUCCESS(Status) )
    {
        DebugLog((DEB_ERROR,"LSA/LogonUser(): Failed to retrieve local groups %lx\n",Status));
        LsapFreeLsaHeap( LocalAuthenticationInformation );
        return Status;
    }

    dwProgress |= LOGONUSER_CLEANUP_TOKEN_GROUPS;

    // HACK for ARAP: If we are calling MSV and we are doing SubAuthEx, do
    // not delete the profile buffer.

    if (AuthPackage->Name.Length == MSV1_0_PACKAGE_NAMEW_LENGTH)
    {
        if ((wcscmp(AuthPackage->Name.Buffer, MSV1_0_PACKAGE_NAMEW) == 0) 
            && (Arguments->AuthenticationInformationLength >= RTL_SIZEOF_THROUGH_FIELD(MSV1_0_LM20_LOGON, MessageType)))
        {
            PMSV1_0_LM20_LOGON TempAuthInfo = (PMSV1_0_LM20_LOGON) LocalAuthenticationInformation;

            if (TempAuthInfo->MessageType == MsV1_0SubAuthLogon)
            {
                fUsedSubAuthEx = TRUE;
            }
        }
    }

    //
    // Now call the package...
    //
    //
    // Once the authentication package returns success from this
    // call, it is LSA's responsibility to clean up the logon
    // session when it is no longer needed.  This is true whether
    // the logon fails due to other constraints, or because the
    // user ultimately logs off.
    //

    try
    {
        if (LogonOrdinal == SP_ORDINAL_LOGONUSEREX2)
        {
            Status = (AuthPackage->FunctionTable.LogonUserEx2)(
                                      (PLSA_CLIENT_REQUEST)ClientRequest,
                                       ActiveLogonType,
                                       LocalAuthenticationInformation,
                                       Arguments->AuthenticationInformation,    //client base
                                       Arguments->AuthenticationInformationLength,
                                       &Arguments->ProfileBuffer,
                                       &Arguments->ProfileBufferLength,
                                       &Arguments->LogonId,
                                       &Arguments->SubStatus,
                                       &TokenInformationType,
                                       &TokenInformation,
                                       &AccountName,
                                       &AuthenticatingAuthority,
                                       &WorkstationName,
                                       &PrimaryCredentials,
                                       &Credentials
                                       );
        }
        else if (LogonOrdinal == SP_ORDINAL_LOGONUSEREX)
        {
            Status = (AuthPackage->FunctionTable.LogonUserEx)(
                                      (PLSA_CLIENT_REQUEST)ClientRequest,
                                       ActiveLogonType,
                                       LocalAuthenticationInformation,
                                       Arguments->AuthenticationInformation,    //client base
                                       Arguments->AuthenticationInformationLength,
                                       &Arguments->ProfileBuffer,
                                       &Arguments->ProfileBufferLength,
                                       &Arguments->LogonId,
                                       &Arguments->SubStatus,
                                       &TokenInformationType,
                                       &TokenInformation,
                                       &AccountName,
                                       &AuthenticatingAuthority,
                                       &WorkstationName
                                       );
        }
        else if (LogonOrdinal == SP_ORDINAL_LOGONUSER)
        {
            //
            // We checked to make sure that at least one of these was exported
            // from the package, so we know we can call this if LsapApLogonUserEx
            // doesn't exist.
            //

            Status = (AuthPackage->FunctionTable.LogonUser)(
                                      (PLSA_CLIENT_REQUEST)ClientRequest,
                                       ActiveLogonType,
                                       LocalAuthenticationInformation,
                                       Arguments->AuthenticationInformation,    //client base
                                       Arguments->AuthenticationInformationLength,
                                       &Arguments->ProfileBuffer,
                                       &Arguments->ProfileBufferLength,
                                       &Arguments->LogonId,
                                       &Arguments->SubStatus,
                                       &TokenInformationType,
                                       &TokenInformation,
                                       &AccountName,
                                       &AuthenticatingAuthority
                                       );
        }
    }
    except(SP_EXCEPTION)
    {
        Status = GetExceptionCode();
        Status = SPException(Status, AuthPackage->dwPackageID);
    }

    SetCurrentPackageId( IntToPtr(SPMGR_ID) );

    AuthenticationId = Arguments->LogonId;

    if ( !NT_SUCCESS(Status) )
    {
        // HACK for ARAP: If we are calling MSV and we are doing SubAuthEx,
        // do not delete the profile buffer.

        // BUGBUG:  Do this on all error paths?

        if (!fUsedSubAuthEx)
        {
            LsapClientFree(
                Arguments->ProfileBuffer
                );
            Arguments->ProfileBuffer = NULL;
        }

        goto Done;
    }

    dwProgress |= LOGONUSER_CLEANUP_LOGON_SESSION;

    //
    // Build the PrimaryCredentials structure if we didn't get it from logon
    //

    if (LogonOrdinal != SP_ORDINAL_LOGONUSEREX2)
    {
        PrimaryCredentials.LogonId = AuthenticationId;
        PrimaryCredentials.DomainName = *AuthenticatingAuthority;
        PrimaryCredentials.DownlevelName = *AccountName;
    }

    //
    // Locate the logon session
    //

    LogonSession = LsapLocateLogonSession(&Arguments->LogonId);

    if (LogonSession == NULL)
    {
        ASSERT(LogonSession != NULL);
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Done;
    }

    //
    // until we know otherwise, assume the package called is the real package.
    //

    RealLogonPackageId = AuthPackage->dwPackageID;

    if ((PrimaryCredentials.Flags & PRIMARY_CRED_PACKAGE_MASK) != 0)
    {
        ULONG RealLogonPackage;

        //
        // If the caller indicated that another package did the logon,
        // reset the logon package in the logon session.
        //

        RealLogonPackage = PrimaryCredentials.Flags >> PRIMARY_CRED_LOGON_PACKAGE_SHIFT;
        //
        // Locate the packge by RPC id
        //

        SupplementalPackage = SpmpLookupPackageByRpcId( RealLogonPackage );

        if (SupplementalPackage != NULL)
        {
            //
            // Update the creating package
            //

            ASSERT(LogonSession != NULL);

            LogonSession->CreatingPackage = SupplementalPackage->dwPackageID;

            //
            // update the package ID.
            //

            RealLogonPackageId = SupplementalPackage->dwPackageID;
        }
    }

    //
    // Don't release the logon session -- we may use it in the
    // License Server case below.
    //


    //
    // For some forms of kerberos logons (e.g. ticket logons, s4u) we want
    // to control the type of token generated.  This flag does that.
    //
    if ((PrimaryCredentials.Flags & PRIMARY_CRED_LOGON_NO_TCB) != 0)
    {
        UseIdentify = TRUE;
    }


    OriginalTokenType = TokenInformationType;

    //
    // Pass the token information through the Local Security Policy
    // Filter/Augmentor.  This may cause some or all of the token
    // information to be replaced/augmented.
    //

    SetCurrentPackageId( RealLogonPackageId );

    Status = LsapAuUserLogonPolicyFilter(
                 ActiveLogonType,
                 &TokenInformationType,
                 &TokenInformation,
                 Arguments->LocalGroups,
                 &QuotaLimits,
                 &PrivilegesAssigned,
                 FALSE
                 );

    SetCurrentPackageId( IntToPtr(SPMGR_ID) );

#if _WIN64

    //
    // QUOTA_LIMITS structure contains SIZE_Ts, which are
    // smaller on 32-bit.  Make sure we don't overflow the
    // client's buffer.
    //

    LsapGetCallInfo(&CallInfo);

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        PQUOTA_LIMITS_WOW64  pQuotaLimitsWOW64 = (PQUOTA_LIMITS_WOW64) &Arguments->Quotas;

        pQuotaLimitsWOW64->PagedPoolLimit        = (ULONG) min(ULONG_MAX, QuotaLimits.PagedPoolLimit);
        pQuotaLimitsWOW64->NonPagedPoolLimit     = (ULONG) min(ULONG_MAX, QuotaLimits.NonPagedPoolLimit);
        pQuotaLimitsWOW64->MinimumWorkingSetSize = (ULONG) min(ULONG_MAX, QuotaLimits.MinimumWorkingSetSize);
        pQuotaLimitsWOW64->MaximumWorkingSetSize = (ULONG) min(ULONG_MAX, QuotaLimits.MaximumWorkingSetSize);
        pQuotaLimitsWOW64->PagefileLimit         = (ULONG) min(ULONG_MAX, QuotaLimits.PagefileLimit);
        pQuotaLimitsWOW64->TimeLimit             = QuotaLimits.TimeLimit;
    }
    else
    {

#endif  // _WIN64

        Arguments->Quotas = QuotaLimits;

#if _WIN64

    }

#endif

    if ( !NT_SUCCESS(Status) )
    {
        goto Done;
    }

    //
    // Check if we only allow admins to logon.  We do allow null session
    // connections since they are severly restricted, though. Since the
    // token type may have been changed, we use the token type originally
    // returned by the package.
    //

    if (LsapAllowAdminLogonsOnly &&
        ((OriginalTokenType == LsaTokenInformationV1) ||
        (OriginalTokenType == LsaTokenInformationV2) ) &&
        !RtlEqualLuid(&Arguments->LogonId, &LocalServiceLuid) &&
        !RtlEqualLuid(&Arguments->LogonId, &NetworkServiceLuid) &&
        !LsapSidPresentInGroups(
            ((PLSA_TOKEN_INFORMATION_V2) TokenInformation)->Groups,
            (SID *)LsapAliasAdminsSid))
    {
        //
        // Set the status to be invalid workstation, since all accounts
        // except administrative ones are locked out for this
        // workstation.
        //

        Arguments->SubStatus = STATUS_INVALID_WORKSTATION;
        Status = STATUS_ACCOUNT_RESTRICTION;

        goto Done;
    }

    //
    // Call the LicenseServer
    //

    if ( CallLicenseServer )
    {
        HANDLE LicenseHandle;
        BOOLEAN IsAdmin = FALSE;

        //
        // Determine if we're logged on as administrator.
        //
        if ((( TokenInformationType == LsaTokenInformationV1) ||
             ( TokenInformationType == LsaTokenInformationV2))&&
            ((PLSA_TOKEN_INFORMATION_V2)TokenInformation)->Owner.Owner != NULL &&
            RtlEqualSid(
                ((PLSA_TOKEN_INFORMATION_V2)TokenInformation)->Owner.Owner,
                LsapAliasAdminsSid ) )
        {
            IsAdmin = TRUE;
        }

        //
        // Call the license server.
        //

        Status = LsaCallLicenseServer(
                    (Session->ClientProcessName != NULL) ? Session->ClientProcessName : L"",
                    AccountName,
                    AuthenticatingAuthority,
                    IsAdmin,
                    &LicenseHandle );

        if ( !NT_SUCCESS(Status) )
        {
            goto Done;
        }

        //
        // Save the LicenseHandle in the LogonSession so we can close the
        //  handle on logoff.
        //

        ASSERT(LogonSession != NULL);

        LogonSession->LicenseHandle = LicenseHandle;
    }

    //
    // Case on the token information returned (and subsequently massaged)
    // to create the correct kind of token.
    //

    switch (TokenInformationType) {

    case LsaTokenInformationNull:

        TokenInformationNull = TokenInformation;

        //
        // The user hasn't logged on to any particular account.
        // An impersonation token with WORLD as owner
        // will be created.
        //

        Status = LsapCreateNullToken(
                     &Arguments->LogonId,
                     &Arguments->SourceContext,
                     TokenInformationNull,
                     &Token
                     );

        //
        // Deallocate all the heap that was passed back from the
        // authentication package via the TokenInformation buffer.
        //

        UserSid = NULL;

        LsapFreeTokenInformationNull( TokenInformationNull );
        TokenInformation = NULL;

        break;

    case LsaTokenInformationV1:
    case LsaTokenInformationV2:

        TokenInformationV2 = TokenInformation;

        //
        // Copy out the User Sid
        //

        if ( NT_SUCCESS( Status ))
        {
            Status = LsapDuplicateSid(&UserSid,
                                      TokenInformationV2->User.User.Sid);

            if ( !NT_SUCCESS( Status ))
            {
                //
                // Don't worry about freeing the token info here -- it'll
                // happen when we break and error out of the function.
                //

                break;
            }
        }

        //
        // the type of token created depends upon the type of logon
        // being requested:
        //
        // Batch, Interactive, Service, (Unlock), and NewCredentials
        // all get a Primary token.  Network and NetworkCleartext
        // get an ImpersonationToken.
        //
        //

        if ( ( ActiveLogonType != Network ) &&
             ( ActiveLogonType != NetworkCleartext ) )
        {
            //
            // Primary token
            //

            Status = LsapCreateV2Token(
                         &Arguments->LogonId,
                         &Arguments->SourceContext,
                         TokenInformationV2,
                         (UseIdentify ? TokenImpersonation : TokenPrimary),
                         (UseIdentify ? SecurityIdentification : SecurityImpersonation),
                         &Token
                         );

            if (NT_SUCCESS( Status ) )
            {
                //
                // Tag the new token with the logon id of the caller,
                // for tracking:
                //

                LsapUpdateOriginInfo( Token );
                
            }
        }
        else
        {
            //
            // Impersonation token
            //

            Status = LsapCreateV2Token(
                         &Arguments->LogonId,
                         &Arguments->SourceContext,
                         TokenInformationV2,
                         TokenImpersonation,
                         (UseIdentify ? SecurityIdentification : SecurityImpersonation),
                         &Token
                         );
        }

        //
        // Deallocate all the heap that was passed back from the
        // authentication package via the TokenInformation buffer.
        //

        if(TokenInformationType == LsaTokenInformationV2)
        {
            LsapFreeTokenInformationV2( TokenInformation );
            TokenInformation = NULL;
        }
        else
        {
            LsapFreeTokenInformationV1( TokenInformation );
            TokenInformation = NULL;
        }

        break;
    }

    if ( !NT_SUCCESS(Status) )
    {
        goto Done;
    }
    else
    {
        //
        // Multi-User NT (HYDRA). Ensure the new token has client's SessionId
        //

        ASSERT(LogonSession != NULL);

        LogonSession->Session = SessionInfo.SessionId ;

        Status = NtSetInformationToken( Token, TokenSessionId,
                               &(SessionInfo.SessionId), sizeof( ULONG ) );

        ASSERT( NT_SUCCESS(Status) );
    }

    //
    // Set the token on the session
    //

    if ( NT_SUCCESS(Status) )
    {
        Status = LsapSetSessionToken( Token, &Arguments->LogonId );
    }

    //
    // Duplicate the token handle back into the calling process
    //

    if ( NT_SUCCESS(Status) )
    {
        Status = LsapDuplicateHandle(Token, &Arguments->Token);
    }

    IgnoreStatus = NtClose( Token );
    ASSERT( NT_SUCCESS(IgnoreStatus) );

    if ( !NT_SUCCESS(Status) )
    {
        goto Done;
    }

    //
    // Now call accept credentials for all packages that support it. We
    // don't do this for network logons because that requires delegation
    // which is not supported.
    //


    LSLog(( "Updating logon session %x:%x for logon type %d\n",
           PrimaryCredentials.LogonId.HighPart,
           PrimaryCredentials.LogonId.LowPart,
           ActiveLogonType ));

    if (ActiveLogonType != Network)
    {
        LsapUpdateNamesAndCredentials(ActiveLogonType,
                                      AccountName,
                                      &PrimaryCredentials,
                                      Credentials);
    }

Done:

    ActiveLogonType = Arguments->LogonType;

    if (NT_SUCCESS(Status))
    {
        if (PrimaryCredentials.Flags & PRIMARY_CRED_CACHED_LOGON)
        {
            if (ActiveLogonType == Interactive)
            {
                ActiveLogonType = CachedInteractive;
            }
            else if (ActiveLogonType == RemoteInteractive)
            {
                ActiveLogonType = CachedRemoteInteractive;
            }
        }
        else
        {
            if (ActiveLogonType == CachedRemoteInteractive)
            {
                ActiveLogonType = RemoteInteractive;
            }
        }
    }

    //
    // Free the local copy of the authentication information
    //

    LsapFreeLsaHeap( LocalAuthenticationInformation );
    LocalAuthenticationInformation = NULL;

    if (dwProgress & LOGONUSER_CLEANUP_TOKEN_GROUPS)
    {
        LsapFreeTokenGroups( Arguments->LocalGroups );
        Arguments->LocalGroups = ClientTokenGroups;   // Restore to client's value
    }

    if (LogonSession != NULL)
    {
        LsapReleaseLogonSession(LogonSession);
        LogonSession = NULL;
    }

    if (!NT_SUCCESS(Status))
    {
        if (dwProgress & LOGONUSER_CLEANUP_LOGON_SESSION)
        {
            //
            // Notify the logon package so it can clean up its
            // logon session information.
            //

            (AuthPackage->FunctionTable.LogonTerminated)( &Arguments->LogonId );

            //
            // And delete the logon session
            //

            IgnoreStatus = LsapDeleteLogonSession( &Arguments->LogonId );
            ASSERT( NT_SUCCESS(IgnoreStatus) );

            //
            // Free up the TokenInformation buffer and ProfileBuffer
            // and return the error.
            //

            IgnoreStatus = LsapClientFree(Arguments->ProfileBuffer);

            Arguments->ProfileBuffer = NULL;

            if (TokenInformation != NULL)
            {
                switch ( TokenInformationType )
                {
                    case LsaTokenInformationNull:
                        LsapFreeTokenInformationNull((PLSA_TOKEN_INFORMATION_NULL) TokenInformation);
                        break;

                    case LsaTokenInformationV1:
                        LsapFreeTokenInformationV1((PLSA_TOKEN_INFORMATION_V1) TokenInformation);
                        break;

                    case LsaTokenInformationV2:
                        LsapFreeTokenInformationV2((PLSA_TOKEN_INFORMATION_V2) TokenInformation);
                        break;
                }
            }
        }
    }

    if( AuthPackage )
    {
        SetCurrentPackageId(AuthPackage->dwPackageID);
    }

    //
    // Audit the logon attempt.  The event type and logged information
    // will depend to some extent on the whether we failed and why.
    //

    {
        PUNICODE_STRING NewUserName = NULL;
        PUNICODE_STRING NewUserDomain = NULL;

        if( (NT_SUCCESS(Status)) &&
            (OriginalTokenType == LsaTokenInformationNull) )
        {
            NewUserName   = &WellKnownSids[LsapAnonymousSidIndex].Name;
            NewUserDomain = &WellKnownSids[LsapAnonymousSidIndex].DomainName;
        }
        else
        {
            NewUserName   = AccountName;
            NewUserDomain = AuthenticatingAuthority;
        }

        //
        // generate the required audits. see function LsapAuGenerateLogonAudits
        // for more info
        //
        (void) LsapAuGenerateLogonAudits(
                   Status,
                   Arguments->SubStatus,
                   &ClientInfo,
                   &AuthenticationId,
                   ActiveLogonType, // Arguments->LogonType,
                   NewUserName,
                   NewUserDomain,
                   UserSid,
                   WorkstationName,
                   &Arguments->SourceContext
                   );
    }

    SetCurrentPackageId( IntToPtr(SPMGR_ID) );

    if ( ( Status == STATUS_LOGON_FAILURE ) &&
         (( Arguments->SubStatus == STATUS_WRONG_PASSWORD ) ||
          ( Arguments->SubStatus == STATUS_NO_SUCH_USER   )) ) {

        //
        // Blow away the substatus, we don't want it to
        // get back to our caller.
        //

        Arguments->SubStatus = STATUS_SUCCESS;
    }

    //
    // The WorkstationName is only used by the audit, free it here.
    //

    if (WorkstationName != NULL) {
        if (WorkstationName->Buffer != NULL) {
            LsapFreeLsaHeap( WorkstationName->Buffer );
        }
        LsapFreeLsaHeap( WorkstationName );
    }

    TmpStatus = STATUS_SUCCESS;

    //
    // Audit special privilege assignment, if there were any
    //

    if ( PrivilegesAssigned != NULL ) {

        //
        // Examine the list of privileges being assigned, and
        // audit special privileges as appropriate.
        //

        if ( NT_SUCCESS( Status )) {
            LsapAdtAuditSpecialPrivileges( PrivilegesAssigned, AuthenticationId, UserSid );
        }

        MIDL_user_free( PrivilegesAssigned );
    }

    //
    // Set the logon session names.
    //

    if (NT_SUCCESS(Status)) {

        //
        // If the original was a null session, set the user name & domain name
        // to be anonymous. If the allocation fail, just use the original name
        //

        if (OriginalTokenType == LsaTokenInformationNull) {
            LPWSTR TempAccountName;
            LPWSTR TempAuthorityName;

            TempAccountName = (LPWSTR) LsapAllocateLsaHeap(WellKnownSids[LsapAnonymousSidIndex].Name.MaximumLength);

            if (TempAccountName != NULL) {

                TempAuthorityName = (LPWSTR) LsapAllocateLsaHeap(WellKnownSids[LsapAnonymousSidIndex].DomainName.MaximumLength);

                if (TempAuthorityName != NULL) {

                    //
                    // Free the original names and copy the new names
                    // into the structures.
                    //

                    LsapFreeLsaHeap(AccountName->Buffer);
                    LsapFreeLsaHeap(AuthenticatingAuthority->Buffer);

                    AccountName->Buffer = TempAccountName;
                    AuthenticatingAuthority->Buffer = TempAuthorityName;

                    AccountName->MaximumLength = WellKnownSids[LsapAnonymousSidIndex].Name.MaximumLength;
                    RtlCopyUnicodeString(
                        AccountName,
                        &WellKnownSids[LsapAnonymousSidIndex].Name
                        );

                    AuthenticatingAuthority->MaximumLength = WellKnownSids[LsapAnonymousSidIndex].DomainName.MaximumLength;
                    RtlCopyUnicodeString(
                        AuthenticatingAuthority,
                        &WellKnownSids[LsapAnonymousSidIndex].DomainName
                        );
                }
                else
                {
                    LsapFreeLsaHeap(TempAccountName);
                }
            }
        }

        TmpStatus = LsapSetLogonSessionAccountInfo(
                        &AuthenticationId,
                        AccountName,
                        AuthenticatingAuthority,
                        NULL,
                        &UserSid,
                        Arguments->LogonType,
                        ((LogonOrdinal == SP_ORDINAL_LOGONUSEREX2) ? &PrimaryCredentials : NULL)
                        );
    }

    if (LogonOrdinal == SP_ORDINAL_LOGONUSEREX2)
    {
        if (PrimaryCredentials.DownlevelName.Buffer != NULL)
        {
            LsapFreeLsaHeap(PrimaryCredentials.DownlevelName.Buffer);
        }
        if (PrimaryCredentials.Password.Buffer != NULL)
        {
            SecureZeroMemory(
                PrimaryCredentials.Password.Buffer,
                PrimaryCredentials.Password.Length );

            LsapFreeLsaHeap(PrimaryCredentials.Password.Buffer);
        }
        if (PrimaryCredentials.DomainName.Buffer != NULL)
        {
            LsapFreeLsaHeap(PrimaryCredentials.DomainName.Buffer);
        }
        if (PrimaryCredentials.UserSid != NULL)
        {
            LsapFreeLsaHeap(PrimaryCredentials.UserSid);
        }
        if (PrimaryCredentials.LogonServer.Buffer != NULL)
        {
            LsapFreeLsaHeap(PrimaryCredentials.LogonServer.Buffer);
        }
        if (PrimaryCredentials.DnsDomainName.Buffer != NULL)
        {
            LsapFreeLsaHeap(PrimaryCredentials.DnsDomainName.Buffer);
        }
        if (PrimaryCredentials.Upn.Buffer != NULL)
        {
            LsapFreeLsaHeap(PrimaryCredentials.Upn.Buffer);
        }
        if (Credentials != NULL)
        {
            LsapFreeLsaHeap(Credentials);
        }
    }

    //
    // If we already had an error, or we receive an error from setting the
    // logon , free any buffers related to the logon session.
    //

    if ((!NT_SUCCESS(Status)) || (!NT_SUCCESS(TmpStatus))) {

        if (AccountName != NULL) {
            if (AccountName->Buffer != NULL) {
                LsapFreeLsaHeap( AccountName->Buffer );
            }
            LsapFreeLsaHeap( AccountName );
            AccountName = NULL ;
        }

        if (AuthenticatingAuthority != NULL) {
            if (AuthenticatingAuthority->Buffer != NULL) {
                LsapFreeLsaHeap( AuthenticatingAuthority->Buffer );
            }
            LsapFreeLsaHeap( AuthenticatingAuthority );
            AuthenticatingAuthority = NULL ;
        }
    }

    if ( NT_SUCCESS( Status ) )
    {
        if ( AccountName )
        {
            LsapFreeLsaHeap( AccountName );
        }

        if ( AuthenticatingAuthority )
        {
            LsapFreeLsaHeap( AuthenticatingAuthority );
        }
    }

    if ( UserSid != NULL ) {
        LsapFreeLsaHeap( UserSid );
    }

    return Status;
}


NTSTATUS
LsapCreateNullToken(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN PLSA_TOKEN_INFORMATION_NULL TokenInformationNull,
    OUT PHANDLE Token
    )

/*++

Routine Description:

    This function creates a token representing a null logon.

Arguments:

    LogonId - The logon ID to assign to the new token.

    TokenSource - Points to the value to use as the source of the token.

    TokenInformationNull - Information received from the authentication
        package authorizing this logon.

    Token - receives the new token's handle value.  The token is opened
        for TOKEN_ALL_ACCESS.


Return Value:

    The status value of the NtCreateToken() call.



--*/

{
    NTSTATUS Status;

    TOKEN_USER UserId;
    TOKEN_PRIMARY_GROUP PrimaryGroup;
    TOKEN_GROUPS GroupIds;
    TOKEN_PRIVILEGES Privileges;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE ImpersonationQos;

    //
    // ISSUE: this token is not meant to be used in access check, the token 
    // built here differs from that of NtImpersonateAnonymousToken() and 
    // the anonymous token created by LSA/SSPs
    //

    UserId.User.Sid = LsapAnonymousSid;
    UserId.User.Attributes = 0;
    GroupIds.GroupCount = 0;
    Privileges.PrivilegeCount = 0;
    PrimaryGroup.PrimaryGroup = LsapAnonymousSid;

    //
    // Set the object attributes to specify an Impersonation impersonation
    // level.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );
    ImpersonationQos.ImpersonationLevel = SecurityImpersonation;
    ImpersonationQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    ImpersonationQos.EffectiveOnly = TRUE;
    ImpersonationQos.Length = (ULONG)sizeof(SECURITY_QUALITY_OF_SERVICE);
    ObjectAttributes.SecurityQualityOfService = &ImpersonationQos;

    Status = NtCreateToken(
                 Token,                    // Handle
                 (TOKEN_ALL_ACCESS),       // DesiredAccess
                 &ObjectAttributes,        // ObjectAttributes
                 TokenImpersonation,       // TokenType
                 LogonId,                  // Authentication LUID
                 &TokenInformationNull->ExpirationTime,
                                           // Expiration Time
                 &UserId,                  // User ID
                 &GroupIds,                // Group IDs
                 &Privileges,              // Privileges
                 NULL,                     // Owner
                 &PrimaryGroup,            // Primary Group
                 NULL,                     // Default Dacl
                 TokenSource               // TokenSource
                 );

    if (NT_SUCCESS(Status))
    {
        Status = LsapAdtLogonPerUserAuditing(
                     UserId.User.Sid,
                     LogonId,
                     *Token
                     );

        if (!NT_SUCCESS(Status))
        {
            NtClose(*Token);
            *Token = NULL;
        }
    }

    return Status;
}

NTSTATUS
LsapCreateTokenDacl(
    IN OPTIONAL PTOKEN_USER ProcessUser,
    IN OPTIONAL PTOKEN_OWNER ProcessOwner,
    IN OPTIONAL PTOKEN_USER TheTokenUser,
    OUT SECURITY_DESCRIPTOR* SecDesc,
    OUT ACL** Dacl
    )

/*++

Routine Description:

    This function creates the DACL for tokens.

Arguments:

    ProcessUser - Process user to grant access to.
    
    ProcessOwner - Process owner to grant access to.
    
    TokenUser - Token user to grant access to.
    
    SecDesc - receives the new secrity descriptors.
    
    Dacl - receives the DACL that need to be freed via LsapFreePrivateHeap.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;

    ULONG AclLength;
    PACL Acl = NULL;
    PSession Session = GetCurrentSession();
    UCHAR OwnerBuffer[ 64 ];
    UCHAR UserBuffer[ 64 ];
    HANDLE ProcessToken;
    ULONG Size;

    *Dacl = NULL;

    if ( Session )
    {
        if ( (!ProcessUser && !ProcessOwner)
             && OpenProcessToken( Session->hProcess,
                    TOKEN_QUERY,
                    &ProcessToken ) )
        {
            ProcessUser = (PTOKEN_USER) UserBuffer;

            Status = NtQueryInformationToken( ProcessToken,
                                              TokenUser,
                                              ProcessUser,
                                              sizeof( UserBuffer ),
                                              &Size );
            if ( !NT_SUCCESS( Status ) )
            {
                ProcessUser = NULL;
            }

            ProcessOwner = (PTOKEN_OWNER) OwnerBuffer ;

            Status = NtQueryInformationToken( ProcessToken,
                                              TokenOwner,
                                              ProcessOwner,
                                              sizeof( OwnerBuffer ),
                                              &Size );

            if ( !NT_SUCCESS( Status ) )
            {
                ProcessOwner = NULL;
            }

            NtClose( ProcessToken );
        }

        //
        // if process owner is the same as process user, skip process owner
        //

        if ( ProcessUser && ProcessOwner && RtlEqualSid( ProcessOwner->Owner, ProcessUser->User.Sid ) )
        {
            ProcessOwner = NULL;
        }

        //
        // if token user is the same as process user, skip token user
        //

        if (ProcessUser && TheTokenUser && RtlEqualSid(TheTokenUser->User.Sid, ProcessUser->User.Sid))
        {
            TheTokenUser = NULL;
        }

        //
        // If this is a local system create, then the default object DACL is fine.  Skip
        // all this.  Otherwise, create the acl
        //

        if (ProcessUser && RtlEqualSid( ProcessUser->User.Sid, LsapLocalSystemSid )) 
        {
            ProcessUser = NULL;
            ProcessOwner = NULL;
        }

        //
        // if token user is localsystem, no need to add it again
        //

        if (TheTokenUser && RtlEqualSid( TheTokenUser->User.Sid, LsapLocalSystemSid )) 
        {
            TheTokenUser = NULL;
        }

        if ( ProcessUser || ProcessOwner || TokenUser )
        {
            AclLength = sizeof( ACL ) +
                        sizeof( ACCESS_ALLOWED_ACE ) +
                            RtlLengthSid( LsapLocalSystemSid ) - sizeof( ULONG ) +
                        sizeof( ACCESS_ALLOWED_ACE ) +
                            RtlLengthSid( LsapAliasAdminsSid ) - sizeof( ULONG );

            if ( ProcessOwner )
            {
                AclLength += sizeof( ACCESS_ALLOWED_ACE ) +
                                RtlLengthSid( ProcessOwner->Owner ) - sizeof( ULONG );
            }

            if ( ProcessUser )
            {
                AclLength += sizeof( ACCESS_ALLOWED_ACE ) +
                                RtlLengthSid( ProcessUser->User.Sid ) - sizeof( ULONG );
            }

            if (TheTokenUser) 
            {
                AclLength += sizeof( ACCESS_ALLOWED_ACE ) +
                    RtlLengthSid( TheTokenUser->User.Sid ) - sizeof( ULONG );
            }

            Acl = LsapAllocatePrivateHeap( AclLength );

            if ( Acl )
            {
                RtlCreateAcl( Acl, AclLength, ACL_REVISION2 );

                RtlAddAccessAllowedAce( Acl,
                                        ACL_REVISION2,
                                        TOKEN_ALL_ACCESS,
                                        LsapLocalSystemSid );

                RtlAddAccessAllowedAce( Acl,
                                        ACL_REVISION2,
                                        TOKEN_READ,
                                        LsapAliasAdminsSid );

                if ( ProcessOwner )
                {
                    RtlAddAccessAllowedAce( Acl,
                                            ACL_REVISION2,
                                            TOKEN_ALL_ACCESS,
                                            ProcessOwner->Owner );
                }

                if ( ProcessUser )
                {
                    RtlAddAccessAllowedAce( Acl,
                                            ACL_REVISION2,
                                            TOKEN_ALL_ACCESS,
                                            ProcessUser->User.Sid );
                }

                if ( TheTokenUser )
                {
                    RtlAddAccessAllowedAce( Acl,
                                            ACL_REVISION2,
                                            TOKEN_ALL_ACCESS,
                                            TheTokenUser->User.Sid );
                }
                
                RtlCreateSecurityDescriptor( SecDesc,
                                             SECURITY_DESCRIPTOR_REVISION );

                RtlSetDaclSecurityDescriptor( SecDesc,
                                              TRUE,
                                              Acl,
                                              FALSE );

                if ( ProcessOwner )
                {
                    RtlSetOwnerSecurityDescriptor( SecDesc,
                                                   ProcessOwner->Owner,
                                                   FALSE );
                }
            }
        }
    }

    *Dacl = Acl;
    Acl = NULL;

    Status = STATUS_SUCCESS;

// Cleanup:
   
     if (Acl) 
     {
         LsapFreePrivateHeap( Acl );
     }

     return Status;
}

NTSTATUS
LsaISetTokenDacl(
    IN HANDLE Token
    )

/*++

Routine Description:

    This function sets the DACL for the token.

Arguments:

    Token - The handle to the token to adjust DACL for.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    PACL Acl = NULL;
    SECURITY_DESCRIPTOR SecDesc = {0};
    PTOKEN_USER ProcessUser = NULL;
    PTOKEN_USER TheTokenUser = NULL;
    CHAR TokenUserBuff[sizeof(TOKEN_USER) + SECURITY_MAX_SID_SIZE] = {0};
    ULONG cbReturnLength = 0;

    Status = NtQueryInformationToken(
                Token,
                TokenUser, 
                TokenUserBuff,
                sizeof(TokenUserBuff),
                &cbReturnLength
                );

    if (!NT_SUCCESS(Status)) 
    {
        goto Cleanup;
    }

    TheTokenUser = (TOKEN_USER*) TokenUserBuff;     

    //
    // Create the security descriptor for the token itself.
    //

    Status = LsapCreateTokenDacl(
                 ProcessUser,
                 NULL, // no process owner supplied
                 TheTokenUser,
                 &SecDesc,
                 &Acl
                 );

    if (!NT_SUCCESS(Status)) 
    {
        goto Cleanup;
    }

    Status = NtSetSecurityObject(
                 Token,
                 DACL_SECURITY_INFORMATION,
                 &SecDesc
                 );

Cleanup:
   
     if (Acl) 
     {
         LsapFreePrivateHeap( Acl );
     }

     return Status;
}

NTSTATUS
LsapCreateV2Token(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN PLSA_TOKEN_INFORMATION_V2 TokenInformationV2,
    IN TOKEN_TYPE TokenType,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE Token
    )

/*++

Routine Description:

    This function creates a token from the information in a
    TOKEN_INFORMATION_V2 structure.

Arguments:

    LogonId - The logon ID to assign to the new token.

    TokenSource - Points to the value to use as the source of the token.

    TokenInformationV2 - Information received from the authentication
        package authorizing this logon.

    TokenType - The type of token (Primary or impersonation) to create.

    ImpersonationLevel - Level of impersonation to use for impersonation
        tokens.

    Token - receives the new token's handle value.  The token is opened
        for TOKEN_ALL_ACCESS.


Return Value:

    The status value of the NtCreateToken() call.



--*/

{
    NTSTATUS Status;

    PTOKEN_OWNER Owner;
    PTOKEN_USER ProcessUser = NULL;
    PTOKEN_USER TheTokenUser = NULL;
    PTOKEN_DEFAULT_DACL Dacl;
    TOKEN_PRIVILEGES NoPrivileges;
    PTOKEN_PRIVILEGES Privileges;

    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE ImpersonationQos;
    PACL Acl = NULL;
    SECURITY_DESCRIPTOR SecDesc = {0};
    LUID LocalServiceLuid = LOCALSERVICE_LUID;
    LUID NetworkServiceLuid = NETWORKSERVICE_LUID;

    TheTokenUser = &TokenInformationV2->User;

    //
    // Set an appropriate Owner and DefaultDacl argument value
    //

    Owner = NULL;
    if ( TokenInformationV2->Owner.Owner != NULL ) {
        Owner = &TokenInformationV2->Owner;
    }

    Dacl = NULL;
    if ( TokenInformationV2->DefaultDacl.DefaultDacl !=NULL ) {
       Dacl = &TokenInformationV2->DefaultDacl;
    }

    if ( TokenInformationV2->Privileges == NULL ) {
       Privileges = &NoPrivileges;
       NoPrivileges.PrivilegeCount = 0;
    } else {
       Privileges = TokenInformationV2->Privileges;
    }

    //
    // Create the security descriptor for the token itself.
    //

    Status = LsapCreateTokenDacl(
                 ProcessUser,
                 NULL, // no process owner supplied
                 TheTokenUser,
                 &SecDesc,
                 &Acl
                 );

    if (!NT_SUCCESS(Status)) 
    {
        goto Cleanup;
    }

    //
    // Create the token - The impersonation level is only looked at
    // if the token type is TokenImpersonation.
    //

    if ( Acl )
    {
        InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, &SecDesc );
    }
    else
    {
        InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );
    }

    ImpersonationQos.ImpersonationLevel = ImpersonationLevel;
    ImpersonationQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    ImpersonationQos.EffectiveOnly = FALSE;
    ImpersonationQos.Length = (ULONG)sizeof(SECURITY_QUALITY_OF_SERVICE);
    ObjectAttributes.SecurityQualityOfService = &ImpersonationQos;

    Status =
        NtCreateToken(
            Token,                                   // Handle
            (TOKEN_ALL_ACCESS),                      // DesiredAccess
            &ObjectAttributes,                       // ObjectAttributes
            TokenType,                               // TokenType
            LogonId,                                 // Authentication LUID
            &TokenInformationV2->ExpirationTime,     // Expiration Time
            &TokenInformationV2->User,               // User ID
            TokenInformationV2->Groups,              // Group IDs
            Privileges,                              // Privileges
            Owner,                                   // Owner
            &TokenInformationV2->PrimaryGroup,       // Primary Group
            Dacl,                                    // Default Dacl
            TokenSource                              // TokenSource
            );

    if (NT_SUCCESS(Status))
    {
        Status = LsapAdtLogonPerUserAuditing(
                     TokenInformationV2->User.User.Sid,
                     LogonId,
                     *Token
                     );

        if (!NT_SUCCESS(Status))
        {
            NtClose(*Token);
            *Token = NULL;
        }
    }

Cleanup:

    if ( Acl )
    {
        LsapFreePrivateHeap( Acl );
    }

    return Status;
}


NTSTATUS
LsapCaptureClientTokenGroups(
    IN PLSAP_CLIENT_REQUEST ClientRequest,
    IN ULONG GroupCount,
    IN PTOKEN_GROUPS ClientTokenGroups,
    OUT PTOKEN_GROUPS *CapturedTokenGroups
    )

/*++

Routine Description:

    This function retrieves a copy of a TOKEN_GROUPS structure from a
    client process.

    This is a messy operation because it involves so many virtual memory
    read requests.  First the variable length TOKEN_GROUPS structure must
    be retrieved.  Then, for each SID, the SID header must be retrieved
    so that the SubAuthorityCount can be used to calculate the length of
    the SID, which is susequently retrieved.

Arguments:

    ClientRequest - Identifies the client.

    GroupCount - Indicates the number of groups in the TOKEN_GROUPS.

    ClientTokenGroups - Points to a TOKEN_GROUPS structure to be captured from
        the client process.

    CapturedTokenGroups - Receives a pointer to the captured token groups.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES - Indicates not enough resources are
        available to the LSA to handle the request right now.

    Any status value returned by LsapCopyFromClientBuffer().



--*/

{

    NTSTATUS Status;
    ULONG i, Length, RetrieveCount, SidHeaderLength;
    PTOKEN_GROUPS LocalGroups;
    PSID SidHeader, NextClientSid;


    if ( GroupCount == 0) {
        (*CapturedTokenGroups) = NULL;
        return STATUS_SUCCESS;
    }



    //
    // First the variable length TOKEN_GROUPS structure
    // is retrieved.
    //

    Length = (ULONG)sizeof(TOKEN_GROUPS)
             + GroupCount * (ULONG)sizeof(SID_AND_ATTRIBUTES)
             - ANYSIZE_ARRAY * (ULONG)sizeof(SID_AND_ATTRIBUTES);

    LocalGroups = LsapAllocatePrivateHeap( Length );
    (*CapturedTokenGroups) = LocalGroups;
    if ( LocalGroups == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = LsapCopyFromClientBuffer (
                 (PLSA_CLIENT_REQUEST)ClientRequest,
                 Length,
                 LocalGroups,
                 ClientTokenGroups
                 );


    if (!NT_SUCCESS(Status) ) {
        LsapFreePrivateHeap( LocalGroups );
        return Status;
    }



    //
    // Now retrieve each group
    //

    RetrieveCount = 0;     // Used for cleanup, if necessary.
    SidHeaderLength  = RtlLengthRequiredSid( 0 );
    SidHeader = LsapAllocatePrivateHeap( SidHeaderLength );
    if ( SidHeader == NULL ) {
        LsapFreePrivateHeap( LocalGroups );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = STATUS_SUCCESS;
    i = 0;
    while ( i < LocalGroups->GroupCount ) {

        //
        // Retrieve the next SID header
        //

        NextClientSid = LocalGroups->Groups[i].Sid;
        Status = LsapCopyFromClientBuffer (
                     (PLSA_CLIENT_REQUEST)ClientRequest,
                     SidHeaderLength,
                     SidHeader,
                     NextClientSid
                     );
        if ( !NT_SUCCESS(Status) ) {
            break;
        }

        //
        // and use the header information to get the whole SID
        //

        Length = RtlLengthSid( SidHeader );
        LocalGroups->Groups[i].Sid = LsapAllocatePrivateHeap( Length );

        if ( LocalGroups->Groups[i].Sid == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        } else {
            RetrieveCount += 1;
        }



        Status = LsapCopyFromClientBuffer (
                     (PLSA_CLIENT_REQUEST)ClientRequest,
                     Length,
                     LocalGroups->Groups[i].Sid,
                     NextClientSid
                     );
        if ( !NT_SUCCESS(Status) ) {
            break;
        }


        i += 1;

    }
    LsapFreePrivateHeap( SidHeader );


    if ( NT_SUCCESS(Status) ) {
        return Status;
    }



    //
    // There was a failure along the way.
    // We need to deallocate what has already been allocated.
    //

    i = 0;
    while ( i < RetrieveCount ) {
        LsapFreePrivateHeap( LocalGroups->Groups[i].Sid );
        i += 1;
    }

    LsapFreePrivateHeap( LocalGroups );

    return Status;
}


NTSTATUS
LsapBuildDefaultTokenGroups(
    PLSAP_LOGON_USER_ARGS Arguments
    )
/*++

Routine Description:

    This function builds the default token groups inserted into a token
    during a non-privileged call to LsaLogonUser().

--*/
{
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;

    LUID Luid;
    PTOKEN_GROUPS TokenGroups = NULL;
    PSID LocalSid = NULL;
    PSID LogonSid = NULL;
    ULONG Length;
    ULONG TokenGroupCount;
    BOOLEAN AddLocalSid = FALSE;

    NTSTATUS Status = STATUS_SUCCESS;


    Arguments->LocalGroupsCount = 0;
    Arguments->LocalGroups = NULL;

    Status = NtAllocateLocallyUniqueId( &Luid );

    if(!NT_SUCCESS( Status ))
    {
        return Status;
    }

    //
    // Add to Local Sid only for service logon and batch logon
    //  (Winlogon adds it for the correct subset of interactive logons)
    //

    TokenGroupCount = 1;
    if ( Arguments->LogonType == Service ||
         Arguments->LogonType == Batch ) {

        TokenGroupCount ++;
        AddLocalSid = TRUE;

    }


    //
    // Allocate the array of token groups
    //

    Length = sizeof(TOKEN_GROUPS) +
                  (TokenGroupCount - ANYSIZE_ARRAY) * sizeof(SID_AND_ATTRIBUTES)
                  ;

    TokenGroups = (PTOKEN_GROUPS) LsapAllocatePrivateHeap( Length );

    if (TokenGroups == NULL) {
        return(STATUS_NO_MEMORY);
    }

    TokenGroups->GroupCount = 0;

    //
    // Add to Local Sid only for service logon and batch logon
    //  (Winlogon adds it for the correct subset of interactive logons)
    //


    if ( AddLocalSid ) {

        Length = RtlLengthRequiredSid( 1 );

        LocalSid = (PSID)LsapAllocatePrivateHeap( Length );

        if (LocalSid == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        RtlInitializeSid(LocalSid, &LocalSidAuthority, 1);
        *(RtlSubAuthoritySid(LocalSid, 0)) = SECURITY_LOCAL_RID;

        TokenGroups->Groups[TokenGroups->GroupCount].Sid = LocalSid;
        TokenGroups->Groups[TokenGroups->GroupCount].Attributes =
                SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
                SE_GROUP_ENABLED_BY_DEFAULT;

        TokenGroups->GroupCount++;
    }


    //
    // Add the logon Sid
    //

    Length = RtlLengthRequiredSid(SECURITY_LOGON_IDS_RID_COUNT);

    LogonSid = (PSID)LsapAllocatePrivateHeap( Length );

    if (LogonSid == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlInitializeSid(LogonSid, &SystemSidAuthority, SECURITY_LOGON_IDS_RID_COUNT);

    ASSERT(SECURITY_LOGON_IDS_RID_COUNT == 3);

    *(RtlSubAuthoritySid(LogonSid, 0)) = SECURITY_LOGON_IDS_RID;
    *(RtlSubAuthoritySid(LogonSid, 1)) = Luid.HighPart;
    *(RtlSubAuthoritySid(LogonSid, 2)) = Luid.LowPart;


    TokenGroups->Groups[TokenGroups->GroupCount].Sid = LogonSid;
    TokenGroups->Groups[TokenGroups->GroupCount].Attributes =
            SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
            SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_LOGON_ID;

    TokenGroups->GroupCount++;

    //
    // Return the groups to the caller
    //

    Arguments->LocalGroupsCount = TokenGroups->GroupCount;
    Arguments->LocalGroups = TokenGroups;

Cleanup:

    if(!NT_SUCCESS( Status ))
    {
        if( LocalSid != NULL )
        {
            LsapFreePrivateHeap( LocalSid );
        }
        if( LogonSid != NULL )
        {
            LsapFreePrivateHeap( LogonSid );
        }
        if( TokenGroups != NULL )
        {
            LsapFreePrivateHeap( TokenGroups );
        }
    }


    return Status;
}


VOID
LsapFreeTokenGroups(
    IN PTOKEN_GROUPS TokenGroups OPTIONAL
    )

/*++

Routine Description:

    This function frees the local groups of a logon user arguments buffer.
    The local groups are expected to have been captured into the server
    process.


Arguments:

    TokenGroups - Points to the TOKEN_GROUPS to be freed.  This may be
        NULL, allowing the caller to pass whatever was returned by
        LsapCaptureClientTokenGroups() - even if there were no local
        groups.

Return Value:

    None.

--*/

{

    ULONG i;

    if ( !ARGUMENT_PRESENT(TokenGroups) ) {
        return;
    }


    i = 0;
    while ( i < TokenGroups->GroupCount ) {
        LsapFreePrivateHeap( TokenGroups->Groups[i].Sid );
        i += 1;
    }

    LsapFreePrivateHeap( TokenGroups );

    return;

}


VOID
LsapFreeTokenInformationNull(
    IN PLSA_TOKEN_INFORMATION_NULL TokenInformationNull
    )

/*++

Routine Description:

    This function frees the allocated structures associated with a
    LSA_TOKEN_INFORMATION_NULL data structure.


Arguments:

    TokenInformationNull - Pointer to the data structure to be released.

Return Value:

    None.

--*/

{

    LsapFreeTokenGroups( TokenInformationNull->Groups );
    LsapFreeLsaHeap( TokenInformationNull );

}


VOID
LsapFreeTokenInformationV1(
    IN PLSA_TOKEN_INFORMATION_V1 TokenInformationV1
    )

/*++

Routine Description:

    This function frees the allocated structures associated with a
    LSA_TOKEN_INFORMATION_V1 data structure.


Arguments:

    TokenInformationV1 - Pointer to the data structure to be released.

Return Value:

    None.

--*/

{

    //
    // Free the user SID (a required field)
    //

    LsapFreeLsaHeap( TokenInformationV1->User.User.Sid );


    //
    // Free any groups present
    //

    LsapFreeTokenGroups( TokenInformationV1->Groups );



    //
    // Free the primary group.
    // This is a required field, but it is freed only if non-NULL
    // so this routine can be used by the filter routine while building
    // a V1 token information structure.
    //


    if ( TokenInformationV1->PrimaryGroup.PrimaryGroup != NULL ) {
        LsapFreeLsaHeap( TokenInformationV1->PrimaryGroup.PrimaryGroup );
    }



    //
    // Free the privileges.
    // If there are no privileges this field will be NULL.
    //


    if ( TokenInformationV1->Privileges != NULL ) {
       LsapFreeLsaHeap( TokenInformationV1->Privileges );
    }



    //
    // Free the owner SID, if one is present
    //

    if ( TokenInformationV1->Owner.Owner != NULL) {
        LsapFreeLsaHeap( TokenInformationV1->Owner.Owner );
    }




    //
    // Free the default DACL if one is present.
    //

    if ( TokenInformationV1->DefaultDacl.DefaultDacl != NULL) {
        LsapFreeLsaHeap( TokenInformationV1->DefaultDacl.DefaultDacl );
    }



    //
    // Free the structure itself.
    //

    LsapFreeLsaHeap( TokenInformationV1 );


}


VOID
LsapFreeTokenInformationV2(
    IN PLSA_TOKEN_INFORMATION_V2 TokenInformationV2
    )

/*++

Routine Description:

    This function frees the allocated structures associated with a
    LSA_TOKEN_INFORMATION_V2 data structure.


Arguments:

    TokenInformationV2 - Pointer to the data structure to be released.

Return Value:

    None.

--*/

{
    LsapFreeLsaHeap( TokenInformationV2 );
}


VOID
LsapAuLogonTerminatedPackages(
    IN PLUID LogonId
    )

/*++

Routine Description:

    This function notifies all loaded authentication packages that a logon
    session is about to be deleted.  The reference monitor portion of the
    logon session has already been deleted, and the LSA portion will be
    immediately after this routine completes.

    To protect themselves against each other, authentication packages should
    assume that the logon session does not necessarily currently exist.
    That is, if the authentication package goes to query information from the
    logon session credential information, and finds no such logon session,
    it may be due to an error in another authentication package.



Arguments:

    LogonId - The LUID of the logon session.


Return Value:

    None.


--*/

{
    PLSAP_SECURITY_PACKAGE AuthPackage;
    ULONG_PTR PackageId = GetCurrentPackageId();

    //
    // Look at each loaded package for a name match
    //


    AuthPackage = SpmpIteratePackagesByRequest( NULL, SP_ORDINAL_LOGONTERMINATED );
    while ( AuthPackage != NULL ) {


        SetCurrentPackageId(AuthPackage->dwPackageID);

        //
        // Now call the package...
        //


        (AuthPackage->FunctionTable.LogonTerminated)( LogonId );

        AuthPackage = SpmpIteratePackagesByRequest( AuthPackage, SP_ORDINAL_LOGONTERMINATED );

    }

    SetCurrentPackageId( PackageId );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\eserver.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    eserver.c

Abstract:

    EFS RPC server code.

Author:

    Robert Gu       (RobertG)    Aug, 1997

Environment:

Revision History:

--*/

#define UNICODE

#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <lsapch2.h>
#include <efsrpc.h>
#include <efsstruc.h>
#include <lm.h>
#include "efssrv.hxx"
#include <rpcasync.h>

#define PATHTOOLONG  (5*1024)
#define TOOMANYUSER  (500)
#define SDTOOBIG     (260*1024)

extern BOOLEAN EfsPersonalVer;
extern BOOLEAN EfsDisabled;

long GetLocalFileName(
    LPCWSTR FileName,
    LPWSTR *LocalFileName,
    WORD   *Flag
    );

BOOL EfsShareDecline(
    LPCWSTR FileName,
    BOOL    VerifyShareAccess,
    DWORD   dwDesiredAccess
    )
/*++

Routine Description:

    Check to see if the FileName is a UNC name and if the user could access the share.
    
Arguments:

    FileName -- File UNC name.
    
    VerifyShareAccess -- if we need to verify the access.
    
    dwDesiredAccess -- Desired access.


Return Value:

    TRUE if the user can't access the file.

--*/
{
    BOOL b = TRUE;
    DWORD FileNameLength = (DWORD) wcslen(FileName);

    if (FileNameLength >= 3) {
        if ((FileName[0] == L'\\') && (FileName[1] == L'\\' )) {

            //
            //  Check if somebody play the trick \\?\
            //

            if ((FileName[2] != L'?')) {

                //
                //  This is a UNC name. If bad name passed in , we will catch later.
                //

                b = FALSE;

            } else {

                //
                // A RPC attack. Do not give good error, such as ERROR_INVALID_PARAMETER.
                // Just return ACCESS_DENIED.
                //

                SetLastError(ERROR_ACCESS_DENIED);

            }
        } else {

            SetLastError(ERROR_ACCESS_DENIED);

        }
    } else {

        SetLastError(ERROR_ACCESS_DENIED);

    }

    if (!b && VerifyShareAccess) {

        LPWSTR  NetFileName = NULL;
        HANDLE  hFile;

        if ( FileNameLength >= MAX_PATH ) {

            //
            // We need \\?\UNC\server\share\dir\file format to open the file.
            //

            NetFileName = LsapAllocateLsaHeap( (FileNameLength + 8) * sizeof (WCHAR) );
            if (!NetFileName) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return TRUE;
            }

            wcscpy(NetFileName, L"\\\\?\\UNC");
            wcscat(NetFileName, &FileName[1]);

        } else {

            NetFileName = (LPWSTR) FileName;

        }

        //
        //  Testing for access rights
        //

        hFile = CreateFile(
                   NetFileName,
                   dwDesiredAccess,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL,
                   OPEN_EXISTING,
                   FILE_FLAG_BACKUP_SEMANTICS, // In case this is a directory
                   NULL
                   );

        if (hFile != INVALID_HANDLE_VALUE) {
            
            
            CloseHandle( hFile );

        } else {

            b = TRUE;

        }

        if (NetFileName != FileName) {
            LsapFreeLsaHeap( NetFileName );
        }

    }

    return b;

}

BOOL EfsCheckForNetSession(
    )
/*++

Routine Description:

    Check to see if the session is from network
        
Arguments:

Return Value:

    TRUE if the session is network session.

--*/
{

    NTSTATUS Status;
    HANDLE TokenHandle;
    ULONG ReturnLength;
    BOOL  b = FALSE;
    BYTE  PefBuffer[1024];

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY,
                 TRUE,                    // OpenAsSelf
                 &TokenHandle
                 );

    if (NT_SUCCESS( Status )) {

        Status = NtQueryInformationToken (
                     TokenHandle,
                     TokenGroups,
                     PefBuffer,
                     sizeof (PefBuffer),
                     &ReturnLength
                     );

        if (NT_SUCCESS( Status ) || (Status == STATUS_BUFFER_TOO_SMALL)) {

            PTOKEN_GROUPS pGroups = NULL;
            PTOKEN_GROUPS pAllocGroups = NULL;

            if ( NT_SUCCESS( Status ) ) {

                pGroups = (PTOKEN_GROUPS) PefBuffer;

            } else {

                pAllocGroups = (PTOKEN_GROUPS)LsapAllocateLsaHeap( ReturnLength );

                if (pAllocGroups) {

                    Status = NtQueryInformationToken (
                                 TokenHandle,
                                 TokenGroups,
                                 pAllocGroups,
                                 ReturnLength,
                                 &ReturnLength
                                 );
    
                    if ( NT_SUCCESS( Status )) {
    
                       pGroups = pAllocGroups;
    
                    }

                }


            }


            if (pGroups) {

                //
                // Search the network SID. Looks like this SID tends to appear at the
                // end of the list. We search from back to the first.
                //

                int SidIndex;

                for ( SidIndex = (int)(pGroups->GroupCount - 1); SidIndex >= 0; SidIndex--) {
                    if (RtlEqualSid(LsapNetworkSid, pGroups->Groups[SidIndex].Sid)) {
                        b = TRUE;
                        break;
                    }
                }

            } else {

                //
                // Playing safe here. Any failure in this routine will assume net session.
                //
        
                b = TRUE;

            }

            if (pAllocGroups) {
                LsapFreeLsaHeap( pAllocGroups );
            }

        } else {

            //
            // Playing safe here. Any failure in this routine will assume net session.
            //
    
            b = TRUE;

        }

        NtClose( TokenHandle );

    } else {

        //
        // Playing safe here. Any failure in this routine will assume net session.
        //

        b = TRUE;

    }

    return( b );
}

long EfsRpcOpenFileRaw(
    handle_t binding_h,
    PPEXIMPORT_CONTEXT_HANDLE pphContext,
    wchar_t __RPC_FAR *FileName,
    long Flags
    )
/*++

Routine Description:

    RPC Stub code for EFS Server EfsOpenFileRaw()

Arguments:

    binding_h -- Binding handle.

    pphContext -- RPC context handle.

    FileName -- Target file name.

    Flags -- Flags of the open request.

Return Value:

    Result of the operation.

--*/
{
    DWORD   hResult;
    LPWSTR LocalFileName;
    BOOL    NetSession = TRUE;
    WORD    WebDavPath;

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    if ((pphContext == NULL) && (FileName == NULL)) {

        //
        // Possible RPC attack, don't tell the caller that the parameter is wrong.
        //

        //return ERROR_INVALID_PARAMETER;
        return ERROR_ACCESS_DENIED;
    }

    *pphContext = (PEXIMPORT_CONTEXT_HANDLE) NULL;
    hResult = GetLocalFileName(
                        FileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcOpenFileRaw: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult =  RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        LsapFreeLsaHeap( LocalFileName );
        DebugLog((DEB_ERROR, "EfsRpcOpenFileRaw: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        return( hResult );
    }

    if (NetSession = EfsCheckForNetSession()) {

        if (EfsShareDecline(FileName, FALSE, 0 )) {

            hResult = GetLastError();
            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcOpenFileRaw: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return hResult;

        }
    }

    hResult = EfsOpenFileRaw(
                        FileName,
                        LocalFileName,
                        NetSession,
                        Flags,
                        pphContext
                        );

    RpcRevertToSelf();

    LsapFreeLsaHeap( LocalFileName );
    return hResult;
}

void EfsRpcCloseRaw(
    PPEXIMPORT_CONTEXT_HANDLE pphContext
    )
/*++

Routine Description:

    RPC Stub code for EFS Server EfsCloseRaw()

Arguments:

    pphContext -- RPC context handle.

Return Value:

    None.

--*/
{
    if ( *pphContext &&
          (((PEXPORT_CONTEXT) *pphContext)->ContextID == EFS_CONTEXT_ID)){
        EfsCloseFileRaw( *pphContext );
        *pphContext = NULL;
    }
}

void __RPC_USER
PEXIMPORT_CONTEXT_HANDLE_rundown(
    PEXIMPORT_CONTEXT_HANDLE phContext
    )
/*++

Routine Description:

    Standard RPC Context Run Down Routine

Arguments:

    phContext -- RPC context handle.

Return Value:

    None.

--*/
{
    EfsCloseFileRaw( phContext );
}

long EfsRpcReadFileRaw(
    PEXIMPORT_CONTEXT_HANDLE phContext,
    EFS_EXIM_PIPE __RPC_FAR *EfsOutPipe
    )
/*++

Routine Description:

    RPC Stub code for EFS Server EfsReadFileRaw

Arguments:

    phContext -- Context handle.
    EfsOutPipe -- Pipe handle.

Return Value:

    The result of operation.

--*/
{
    if ((EfsOutPipe == NULL) || (phContext == NULL)) {

        //
        // RPC Attack.
        //

        return ERROR_ACCESS_DENIED;

    }
    return (EfsReadFileRaw(
                        phContext,
                        EfsOutPipe
                        )
                );
}

long EfsRpcWriteFileRaw(
    PEXIMPORT_CONTEXT_HANDLE phContext,
    EFS_EXIM_PIPE __RPC_FAR *EfsInPipe
    )
/*++

Routine Description:

    RPC Stub code for EFS Server EfsWriteFileRaw

Arguments:

    phContext -- Context handle.
    EfsInPipe -- Pipe handle.

Return Value:

    The result of operation.

--*/
{
    long hResult;

    if ((EfsInPipe == NULL) || (phContext == NULL)) {

        //
        // RPC Attack.
        //

        return ERROR_ACCESS_DENIED;

    }

    hResult =  RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcWriteFileRaw: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        return( hResult );
    }

    hResult = EfsWriteFileRaw(
                        phContext,
                        EfsInPipe
                        );

    RpcRevertToSelf();

    return hResult;

}

DWORD
EFSSendPipeData(
    char    *DataBuf,
    ULONG   DataLength,
    PVOID   Context
    )
/*++

Routine Description:

    This is a wrapper routine for calling RPC pipe. The purposes of this routine
    and EfsRpcReadFileRaw() are to isolate efsapi.c from RPC details,
    and implemtation details from eserver.c.

Arguments:

    DataBuf -- Data buffer.
    DataLength -- The length of data in bytes to be sent out to the client.
    Context -- Pipe handle.

Return Value:

    The result of operation.

--*/
{
    EFS_EXIM_PIPE __RPC_FAR *EfsOutPipe;
    DWORD   HResult = NO_ERROR;

    //
    // Pass in parameter should not be 0. It is called by ourselves.
    //

    ASSERT( Context );

    EfsOutPipe = ( EFS_EXIM_PIPE __RPC_FAR * )Context;

    RpcTryExcept {

        EfsOutPipe->push(
            EfsOutPipe->state,
            (unsigned char *) DataBuf,
            DataLength
            );

    }  RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
            HResult = RpcExceptionCode();
    } RpcEndExcept;

    return (HResult);
}

DWORD
EFSReceivePipeData(
    char    *DataBuf,
    ULONG*   DataLength,
    PVOID   Context
    )
/*++

Routine Description:

    This is a wrapper routine for calling RPC pipe. The purposes of this routine
    and EfsRpcWriteFileRaw() are to isolate efsapi.c from RPC details,
    and implemtation details from eserver.c.

Arguments:

    DataBuf -- Data buffer.
    DataLength -- The length of data in bytes to be got from the client.
    Context -- Pipe handle.

Return Value:

    The result of operation.

--*/
{
    EFS_EXIM_PIPE __RPC_FAR *EfsInPipe;
    DWORD   HResult = NO_ERROR;
    char    *WorkBuf;
    ULONG   MoreDataBytes;
    ULONG   BytesGot = 0;
    BOOLEAN GetMoreData = TRUE;


    //
    // Pass in parameter should not be 0. It is called by ourselves.
    //

    ASSERT( Context );

    EfsInPipe = ( EFS_EXIM_PIPE __RPC_FAR * )Context;
    WorkBuf = DataBuf;
    MoreDataBytes = *DataLength;

    while ( GetMoreData ) {
        BytesGot = 0;

        RpcTryExcept {

            EfsInPipe->pull(
                EfsInPipe->state,
                (unsigned char *) WorkBuf,
                MoreDataBytes,
                &BytesGot
                );

        }  RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                HResult = RpcExceptionCode();
                GetMoreData = FALSE;
        } RpcEndExcept;
        if ( BytesGot && (BytesGot < MoreDataBytes)){
            WorkBuf += BytesGot;
            MoreDataBytes -= BytesGot;
        } else {
            GetMoreData = FALSE;
        }
    }

    if (HResult == NO_ERROR){
        *DataLength =  (ULONG)(WorkBuf - DataBuf) + BytesGot;
    }

    return (HResult);
}

long EfsRpcEncryptFileSrv(
    handle_t binding_h,
    wchar_t __RPC_FAR *FileName
    )
/*++

Routine Description:

    RPC Stub code for EFS Server Encryption

Arguments:

    binding_h -- RPC binding handle.
    FileName -- Target name.

Return Value:

    The result of operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING DestFileName;
    DWORD hResult;
    UNICODE_STRING  RootPath;
    HANDLE LogFile;
    LPWSTR LocalFileName;
    EFS_USER_INFO EfsUserInfo;
    DWORD FileAttributes;
    BOOL b;
    WORD WebDavPath;

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }

    hResult = GetLocalFileName(
                        FileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcEncryptFileSrv: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if ((hResult == RPC_S_OK) && EfsCheckForNetSession()) {

        if (WebDavPath == WEBDAVPATH) {

            //
            // A RPC attacker. WEBDAV should be local session.
            //

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            return ERROR_ACCESS_DENIED;


        }

        if (EfsShareDecline(FileName, TRUE, FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES )) {

            hResult = GetLastError();
            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcEncryptFileSrv: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()));
            return hResult;

        }
    }
    if (hResult == RPC_S_OK) {
        if (WebDavPath == WEBDAVPATH) {

            //
            // This is a WEB DAV path. We will treat it specially.
            //

            FileAttributes = GetFileAttributes( LocalFileName );
            if (FileAttributes == -1) {

                DWORD rc = GetLastError();

                LsapFreeLsaHeap( LocalFileName );
                RpcRevertToSelf();
                DebugLog((DEB_ERROR, "EfsRpcEncryptFileSrv: GetFileAttributes failed on WEBDAV file, Error = (%x)\n" ,GetLastError()));
                return rc;
            }

            //
            // Mapping the attributes and fake the call of FileEncryptionStatus. 
            //

            if (FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                hResult = FILE_IS_ENCRYPTED;
            } else if (FileAttributes & FILE_ATTRIBUTE_READONLY) {
                hResult = FILE_READ_ONLY;
            } else {
                hResult = FILE_UNKNOWN;
            }

            b = TRUE;

        } else {
            b = FileEncryptionStatus(LocalFileName, &hResult);
        }
    } else {
        DebugLog((DEB_ERROR, "EfsRpcEncryptFileSrv: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return hResult;
    }

    RpcRevertToSelf();

    if ( b ){
        if ( (hResult != FILE_ENCRYPTABLE) && (hResult != FILE_UNKNOWN)){

            //
            // No encryption is allowed or file is already encrypted
            //

            if ( hResult == FILE_IS_ENCRYPTED ){

                HANDLE hSourceFile;

                hResult = RpcImpersonateClient( NULL );
                if (hResult == RPC_S_OK) {

                    FileAttributes = GetFileAttributes( LocalFileName );
    
                    if (FileAttributes != -1) {
    
                        if ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY ){
                            hResult = ERROR_SUCCESS;
                        } else {
    
                            hSourceFile =  CreateFile(
                                                LocalFileName,
                                                FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                                                0,
                                                NULL,
                                                OPEN_EXISTING,
                                                FILE_FLAG_OPEN_REPARSE_POINT,
                                                NULL
                                                );

                            if (hSourceFile == INVALID_HANDLE_VALUE) {
                                hResult = GetLastError();
                            } else {

                                CloseHandle( hSourceFile );
                                hResult = ERROR_SUCCESS;

                            }
    

                        }
                    } else{
                        hResult = GetLastError();
                    }

                    RpcRevertToSelf();

                } 

            } else if (hResult == FILE_DIR_DISALLOWED ) {
                hResult = ERROR_DIR_EFS_DISALLOWED;
            } else if ( hResult == FILE_READ_ONLY ){
                hResult = ERROR_FILE_READ_ONLY;
            } else {
                hResult = ERROR_ACCESS_DENIED;
            }
            LsapFreeLsaHeap( LocalFileName );
            return hResult;

        }
    } else {

        //
        // Error occured checking the status
        //
        DebugLog((DEB_TRACE_EFS, "EfsRpcEncryptFileSrv: FileEncryptionStatus() failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcEncryptFileSrv: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    DestFileName.Length = (USHORT) (sizeof(WCHAR) * wcslen(LocalFileName));
    DestFileName.MaximumLength = DestFileName.Length + sizeof (WCHAR);
    DestFileName.Buffer = LocalFileName;
    //
    //   Get the rootname
    //

    if (WebDavPath == WEBDAVPATH){

        //
        //  Do not support LOGFILE for WEB DAV
        //

        LogFile = NULL;
        RpcRevertToSelf();

    } else {
        hResult = GetVolumeRoot(&DestFileName, &RootPath);
        RpcRevertToSelf();
        if (hResult != ERROR_SUCCESS) {
            DebugLog((DEB_ERROR, "EfsRpcEncryptFileSrv: GetVolumeRoot failed, Error = (%x)\n" ,hResult  ));
            LsapFreeLsaHeap( LocalFileName );
            return( hResult );
        }
    
        Status = GetLogFile( &RootPath, &LogFile );
        LsapFreeLsaHeap( RootPath.Buffer );
    }

    if (NT_SUCCESS( Status )) {
        hResult = RpcImpersonateClient( NULL );

        if (hResult == RPC_S_OK) {

            if (EfspGetUserInfo( &EfsUserInfo )) {
                if (EfspLoadUserProfile( &EfsUserInfo, FALSE )) {
                    hResult = EncryptFileSrv( &EfsUserInfo, &DestFileName, LogFile );
                    EfspUnloadUserProfile( &EfsUserInfo );
                } else {
                    hResult = GetLastError();
                }
                EfspFreeUserInfo( &EfsUserInfo );
            } else{
                hResult = GetLastError();
            }

            RpcRevertToSelf();

        } else {
            if (LogFile) {
                MarkFileForDelete( LogFile );
            }
        }

        if (LogFile) {
            CloseHandle(LogFile);
        }
    }
    if (!NT_SUCCESS( Status )){
        hResult = RtlNtStatusToDosError( Status );

        //
        // Make sure the error was mapped
        //

        if (hResult == ERROR_MR_MID_NOT_FOUND) {

            DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
            hResult = ERROR_ENCRYPTION_FAILED;
        }
    }

    LsapFreeLsaHeap( LocalFileName );
    return( hResult );
}

long EfsRpcDecryptFileSrv(
    handle_t binding_h,
    wchar_t __RPC_FAR *FileName,
    unsigned long OpenFlag
    )
/*++

Routine Description:

    RPC Stub code for EFS Server Decryption

Arguments:

    binding_h -- RPC binding handle.
    FileName -- Target name.
    OpenFlag -- Open for recovery or decryption

Return Value:

    The result of operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING DestFileName;
    DWORD hResult;
    UNICODE_STRING  RootPath;
    HANDLE LogFile;
    LPWSTR LocalFileName;
    DWORD  FileAttributes;
    WORD   WebDavPath;

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    hResult = GetLocalFileName(
                        FileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcDecryptFileSrv: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }


    hResult =  RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcDecryptFileSrv: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    if (EfsCheckForNetSession()) {

        if (WebDavPath == WEBDAVPATH) {

            //
            // A RPC attacker. WEBDAV should be local session.
            //

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            return ERROR_ACCESS_DENIED;


        }

        if (EfsShareDecline(FileName, TRUE, FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES )) {

            hResult = GetLastError();
            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcDecryptFileSrv: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return hResult;

        }
    }

    FileAttributes = GetFileAttributes( LocalFileName );
    if (-1 != FileAttributes){
        if ( !(FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ){

            //
            // No decryption is needed.
            //

            RpcRevertToSelf();
            LsapFreeLsaHeap( LocalFileName );
            return ERROR_SUCCESS;

        }
    } else {

        //
        // Error occured checking the status
        //

        hResult = GetLastError();
        RpcRevertToSelf();
        DebugLog((DEB_TRACE_EFS, "EfsRpcDecryptFileSrv: GetFileAttributes() failed, Error = (%x)\n" , hResult));
        LsapFreeLsaHeap( LocalFileName );
        return hResult;
    }

    DestFileName.Length = (USHORT) (sizeof(WCHAR) * wcslen(LocalFileName));
    DestFileName.MaximumLength = DestFileName.Length + sizeof (WCHAR);
    DestFileName.Buffer = LocalFileName;
    //
    //   Get the rootname
    //

    if (WebDavPath == WEBDAVPATH){

        //
        //  Do not support LOGFILE for WEB DAV
        //

        LogFile = NULL;
        RpcRevertToSelf();

    } else {

        hResult = GetVolumeRoot(&DestFileName, &RootPath);
        RpcRevertToSelf();
        if (hResult != ERROR_SUCCESS) {
            DebugLog((DEB_ERROR, "EfsRpcDecryptFileSrv: GetVolumeRoot failed, Error = (%x)\n" ,hResult  ));
            LsapFreeLsaHeap( LocalFileName );
            return( hResult );
        }
    
        Status = GetLogFile( &RootPath, &LogFile );
        LsapFreeLsaHeap( RootPath.Buffer );
    
    }


    if (NT_SUCCESS( Status )) {

        hResult =  RpcImpersonateClient( NULL );

        if (hResult == RPC_S_OK) {
            hResult = DecryptFileSrv( &DestFileName, LogFile, OpenFlag );
            RpcRevertToSelf();
        } else {
            if (LogFile) {
                MarkFileForDelete( LogFile );
            }
        }

        if (LogFile) {
            CloseHandle(LogFile);
        }
    }

    if (!NT_SUCCESS( Status )){
        hResult = RtlNtStatusToDosError( Status );

        //
        // Make sure the error was mapped
        //

        if (hResult == ERROR_MR_MID_NOT_FOUND) {

            DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_DECRYPTION_FAILED\n" , Status  ));
            hResult = ERROR_DECRYPTION_FAILED;
        }
    }

    LsapFreeLsaHeap( LocalFileName );
    return( (long)hResult );
}

long GetLocalFileName(
    LPCWSTR FileName,
    LPWSTR *LocalFileName,
    WORD   *Flag
    )
/*++

Routine Description:

    Get the local file name from the UNC name

Arguments:

    FileName -- Target UNC file name.

    LocalFileName -- Local file name.
    
    Flag  -- Indicating special path, such as WEB DAV path.

Return Value:

    The result of operation.

--*/
{
    long RetCode = ERROR_SUCCESS;
    LPWSTR NetName;
    ULONG ii, jj;
    LPBYTE ShareInfo;
    DWORD  PathLen;
    DWORD  BufLen;
    BOOL   SharePath = FALSE;
    BOOL   LocalCheckLength = TRUE;

    *Flag = 0;
    if ( FileName == NULL ) {

        //
        // Possible RPC attack
        //

        return ERROR_ACCESS_DENIED;
    }
    PathLen = (DWORD) wcslen(FileName);

    if (PathLen >= PATHTOOLONG) {

        //
        // A possible RPC attack. Just return.
        // No need to return good error here.
        //

        return ERROR_ACCESS_DENIED;
    }

    BufLen = MAX_PATH >= PathLen + 1? MAX_PATH + 1: PathLen + 10;

    //
    // Check the WEB DAV path first
    //

    if (DAVHEADER == FileName[0]) {

        //
        // This is the WEB DAV path. Treat it as the local case.
        // Take whatever the user passed in.
        //

        *LocalFileName = (LPWSTR)LsapAllocateLsaHeap( PathLen * sizeof (WCHAR));
        if (NULL == *LocalFileName) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        *Flag = WEBDAVPATH;
        wcscpy(*LocalFileName, &FileName[1]);
        return ERROR_SUCCESS;

    }


    //
    //  See if the pass in name is \\server\share
    //

    if ((PathLen > 4) && (FileName[0] == L'\\') && (FileName[1] == L'\\')) {
        if ((FileName[2] != L'?') && FileName[2] != L'.') {
            SharePath = TRUE;
        } else {
            if (FileName[3] != L'\\') {
                SharePath = TRUE;
            } else {

                //
                //  path \\?\ or \\.\
                //

                LocalCheckLength = FALSE;
            }
        }
    }

    *LocalFileName = (LPWSTR)LsapAllocateLsaHeap( BufLen * sizeof (WCHAR));
    if (  NULL == *LocalFileName ){
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (!SharePath) {

        //
        // This is a local path. Just copy it.
        //

        if (LocalCheckLength && PathLen >= MAX_PATH) {

            //
            // This is for Win2K compatibility
            //

            wcscpy(*LocalFileName, L"\\\\?\\");
            wcscat(*LocalFileName, FileName);
        } else {
            wcscpy(*LocalFileName, FileName);
        }
        return ERROR_SUCCESS;

    }

    NetName = (LPWSTR)LsapAllocateLsaHeap( PathLen * sizeof (WCHAR));
    if ( NULL == NetName ){
        LsapFreeLsaHeap( *LocalFileName );
        *LocalFileName = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Extract the net name
    //

    ii = jj = 0;

    while ( (FileName[jj]) && (FileName[jj] == L'\\') ){
        jj++;
    }
    while ( (FileName[jj]) && (FileName[jj++] != L'\\') );
    while ( (FileName[jj]) && (FileName[jj] != L'\\')){
        NetName[ii++] = FileName[jj++];
    }

    if ( !(FileName[jj]) ){

        //
        // Invalid path name
        //

        LsapFreeLsaHeap( NetName );
        LsapFreeLsaHeap( *LocalFileName );
        *LocalFileName = NULL;
        return ERROR_BAD_NETPATH ;

    }

    NetName[ii] = 0;
    RetCode = NetShareGetInfo(
                            NULL,
                            NetName,
                            2,
                            &ShareInfo
                            );

    if ( NERR_Success == RetCode ){

        PathLen = (DWORD) (wcslen(((LPSHARE_INFO_2)ShareInfo)->shi2_path) +
                           wcslen(&FileName[jj]) + 1);

        if ( PathLen >= MAX_PATH ){
            if (PathLen + 5 > BufLen){
                LsapFreeLsaHeap( *LocalFileName );
                BufLen = PathLen + 5;
                *LocalFileName = (LPWSTR)LsapAllocateLsaHeap( BufLen * sizeof (WCHAR));
                if ( NULL == *LocalFileName ){
                    NetApiBufferFree(ShareInfo);
                    LsapFreeLsaHeap( NetName );
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

            }

        }
        if (MAX_PATH <= PathLen){

            //
            // Put in the \\?\. Buffer should be bigger enough.
            //
            wcscpy(*LocalFileName,L"\\\\?\\");
            wcscat(
                *LocalFileName,
                ((LPSHARE_INFO_2)ShareInfo)->shi2_path
                );

        } else {
            wcscpy(
                *LocalFileName,
                ((LPSHARE_INFO_2)ShareInfo)->shi2_path
                );
        }

        wcscat(*LocalFileName, &FileName[jj]);
        NetApiBufferFree(ShareInfo);

    } else {

        //
        // Invalid path name
        //

        LsapFreeLsaHeap( *LocalFileName );
        *LocalFileName = NULL;
        RetCode = ERROR_BAD_NETPATH ;

    }

    LsapFreeLsaHeap( NetName );
    return RetCode;

}

DWORD
EfsRpcQueryUsersOnFile(
    IN handle_t binding_h,
    IN LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST *pUsersList
    )
{
    DWORD hResult;
    PENCRYPTION_CERTIFICATE_HASH_LIST pHashList;
    LPWSTR LocalFileName;
    WORD   WebDavPath;

    DebugLog((DEB_WARN, "Made it into EfsRpcQueryUsersOnFile\n"   ));

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    if (pUsersList == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    hResult = GetLocalFileName(
                        lpFileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcQueryUsersOnFile: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcQueryUsersOnFile: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    if (EfsCheckForNetSession()) {

        if (WebDavPath == WEBDAVPATH) {

            //
            // A RPC attacker. WEBDAV should be local session.
            //

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            return ERROR_ACCESS_DENIED;


        }

        if (EfsShareDecline(lpFileName, TRUE, FILE_READ_ATTRIBUTES )) {

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcQueryUsersOnFile: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }
    }

    //
    // Allocate the structure we're going to return
    //

    pHashList = (PENCRYPTION_CERTIFICATE_HASH_LIST)MIDL_user_allocate( sizeof( ENCRYPTION_CERTIFICATE_HASH_LIST ));

    *pUsersList = pHashList;

    if (pHashList) {

        hResult = QueryUsersOnFileSrv(
                      LocalFileName,
                      &pHashList->nCert_Hash,
                      &pHashList->pUsers
                      );

        if (hResult != ERROR_SUCCESS) {

            //
            // Free the structure we allocated
            //

            MIDL_user_free( pHashList );
            *pUsersList = NULL;   // paranoia
        }
    
    }

    RpcRevertToSelf();
    LsapFreeLsaHeap( LocalFileName );

    return( hResult );
}

DWORD EfsRpcQueryRecoveryAgents(
    IN handle_t binding_h,
    IN LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    )
{
    DWORD hResult;
    PENCRYPTION_CERTIFICATE_HASH_LIST pHashList;
    LPWSTR LocalFileName;
    WORD   WebDavPath;

    DebugLog((DEB_WARN, "Made it into EfsRpcQueryRecoveryAgents\n"   ));
    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    if (pRecoveryAgents == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    hResult = GetLocalFileName(
                        lpFileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcQueryRecoveryAgents: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcQueryRecoveryAgents: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    if (EfsCheckForNetSession()) {

        if (WebDavPath == WEBDAVPATH) {

            //
            // A RPC attacker. WEBDAV should be local session.
            //

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            return ERROR_ACCESS_DENIED;


        }

        if (EfsShareDecline(lpFileName, TRUE, FILE_READ_ATTRIBUTES )) {

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcQueryRecoveryAgents: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }
    }

    //
    // Allocate the structure we're going to return
    //

    pHashList = (PENCRYPTION_CERTIFICATE_HASH_LIST)MIDL_user_allocate( sizeof( ENCRYPTION_CERTIFICATE_HASH_LIST ));

    *pRecoveryAgents = pHashList;

    if (pHashList) {

        hResult = QueryRecoveryAgentsSrv(
                      LocalFileName,
                      &pHashList->nCert_Hash,
                      &pHashList->pUsers
                      );

        if (hResult != ERROR_SUCCESS) {

            //
            // Free the structure we allocated
            //

            MIDL_user_free( pHashList );
            *pRecoveryAgents = NULL;   // paranoia
        }

    }

    RpcRevertToSelf();
    LsapFreeLsaHeap( LocalFileName );

    return( hResult );
}

DWORD EfsRpcRemoveUsersFromFile(
    IN handle_t binding_h,
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pUsers
    )
{
    DWORD hResult;
    LPWSTR LocalFileName;
    EFS_USER_INFO EfsUserInfo;
    WORD   WebDavPath;

    DebugLog((DEB_WARN, "Made it into EfsRpcRemoveUsersFromFile\n"   ));

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    if ((pUsers == NULL) || (lpFileName == NULL) || (pUsers->pUsers == NULL)) {
       return ERROR_INVALID_PARAMETER;
    }
    if (pUsers->nCert_Hash > TOOMANYUSER) {

        //
        // Possible RPC attack
        //

        return ERROR_ACCESS_DENIED;

    }

    hResult = GetLocalFileName(
                        lpFileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcRemoveUsersFromFile: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcRemoveUsersFromFile: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    if (EfsCheckForNetSession()) {

        if (WebDavPath == WEBDAVPATH) {

            //
            // A RPC attacker. WEBDAV should be local session.
            //

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            return ERROR_ACCESS_DENIED;


        }

        if (EfsShareDecline(lpFileName, TRUE, FILE_READ_ATTRIBUTES| FILE_WRITE_DATA )) {

            hResult = GetLastError();
            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcRemoveUsersFromFile: EfsShareDecline failed, Error = (%x)\n" ,hResult ));
            return hResult;

        }
    }


    if (EfspGetUserInfo( &EfsUserInfo )) {

        if (EfspLoadUserProfile( &EfsUserInfo, FALSE )) {

            //
            // The cert hash list could be garbage
            //

            __try{

                hResult = RemoveUsersFromFileSrv(
                              &EfsUserInfo,
                              LocalFileName,
                              pUsers->nCert_Hash,
                              pUsers->pUsers
                              );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                hResult = ERROR_INVALID_PARAMETER;

            }

            EfspUnloadUserProfile( &EfsUserInfo );

        } else {

            hResult = GetLastError();
        }

        EfspFreeUserInfo( &EfsUserInfo );

    } else {

        hResult = GetLastError();
    }

    RpcRevertToSelf();
    LsapFreeLsaHeap( LocalFileName );

    return( hResult );
}

DWORD
EfsRpcAddUsersToFile(
    IN handle_t binding_h,
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates
    )
{
    DWORD hResult;
    LPWSTR LocalFileName;

    EFS_USER_INFO EfsUserInfo;
    WORD   WebDavPath;

    DebugLog((DEB_WARN, "Made it into EfsRpcAddUsersToFile\n"   ));

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }

    if (pEncryptionCertificates == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pEncryptionCertificates->nUsers > TOOMANYUSER) {

        //
        // Possible RPC attack
        // We could make this bigger in the future if there is the need.
        //

        return ERROR_ACCESS_DENIED;

    }


    hResult = GetLocalFileName(
                        lpFileName,
                        &LocalFileName,                       
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcAddUsersToFile: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcAddUsersToFile: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    if (EfsCheckForNetSession()) {

        if (WebDavPath == WEBDAVPATH) {

            //
            // A RPC attacker. WEBDAV should be local session.
            //

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            return ERROR_ACCESS_DENIED;


        }

        if (EfsShareDecline(lpFileName, TRUE, FILE_READ_ATTRIBUTES| FILE_WRITE_DATA )) {

            hResult = GetLastError();
            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcAddUsersToFile: EfsShareDecline failed, Error = (%x)\n" , hResult  ));
            return hResult;

        }
    }

    if (EfspGetUserInfo( &EfsUserInfo )) {

        if (EfspLoadUserProfile( &EfsUserInfo, FALSE )) {

            //
            // We may be passed in garbage for the cert list
            // However, RPC will guarantee that the first level reference will not cause AV.
            // TRY is used in AddUsersToFileSrv for better error handling.
            //

            hResult = AddUsersToFileSrv(
                         &EfsUserInfo,
                         LocalFileName,
                         pEncryptionCertificates->nUsers,
                         pEncryptionCertificates->pUsers
                         );


            EfspUnloadUserProfile( &EfsUserInfo );

        } else {

            hResult = GetLastError();
        }

        EfspFreeUserInfo( &EfsUserInfo );

    } else {

        hResult = GetLastError();
    }

    RpcRevertToSelf();
    LsapFreeLsaHeap( LocalFileName );

    return( hResult );
}


DWORD
EfsRpcSetFileEncryptionKey(
    IN handle_t binding_h,
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    )
{

    DWORD hResult;

    EFS_USER_INFO EfsUserInfo;

    DebugLog((DEB_WARN, "Made it into EfsRpcSetFileEncryptionKey\n"   ));

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }

    hResult = RpcImpersonateClient( NULL );
    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcSetFileEncryptionKey: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        return( hResult );
    }

    if (EfsCheckForNetSession()) {

        //
        // This call can only be done locally.
        //

        RpcRevertToSelf();
        return ERROR_NOT_SUPPORTED; 
    }

    if (EfspGetUserInfo( &EfsUserInfo )) {

        if (EfspLoadUserProfile( &EfsUserInfo, TRUE )) {

            hResult = SetFileEncryptionKeySrv( &EfsUserInfo, pEncryptionCertificate );

            EfspUnloadUserProfile( &EfsUserInfo );

        } else {

            hResult = GetLastError();
        }

        EfspFreeUserInfo( &EfsUserInfo );
    }

    RpcRevertToSelf();

    return( hResult );
}


DWORD
EfsRpcDuplicateEncryptionInfoFile(
    IN handle_t binding_h,
    IN LPCWSTR lpSrcFileName,
    IN LPCWSTR lpDestFileName,
    IN DWORD dwCreationDistribution, 
    IN DWORD dwAttributes, 
    IN PEFS_RPC_BLOB pRelativeSD,
    IN BOOL bInheritHandle
    )
{
    DWORD hResult;

    LPWSTR LocalSrcFileName;
    LPWSTR LocalDestFileName;
    BOOLEAN NetSession=FALSE;
    WORD   WebDavPathSrc;
    WORD   WebDavPathDst;

    EFS_USER_INFO EfsUserInfo;
    DebugLog((DEB_WARN, "Made it into EfsRpcDuplicateEncryptionInfoFile\n"   ));


    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }

    if (pRelativeSD && pRelativeSD->cbData > SDTOOBIG) {

        //
        //  RPC attack
        //

        return ERROR_ACCESS_DENIED;

    }

    hResult = GetLocalFileName(
                        lpSrcFileName,
                        &LocalSrcFileName,
                        &WebDavPathSrc
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcDuplicateEncryptionInfoFile: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = GetLocalFileName(
                        lpDestFileName,
                        &LocalDestFileName,
                        &WebDavPathDst
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcDuplicateEncryptionInfoFile: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalSrcFileName );
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcDuplicateEncryptionInfoFile: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalDestFileName );
        LsapFreeLsaHeap( LocalSrcFileName );
        return ( hResult );
    }

    if (EfsCheckForNetSession()) {

        if ((WebDavPathSrc == WEBDAVPATH) || (WebDavPathDst == WEBDAVPATH)) {

            //
            // A RPC attacker. WEBDAV should be local session.
            //

            LsapFreeLsaHeap( LocalDestFileName );
            LsapFreeLsaHeap( LocalSrcFileName );
            RpcRevertToSelf();
            return ERROR_ACCESS_DENIED;


        }

        if (EfsShareDecline(lpSrcFileName, TRUE, FILE_READ_ATTRIBUTES )) {

            LsapFreeLsaHeap( LocalDestFileName );
            LsapFreeLsaHeap( LocalSrcFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcDuplicateEncryptionInfoFile: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }

        if (EfsShareDecline(lpDestFileName, FALSE, 0 )) {

            LsapFreeLsaHeap( LocalDestFileName );
            LsapFreeLsaHeap( LocalSrcFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcDuplicateEncryptionInfoFile: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }
        NetSession = TRUE;

    }

    if (EfspGetUserInfo( &EfsUserInfo )) {

        //
        // Load the profile so we can open the source file
        //

        if (EfspLoadUserProfile( &EfsUserInfo, FALSE )) {

            hResult = DuplicateEncryptionInfoFileSrv( &EfsUserInfo, 
                                                      LocalSrcFileName, 
                                                      LocalDestFileName,
                                                      NetSession? lpDestFileName: NULL,
                                                      dwCreationDistribution, 
                                                      dwAttributes, 
                                                      pRelativeSD,
                                                      bInheritHandle
                                                      );

            EfspUnloadUserProfile( &EfsUserInfo );

        } else {

            hResult = GetLastError();
        }

        EfspFreeUserInfo( &EfsUserInfo );
    }

    LsapFreeLsaHeap( LocalDestFileName );
    LsapFreeLsaHeap( LocalSrcFileName );
    RpcRevertToSelf();

    return( hResult );
}

DWORD EfsRpcFileKeyInfo(
    IN handle_t binding_h,
    IN LPCWSTR lpFileName,
    IN DWORD   InfoClass,
    OUT PEFS_RPC_BLOB *KeyInfo
    )
{
    DWORD hResult;
    PEFS_RPC_BLOB pKeyInfo;
    LPWSTR LocalFileName;
    WORD  WebDavPath;

    DebugLog((DEB_WARN, "Made it into EfsRpcFileKeyInfo\n"   ));

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    if (KeyInfo == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    hResult = GetLocalFileName(
                        lpFileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcFileKeyInfo: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcFileKeyInfo: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    if (EfsCheckForNetSession()) {
        if (WebDavPath == WEBDAVPATH) {

            //
            // A RPC attacker. WEBDAV should be local session.
            //

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            return ERROR_ACCESS_DENIED;


        }
        if (EfsShareDecline(lpFileName, TRUE, FILE_READ_ATTRIBUTES )) {

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcFileKeyInfo: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }
    }


    //
    // Allocate the structure we're going to return
    //

    pKeyInfo = (PEFS_RPC_BLOB)MIDL_user_allocate( sizeof( EFS_RPC_BLOB ));

    *KeyInfo = pKeyInfo;

    if (pKeyInfo) {

        hResult = EfsFileKeyInfoSrv(
                      LocalFileName,
                      InfoClass,
                      &pKeyInfo->cbData,
                      &pKeyInfo->pbData
                      );

        if (hResult != ERROR_SUCCESS) {

            //
            // Free the structure we allocated
            //

            if (pKeyInfo->pbData) {
                MIDL_user_free( pKeyInfo->pbData );
            }
            MIDL_user_free( pKeyInfo );
            *KeyInfo = NULL;   // paranoia
        } else {
            if (NULL == pKeyInfo->pbData) {
    
                //
                // No data returned
                //
    
                MIDL_user_free( pKeyInfo );
                *KeyInfo = NULL;    
            }
        }
    
    } else {

        hResult = ERROR_NOT_ENOUGH_MEMORY;

    }

    RpcRevertToSelf();
    LsapFreeLsaHeap( LocalFileName );

    return( hResult );
}


DWORD
EfsRpcNotSupported(
    IN handle_t binding_h,
    IN LPCWSTR lpSrcFileName,
    IN LPCWSTR lpDestFileName,
    IN DWORD dwCreationDistribution, 
    IN DWORD dwAttributes, 
    IN PEFS_RPC_BLOB pRelativeSD,
    IN BOOL bInheritHandle
    )
{
    DebugLog((DEB_WARN, "Made it into EfsRpcNotSupported\n"   ));

    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\credapi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    credapi.c

Abstract:

    Credential Manager RPC API Interfaces

Author:

    Cliff Van Dyke      (CliffV)

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include <credp.hxx>
#include <windns.h>

NTSTATUS
CrediGetLogonId(
    OUT PLUID LogonId
    )
/*++

Routine Description:

    This routine impersonates the client then gets the logon id from the impersonated token.
    This routine also checks to ensure the user sid isn't restricted.

    On successful return, we are still imperonating the client.  The caller should call
    RpcRevertToSelf();

Arguments:

    LogonId - Returns the logon ID.

Return Value:

    Status of the operation.

--*/

{
    NTSTATUS Status;

    //
    // Impersonate
    //

    Status = I_RpcMapWin32Status( RpcImpersonateClient( 0 ) );

    if ( NT_SUCCESS(Status) ) {
        HANDLE ClientToken;

        //
        // Open the token
        //
        Status = NtOpenThreadToken( NtCurrentThread(),
                                    TOKEN_QUERY,
                                    TRUE,
                                    &ClientToken );

        if ( NT_SUCCESS( Status ) ) {
            TOKEN_STATISTICS TokenStats;
            ULONG ReturnedSize;

            //
            // Get the LogonId
            //

            Status = NtQueryInformationToken( ClientToken,
                                              TokenStatistics,
                                              &TokenStats,
                                              sizeof( TokenStats ),
                                              &ReturnedSize );

            if ( NT_SUCCESS( Status ) ) {

                //
                // Save the logon id
                //

                *LogonId = TokenStats.AuthenticationId;


                //
                // Get the user sid
                //

                Status = NtQueryInformationToken (
                             ClientToken,
                             TokenUser,
                             NULL,
                             0,
                             &ReturnedSize );

                if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                    PTOKEN_USER UserSid;

                    UserSid = LsapAllocateLsaHeap( ReturnedSize );

                    if ( UserSid == NULL ) {
                        Status = STATUS_NO_MEMORY;
                    } else {

                        Status = NtQueryInformationToken (
                                     ClientToken,
                                     TokenUser,
                                     UserSid,
                                     ReturnedSize,
                                     &ReturnedSize );


                        if ( NT_SUCCESS( Status )) {
                            BOOL IsMember;

                            //
                            // Ensure the user sid isn't restricted.
                            //

                            if ( !CheckTokenMembership( ClientToken,
                                                        UserSid->User.Sid,
                                                        &IsMember ) ) {

                                Status = I_RpcMapWin32Status( GetLastError() );

                            } else {

                                //
                                // If not, fail
                                //

                                if ( !IsMember ) {
                                    Status = STATUS_ACCESS_DENIED;
                                } else {

                                    BOOLEAN IsNetworkClient;

                                    //
                                    // Don't allow the caller to have come in from the network.
                                    //

                                    Status = LsapDbIsRpcClientNetworkClient( &IsNetworkClient );

                                    if ( NT_SUCCESS(Status ) ) {
                                        if ( IsNetworkClient ) {
                                            Status = STATUS_ACCESS_DENIED;
                                        } else {
                                            Status = STATUS_SUCCESS;
                                        }
                                    }
                                }
                            }
                        }

                        LsapFreeLsaHeap( UserSid );
                    }

                }
            }

            NtClose( ClientToken );

        }

        if ( !NT_SUCCESS(Status) ) {
            RpcRevertToSelf();
        }

    }

    return Status;
}

NTSTATUS
CredrWrite(
    IN LPWSTR ServerName,
    IN PENCRYPTED_CREDENTIALW Credential,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredWrite API creates a new credential or modifies an existing
    credential in the user's credential set.  The new credential is
    associated with the logon session of the current token.  The token
    must not have the user's SID disabled.

    The CredWrite API creates a credential if none already exists by the
    specified TargetName.  If the specified TargetName already exists, the
    specified credential replaces the existing one.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    Credential - Specifies the credential to be written.

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_PRESERVE_CREDENTIAL_BLOB: The credential blob should be preserved from the
            already existing credential with the same credential name and credential type.

Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

        STATUS_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.
            Returned only if CRED_PRESERVE_CREDENTIAL_BLOB was specified.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediWrite( &LogonId,
                         CREDP_FLAGS_USER_ENCRYPTED_PASSWORD,
                         Credential,
                         Flags );

    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrRead (
    IN LPWSTR ServerName,
    IN LPWSTR TargetName,
    IN ULONG Type,
    IN ULONG Flags,
    OUT PENCRYPTED_CREDENTIALW *Credential
    )

/*++

Routine Description:

    The CredRead API reads a credential from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    TargetName - Specifies the name of the credential to read.

    Type - Specifies the Type of the credential to find.
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Credential - Returns a pointer to the credential.  The returned buffer
        must be freed by calling CredFree.

Return Values:

    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediRead( &LogonId,
                        CREDP_FLAGS_USE_MIDL_HEAP,  // Use MIDL_user_allocate
                        TargetName,
                        Type,
                        Flags,
                        Credential );
    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrEnumerate (
    IN LPWSTR ServerName,
    IN LPWSTR Filter,
    IN ULONG Flags,
    OUT PCREDENTIAL_ARRAY CredentialArray
    )

/*++

Routine Description:

    The CredEnumerate API enumerates the credentials from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    Filter - Specifies a filter for the returned credentials.  Only credentials
        with a TargetName matching the filter will be returned.  The filter specifies
        a name prefix followed by an asterisk.  For instance, the filter "FRED*" will
        return all credentials with a TargetName beginning with the string "FRED".

        If NULL is specified, all credentials will be returned.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Count - Returns a count of the number of credentials returned in Credentials.

    Credentials - Returns a pointer to an array of pointers to credentials.
        The returned buffer must be freed by calling CredFree.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credentials matching the specified Filter.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;

    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Validate the credential array.
    //

    if ( CredentialArray == NULL ||
         CredentialArray->CredentialCount != 0 ||
         CredentialArray->Credentials != NULL ) {

         Status = STATUS_INVALID_PARAMETER;
         goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediEnumerate( &LogonId,
                             0,
                             Filter,
                             Flags,
                             &CredentialArray->CredentialCount,
                             &CredentialArray->Credentials );
    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrWriteDomainCredentials (
    IN LPWSTR ServerName,
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN PENCRYPTED_CREDENTIALW Credential,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredWriteDomainCredentials API writes a new domain
    credential to the user's credential set.  The new credential is
    associated with the logon session of the current token.  The token
    must not have the user's SID disabled.

    CredWriteDomainCredentials differs from CredWrite in that it handles
    the idiosyncrasies of domain (CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE)
    credentials.  Domain credentials contain more than one target field.

    At least one of the naming parameters must be specified: NetbiosServerName,
    DnsServerName, NetbiosDomainName, DnsDomainName or DnsForestName.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    TargetInfo - Specifies the target information identifying the target server.

    Credential - Specifies the credential to be written.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

        STATUS_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        STATUS_INVALID_PARAMETER - None of the naming parameters were specified
            or the credential specified did not have the Type field set to
            CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediWriteDomainCredentials( &LogonId,
                                          CREDP_FLAGS_USER_ENCRYPTED_PASSWORD,
                                          TargetInfo,
                                          Credential,
                                          Flags );
    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}



NTSTATUS
CredrReadDomainCredentials (
    IN LPWSTR ServerName,
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN ULONG Flags,
    OUT PCREDENTIAL_ARRAY CredentialArray
    )

/*++

Routine Description:

    The CredReadDomainCredentials API reads the domain credentials from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    CredReadDomainCredentials differs from CredRead in that it handles the
    idiosyncrasies of domain (CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE)
    credentials.  Domain credentials contain more than one target field.

    At least one of the naming parameters must be specified: NetbiosServerName,
    DnsServerName, NetbiosDomainName, DnsDomainName or DnsForestName. This API returns
    the most specific credentials that match the naming parameters.  That is, if there
    is a credential that matches the target server name and a credential that matches
    the target domain name, only the server specific credential is returned.  This is
    the credential that would be used.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    TargetInfo - Specifies the target information identifying the target ser

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_CACHE_TARGET_INFORMATION: The TargetInfo should be cached for a subsequent read via
            CredGetTargetInfo.

    Count - Returns a count of the number of credentials returned in Credentials.

    Credentials - Returns a pointer to an array of pointers to credentials.
        The most specific existing credential matching the TargetInfo is returned.
        If there is both a CRED_TYPE_DOMAIN_PASSWORD and CRED_TYPE_DOMAIN_CERTIFICATE
        credential, both are returned. If a connection were to be made to the named
        target, this most-specific credential would be used.

        The returned buffer must be freed by calling CredFree.

Return Values:

    The following status codes may be returned:

        STATUS_INVALID_PARAMETER - None of the naming parameters were specified.

        STATUS_NOT_FOUND - There are no credentials matching the specified naming parameters.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    LUID LogonId;
    ULONG CredFlags = 0;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Validate the credential array.
    //

    if ( CredentialArray == NULL ||
         CredentialArray->CredentialCount != 0 ||
         CredentialArray->Credentials != NULL ) {

         Status = STATUS_INVALID_PARAMETER;
         goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Handle caching target info.
    //
    // The Credi* routine caches by default and has to be asked to not cache.
    // Whereas the public API doesn't cache by default.
    //

    if ( Flags & CRED_CACHE_TARGET_INFORMATION ) {
        Flags &= ~CRED_CACHE_TARGET_INFORMATION;
    } else {
        CredFlags |= CREDP_FLAGS_DONT_CACHE_TI;
    }

    //
    // Call the internal routine
    //

    Status = CrediReadDomainCredentials(
                             &LogonId,
                             CredFlags,
                             TargetInfo,
                             Flags,
                             &CredentialArray->CredentialCount,
                             &CredentialArray->Credentials );
    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrDelete (
    IN LPWSTR ServerName,
    IN LPWSTR TargetName,
    IN ULONG Type,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredDelete API deletes a credential from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    TargetName - Specifies the name of the credential to delete.

    Type - Specifies the Type of the credential to find.
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:

    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediDelete( &LogonId,
                          0,
                          TargetName,
                          Type,
                          Flags );
    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}

NTSTATUS
CredrRename (
    IN LPWSTR ServerName,
    IN LPWSTR OldTargetName,
    IN LPWSTR NewTargetName,
    IN ULONG Type,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredRename API renames a credential in the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    OldTargetName - Specifies the current name of the credential to rename.

    NewTargetName - Specifies the new name of the credential.

    Type - Specifies the Type of the credential to rename
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:
    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credential with the specified OldTargetName.

        STATUS_OBJECT_NAME_COLLISION - There is already a credential named NewTargetName.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediRename( &LogonId,
                          OldTargetName,
                          NewTargetName,
                          Type,
                          Flags );
    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrGetTargetInfo (
    IN LPWSTR ServerName,
    IN LPWSTR TargetServerName,
    IN ULONG Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    )

/*++

Routine Description:

    The CredGetTargetInfo API gets all of the known target name information
    for the named target machine.  This executed locally
    and does not need any particular privilege.  The information returned is expected
    to be passed to the CredReadDomainCredentials and CredWriteDomainCredentials APIs.
    The information should not be used for any other purpose.

    Authentication packages compute TargetInfo when attempting to authenticate to
    ServerName.  The authentication packages cache this target information to make it
    available to CredGetTargetInfo.  Therefore, the target information will only be
    available if we've recently attempted to authenticate to ServerName.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    TargetServerName - This parameter specifies the name of the machine to get the information
        for.

    Flags - Specifies flags to control the operation of the API.

        CRED_ALLOW_NAME_RESOLUTION - Specifies that if no target info can be found for
            TargetName, then name resolution should be done on TargetName to convert it
            to other forms.  If target info exists for any of those other forms, that
            target info is returned.  Currently only DNS name resolution is done.

            This bit is useful if the application doesn't call the authentication package
            directly.  The application might pass the TargetName to another layer of software
            to authenticate to the server.  That layer of software might resolve the name and
            pass the resolved name to the authentication package.  As such, there will be no
            target info for the original TargetName.

    TargetInfo - Returns a pointer to the target information.
        At least one of the returned fields of TargetInfo will be non-NULL.

Return Values:

    The following status codes may be returned:

        STATUS_NO_MEMORY - There isn't enough memory to complete the operation.

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        return STATUS_INVALID_COMPUTER_NAME;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediGetTargetInfo( &LogonId, TargetServerName, Flags, TargetInfo );

    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrGetSessionTypes (
    IN LPWSTR ServerName,
    IN DWORD MaximumPersistCount,
    OUT LPDWORD MaximumPersist
    )

/*++

Routine Description:

    CredGetSessionTypes returns the maximum persistence supported by the current logon
    session.

    For whistler, CRED_PERSIST_LOCAL_MACHINE and CRED_PERSIST_ENTERPRISE credentials can not
    be stored for sessions where the profile is not loaded.  If future releases, credentials
    might not be associated with the user's profile.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    MaximumPersistCount - Specifies the number of elements in the MaximumPersist array.
        The caller should specify CRED_TYPE_MAXIMUM for this parameter.

    MaximumPersist - Returns the maximum persistance supported by the current logon session for
        each credential type.  Index into the array with one of the CRED_TYPE_* defines.
        Returns CRED_PERSIST_NONE if no credential of this type can be stored.
        Returns CRED_PERSIST_SESSION if only session specific credential may be stored.
        Returns CRED_PERSIST_LOCAL_MACHINE if session specific and machine specific credentials
            may be stored.
        Returns CRED_PERSIST_ENTERPRISE if any credential may be stored.

Return Values:

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediGetSessionTypes( &LogonId, MaximumPersistCount, MaximumPersist );

    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrProfileLoaded (
    IN LPWSTR ServerName
    )

/*++

Routine Description:

    The CredProfileLoaded API is a private API used by LoadUserProfile to notify the
    credential manager that the profile for the current user has been loaded.

    The caller must be impersonating the logged on user.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/
{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {

        //
        // This is a notification API.  Don't bother the caller with trivia.
        //  This might be a network token.  Network tokens don't have credentials.
        //

        if ( Status == STATUS_ACCESS_DENIED ) {
            Status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediProfileLoaded( &LogonId );

    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\global.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    global.c

Abstract:

    LSA Subsystem - globals for server side

    This file contains variables that are global to the Lsa Server Side

Author:

    Mike Swift          (MikeSw)        January 14, 1997

Environment:

Revision History:

--*/

#include <lsapch2.h>

//
// Well known LUIDs
//

LUID LsapSystemLogonId;
LUID LsapAnonymousLogonId;

//
//  Well known privilege values
//

LUID LsapTcbPrivilege;

//
// Strings needed for auditing.
//

UNICODE_STRING LsapLsaAuName;
UNICODE_STRING LsapRegisterLogonServiceName;

//
//  The following information pertains to the use of the local SAM
//  for authentication.
//

//
// Length of typical Sids of members of the Account or Built-In Domains
//

ULONG LsapAccountDomainMemberSidLength,
      LsapBuiltinDomainMemberSidLength;

// Sub-Authority Counts for members of the Account or Built-In Domains

UCHAR LsapAccountDomainSubCount,
      LsapBuiltinDomainSubCount;

// Typical Sids for members of Account or Built-in Domains

PSID LsapAccountDomainMemberSid,
     LsapBuiltinDomainMemberSid;

//
// Policy realted globals

UNICODE_STRING LsapDbNames[DummyLastName];
UNICODE_STRING LsapDbObjectTypeNames[DummyLastObject];


//
// Installed, absolute minimum and absolute maximum Quota Limits.
//

LUID LsapSystemLogonId;
LUID LsapZeroLogonId;

//
// Well known privilege values
//

LUID LsapTcbPrivilege;

//
// Well known identifier authorities
//

SID_IDENTIFIER_AUTHORITY    LsapNullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    LsapWorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    LsapLocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    LsapCreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    LsapNtAuthority         = SECURITY_NT_AUTHORITY;

//
// Well Known Sid Table Pointer
//

PLSAP_WELL_KNOWN_SID_ENTRY WellKnownSids;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\lsaerror.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaerror.c

Abstract:

    Local Security Authority Protected Subsystem - Error Routines

Author:

    Scott Birrell       (ScottBi)       April 30, 1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include <netlibnt.h>   // for NetpApiStatusToNtStatus


VOID
LsapLogError(
    IN OPTIONAL PUCHAR Message,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This function retrieves the status of Lsa Initialization.

Arguments:

    Message - Optional Message to be printed out if debugging enabled.

    Status - Standard Nt Result Code supplied by calling routine.

Return Value:

    None.

--*/

{

#if DBG

     if (ARGUMENT_PRESENT(Message)) {

         DbgPrint( Message, Status );
     }

#endif //DBG

}


NTSTATUS
LsapWinerrorToNtStatus(
    IN DWORD WinError
    )
/*++

Routine Description:

    Convert Win32 error code to NTSTATUS code

Arguments:

    WinError - Win32 error code

Return Value:

    Equivalent NTSTATUS code

--*/
{
    return NetpApiStatusToNtStatus( WinError );
}


NTSTATUS
LsapNtStatusFromLastWinError(
    )
/*++

Routine Description:

    Convert error returned by GetLastError() to NTSTATUS code and return

Arguments:

    None

Return Value:

    NTSTATUS code equivalent of GetLastError()

--*/
{
    return LsapWinerrorToNtStatus( GetLastError() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\lsaifree.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    lsaifree.c

Abstract:

    This file contains routines to free structure allocated by the lsar
    routines.  These routines are used by lsa clients which live in the
    lsae process as the lsa server and call the lsar routines directly.


Author:

    Scott Birrell     (ScottBi)    April 15, 1992

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <lsapch2.h>


VOID
LsaiFree_LSAPR_SR_SECURITY_DESCRIPTOR (
    PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine frees the node and the graph of allocated subnodes
    pointed to by an LSAPR_SR_SECURITY_DESCRIPTOR structure.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( SecurityDescriptor )) {

        _fgs__LSAPR_SR_SECURITY_DESCRIPTOR ( SecurityDescriptor );
        MIDL_user_free ( SecurityDescriptor );
    }
}


VOID
LsaIFree_LSAPR_ACCOUNT_ENUM_BUFFER (
    PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer
    )

/*++

Routine Description:

    This routine frees the graph of allocated subnodes pointed to by
    an LSAPR_ACCOUNT_ENUM_BUFFER structure. The structure itself is
    left intact.

Parameters:

    EnumerationBuffer - A pointer to the node whose graph of subnodes
       is to be freed.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT(EnumerationBuffer)) {

        _fgs__LSAPR_ACCOUNT_ENUM_BUFFER ( EnumerationBuffer );
    }
}


VOID
LsaIFree_LSAPR_TRANSLATED_SIDS (
    PLSAPR_TRANSLATED_SIDS TranslatedSids
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_TRANSLATED_SIDS structure.

Parameters:

    TranslatedSids - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( TranslatedSids )) {

        _fgs__LSAPR_TRANSLATED_SIDS ( TranslatedSids );
//        MIDL_user_free( TranslatedSids );
    }
}



VOID
LsaIFree_LSAPR_TRANSLATED_NAMES (
    PLSAPR_TRANSLATED_NAMES TranslatedNames
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_TRANSLATED_NAMES structure.

Parameters:

    TranslatedNames - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( TranslatedNames )) {

        _fgs__LSAPR_TRANSLATED_NAMES( TranslatedNames );
//        MIDL_user_free( TranslatedNames );
    }
}


VOID
LsaIFree_LSAPR_POLICY_INFORMATION (
    POLICY_INFORMATION_CLASS InformationClass,
    PLSAPR_POLICY_INFORMATION PolicyInformation
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated nodes pointed to by
    an LSAPR_POLICY_INFORMATION structure.

Parameters:

    PolicyInformation - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( PolicyInformation )) {

        _fgu__LSAPR_POLICY_INFORMATION ( PolicyInformation, InformationClass );
        MIDL_user_free( PolicyInformation );
    }
}

VOID
LsaIFree_LSAPR_POLICY_DOMAIN_INFORMATION (
    IN POLICY_DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PLSAPR_POLICY_DOMAIN_INFORMATION PolicyDomainInformation
    )
/*++

Routine Description:

    This routine frees the node and graph of allocated nodes pointed to by
    an LSAPR_POLICY_DOMAIN_INFORMATION structure.

Parameters:

    PolicyDomainInformation - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( PolicyDomainInformation )) {

        _fgu__LSAPR_POLICY_DOMAIN_INFORMATION ( PolicyDomainInformation, DomainInformationClass );
        MIDL_user_free( PolicyDomainInformation );
    }
}



VOID
LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO (
    TRUSTED_INFORMATION_CLASS InformationClass,
    PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_TRUSTED_DOMAIN_INFO structure.

Parameters:

    InformationClass - Specifies the Trusted Domain Information Class
        to which the TrustedDomainInformation relates.

    TrustedDomainInformation - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( TrustedDomainInformation )) {

        _fgu__LSAPR_TRUSTED_DOMAIN_INFO ( TrustedDomainInformation, InformationClass );
        MIDL_user_free( TrustedDomainInformation );
    }
}


VOID
LsaIFree_LSAPR_REFERENCED_DOMAIN_LIST (
    PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated nodes pointed to by
    an LSAPR_REFERENCED_DOMAIN_LIST structure.

Parameters:

    ReferencedDomains - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( ReferencedDomains )) {

        _fgs__LSAPR_REFERENCED_DOMAIN_LIST ( ReferencedDomains );
        MIDL_user_free( ReferencedDomains );
    }
}


VOID
LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER (
    PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer
    )

/*++

Routine Description:

    This routine frees the graph of allocated nodes pointed to by
    an LSAPR_TRUST_INFORMATION structure.  The structure itself is
    left intact.

Parameters:

    EnumerationBuffer - A pointer to the node whose graph of subnodes
       is to be freed.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( EnumerationBuffer )) {

        _fgs__LSAPR_TRUSTED_ENUM_BUFFER ( EnumerationBuffer );
    }
}

VOID
LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER_EX (
    PLSAPR_TRUSTED_ENUM_BUFFER_EX EnumerationBuffer
    )

/*++

Routine Description:

    This routine frees the graph of allocated nodes pointed to by
    an LSAPR_TRUST_INFORMATION structure.  The structure itself is
    left intact.

Parameters:

    EnumerationBuffer - A pointer to the node whose graph of subnodes
       is to be freed.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( EnumerationBuffer )) {

        _fgs__LSAPR_TRUSTED_ENUM_BUFFER_EX ( EnumerationBuffer );
    }
}


VOID
LsaIFree_LSAPR_TRUST_INFORMATION (
    PLSAPR_TRUST_INFORMATION TrustInformation
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated nodes pointed to by
    an LSAPR_TRUST_INFORMATION structure.

Parameters:

    TrustInformation - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( TrustInformation )) {

        _fgs__LSAPR_TRUST_INFORMATION ( TrustInformation );
        MIDL_user_free( TrustInformation );
    }
}


VOID
LsaIFree_LSAPR_TRUSTED_DOMAIN_AUTH_BLOB (
    PLSAPR_TRUSTED_DOMAIN_AUTH_BLOB TrustedDomainAuthBlob
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_TRUSTED_DOMAIN_AUTH_BLOB structure.

Parameters:

    TrustedDomainAuthBlob - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( TrustedDomainAuthBlob )) {

        MIDL_user_free( TrustedDomainAuthBlob->AuthBlob );
    }
}

VOID
LsaIFree_LSAI_SECRET_ENUM_BUFFER (
    PVOID EnumerationBuffer,
    ULONG Count
    )

/*++

Routine Description:

    This routine frees the graph of allocated subnodes pointed to by
    an LSAI_SECRET_ENUM_BUFFER structure.  The structure itself is
    left intact.

Parameters:

    EnumerationBuffer - A pointer to the node whose graph of subnodes
        is to be freed.

    Count - Count of the number of Entries in the structure.

Return Values:

    None.

--*/

{
    ULONG Index;

    PLSAPR_UNICODE_STRING EnumerationBufferU = (PLSAPR_UNICODE_STRING) EnumerationBuffer;

    if ( ARGUMENT_PRESENT( EnumerationBuffer)) {

        for (Index = 0; Index < Count; Index++ ) {

            _fgs__LSAPR_UNICODE_STRING( &EnumerationBufferU[Index] );
        }

        MIDL_user_free( EnumerationBufferU );
    }
}


VOID
LsaIFree_LSAI_PRIVATE_DATA (
    PVOID Data
    )

/*++

Routine Description:

    This routine frees a structure containing LSA Private Database
    Information.

Parameters:

    Data - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( Data )) {

        MIDL_user_free( Data );
    }

}


VOID
LsaIFree_LSAPR_SR_SECURITY_DESCRIPTOR (
    PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_SR_SECURITY_DESCRIPTOR structure.

Parameters:

    SecurityDescriptor - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( SecurityDescriptor )) {

        _fgs__LSAPR_SR_SECURITY_DESCRIPTOR( SecurityDescriptor );
        MIDL_user_free( SecurityDescriptor );
    }
}




VOID
LsaIFree_LSAPR_UNICODE_STRING (
    IN PLSAPR_UNICODE_STRING UnicodeName
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_UNICODE_STRING structure.

Parameters:

    UnicodeName - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( UnicodeName )) {

        _fgs__LSAPR_UNICODE_STRING( UnicodeName );
        MIDL_user_free( UnicodeName );
    }
}


VOID
LsaIFree_LSAPR_UNICODE_STRING_BUFFER (
    IN PLSAPR_UNICODE_STRING UnicodeName
    )

/*++

Routine Description:

    This routine frees the graph of allocated subnodes pointed to by
    an LSAPR_UNICODE_STRING structure.

Parameters:

    UnicodeName - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( UnicodeName )) {

        _fgs__LSAPR_UNICODE_STRING( UnicodeName );
    }
}


VOID
LsaIFree_LSAPR_PRIVILEGE_SET (
    IN PLSAPR_PRIVILEGE_SET PrivilegeSet
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_PRIVILEGE_SET structure.

Parameters:

    PrivilegeSet - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( PrivilegeSet )) {

        MIDL_user_free( PrivilegeSet );
    }
}


VOID
LsaIFree_LSAPR_CR_CIPHER_VALUE (
    IN PLSAPR_CR_CIPHER_VALUE CipherValue
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_CR_CIPHER_VALUE structure.  Note that this structure is in
    fact allocated(all_nodes) on the server side of LSA.

Parameters:

    CipherValue - A pointer to the node to free.

Return Values:

    None.

--*/

{
    MIDL_user_free( CipherValue );
}


VOID
LsaIFree_LSAPR_PRIVILEGE_ENUM_BUFFER (
    PLSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer
    )

/*++

Routine Description:

    This routine frees the graph of allocated subnodes pointed to by
    an LSAPR_PRIVILEGE_ENUM_BUFFER structure. The structure itself is
    left intact.

Parameters:

    EnumerationBuffer - A pointer to the node whose graph of subnodes
       is to be freed.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT(EnumerationBuffer)) {

        _fgs__LSAPR_PRIVILEGE_ENUM_BUFFER ( EnumerationBuffer );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\lsainit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsainit.c

Abstract:

    Local Security Authority Protected Subsystem - Initialization

Author:

    Scott Birrell       (ScottBi)       March 12, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include <secur32p.h>
#include <ntddksec.h>
#include <ntdsa.h>
#include "adtp.h"
#include "spinit.h"
#include "efssrv.hxx"
#include "dssetp.h"
#include "sidcache.h"
#include "klpcstub.h"
#include "lsawmi.h"
#include "dpapiprv.h"

//
// Name of event which says that the LSA RPC server is ready
//

#define LSA_RPC_SERVER_ACTIVE           L"LSA_RPC_SERVER_ACTIVE"


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Shared Global Variables                                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

#if LSAP_DIAGNOSTICS
//
// LSA Global Controls
//

ULONG LsapGlobalFlag = 0;
#endif //LSAP_DIAGNOSTICS

//
// Handles used to talk to SAM directly.
// Also, a flag to indicate whether or not the handles are valid.
//

BOOLEAN LsapSamOpened = FALSE;

SAMPR_HANDLE LsapAccountDomainHandle;
SAMPR_HANDLE LsapBuiltinDomainHandle;

DWORD LsapGlobalRestrictNullSessions = TRUE;
DWORD LsapGlobalRestrictAnonymous = TRUE;
DWORD LsapGlobalSetAdminOwner = TRUE;

PWSTR   pszPreferred;

//
// Handle to KSecDD device, for passing down ioctls.
//

HANDLE KsecDevice ;

//
// For outside calls (e.g. RPC originated) CallInfo won't be there,
// but some helper functions will look for it.  This is a default one
// that can be used.
//

LSA_CALL_INFO   LsapDefaultCallInfo ;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Module-Wide variables                                          //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

BOOLEAN LsapHealthCheckingEnabled = FALSE;
BOOLEAN LsapPromoteInitialized = FALSE;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Internal routine prototypes                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

NTSTATUS
LsapActivateRpcServer();

DWORD
LsapRpcServerThread(
    LPVOID Parameter
    );

NTSTATUS
LsapInstallationPause();

VOID
LsapSignalRpcIsActive();

NTSTATUS
LsapDsInitializePromoteInterface(
    VOID
    );

//
// Open the KSec Device
//

VOID
LsapOpenKsec(
    VOID
    )
{
    NTSTATUS Status ;
    UNICODE_STRING String ;
    OBJECT_ATTRIBUTES ObjA ;
    IO_STATUS_BLOCK IoStatus ;

    RtlInitUnicodeString( &String, DD_KSEC_DEVICE_NAME_U );

    InitializeObjectAttributes( &ObjA,
                                &String,
                                0,
                                0,
                                0);

    Status = NtOpenFile( &KsecDevice,
                         GENERIC_READ | GENERIC_WRITE,
                         &ObjA,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         0 );

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "FAILED to open %ws, status %x\n",
                        String.Buffer, Status ));
        return;
    }

    Status = NtDeviceIoControlFile(
                    KsecDevice,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_KSEC_CONNECT_LSA,
                    NULL,
                    0,
                    NULL,
                    0 );

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "FAILED to send ioctl, status %x\n", Status ));
    }
    else
    {
        LsapFindEfsSession();
    }
}


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Routines                                                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



VOID
FixupEnvironment(
    VOID
    )
{
    WCHAR  Root[ MAX_PATH ];
    DWORD  Length;
    PWCHAR PostFix = L"\\System32";
    BOOL   RetVal;

    Length = GetEnvironmentVariable(L"SystemRoot", Root, MAX_PATH);

    ASSERT(Length && Length < MAX_PATH); // Let someone know if the call doesn't work

    wcsncat(Root, PostFix, MAX_PATH - Length - 1);

    ASSERT(MAX_PATH - Length > wcslen (PostFix)); // Let someone know if buffer is too small

    DebugLog((DEB_TRACE_INIT, "Setting PATH to %ws\n", Root));

    RetVal = SetEnvironmentVariable( TEXT("Path"), Root);

    ASSERT(RetVal);
}



VOID
LsapSetupTuningParameters(
    VOID
    )
{
    NT_PRODUCT_TYPE ProductType;
    SYSTEM_INFO si;
    HKEY LsaKey ;
    int err ;
    ULONG Value ;
    ULONG Type ;
    ULONG Size ;
    ULONG GlobalReturn = 0 ;
    NTSTATUS scRet ;

    LsaTuningParameters.ThreadLifespan = 60 ;
    LsaTuningParameters.SubQueueLifespan = 30 ;
    LsaTuningParameters.Options = TUNE_TRIM_WORKING_SET ;


    //
    // setup the preferred critsec spin count.
    //

    GetSystemInfo( &si );

    LsaTuningParameters.CritSecSpinCount = 1000 * si.dwNumberOfProcessors;

    if( LsaTuningParameters.CritSecSpinCount > 32000 )
    {
        LsaTuningParameters.CritSecSpinCount = 32000;
    } else if( LsaTuningParameters.CritSecSpinCount < 1000 )
    {
        LsaTuningParameters.CritSecSpinCount = 1000;
    }


    scRet = RtlGetNtProductType( &ProductType );

    if ( NT_SUCCESS( scRet ) )
    {
        if ( ProductType != NtProductWinNt )
        {
            LsaTuningParameters.ThreadLifespan = 15 * 60 ;
            LsaTuningParameters.SubQueueLifespan = 5 * 60 ;
            LsaTuningParameters.Options = 0 ;

            if ( ProductType == NtProductLanManNt )
            {
                LsaTuningParameters.Options |= TUNE_PRIVATE_HEAP ;

                //
                // On DCs, link to the real version of the NTDSA
                // save and restore.
                //
                GetDsaThreadState = (DSA_THSave *) THSave ;
                RestoreDsaThreadState = (DSA_THRestore *) THRestore ;
            }
        }
    }

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                        0,
                        KEY_READ | KEY_WRITE,
                        &LsaKey );

    if ( err == 0 )
    {
        Value = GetCurrentProcessId();

        RegSetValueEx(
            LsaKey,
            TEXT("LsaPid"),
            0,
            REG_DWORD,
            (PUCHAR) &Value,
            sizeof( DWORD ) );

        Size = sizeof(DWORD);

        err = RegQueryValueEx(  LsaKey,
                                TEXT("GeneralThreadLifespan"),
                                0,
                                &Type,
                                (PUCHAR) &Value,
                                &Size );

        if ( err == 0 )
        {
            LsaTuningParameters.ThreadLifespan = Value ;
        }

        Size = sizeof( DWORD );
        err = RegQueryValueEx(  LsaKey,
                                TEXT("DedicatedThreadLifespan"),
                                0,
                                &Type,
                                (PUCHAR) &Value,
                                &Size );

        if ( err == 0 )
        {
            LsaTuningParameters.SubQueueLifespan = Value ;
        }

        Size = sizeof( DWORD );

        err = RegQueryValueEx(  LsaKey,
                                TEXT("HighPriority"),
                                0,
                                &Type,
                                (PUCHAR) &Value,
                                &Size );

        if ( err == 0 )
        {
            if ( Value )
            {
                LsaTuningParameters.Options |= TUNE_SRV_HIGH_PRIORITY ;
            }
        }


        Size = sizeof( DWORD );
        err = RegQueryValueEx(  LsaKey,
                                TEXT("CritSecSpinCount"),
                                0,
                                &Type,
                                (PUCHAR) &Value,
                                &Size );

        if ( err == 0 )
        {
            if ( Value && (Type == REG_DWORD) )
            {
                LsaTuningParameters.CritSecSpinCount = Value;
            }
        }


        RegCloseKey( LsaKey );
    }

    DebugLog(( DEB_TRACE_INIT, "Tuning parameters:\n" ));
    DebugLog(( DEB_TRACE_INIT, "   Thread Lifespan %d sec\n",
                    LsaTuningParameters.ThreadLifespan ));
    DebugLog(( DEB_TRACE_INIT, "   SubQueue Lifespan %d sec\n",
                    LsaTuningParameters.SubQueueLifespan ));
    DebugLog(( DEB_TRACE_INIT, "   Options:\n" ));
}



NTSTATUS
LsapInitLsa(
    )

/*++

Routine Description:

    This process is activated as a standard SM subsystem.  Initialization
    completion of a SM subsystem is indicated by having the first thread
    exit with status.

    This function initializes the LSA.  The initialization procedure comprises
    the following steps:

    o  LSA Heap Initialization
    o  LSA Command Server Initialization
    o  LSA Database Load
    o  Reference Monitor State Initialization
    o  LSA RPC Server Initialization
    o  LSA Auditing Initialization
    o  LSA Authentication Services Initialization
    o  Wait for Setup to complete (if necessary)
    o  LSA database initialization (product type-specific)
    o  Start backgroup thread to register WMI tracing guids

    Any failure in any of the above steps is fatal and causes the LSA
    process to terminate.  The system must be aborted.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS Status;
    BOOLEAN BooleanStatus = TRUE;
    DWORD EFSRecoverThreadID;
    HANDLE EFSThread ;
    SYSTEM_INFO SysInfo ;

#if DBG
    InitDebugSupport();
#endif

    FixupEnvironment();

    //
    // Optional break point
    //

    BreakOnError(BREAK_ON_BEGIN_INIT);

    //
    // Init the TLS indices
    //

    (void) InitThreadData();

    //
    // Initialize the stack allocator
    //

    SafeAllocaInitialize(
        SAFEALLOCA_USE_DEFAULT,
        SAFEALLOCA_USE_DEFAULT,
        LsapAllocatePrivateHeapNoZero,
        LsapFreePrivateHeap
        );

    LsapSetupTuningParameters();

#if DBG
    LsaTuningParameters.Options |= TUNE_PRIVATE_HEAP ;
#endif

    GetSystemInfo( &SysInfo );
    LsapPageSize = SysInfo.dwPageSize ;
    LsapUserModeLimit = (ULONG_PTR) SysInfo.lpMaximumApplicationAddress ;

    LsapHeapInitialize( ((LsaTuningParameters.Options & TUNE_PRIVATE_HEAP ) != 0) );

    //
    // Initialize this thread:
    //

    SpmpThreadStartup();

    //
    // Update the SSPI cache
    //

    SecCacheSspiPackages();

    //
    // Initialize session tracking:
    //

    if (!InitSessionManager())
    {
        DebugLog((DEB_ERROR, "InitSessionManager failed?\n"));
        Status = STATUS_INTERNAL_ERROR;
        goto InitLsaError;
    }

    //
    // Initialize misc. global variables:
    //

    LsapDefaultCallInfo.Session = pDefaultSession ;
    LsapDefaultCallInfo.LogContext = NULL ;
    LsapDefaultCallInfo.LogonId.HighPart = 0 ;
    LsapDefaultCallInfo.LogonId.LowPart = 999 ;
    LsapDefaultCallInfo.InProcCall = TRUE ;
    LsapDefaultCallInfo.Allocs = MAX_BUFFERS_IN_CALL ;

#if defined(REMOTE_BOOT)
    //
    // Initilize the state indicating whether this is a remote boot machine.
    //

    LsapDbInitializeRemoteBootState();
#endif // defined(REMOTE_BOOT)

    //
    // Initialize scavenger thread control
    //

    if ( !LsapInitializeScavenger() )
    {
        DebugLog(( DEB_ERROR, "Could not initialize scavenger thread\n"));
        Status = STATUS_INTERNAL_ERROR ;
        goto InitLsaError ;
    }

    //
    // Start up the thread pool for support for LPC.
    //

    if (!InitializeThreadPool())
    {
        DebugLog((DEB_ERROR, "Could not init thread pool\n"));
        Status = STATUS_INTERNAL_ERROR;
        goto InitLsaError;

    }

    DebugLog((DEB_TRACE_INIT, "Current TraceLevel is %x\n", SPMInfoLevel));

    //
    // Load parameters from Registry:
    //

    Status = LoadParameters( FALSE );

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // Initialize a copy of the Well-Known Sids, etc. for use by
    // the LSA.
    //

    Status = LsapDbInitializeWellKnownValues();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // If this is a time-checking build, load the timer support
    // functions and initialize them.
    //

#ifdef TIME_SPM

    InitTimer();

#endif

    //
    // If we're going to be in a setup phase, tag it.
    //

    SetupPhase = SpmpIsSetupPass();

    //
    // Tell base/wincon how to shut us down.
    // First, tell base to shut us down as late in the game as possible.

    SetProcessShutdownParameters(SPM_SHUTDOWN_VALUE, SHUTDOWN_NORETRY);

    //
    // And, tell them what function to call when we are being shutdown:
    //

    SetConsoleCtrlHandler(SpConsoleHandler, TRUE);

    //
    // Set security on the synchronization event
    //

    Status = LsapBuildSD(BUILD_KSEC_SD, NULL);

    if (FAILED(Status))
    {
        DebugLog((DEB_ERROR,"Failed to set Ksec security: 0x%x\n",Status));
        goto InitLsaError;
    }

    //
    // Perform LSA Command Server Initialization.  This involves creating
    // an LPC port called the LSA Command Server Port so that the Reference
    // monitor can send commands to the LSA via the port.  After the port
    // is created, an event created by the Reference Monitor is signalled,
    // so that the Reference Monitor can proceed to connect to the port.

    Status = LsapRmInitializeServer();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // Perform LSA Database Server Initialization - Pass 1.
    // This initializes the non-product-type-specific information.
    //

    Status = LsapDbInitializeServer(1);

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // Perform Auditing Initialization - Pass 1.
    //

    Status = LsapAdtInitialize();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    Status = LsapAdtObjsInitialize();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // Load packages:
    //

    // The System Logon session must be present before (at least) the
    // NegpackageLoad routine is called, so we can set it's creating package
    // id, otherwise the package id is 0, which is normally ok, but when a
    // machine is joined to a pre NT5 domain, this will mean that we
    // will not do NTLM in a system logon session.

    if ( !LsapLogonSessionInitialize() )
    {
        goto InitLsaError ;
    }

    Status = LoadPackages(  ppszPackages,
                            ppszOldPkgs,
                            pszPreferred );

    if (FAILED(Status))
    {
        DebugLog((DEB_ERROR, "Error loading packages, terminating (0x%08x)\n",
                Status));
        goto InitLsaError;
    }

    //
    // Initialize the credential manager
    //

    Status = CredpInitialize();

    if ( !NT_SUCCESS( Status )) {
        goto InitLsaError;
    }

    //
    // Initialize data for System LogonID (999):
    //

    InitSystemLogon();

    //
    // Perform RPC Server Initialization.
    //

    Status = LsapRPCInit();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // Initialize Authentication Services
    //

    if (!LsapAuInit()) {

        Status = STATUS_UNSUCCESSFUL;
        goto InitLsaError;
    }

    //
    // Initialize the sid cache
    //

    Status = LsapDbInitSidCache();

    if (!NT_SUCCESS(Status)) {

        DebugLog((DEB_ERROR, "Error initializing sid cache: 0x%x\n",Status));
        goto InitLsaError;
    }

    //
    // Initialize LPC Server to talk to the FSPs waiting on the device driver
    //

    Status = StartLpcThread();

    if (FAILED(Status))
    {
        DebugLog((DEB_ERROR, "Error starting LPC thread, no DD support (0x%08x)\n",
            Status));
        goto InitLsaError;
    }

    //
    // open ksec and have it connect back to us in our own context.
    //

    LsapOpenKsec();

    //
    // Optional breakpoint when initialization complete
    //

    BreakOnError(BREAK_ON_BEGIN_END);

    //
    //  Start processing RPC calls
    //

    Status = LsapActivateRpcServer();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // Initialize DPAPI
    //

    Status = DPAPIInitialize(&LsapSecpkgFunctionTable);

    if ( !NT_SUCCESS( Status )) {

        goto InitLsaError;
    }

    //
    // Pause for installation if necessary
    //

    Status = LsapInstallationPause();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // Perform LSA Database Server Initialization - Pass 2.
    // This initializes the product-type-specific information.
    //

    Status = LsapDbInitializeServer(2);

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // Initialize EFS
    //

    ( VOID )EfsServerInit();

    //
    // If EfsServerInit() fails because of policy & etc.
    // the recovery thread should not be run.
    //

    EFSThread = CreateThread( NULL,
                          0,
                          EFSRecover,
                          NULL,
                          0,
                          &EFSRecoverThreadID );

    if ( EFSThread )
    {
        CloseHandle( EFSThread );
    }

    //
    // Initialize the Setup APIs
    //

    if ( !LsapPromoteInitialized ) {

        DsRolepInitialize();
    }

    Status = LsapStartWmiTraceInitThread();

    if (!NT_SUCCESS(Status)) {
        goto InitLsaError;
    }

InitLsaFinish:

    return(Status);

InitLsaError:

    goto InitLsaFinish;
}



NTSTATUS
LsapActivateRpcServer( VOID )

/*++

Routine Description:

    This function creates a thread for the RPC server.
    The new Thread then goes on to activate the RPC server,
    which causes RPC calls to be delivered when recieved.

Arguments:

    None.

Return Value:

        STATUS_SUCCESS - The thread was successfully created.

        Other status values that may be set by CreateThread().

--*/

{
    NTSTATUS Status;

    // Start listening for remote procedure calls.  The first
    // argument to RpcServerListen is the minimum number of call
    // threads to create; the second argument is the maximum number
    // of concurrent calls allowed.  The final argument indicates that
    // this routine should not wait.  After everything has been initialized,
    // we return.

    Status = I_RpcMapWin32Status(RpcServerListen(1, 1234, 1));

    ASSERT( Status == RPC_S_OK );

    //
    // Set event which signals that RPC server is available.
    //

    LsapSignalRpcIsActive();

    return(STATUS_SUCCESS);
}



NTSTATUS
LsapInstallationPause( VOID )


/*++

Routine Description:

    This function checks to see if the system is in an
    installation state.  If so, it suspends further initialization
    until the installation state is complete.

    Installation state is signified by the existance of a well known
    event.


Arguments:

    None.

Return Value:


        STATUS_SUCCESS - Proceed with initialization.

        Other status values are unexpected.

--*/

{
    if ( SpmpIsSetupPass() ) {

        //
        // The event exists - installation created it and will signal it
        // when it is ok to proceed with security initialization.
        //

        LsapSetupWasRun = TRUE;

        //
        // Intialize the promotion interface
        //
        DsRolepInitialize();
        LsapDsInitializePromoteInterface();
        LsapPromoteInitialized = TRUE;

        //
        // Make sure we are not in mini-setup
        //
        if ( SpmpIsMiniSetupPass() ) {

            LsapSetupWasRun = FALSE;
        }
    }

    return( STATUS_SUCCESS );
}



BOOLEAN
LsaISetupWasRun(
    )

/*++

Routine Description:

    This function determines whether Setup was run.

Arguments:

    None

Return Values

    BOOLEAN - TRUE if setup was run, else FALSE

--*/

{
    return(LsapSetupWasRun);
}



VOID
LsapSignalRpcIsActive(
    )
/*++

Routine Description:

    It creates the LSA_RPC_SERVER_ACTIVE event if one does not already exist
    and signals it so that the service controller can proceed with LSA calls.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD status;
    HANDLE EventHandle;

    EventHandle = CreateEventW(
                      NULL,    // No special security
                      TRUE,    // Must be manually reset
                      FALSE,   // The event is initially not signalled
                      LSA_RPC_SERVER_ACTIVE
                      );

    if (EventHandle == NULL) {

        status = GetLastError();

        //
        // If the event already exists, the service controller beats us
        // to creating it.  Just open it.
        //

        if (status == ERROR_ALREADY_EXISTS) {

            EventHandle = OpenEventW(
                              GENERIC_WRITE,
                              FALSE,
                              LSA_RPC_SERVER_ACTIVE
                              );
        }

        if (EventHandle == NULL) {
            //
            // Could not create or open the event.  Nothing we can do...
            //
            return;
        }
    }

    (VOID) SetEvent(EventHandle);
}


NTSTATUS
LsapGetAccountDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    )

/*++

Routine Description:

    This routine retrieves ACCOUNT domain information from the LSA
    policy database.


Arguments:

    PolicyAccountDomainInfo - Receives a pointer to a
        POLICY_ACCOUNT_DOMAIN_INFO structure containing the account
        domain info.



Return Value:

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

             LsaOpenPolicy()
             LsaQueryInformationPolicy()
--*/

{
    NTSTATUS Status;

    //
    // Query the account domain information
    //

    Status = LsarQueryInformationPolicy( LsapPolicyHandle,
                                        PolicyAccountDomainInformation,
                                        (PLSAPR_POLICY_INFORMATION *) PolicyAccountDomainInfo );
#if DBG
    if ( NT_SUCCESS(Status) ) {
        ASSERT( (*PolicyAccountDomainInfo) != NULL );
        ASSERT( (*PolicyAccountDomainInfo)->DomainSid != NULL );
    }
#endif // DBG

    return(Status);
}


NTSTATUS
LsapOpenSam( VOID )

/*++

Routine Description:

    This routine opens SAM for use during authentication.  It
    opens a handle to both the BUILTIN domain and the ACCOUNT domain.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Succeeded.
--*/

{
    return LsapOpenSamEx( FALSE );
}


NTSTATUS
LsapOpenSamEx(
    BOOLEAN DuringStartup
    )

/*++

Routine Description:

    This routine opens SAM for use during authentication.  It
    opens a handle to both the BUILTIN domain and the ACCOUNT domain.

Arguments:


    DuringStartup - TRUE if this is the call made during startup.  In that case,
        there is no need to wait on the SAM_STARTED_EVENT since the caller ensures
        that SAM is started before the call is made.

Return Value:

    STATUS_SUCCESS - Succeeded.
--*/

{
    NTSTATUS Status, IgnoreStatus;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    SAMPR_HANDLE SamHandle;

    if (LsapSamOpened == TRUE) {    // Global variable

        return(STATUS_SUCCESS);
    }

    //
    // Make sure SAM has initialized
    //

    if ( !DuringStartup ) {
        HANDLE EventHandle;
        OBJECT_ATTRIBUTES EventAttributes;
        UNICODE_STRING EventName;
        LARGE_INTEGER Timeout;

        RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
        InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );
        Status = NtOpenEvent( &EventHandle, SYNCHRONIZE, &EventAttributes );

        if ( !NT_SUCCESS(Status)) {

            if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

                //
                // SAM hasn't created this event yet, let us create it now.
                // SAM opens this event to set it.
                //

                Status = NtCreateEvent(
                               &EventHandle,
                               SYNCHRONIZE|EVENT_MODIFY_STATE,
                               &EventAttributes,
                               NotificationEvent,
                               FALSE // The event is initially not signaled
                               );

                if( Status == STATUS_OBJECT_NAME_EXISTS ||
                    Status == STATUS_OBJECT_NAME_COLLISION ) {

                    //
                    // second change, if the SAM created the event before we
                    // do.
                    //

                    Status = NtOpenEvent( &EventHandle,
                                            SYNCHRONIZE|EVENT_MODIFY_STATE,
                                            &EventAttributes );
                }
            }
        }

        if (NT_SUCCESS(Status)) {

            //
            // See if SAM has signalled that he is initialized.
            //

            Timeout.QuadPart = -10000000; // 1000 seconds
            Timeout.QuadPart *= 1000;
            Status = NtWaitForSingleObject( EventHandle, FALSE, &Timeout );
            IgnoreStatus = NtClose( EventHandle );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {

            return( STATUS_INVALID_SERVER_STATE );
        }
    }

    //
    // Get the member Sid information for the account domain
    //

    Status = LsapGetAccountDomainInfo( &PolicyAccountDomainInfo );

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Get our handles to the ACCOUNT and BUILTIN domains.
    //

    Status = SamIConnect( NULL,     // No server name
                          &SamHandle,
                          SAM_SERVER_CONNECT,
                          TRUE );   // Indicate we are privileged

    if ( NT_SUCCESS(Status) ) {

        //
        // Open the ACCOUNT domain.
        //

        Status = SamrOpenDomain( SamHandle,
                                 DOMAIN_ALL_ACCESS,
                                 PolicyAccountDomainInfo->DomainSid,
                                 &LsapAccountDomainHandle );

        if (NT_SUCCESS(Status)) {

            //
            // Open the BUILTIN domain.
            //

            Status = SamrOpenDomain( SamHandle,
                                     DOMAIN_ALL_ACCESS,
                                     LsapBuiltInDomainSid,
                                     &LsapBuiltinDomainHandle );


            if (NT_SUCCESS(Status)) {

                LsapSamOpened = TRUE;

            } else {

                IgnoreStatus = SamrCloseHandle( &LsapAccountDomainHandle );
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }
        }

        IgnoreStatus = SamrCloseHandle( &SamHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the ACCOUNT domain information
    //

    LsaIFree_LSAPR_POLICY_INFORMATION(
        PolicyAccountDomainInformation,
        (PLSAPR_POLICY_INFORMATION) PolicyAccountDomainInfo );

    return(Status);
}


NTSTATUS
LsapDsInitializePromoteInterface(
    VOID
    )
/*++

Routine Description:

    Performs the initialization required for the Dc promotion/demotions apis, apart
    from what is done during LsaInit

Arguments:

    VOID


Return Values:

    STATUS_SUCCESS -- Success.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ( LsapPromoteInitialized == FALSE ) {

        Status = DsRolepInitializePhase2();
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\lsarm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsarm.c

Abstract:

    Local Security Authority - Reference Monitor Communication

Author:

    Scott Birrell       (ScottBi)      March 26, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>

//
// LSA Global State
//

LSAP_STATE LsapState;

//
// Lsa Reference Monitor Server Command Dispatch Table
//

NTSTATUS
LsapAsyncWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    );

PLSA_COMMAND_WORKER LsapCommandDispatch[] = {

    LsapComponentTestWrkr,
    LsapAdtWriteLogWrkr,
    LsapComponentTestWrkr,
    LsapAsyncWrkr               // LogonSessionDelete handled async

};

PLSA_COMMAND_WORKER LsapAsyncCommandDispatch[] = {
    LsapComponentTestWrkr,
    LsapAdtWriteLogWrkr,
    LsapComponentTestWrkr,
    LsapLogonSessionDeletedWrkr
};

#if 0
DWORD
LsapRmServerWorker(
    PVOID Ignored
    )
{
    PLSA_REPLY_MESSAGE Reply;
    LSA_COMMAND_MESSAGE CommandMessage;

    NTSTATUS Status;

    //
    // Initialize the LPC port message header type and data sizes for
    // for the reply message.
    //

    ReplyMessage.MessageHeader.u2.ZeroInit = 0;
    ReplyMessage.MessageHeader.u1.s1.TotalLength =
        (CSHORT) sizeof(RM_COMMAND_MESSAGE);
    ReplyMessage.MessageHeader.u1.s1.DataLength =
    ReplyMessage.MessageHeader.u1.s1.TotalLength -
        (CSHORT) sizeof(PORT_MESSAGE);

    //
    // Called whenever the port handle is signalled
    //

    return 0;


}
#endif

NTSTATUS
LsapAsyncRmWorker(
    IN PLSA_COMMAND_MESSAGE CommandMessage
    )
{
    LSA_REPLY_MESSAGE ReplyMessage;
    NTSTATUS Status ;

    Status = (LsapAsyncCommandDispatch[CommandMessage->CommandNumber])(
                         CommandMessage,
                         &ReplyMessage);

    //
    // only send a reply if it wasn't a datagram.
    //

    if (CommandMessage->MessageHeader.u2.s2.Type != LPC_DATAGRAM) {

        ReplyMessage.MessageHeader = CommandMessage->MessageHeader ;
        ReplyMessage.ReturnedStatus = Status ;

        Status = NtReplyPort( LsapState.LsaCommandPortHandle,
                              (PPORT_MESSAGE) &ReplyMessage );

    }

    LsapFreePrivateHeap( CommandMessage );

    return Status ;


}

NTSTATUS
LsapAsyncWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    )
{
    LsapAssignThread( LsapAsyncRmWorker,
                      CommandMessage,
                      pDefaultSession,
                      FALSE );

    return STATUS_PENDING ;
}



VOID
LsapRmServerThread(
   )

/*++

Routine Description:

    This function is executed by the LSA Reference Monitor Server Thread.  This
    thread receives messages from the Reference Monitor.  Examples of messages
    include Audit Messages,...  The function is implemented as a for loop
    which runs indefinitely unless an error occurs.  Currently, any
    error is fatal.  On each iteration a message is received from the
    Reference Monitor and dispatched to a handler.

Arguments:

    None.

Return Value:

    None.  Any return is a fatal error.

--*/

{
    PLSA_REPLY_MESSAGE Reply;
    // LSA_COMMAND_MESSAGE CommandMessage;
    LSA_REPLY_MESSAGE ReplyMessage;
    PLSA_COMMAND_MESSAGE CommandMessage = NULL;

    NTSTATUS Status;
    BOOLEAN PriorDatagram = FALSE;

    //
    // Initialize the LPC port message header type and data sizes for
    // for the reply message.
    //

    ReplyMessage.MessageHeader.u2.ZeroInit = 0;
    ReplyMessage.MessageHeader.u1.s1.TotalLength =
        (CSHORT) sizeof(RM_COMMAND_MESSAGE);
    ReplyMessage.MessageHeader.u1.s1.DataLength =
    ReplyMessage.MessageHeader.u1.s1.TotalLength -
        (CSHORT) sizeof(PORT_MESSAGE);

    //
    // First time through, there is no reply.
    //

    Reply = NULL;

    //
    // Now loop indefinitely, processing incoming Command Message Packets
    //

    for(;;) {

        //
        // Wait for and receive a message from the Reference Monitor through
        // the Lsa Command LPC Port.
        //

        //
        // If Reply is NULL, then this is either the first time through the
        // loop, or we have spun the last command off async, so don't screw
        // with its buffer.  Otherwise, the pointer is valid, and ready to
        // be reused.
        //

        if ( !Reply )
        {
            CommandMessage = LsapAllocatePrivateHeap(
                                sizeof( LSA_COMMAND_MESSAGE ) );

            while ( !CommandMessage )
            {
                //
                // A bit of a pickle.  We need to have a buffer to receive on.
                // Spin and retry:
                //

                Sleep( 100 );

                CommandMessage = LsapAllocatePrivateHeap(
                                    sizeof( LSA_COMMAND_MESSAGE ) );
            }
        }


        //
        // if prior datagram, do not send a reply.
        //

        Status = NtReplyWaitReceivePort(
                    LsapState.LsaCommandPortHandle,
                    NULL,
                    (PPORT_MESSAGE) (!PriorDatagram ? Reply : NULL),
                    (PPORT_MESSAGE) CommandMessage
                    );

        //
        // assume not datagram.
        //

        PriorDatagram = FALSE;


        if (Status != 0) {
            if (!NT_SUCCESS( Status ) &&
                Status != STATUS_INVALID_CID &&
                Status != STATUS_UNSUCCESSFUL
               ) {
                KdPrint(("LSASS: Lsa message receive from Rm failed x%lx\n", Status));
            }

            //
            // Ignore if client went away.
            //

            Reply = NULL;
            continue;
        }

        //
        // If an LPC request, process it.
        //

        if (CommandMessage->MessageHeader.u2.s2.Type == LPC_REQUEST ||
            CommandMessage->MessageHeader.u2.s2.Type == LPC_DATAGRAM) {

            //
            //
            // Now dispatch to a routine to handle the command.  Allow
            // command errors to occur without bringing system down.
            //

            Reply = &ReplyMessage;
            Reply->MessageHeader = CommandMessage->MessageHeader ;

            Status = (LsapCommandDispatch[CommandMessage->CommandNumber])(
                         CommandMessage,
                         Reply);

            if ( Status == STATUS_PENDING )
            {
                //
                // It has been sent off asynchronously.  Set the reply
                // to NULL so that we don't trip the LPC at the top of
                // the loop, and the handler will do it when it is done.
                //

                Reply = NULL ;
            }
            else
            {
                ReplyMessage.ReturnedStatus = Status;

                //
                // datagram should not send a reply, and, we can re-use
                // the prior buffer.
                //

                if(CommandMessage->MessageHeader.u2.s2.Type == LPC_DATAGRAM)
                {
                    PriorDatagram = TRUE;
                }

            }

        } else {

            Reply = NULL;
        }

    }  // end_for

    return;
}


NTSTATUS
LsapRmInitializeServer(
    )

/*++

Routine Description:

    This function initializes the Lsa Reference Monitor Server Thread.
    The following steps are performed.

    o Create the Lsa Command LPC Port
    o Open the Lsa Init event created by the Reference Monitor
    o Signal the Lsa Init Event, telling RM to go ahead and connect
      to the port
    o Connect to the Reference Monitor Command Port as client
    o Listen for the Reference Monitor to connect to the port
    o Accept the connection to the port
    o Complete the connection to the port
    o Create the LSA Reference Monitor Server Thread

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status;

    PORT_MESSAGE ConnectionRequest;
    REMOTE_PORT_VIEW ClientView;

    HANDLE LsaInitEventHandle;
    OBJECT_ATTRIBUTES LsaInitEventObjA;
    UNICODE_STRING LsaInitEventName;

    UNICODE_STRING RmCommandPortName, LsaCommandPortName;

    OBJECT_ATTRIBUTES LsaCommandPortObjA;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;

    HANDLE Thread;
    DWORD Ignore;

    //
    // Create the Lsa Command LPC Port.  This port will receive
    // commands from the Reference Monitor.
    //

    RtlInitUnicodeString( &LsaCommandPortName, L"\\SeLsaCommandPort" );

    //
    // Setup to create LSA Command Port
    //

    InitializeObjectAttributes(
        &LsaCommandPortObjA,
        &LsaCommandPortName,
        0,
        NULL,
        NULL
        );

    Status = NtCreatePort(
                 &LsapState.LsaCommandPortHandle,
                 &LsaCommandPortObjA,
                 0,
                 sizeof(LSA_COMMAND_MESSAGE),
                 sizeof(LSA_COMMAND_MESSAGE) * 32
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Port Create failed 0x%lx\n",Status));
        goto InitServerError;
    }

    //
    // Open the LSA Init Event created by the Reference Monitor
    //

    RtlInitUnicodeString( &LsaInitEventName, L"\\SeLsaInitEvent" );

    InitializeObjectAttributes(
        &LsaInitEventObjA,
        &LsaInitEventName,
        0,
        NULL,
        NULL
        );

    Status = NtOpenEvent(
        &LsaInitEventHandle,
        EVENT_MODIFY_STATE,
        &LsaInitEventObjA
        );

    //
    // If the LSA Init event could not be opened, the LSA cannot
    // synchronize with the Reference Monitor so neither component will
    // function correctly.
    //

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Lsa Init Event Open failed 0x%lx\n",Status));
        goto InitServerError;
    }

    //
    // Signal the LSA Init Event.  If the signalling fails, the LSA
    // is not able to synchronize properly with the Reference Monitor.
    // This is a serious error which prevents both components from
    // functioning correctly.
    //

    Status = NtSetEvent( LsaInitEventHandle, NULL );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Init Event Open failed 0x%lx\n",Status));
        goto InitServerError;
    }

    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    //
    // Connect to the Reference Monitor Command Port.  This port
    // is used to send commands from the LSA to the Reference Monitor.
    //

    RtlInitUnicodeString( &RmCommandPortName, L"\\SeRmCommandPort" );

    Status = NtConnectPort(
                 &LsapState.RmCommandPortHandle,
                 &RmCommandPortName,
                 &DynamicQos,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Connect to Rm Command Port failed 0x%lx\n",Status));
        goto InitServerError;
    }

    //
    // Listen for the Reference Monitor To Connect to the LSA
    // Command Port.
    //

    ConnectionRequest.u1.s1.TotalLength = sizeof(ConnectionRequest);
    ConnectionRequest.u1.s1.DataLength = (CSHORT)0;
    Status = NtListenPort(
                 LsapState.LsaCommandPortHandle,
                 &ConnectionRequest
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Port Listen failed 0x%lx\n",Status));
        goto InitServerError;
    }

    //
    // Accept the connection to the Lsa Command Port.
    //

    ClientView.Length = sizeof(ClientView);
    Status = NtAcceptConnectPort(
                 &LsapState.LsaCommandPortHandle,
                 NULL,
                 &ConnectionRequest,
                 TRUE,
                 NULL,
                 &ClientView
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Port Accept Connect failed 0x%lx\n",Status));

        goto InitServerError;
    }

    //
    // Complete the connection
    //

    Status = NtCompleteConnectPort(LsapState.LsaCommandPortHandle);

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Port Complete Connect failed 0x%lx\n",Status));
        goto InitServerError;
    }



    //
    // Create the LSA Reference Monitor Server Thread
    //

    Thread = CreateThread(
                 NULL,
                 0L,
                 (LPTHREAD_START_ROUTINE) LsapRmServerThread,
                 (LPVOID)0,
                 0L,
                 &Ignore
                 );

    if (Thread == NULL) {

        KdPrint(("LsapRmInitializeServer - Create Thread  failed 0x%lx\n",Status));
    } else {
        CloseHandle(Thread);
        Thread = NULL;
    }

    Status = STATUS_SUCCESS;

    goto InitServerCleanup;

InitServerError:

    //
    // Perform cleanup needed only in error cases here.
    //

InitServerCleanup:

    //
    // Perform cleanup needed in all cases here
    //

    return Status;
}


NTSTATUS
LsapCallRm(
    IN RM_COMMAND_NUMBER CommandNumber,
    IN OPTIONAL PVOID CommandParams,
    IN ULONG CommandParamsLength,
    OUT OPTIONAL PVOID ReplyBuffer,
    IN ULONG ReplyBufferLength
    )

/*++

Routine Description:

    This function sends a command to the Reference Monitor from the LSA via
    the LSA Command LPC Port.  This function must only be called from within
    Lsa code.  If the command has parameters, they will be copied directly
    into a message structure and sent via LPC, therefore, the supplied
    parameters may not contain any absolute pointers.  A caller must remove
    pointers by "marshalling" them into the buffer CommandParams.

    To implement a new RM command, do the following:
    ================================================

    (1)  Provide in the executive an RM worker routine called
         SepRm<command>Wrkr to service the command.  See file
         ntos\se\rmmain.c for examples.  NOTE: If the command takes
         parameters, they must not contain any absolute pointers (addresses).

    (2)  In file private\inc\ntrmlsa.h, append the name of the new command to
         the enumerated type RM_COMMAND_NUMBER.  Change the #define for
         RmMaximumCommand to reference the new command.

    (3)  Add the SepRm<command>Wrkr to the command dispatch table structure
         SepRmCommandDispatch[] in file ntos\se\rmmain.c.

    (4)  Add function prototypes to lsap.h and sep.h.

Arguments:

    CommandNumber - Specifies the command

    CommandParams - Optional command-dependent parameters.  The parameters
        must be in marshalled format, that is, there must not be any
        absolute address pointers in the buffer.

    CommandParamsLength - Length in bytes of command parameters.  Must be 0
          if no command parameters supplied.

    ReplyBuffer - Reply Buffer in which data (if any) from the command will
        be returned.

    ReplyBufferLength - Length of ReplyBuffer in bytes.

Return Value:

    NTSTATUS - Result Code.  This is either a result code returned from
        trying to send the command/receive the reply, or a status code
        from the command itself.

--*/

{
    NTSTATUS Status;
    RM_COMMAND_MESSAGE CommandMessage;
    RM_REPLY_MESSAGE ReplyMessage;

    //
    // Assert that the Command Number is valid.
    //

    ASSERT( CommandNumber >= RmMinimumCommand &&
            CommandNumber <= RmMaximumCommand );

    //
    // If command parameters are supplied, assert that the length of the
    // command parameters is positive and not too large.  If no command
    // parameters are supplied, assert that the length field is 0.
    //

    ASSERT( ( ARGUMENT_PRESENT( CommandParams ) &&
              CommandParamsLength > 0 &&
              CommandParamsLength <= RM_MAXIMUM_COMMAND_PARAM_SIZE ) ||

            ( !ARGUMENT_PRESENT( CommandParams ) &&
              CommandParamsLength == 0 )
          );

    //
    // If a Reply Buffer is provided, assert that its length is > 0
    // and not too large.
    //

    ASSERT( ( ARGUMENT_PRESENT( ReplyBuffer ) &&
              ReplyBufferLength > 0 &&
              ReplyBufferLength <= LSA_MAXIMUM_REPLY_BUFFER_SIZE ) ||

            ( !ARGUMENT_PRESENT( ReplyBuffer ) &&
              ReplyBufferLength == 0 )
          );

    //
    // Construct a message for LPC.  First, fill in the message header
    // fields for LPC, specifying the message type and data sizes for
    // the outgoing CommandMessage and the incoming ReplyMessage.
    //

    CommandMessage.MessageHeader.u2.ZeroInit = 0;
    CommandMessage.MessageHeader.u1.s1.TotalLength =
        ((CSHORT) RM_COMMAND_MESSAGE_HEADER_SIZE +
        (CSHORT) CommandParamsLength);
    CommandMessage.MessageHeader.u1.s1.DataLength =
        CommandMessage.MessageHeader.u1.s1.TotalLength -
        (CSHORT) sizeof(PORT_MESSAGE);

    ReplyMessage.MessageHeader.u2.ZeroInit = 0;
    ReplyMessage.MessageHeader.u1.s1.DataLength = (CSHORT) ReplyBufferLength;
    ReplyMessage.MessageHeader.u1.s1.TotalLength =
        ReplyMessage.MessageHeader.u1.s1.DataLength +
        (CSHORT) sizeof(PORT_MESSAGE);

    //
    // Next, fill in the header info needed by the Reference Monitor.
    //

    CommandMessage.CommandNumber = CommandNumber;
    ReplyMessage.ReturnedStatus = STATUS_SUCCESS;

    //
    // Finally, copy the command parameters (if any) into the message buffer.
    //

    if (CommandParamsLength > 0) {

        RtlCopyMemory(CommandMessage.CommandParams,CommandParams,CommandParamsLength);
    }

    // Send Message to the RM via the RM Command Server LPC Port
    //

    Status = NtRequestWaitReplyPort(
                 LsapState.RmCommandPortHandle,
                 (PPORT_MESSAGE) &CommandMessage,
                 (PPORT_MESSAGE) &ReplyMessage
                 );

    //
    // If the command was successful, copy the data back to the output
    // buffer.
    //

    if (NT_SUCCESS(Status)) {

        //
        // Move output from command (if any) to buffer.  Note that this
        // is done even if the command returns status, because some status
        // values are not errors.
        //

        if (ARGUMENT_PRESENT(ReplyBuffer)) {

            RtlCopyMemory(
                ReplyBuffer,
                ReplyMessage.ReplyBuffer,
                ReplyBufferLength
                );

        }

        //
        // Return status from command.
        //

        Status = ReplyMessage.ReturnedStatus;

    } else {

        KdPrint(("Security: Command sent from LSA to RM returned 0x%lx\n",Status));
    }

    return Status;
}



NTSTATUS
LsapComponentTestWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    This function processes the Component Test LSA Rm Server command.
    This is a temporary command that can be used to verifiey that the link
    from RM to LSA is working.

Arguments:

    CommandMessage - Pointer to structure containing LSA command message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command number (LsapComponentTestCommand).  This command
        currently has one parameter, the fixed value 0x1234567.

    ReplyMessage - Pointer to structure containing LSA reply message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command ReturnedStatus field in which a status code from the
        command will be returned.

Return Value:

    STATUS_SUCCESS - The test call has completed successfully.

    STATUS_INVALID_PARAMETER - The argument value received was not the
        expected argument value.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Strict check that command is correct.
    //

    ASSERT( CommandMessage->CommandNumber == LsapComponentTestCommand );

    KdPrint(("Security: LSA Component Test Command Received\n"));

    //
    // Verify that the parameter value passed is as expected.
    //

    if (*((ULONG *) CommandMessage->CommandParams) !=
        LSA_CT_COMMAND_PARAM_VALUE ) {

        Status = STATUS_INVALID_PARAMETER;
    }

    UNREFERENCED_PARAMETER(ReplyMessage); // Intentionally not referenced
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\lsasrvmm.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lsasrvmm.c

Abstract:

    This module provides LSA Server Memory Management including the following

    - Heap allocation and free routines
    - Free List Management.
    - RPC memory copy routines

Author:

    Jim Kelly         JimK         February 26, 1991
    Scott Birrell     ScottBi      February 29, 1992

Revision History:

--*/

#include <lsapch2.h>




NTSTATUS
LsapMmCreateFreeList(
    OUT PLSAP_MM_FREE_LIST FreeList,
    IN ULONG MaxEntries
    )

/*++

Routine Description:

    This function creates a Free List.  The Free List structure is
    initialized and, if a non-zero maximum entry count is
    specified, an array of buffer entries is created.

Arguments:

    FreeList - Pointer to Free List structure to be initialized.  It is
        the caller's responsibility to provide memory for this structure.

    MaxEntries - Specifies the maximum entries for the Free List.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.  In this case,
            the Free List header is initialized with a zero count.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    FreeList->MaxCount = MaxEntries;
    FreeList->UsedCount = 0;

    if (MaxEntries > 0) {

        FreeList->Buffers =
            LsapAllocateLsaHeap(MaxEntries * sizeof(LSAP_MM_FREE_LIST_ENTRY));

        if (FreeList->Buffers == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            FreeList->MaxCount = 0;
        }
    }

    return(Status);
}


NTSTATUS
LsapMmAllocateMidl(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PVOID *BufferAddressLocation,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This function allocates memory for a buffer via MIDL_user_allocate
    and returns the resulting buffer address in a specified location.
    The address of the allocated buffer is recorded in the Free List.

Arguments:

    FreeList - Optional pointer to Free List.

    BufferAddressLocation - Pointer to location that will receive either the
        address of the allocated buffer, or NULL.

    BufferLength - Size of the buffer in bytes.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            such as memory to complete the call.

--*/

{
    //
    // If no Free List is specified, just allocate the memory.
    //

    if (FreeList == NULL) {

        *BufferAddressLocation = MIDL_user_allocate(BufferLength);

        if (*BufferAddressLocation != NULL) {

            return(STATUS_SUCCESS);
        }

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // A Free List is specified.
    //

    if (FreeList->UsedCount < FreeList->MaxCount) {

        *BufferAddressLocation = MIDL_user_allocate(BufferLength);

        if (*BufferAddressLocation != NULL) {

            FreeList->Buffers[FreeList->UsedCount].Buffer = *BufferAddressLocation;
            FreeList->Buffers[FreeList->UsedCount].Options = LSAP_MM_MIDL;
            FreeList->UsedCount++;
            return(STATUS_SUCCESS);
        }
    }

    *BufferAddressLocation = NULL;
    return(STATUS_INSUFFICIENT_RESOURCES);
}


VOID
LsapMmFreeLastEntry(
    IN PLSAP_MM_FREE_LIST FreeList
    )

/*++

Routine Description:

    This function frees the last buffer appeended to the Free List.

Arguments:

    FreeList - Pointer to Free List.

--*/

{
    ULONG LastIndex = FreeList->UsedCount - 1;

    if (FreeList->Buffers[LastIndex].Options & LSAP_MM_MIDL) {

        MIDL_user_free( FreeList->Buffers[LastIndex].Buffer );

    } else {

        LsapFreeLsaHeap( FreeList->Buffers[LastIndex].Buffer );
    }

    FreeList->Buffers[LastIndex].Buffer = NULL;
    FreeList->UsedCount--;
}

VOID
LsapMmCleanupFreeList(
    IN PLSAP_MM_FREE_LIST FreeList,
    IN ULONG Options
    )

/*++

Routine Description:

    This function optionally frees up buffers on the specified Free List,
    and disposes of the List buffer pointer array.

Arguments:

    FreeList - Pointer to Free List

    Options - Specifies optional actions to be taken

        LSAP_MM_FREE_BUFFERS - Free buffers on the list.

Return Values:

    None.

--*/

{
    ULONG Index;
    PVOID Buffer = NULL;

    //
    // If requested, free up the memory for each buffer on the list.
    //

    if (Options & LSAP_MM_FREE_BUFFERS) {

        for (Index = 0; Index < FreeList->UsedCount; Index++) {

            Buffer = FreeList->Buffers[Index].Buffer;

            if (FreeList->Buffers[Index].Options & LSAP_MM_MIDL) {

                MIDL_user_free(Buffer);
                continue;
            }

            if (FreeList->Buffers[Index].Options & LSAP_MM_HEAP) {

                LsapFreeLsaHeap(Buffer);
            }
        }
    }

    //
    // Now dispose of the List buffer pointer array.
    //

    if (FreeList->MaxCount > 0) {

        LsapFreeLsaHeap( FreeList->Buffers );
        FreeList->Buffers = NULL;
    }
}


NTSTATUS
LsapRpcCopyUnicodeString(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString
    )

/*++

Routine Description:

    This function copies a Unicode String to an output string, allocating
    memory for the output string's buffer via MIDL_user_allocate.  The
    buffer is recorded on the specified Free List (if any).

Arguments:

    FreeList - Optional pointer to Free List.

    DestinationString - Pointer to Output Unicode String structure to
        be initialized.

    SourceString - Pointer to input string

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Copy the Unicode String structure.
    //

    *DestinationString = *SourceString;

    //
    // If there is no source string buffer, just return.
    //

    if (SourceString->Buffer == NULL) {

        goto RpcCopyUnicodeStringFinish;
    }

    //
    // If the source string is of NULL length, set the destination buffer
    // to NULL.
    //

    if (SourceString->MaximumLength == 0) {

        DestinationString->Buffer = NULL;
        goto RpcCopyUnicodeStringFinish;
    }

    if (ARGUMENT_PRESENT(FreeList)) {

        Status = LsapMmAllocateMidl(
                     FreeList,
                     (PVOID *) &DestinationString->Buffer,
                     SourceString->MaximumLength
                     );

        if (!NT_SUCCESS(Status)) {

            goto RpcCopyUnicodeStringError;
        }

    } else {

         DestinationString->Buffer =
             MIDL_user_allocate( SourceString->MaximumLength );

         if (DestinationString->Buffer == NULL) {

             goto RpcCopyUnicodeStringError;
         }
    }

    //
    // Copy the source Unicode string over to the MIDL-allocated destination.
    //

    RtlCopyUnicodeString( DestinationString, SourceString );

RpcCopyUnicodeStringFinish:

    return(Status);

RpcCopyUnicodeStringError:

    Status = STATUS_INSUFFICIENT_RESOURCES;
    goto RpcCopyUnicodeStringFinish;
}


NTSTATUS
LsapRpcCopyUnicodeStrings(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    IN ULONG Count,
    OUT PUNICODE_STRING *DestinationStrings,
    IN PUNICODE_STRING SourceStrings
    )

/*++

Routine Description:

    This function constructs an array of Unicode strings in which the
    memory for the array and the string buffers has been allocated via
    MIDL_user_allocate().  It is called by server API workers to construct
    output string arrays.  Memory allocated can optionally be placed on
    the caller's Free List (if any).

Arguments:

    FreeList - Optional pointer to Free List.

    DestinationStrings - Receives a pointer to an initialized array of Count
        Unicode String structures.

    SourceStrings - Pointer to input array of Unicode String structures.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index = 0, FreeIndex;
    PUNICODE_STRING OutputDestinationStrings = NULL;
    ULONG OutputDestinationStringsLength;

    if (Count == 0) {

        goto CopyUnicodeStringsFinish;
    }

    //
    // Allocate zero-filled memory for the array of Unicode String
    // structures.
    //

    OutputDestinationStringsLength = Count * sizeof (UNICODE_STRING);
    OutputDestinationStrings = MIDL_user_allocate( OutputDestinationStringsLength );

    Status = STATUS_INSUFFICIENT_RESOURCES;

    if (OutputDestinationStrings == NULL) {

        goto CopyUnicodeStringsError;
    }

    //
    // Now copy each string, allocating memory via MIDL_user_allocate()
    // for its buffer if non-NULL.
    //

    for (Index = 0; Index < Count; Index++) {

        Status = LsapRpcCopyUnicodeString(
                     FreeList,
                     &OutputDestinationStrings[Index],
                     &SourceStrings[Index]
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto CopyUnicodeStringsError;
    }

CopyUnicodeStringsFinish:

    *DestinationStrings = OutputDestinationStrings;

    return(Status);

CopyUnicodeStringsError:

    //
    // If necessary, free up any Unicode string buffers allocated here.
    //

    for (FreeIndex = 0; FreeIndex < Index; FreeIndex++) {

        if (OutputDestinationStrings[ FreeIndex].Buffer != NULL) {

            MIDL_user_free( &OutputDestinationStrings[ FreeIndex].Buffer );
        }
    }

    //
    // If necessary, free the buffer allocated to hold the array of
    // Unicode string structures.
    //

    if (OutputDestinationStrings != NULL) {

        MIDL_user_free( OutputDestinationStrings );
        OutputDestinationStrings = NULL;
    }

    goto CopyUnicodeStringsFinish;
}


NTSTATUS
LsapRpcCopySid(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PSID *DestinationSid,
    IN PSID SourceSid
    )

/*++

Routine Description:

    This function makes a copy of a Sid in which memory is allocated
    via MIDL user allocate.  It is called to return Sids via RPC to
    the client.

Arguments:

    FreeList - Optional pointer to Free List.

    DestinationSid - Receives a pointer to the Sid copy.

    SourceSid - Pointer to the Sid to be copied.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG SidLength;

    if ( SourceSid ) {

        SidLength = RtlLengthSid( SourceSid );

        Status = LsapMmAllocateMidl(
                     FreeList,
                     DestinationSid,
                     SidLength
                     );

        if (NT_SUCCESS(Status)) {

            RtlCopyMemory( *DestinationSid, SourceSid, SidLength );
        }

    } else {

        *DestinationSid = NULL;
    }

    return( Status );
}


NTSTATUS
LsapRpcCopyTrustInformation(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PLSAPR_TRUST_INFORMATION OutputTrustInformation,
    IN PLSAPR_TRUST_INFORMATION InputTrustInformation
    )

/*++

Routine Description:

    This function makes a copy of a Trust Information structure in which
    the Sid and Name buffer have been allocated individually by
    MIDL_user_allocate.  The function is used to generate output
    Trust Information for RPC server API.  Cleanup is the responsibility
    of the caller.

Arguments:

    FreeList - Optional pointer to Free List.

    OutputTrustInformation - Points to Trust Information structure to
        be filled in.  This structure has normally been allocated via
        MIDL_user_allocate.

    InputTrustInformation - Pointer to input Trust Information.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Copy the Name.
    //

    Status = LsapRpcCopyUnicodeString(
                 FreeList,
                 (PUNICODE_STRING) &OutputTrustInformation->Name,
                 (PUNICODE_STRING) &InputTrustInformation->Name
                 );

    if (!NT_SUCCESS(Status)) {

        goto CopyTrustInformationError;
    }

    //
    // Copy the Sid.
    //

    Status = LsapRpcCopySid(
                 FreeList,
                 (PSID) &OutputTrustInformation->Sid,
                 (PSID) InputTrustInformation->Sid
                 );

    if (!NT_SUCCESS(Status)) {

        goto CopyTrustInformationError;
    }

CopyTrustInformationFinish:

    return(Status);

CopyTrustInformationError:

    goto CopyTrustInformationFinish;
}



NTSTATUS
LsapRpcCopyTrustInformationEx(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX OutputTrustInformation,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX InputTrustInformation
    )
/*++

Routine Description:

    This function makes a copy of a Trust Information Ex structure in which
    the Sid and Name buffers have been allocated individually by
    MIDL_user_allocate.  The function is used to generate output
    Trust Information for RPC server API.  Cleanup is the responsibility
    of the caller.

Arguments:

    FreeList - Optional pointer to Free List.

    OutputTrustInformation - Points to Trust Information structure to
        be filled in.  This structure has normally been allocated via
        MIDL_user_allocate.

    InputTrustInformation - Pointer to input Trust Information.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlZeroMemory( OutputTrustInformation, sizeof( LSAPR_TRUSTED_DOMAIN_INFORMATION_EX ) );
    //
    // Copy the Name.
    //

    Status = LsapRpcCopyUnicodeString(
                 FreeList,
                 (PUNICODE_STRING) &OutputTrustInformation->Name,
                 (PUNICODE_STRING) &InputTrustInformation->Name
                 );

    if (!NT_SUCCESS(Status)) {

        goto CopyTrustInformationError;
    }

    //
    // Copy the Flat Name.
    //

    Status = LsapRpcCopyUnicodeString(
                 FreeList,
                 (PUNICODE_STRING) &OutputTrustInformation->FlatName,
                 (PUNICODE_STRING) &InputTrustInformation->FlatName
                 );

    if (!NT_SUCCESS(Status)) {

        goto CopyTrustInformationError;
    }

    //
    // Copy the Sid.
    //

    if ( InputTrustInformation->Sid ) {

        Status = LsapRpcCopySid(
                     FreeList,
                     (PSID) &OutputTrustInformation->Sid,
                     (PSID) InputTrustInformation->Sid
                     );

        if (!NT_SUCCESS(Status)) {

            goto CopyTrustInformationError;
        }

    } else {

        OutputTrustInformation->Sid = NULL;
    }

    //
    // Copy the remaining information
    //
    OutputTrustInformation->TrustType = InputTrustInformation->TrustType;
    OutputTrustInformation->TrustDirection = InputTrustInformation->TrustDirection;
    OutputTrustInformation->TrustAttributes = InputTrustInformation->TrustAttributes;

CopyTrustInformationFinish:

    return(Status);

CopyTrustInformationError:

    if ( FreeList == NULL ) {

        MIDL_user_free( OutputTrustInformation->Name.Buffer );
        OutputTrustInformation->Name.Buffer = NULL;

        MIDL_user_free( OutputTrustInformation->FlatName.Buffer );
        OutputTrustInformation->FlatName.Buffer = NULL;

        MIDL_user_free( OutputTrustInformation->Sid );
        OutputTrustInformation->Sid = NULL;
    }

    goto CopyTrustInformationFinish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\oldstub.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    oldstub.c

Abstract:

    This file contains functions generated by midl v1.0.  These
    function were designed to only be called by the stubs,
    these paticular functions are called by user code.  This
    file is needed in order to compile lsa with midl v2.0 which
    doesn't generated these paticular functions anymore.

Author:

    Mario Goertzel      (MarioGo)    Jan 10, 1994

Environment:

    User Mode - Win32

Revision History:


--*/
#include <lsapch2.h>

/* routine that frees graph for struct _STRING */
void _fgs__STRING (STRING  * _source)
  {
  if (_source->Buffer !=0)
    {
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

  /* routine that frees graph for struct _LSAPR_SID_INFORMATION */
void _fgs__LSAPR_SID_INFORMATION (LSAPR_SID_INFORMATION  * _source)
  {
  if (_source->Sid !=0)
    {
    MIDL_user_free((void  *)(_source->Sid));
    }
  }

  /* routine that frees graph for struct _LSAPR_SID_ENUM_BUFFER */
void _fgs__LSAPR_SID_ENUM_BUFFER (LSAPR_SID_ENUM_BUFFER  * _source)
  {
  if (_source->SidInfo !=0)
    {
      {
      unsigned long _sym5;
      for (_sym5 = 0; _sym5 < (unsigned long )(0 + _source->Entries); _sym5++)
        {
        _fgs__LSAPR_SID_INFORMATION ((LSAPR_SID_INFORMATION *)&_source->SidInfo[_sym5]);
        }
      }
    MIDL_user_free((void  *)(_source->SidInfo));
    }
  }

  /* routine that frees graph for struct _LSAPR_ACCOUNT_INFORMATION */
void _fgs__LSAPR_ACCOUNT_INFORMATION (LSAPR_ACCOUNT_INFORMATION  * _source)
  {
  if (_source->Sid !=0)
    {
    MIDL_user_free((void  *)(_source->Sid));
    }
  }

  /* routine that frees graph for struct _LSAPR_ACCOUNT_ENUM_BUFFER */
void _fgs__LSAPR_ACCOUNT_ENUM_BUFFER (LSAPR_ACCOUNT_ENUM_BUFFER  * _source)
  {
  if (_source->Information !=0)
    {
      {
      unsigned long _sym11;
      for (_sym11 = 0; _sym11 < (unsigned long )(0 + _source->EntriesRead); _sym11++)
        {
        _fgs__LSAPR_ACCOUNT_INFORMATION ((LSAPR_ACCOUNT_INFORMATION *)&_source->Information[_sym11]);
        }
      }
    MIDL_user_free((void  *)(_source->Information));
    }
  }

  /* routine that frees graph for struct _LSAPR_UNICODE_STRING */
void _fgs__LSAPR_UNICODE_STRING (LSAPR_UNICODE_STRING  * _source)
  {
  if (_source->Buffer !=0)
    {
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

  /* routine that frees graph for struct _LSAPR_SECURITY_DESCRIPTOR */
void _fgs__LSAPR_SECURITY_DESCRIPTOR (LSAPR_SECURITY_DESCRIPTOR  * _source)
  {
  if (_source->Owner !=0)
    {
    MIDL_user_free((void  *)(_source->Owner));
    }
  if (_source->Group !=0)
    {
    MIDL_user_free((void  *)(_source->Group));
    }
  if (_source->Sacl !=0)
    {
    MIDL_user_free((void  *)(_source->Sacl));
    }
  if (_source->Dacl !=0)
    {
    MIDL_user_free((void  *)(_source->Dacl));
    }
  }

  /* routine that frees graph for struct _LSAPR_SR_SECURITY_DESCRIPTOR */
void _fgs__LSAPR_SR_SECURITY_DESCRIPTOR (LSAPR_SR_SECURITY_DESCRIPTOR  * _source)
  {
  if (_source->SecurityDescriptor !=0)
    {
    MIDL_user_free((void  *)(_source->SecurityDescriptor));
    }
  }

  /* routine that frees graph for struct _LSAPR_POLICY_PRIVILEGE_DEF */
void _fgs__LSAPR_POLICY_PRIVILEGE_DEF (LSAPR_POLICY_PRIVILEGE_DEF  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  }

  /* routine that frees graph for struct _LSAPR_PRIVILEGE_ENUM_BUFFER */
void _fgs__LSAPR_PRIVILEGE_ENUM_BUFFER (LSAPR_PRIVILEGE_ENUM_BUFFER  * _source)
  {
  if (_source->Privileges !=0)
    {
      {
      unsigned long _sym25;
      for (_sym25 = 0; _sym25 < (unsigned long )(0 + _source->Entries); _sym25++)
        {
        _fgs__LSAPR_POLICY_PRIVILEGE_DEF ((LSAPR_POLICY_PRIVILEGE_DEF *)&_source->Privileges[_sym25]);
        }
      }
    MIDL_user_free((void  *)(_source->Privileges));
    }
  }

  /* routine that frees graph for struct _LSAPR_OBJECT_ATTRIBUTES */
void _fgs__LSAPR_OBJECT_ATTRIBUTES (LSAPR_OBJECT_ATTRIBUTES  * _source)
  {
  if (_source->RootDirectory !=0)
    {
    MIDL_user_free((void  *)(_source->RootDirectory));
    }
  if (_source->ObjectName !=0)
    {
    _fgs__STRING ((STRING *)_source->ObjectName);
    MIDL_user_free((void  *)(_source->ObjectName));
    }
  if (_source->SecurityDescriptor !=0)
    {
    _fgs__LSAPR_SECURITY_DESCRIPTOR ((LSAPR_SECURITY_DESCRIPTOR *)_source->SecurityDescriptor);
    MIDL_user_free((void  *)(_source->SecurityDescriptor));
    }
  if (_source->SecurityQualityOfService !=0)
    {
    MIDL_user_free((void  *)(_source->SecurityQualityOfService));
    }
  }

  /* routine that frees graph for struct _LSAPR_CR_CIPHER_VALUE */
void _fgs__LSAPR_CR_CIPHER_VALUE (LSAPR_CR_CIPHER_VALUE  * _source)
  {
  if (_source->Buffer !=0)
    {
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

  /* routine that frees graph for struct _LSAPR_TRUST_INFORMATION */
void _fgs__LSAPR_TRUST_INFORMATION (LSAPR_TRUST_INFORMATION  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  if (_source->Sid !=0)
    {
    MIDL_user_free((void  *)(_source->Sid));
    }
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_ENUM_BUFFER */
void _fgs__LSAPR_TRUSTED_ENUM_BUFFER (LSAPR_TRUSTED_ENUM_BUFFER  * _source)
  {
  if (_source->Information !=0)
    {
      {
      unsigned long _sym31;
      for (_sym31 = 0; _sym31 < (unsigned long )(0 + _source->EntriesRead); _sym31++)
        {
        _fgs__LSAPR_TRUST_INFORMATION ((LSAPR_TRUST_INFORMATION *)&_source->Information[_sym31]);
        }
      }
    MIDL_user_free((void  *)(_source->Information));
    }
  }


  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_EX */
void _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX (LSAPR_TRUSTED_DOMAIN_INFORMATION_EX  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->FlatName);
  MIDL_user_free(_source->Sid);
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_ENUM_BUFFER_EX */
void _fgs__LSAPR_TRUSTED_ENUM_BUFFER_EX (LSAPR_TRUSTED_ENUM_BUFFER_EX  * _source)
  {
  if (_source->EnumerationBuffer !=0)
    {
      {
      unsigned long _sym31;
      for (_sym31 = 0; _sym31 < (unsigned long )(0 + _source->EntriesRead); _sym31++)
        {
        _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX (&_source->EnumerationBuffer[_sym31]);
        }
      }
    MIDL_user_free((void  *)(_source->EnumerationBuffer));
    }
  }

  /* routine that frees graph for struct _LSAPR_REFERENCED_DOMAIN_LIST */
void _fgs__LSAPR_REFERENCED_DOMAIN_LIST (LSAPR_REFERENCED_DOMAIN_LIST  * _source)
  {
  if (_source->Domains !=0)
    {
      {
      unsigned long _sym37;
      for (_sym37 = 0; _sym37 < (unsigned long )(0 + _source->Entries); _sym37++)
        {
        _fgs__LSAPR_TRUST_INFORMATION ((LSAPR_TRUST_INFORMATION *)&_source->Domains[_sym37]);
        }
      }
    MIDL_user_free((void  *)(_source->Domains));
    }
  }

  /* routine that frees graph for struct _LSAPR_TRANSLATED_SIDS */
void _fgs__LSAPR_TRANSLATED_SIDS (LSAPR_TRANSLATED_SIDS  * _source)
  {
  if (_source->Sids !=0)
    {
    MIDL_user_free((void  *)(_source->Sids));
    }
  }

  /* routine that frees graph for struct _LSAPR_TRANSLATED_NAME */
void _fgs__LSAPR_TRANSLATED_NAME (LSAPR_TRANSLATED_NAME  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  }

  /* routine that frees graph for struct _LSAPR_TRANSLATED_NAMES */
void _fgs__LSAPR_TRANSLATED_NAMES (LSAPR_TRANSLATED_NAMES  * _source)
  {
  if (_source->Names !=0)
    {
      {
      unsigned long _sym58;
      for (_sym58 = 0; _sym58 < (unsigned long )(0 + _source->Entries); _sym58++)
        {
        _fgs__LSAPR_TRANSLATED_NAME ((LSAPR_TRANSLATED_NAME *)&_source->Names[_sym58]);
        }
      }
    MIDL_user_free((void  *)(_source->Names));
    }
  }

  /* routine that frees graph for struct _LSAPR_POLICY_ACCOUNT_DOM_INFO */
void _fgs__LSAPR_POLICY_ACCOUNT_DOM_INFO (LSAPR_POLICY_ACCOUNT_DOM_INFO  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->DomainName);
  if (_source->DomainSid !=0)
    {
    MIDL_user_free((void  *)(_source->DomainSid));
    }
  }

  /* routine that frees graph for struct _LSAPR_POLICY_PRIMARY_DOM_INFO */
void _fgs__LSAPR_POLICY_PRIMARY_DOM_INFO (LSAPR_POLICY_PRIMARY_DOM_INFO  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  if (_source->Sid !=0)
    {
    MIDL_user_free((void  *)(_source->Sid));
    }
  }

  /* routine that frees graph for struct _LSAPR_POLICY_DNS_DOMAIN_INFO */
void _fgs__LSAPR_POLICY_DNS_DOMAIN_INFO (LSAPR_POLICY_DNS_DOMAIN_INFO  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->DnsDomainName);
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->DnsForestName);
  if (_source->Sid !=0)
    {
    MIDL_user_free((void  *)(_source->Sid));
    }
  }

  /* routine that frees graph for struct _LSAPR_POLICY_PD_ACCOUNT_INFO */
void _fgs__LSAPR_POLICY_PD_ACCOUNT_INFO (LSAPR_POLICY_PD_ACCOUNT_INFO  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  }

  /* routine that frees graph for struct _LSAPR_POLICY_REPLICA_SRCE_INFO */
void _fgs__LSAPR_POLICY_REPLICA_SRCE_INFO (LSAPR_POLICY_REPLICA_SRCE_INFO  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->ReplicaSource);
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->ReplicaAccountName);
  }

  /* routine that frees graph for struct _LSAPR_POLICY_AUDIT_EVENTS_INFO */
void _fgs__LSAPR_POLICY_AUDIT_EVENTS_INFO (LSAPR_POLICY_AUDIT_EVENTS_INFO  * _source)
  {
  if (_source->EventAuditingOptions !=0)
    {
    MIDL_user_free((void  *)(_source->EventAuditingOptions));
    }
  }

  /* routine that frees graph for union _LSAPR_POLICY_INFORMATION */
void _fgu__LSAPR_POLICY_INFORMATION (LSAPR_POLICY_INFORMATION  * _source, POLICY_INFORMATION_CLASS _branch)
  {
  switch (_branch)
    {
    case PolicyAuditLogInformation :
      {
      break;
      }
    case PolicyAuditEventsInformation :
      {
      _fgs__LSAPR_POLICY_AUDIT_EVENTS_INFO ((LSAPR_POLICY_AUDIT_EVENTS_INFO *)&_source->PolicyAuditEventsInfo);
      break;
      }
    case PolicyPrimaryDomainInformation :
      {
      _fgs__LSAPR_POLICY_PRIMARY_DOM_INFO ((LSAPR_POLICY_PRIMARY_DOM_INFO *)&_source->PolicyPrimaryDomainInfo);
      break;
      }
    case PolicyAccountDomainInformation :
      {
      _fgs__LSAPR_POLICY_ACCOUNT_DOM_INFO ((LSAPR_POLICY_ACCOUNT_DOM_INFO *)&_source->PolicyAccountDomainInfo);
      break;
      }
    case PolicyPdAccountInformation :
      {
      _fgs__LSAPR_POLICY_PD_ACCOUNT_INFO ((LSAPR_POLICY_PD_ACCOUNT_INFO *)&_source->PolicyPdAccountInfo);
      break;
      }
    case PolicyLsaServerRoleInformation :
      {
      break;
      }
    case PolicyReplicaSourceInformation :
      {
      _fgs__LSAPR_POLICY_REPLICA_SRCE_INFO ((LSAPR_POLICY_REPLICA_SRCE_INFO *)&_source->PolicyReplicaSourceInfo);
      break;
      }
    case PolicyDefaultQuotaInformation :
      {
      break;
      }
    case PolicyModificationInformation :
      {
      break;
      }
    case PolicyAuditFullSetInformation :
      {
      break;
      }
    case PolicyAuditFullQueryInformation :
      {
      break;
      }
    case PolicyDnsDomainInformation :
      {
      _fgs__LSAPR_POLICY_DNS_DOMAIN_INFO ((LSAPR_POLICY_DNS_DOMAIN_INFO *)&_source->PolicyDnsDomainInfo);
      break;
      }
    }
  }

  /* routine that frees graph for struct _LSAPR_POLICY_DOMAIN_EFS_INFO */
void _fgs__LSAPR_POLICY_EFS_INFORMATION(PLSAPR_POLICY_DOMAIN_EFS_INFO EfsInfo)
{
    if( EfsInfo->EfsBlob != NULL )
    {
        MIDL_user_free( EfsInfo->EfsBlob );
    }
}

  /* routine that frees graph for union _LSAPR_POLICY_DOMAIN_INFORMATION */
void _fgu__LSAPR_POLICY_DOMAIN_INFORMATION (LSAPR_POLICY_DOMAIN_INFORMATION  * _source,
                                            POLICY_DOMAIN_INFORMATION_CLASS _branch)
{
    switch (_branch)
    {
    case PolicyDomainEfsInformation:

        _fgs__LSAPR_POLICY_EFS_INFORMATION( &( _source->PolicyDomainEfsInfo ) );
        break;

    case PolicyDomainKerberosTicketInformation:

        break;

    }
  }


  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_NAME_INFO */
void _fgs__LSAPR_TRUSTED_DOMAIN_NAME_INFO (LSAPR_TRUSTED_DOMAIN_NAME_INFO  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_CONTROLLERS_INFO */
void _fgs__LSAPR_TRUSTED_CONTROLLERS_INFO (LSAPR_TRUSTED_CONTROLLERS_INFO  * _source)
  {
  if (_source->Names !=0)
    {
      {
      unsigned long _sym69;
      for (_sym69 = 0; _sym69 < (unsigned long )(0 + _source->Entries); _sym69++)
        {
        _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Names[_sym69]);
        }
      }
    MIDL_user_free((void  *)(_source->Names));
    }
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC */
void _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC (LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  MIDL_user_free(_source->Sid);
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION */
void _fgs__LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION (LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION  * _source)
{

    ULONG Index;
    if (_source->IncomingAuthenticationInformation != NULL) {
        for (Index = 0; Index < _source->IncomingAuthInfos ; Index++ ) {
            if (_source->IncomingAuthenticationInformation[Index].AuthInfo != NULL) {
                MIDL_user_free(_source->IncomingAuthenticationInformation[Index].AuthInfo);
            }
        }
        MIDL_user_free (_source->IncomingAuthenticationInformation );
    }
    if (_source->IncomingPreviousAuthenticationInformation != NULL) {
        for (Index = 0; Index < _source->IncomingAuthInfos ; Index++ ) {
            if (_source->IncomingPreviousAuthenticationInformation[Index].AuthInfo != NULL) {
                MIDL_user_free(_source->IncomingPreviousAuthenticationInformation[Index].AuthInfo);
            }
          }
          MIDL_user_free (_source->IncomingPreviousAuthenticationInformation );
      }
    if (_source->OutgoingAuthenticationInformation != NULL) {
        for (Index = 0; Index < _source->OutgoingAuthInfos ; Index++ ) {
            if (_source->OutgoingAuthenticationInformation[Index].AuthInfo != NULL) {
                MIDL_user_free(_source->OutgoingAuthenticationInformation[Index].AuthInfo);
            }
        }
        MIDL_user_free (_source->OutgoingAuthenticationInformation );
    }
    if (_source->OutgoingPreviousAuthenticationInformation != NULL) {
        for (Index = 0; Index < _source->OutgoingAuthInfos ; Index++ ) {
            if (_source->OutgoingPreviousAuthenticationInformation[Index].AuthInfo != NULL) {
                MIDL_user_free(_source->OutgoingPreviousAuthenticationInformation[Index].AuthInfo);
            }
          }
          MIDL_user_free (_source->OutgoingPreviousAuthenticationInformation );
      }
}

  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION */
void _fgs__LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION (LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION  * _source)
  {
  _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX( &_source->Information );
  _fgs__LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION( &_source->AuthInformation );
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 */
void _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 (LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->FlatName);
  MIDL_user_free(_source->Sid);
  MIDL_user_free(_source->ForestTrustInfo);
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 */
void _fgs__LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 (LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2  * _source)
  {
  _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2( &_source->Information );
  _fgs__LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION( &_source->AuthInformation );
  }

  /* routine that frees graph for union _LSAPR_TRUSTED_DOMAIN_INFO */
void _fgu__LSAPR_TRUSTED_DOMAIN_INFO (LSAPR_TRUSTED_DOMAIN_INFO  * _source, TRUSTED_INFORMATION_CLASS _branch)
  {
  switch (_branch)
    {
    case TrustedDomainNameInformation :
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_NAME_INFO ((LSAPR_TRUSTED_DOMAIN_NAME_INFO *)&_source->TrustedDomainNameInfo);
      break;
      }
    case TrustedControllersInformation :
      {
      _fgs__LSAPR_TRUSTED_CONTROLLERS_INFO ((LSAPR_TRUSTED_CONTROLLERS_INFO *)&_source->TrustedControllersInfo);
      break;
      }
    case TrustedPosixOffsetInformation :
      {
      break;
      }
   case TrustedPasswordInformation:
      {
      break;
      }
    case TrustedDomainInformationBasic:
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC ((LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC *)&_source->TrustedDomainInfoBasic);
      break;
      }
    case TrustedDomainInformationEx:
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX ((LSAPR_TRUSTED_DOMAIN_INFORMATION_EX *)&_source->TrustedDomainInfoEx);
      break;
      }
    case TrustedDomainAuthInformation:
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION ((LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION *)&_source->TrustedAuthInfo);
      break;
      }
    case TrustedDomainFullInformation:
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION ((LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION *)&_source->TrustedFullInfo);
      break;
      }
    case TrustedDomainInformationEx2Internal:
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 ((LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 *)&_source->TrustedDomainInfoEx2);
      break;
      }
    case TrustedDomainFullInformation2Internal:
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 ((LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 *)&_source->TrustedFullInfo2);
      break;
      }
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\rpcinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rpcinit.c

Abstract:

    LSA - RPC Server Initialization

Author:

    Scott Birrell       (ScottBi)      April 29, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include <efsrpc.h>

#include "adtgenp.h"

PVOID LsapRegisterTcpIpTask = NULL;

NTSTATUS
LsapRegisterTcpIp(
    PVOID pVoid
    )
/*++

Routine Description:

    This routine registers the LSA interface over any protocols that have
    been registered so far.  This routine is designed to be called on a
    domain controller after the DS has started since it already waits
    for the conditions necessary to register its RPC interface over TCP/IP.
    

    N.B. Should the DS ever not register of TCP/IP this mechanism will
    need to be updated.
    
    N.B. This routine is called from the thread pool call back mechanism.
    
Arguments:

    pVoid -- ignored.

Return Value:

    STATUS_SUCCESS

--*/
{
    ULONG RpcStatus = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    RPC_BINDING_VECTOR *BindingVector;

    //
    // Register LSA's interface over the new interfaces
    //
    RpcStatus = RpcServerInqBindings(&BindingVector);
    if (RpcStatus == 0) {

        RpcStatus = RpcEpRegister(
                        lsarpc_ServerIfHandle,
                        BindingVector,
                        NULL,                   // no uuid vector
                        L""  // no annotation
                        );

        RpcBindingVectorFree(&BindingVector);
    }

    if (RpcStatus != 0) {

        SpmpReportEvent( TRUE,
                         EVENTLOG_WARNING_TYPE,
                         LSAEVENT_LOOKUP_TCPIP_NOT_INSTALLED,
                         0,
                         sizeof( ULONG ),
                         &RpcStatus,
                         0);
    }

    //
    // Deregister ourselves
    //
    ASSERT(NULL != LsapRegisterTcpIpTask);
    Status = LsaICancelNotification(LsapRegisterTcpIpTask);
    ASSERT(NT_SUCCESS(Status));
    LsapRegisterTcpIpTask = NULL;

    //
    // Close the handle
    //
    ASSERT(pVoid != NULL);
    CloseHandle((HANDLE)pVoid);

    return STATUS_SUCCESS;

}

NTSTATUS
LsapRPCInit(
    )

/*++

Routine Description:

    This function performs the initialization of the RPC server in the LSA
    subsystem.  Clients such as the Local Security Manager on this or some
    other machine will then be able to call the LSA API that use RPC .

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code.

        All Result Code returned are from called routines.

Environment:

     User Mode
--*/

{
    NTSTATUS         NtStatus;
    NTSTATUS         TmpStatus;
    LPWSTR           ServiceName;


    //
    // Publish the Lsa server interface package...
    //
    //
    // NOTE:  Now all RPC servers in lsass.exe (now winlogon) share the same
    // pipe name.  However, in order to support communication with
    // version 1.0 of WinNt,  it is necessary for the Client Pipe name
    // to remain the same as it was in version 1.0.  Mapping to the new
    // name is performed in the Named Pipe File System code.
    //
    //

    ServiceName = L"lsass";
    NtStatus = RpcpAddInterface( ServiceName, lsarpc_ServerIfHandle);

    if (!NT_SUCCESS(NtStatus)) {

        LsapLogError(
            "LSASS:  Could Not Start RPC Server.\n"
            "        Failing to initialize LSA Server.\n",
            NtStatus
            );
    }

    TmpStatus = RpcpAddInterface( ServiceName, efsrpc_ServerIfHandle);
    if (!NT_SUCCESS(TmpStatus)) {

        LsapLogError(
            "LSASS:  Could Not Start RPC Server.\n"
            "        Failing to initialize LSA Server.\n",
            TmpStatus
            );
    }

    //
    // Register for authenticated RPC for name and sid lookups
    //

#ifndef RPC_C_AUTHN_NETLOGON
#define RPC_C_AUTHN_NETLOGON 0x44
#endif // RPC_C_AUTHN_NETLOGON

    TmpStatus = I_RpcMapWin32Status(RpcServerRegisterAuthInfo(
                    NULL,                       // no principal name
                    RPC_C_AUTHN_NETLOGON,
                    NULL,                       // no get key fn
                    NULL                        // no get key argument
                    ));
    if (!NT_SUCCESS(TmpStatus))
    {
        DebugLog((DEB_ERROR,"Failed to register NETLOGON auth info: 0x%x\n",TmpStatus));
    }

    //
    // If we are a DC, register our interface over TCP/IP for fast
    // lookups.  Note that this routine is called so early on in startup
    // the the TCP/IP interface is not ready yet.  We must wait until
    // it is ready.  The DS currently waits on the necessary conditions, so
    // simply wait until the DS is ready to register our interface over
    // TCP/IP.
    //
    {
        NT_PRODUCT_TYPE Product;
        if (   RtlGetNtProductType( &Product ) 
           && (Product == NtProductLanManNt) ) {

            HANDLE hDsStartup;

            hDsStartup = CreateEvent(NULL, 
                                     TRUE,  
                                     FALSE,
                                     NTDS_DELAYED_STARTUP_COMPLETED_EVENT);

            if (hDsStartup) {
                
                LsapRegisterTcpIpTask = LsaIRegisterNotification(
                                         LsapRegisterTcpIp,
                                         (PVOID) hDsStartup,
                                         NOTIFIER_TYPE_HANDLE_WAIT,
                                         0, // no class,
                                         0,
                                         0,
                                         hDsStartup);
            }
        } 
    }
    
    {
        RPC_STATUS RpcStatus;

        //
        // enable lsa rpc server to listen on LRPC transport on endpoint 'audit'
        // this endpoint is used by auditing clients
        //

        RpcStatus = RpcServerUseProtseqEp(
                        L"ncalrpc",
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT , // max concurrent calls
                        L"audit",                        // end point
                        NULL                             // security descriptor
                        );

        if ( RpcStatus != RPC_S_OK )
        {
            DebugLog((DEB_ERROR, "RpcServerUseProtseqEp failed for ncalrpc: %d\n",
                      RpcStatus));
            NtStatus = I_RpcMapWin32Status( RpcStatus );
        }
    }
    
    {
        RPC_STATUS RpcStatus;

        //
        // Enable lsa rpc server to listen on LRPC transport on endpoint 'securityevent'.
        // This endpoint is used by auditing clients.
        //

        RpcStatus = RpcServerUseProtseqEp(
                        L"ncalrpc",
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,  // max concurrent calls
                        L"securityevent",                // end point
                        NULL                             // security descriptor
                        );

        if ( RpcStatus != RPC_S_OK )
        {
            DebugLog((DEB_ERROR, "RpcServerUseProtseqEp failed for ncalrpc: %d\n",
                      RpcStatus));
            NtStatus = I_RpcMapWin32Status( RpcStatus );
        }
    }

    return(NtStatus);
}

VOID LSAPR_HANDLE_rundown(
    LSAPR_HANDLE LsaHandle
    )

/*++

Routine Description:

    This routine is called by the server RPC runtime to run down a
    Context Handle.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status;

    //
    // Close and free the handle.  Since the container handle reference
    // count includes one reference for every reference made to the
    // target handle, the container's reference count will be decremented
    // by n where n is the reference count in the target handle.
    //

    Status = LsapDbCloseObject(
                 &LsaHandle,
                 LSAP_DB_DEREFERENCE_CONTR |
                    LSAP_DB_VALIDATE_HANDLE |
                    LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES,
                 STATUS_SUCCESS
                 );

}


VOID PLSA_ENUMERATION_HANDLE_rundown(
    PLSA_ENUMERATION_HANDLE LsaHandle
    )

/*++

Routine Description:

    This routine is called by the server RPC runtime to run down a
    Context Handle.

Arguments:

    None.

Return Value:

--*/

{
    DBG_UNREFERENCED_PARAMETER(LsaHandle);

    return;
}

VOID AUDIT_HANDLE_rundown(
    AUDIT_HANDLE hAudit
    )

/*++

Routine Description:

    This routine is called by the server RPC runtime to run down a
    Context Handle.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = LsapUnregisterAuditEvent( &hAudit );
    
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"AUDIT_HANDLE_rundown: LsapUnregisterAuditEvent: 0x%x\n", Status));
    }
}


VOID SECURITY_SOURCE_HANDLE_rundown(
    SECURITY_SOURCE_HANDLE hSecuritySource
    )

/*++

Routine Description:

    This routine is called by the server RPC runtime to run down a
    Context Handle.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

#if DEBUG_AUTHZ
    DbgPrint("Rundown Source 0x%x\n", hSecuritySource);
#endif

    Status = LsapAdtRundownSecurityEventSource( 0, 0, &hSecuritySource );
    
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"SECURITY_SOURCE_HANDLE_rundown: LsapUnregisterSecurityEventSource: 0x%x\n", Status));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\wsautils.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    wsautils.h

Abstract:

    IPv6 related functions

Author:

    kumarp 18-July-2002 created


Revision History:

--*/

#ifndef _WSAUTILS_H
#define _WSAUTILS_H


//
// taken from /nt/net/sockets/winsock2/wsp/afdsys/kdext/tdiutil.c
//

INT
MyIp6AddressToString (
    PIN6_ADDR Addr,
    PWCHAR     S,
    INT       L
    );


#endif _WSAUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dsdll\makefile.inc ===
..\credmgr.cxx: ..\..\netclient\credapi.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\sepriv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sepriv.c

Abstract:

    Security Runtime Library Privilege Routines

    (Temporary copy of \nt\private\ntos\rtl\sepriv.c to allow
     ntdailybld version of ntdll.dll to be used)

    These routines perform operations with privilege sets

Author:

    Scott Birrell       (ScottBi)       June 17, 1991

Environment:

Revision History:
    Pete Skelly         (petesk)        Modified LsapRtlAddPrivileges to work within a preallocated
                                        buffer for performance reasons

--*/
#include <lsapch2.h>
#include <string.h>

#define LsapRtlEqualPrivileges(FirstPrivilege, SecondPrivilege)                 \
    (RtlEqualLuid(&(FirstPrivilege)->Luid, &(SecondPrivilege)->Luid))

#define PRIVILEGE_SET_STEP_SIZE 20


NTSTATUS
LsapRtlAddPrivileges(
    IN OUT PPRIVILEGE_SET * RunningPrivileges,
    IN OUT PULONG           MaxRunningPrivileges,
    IN PPRIVILEGE_SET       PrivilegesToAdd,
    IN ULONG                Options,
    OUT OPTIONAL BOOLEAN *  Changed
    )

/*++

Routine Description:

    This function adds and/or updates privileges in a privilege set.  The
    existing privilege set is unaltered, a new privilege set being generated.
    Existing privileges and Udpate privilege sets may point to the same location.
    The memory for the new privilege set must already be allocated by the
    caller.  To assist in calculating the size of buffer required, the
    routine may be called in 'query' mode by supplying buffer size of 0.  In
    this mode, the amount of memory required is returned and no copying
    takes place.

    WARNING:  Privileges within each privilege set must all be distinct, that
    is, there must not be two privileges in the same set having the same LUID.

Arguments:

    RunningPrivileges - Pointer to a pointer pointing to a running privilege set.

    MaxRunningPrivileges - maximum number of privileges that can be copied into the current privilege set
                           before it must be grown.

    PrivilegesToAdd - Pointer to privilege set specifying privileges to
        be added.  The attributes of privileges in this set that also exist
        in the ExistingPrivileges set supersede the attributes therein.

    Options - Specifies optional actions.

        RTL_COMBINE_PRIVILEGE_ATTRIBUTES - If the two privilege sets have
            privileges in common, combine the attributes

        RTL_SUPERSEDE_PRIVILEGE_ATTRIBUTES - If the two privilege sets
            have privileges in common, supersede the existing attributes
            with those specified in PrivilegesToAdd.

    Changed - Used to indicate whether any change has been made

Return Value:

    NTSTATUS - Standard Nt Result Code

    STATUS_INVALID_PARAMETER

    STATUS_INSUFFICIENT_RESOURCES

Environment:

    User or Kernel modes.

--*/

{
    PLUID_AND_ATTRIBUTES Privilege;
    ULONG AddIndex = 0L;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CurrentPrivilegeCount = 0;
    DWORD OldPrivilegeSetSize = 0;

    //
    // Verify that mandatory parameters have been specified.
    // specified.
    //

    if (RunningPrivileges == NULL ||
        MaxRunningPrivileges == NULL) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Validate the Options parameter.
    //

    if ((Options != RTL_SUPERSEDE_PRIVILEGE_ATTRIBUTES) &&
        (Options != RTL_COMBINE_PRIVILEGE_ATTRIBUTES)) {

        return STATUS_INVALID_PARAMETER;
    }

    if ( Changed ) {

        *Changed = FALSE;
    }

    if((PrivilegesToAdd == NULL) || (PrivilegesToAdd->PrivilegeCount == 0))
    {
        return STATUS_SUCCESS;
    }

    if(*RunningPrivileges == NULL)
    {
        PPRIVILEGE_SET UpdatedPrivileges = NULL;

        ASSERT(PrivilegesToAdd->PrivilegeCount > 0);

        OldPrivilegeSetSize = sizeof (PRIVILEGE_SET) + sizeof(LUID_AND_ATTRIBUTES)*
                                                       (PrivilegesToAdd->PrivilegeCount - ANYSIZE_ARRAY);


        // We need to grow our privilege set
        UpdatedPrivileges = (PPRIVILEGE_SET)MIDL_user_allocate(  OldPrivilegeSetSize + 
                                                                sizeof(LUID_AND_ATTRIBUTES)* PRIVILEGE_SET_STEP_SIZE);

        if (UpdatedPrivileges == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(UpdatedPrivileges, PrivilegesToAdd,  OldPrivilegeSetSize);
        *RunningPrivileges = UpdatedPrivileges;
        *MaxRunningPrivileges = PrivilegesToAdd->PrivilegeCount + PRIVILEGE_SET_STEP_SIZE;

        if ( Changed ) {

            *Changed = TRUE;
        }

        return STATUS_SUCCESS;
    }

    CurrentPrivilegeCount = (*RunningPrivileges)->PrivilegeCount;

    //
    // For each privilege to add, see if it's in the running privilege list,
    // set the attributes if it is, append it if it isn't.
    //

    //
    // Note, we dont' modify the count of RunningPrivileges until the end, so we don't 
    // inefficiently search things we are currently adding (there should be no duplicates in what
    // we're currently adding);
    //

    for(AddIndex = 0;
        AddIndex < PrivilegesToAdd->PrivilegeCount;
        AddIndex++) {

            Privilege = NULL;

            if ((Privilege = LsapRtlGetPrivilege(
                                 &PrivilegesToAdd->Privilege[AddIndex],
                                 *RunningPrivileges
                                 )) != NULL) {

                if( Options & RTL_SUPERSEDE_PRIVILEGE_ATTRIBUTES &&
                    Privilege->Attributes != PrivilegesToAdd->Privilege[AddIndex].Attributes ) {

                    if ( Changed ) {

                        *Changed = TRUE;
                    }

                    Privilege->Attributes = PrivilegesToAdd->Privilege[AddIndex].Attributes;
                }
            }
            else
            {
                // This is a new privilege, so add it to the end

                ASSERT(*MaxRunningPrivileges >= CurrentPrivilegeCount);
                if((CurrentPrivilegeCount+1) > *MaxRunningPrivileges)
                {

                    // We need to grow our privilege set
                    PPRIVILEGE_SET UpdatedPrivileges = (PPRIVILEGE_SET)MIDL_user_allocate( sizeof (PRIVILEGE_SET) + 
                                                                           sizeof(LUID_AND_ATTRIBUTES)*
                                                                                  (*MaxRunningPrivileges + 
                                                                                   PRIVILEGE_SET_STEP_SIZE - 1));

                    if (UpdatedPrivileges == NULL) {

                        return STATUS_INSUFFICIENT_RESOURCES;
                    }
                    if(*MaxRunningPrivileges > 0)
                    {
                        RtlCopyMemory(UpdatedPrivileges, *RunningPrivileges, sizeof (PRIVILEGE_SET) + 
                                                                           sizeof(LUID_AND_ATTRIBUTES)*
                                                                                  (*MaxRunningPrivileges - 1));
                    }
                    else
                    {
                        RtlCopyMemory(UpdatedPrivileges, *RunningPrivileges, sizeof (PRIVILEGE_SET));
                    }
                    MIDL_user_free(*RunningPrivileges);
                    *RunningPrivileges = UpdatedPrivileges;
                    *MaxRunningPrivileges += PRIVILEGE_SET_STEP_SIZE;
                }

                (*RunningPrivileges)->Privilege[CurrentPrivilegeCount++] = PrivilegesToAdd->Privilege[AddIndex];

                if ( Changed ) {

                    *Changed = TRUE;
                }
            }
    }

    (*RunningPrivileges)->PrivilegeCount = CurrentPrivilegeCount;

    return Status;
}



NTSTATUS
LsapRtlRemovePrivileges(
    IN OUT PPRIVILEGE_SET ExistingPrivileges,
    IN PPRIVILEGE_SET PrivilegesToRemove
    )

/*++

Routine Description:

    This function removes privileges in a privilege set.  The existing
    privilege set is unaltered, a new privilege set being generated.

    WARNING:  Privileges within each privilege set must all be distinct, that
    is, there must not be two privileges in the same set having the same LUID.

Arguments:

    ExistingPrivileges - Pointer to existing privilege set

    PrivilegesToRemove - Pointer to privilege set specifying privileges to
        be removed.  The privilege attributes are ignored.  Privileges
        in the PrivilegesToRemove set that are not present in the
        ExistingPrivileges set will be ignored.

    UpdatedPrivileges - Pointer to buffer that will receive the updated
        privilege set.  Care must be taken to ensure that UpdatedPrivileges
        occupies memory disjoint from that occupied by ExistingPrivileges
        and PrivilegesToChange.

    UpdatedPrivilegesSize - Pointer to variable that contains a size.
        On input, the size is the size of the UpdatedPrivileges buffer
        (if any).  On output, the size is the size needed/used for the
        updated privilege set.  If the updated privilege set will be
        NULL, 0 is returned.

Return Value:

    NTSTATUS - Standard Nt Result Code

        - STATUS_INVALID_PARAMETER - Invalid parameter(s)
              Mandatory parameters not specified
              UpdatedPrivileges buffer not specified (except on
              query-only calls

        - STATUS_INSUFFICIENT_RESOURCES - Ran out of memory

Environment:

    User or Kernel modes.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ExistingIndex = 0;
    ULONG ExistingNew = 0;
    ULONG RemoveIndex;

    //
    // Verify that mandatory parameters have been specified.
    //

    if (ExistingPrivileges == NULL ||
        PrivilegesToRemove == NULL) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Scan through the privileges in the existing privilege set.  Look up
    // each privilege in the list of privileges to be removed.  If the
    // privilege is not found there, it is to be retained, so copy it
    // to the output buffer/count it.
    //

    for (ExistingIndex = 0, ExistingNew = 0;
        ExistingIndex < ExistingPrivileges->PrivilegeCount;
        ExistingIndex++) 
    {

        //
        // If the next privilege is not in the set to be deleted,
        // copy it to output/count it
        //

        for(RemoveIndex = 0; RemoveIndex < PrivilegesToRemove->PrivilegeCount; RemoveIndex++)
        {
            if(LsapRtlEqualPrivileges(
                &(ExistingPrivileges->Privilege[ExistingIndex]),
                &(PrivilegesToRemove->Privilege[RemoveIndex])))
            {
                break;
            }
        }
        if(RemoveIndex == PrivilegesToRemove->PrivilegeCount)
        {
            // We don't need to remove this one, so move it if necessary
            if(ExistingIndex != ExistingNew)
            {
                ExistingPrivileges->Privilege[ExistingNew] = ExistingPrivileges->Privilege[ExistingIndex];
            }
            ExistingNew++;
        }
    }

    ExistingPrivileges->PrivilegeCount = ExistingNew;
    
    return Status;
}


PLUID_AND_ATTRIBUTES
LsapRtlGetPrivilege(
    IN PLUID_AND_ATTRIBUTES Privilege,
    IN PPRIVILEGE_SET Privileges
    )

/*++

Routine Description:

WARNING: THIS ROUTINE IS NOT YET AVAILABLE

    This function locates a privilege in a privilege set.  If found,
    a pointer to the privilege wihtin the set is returned, otherwise NULL
    is returned.

Arguments:

    Privilege - Pointer to the privilege to be looked up.

    Privileges - Pointer to the privilege set to be scanned.

Return Value:

    PLUID_AND_ATTRIBUTES - If the privilege is found, a pointer to its
        LUID and ATTRIBUTES structure within the privilege set is returned,
        otherwise NULL is returned.

Environment:

    User or Kernel modes.

--*/

{
    ULONG PrivilegeIndex;

    for (PrivilegeIndex = 0;
         PrivilegeIndex < Privileges->PrivilegeCount;
         PrivilegeIndex++) {

        if (LsapRtlEqualPrivileges(
                Privilege,
                &(Privileges->Privilege[PrivilegeIndex])
                )) {

            return &(Privileges->Privilege[PrivilegeIndex]);
        }
    }

    //
    // The privilege was no found.  Return NULL
    //

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\sidcache.c ===
//+-----------------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        sidcache.c
//
// Contents:    code for cache for sid/name translation, lookup
//
//
// History:     17-May-1994     MikeSw      Created
//
//------------------------------------------------------------------------------

#include <lsapch2.h>
#include <sidcache.h>

#include <ntdsapi.h>

//
// Global data
//

//
// This is the head of the linked list that implements the sid cache
//
PLSAP_DB_SID_CACHE_ENTRY LsapSidCache = NULL;

//
// This lock gaurds access to the linked list
//
RTL_CRITICAL_SECTION LsapSidCacheLock;

//
// This is the number of elements current in LsapSidCache.
//
ULONG LsapSidCacheCount = 0;


//
// The amount of time an entry can be used before it needs to be refreshed.
//

// This is interpreted as minutes in the registry
#define LSAP_LOOKUP_CACHE_REFRESH_NAME  L"LsaLookupCacheRefreshTime"

// 10 minutes
#define LSAP_DEFAULT_REFRESH_TIME 10

LARGE_INTEGER LsapSidCacheRefreshTime;

//
// The amount of time an entry can be used before it is no longer valid.
//

// This is interpreted as minutes in the registry
#define LSAP_LOOKUP_CACHE_EXPIRY_NAME   L"LsaLookupCacheExpireTime"

// 7 days
#define LSAP_DEFAULT_EXPIRY_TIME (7 * 24 * 60)

LARGE_INTEGER LsapSidCacheExpiryTime;

//
// The maximum size of the cache.
//

#define LSAP_LOOKUP_CACHE_MAX_SIZE_NAME   L"LsaLookupCacheMaxSize"

#define LSAP_DEFAULT_MAX_CACHE_SIZE  128

ULONG LsapSidCacheMaxSize = LSAP_DEFAULT_MAX_CACHE_SIZE;


//
// Mutually exclusive flags to control the search semantics of 
// LdapDbFindSidCacheEntry*
//
typedef enum {

    LsapSidCacheSearchValidEntries = 1,
    LsapSidCacheSearchStaleEntries,
    LsapSidCacheSearchExpiredEntries

} LSAP_DB_SID_CACHE_SEARCH_TYPE, *PLSAP_DB_SID_CACHE_SEARCH_TYPE;


//
// Forward function declarations
//
PLSAP_DB_SID_CACHE_ENTRY
LsapDbFindSidCacheEntry(
    IN PSID Sid,
    IN LSAP_DB_SID_CACHE_SEARCH_TYPE SearchType
    );

BOOLEAN
LsapAccountIsFromLocalDatabase(
    IN PSID Sid
    );

VOID
LsapUpdateConfigSettings(
    VOID
    );

#define LockSidCache()     RtlEnterCriticalSection(&LsapSidCacheLock);

#define UnLockSidCache()   RtlLeaveCriticalSection(&LsapSidCacheLock);

#define SidUnmapped(TranslatedName) (((TranslatedName).Use == SidTypeUnknown))

#define NameUnmapped(TranslatedSid) (((TranslatedSid).Use == SidTypeUnknown))


#define LsapNamesMatch(x, y)                                        \
  ((CSTR_EQUAL == CompareString(DS_DEFAULT_LOCALE,                  \
                                DS_DEFAULT_LOCALE_COMPARE_FLAGS,    \
                                (x)->Buffer,                        \
                                (x)->Length/sizeof(WCHAR),          \
                                (y)->Buffer,                        \
                                (y)->Length/sizeof(WCHAR) )))

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbFreeCacheEntry
//
//  Synopsis:   Frees a cache entry structure
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapDbFreeCacheEntry(PLSAP_DB_SID_CACHE_ENTRY CacheEntry)
{
    if (CacheEntry->Sid != NULL)
    {
        LsapFreeLsaHeap(CacheEntry->Sid);
    }
    if (CacheEntry->DomainSid != NULL)
    {
        LsapFreeLsaHeap(CacheEntry->DomainSid);
    }
    if (CacheEntry->DomainName.Buffer != NULL)
    {
        MIDL_user_free(CacheEntry->DomainName.Buffer);
    }
    if (CacheEntry->AccountName.Buffer != NULL)
    {
        MIDL_user_free(CacheEntry->AccountName.Buffer);
    }
    LsapFreeLsaHeap(CacheEntry);
}



//+-------------------------------------------------------------------------
//
//  Function:   LsapDbPurgeOneSid
//
//  Synopsis:   removes the least-recently accessed sid from the cache
//
//  Effects:
//
//  Arguments:  None
//
//  Requires:
//
//  Returns:    sid cache be locked
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL
LsapDbPurgeOneSid()
{
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL;
    PLSAP_DB_SID_CACHE_ENTRY PrevEntry = NULL;
    PLSAP_DB_SID_CACHE_ENTRY OldestEntry = NULL;
    PLSAP_DB_SID_CACHE_ENTRY OldestPrevEntry = NULL;
    LARGE_INTEGER OldestTime;
    LARGE_INTEGER CurrentTime ;
    BOOL Retried = FALSE;

    //
    // Set the max time to the oldest time so if there are any entries
    // is is guaranteed to change.
    //

    OldestTime.QuadPart = 0x7fffffffffffffff;
    GetSystemTimeAsFileTime( (LPFILETIME) &CurrentTime );

RetryScan:
    for (CacheEntry = LsapSidCache, PrevEntry = NULL;
         CacheEntry != NULL;
         CacheEntry = CacheEntry->Next )
    {
        if ( CacheEntry->InUseCount == 0 &&
             ( CacheEntry->LastUse.QuadPart < OldestTime.QuadPart) &&
             ( CacheEntry->ExpirationTime.QuadPart < CurrentTime.QuadPart ) )
        {
            OldestTime = CacheEntry->LastUse;
            OldestEntry = CacheEntry;
            OldestPrevEntry = PrevEntry;
        }
        PrevEntry = CacheEntry;
    }

    if ( !Retried && !OldestEntry )
    {
        CurrentTime.QuadPart = 0x7FFFFFFFFFFFFFFF;
        Retried = TRUE;
        goto RetryScan ;
    }

    if (OldestEntry != NULL)
    {
        if (OldestPrevEntry != NULL)
        {
            OldestPrevEntry->Next = OldestEntry->Next;
        }
        else
        {
            ASSERT(LsapSidCache == OldestEntry);
            LsapSidCache = OldestEntry->Next;
        }
        LsapDbFreeCacheEntry(OldestEntry);
        LsapSidCacheCount--;
    }

    return (OldestEntry != NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbAddOneSidToCache
//
//  Synopsis:   Adds one sid to cache
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    sid cache be locked
//
//  Notes:
//
//
//--------------------------------------------------------------------------

//
// This operation flag means that the name is known not to exist
// in the cache.  That is, the list has already been scanned
//
#define LSAP_SID_CACHE_UNIQUE 0x00000001

NTSTATUS
LsapDbAddOneSidToCache(
    IN PSID Sid,
    IN PUNICODE_STRING Name,
    IN SID_NAME_USE Use,
    IN PLSAPR_TRUST_INFORMATION Domain,
    IN ULONG Flags,
    IN ULONG OperationalFlags,
    OUT PLSAP_DB_SID_CACHE_ENTRY * CacheEntry OPTIONAL
    )
{
    PLSAP_DB_SID_CACHE_ENTRY NewEntry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL Continue = TRUE;

    if ((OperationalFlags & LSAP_SID_CACHE_UNIQUE) == 0) {

        NewEntry = LsapDbFindSidCacheEntry(Sid, LsapSidCacheSearchExpiredEntries);
    
        if (NewEntry)
        {
            LARGE_INTEGER NewTime;
    
            GetSystemTimeAsFileTime( (LPFILETIME) &NewTime );
            NewEntry->LastUse = NewTime;
            NewEntry->RefreshTime.QuadPart = NewTime.QuadPart + LsapSidCacheRefreshTime.QuadPart;
            NewEntry->ExpirationTime.QuadPart = NewTime.QuadPart + LsapSidCacheExpiryTime.QuadPart;
    
            if (CacheEntry)
            {
                *CacheEntry = NewEntry;
            }
    
            return STATUS_SUCCESS;
        }
    }

    //
    // Make sure we haven't exceeded the maximum cache size.  Since the
    // max cache size may have changed recently, don't just check the
    // boundary.
    //

    if (LsapSidCacheMaxSize == 0)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    while (LsapSidCacheCount >= LsapSidCacheMaxSize && Continue)
    {
        Continue = LsapDbPurgeOneSid();
    }

    //
    // A large number of cache entries are currently in use and we can't
    // remove any to make space, so return a failure instead.  This shouldn't
    // happen very often since all the SIDs must be logon SIDs.
    //
    if (LsapSidCacheCount >= LsapSidCacheMaxSize)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Build the new cache entry
    //

    NewEntry = (PLSAP_DB_SID_CACHE_ENTRY) LsapAllocateLsaHeap(sizeof(LSAP_DB_SID_CACHE_ENTRY));
    if (NewEntry == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(NewEntry,sizeof(PLSAP_DB_SID_CACHE_ENTRY));

    Status = LsapDuplicateSid(
                &NewEntry->Sid,
                Sid
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status= LsapDuplicateSid(
                &NewEntry->DomainSid,
                Domain->Sid
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsapRpcCopyUnicodeString(
                NULL,
                &NewEntry->AccountName,
                Name
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsapRpcCopyUnicodeString(
                NULL,
                &NewEntry->DomainName,
                (PUNICODE_STRING) &Domain->Name
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    NewEntry->SidType = Use;
    GetSystemTimeAsFileTime( (LPFILETIME) &NewEntry->CreateTime );
    NewEntry->LastUse = NewEntry->CreateTime;
    NewEntry->ExpirationTime.QuadPart = NewEntry->CreateTime.QuadPart + LsapSidCacheExpiryTime.QuadPart ;
    NewEntry->RefreshTime.QuadPart = NewEntry->CreateTime.QuadPart + LsapSidCacheRefreshTime.QuadPart ;
    NewEntry->Next = LsapSidCache;
    NewEntry->InUseCount = 0;
    NewEntry->Flags = (Flags & LSA_LOOKUP_NAME_NOT_SAM_ACCOUNT_NAME) ? LSAP_SID_CACHE_UPN : LSAP_SID_CACHE_SAM_ACCOUNT_NAME;
    LsapSidCache = NewEntry;
    LsapSidCacheCount++;

    if ( CacheEntry )
    {
        *CacheEntry = NewEntry ;
    }

Cleanup:

    if (!NT_SUCCESS(Status) && (NewEntry != NULL))
    {
        LsapDbFreeCacheEntry(NewEntry);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapDbAddSidsToCache
//
//  Synopsis:   Adds a new sid entries to the cache and saves the cache
//
//  Effects:    Grabs a the SidCacheLock resource for write access
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapDbAddLogonNameToCache(
    PUNICODE_STRING AccountName,
    PUNICODE_STRING DomainName,
    PSID AccountSid
    )
{
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry ;
    NTSTATUS Status ;
    LSAPR_TRUST_INFORMATION Trust ;
    PSID Sid ;
    UCHAR SubAuthorityCount ;

    Trust.Name.Buffer = DomainName->Buffer ;
    Trust.Name.Length = DomainName->Length ;
    Trust.Name.MaximumLength = DomainName->MaximumLength ;

    if (LsapSidCacheMaxSize == 0) {
        //
        // If the maximum cache size is zero, there is nothing to do
        // here
        //
        return;
    }

    if ( RtlEqualSid( AccountSid, LsapLocalSystemSid ) 
      || RtlEqualSid( AccountSid, LsapAnonymousSid )  ) {
        //
        // Someone logon'ed on as local system (ie used the machine
        // account).  Don't cache this value as it confuse lookups
        // on the machine account, which should return the real
        // sid of the machine account, not local system
        //
        // Also, don't cache the anonymous sid, either
        //
        return;
    }

    if ( LsapAccountIsFromLocalDatabase( AccountSid ) ) {

        //
        // The account is from the local database which means
        // we always lookup regardless of network conditions
        //
        return;
    }

    Sid = LsapAllocatePrivateHeap( RtlLengthSid( AccountSid ) );

    if ( !Sid )
    {
        return;
    }

    RtlCopyMemory( Sid, AccountSid, RtlLengthSid( AccountSid ) );

    Trust.Sid = Sid ;

    SubAuthorityCount = *RtlSubAuthorityCountSid( Sid );
    if ( SubAuthorityCount > 1 )
    {
        SubAuthorityCount-- ;
        *RtlSubAuthorityCountSid( Sid ) = SubAuthorityCount ;
    }

    LockSidCache();

    Status = LsapDbAddOneSidToCache(
                AccountSid,
                AccountName,
                SidTypeUser,
                &Trust,
                0, // no flags
                0, // no operation flags
                &CacheEntry );

    if ( NT_SUCCESS( Status ) )
    {
        //
        // Logon sessions increment the reference count so that
        // the cache entry does not expire.
        //
        CacheEntry->InUseCount++;
    }

    UnLockSidCache();

    LsapFreePrivateHeap( Sid );

}

VOID
LsapDbReleaseLogonNameFromCache(
    PSID Sid
    )
{
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry ;

    LockSidCache();

    CacheEntry = LsapDbFindSidCacheEntry(
                        Sid,
                        LsapSidCacheSearchExpiredEntries );

    if ( CacheEntry )
    {
        if (CacheEntry->InUseCount > 0)
        {
            CacheEntry->InUseCount--;
        }

        if (CacheEntry->InUseCount == 0)
        {
            LARGE_INTEGER CurrentTime;

            GetSystemTimeAsFileTime( (LPFILETIME) &CurrentTime );
            CacheEntry->RefreshTime.QuadPart = CurrentTime.QuadPart + LsapSidCacheRefreshTime.QuadPart ;
            CacheEntry->ExpirationTime.QuadPart = CurrentTime.QuadPart + LsapSidCacheExpiryTime.QuadPart ;
        }
    }

    UnLockSidCache();

}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbFindSidCacheEntry
//
//  Synopsis:   Checks the cache for a specific SID
//
//  Effects:
//
//  Arguments:
//
//      Sid - The Sid to search for in the cache.
//
//      SearchType - Controls the search semantics
//
//  Requires:   the SidCacheLock resource must be locked for read access
//
//  Returns:    the entry found, or NULL if nothing was found
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PLSAP_DB_SID_CACHE_ENTRY
LsapDbFindSidCacheEntry(
    IN PSID Sid,
    IN LSAP_DB_SID_CACHE_SEARCH_TYPE SearchType
    )
{
    LARGE_INTEGER LimitTime;
    LARGE_INTEGER CurrentTime;
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL;

    GetSystemTimeAsFileTime( (LPFILETIME) &CurrentTime );
    for (CacheEntry = LsapSidCache; CacheEntry != NULL; CacheEntry = CacheEntry->Next )
    {
        if (RtlEqualSid(
                CacheEntry->Sid,
                Sid
                )
          && ((CacheEntry->Flags & LSAP_SID_CACHE_SAM_ACCOUNT_NAME) == LSAP_SID_CACHE_SAM_ACCOUNT_NAME)  )
        {
            DebugLog((DEB_TRACE_LSA,"Found cache entry %wZ\n",
                        &CacheEntry->AccountName));

            //
            // LsapSidCacheSearchValidEntries includes only those that have 
            // not aged beyond the refresh time.
            //
            // LsapSidCacheSearchStaleEntries includes those that have not aged
            // beyond the expiry time.
            //
            // LsapSidCacheSearchExpiredEntries includes all entries.
            //
            switch (SearchType) {
                
                case LsapSidCacheSearchValidEntries:
                    LimitTime.QuadPart = CacheEntry->RefreshTime.QuadPart;
                    break;
                    
                case LsapSidCacheSearchStaleEntries:
                    LimitTime.QuadPart = CacheEntry->ExpirationTime.QuadPart;
                    break;
                    
                case LsapSidCacheSearchExpiredEntries:
                    LimitTime.QuadPart = CurrentTime.QuadPart;
                    break;
                    
                default:
                    ASSERT("Invalid Sid Cache Search Type\n");
                    LimitTime.QuadPart = 0;
                    break;   
            }
            
            //
            // Refcounted (currently logged in) entries are always used.
            //
            if ( (CacheEntry->InUseCount == 0)
              &&  LimitTime.QuadPart < CurrentTime.QuadPart ) {

                //
                // can't use this entry
                //
                break;
            }

            CacheEntry->LastUse = CurrentTime;
            return(CacheEntry);
        }
    }

    return(NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbFindSidCacheEntryByName
//
//  Synopsis:   Checks the cache for a specific name
//
//  Effects:
//
//  Arguments:
//
//      Sid - The Sid to search for in the cache.
//
//      SearchType - Controls the search semantics//     
//
//  Requires:   the SidCacheLock resource must be locked for read access
//
//  Returns:    the entry found, or NULL if nothing was found
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PLSAP_DB_SID_CACHE_ENTRY
LsapDbFindSidCacheEntryByName(
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName,
    IN LSAP_DB_SID_CACHE_SEARCH_TYPE SearchType
    )
{
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER LimitTime;
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL;

    GetSystemTimeAsFileTime( (LPFILETIME) &CurrentTime );
    for (CacheEntry = LsapSidCache; CacheEntry != NULL; CacheEntry = CacheEntry->Next )
    {
        if (RtlEqualUnicodeString(
                &CacheEntry->AccountName,
                AccountName,
                TRUE                    // case insensitive
                ) &&
            ((DomainName->Length == 0) ||
             RtlEqualUnicodeString(
                &CacheEntry->DomainName,
                DomainName,
                TRUE                    // case insensitive
                )))
        {
            DebugLog((DEB_TRACE_LSA,"Found cache entry %wZ\n",
                        &CacheEntry->AccountName));

            //
            // LsapSidCacheSearchValidEntries includes only those that have 
            // not aged beyond the refresh time.
            //
            // LsapSidCacheSearchStaleEntries includes those that have not aged
            // beyond the expiry time.
            //
            // LsapSidCacheSearchExpiredEntries includes all entries.
            //
            switch (SearchType) {
                
                case LsapSidCacheSearchValidEntries:
                    LimitTime.QuadPart = CacheEntry->RefreshTime.QuadPart;
                    break;
                    
                case LsapSidCacheSearchStaleEntries:
                    LimitTime.QuadPart = CacheEntry->ExpirationTime.QuadPart;
                    break;
                    
                case LsapSidCacheSearchExpiredEntries:
                    LimitTime.QuadPart = CurrentTime.QuadPart;
                    break;
                    
                default:
                    ASSERT("Invalid Sid Cache Search Type\n");
                    LimitTime.QuadPart = 0;
                    break;   
            }
            
            //
            // Refcounted (currently logged in) entries are always used.
            //
            if ( (CacheEntry->InUseCount == 0)
              &&  LimitTime.QuadPart < CurrentTime.QuadPart ) {

                //
                // can't use this entry
                //
                break;
            }

            CacheEntry->LastUse = CurrentTime;
            return(CacheEntry);
        }
    }

    return(NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbMapCachedSids
//
//  Synopsis:   Checks the SPMgr's cache of sid-name pairs for the sid
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
LsapDbMapCachedSids(
    IN PSID *Sids,
    IN ULONG Count,
    IN BOOLEAN UseOldEntries,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    OUT PULONG MappedCount
    )
{
    ULONG SidIndex;
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL;
    LSAPR_TRUST_INFORMATION TrustInformation;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DomainIndex;
    PLSA_TRANSLATED_NAME_EX OutputNames = NULL;
    LSAP_DB_SID_CACHE_SEARCH_TYPE SearchType = 
        UseOldEntries ? LsapSidCacheSearchStaleEntries 
        : LsapSidCacheSearchValidEntries;

    OutputNames = (PLSA_TRANSLATED_NAME_EX) TranslatedNames->Names;

    LockSidCache();

    for (SidIndex = 0; SidIndex < Count ; SidIndex++)
    {

        if (TranslatedNames->Names[SidIndex].Use != SidTypeUnknown) {

            continue;

        }

        //
        // lookup the sid in the cache
        //

        CacheEntry = LsapDbFindSidCacheEntry(Sids[SidIndex], SearchType);
        if (CacheEntry == NULL)
        {
            //
            // Sid wasn't found - continue
            //

            continue;
        }

        TrustInformation.Name = *(PLSAPR_UNICODE_STRING) &CacheEntry->DomainName;
        TrustInformation.Sid = (PLSAPR_SID) CacheEntry->DomainSid;

        //
        // At least one Sid has the domain Sid as prefix (or is the
        // domain SID).  Add the domain to the list of Referenced
        // Domains and obtain a Domain Index back.
        //

        Status = LsapDbLookupAddListReferencedDomains(
                     ReferencedDomains,
                     &TrustInformation,
                     &DomainIndex
                     );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        OutputNames[SidIndex].Use = CacheEntry->SidType;
        OutputNames[SidIndex].DomainIndex = DomainIndex;

        Status = LsapRpcCopyUnicodeString(
                    NULL,
                    &OutputNames[SidIndex].Name,
                    &CacheEntry->AccountName
                    );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        (*MappedCount)++;
    }

Cleanup:

    UnLockSidCache();

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapDbMapCachedNames
//
//  Synopsis:   Checks the LSA's cache of sid-name pairs for the name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
LsapDbMapCachedNames(
    IN ULONG           LookupOptions,
    IN PUNICODE_STRING AccountNames,
    IN PUNICODE_STRING DomainNames,
    IN ULONG Count,
    IN BOOLEAN UseOldEntries,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    OUT PULONG MappedCount
    )
{
    ULONG SidIndex;
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL;
    LSAPR_TRUST_INFORMATION TrustInformation;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DomainIndex;
    PLSA_TRANSLATED_SID_EX2 OutputSids = NULL;
    LSAP_DB_SID_CACHE_SEARCH_TYPE SearchType = 
        UseOldEntries ? LsapSidCacheSearchStaleEntries 
        : LsapSidCacheSearchValidEntries;

    OutputSids = (PLSA_TRANSLATED_SID_EX2) TranslatedSids->Sids;

    LockSidCache();
    for (SidIndex = 0; SidIndex < Count ; SidIndex++)
    {
        //
        // lookup the Sids in the cache
        //
        if (TranslatedSids->Sids[SidIndex].Use != SidTypeUnknown) {

            continue;

        }

        if ( (LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL)
         &&  (DomainNames[SidIndex].Length == 0) ) {

            //
            // If the name is isolated don't map to a name that
            // was found off machine
            //
            continue;
        }

        CacheEntry = LsapDbFindSidCacheEntryByName(
                        &AccountNames[SidIndex],
                        &DomainNames[SidIndex],
                        SearchType
                        );

        if (CacheEntry == NULL)
        {
            //
            // Name wasn't found - continue
            //

            continue;
        }

        TrustInformation.Name = *(PLSAPR_UNICODE_STRING) &CacheEntry->DomainName;
        TrustInformation.Sid = (PLSAPR_SID) CacheEntry->DomainSid;

        //
        // At least one Sid has the domain Sid as prefix (or is the
        // domain SID).  Add the domain to the list of Referenced
        // Domains and obtain a Domain Index back.
        //

        Status = LsapDbLookupAddListReferencedDomains(
                     ReferencedDomains,
                     &TrustInformation,
                     &DomainIndex
                     );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        OutputSids[SidIndex].Use = CacheEntry->SidType;
        OutputSids[SidIndex].DomainIndex = DomainIndex;

        Status = LsapRpcCopySid(NULL,
                                &OutputSids[SidIndex].Sid,
                                CacheEntry->Sid);
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

//        LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Cache hit for %wZ\%wZ\n", &DomainNames[SidIndex], &AccountNames[SidIndex] ));

        (*MappedCount)++;
    }

Cleanup:


    UnLockSidCache();

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbFreeSidCache
//
//  Synopsis:   frees the entire sid cache
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
LsapDbFreeSidCache()
//
// SidCache is the global sid cache
//
{
    LockSidCache();

    while ( LsapSidCache != NULL )
    {
        PLSAP_DB_SID_CACHE_ENTRY Temp = LsapSidCache;

        Temp = LsapSidCache->Next;

        LsapDbFreeCacheEntry( LsapSidCache );

        LsapSidCache = Temp;
    }

    LsapSidCacheCount = 0;

    UnLockSidCache();

}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbInitSidCache
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LsapDbInitSidCache(
    VOID
    )
{
    NTSTATUS Status = RtlInitializeCriticalSection(&LsapSidCacheLock);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Sets the global parameters
    //
    LsapSidCacheReadParameters(NULL);

    //
    // Move old settings to new location -- note this will
    // cause the global parameters to be re-read if there
    // are any changes.
    //
    LsapUpdateConfigSettings();

    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapAccountIsFromLocalDatabase
//
//  Synopsis:   Returns TRUE if the passed in SID is from the local account
//              database; FALSE otherwise
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
LsapAccountIsFromLocalDatabase(
    IN PSID Sid
    )
{
    BOOLEAN fLocal = FALSE;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo;
    NTSTATUS Status;
    UCHAR SubAuthorityCount;
    BOOLEAN fRevert = FALSE;

    Status = LsapDbLookupGetDomainInfo(&AccountDomainInfo,
                                       NULL);
    if ( NT_SUCCESS( Status ) ) {
        SubAuthorityCount = *RtlSubAuthorityCountSid( Sid );
        if ( SubAuthorityCount > 1 )
        {
            SubAuthorityCount-- ;
            *RtlSubAuthorityCountSid( Sid ) = SubAuthorityCount ;
            fRevert = TRUE;
        }
    
        if ( RtlEqualSid( Sid, AccountDomainInfo->DomainSid ) ) {
            fLocal = TRUE;
        }
    }

    if ( fRevert ) {
        *RtlSubAuthorityCountSid( Sid ) += 1;
    }

    return fLocal;

}


VOID
LsapUpdateConfigSettings(
    VOID
    )

/*++

Routine Description:

    This routine moves the configuration data from the old location
    (under HKLM\Security\SidCache) to the new location.  Note, 
    the act of writing the value to the new location will trigger
    LsapSidCacheReadParameters to run.
            
Arguments:

    None.
        
Return Values:

    None.

--*/
{

#define SID_CACHE_STORAGE_ROOT  L"Security\\SidCache"
#define SID_CACHE_MAX_ENTRIES_NAME L"MaxEntries"

    DWORD err;        
    HKEY PrevKey = NULL;
    HKEY Key = NULL;
    ULONG Size = sizeof(ULONG);
    ULONG MaxEntries;

    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     SID_CACHE_STORAGE_ROOT,
                     &PrevKey);

    if (ERROR_SUCCESS == err) {

        err = RegQueryValueEx(PrevKey,
                              SID_CACHE_MAX_ENTRIES_NAME,
                              NULL,
                              NULL,
                              (PUCHAR) &MaxEntries,
                              &Size);

        if (ERROR_SUCCESS == err) {

            //
            // A value existed -- move it over to the new location
            //
            err = RegOpenKey(HKEY_LOCAL_MACHINE,
                             L"SYSTEM\\CurrentControlSet\\Control\\LSA",
                             &Key);

            if (ERROR_SUCCESS == err) {

                err = RegSetValueEx(Key,
                                    LSAP_LOOKUP_CACHE_MAX_SIZE_NAME,
                                    0,
                                    REG_DWORD,
                                    (CONST BYTE*)&MaxEntries,
                                     sizeof(MaxEntries));

                if (ERROR_SUCCESS == err) {
                    
                    //
                    // And delete the old one
                    //
                    (VOID) RegDeleteValue(PrevKey,
                                          SID_CACHE_MAX_ENTRIES_NAME);

                }
            }

        }
    }

    if (PrevKey) {
        RegCloseKey(PrevKey);
    }

    if (Key) {
        RegCloseKey(Key);
    }
}

VOID
LsapSidCacheReadParameters(
    IN HKEY hKey OPTIONAL
    )
/*++

Routine Description:

    This routine reads in the configurable parameters of the SID cache
    from the registry and updates the corresponding global parameters.
    
    N.B. This routine is called when ever a change occurs under
    SYSTEM\CCS\Control\LSA
    
Arguments:

    hKey -- a handle to SYSTEM\CCS\Control\LSA
    
Return Values:

    None.

--*/
{
    DWORD err;
    NT_PRODUCT_TYPE ProductType;
    DWORD dwType;
    DWORD dwValue;
    DWORD dwValueSize;
    HKEY LocalKey = NULL;

    if (!RtlGetNtProductType( &ProductType ) ) {
        ProductType = NtProductWinNt;
    }

    if ( NtProductLanManNt == ProductType ) { 
        //
        // Disable the cache and ignore the parameters
        //
        LsapSidCacheMaxSize = 0;
        return;

    } 

    if (hKey == NULL) {

        err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            L"SYSTEM\\CurrentControlSet\\Control\\Lsa",
                            0, // reserved
                            KEY_QUERY_VALUE,
                            &LocalKey );
        if (err) {
            return;
        }
        hKey = LocalKey;
    }

    //
    // Read in the SID cache parameters
    //
    dwValueSize = sizeof(dwValue);
    err = RegQueryValueExW( hKey,
                            LSAP_LOOKUP_CACHE_REFRESH_NAME,
                            NULL,  //reserved,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwValueSize );

    if ( (ERROR_SUCCESS == err)
      && (dwType == REG_DWORD)
      && (dwValueSize == sizeof(dwValue)) ) {
          // dwValue is good
          NOTHING;
    } else {
        dwValue = LSAP_DEFAULT_REFRESH_TIME;
    }
    LsapSidCacheRefreshTime.QuadPart = Int32x32To64(dwValue*60, 10000000i64);

    dwValueSize = sizeof(dwValue);
    err = RegQueryValueExW( hKey,
                            LSAP_LOOKUP_CACHE_EXPIRY_NAME,
                            NULL,  //reserved,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwValueSize );


    if ( (ERROR_SUCCESS == err)
      && (dwType == REG_DWORD)
      && (dwValueSize == sizeof(dwValue))) {
        // dwValue is good
        NOTHING;
    } else {
        dwValue = LSAP_DEFAULT_EXPIRY_TIME;
    }
    LsapSidCacheExpiryTime.QuadPart = Int32x32To64(dwValue*60, 10000000i64);

    dwValueSize = sizeof(dwValue);
    err = RegQueryValueExW( hKey,
                            LSAP_LOOKUP_CACHE_MAX_SIZE_NAME,
                            NULL,  //reserved,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwValueSize );


    if ( (ERROR_SUCCESS == err)
      && (dwType == REG_DWORD)
      && (dwValueSize == sizeof(dwValue))) {
        // dwValue is good
        NOTHING;
    } else {
        dwValue = LSAP_DEFAULT_MAX_CACHE_SIZE;
    }
    LsapSidCacheMaxSize = dwValue;


    //
    // If the cache size is set to 0, immediately free everthing.
    //
    if (0 ==  LsapSidCacheMaxSize) {
        LsapDbFreeSidCache();
    }

    if (LocalKey) {
        RegCloseKey(LocalKey);
    }

    return;
}


VOID
LsapDbUpdateCacheWithSids(
    IN PSID *Sids,
    IN ULONG Count,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSA_TRANSLATED_NAME_EX TranslatedNames
    )
/*++

Routine Description:

    This routine updates the global cache with the results of resolving
    Sids at a domain controller.  If a SID was resolved, any existing entry
    is refreshed; otherwise any existing entry is removed.

Arguments:

    Sids -- the list of SID's to update in the cache
    
    Count -- number of elements in Sids
    
    ReferencedDomains -- the domains that elements in Sids belong to
    
    TranslatedNames -- the resolved names, if any, of Sids

Return Values:

    None.

--*/
{
    ULONG i;
    LARGE_INTEGER CurrentTime;
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL, PrevEntry = NULL;

    GetSystemTimeAsFileTime( (LPFILETIME) &CurrentTime );

    LockSidCache();

    //
    // For each entry, try to find in cache
    //
    for (i = 0; i < Count; i++) {

        BOOLEAN SidWasResolved = TRUE;
        BOOLEAN EntryUpdated = FALSE;

        if (TranslatedNames[i].Flags & LSA_LOOKUP_SID_FOUND_BY_HISTORY) {
            //
            // The SID cache doesn't currently handle lookup's by SID history
            //
            continue;
        }

        if (  (TranslatedNames[i].Use == SidTypeUnknown)
           || (TranslatedNames[i].Use == SidTypeDeletedAccount)
           || (TranslatedNames[i].Use == SidTypeInvalid)  ) {

            SidWasResolved = FALSE;

        }

        PrevEntry = NULL;
        CacheEntry = LsapSidCache;
        while (CacheEntry != NULL) {

            BOOLEAN fRemovedFirstEntry = FALSE;
           
            if ( RtlEqualSid(CacheEntry->Sid, Sids[i]) ) {

                PLSAP_DB_SID_CACHE_ENTRY DiscardEntry = NULL;

                //
                // An entry for this SID exists
                //
                if (SidWasResolved) {
                

                    if ((CacheEntry->Flags & LSAP_SID_CACHE_SAM_ACCOUNT_NAME)) {

                        if (LsapNamesMatch(&CacheEntry->AccountName, &TranslatedNames[i].Name)
                         && LsapNamesMatch(&CacheEntry->DomainName, &ReferencedDomains->Domains[TranslatedNames[i].DomainIndex].Name) ) {

                            //
                            // This entry is still valid -- update refresh time
                            //
                            ASSERT(FALSE == EntryUpdated);
                            CacheEntry->RefreshTime.QuadPart = CurrentTime.QuadPart + LsapSidCacheRefreshTime.QuadPart;
                            CacheEntry->ExpirationTime.QuadPart = CurrentTime.QuadPart + LsapSidCacheExpiryTime.QuadPart;
                            EntryUpdated = TRUE;

                        } else {

                            //
                            // There is an entry with this SID and a sam
                            // account name but not the name that was returned.
                            // This is the account rename case.
                            DiscardEntry = CacheEntry;
                        }
                    } else {

                        //
                        // The SID was resolved and this entry has a UPN
                        // in it. Don't update since we don't know if
                        // the UPN is still valid
                        //
                    }

                } else {

                    //
                    // This SID could not be found -- discard this entry
                    // and remove from the list.
                    //
                    DiscardEntry = CacheEntry;
                }

                if ( DiscardEntry
                  && (DiscardEntry->InUseCount == 0) ) {
                    
                    if (PrevEntry) {
                        ASSERT(PrevEntry->Next == CacheEntry);
                        PrevEntry->Next = CacheEntry->Next;
                        CacheEntry = PrevEntry;
                    } else {
                        ASSERT(LsapSidCache == CacheEntry);
                        LsapSidCache = CacheEntry->Next;
                        CacheEntry = LsapSidCache;
                        fRemovedFirstEntry = TRUE;
                    }
                    PrevEntry = NULL;
                    LsapDbFreeCacheEntry(DiscardEntry);
                    LsapSidCacheCount--;
                }
            }

            if (!fRemovedFirstEntry)
            { 
               PrevEntry = CacheEntry;
               
               if (CacheEntry) {
                  CacheEntry = CacheEntry->Next;
               }
            }
        }

        if ( SidWasResolved 
         && !EntryUpdated   ) {

            //
            // Add an entry
            //
            (VOID) LsapDbAddOneSidToCache(
                        Sids[i],
                        &TranslatedNames[i].Name,
                        TranslatedNames[i].Use,
                        &ReferencedDomains->Domains[TranslatedNames[i].DomainIndex],
                        TranslatedNames[i].Flags,
                        LSAP_SID_CACHE_UNIQUE,
                        NULL
                        );
        }
    }

    UnLockSidCache();

}


VOID
LsapDbUpdateCacheWithNames(
    IN PUNICODE_STRING AccountNames,
    IN PUNICODE_STRING DomainNames,
    IN ULONG Count,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRANSLATED_SID_EX2 TranslatedSids
    )
/*++

Routine Description:

    This routine updates the global cache with the results of resolving
    AccountNames at a domain controller.  If a name was resolved, any existing
    entry is refreshed; otherwise any existing entry is removed.

Arguments:

    AccountNames/DomainNames -- the list of names to update in the cache
    
    Count -- the number of elements in both AccountNames and DomainNames
    
    ReferencedDomains -- the domains that elements in Account belong to
    
    TranslatedNames -- the resolved SIDs, if any, of AccountNames

Return Values:

    None.

--*/
{
    ULONG i;
    LARGE_INTEGER CurrentTime;
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL, PrevEntry = NULL;

    GetSystemTimeAsFileTime( (LPFILETIME) &CurrentTime );

    LockSidCache();

    //
    // For each entry, try to find in cache
    //
    for (i = 0; i < Count; i++) {

        BOOLEAN NameWasResolved = TRUE;
        BOOLEAN EntryUpdated = FALSE;


        if (  (TranslatedSids[i].Use == SidTypeUnknown)
           || (TranslatedSids[i].Use == SidTypeDeletedAccount)
           || (TranslatedSids[i].Use == SidTypeInvalid)  ) {

            NameWasResolved = FALSE;

        }

        PrevEntry = NULL;
        CacheEntry = LsapSidCache;
        while (CacheEntry != NULL) {

            BOOLEAN fNameMatched = FALSE;
            BOOLEAN fRemovedFirstEntry = FALSE;

            if (CacheEntry->SidType == SidTypeDomain) {
                //
                // No account name -- try just the domain name
                //
                fNameMatched =  LsapNamesMatch(&CacheEntry->DomainName, &AccountNames[i]);

            } else {

                if (NameWasResolved) {

                    fNameMatched =  LsapNamesMatch(&CacheEntry->AccountName, &AccountNames[i]) 
                                 && LsapNamesMatch(&CacheEntry->DomainName, &ReferencedDomains->Domains[TranslatedSids[i].DomainIndex].Name);

                } else {
                    //
                    // We don't have the translated name
                    //
                    fNameMatched =  LsapNamesMatch(&CacheEntry->AccountName, &AccountNames[i]);
                    if (fNameMatched 
                     && DomainNames[i].Length != 0) {
                        fNameMatched =  LsapNamesMatch(&CacheEntry->DomainName, &DomainNames[i]);
                    }
                }
            }

            if ( fNameMatched ) {

                PLSAP_DB_SID_CACHE_ENTRY DiscardEntry = NULL;

                //
                // An entry for this name exists
                //
                if (NameWasResolved) {
                
                    if  (RtlEqualSid(CacheEntry->Sid, TranslatedSids[i].Sid)) {

                        //
                        // This entry is still valid -- update refresh time
                        //
                        ASSERT(FALSE == EntryUpdated);
                        CacheEntry->RefreshTime.QuadPart = CurrentTime.QuadPart + LsapSidCacheRefreshTime.QuadPart;
                        CacheEntry->ExpirationTime.QuadPart = CurrentTime.QuadPart + LsapSidCacheExpiryTime.QuadPart;
                        EntryUpdated = TRUE;
                    } else {

                        //
                        // The entry has the same name as the resolved name
                        // but a different SID. This can happen in usual
                        // rename cases.
                        //
                        DiscardEntry = CacheEntry;
                    }

                } else {

                    //
                    // The name was not resolved -- remove
                    //
                    DiscardEntry = CacheEntry;
                }

                if ( DiscardEntry
                  && (DiscardEntry->InUseCount == 0) ) {

                    //
                    // Discard and remove from list
                    //
                    if (PrevEntry) {
                        ASSERT(PrevEntry->Next == CacheEntry);
                        PrevEntry->Next = CacheEntry->Next;
                        CacheEntry = PrevEntry;
                    } else {
                        ASSERT(LsapSidCache == CacheEntry);
                        LsapSidCache = CacheEntry->Next;
                        CacheEntry = LsapSidCache;
                        fRemovedFirstEntry = TRUE;
                    }
                    PrevEntry = NULL;
                    LsapDbFreeCacheEntry(DiscardEntry);
                    LsapSidCacheCount--;
                }
            }

            if (!fRemovedFirstEntry)
            { 
               PrevEntry = CacheEntry;
               
               if (CacheEntry) {
                  CacheEntry = CacheEntry->Next;
               }
            }
        }

        if ( NameWasResolved 
         && !EntryUpdated   ) {

            //
            // Add an entry
            //
            (VOID) LsapDbAddOneSidToCache(
                        TranslatedSids[i].Sid,
                        &AccountNames[i],
                        TranslatedSids[i].Use,
                        &ReferencedDomains->Domains[TranslatedSids[i].DomainIndex],
                        TranslatedSids[i].Flags,
                        LSAP_SID_CACHE_UNIQUE,
                        NULL
                        );
        }
    }

    UnLockSidCache();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\services.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    services.c

Abstract:

    This is the service dispatcher for the security process.  It contains
    the service dispatcher initialization routine and the routines to
    load the DLL for the individual serices and execute them.

Author:

    Rajen Shah  (rajens)    11-Apr-1991

[Environment:]

    User Mode - Win32

Revision History:

    11-Apr-1991         RajenS
        created
    27-Sep-1991 JohnRo
        More work toward UNICODE.
    24-Jan-1991 CliffV
        Converted to be service dispatcher for the security process.

--*/

#include <lsapch2.h>

#include <lmcons.h>
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <lmsname.h>
#include <crypt.h>
#include <logonmsv.h>
#include <ntdsa.h>
#include <netlib.h>             // SET_SERVICE_EXITCODE


//
// Names of services run in-proc
//

#ifndef SERVICE_KDC
#define SERVICE_KDC TEXT("KDC")
#endif

#ifndef SERVICE_SAM
#define SERVICE_SAM TEXT("SAMSS")
#endif

#ifndef SERVICE_IPSECPOLICYAGENT
#define SERVICE_IPSECPOLICYAGENT TEXT("PolicyAgent")
#endif

#ifndef SERVICE_PSTORE
#define SERVICE_PSTORE TEXT("ProtectedStorage")
#endif

#ifndef SERVICE_HTTPFILTER
#define SERVICE_HTTPFILTER TEXT("HTTPFilter")
#endif


//
// Private API to tell the Service Controller
// that this is the LSA.
//

VOID
I_ScIsSecurityProcess(
    VOID
    );


//
// Internal service table structure/enum definitions
//

typedef struct _LSAP_SERVICE_TABLE
{
    LPCSTR  lpDllName;
    LPCSTR  lpEntryPoint;
    LPCWSTR lpServiceName;
}
LSAP_SERVICE_TABLE, *PLSAP_SERVICE_TABLE;


typedef enum
{
    LSAP_SERVICE_NETLOGON,
    LSAP_SERVICE_KDC,
    LSAP_SERVICE_IPSECPOLICYAGENT,
    LSAP_SERVICE_PROTECTEDSTORAGE,
    LSAP_SERVICE_HTTPFILTER,
    LSAP_SERVICE_MAX
}
LSAP_SERVICE_TYPE, *PLSAP_SERVICE_TYPE;


//
// Keep this list in order with the service types above
//

LSAP_SERVICE_TABLE g_LsaServiceTable[LSAP_SERVICE_MAX] = {
                       { "netlogon.dll" , "NlNetlogonMain"   , SERVICE_NETLOGON         } ,
                       { "kdcsvc.dll"   , "KdcServiceMain"   , SERVICE_KDC              } ,
                       { "ipsecsvc.dll" , "SPDServiceMain"   , SERVICE_IPSECPOLICYAGENT } ,
                       { "pstorsvc.dll" , "PSTOREServiceMain", SERVICE_PSTORE           } ,
                       { "w3ssl.dll"    , "HTTPFilterServiceMain" , SERVICE_HTTPFILTER  }
                   };



//
// Prototypes for the service-specific start routines themselves
//

VOID
SrvLoadNetlogon(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );

VOID
SrvLoadKdc(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );

VOID
SrvLoadIPSecSvcs(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );

VOID
SrvLoadNtlmssp(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );

VOID
SrvLoadPSTORE(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );

VOID
SrvLoadSamss(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );

VOID
SrvLoadHTTPFilter(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );


//
// The actual dispatch table for the in-proc services and their start routines
//

SERVICE_TABLE_ENTRY  SecurityServiceDispatchTable[] = {
                        { SERVICE_NETLOGON,         SrvLoadNetlogon     },
                        { SERVICE_KDC,              SrvLoadKdc          },
                        { SERVICE_NTLMSSP,          SrvLoadNtlmssp      },
                        { SERVICE_IPSECPOLICYAGENT, SrvLoadIPSecSvcs    },
                        { SERVICE_PSTORE,           SrvLoadPSTORE       },
                        { SERVICE_SAM,              SrvLoadSamss        },
                        { SERVICE_HTTPFILTER,       SrvLoadHTTPFilter   },
                        { NULL,                     NULL                }
                    };



BOOLEAN
LsapWaitForSamService(
    SERVICE_STATUS_HANDLE hService,
    SERVICE_STATUS *SStatus
    );


VOID
DummyControlHandler(
    IN DWORD opcode
    )
/*++

Routine Description:

    Process and respond to a control signal from the service controller.

Arguments:

    opcode - Supplies a value which specifies the action for the Netlogon
        service to perform.

Return Value:

    None.

    NOTE : this is a dummy handler, used to uninstall the netlogon service
           when we unable to load netlogon dll.
--*/
{

    DebugLog((DEB_TRACE, "[Security Process] in control handler\n"));
    return;
}


VOID
LsapStartService(
    IN LSAP_SERVICE_TYPE  ServiceType,
    IN DWORD              dwNumServicesArgs,
    IN LPTSTR             *lpServiceArgVectors,
    IN BOOLEAN            fUnload
    )
{
    NET_API_STATUS          NetStatus;
    HANDLE                  DllHandle = NULL;
    LPSERVICE_MAIN_FUNCTION pfnServiceMain;

    SERVICE_STATUS_HANDLE ServiceHandle;
    SERVICE_STATUS        ServiceStatus;

    //
    // Load the service DLL
    //

    DllHandle = LoadLibraryA(g_LsaServiceTable[ServiceType].lpDllName);

    if (DllHandle == NULL)
    {
        NetStatus = GetLastError();

        DebugLog((DEB_ERROR,
                  "[Security process] load library %s failed %ld\n",
                  g_LsaServiceTable[ServiceType].lpDllName,
                  NetStatus));

        goto Cleanup;
    }

    //
    // Find the main entry point for the service
    //

    pfnServiceMain = (LPSERVICE_MAIN_FUNCTION) GetProcAddress(DllHandle,
                                                         g_LsaServiceTable[ServiceType].lpEntryPoint);

    if (pfnServiceMain == NULL)
    {
        NetStatus = GetLastError();

        DebugLog((DEB_ERROR,
                  "[Security process] GetProcAddress %s failed %ld\n",
                  g_LsaServiceTable[ServiceType].lpEntryPoint,
                  NetStatus));

        goto Cleanup;
    }

    //
    // Call the service entrypoint
    //

    (*pfnServiceMain)(dwNumServicesArgs, lpServiceArgVectors);

    //
    // Note that it's inherently unsafe to load/unload a service DLL, which is why
    // no LSA-hosted service in the product should have this set to TRUE for a
    // call to LsapStartService.  Leave this code in here, however, as it facilitates
    // debugging and fast swapping of private binaries for developers of said services.
    //

    if(fUnload)
    {
        FreeLibrary(DllHandle);
    }

    return;

Cleanup:

    if (DllHandle != NULL)
    {
        FreeLibrary(DllHandle);
    }

    //
    // Register the service to the Service Controller
    //

    ServiceHandle = RegisterServiceCtrlHandler(g_LsaServiceTable[ServiceType].lpServiceName,
                                               DummyControlHandler);

    if (ServiceHandle != 0)
    {
        //
        // inform service controller that the service can't start.
        //

        ServiceStatus.dwServiceType      = SERVICE_WIN32;
        ServiceStatus.dwCurrentState     = SERVICE_STOPPED;
        ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
        ServiceStatus.dwCheckPoint       = 0;
        ServiceStatus.dwWaitHint         = 0;

        SET_SERVICE_EXITCODE(NetStatus,
                             ServiceStatus.dwWin32ExitCode,
                             ServiceStatus.dwServiceSpecificExitCode);

        if (!SetServiceStatus( ServiceHandle, &ServiceStatus))
        {
            DebugLog((DEB_ERROR,
                      "[Security process] SetServiceStatus for %ws failed %ld\n",
                      g_LsaServiceTable[ServiceType].lpServiceName,
                      GetLastError()));
        }
    }
    else
    {
        DebugLog((DEB_ERROR,
                  "[Security process] RegisterServiceCtrlHandler for %ws failed %ld\n",
                  g_LsaServiceTable[ServiceType].lpServiceName,
                  GetLastError()));
    }

    return;
}


VOID
SrvLoadNetlogon (
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the netlogon service.  It loads
    Netlogon.dll (which contains the remainder of the service) and
    calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    LsapStartService(LSAP_SERVICE_NETLOGON, dwNumServicesArgs, lpServiceArgVectors, FALSE);
}



VOID
SrvLoadKdc (
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the KDC service.  It loads
    Netlogon.dll (which contains the remainder of the service) and
    calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    LsapStartService(LSAP_SERVICE_KDC, dwNumServicesArgs, lpServiceArgVectors, FALSE);
}


SERVICE_STATUS_HANDLE hService;
SERVICE_STATUS SStatus;

void
NtlmsspHandler(DWORD   dwControl)
{

    switch (dwControl)
    {

    case SERVICE_CONTROL_STOP:
        SStatus.dwCurrentState = SERVICE_STOPPED;
        if (!SetServiceStatus(hService, &SStatus)) {
            KdPrint(("Failed to set service status: %d\n",GetLastError()));
            hService = 0;
        }
        break;

    default:
        break;

    }

}


VOID
SrvLoadNtlmssp (
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the KDC service.  It loads
    Netlogon.dll (which contains the remainder of the service) and
    calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    //
    // Notify the service controller that we are starting.
    //

    hService = RegisterServiceCtrlHandler(SERVICE_NTLMSSP, NtlmsspHandler);
    if (hService)
    {

        SStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
        SStatus.dwCurrentState = SERVICE_RUNNING;
        SStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
        SStatus.dwWin32ExitCode = 0;
        SStatus.dwServiceSpecificExitCode = 0;
        SStatus.dwCheckPoint = 0;
        SStatus.dwWaitHint = 0;
        if (!SetServiceStatus(hService, &SStatus)) {
            KdPrint(("Failed to set service status: %d\n",GetLastError()));
        }
    }
    else
    {
        KdPrint(("Could not register handler, %d\n", GetLastError()));
    }
    return;
}


VOID
SrvLoadIPSecSvcs (
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the IPSEC Services.  It loads
    ipsecsvc.dll (which contains the service implementation) and
    calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    LsapStartService(LSAP_SERVICE_IPSECPOLICYAGENT, dwNumServicesArgs, lpServiceArgVectors, FALSE);
}


VOID
SrvLoadPSTORE (
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the PSTORE service.  It loads
    cryptsvc.dll (which contains the service implementation) and
    calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    LsapStartService(LSAP_SERVICE_PROTECTEDSTORAGE, dwNumServicesArgs, lpServiceArgVectors, FALSE);
}


VOID
SrvLoadHTTPFilter(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the w3ssl service, run in-proc
    for improving SSL performance.  It loads w3ssl.dll (which contains the
    remainder of the service) and calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    LsapStartService(LSAP_SERVICE_HTTPFILTER, dwNumServicesArgs, lpServiceArgVectors, FALSE);
}


VOID
SrvLoadSamss (
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the KDC service.  It loads
    Netlogon.dll (which contains the remainder of the service) and
    calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    SERVICE_STATUS_HANDLE hService;
    SERVICE_STATUS SStatus;
    HANDLE hDsStartup = NULL;
    DWORD err = 0;
    DWORD netError = ERROR_GEN_FAILURE;
    NT_PRODUCT_TYPE prod;

    //
    // Notify the service controller that we are starting.
    //

    hService = RegisterServiceCtrlHandler(SERVICE_SAM, DummyControlHandler);
    if (hService == 0 ) {
        KdPrint(("Could not register handler, %d\n", GetLastError()));
        return;
    }

    //
    // Which product are we running on?
    //

    if ( !RtlGetNtProductType( &prod ) ) {
        KdPrint(("RtlGetNtProductType failed with %d. Defaulting to Winnt\n",
                 GetLastError()));
        prod = NtProductWinNt;
    } 

    //
    // if this is a DS, also wait for the DS
    //

    if ( prod == NtProductLanManNt ) {

        if ( SampUsingDsData() ) {

            hDsStartup = CreateEvent(NULL, TRUE,  FALSE,
                            NTDS_DELAYED_STARTUP_COMPLETED_EVENT);

            if ( hDsStartup == NULL ) {
                KdPrint(("SrvLoadSamss: CreateEvent failed with %d\n",GetLastError()));
            }
        }
    }

    SStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    SStatus.dwCurrentState = SERVICE_START_PENDING;
    SStatus.dwControlsAccepted = 0;
    SStatus.dwWin32ExitCode = 0;
    SStatus.dwServiceSpecificExitCode = 0;
    SStatus.dwCheckPoint = 1;
    SStatus.dwWaitHint = 30*1000;    // 30 sec

    //
    // Wait for sam startup
    //

    if (!LsapWaitForSamService(hService, &SStatus)) {
        KdPrint(("error waiting for sam\n"));
        goto exit;
    }

    //
    // Wait for DS
    //

    if ( hDsStartup != NULL ) {

        SStatus.dwWaitHint = 64*1000;    // 64 sec
        do {
            if (!SetServiceStatus(hService, &SStatus)) {
                KdPrint(("LoadSamss: Failed to set service status: %d\n",GetLastError()));
            }

            SStatus.dwCheckPoint++;
            err = WaitForSingleObject(hDsStartup, 60 * 1000);
                            
        } while ( err == WAIT_TIMEOUT );
    } else {
        err = WAIT_OBJECT_0;
    }

exit:

    if ( err == WAIT_OBJECT_0 ) {
        SStatus.dwCurrentState = SERVICE_RUNNING;
    } else {
        KdPrint(("SAM service failed to start[Error %d].\n", netError));
        SStatus.dwCurrentState = SERVICE_STOPPED;
        SET_SERVICE_EXITCODE(
            netError,
            SStatus.dwWin32ExitCode,
            SStatus.dwServiceSpecificExitCode
            );
    }

    SStatus.dwCheckPoint = 0;
    SStatus.dwWaitHint = 0;

    if (!SetServiceStatus(hService, &SStatus)) {
        KdPrint(("LoadSamss: Failed to set service status: %d\n",GetLastError()));
    }


    if ( hDsStartup != NULL ) {
        CloseHandle(hDsStartup);
    }
    return;
} // SrvLoadSamss



DWORD
ServiceDispatcherThread (
    LPVOID Parameter
    )

/*++

Routine Description:

    This routine synchronizes with the  service controller.  It waits
    for the service controller to set the SECURITY_SERVICES_STARTED
    event then starts up the main
    thread that is going to handle the control requests from the service
    controller.

    It basically sets up the ControlDispatcher and, on return, exits from
    this main thread. The call to NetServiceStartCtrlDispatcher does
    not return until all services have terminated, and this process can
    go away.

    It will be up to the ControlDispatcher thread to start/stop/pause/continue
    any services. If a service is to be started, it will create a thread
    and then call the main routine of that service.


Arguments:

    EventHandle - Event handle to wait on before continuing.

Return Value:

    Exit status of thread.

Note:


--*/
{
    DWORD WaitStatus;
    HANDLE EventHandle;
    BOOL StartStatus;

    //
    // Create an event for us to wait on.
    //

    EventHandle = CreateEventW( NULL,   // No special security
                                TRUE,   // Must be manually reset
                                FALSE,  // The event is initially not signalled
                                SECURITY_SERVICES_STARTED );

    if ( EventHandle == NULL ) {
        WaitStatus = GetLastError();

        //
        // If the event already exists,
        //  the service controller already created it.  Just open it.
        //

        if ( WaitStatus == ERROR_ALREADY_EXISTS ) {

            EventHandle = OpenEventW( EVENT_ALL_ACCESS,
                                      FALSE,
                                      SECURITY_SERVICES_STARTED );

            if ( EventHandle == NULL ) {

                WaitStatus = GetLastError();

                DebugLog((DEB_ERROR,
                          "[Security process] OpenEvent failed %ld\n",
                          WaitStatus));

                return WaitStatus;
            }

        } else {

            DebugLog((DEB_ERROR,
                      "[Security process] CreateEvent failed %ld\n",
                      WaitStatus));

            return WaitStatus;
        }
    }


    //
    // Wait for the service controller to come up.
    //

    WaitStatus = WaitForSingleObject( (HANDLE) EventHandle, (DWORD) -1 );

    CloseHandle( EventHandle );

    if ( WaitStatus != 0 ) {

        DebugLog((DEB_ERROR,
                  "[Security process] WaitForSingleObject failed %ld\n",
                  WaitStatus));

        return WaitStatus;
    }


    //
    // Let the client side of the Service Controller know that
    // is the security process
    //

    I_ScIsSecurityProcess();

    //
    // Call NetServiceStartCtrlDispatcher to set up the control interface.
    // The API won't return until all services have been terminated. At that
    // point, we just exit.
    //

    StartStatus = StartServiceCtrlDispatcher(SecurityServiceDispatchTable);

    DebugLog((DEB_ERROR,
              "[Security process] return from StartCtrlDispatcher %ld \n",
              StartStatus));

    return StartStatus;

    UNREFERENCED_PARAMETER(Parameter);
}


NTSTATUS
ServiceInit (
    VOID
    )

/*++

Routine Description:

    This is a main routine for the service dispatcher of the security process.
    It starts up a thread responsible for coordinating with the
    service controller.


Arguments:

    NONE.

Return Value:

    Status of the thread creation operation.

Note:


--*/
{
    DWORD ThreadId;
    HANDLE ThreadHandle;

    //
    // The control dispatcher runs in a thread of its own.
    //

    ThreadHandle = CreateThread(
                        NULL,       // No special thread attributes
                        0,          // No special stack size
                        &ServiceDispatcherThread,
                        NULL,       // No special parameter
                        0,          // No special creation flags
                        &ThreadId);

    if ( ThreadHandle == NULL ) {
        return (NTSTATUS) GetLastError();
    } else {
        CloseHandle(ThreadHandle);
    }

    return STATUS_SUCCESS;
}


BOOLEAN
LsapWaitForSamService(
    SERVICE_STATUS_HANDLE hService,
    SERVICE_STATUS* SStatus
    )
/*++

Routine Description:

    This procedure waits for the SAM service to start and to complete
    all its initialization.

Arguments:

    NetlogonServiceCalling:
         TRUE if this is the netlogon service proper calling
         FALSE if this is the changelog worker thread calling

Return Value:

    TRUE : if the SAM service is successfully starts.

    FALSE : if the SAM service can't start.

--*/
{
    NTSTATUS Status;
    DWORD WaitStatus;
    UNICODE_STRING EventName;
    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;

    //
    // open SAM event
    //

    RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtOpenEvent( &EventHandle,
                            SYNCHRONIZE|EVENT_MODIFY_STATE,
                            &EventAttributes );

    if ( !NT_SUCCESS(Status)) {

        if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

            //
            // SAM hasn't created this event yet, let us create it now.
            // SAM opens this event to set it.
            //

            Status = NtCreateEvent(
                           &EventHandle,
                           SYNCHRONIZE|EVENT_MODIFY_STATE,
                           &EventAttributes,
                           NotificationEvent,
                           FALSE // The event is initially not signaled
                           );

            if( Status == STATUS_OBJECT_NAME_EXISTS ||
                Status == STATUS_OBJECT_NAME_COLLISION ) {

                //
                // second change, if the SAM created the event before we
                // do.
                //

                Status = NtOpenEvent( &EventHandle,
                                        SYNCHRONIZE|EVENT_MODIFY_STATE,
                                        &EventAttributes );

            }
        }

        if ( !NT_SUCCESS(Status)) {

            //
            // could not make the event handle
            //

            KdPrint(("NlWaitForSamService couldn't make the event handle : "
                "%lx\n", Status));

            return( FALSE );
        }
    }

    //
    // Loop waiting.
    //

    for (;;) {
        WaitStatus = WaitForSingleObject( EventHandle,
                                          5*1000 );  // 5 Seconds

        if ( WaitStatus == WAIT_TIMEOUT ) {

            if (!SetServiceStatus(hService, SStatus)) {
                KdPrint(("LoadSamss: Failed to set service status: %d\n",GetLastError()));
            }
    
            SStatus->dwCheckPoint++;
            continue;

        } else if ( WaitStatus == WAIT_OBJECT_0 ) {
            break;

        } else {
            KdPrint(("NlWaitForSamService: error %ld %ld\n",
                     GetLastError(),
                     WaitStatus ));
            (VOID) NtClose( EventHandle );
            return FALSE;
        }
    }

    (VOID) NtClose( EventHandle );
    return TRUE;

} // LsapWaitForSamService
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\wsautils.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    wsautils.h

Abstract:

    IPv6 related functions

Author:

    kumarp 18-July-2002 created


Revision History:

--*/


#include <lsapch2.h>

#include "wsautils.h"


//
// taken from /nt/net/sockets/winsock2/wsp/afdsys/kdext/tdiutil.c
//
// the only changes were:
// -- made type of S as PWCHAR instead of PCHAR
// -- _snprintf ==> _snwprintf
// -- format strings "foo" ==> L"foo"
//
//

INT
MyIp6AddressToString (
    PIN6_ADDR Addr,
    PWCHAR    S,
    INT       L
    )
{
    int maxFirst, maxLast;
    int curFirst, curLast;
    int i;
    int endHex = 8, n = 0;

    // Check for IPv6-compatible, IPv4-mapped, and IPv4-translated
    // addresses
    if ((Addr->s6_words[0] == 0) && (Addr->s6_words[1] == 0) &&
        (Addr->s6_words[2] == 0) && (Addr->s6_words[3] == 0) &&
        (Addr->s6_words[6] != 0)) {
        if ((Addr->s6_words[4] == 0) &&
             ((Addr->s6_words[5] == 0) || (Addr->s6_words[5] == 0xffff)))
        {
            // compatible or mapped
            n += _snwprintf(&S[n], L-1-n, L"::%s%u.%u.%u.%u",
                           Addr->s6_words[5] == 0 ? L"" : L"ffff:",
                           Addr->s6_bytes[12], Addr->s6_bytes[13],
                           Addr->s6_bytes[14], Addr->s6_bytes[15]);
            S[n]=0;
            return n;
        }
        else if ((Addr->s6_words[4] == 0xffff) && (Addr->s6_words[5] == 0)) {
            // translated
            n += _snwprintf(&S[n], L-1-n, L"::ffff:0:%u.%u.%u.%u",
                           Addr->s6_bytes[12], Addr->s6_bytes[13],
                           Addr->s6_bytes[14], Addr->s6_bytes[15]);
            S[n]=0;
            return n;
        }
    }


    // Find largest contiguous substring of zeroes
    // A substring is [First, Last), so it's empty if First == Last.

    maxFirst = maxLast = 0;
    curFirst = curLast = 0;

    // ISATAP EUI64 starts with 00005EFE (or 02005EFE)...
    if (((Addr->s6_words[4] & 0xfffd) == 0) && (Addr->s6_words[5] == 0xfe5e)) {
        endHex = 6;
    }

    for (i = 0; i < endHex; i++) {

        if (Addr->s6_words[i] == 0) {
            // Extend current substring
            curLast = i+1;

            // Check if current is now largest
            if (curLast - curFirst > maxLast - maxFirst) {

                maxFirst = curFirst;
                maxLast = curLast;
            }
        }
        else {
            // Start a new substring
            curFirst = curLast = i+1;
        }
    }

    // Ignore a substring of length 1.
    if (maxLast - maxFirst <= 1)
        maxFirst = maxLast = 0;

        // Write colon-separated words.
        // A double-colon takes the place of the longest string of zeroes.
        // All zeroes is just "::".

    for (i = 0; i < endHex; i++) {

        // Skip over string of zeroes
        if ((maxFirst <= i) && (i < maxLast)) {

            n += _snwprintf(&S[n], L-1-n, L"::");
            i = maxLast-1;
            continue;
        }

        // Need colon separator if not at beginning
        if ((i != 0) && (i != maxLast))
            n += _snwprintf(&S[n], L-1-n, L":");

        n += _snwprintf(&S[n], L-1-n, L"%x", RtlUshortByteSwap(Addr->s6_words[i]));
    }

    if (endHex < 8) {
        n += _snwprintf(&S[n], L-1-n, L":%u.%u.%u.%u",
                       Addr->s6_bytes[12], Addr->s6_bytes[13],
                       Addr->s6_bytes[14], Addr->s6_bytes[15]);
    }

    S[n] = 0;
    return n;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\cfiles\safemode.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    safemode.c

Abstract:

    Module to determine what boot mode the system was boot into.

Author:

    Colin Brace         (ColinBr)    May 27, 1997.

Environment:

    User mode

Revision History:

--*/

#include <lsapch2.h>
#include <safeboot.h>
#include "safemode.h"

//
// Variables global to just this module.  They are kept non-static
// for debugging ease.
//
BOOLEAN fLsapSafeMode;

//
// Forward prototypes
//

BOOLEAN
LsapGetRegistryProductType(
    PNT_PRODUCT_TYPE NtProductType
    );

BOOLEAN
LsapBaseNtSetupIsRunning(
    VOID
    );


//
// Function definitions
//

NTSTATUS
LsapCheckBootMode(
    VOID
    )
/*++

Routine Description:

    This routine determine if the environment variable SAFEBOOT_OPTION is 
    set and if the product type is domain controller.  If so, LsaISafeMode 
    will return TRUE; otherwise it will return FALSE.        

    Note that during kernel initialization, the kernel detects the safemode 
    boot option and if the product type is LanmanNT will set 
    SharedUserData->ProductType to ServerNT, so that RtlNtGetProductType() 
    will return ServerNT for this boot session.

Arguments:

    None.

Return Values:

    STATUS_SUCCESS on completion;
    Otherwise error from system services - this is fatal to the boot session.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NT_PRODUCT_TYPE     CurrentProductType;
    NT_PRODUCT_TYPE     OriginalProductType;

    WCHAR               SafeBootEnvVar[sizeof(SAFEBOOT_DSREPAIR_STR_W)];

    BOOLEAN             fSafeModeBootOptionPresent = FALSE;

    RtlZeroMemory(SafeBootEnvVar, sizeof(SafeBootEnvVar));

    //
    // If we are running during base nt setup, there is no point doing any
    // further investigation
    //
    if (LsapBaseNtSetupIsRunning()) {
        fLsapSafeMode = FALSE;
        return STATUS_SUCCESS;
    }

    //
    // Does environment variable exist
    //
    RtlZeroMemory( SafeBootEnvVar, sizeof( SafeBootEnvVar ) );
    if ( GetEnvironmentVariableW(L"SAFEBOOT_OPTION", SafeBootEnvVar, sizeof(SafeBootEnvVar)/sizeof(SafeBootEnvVar[0]) ) )
    {
        if ( !wcscmp( SafeBootEnvVar, SAFEBOOT_DSREPAIR_STR_W ) )
        {
            fSafeModeBootOptionPresent = TRUE;
            OutputDebugStringA("LSASS: found ds repair option\n");
        }
    }

    //
    // Get the  product type as determined by RtlGetNtProductType
    //
    if (!RtlGetNtProductType(&CurrentProductType)) {
        OutputDebugStringA("LSASS: RtlGetNtProductType failed\n");
        return STATUS_UNSUCCESSFUL;
    }

    //
    // See what the original product type is
    //
    if (!LsapGetRegistryProductType(&OriginalProductType)) {
        OutputDebugStringA("LSASS: RtlGetNtProductType failed\n");
        return STATUS_UNSUCCESSFUL;
    }


    //
    // Now for some analysis
    //
    if (fSafeModeBootOptionPresent
    && (OriginalProductType == NtProductLanManNt)) {

        // We are entering safe mode boot

        ASSERT(CurrentProductType == NtProductServer);

        fLsapSafeMode = TRUE;

        OutputDebugStringA("LSASS: Booting into Ds Repair Mode\n");

    } else {

        // This is a normal boot
        fLsapSafeMode = FALSE;

    }

    return(NtStatus);
}


BOOLEAN
LsaISafeMode(
    VOID
    )
/*++

Routine Description:

    This function is meant be called from in process servers of lsass.exe to
    determine if the current boot session is a "safe mode" boot session.

Arguments:

    None.

Return Values:

    TRUE  : the system is in safe mode

    FALSE :  the system is in safe mode

--*/
{
    DebugLog((DEB_TRACE_LSA, "LsaISafeMode entered\n"));
    return fLsapSafeMode;
}

BOOLEAN
LsapGetRegistryProductType(
    PNT_PRODUCT_TYPE NtProductType
    )
/*++

Routine Description:

    This routine retrieves the product type as stored in the registry.
    Note that when the safemode option is set and the product type at
    kernel initialization is LanmanNT then then SharedUserData->ProductType
    is set the ServerNT, which is what RtlGetNtProductType returns.

Arguments:

    None.

Return Values:

--*/
{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    ULONG KeyValueInfoLength;
    ULONG ResultLength;
    UNICODE_STRING KeyPath;
    UNICODE_STRING ValueName;
    UNICODE_STRING Value;
    UNICODE_STRING WinNtValue;
    UNICODE_STRING LanmanNtValue;
    UNICODE_STRING ServerNtValue;
    BOOLEAN Result;

    //
    // Prepare default value for failure case
    //

    *NtProductType = NtProductWinNt;
    Result = FALSE;

    RtlInitUnicodeString( &KeyPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ProductOptions" );
    RtlInitUnicodeString( &ValueName, L"ProductType" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &KeyHandle,
                        MAXIMUM_ALLOWED,
                        &ObjectAttributes
                      );
    KeyValueInformation = NULL;
    if (NT_SUCCESS( Status )) {
        KeyValueInfoLength = 256;
        KeyValueInformation = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               KeyValueInfoLength
                                             );
        if (KeyValueInformation == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {
            Status = NtQueryValueKey( KeyHandle,
                                      &ValueName,
                                      KeyValueFullInformation,
                                      KeyValueInformation,
                                      KeyValueInfoLength,
                                      &ResultLength
                                    );
        }
    } else {
        KeyHandle = NULL;
    }

    if (NT_SUCCESS( Status ) && KeyValueInformation->Type == REG_SZ) {

        //
        // Decide which product we are installed as
        //

        Value.Buffer = (PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
        Value.Length = (USHORT)(KeyValueInformation->DataLength - sizeof( UNICODE_NULL ));
        Value.MaximumLength = (USHORT)(KeyValueInformation->DataLength);
        RtlInitUnicodeString(&WinNtValue, L"WinNt");
        RtlInitUnicodeString(&LanmanNtValue, L"LanmanNt");
        RtlInitUnicodeString(&ServerNtValue, L"ServerNt");

        if (RtlEqualUnicodeString(&Value, &WinNtValue, TRUE)) {
            *NtProductType = NtProductWinNt;
            Result = TRUE;
        } else if (RtlEqualUnicodeString(&Value, &LanmanNtValue, TRUE)) {
            *NtProductType = NtProductLanManNt;
            Result = TRUE;
        } else if (RtlEqualUnicodeString(&Value, &ServerNtValue, TRUE)) {
            *NtProductType = NtProductServer;
            Result = TRUE;
        } else {
#if DBG
            DbgPrint("RtlGetNtProductType: Product type unrecognised <%wZ>\n", &Value);
#endif // DBG
        }
    } else {
#if DBG
        DbgPrint("RtlGetNtProductType: %wZ\\%wZ not found or invalid type\n", &KeyPath, &ValueName );
#endif // DBG
    }

    //
    // Clean up our resources.
    //

    if (KeyValueInformation != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInformation );
    }

    if (KeyHandle != NULL) {
        NtClose( KeyHandle );
    }

    //
    // Return result.
    //

    return(Result);

}

BOOLEAN
LsapBaseNtSetupIsRunning(
    VOID
    )
/*++

Routine Description:

    This function returns TRUE if the boot context is base nt setup

Arguments:

    None.

Return Values:

    TRUE is it can be determined that base nt setup is running
    FALSE otherwise

--*/
{
    BOOLEAN fUpgrade;
    return SamIIsSetupInProgress(&fUpgrade);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dsexe\makefile.inc ===
# MOF resources required for WMI tracing
lsasrv.bmf: lsasrv.mof
    mofcomp -WMI -B:lsasrv.bmf lsasrv.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dspolicy\dbaccnt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbaccnt.c

Abstract:

    LSA - Database - Account Object Private API Workers

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.

Author:

    Scott Birrell       (ScottBi)      April 29, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Private Datatypes                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

//
// The following structures define output for the LsarQueryInformationAccount()
// API.  Curerently, this API is internal.  If made external, these structures
// should be moved to lsarpc.idl and annotated with MIDL qualifiers [..].
//

//
// This data type defines the following information classes that may be
// queried or set.
//

typedef enum _ACCOUNT_INFORMATION_CLASS {

    AccountSystemAccessInformation = 1,
    AccountPrivilegeInformation,
    AccountQuotaInformation

} ACCOUNT_INFORMATION_CLASS, *PACCOUNT_INFORMATION_CLASS;

typedef PRIVILEGE_SET LSAPR_ACCOUNT_PRIVILEGE_INFO;
typedef QUOTA_LIMITS LSAPR_ACCOUNT_QUOTA_INFO;
typedef ULONG LSAPR_ACCOUNT_SYSTEM_ACCESS_INFO;

typedef union _LSAPR_ACCOUNT_INFO {

    LSAPR_ACCOUNT_PRIVILEGE_INFO          AccountPrivilegeInfo;
    LSAPR_ACCOUNT_QUOTA_INFO              AccountQuotaInfo;
    LSAPR_ACCOUNT_SYSTEM_ACCESS_INFO      AccountSystemAccessInfo;

} LSAPR_ACCOUNT_INFO, *PLSAPR_ACCOUNT_INFO;

#define LsapDbFirstAccount()                                              \
    ((PLSAP_DB_ACCOUNT) LsapDbAccountList.Links.Flink)

#define LsapDbNextAccount( Account )                                      \
    ((PLSAP_DB_ACCOUNT) Account->Links.Flink)


#define LSAP_DB_BUILD_ACCOUNT_LIST_LENGTH     ((ULONG) 0x00001000L)

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Private Function Prototypes                                             //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
LsarQueryInformationAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ACCOUNT_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_ACCOUNT_INFO *AccountInformation
    );

NTSTATUS
LsapDbQueryInformationAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ACCOUNT_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_ACCOUNT_INFO *AccountInformation
    );

NTSTATUS
LsapDbQueryAllInformationAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PLSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO AccountInfo
    );

NTSTATUS
LsapDbSlowQueryAllInformationAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PLSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO AccountInfo
    );

NTSTATUS
LsapDbSlowQueryInformationAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ACCOUNT_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_ACCOUNT_INFO *AccountInformation
    );

NTSTATUS
LsapDbSlowQueryPrivilegesAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PLSAPR_PRIVILEGE_SET *Privileges
    );

NTSTATUS
LsapDbSlowQueryQuotasAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PQUOTA_LIMITS QuotaLimits
    );

NTSTATUS
LsapDbSlowQuerySystemAccessAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PULONG SystemAccess
    );

NTSTATUS
LsapDbLookupAccount(
    IN PSID AccountSid,
    OUT PLSAP_DB_ACCOUNT *Account
    );

NTSTATUS
LsapDbUpdateSystemAccessAccount(
    IN PLSAPR_SID AccountSid,
    IN PULONG SystemAccess
    );

NTSTATUS
LsapDbUpdatePrivilegesAccount(
    IN PLSAPR_SID AccountSid,
    IN OPTIONAL PPRIVILEGE_SET Privileges
    );

NTSTATUS
LsapDbUpdateQuotasAccount(
    IN PLSAPR_SID AccountSid,
    IN PQUOTA_LIMITS QuotaLimits
    );

NTSTATUS
LsapDbCreateAccountList(
    OUT PLSAP_DB_ACCOUNT_LIST AccountList
    );

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Private Global Data                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

LSAP_DB_ACCOUNT_LIST LsapDbAccountList;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Code                                                                    //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
LsarCreateAccount(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID AccountSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE AccountHandle
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaCreateAccount API.

    The LsaCreateAccount API creates a new Account Object.  The account will
    be opened with the specified accesses granted.  The caller must
    have POLICY_CREATE_ACCOUNT access to the Policy Object.

    Note that no verification is done to ensure the SID actually represents
    a valid user, group or alias in any trusted domain.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    AccountSid - Points to the SID of the account.

    DesiredAccess - Specifies the accesses to be granted to the newly
        created and opened account at this time.

    AccountHandle - Receives a handle referencing the newly created
        account.  This handle is used on subsequent accesses to the
        account object.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_EXISTS - An account object having the given Sid
            already exists and has been opened because LSA_OBJECT_OPEN_IF
            disposition has been specified.  This is a warning only.

        STATUS_OBJECT_NAME_COLLISION - An account object having the given Sid
            already exists but has not been opened because LSA_OBJECT_CREATE
            disposition has been specified.  This is an error.

        STATUS_INVALID_PARAMETER - An invalid parameter has been specified.
--*/

{
    NTSTATUS Status;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_ACCOUNT];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    UNICODE_STRING LogicalNameU;
    ULONG AttributeCount;
    BOOLEAN ContainerReferenced = FALSE;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarCreateAccount\n" ));


    LogicalNameU.Length = 0;

    //
    // Set up the object's attributes specific to the Account object type.
    // These are the Account Type and the Sid.
    //

    AttributeCount = 0;
    NextAttribute = Attributes;

    //
    // Validate the Account Sid.
    //

    if (!RtlValidSid( (PSID) AccountSid )) {

        Status = STATUS_INVALID_PARAMETER;
        goto CreateAccountError;
    }

    Status = LsapDbMakeSidAttributeDs(
                 AccountSid,
                 Sid,
                 NextAttribute
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateAccountError;
    }

    AttributeCount++;
    NextAttribute++;

    //
    // Acquire the Lsa Database lock.  Verify that the PolicyHandle
    // is valid and has the necessary access granted.  Reference the Policy
    // Object handle (as container object).
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_CREATE_ACCOUNT,
                 PolicyObject,
                 AccountObject,
                 LSAP_DB_LOCK | LSAP_DB_NO_DS_OP_TRANSACTION | LSAP_DB_READ_ONLY_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateAccountError;
    }

    ContainerReferenced = TRUE;

    //
    // Construct the Logical Name (Internal LSA Database Name) of the
    // account object.  The Logical Name is constructed from the account
    // Sid by extracting the Relative Id (lowest subauthority) and converting
    // it to an 8-digit numeric Unicode String in which leading zeros are
    // added if needed.
    //

    Status = LsapDbSidToLogicalNameObject(AccountSid, &LogicalNameU);

    if (!NT_SUCCESS(Status)) {

        goto CreateAccountError;
    }

    //
    // Fill in the ObjectInformation structure.  Initialize the
    // embedded Object Attributes with the PolicyHandle as the
    // Root Directory (Container Object) handle and the Logical Name
    // of the account. Store the types of the object and its container.
    //

    InitializeObjectAttributes(
        &ObjectInformation.ObjectAttributes,
        &LogicalNameU,
        OBJ_CASE_INSENSITIVE,
        PolicyHandle,
        NULL
        );

    ObjectInformation.ObjectTypeId = AccountObject;
    ObjectInformation.ContainerTypeId = PolicyObject;
    ObjectInformation.Sid = AccountSid;
    ObjectInformation.ObjectAttributeNameOnly = FALSE;
    ObjectInformation.DesiredObjectAccess = DesiredAccess;

    //
    // Create the Account Object.  We fail if the object already exists.
    // Note that the object create routine performs a Database transaction.
    // If caching is supported, the object will also be added to the cache.
    //

    Status = LsapDbCreateObject(
                 &ObjectInformation,
                 DesiredAccess,
                 LSAP_DB_OBJECT_CREATE,
                 0,
                 Attributes,
                 &AttributeCount,
                 RTL_NUMBER_OF(Attributes),
                 AccountHandle
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateAccountError;
    }

CreateAccountFinish:

    //
    // If necessary, release the LSA Database lock.
    //

    if (ContainerReferenced) {

        LsapDbApplyTransaction( PolicyHandle,
                                LSAP_DB_NO_DS_OP_TRANSACTION |
                                    LSAP_DB_READ_ONLY_TRANSACTION,
                                (SECURITY_DB_DELTA_TYPE) 0 );

        LsapDbReleaseLockEx( AccountObject,
                             LSAP_DB_READ_ONLY_TRANSACTION );
    }

    //
    // If necessary, free the Unicode String buffer allocated for the Logical Name
    //

    if (LogicalNameU.Length > 0) {

        RtlFreeUnicodeString(&LogicalNameU);
    }

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarCreateAccount: 0x%lx\n", Status ));

    return( Status );

CreateAccountError:

    //
    // If necessary, dereference the Container Object, release the LSA
    // Database Lock and return.
    //

    if (ContainerReferenced) {

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     AccountObject,
                     LSAP_DB_LOCK | LSAP_DB_NO_DS_OP_TRANSACTION | LSAP_DB_READ_ONLY_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );

        ContainerReferenced = FALSE;
    }

    goto CreateAccountFinish;
}


NTSTATUS
LsarOpenAccount(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID AccountSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE AccountHandle
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the LsaOpenAccount
    API.

    The LsaOpenAccount API opens an account object in the Lsa Database of the
    target system.  An account must be opened before any operation can be
    performed, including deletion of the account.  A handle to the account
    object is returned for use on subsequent API calls that access the
    account.  Before calling this API, the caller must have connected to
    the target system's LSA and opened the LsaDatabase object by means
    of a preceding call to LsaOpenPolicy.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    AccountSid - Pointer to the account's Sid.

    DesiredAccess - This is an access mask indicating accesses being
        requested for the Account object.  These access types
        are reconciled with the Discretionary Access Control List of the
        object to determine whether the accesses will be granted or denied.

    AccountHandle - Pointer to location in which a handle to the opened
        account object will be returned if the call succeeds.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no account object in the
            target system's LSA Database having the specified AccountSid.

--*/

{
    NTSTATUS Status;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    UNICODE_STRING LogicalNameU;
    BOOLEAN ContainerReferenced = FALSE;
    BOOLEAN AcquiredLock = FALSE;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarOpenAccount\n" ));


    //
    // Validate the Account Sid.
    //

    if (!RtlValidSid( AccountSid )) {

        Status = STATUS_INVALID_PARAMETER;
        goto OpenAccountError;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the connection handle
    // (container object handle) is valid, and is of the expected type.
    // Reference the container object handle.  This reference remains in
    // effect until the child object handle is closed.
    //
    // We can't check access on the policy handle.  Too many applications
    //  rely on no access being acquired.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 0,
                 PolicyObject,
                 AccountObject,
                 LSAP_DB_LOCK |
                    LSAP_DB_NO_DS_OP_TRANSACTION |
                    LSAP_DB_READ_ONLY_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto OpenAccountError;
    }

    AcquiredLock = TRUE;
    ContainerReferenced =TRUE;

    //
    // Setup Object Information prior to calling the Object
    // Open routine.  The Object Type, Container Object Type and
    // Logical Name (derived from the Sid) need to be filled in.
    //

    ObjectInformation.ObjectTypeId = AccountObject;
    ObjectInformation.ContainerTypeId = PolicyObject;
    ObjectInformation.Sid = AccountSid;
    ObjectInformation.ObjectAttributeNameOnly = FALSE;
    ObjectInformation.DesiredObjectAccess = DesiredAccess;

    //
    // Construct the Logical Name (Internal LSA Database Name) of the
    // account object.  The Logical Name is constructed from the account
    // Sid by extracting the Relative Id (lowest subauthority) and converting
    // it to an 8-digit numeric Unicode String in which leading zeros are
    // added if needed.
    //

    Status = LsapDbSidToLogicalNameObject(AccountSid,&LogicalNameU);

    if (!NT_SUCCESS(Status)) {

        goto OpenAccountError;
    }
    //
    // Initialize the Object Attributes.  The Container Object Handle and
    // Logical Name (Internal Name) of the object must be set up.
    //

    InitializeObjectAttributes(
        &ObjectInformation.ObjectAttributes,
        &LogicalNameU,
        0,
        PolicyHandle,
        NULL
        );

    //
    // Open the specific account object.  Note that the account object
    // handle returned is an RPC Context Handle.
    //

    Status = LsapDbOpenObject(
                 &ObjectInformation,
                 DesiredAccess,
                 0,
                 AccountHandle
                 );

    RtlFreeUnicodeString( &LogicalNameU );

    if (!NT_SUCCESS(Status)) {

        goto OpenAccountError;
    }

OpenAccountFinish:

    //
    // If necessary, release the LSA Database lock.
    //

    if (AcquiredLock) {

        LsapDbApplyTransaction( PolicyHandle,
                                LSAP_DB_NO_DS_OP_TRANSACTION |
                                    LSAP_DB_READ_ONLY_TRANSACTION,
                                (SECURITY_DB_DELTA_TYPE) 0 );

        LsapDbReleaseLockEx( AccountObject,
                             LSAP_DB_READ_ONLY_TRANSACTION );

        AcquiredLock = FALSE;
    }

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarOpenAccount: 0x%lx\n", Status ));

    return( Status );

OpenAccountError:

    //
    // If necessary, dereference the Container Object handle.  Note that
    // this is only done in the error case.  In the non-error case, the
    // Container handle stays referenced until the Account object is
    // closed.
    //

    if (ContainerReferenced) {

        *AccountHandle = NULL;

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     AccountObject,
                     LSAP_DB_LOCK | LSAP_DB_NO_DS_OP_TRANSACTION | LSAP_DB_READ_ONLY_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );

        ContainerReferenced = FALSE;
        AcquiredLock = FALSE;
    }

    goto OpenAccountFinish;

}


NTSTATUS
LsarEnumerateAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaEnumerateAccounts API.

    The LsaEnumerateAccounts API returns information about the accounts
    in the target system's Lsa Database.  This call requires
    POLICY_VIEW_LOCAL_INFORMATION access to the Policy object.  Since there
    may be more information than can be returned in a single call of the
    routine, multiple calls can be made to get all of the information.  To
    support this feature, the caller is provided with a handle that can be
    used across calls to the API.  On the initial call, EnumerationContext
    should point to a variable that has been initialized to 0.  On each
    subsequent call, the value returned by the preceding call should be passed
    in unchanged.  The enumeration is complete when the warning
    STATUS_NO_MORE_ENTRIES is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    EnumerationBuffer - Pointer to an enumeration structure that will receive
        a count of the accounts enumerated on this call and a pointer to
        an array of entries containing information for each enumerated
        account.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects are enumerated because the
            EnumerationContext value passed in is too high.
--*/

{
    NTSTATUS Status;
    LSAP_DB_SID_ENUMERATION_BUFFER DbEnumerationBuffer;
    ULONG MaxLength;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarEnumerateAccounts\n" ));

    //
    // If no Enumeration Structure or index is provided, return an error.
    //

    if ( !ARGUMENT_PRESENT(EnumerationBuffer) ||
         !ARGUMENT_PRESENT(EnumerationContext)    ) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Initialize the internal Lsa Database Enumeration Buffer, and
    // the provided Enumeration Buffer to NULL.
    //

    DbEnumerationBuffer.EntriesRead = 0;
    DbEnumerationBuffer.Sids = NULL;
    EnumerationBuffer->EntriesRead = 0;
    EnumerationBuffer->Information = NULL;

    //
    // Bug #340164: anonymous users are not allowed to look at accounts
    //

    if ( LsapGlobalRestrictAnonymous &&
         PolicyHandle != NULL &&
         ((LSAP_DB_HANDLE)PolicyHandle)->Options & LSAP_DB_OPENED_BY_ANONYMOUS ) {

        return STATUS_ACCESS_DENIED;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the connection handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 PolicyObject,
                 AccountObject,
                 LSAP_DB_LOCK |
                    LSAP_DB_NO_DS_OP_TRANSACTION |
                    LSAP_DB_READ_ONLY_TRANSACTION
                 );

    if ( NT_SUCCESS( Status )) {

        //
        // Limit the enumeration length except for trusted callers
        //

        if ( !((LSAP_DB_HANDLE)PolicyHandle)->Trusted   &&
            (PreferedMaximumLength > LSA_MAXIMUM_ENUMERATION_LENGTH)
            ) {
            MaxLength = LSA_MAXIMUM_ENUMERATION_LENGTH;
        } else {
            MaxLength = PreferedMaximumLength;
        }

        //
        // Call general Sid enumeration routine.
        //
        Status = LsapDbEnumerateSids(
                     PolicyHandle,
                     AccountObject,
                     EnumerationContext,
                     &DbEnumerationBuffer,
                     MaxLength
                     );

        LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     AccountObject,
                     LSAP_DB_LOCK |
                        LSAP_DB_NO_DS_OP_TRANSACTION |
                        LSAP_DB_READ_ONLY_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );

    }

    //
    // Copy the enumerated information to the output.  We can use the
    // information actually returned by LsapDbEnumerateSids because it
    // happens to be in exactly the correct form.
    //
    EnumerationBuffer->EntriesRead = DbEnumerationBuffer.EntriesRead;
    EnumerationBuffer->Information = (PLSAPR_ACCOUNT_INFORMATION) DbEnumerationBuffer.Sids;



    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarEnumerateAccounts:0x%lx\n", Status ));

    return(Status);

}


NTSTATUS
LsarEnumeratePrivilegesAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PLSAPR_PRIVILEGE_SET *Privileges
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaEnumeratePrivilegesOfAccount API.

    The LsaEnumeratePrivilegesOfAccount API obtains information which
    describes the privileges assigned to an account.  This call requires
    ACCOUNT_VIEW access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose privilege
        information is to be obtained.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    Privileges - Receives a pointer to a buffer containing the Privilege
        Set.  The Privilege Set is an array of structures, one for each
        privilege.  Each structure contains the LUID of the privilege and
        a mask of the privilege's attributes.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    return(LsarQueryInformationAccount(
               AccountHandle,
               AccountPrivilegeInformation,
               (PLSAPR_ACCOUNT_INFO *) Privileges
               ));
}


NTSTATUS
LsarAddPrivilegesToAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN PLSAPR_PRIVILEGE_SET Privileges
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaAddPrivilegesToAccount API.

    The LsaAddPrivilegesToAccount API adds privileges and their attributes
    to an account object.  If any provided privilege is already assigned
    to the account object, the attributes of that privilege are replaced
    by the newly rpovided values.  This API call requires
    ACCOUNT_ADJUST_PRIVILEGES access to the account object.

Arguments:

    AccountHandle - The handle to the open account object to which
        privileges are to be added.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    Privileges - Points to a set of privileges (and their attributes) to
        be assigned to the account.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

--*/

{
    return LsapAddPrivilegesToAccount( AccountHandle, Privileges, TRUE );
}



NTSTATUS
LsapAddPrivilegesToAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN PLSAPR_PRIVILEGE_SET Privileges,
    IN BOOL LockSce
    )
/*++

Routine Description:

    This is the worker routine for LsarAddPrivilegesToAccount, with an added
    semantics of not locking the SCE policy.

--*/
{
    NTSTATUS Status;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsapAddPrivilegesToAccount\n" ));


    Status = LsapDbChangePrivilegesAccount( AccountHandle,
                                            AddPrivileges,
                                            FALSE,
                                            (PPRIVILEGE_SET) Privileges,
                                            LockSce );

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsapAddPrivilegesToAccount: 0x%lx\n", Status ));

    return( Status );
}


NTSTATUS
LsarRemovePrivilegesFromAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN BOOLEAN AllPrivileges,
    IN OPTIONAL PLSAPR_PRIVILEGE_SET Privileges
    )

/*++

Routine Description:

    This function is the RPC server worker routine for the
    LsaRemovePrivilegesFromAccount API.

    The LsaRemovePrivilegesFromAccount API removes privileges from an
    account object.  This API call requires ACCOUNT_ADJUST_PRIVILEGES
    access to the account object.  Note that if all privileges are removed
    from the account object, the account object remains in existence until
    deleted explicitly via a    call to the LsaDeleteAccount API.

Arguments:

    AccountHandle - The handle to the open account object to which
        privileges are to be removed.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    AllPrivileges - If TRUE, then all privileges are to be removed from
        the account.  In this case, the Privileges parameter must be
        specified as NULL.  If FALSE, the Privileges parameter specifies
        the privileges to be removed, and must be non NULL.

    Privileges - Optionally points to a set of privileges (and their
        attributes) to be removed from the account object.  The attributes
        fields of this structure are ignored.  This parameter must
        be specified as non-NULL if and only if AllPrivileges is set to
        FALSE.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

        STATUS_INVALID_PARAMETER - The optional Privileges paraemter was
            specified as NULL and AllPrivileges was set to FALSE.

--*/

{
    return LsapRemovePrivilegesFromAccount( AccountHandle, AllPrivileges, Privileges, TRUE );
}



NTSTATUS
LsapRemovePrivilegesFromAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN BOOLEAN AllPrivileges,
    IN OPTIONAL PLSAPR_PRIVILEGE_SET Privileges,
    IN BOOL LockSce
    )
/*++

Routine Description:

    This is the worker routine for LsarRemovePrivilegesFromAccount, with an added
    semantics of not locking the SCE policy.

--*/
{
    NTSTATUS Status;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsapRemovePrivilegesFromAccount\n" ));


    //
    // Verify that a meaningful combination of AllPrivileges and Privileges
    // has been specified.
    //

    if (AllPrivileges) {

        if (Privileges != NULL) {

            return STATUS_INVALID_PARAMETER;
        }

    } else {

        if (Privileges == NULL) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Remove the privileges requested.
    //

    Status = LsapDbChangePrivilegesAccount(
                 AccountHandle,
                 RemovePrivileges,
                 AllPrivileges,
                 (PPRIVILEGE_SET) Privileges,
                 LockSce
                 );

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsapRemovePrivilegesFromAccount: 0x%lx\n", Status ));

    return(Status);
}



NTSTATUS
LsapDbChangePrivilegesAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN LSAP_DB_CHANGE_PRIVILEGE_MODE ChangeMode,
    IN BOOLEAN AllPrivileges,
    IN OPTIONAL PPRIVILEGE_SET Privileges,
    IN BOOL LockSce
    )

/*++

Routine Description:

    This function changes the privileges assigned to an account.  It is
    called only by LsarAddPrivilegesToAccount and LsarRemovePrivilegesFrom-
    Account.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    AccountHandle - Handle to open Account object obtained from LsaOpenAccount.

    ChangeMode - Specifies the change mode

        AddPrivileges - Add the privileges
        RemovePrivileges - Delete the privileges

    AllPrivileges - If removing privileges from an account and this boolean
        is set to TRUE, all privileges are to be removed.  In this case,
        the Privileges parameter must be set to NULL.  In all other cases,
        AllPrivileges must be set to FALSE and Privileges must be non-NULL.

    Privileges - Specifies set of privileges to be changed.  This parameter
        must be set to NULL if and only if removing all privileges.

    LockSce - Specifies whether SCE policy should be locked or not (should be FALSE
              for situations where the caller already has it locked)

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus;
    ULONG ExistingPrivilegesSize;
    LSAPR_HANDLE SubKeyHandle = NULL;
    PPRIVILEGE_SET ExistingPrivileges = NULL;
    PPRIVILEGE_SET PrivilegesToAudit  = NULL;
    BOOLEAN TransactionAbort = FALSE;
    ULONG AuditEventId;
    PLUID_AND_ATTRIBUTES Luids = NULL;
    BOOLEAN ObjectReferenced = FALSE;
    PLSAPR_SID AccountSid = NULL;
    BOOLEAN bAudit = FALSE;
    LSAP_DB_HANDLE InternalHandle = AccountHandle;
    BOOLEAN ScePolicyLocked = FALSE;
    BOOLEAN NotifySce = FALSE;
    ULONG MaxPrivileges = 0;

#if DBG

    if( AllPrivileges ) {

        //
        // If AllPrivileges is TRUE then we must be removing privileges
        //      and Privileges must be NULL
        //
        ASSERT( ChangeMode == RemovePrivileges );
        ASSERT( Privileges == NULL );

    } else {

        //
        // If AllPrivileges is FALSE then
        //      Privileges must be non-NULL
        //
        ASSERT( Privileges != NULL );
    }

    //
    // Does ChangeMode has a valid value?
    //
    switch( ChangeMode ) {
        case AddPrivileges:
        case RemovePrivileges:
        case SetPrivileges:
            break;
        default:
            ASSERT( !"Change mode doesn't have a valid value" );
            break;
    }

#endif

    //
    // Do not grab the SCE policy lock for handles opened as SCE policy handles
    //

    if ( !InternalHandle->SceHandleChild ) {

        if ( LockSce ) {

            RtlEnterCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );
            if ( LsapDbState.ScePolicyLock.NumberOfWaitingShared > MAX_SCE_WAITING_SHARED ) {

                Status = STATUS_TOO_MANY_THREADS;
            }
            RtlLeaveCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );

            if ( !NT_SUCCESS( Status )) {

                goto ChangePrivilegesError;
            }

            WaitForSingleObject( LsapDbState.SceSyncEvent, INFINITE );
            RtlAcquireResourceShared( &LsapDbState.ScePolicyLock, TRUE );
            ASSERT( !g_ScePolicyLocked );
            ScePolicyLocked = TRUE;
        }

        NotifySce = TRUE;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the Account Object handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle and open a database transaction.
    //

    Status = LsapDbReferenceObject(
                 AccountHandle,
                 ACCOUNT_ADJUST_PRIVILEGES,
                 AccountObject,
                 AccountObject,
                 LSAP_DB_LOCK |
                    LSAP_DB_START_TRANSACTION |
                    LSAP_DB_NO_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto ChangePrivilegesError;
    }

    ObjectReferenced = TRUE;

    //
    // Query size of buffer needed for the existing Privileges.
    // Read the Account Object's Privileges data from the LSA Database
    //
    ExistingPrivilegesSize = 0;

    //
    // If we're doing a SetPrivileges and we're in registry mode, we'll just pretend we
    // have no existing privs and do an add
    //
    if ( ChangeMode == SetPrivileges ) {

        ExistingPrivileges = NULL;
        ChangeMode = AddPrivileges;

    } else {

        Status = LsapDbReadAttributeObject(
                     AccountHandle,
                     &LsapDbNames[Privilgs],
                     NULL,
                     &ExistingPrivilegesSize
                     );

        if (!NT_SUCCESS(Status)) {

            //
            // The only error permitted is STATUS_OBJECT_NAME_NOT_FOUND
            // because the account object does not have any privileges
            // assigned and has no Privilgs attribute.
            //

            if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

                goto ChangePrivilegesError;
            }

            //
            // Account has no existing privileges.
            //

            ExistingPrivileges = NULL;

        } else {

            //
            // Account already has privileges.  Allocate buffer for reading
            // the existing privilege set and read them in.
            //

            ExistingPrivileges = LsapAllocateLsaHeap( ExistingPrivilegesSize );

            if (ExistingPrivileges == NULL) {

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ChangePrivilegesError;
            }

            Status = LsapDbReadAttributeObject(
                         AccountHandle,
                         &LsapDbNames[Privilgs],
                         ExistingPrivileges,
                         &ExistingPrivilegesSize
                         );

            if (!NT_SUCCESS(Status)) {

                goto ChangePrivilegesError;
            }
        }
    }

    //
    // when caller wants to remove privileges and AllPrivileges == TRUE,
    // the passed value of Privileges is NULL. This poses a problem for
    // the auditing code as we wnat to see what privileges got removed
    // in the audit event. Therefore, in this case, make a copy of the
    // existing privileges so that we can use it later in auditing.
    //

    if (AllPrivileges && (ChangeMode == RemovePrivileges)) {

        PrivilegesToAudit = ExistingPrivileges;
        ExistingPrivileges = NULL;

    } else {

        PrivilegesToAudit = Privileges;

        //
        // Now query the size of buffer required for the updated privilege
        // set
        //

        if ( ExistingPrivileges ) {

            MaxPrivileges = ExistingPrivileges->PrivilegeCount;
        }

        if (ChangeMode == AddPrivileges) {

            BOOLEAN Changed = FALSE;

            Status = LsapRtlAddPrivileges(
                         &ExistingPrivileges,
                         &MaxPrivileges,
                         Privileges,
                         RTL_SUPERSEDE_PRIVILEGE_ATTRIBUTES,
                         &Changed
                         );

            if ( NT_SUCCESS( Status ) && !Changed ) {

                //
                // Nothing has changed, so bail
                //

                goto ChangePrivilegesFinish;
            }

        } else {

            Status = LsapRtlRemovePrivileges(
                         ExistingPrivileges,
                         Privileges
                         );
        }
    }


    //
    // If privileges remain, write the updated privilege set back to
    // the LSA Database as the value of the Privilgs attribute of the
    // account object.  If no privileges remain, delete the Privilgs
    // attribute.
    //

    if (ExistingPrivileges && (ExistingPrivileges->PrivilegeCount > 0)) {

        Status = LsapDbWriteAttributeObject(
                     AccountHandle,
                     &LsapDbNames[Privilgs],
                     ExistingPrivileges,
                     sizeof (PRIVILEGE_SET) + (ExistingPrivileges->PrivilegeCount - 1)*sizeof(LUID_AND_ATTRIBUTES)
                     );

    } else {

        Status = LsapDbDeleteAttributeObject(
                     AccountHandle,
                     &LsapDbNames[Privilgs],
                     FALSE
                     );

        //
        // The only error permitted is STATUS_OBJECT_NAME_NOT_FOUND
        // because the account object does not have any privileges
        // assigned and so has no Privilgs attribute.
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

            Status = STATUS_SUCCESS;
        }
    }

    //
    // If auditing of policy changes is enabled, generate an audit.
    //

    AccountSid = LsapDbSidFromHandle( AccountHandle );

    IgnoreStatus = LsapAdtAuditingEnabledBySid(
                       AuditCategoryPolicyChange,
                       AccountSid,
                       EVENTLOG_AUDIT_SUCCESS,
                       &bAudit
                       );

    if (NT_SUCCESS(IgnoreStatus) && bAudit &&
        PrivilegesToAudit && PrivilegesToAudit->PrivilegeCount) {

        AuditEventId = ((ChangeMode == AddPrivileges) ?
                           SE_AUDITID_USER_RIGHT_ASSIGNED :
                           SE_AUDITID_USER_RIGHT_REMOVED);

        //
        // Audit the privilege set change.  Ignore failures from Auditing.
        //

        IgnoreStatus = LsapAdtGenerateLsaAuditEvent(
                           AccountHandle,
                           SE_CATEGID_POLICY_CHANGE,
                           AuditEventId,
                           PrivilegesToAudit,
                           1,
                           (PSID *) &AccountSid,
                           0,
                           NULL,
                           NULL
                           );

    }

    //
    // Update the Account Object Cache while holding the Lsa Database Lock.
    // If the commit to backing storage below fails, caching will automatically
    // be turned off.
    //
    // NOTE: A pointer to the UpdatedPrivileges buffer will be placed directly
    // in the cached Account Object, so it should not be freed by this routine.
    //

    if (ExistingPrivileges && (ExistingPrivileges->PrivilegeCount > 0)) {

        IgnoreStatus = LsapDbUpdatePrivilegesAccount(
                           AccountSid,
                           ExistingPrivileges
                           );

        //
        // The cache takes ownership of the privileges structure, so we don't
        // want to free it.
        //
        if( NT_SUCCESS( IgnoreStatus ) ) {

            ExistingPrivileges = NULL;
        }

    } else {

        IgnoreStatus = LsapDbUpdatePrivilegesAccount(
                           AccountSid,
                           NULL
                           );
    }

ChangePrivilegesFinish:

    //
    // free the allocated privileges
    //

    if ( AllPrivileges && (ChangeMode == RemovePrivileges) && PrivilegesToAudit )
    {
        LsapFreeLsaHeap( PrivilegesToAudit );
    }

    //
    // If necessary, free the ExistingPrivileges buffer.
    //

    if (ExistingPrivileges != NULL) {

        LsapFreeLsaHeap(ExistingPrivileges);
        ExistingPrivileges = NULL;
    }

    //
    // If necessary, dereference the Account object, close the database
    // transaction, release the LSA Database lock and return.
    //

    if (ObjectReferenced) {

        IgnoreStatus = LsapDbDereferenceObject(
                           &AccountHandle,
                           AccountObject,
                           AccountObject,
                           LSAP_DB_LOCK |
                           LSAP_DB_FINISH_TRANSACTION |
                              LSAP_DB_NO_DS_OP_TRANSACTION,
                           SecurityDbChange,
                           Status
                           );
    }

    //
    // Notify SCE of the change.  Only notify for callers
    // that did not open their policy handles with LsaOpenPolicySce.
    //

    if ( NotifySce && NT_SUCCESS( Status )) {

        LsapSceNotify(
            SecurityDbChange,
            SecurityDbObjectLsaAccount,
            InternalHandle->Sid
            );
    }

    if ( ScePolicyLocked ) {

        RtlReleaseResource( &LsapDbState.ScePolicyLock );
    }

    return Status;

ChangePrivilegesError:

    goto ChangePrivilegesFinish;
}


NTSTATUS
LsarGetQuotasForAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PQUOTA_LIMITS QuotaLimits
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsarGetQuotasForAccount API.

    The LsaGetQuotasForAccount API obtains the quota limits for pageable and
    non-pageable memory (in Kilobytes) and the maximum execution time (in
    seconds) for any session logged on to the account specified by
    AccountHandle.

    Quotas is not supported any more. In the past, we need LSA_ACCOUNT_VIEW
    access to the object, but currently, there is no such access right &
    you don't need any right to call this function. We will return QuotaLimits
    as 0 and return SUCCESS.

Arguments:

    AccountHandle - The handle to the open account object whose quotas
        are to be obtained.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    QuotaLimits - Pointer to structure in which the system resource
        quota limits applicable to each session logged on to this account
        will be returned.  Note that all quotas, including those specified
        as being the system default values, are returned as actual values.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status;
    PLSAPR_ACCOUNT_INFO AccountInformation = NULL;

    LsarpReturnCheckSetup();

    //
    // Stub it out
    //
    LsapDsDebugOut(( DEB_TRACE,
                     "LsarGetQuotasForAccount has been removed.  Returning STATUS_SUCCESS anyway\n" ));

    RtlZeroMemory( QuotaLimits, sizeof( QUOTA_LIMITS ) );

    LsarpReturnPrologue();

    return( STATUS_SUCCESS );
}


NTSTATUS
LsarSetQuotasForAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN PQUOTA_LIMITS QuotaLimits
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaSetQuotasForAccount API.

    The LsaSetQuotasForAccount API sets the quota limits for pageable and
    non-pageable memory (in Kilobytes) and the maximum execution time (in
    seconds) for any session logged on to the account specified by
    AccountHandle.  For each quota an explicit value or the system default
    may be specified.

    Quotas is not supported any more. In the past, we need LSA_ACCOUNT_ADJUST_QUOTAS
    access to the account, but currently, there is no such access right &
    you don't need any right to call this function. We will return SUCCESS.

Arguments:

    AccountHandle - The handle to the open account object whose quotas
        are to be set.  This handle will have been returned from a prior
        LsaOpenAccount or LsaCreateAccountInLsa API call.

    QuotaLimits - Pointer to structure containing the system resource
        quota limits applicable to each session logged on to this account.
        A zero value specified in any field indicates that the current
        System Default Quota Limit is to be applied.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    LsarpReturnCheckSetup();

    //
    // Quotas have been disabled.
    //
    LsapDsDebugOut(( DEB_TRACE,
                     "LsarSetQuotasForAccount has been removed: Returning STATUS_SUCCESS anyway\n" ));

    return( STATUS_SUCCESS );
}


NTSTATUS
LsarGetSystemAccessAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PULONG SystemAccess
    )

/*++

Routine Description:

    The LsaGetSystemAccessAccount() service returns the System Access
    account flags for an Account object.

Arguments:

    AccountHandle - The handle to the Account object whose system access
        flags are to be read.  This handle will have been returned
        from a preceding LsaOpenAccount() or LsaCreateAccount() call
        an must be open for ACCOUNT_VIEW access.

    SystemAccess - Points to location that will receive the system access
        flags for the account.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call was successful.

        STATUS_ACCESS_DENIED - The AccountHandle does not specify
            ACCOUNT_VIEW access.

        STATUS_INVALID_HANDLE - The specified AccountHandle is invalid.

--*/

{
    NTSTATUS Status;
    PLSAPR_ACCOUNT_INFO AccountInformation = NULL;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarGetSystemAccessAccount\n" ));


    Status = LsarQueryInformationAccount(
                 AccountHandle,
                 AccountSystemAccessInformation,
                 &AccountInformation
                 );

    if (!NT_SUCCESS(Status)) {

        goto GetSystemAccessAccountError;
    }

    *SystemAccess = *((PULONG) AccountInformation);

GetSystemAccessAccountFinish:

    //
    // If necessary, free the buffer in which the Account Information was
    // returned.
    //

    if (AccountInformation != NULL) {

        MIDL_user_free( AccountInformation );
        AccountInformation = NULL;
    }

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarGetSystemAccessAccount: 0x%lx\n", Status ));

    return(Status);

GetSystemAccessAccountError:

    *SystemAccess = 0;
    goto GetSystemAccessAccountFinish;
}


NTSTATUS
LsarSetSystemAccessAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ULONG SystemAccess
    )

/*++

Routine Description:

    The LsaSetSystemAccessAccount() service sets the System Access
    account flags for an Account object.

Arguments:

    AccountHandle - The handle to the Account object whose system access
        flags are to be read.  This handle will have been returned
        from a preceding LsaOpenAccount() or LsaCreateAccount() call
        an must be open for ACCOUNT_ADJUST_SYSTEM_ACCESS access.

    SystemAccess - A mask of the system access flags to assign to the
        Account object.  The valid access flags include:

        POLICY_MODE_INTERACTIVE - Account can be accessed interactively

        POLICY_MODE_NETWORK - Account can be accessed remotely

        POLICY_MODE_SERVICE - TBS

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call was successful.

        STATUS_ACCESS_DENIED - The AccountHandle does not specify
            ACCOUNT_VIEW access.

        STATUS_INVALID_HANDLE - The specified AccountHandle is invalid.

        STATUS_INVALID_PARAMETER - The specified Access Flags are invalid.
--*/

{
    return LsapSetSystemAccessAccount( AccountHandle, SystemAccess, TRUE );
}



NTSTATUS
LsapSetSystemAccessAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ULONG SystemAccess,
    IN BOOL LockSce
    )
/*++

Routine Description:

    This is the worker routine for LsarSetSystemAccessAccount, with an added
    semantics of not locking the SCE policy.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus;
    BOOLEAN ObjectReferenced = FALSE;
    PLSAPR_SID AccountSid = NULL;
    LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )AccountHandle;
    BOOLEAN ScePolicyLocked = FALSE;
    BOOLEAN NotifySce = FALSE;
    PLSAPR_ACCOUNT_INFO pAccountInfo = NULL;
    LONG i;
    BOOLEAN bObtainedPreviousAccountInfo = TRUE;
    BOOLEAN bAudit = FALSE;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarSetSystemAccessAccount\n" ));


    //
    // Verify that the specified flags are valid
    //


    if (SystemAccess != (SystemAccess & (POLICY_MODE_ALL))) {

        Status = STATUS_INVALID_PARAMETER;
        goto SetSystemAccessAccountError;
    }

    //
    // Do not grab the SCE policy lock for handles opened as SCE policy handles
    //

    if ( !InternalHandle->SceHandleChild ) {

        if ( LockSce ) {

            RtlEnterCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );
            if ( LsapDbState.ScePolicyLock.NumberOfWaitingShared > MAX_SCE_WAITING_SHARED ) {

                Status = STATUS_TOO_MANY_THREADS;
            }
            RtlLeaveCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );

            if ( !NT_SUCCESS( Status )) {

                goto SetSystemAccessAccountError;
            }

            WaitForSingleObject( LsapDbState.SceSyncEvent, INFINITE );
            RtlAcquireResourceShared( &LsapDbState.ScePolicyLock, TRUE );
            ASSERT( !g_ScePolicyLocked );
            ScePolicyLocked = TRUE;
        }

        NotifySce = TRUE;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the Account Object handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle and open a database transaction.
    //

    Status = LsapDbReferenceObject(
                 AccountHandle,
                 ACCOUNT_ADJUST_SYSTEM_ACCESS,
                 AccountObject,
                 AccountObject,
                 LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetSystemAccessAccountError;
    }

    ObjectReferenced = TRUE;

    //
    // Record the previous access flags for auditing.
    //
    
    bObtainedPreviousAccountInfo = FALSE;
    
    if( LsapDbIsCacheValid( AccountObject ) ) {

        Status = LsapDbQueryInformationAccount(
                     AccountHandle,
                     AccountSystemAccessInformation,
                     &pAccountInfo
                     );

        if( NT_SUCCESS( Status ) ) {

            bObtainedPreviousAccountInfo = TRUE;
        }
    }
    
    //
    // Write the System Access flags
    //
    Status = LsapDbWriteAttributeObject(
                 AccountHandle,
                 &LsapDbNames[ActSysAc],
                 &SystemAccess,
                 sizeof (ULONG)
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetSystemAccessAccountError;
    }

    AccountSid = LsapDbSidFromHandle( AccountHandle );

    //
    // Update the Account Object Cache while holding the Lsa Database Lock.
    // If the commit to backing storage below fails, caching will automatically
    // be turned off.
    //

    IgnoreStatus = LsapDbUpdateSystemAccessAccount(
                       AccountSid,
                       &SystemAccess
                       );

    //
    // If auditing of policy changes is enabled, generate an audit.
    //

    IgnoreStatus = LsapAdtAuditingEnabledBySid(
                      AuditCategoryPolicyChange,
                      AccountSid,
                      EVENTLOG_AUDIT_SUCCESS,
                      &bAudit
                      );

    if (bObtainedPreviousAccountInfo && NT_SUCCESS(IgnoreStatus) && bAudit) {

        //
        // Audit the system access change.  Ignore failures from Auditing.
        //

        NTSTATUS Status2 = STATUS_SUCCESS;
        LUID ClientAuthenticationId;
        PTOKEN_USER TokenUserInformation;
        PSID ClientSid;

        PWCHAR GrantedAccess[11];
        LONG GrantedAccessCount = 0;
        ULONG GrantedAccessMask = 0;

        PWCHAR RemovedAccess[11];
        LONG RemovedAccessCount = 0;
        ULONG RemovedAccessMask = 0;

        USHORT EventType = EVENTLOG_AUDIT_SUCCESS;

        //
        // Determine the rights that were enabled.
        //

        GrantedAccessMask = (pAccountInfo != NULL ) ? SystemAccess & (~pAccountInfo->AccountSystemAccessInfo) : SystemAccess;

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_INTERACTIVE)) {
            GrantedAccess[GrantedAccessCount++] = SE_INTERACTIVE_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_NETWORK)) {
            GrantedAccess[GrantedAccessCount++] = SE_NETWORK_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_BATCH)) {
            GrantedAccess[GrantedAccessCount++] = SE_BATCH_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_SERVICE)) {
            GrantedAccess[GrantedAccessCount++] = SE_SERVICE_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_REMOTE_INTERACTIVE)) {
            GrantedAccess[GrantedAccessCount++] = SE_REMOTE_INTERACTIVE_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_DENY_INTERACTIVE)) {
            GrantedAccess[GrantedAccessCount++] = SE_DENY_INTERACTIVE_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_DENY_NETWORK)) {
            GrantedAccess[GrantedAccessCount++] = SE_DENY_NETWORK_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_DENY_BATCH)) {
            GrantedAccess[GrantedAccessCount++] = SE_DENY_BATCH_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_DENY_SERVICE)) {
            GrantedAccess[GrantedAccessCount++] = SE_DENY_SERVICE_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_DENY_REMOTE_INTERACTIVE)) {
            GrantedAccess[GrantedAccessCount++] = SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME;
        }

        //
        // Determine the rights which were turned off.
        //

        RemovedAccessMask = (pAccountInfo != NULL) ? pAccountInfo->AccountSystemAccessInfo & (~SystemAccess) : SystemAccess;

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_INTERACTIVE)) {
            RemovedAccess[RemovedAccessCount++] = SE_INTERACTIVE_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_NETWORK)) {
            RemovedAccess[RemovedAccessCount++] = SE_NETWORK_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_BATCH)) {
            RemovedAccess[RemovedAccessCount++] = SE_BATCH_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_SERVICE)) {
            RemovedAccess[RemovedAccessCount++] = SE_SERVICE_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_REMOTE_INTERACTIVE)) {
            RemovedAccess[RemovedAccessCount++] = SE_REMOTE_INTERACTIVE_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_DENY_INTERACTIVE)) {
            RemovedAccess[RemovedAccessCount++] = SE_DENY_INTERACTIVE_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_DENY_NETWORK)) {
            RemovedAccess[RemovedAccessCount++] = SE_DENY_NETWORK_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_DENY_BATCH)) {
            RemovedAccess[RemovedAccessCount++] = SE_DENY_BATCH_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_DENY_SERVICE)) {
            RemovedAccess[RemovedAccessCount++] = SE_DENY_SERVICE_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_DENY_REMOTE_INTERACTIVE)) {
            RemovedAccess[RemovedAccessCount++] = SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME;
        }

        Status2 = LsapQueryClientInfo(
                     &TokenUserInformation,
                     &ClientAuthenticationId
                     );

        if ( NT_SUCCESS( Status2 )) {

            //
            // We can't generate an audit without a
            // user Sid.
            //

            ClientSid = TokenUserInformation->User.Sid;

            //
            // Audit any granted system access rights
            //

            for (i = 0; i < GrantedAccessCount; i++) {
                LsapAdtGenerateLsaAuditSystemAccessChange(
                             SE_CATEGID_POLICY_CHANGE,
                             SE_AUDITID_SYSTEM_ACCESS_GRANTED,
                             EventType,
                             ClientSid,
                             ClientAuthenticationId,
                             AccountSid,
                             GrantedAccess[i]
                             );
            }

            //
            // Audit any removed system access rights
            //

            for (i = 0; i < RemovedAccessCount; i++) {
                LsapAdtGenerateLsaAuditSystemAccessChange(
                             SE_CATEGID_POLICY_CHANGE,
                             SE_AUDITID_SYSTEM_ACCESS_REMOVED,
                             EventType,
                             ClientSid,
                             ClientAuthenticationId,
                             AccountSid,
                             RemovedAccess[i]
                             );
            }

            LsapFreeLsaHeap( TokenUserInformation );
        }
    }

SetSystemAccessAccountFinish:

    if (NULL != pAccountInfo) {
        LsaFreeMemory(pAccountInfo);
    }

    //
    // If necessary, dereference the Account object, close the database
    // transaction, notify the LSA Database Replicator of the change,
    // release the LSA Database lock and return.
    //

    if (ObjectReferenced) {

        LsapDbDereferenceObject(
                     &AccountHandle,
                     AccountObject,
                     AccountObject,
                     LSAP_DB_LOCK | LSAP_DB_FINISH_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION,
                     SecurityDbChange,
                     Status
                     );
    }

    //
    // Notify SCE of the change.  Only notify for callers
    // that did not open their policy handles with LsaOpenPolicySce.
    //

    if ( NotifySce && NT_SUCCESS( Status )) {

        LsapSceNotify(
            SecurityDbChange,
            SecurityDbObjectLsaAccount,
            AccountSid
            );
    }

    if ( ScePolicyLocked ) {

        RtlReleaseResource( &LsapDbState.ScePolicyLock );
    }

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarSetSystemAccessAccount: 0x%lx\n", Status ));

    return(Status);

SetSystemAccessAccountError:

    goto SetSystemAccessAccountFinish;
}


NTSTATUS
LsarQueryInformationAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ACCOUNT_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_ACCOUNT_INFO *AccountInformation
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    (as yet non-existent) LsarQueryInformationAccount API.  Currently,
    LsarGet...Account() API call this routine.  In the future, this
    routine may be added as an API.

    The LsaQueryInformationAccount API obtains information from the Policy
    object.  The caller must have access appropriate to the information
    being requested (see InformationClass parameter).

Arguments:

    AccountHandle - Handle from an LsaOpenAccount call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        AccountPrivilegeInformation       ACCOUNT_VIEW
        AccountQuotaInformation           ACCOUNT_VIEW
        AccountSystemAccessInformation    ACCOUNT_VIEW

    AccountInformation - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INTERNAL_DB_CORRUPTION - The Policy Database is possibly
            corrupt.  The returned Policy Information is invalid for
            the given class.
--*/

{
    NTSTATUS Status;
    PLSAP_DB_ACCOUNT Account = NULL;
    PLSAPR_ACCOUNT_INFO CachedAccountInformation = NULL;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarQueryInformationAccount\n" ));


    //
    // Acquire the Lsa Database lock.  Verify that the Account Object handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 AccountHandle,
                 ACCOUNT_VIEW,
                 AccountObject,
                 AccountObject,
                 LSAP_DB_LOCK |
                    LSAP_DB_NO_DS_OP_TRANSACTION |
                    LSAP_DB_READ_ONLY_TRANSACTION
                 );

    if (NT_SUCCESS(Status)) {


        if (LsapDbIsCacheValid(AccountObject)) {

            Status = LsapDbQueryInformationAccount(
                         AccountHandle,
                         InformationClass,
                         AccountInformation
                         );

        } else {

            Status = LsapDbSlowQueryInformationAccount(
                         AccountHandle,
                         InformationClass,
                         AccountInformation
                         );
        }

        Status = LsapDbDereferenceObject(
                     &AccountHandle,
                     AccountObject,
                     AccountObject,
                     LSAP_DB_LOCK |
                        LSAP_DB_NO_DS_OP_TRANSACTION |
                        LSAP_DB_READ_ONLY_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarQueryInformationAccount: 0x%lx\n", Status ));

    return(Status);

}


NTSTATUS
LsapDbQueryInformationAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ACCOUNT_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_ACCOUNT_INFO *AccountInformation
    )

/*++

Routine Description:

    This function is the fast LSA server RPC worker routine for the
    (as yet non-existent) LsarQueryInformationAccount API.  It is called
    when the in-memory Account List is valid.

Arguments:

    AccountHandle - Handle from an LsaOpenAccount call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        AccountPrivilegeInformation       ACCOUNT_VIEW
        AccountQuotaInformation           ACCOUNT_VIEW
        AccountSystemAccessInformation    ACCOUNT_VIEW

    AccountInformation - Receives a pointer to the buffer returned containing
        the requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INTERNAL_DB_CORRUPTION - The Policy Database is possibly
            corrupt.  The returned Policy Information is invalid for
            the given class.
--*/

{
    NTSTATUS Status;
    PLSAP_DB_ACCOUNT Account = NULL;
    ULONG AccountInformationLength = 0;
    PLSAPR_ACCOUNT_INFO CachedAccountInformation = NULL;
    ULONG PrivilegesCount;
    PLSAPR_PRIVILEGE_SET OutputPrivilegeSet = NULL;


    ASSERTMSG( "Account Cache is not valid!", LsapDbIsCacheValid( AccountObject ) );

    (*AccountInformation) = NULL;

    //
    // Lookup the Account.
    //

    Status = LsapDbLookupAccount(
                 LsapDbSidFromHandle( AccountHandle ),
                 &Account
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryInformationAccountError;
    }

    //
    // Branch on Information Class.
    //

    switch (InformationClass) {

    case AccountPrivilegeInformation:

        //
        // Calculate size of buffer needed for the output privilege set.
        //

        PrivilegesCount = 0;

        if (Account->Info.PrivilegeSet != NULL) {

            PrivilegesCount = Account->Info.PrivilegeSet->PrivilegeCount;
        }

        AccountInformationLength = sizeof(PRIVILEGE_SET) +
            (PrivilegesCount * sizeof(LUID_AND_ATTRIBUTES)) -
            (sizeof(LUID_AND_ATTRIBUTES));

        CachedAccountInformation = (PLSAPR_ACCOUNT_INFO) Account->Info.PrivilegeSet;
        break;

    case AccountQuotaInformation:

        //
        // Calculate size of buffer needed for the output privilege set.
        //

        AccountInformationLength = sizeof(QUOTA_LIMITS);
        CachedAccountInformation = (PLSAPR_ACCOUNT_INFO) &Account->Info.QuotaLimits;
        break;

    case AccountSystemAccessInformation:

        //
        // Calculate size of buffer needed for the output privilege set.
        //

        AccountInformationLength = sizeof(ULONG);
        CachedAccountInformation = (PLSAPR_ACCOUNT_INFO) &Account->Info.SystemAccess;
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto QueryInformationAccountError;
    }

    //
    // Allocate output buffer.
    //

    *AccountInformation = MIDL_user_allocate( AccountInformationLength );

    if (*AccountInformation == NULL) {

        Status = STATUS_NO_MEMORY;
        goto QueryInformationAccountError;
    }

    //
    // Copy the data requested if the cached information is non-NULL.
    //

    if (CachedAccountInformation != NULL) {

        RtlCopyMemory(
            *AccountInformation,
            CachedAccountInformation,
            AccountInformationLength
            );

        goto QueryInformationAccountFinish;
    }

    //
    // The cached information is NULL.  The only information class for which
    // this can happen is AccountPrivilegeInformation, since this is the
    // only class for which a pointer is kept rather than in-structure data.
    //

    if (InformationClass == AccountPrivilegeInformation) {

        OutputPrivilegeSet = (PLSAPR_PRIVILEGE_SET) *AccountInformation;
        OutputPrivilegeSet->PrivilegeCount = 0;
        OutputPrivilegeSet->Control = 0;

    } else {

        Status = STATUS_INTERNAL_DB_CORRUPTION;
    }

    if (!NT_SUCCESS(Status)) {

        goto QueryInformationAccountError;
    }

QueryInformationAccountFinish:

    return(Status);

QueryInformationAccountError:

    if (*AccountInformation) {
        MIDL_user_free(*AccountInformation);
    }
    (*AccountInformation) = NULL;
    goto QueryInformationAccountFinish;
}


NTSTATUS
LsapDbSlowQueryInformationAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ACCOUNT_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_ACCOUNT_INFO *Buffer
    )

/*++

Routine Description:

    This function is the slow LSA server RPC worker routine for the
    (as yet non-existent) LsarQueryInformationAccount API.  It is called
    when the in-memory Account List is valid.

Arguments:

    AccountHandle - Handle from an LsaOpenAccount call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        AccountPrivilegeInformation       ACCOUNT_VIEW
        AccountQuotaInformation           ACCOUNT_VIEW
        AccountSystemAccessInformation    ACCOUNT_VIEW

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INTERNAL_DB_CORRUPTION - The Policy Database is possibly
            corrupt.  The returned Policy Information is invalid for
            the given class.
--*/

{
    NTSTATUS Status;
    QUOTA_LIMITS QuotaLimits;
    ULONG SystemAccess;
    PLSAPR_ACCOUNT_INFO OutputBuffer = NULL;

    //
    // Branch on Information Class.
    //

    switch (InformationClass) {

    case AccountPrivilegeInformation:

        Status = LsapDbSlowQueryPrivilegesAccount(
                     AccountHandle,
                     (PLSAPR_PRIVILEGE_SET *) &OutputBuffer
                     );
        break;

    case AccountQuotaInformation:

        Status = LsapDbSlowQueryQuotasAccount(
                     AccountHandle,
                     &QuotaLimits
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        OutputBuffer = MIDL_user_allocate( sizeof(QUOTA_LIMITS));

        if (OutputBuffer == NULL) {

            Status = STATUS_NO_MEMORY;
            break;
        }

        *((PQUOTA_LIMITS) OutputBuffer) = QuotaLimits;
        break;

    case AccountSystemAccessInformation:

        Status = LsapDbSlowQuerySystemAccessAccount(
                     AccountHandle,
                     &SystemAccess
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        OutputBuffer = MIDL_user_allocate( sizeof(ULONG));

        if (OutputBuffer == NULL) {

            Status = STATUS_NO_MEMORY;
            break;
        }

        *((PULONG) OutputBuffer) = SystemAccess;
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto SlowQueryInformationAccountError;
    }

    *Buffer = OutputBuffer;

SlowQueryInformationAccountFinish:

    return(Status);

SlowQueryInformationAccountError:

    *Buffer = NULL;
    goto SlowQueryInformationAccountFinish;
}


NTSTATUS
LsapDbQueryAllInformationAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PLSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO AccountInfo
    )

/*++

Routine Description:

    This routine:

        1) Gets all privileges assigned to the user (or any group/alias
           the user is a member of).

        2) Establishes the quotas assigned to the user.  This is the
           maximum of the system default quotas or any quotas assigned
           to the user (or any group/alias the user is a member of).

        3) Gets all the System Accesses assigned to the user.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.  The handle must
        have POLICY_VIEW_LOCAL_INFORMATION access granted.

    IdCount - Indicates the number of IDs being provided in the Ids array.

    Ids - Points to an array of SIDs.

    AccountInfo - Pointer to buffer that will receive the Account information
        comprising its Privilege Set, System Access Flags and Quotas.

Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_LOGON_TYPE_NOT_GRANTED - Indicates the specified type of logon
        has not been granted to any of the IDs in the passed set.
--*/

{
    NTSTATUS Status;
    BOOLEAN ObjectReferenced = FALSE;
    PPRIVILEGE_SET RunningPrivileges = NULL;
    ULONG          MaxRunningPrivileges = 0;

    PPRIVILEGE_SET NextPrivileges = NULL;
    ULONG RunningSystemAccess;
    QUOTA_LIMITS NextQuotaLimits;
    QUOTA_LIMITS RunningQuotaLimits;
    PQUOTA_LIMITS PolicyDefaultQuotaLimits = NULL;
    PPOLICY_DEFAULT_QUOTA_INFO PolicyDefaultQuotaInfo = NULL;
    ULONG SidIndex;
    PLSAP_DB_ACCOUNT Account = NULL;

    //
    // If we are unable to use the Account List, use the slow method
    // for querying Privileges and Quotas
    //

    if (!LsapDbIsCacheValid(AccountObject)) {

        return(LsapDbSlowQueryAllInformationAccounts(
                   PolicyHandle,
                   IdCount,
                   Ids,
                   AccountInfo
                   ));
    }

    //
    // The Account List is valid.  We'll use it instead of opening individual
    // Account objects.  Verify that the Policy Handle is valid, is the handle
    // object and has the necessary access granted.  Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 PolicyObject,
                 AccountObject,
                 LSAP_DB_LOCK | LSAP_DB_NO_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryAllInformationAccountsError;
    }

    ObjectReferenced = TRUE;

    //
    // Obtain the Master Default Quota Limits from the Policy Object.  If
    // the Policy Object is cached (partially for now) instruct the query
    // routine to just copy the data.

    PolicyDefaultQuotaLimits = &RunningQuotaLimits;

    Status = LsapDbQueryInformationPolicy(
                 PolicyHandle,
                 PolicyDefaultQuotaInformation,
                 (PLSAPR_POLICY_INFORMATION *) &PolicyDefaultQuotaLimits
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryAllInformationAccountsError;
    }

    //
    // Iterate through all of the Sids provided.  For each one, check if the
    // Sid is that of an Account object in the local LSA.  If it is,
    //
    // (1)  Obtain the System Accesses and add those found so far.
    // (2)  Obtain the Account Privileges and add to those found so far.
    // (3)  Obtain the Quota Limits (if any) assigned to the account.
    //      Compare these with the quota limits obtained so far.  If any
    //      limits are more generous than the running values, update
    //      the running values.
    //

    RunningSystemAccess = 0;

    for( SidIndex = 0; SidIndex < IdCount; SidIndex++) {

        //
        // Locate the Account information block for this Sid.
        //

        Status = LsapDbLookupAccount( Ids[SidIndex].Sid, &Account );

        if (!NT_SUCCESS(Status)) {

            if (Status == STATUS_NO_SUCH_USER) {

                Status = STATUS_SUCCESS;
                continue;
            }

            break;
        }

        //
        // We have found the Account information.  Add in the System Accesses
        // for this account.
        //

        RunningSystemAccess |= Account->Info.SystemAccess;

        //
        // Obtain the account's Special privileges.
        //

        NextPrivileges = Account->Info.PrivilegeSet;

        //
        // Add the Privileges of this account (if any) to the running set.
        //

        if (NextPrivileges != NULL) {

            Status = LsapRtlAddPrivileges(
                         &RunningPrivileges,
                         &MaxRunningPrivileges,
                         NextPrivileges,
                         RTL_COMBINE_PRIVILEGE_ATTRIBUTES,
                         NULL // don't care if the set has changed or not
                         );

            if (!NT_SUCCESS(Status)) {

                goto QueryAllInformationAccountsError;
            }
        }

        //
        // Obtain the special Quota Limits for this account (if any).
        //

        RtlMoveMemory(&NextQuotaLimits, &Account->Info.QuotaLimits, sizeof(QUOTA_LIMITS));

        //
        // Special Quota Limits are assigned.  Compare each of the quota
        // limits obtained with the running values.  If a quota limit just
        // obtained is less restrictive than the running value, supersede the
        // running value.
        //

        if (RunningQuotaLimits.PagedPoolLimit < NextQuotaLimits.PagedPoolLimit) {

            RunningQuotaLimits.PagedPoolLimit = NextQuotaLimits.PagedPoolLimit;
        }

        if (RunningQuotaLimits.NonPagedPoolLimit < NextQuotaLimits.NonPagedPoolLimit) {

            RunningQuotaLimits.NonPagedPoolLimit = NextQuotaLimits.NonPagedPoolLimit;
        }

        if (RunningQuotaLimits.MinimumWorkingSetSize > NextQuotaLimits.MinimumWorkingSetSize) {

            RunningQuotaLimits.MinimumWorkingSetSize = NextQuotaLimits.MinimumWorkingSetSize;
        }

        if (RunningQuotaLimits.MaximumWorkingSetSize < NextQuotaLimits.MaximumWorkingSetSize) {

            RunningQuotaLimits.MaximumWorkingSetSize = NextQuotaLimits.MaximumWorkingSetSize;
        }

        if (RunningQuotaLimits.PagefileLimit < NextQuotaLimits.PagefileLimit) {

            RunningQuotaLimits.PagefileLimit = NextQuotaLimits.PagefileLimit;
        }

        if (RunningQuotaLimits.TimeLimit.QuadPart < NextQuotaLimits.TimeLimit.QuadPart) {

            RunningQuotaLimits.TimeLimit = NextQuotaLimits.TimeLimit;
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto QueryAllInformationAccountsError;
    }

    //
    // Return the collective Privilege Set
    //

    AccountInfo->PrivilegeSet = RunningPrivileges;

    //
    // Return the collective System Accesses

    AccountInfo->SystemAccess = RunningSystemAccess;

    //
    // Return the collective Quota Limits
    //

    AccountInfo->QuotaLimits = RunningQuotaLimits;

QueryAllInformationAccountsFinish:

    //
    // If necessary, dereference the Policy Object.
    //

    if (ObjectReferenced) {

        LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     AccountObject,
                     LSAP_DB_LOCK | LSAP_DB_NO_DS_OP_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    return(Status);

QueryAllInformationAccountsError:

    //
    // If necessary, free the memory allocated for the Privilege Set.
    //

    if (RunningPrivileges != NULL) {

        MIDL_user_free( RunningPrivileges );
        RunningPrivileges = NULL;
    }



    //
    // Return null values
    //

    RtlZeroMemory( &AccountInfo->QuotaLimits, sizeof(QUOTA_LIMITS) );
    AccountInfo->SystemAccess = 0;
    AccountInfo->PrivilegeSet = NULL;
    goto QueryAllInformationAccountsFinish;
}


NTSTATUS
LsapDbSlowQueryAllInformationAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PLSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO AccountInfo
    )

/*++

Routine Description:

    This routine is the slow version of LsapDbQueryInformation().
    It is called when the Account List is not available, and assembles the
    necessary information from the Policy Database.

    This routine:

        1) Gets all privileges assigned to the user (or any group/alias
           the user is a member of).

        2) Establishes the quotas assigned to the user.  This is the
           maximum of the system default quotas or any quotas assigned
           to the user (or any group/alias the user is a member of).

        3) Gets all the System Accesses assigned to the user.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.  The handle must
        have POLICY_VIEW_LOCAL_INFORMATION access granted.

    IdCount - Indicates the number of IDs being provided in the Ids array.

    Ids - Points to an array of SIDs.

    AccountInfo - Pointer to buffer that will receive the Account information
        comprising its Privilege Set, System Access Flags and Quotas.

Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_LOGON_TYPE_NOT_GRANTED - Indicates the specified type of logon
        has not been granted to any of the IDs in the passed set.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS LocalStatus;
    BOOLEAN ObjectReferenced = FALSE;
    PPRIVILEGE_SET RunningPrivileges = NULL;
    ULONG          MaxRunningPrivileges = 0;
    PPRIVILEGE_SET NextPrivileges = NULL;

    ULONG RunningSystemAccess;
    QUOTA_LIMITS NextQuotaLimits;
    QUOTA_LIMITS RunningQuotaLimits;
    PQUOTA_LIMITS PointerToNextQuotaLimits = NULL;
    PQUOTA_LIMITS PolicyDefaultQuotaLimits = NULL;
    ULONG SidIndex;
    LSAPR_HANDLE AccountHandle = NULL;
    PULONG SystemAccessThisId = NULL;

    //
    // Verify that the Policy Handle is valid, is the handle to the Policy
    // object and has the necessary access granted.  Reference the handle.
    // Note that the Lsa Database lock is NOT held at this point.  Instead,
    // the lock is taken and released by called routines where required.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 PolicyObject,
                 AccountObject,
                 LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION |
                    LSAP_DB_NO_DS_OP_TRANSACTION | LSAP_DB_READ_ONLY_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto SlowQueryAllInformationAccountsError;
    }

    ObjectReferenced = TRUE;

    PolicyDefaultQuotaLimits = &RunningQuotaLimits;

    //
    // Obtain the Master Default Quota Limits from the Policy Object.
    //

    Status = LsapDbQueryInformationPolicy(
                 LsapPolicyHandle,
                 PolicyDefaultQuotaInformation,
                 (PLSAPR_POLICY_INFORMATION *) &PolicyDefaultQuotaLimits
                 );

    if (!NT_SUCCESS(Status)) {

        goto SlowQueryAllInformationAccountsError;
    }

    //
    // Iterate through all of the Sids provided.  For each one, check if the
    // Sid is that of an Account object in the local LSA.  If it is,
    //
    // (1)  Obtain the System Accesses and add those found so far.
    // (2)  Obtain the Account Privileges and add to thosde found so far.
    // (3)  Obtain the Quota Limits (if any) assigned to the account.
    //      Compare these with the quota limits obtained so far.  If any
    //      limits are more generous than the running values, update
    //      the running values.
    //

    RunningSystemAccess = 0;

    for( SidIndex = 0; SidIndex < IdCount; SidIndex++) {

        //
        // Attempt to open an Lsa Account object specifying the next Sid.
        // If successful, the open returns a Trusted handle to the account.
        //

        Status = LsarOpenAccount(
                     PolicyHandle,
                     Ids[SidIndex].Sid,
                     ACCOUNT_VIEW,
                     (LSAPR_HANDLE *) &AccountHandle
                     );

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

                break;
            }

            Status = STATUS_SUCCESS;
            continue;
        }

        //
        // An account object has been successfully opened.  Obtain
        // its system accesses.
        //

        Status = LsapDbSlowQueryInformationAccount(
                     AccountHandle,
                     AccountSystemAccessInformation,
                     (PLSAPR_ACCOUNT_INFO *) &SystemAccessThisId
                     );

        if (!NT_SUCCESS(Status)) {

            goto SlowQueryAllInformationAccountsError;
        }

        RunningSystemAccess |= *SystemAccessThisId;
        MIDL_user_free(SystemAccessThisId);
        SystemAccessThisId = NULL;

        //
        // Obtain the account's Special privileges.
        //

        ASSERT( NextPrivileges == NULL );
        Status = LsapDbSlowQueryInformationAccount(
                     AccountHandle,
                     AccountPrivilegeInformation,
                     (PLSAPR_ACCOUNT_INFO *) &NextPrivileges
                     );

        if (!NT_SUCCESS(Status)) {

            goto SlowQueryAllInformationAccountsError;
        }

        //
        // Add the Privileges of this account (if any) to the running set.
        //

        if (NextPrivileges != NULL) {

            Status = LsapRtlAddPrivileges(
                         &RunningPrivileges,
                         &MaxRunningPrivileges,
                         NextPrivileges,
                         RTL_COMBINE_PRIVILEGE_ATTRIBUTES,
                         NULL // don't care if the set has changed or not
                         );

            MIDL_user_free(NextPrivileges);
            NextPrivileges = NULL;

            if (!NT_SUCCESS(Status))  {

                goto SlowQueryAllInformationAccountsError;
            }
        }

        //
        // Obtain the special Quota Limits for this account (if any).
        //

        Status = LsapDbSlowQueryInformationAccount(
                     AccountHandle,
                     AccountQuotaInformation,
                     (PLSAPR_ACCOUNT_INFO *) &PointerToNextQuotaLimits
                     );

        if (Status == STATUS_NO_QUOTAS_FOR_ACCOUNT) {

            LocalStatus = LsapCloseHandle( &AccountHandle, STATUS_SUCCESS );
            continue;
        }

        if (!NT_SUCCESS(Status)) {

            goto SlowQueryAllInformationAccountsError;
        }

        NextQuotaLimits = *PointerToNextQuotaLimits;
        MIDL_user_free(PointerToNextQuotaLimits);
        PointerToNextQuotaLimits = NULL;

        //
        // Special Quota Limits are assigned.  Compare each of the quota
        // limits obtained with the running values.  If a quota limit just
        // obtained is less restrictive than the running value, supersede the
        // running value.
        //

        if (RunningQuotaLimits.PagedPoolLimit < NextQuotaLimits.PagedPoolLimit) {

            RunningQuotaLimits.PagedPoolLimit = NextQuotaLimits.PagedPoolLimit;
        }

        if (RunningQuotaLimits.NonPagedPoolLimit < NextQuotaLimits.NonPagedPoolLimit) {

            RunningQuotaLimits.NonPagedPoolLimit = NextQuotaLimits.NonPagedPoolLimit;
        }

        if (RunningQuotaLimits.MinimumWorkingSetSize > NextQuotaLimits.MinimumWorkingSetSize) {

            RunningQuotaLimits.MinimumWorkingSetSize = NextQuotaLimits.MinimumWorkingSetSize;
        }

        if (RunningQuotaLimits.MaximumWorkingSetSize < NextQuotaLimits.MaximumWorkingSetSize) {

            RunningQuotaLimits.MaximumWorkingSetSize = NextQuotaLimits.MaximumWorkingSetSize;
        }

        if (RunningQuotaLimits.PagefileLimit < NextQuotaLimits.PagefileLimit) {

            RunningQuotaLimits.PagefileLimit = NextQuotaLimits.PagefileLimit;
        }

        if (RunningQuotaLimits.TimeLimit.QuadPart < NextQuotaLimits.TimeLimit.QuadPart) {

            RunningQuotaLimits.TimeLimit = NextQuotaLimits.TimeLimit;
        }

        //
        // Close the account handle
        //

        LocalStatus = LsapCloseHandle( &AccountHandle, STATUS_SUCCESS );
    }

    if (!NT_SUCCESS(Status)) {

        goto SlowQueryAllInformationAccountsError;
    }

    //
    // Return the collective Privilege Set
    //

    AccountInfo->PrivilegeSet = RunningPrivileges;

    //
    // Return the collective System Accesses

    AccountInfo->SystemAccess = RunningSystemAccess;

    //
    // Return the collective Quota Limits
    //

    AccountInfo->QuotaLimits = RunningQuotaLimits;

SlowQueryAllInformationAccountsFinish:

    if ( NextPrivileges != NULL ) {
        MIDL_user_free( NextPrivileges );
    }

    //
    // If necessary, dereference the Policy Object.
    //

    if (ObjectReferenced) {

        LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     AccountObject,
                     LSAP_DB_LOCK | LSAP_DB_FINISH_TRANSACTION |
                            LSAP_DB_NO_DS_OP_TRANSACTION | LSAP_DB_READ_ONLY_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    return(Status);

SlowQueryAllInformationAccountsError:

    //
    // If necessary, free the memory allocated for the Privilege Set.
    //

    if (RunningPrivileges != NULL) {

        MIDL_user_free( RunningPrivileges );
        RunningPrivileges = NULL;
    }

    //
    // Close an account handle, if one is open
    //

    if (AccountHandle != NULL) {

        LocalStatus = LsapCloseHandle( &AccountHandle, Status );
    }

    //
    // Return null values
    //

    RtlZeroMemory( &AccountInfo->QuotaLimits, sizeof(QUOTA_LIMITS) );
    AccountInfo->SystemAccess = 0;
    AccountInfo->PrivilegeSet = NULL;
    goto SlowQueryAllInformationAccountsFinish;
}



NTSTATUS
LsapDbSlowQueryPrivilegesAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PLSAPR_PRIVILEGE_SET *Privileges
    )

/*++

Routine Description:

    This function is the slow LSA server RPC worker routine for the
    LsaEnumeratePrivilegesOfAccount API.

    The LsaEnumeratePrivilegesOfAccount API obtains information which
    describes the privileges assigned to an account.  This call requires
    ACCOUNT_VIEW access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose privilege
        information is to be obtained.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    Privileges - Receives a pointer to a buffer containing the Privilege
        Set.  The Privilege Set is an array of structures, one for each
        privilege.  Each structure contains the LUID of the privilege and
        a mask of the privilege's attributes.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status;
    PPRIVILEGE_SET PrivilegeSet = NULL;
    ULONG PrivilegeSetLength;
    BOOLEAN ObjectReferenced = FALSE;
    LSAP_DB_ATTRIBUTE Attribute;
    PPRIVILEGE_SET DsPrivs;

    UCHAR FastBuffer[ 256 ];

    //
    // Attempt query of attribute using fast stack buffer.
    //

    PrivilegeSetLength = sizeof(FastBuffer);

    Status = LsapDbReadAttributeObject(
                 AccountHandle,
                 &LsapDbNames[Privilgs],
                 FastBuffer,
                 &PrivilegeSetLength
                 );

    if(NT_SUCCESS(Status)) {
        if( PrivilegeSetLength <= (sizeof(PRIVILEGE_SET) - sizeof (LUID_AND_ATTRIBUTES)) )
        {
            //
            // The privilege set attribute exists but has zero entries.
            // fall-through and handle it same way as non-existent entry.
            //

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        } else {

            //
            // Success!  copy the fast buffer for the caller.
            //

            PrivilegeSet = MIDL_user_allocate ( PrivilegeSetLength );

            if (PrivilegeSet == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SlowQueryPrivilegesError;
            }

            RtlCopyMemory( PrivilegeSet, FastBuffer, PrivilegeSetLength );
            *Privileges = (PLSAPR_PRIVILEGE_SET) PrivilegeSet;
            goto SlowQueryPrivilegesFinish;

        }
    }

    if ((Status == STATUS_OBJECT_NAME_NOT_FOUND)) {

        //
        // If the Privileg attribute does not exist, convert the status
        // back to STATUS_SUCCESS.  Note that an account object need not
        // have any privileges assigned so STATUS_OBJECT_NAME_NOT_FOUND is
        // not an error in this case.  Return a Privilege Set containing
        // a zero Count.
        //

        PrivilegeSetLength = sizeof(PRIVILEGE_SET) - sizeof(LUID_AND_ATTRIBUTES);

        PrivilegeSet = MIDL_user_allocate ( PrivilegeSetLength );

        if (PrivilegeSet == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto SlowQueryPrivilegesError;
        }

        Status = STATUS_SUCCESS;

        PrivilegeSet->Control = (ULONG) 0L;
        PrivilegeSet->PrivilegeCount = (ULONG) 0L;
        *Privileges = (PLSAPR_PRIVILEGE_SET) PrivilegeSet;
        goto SlowQueryPrivilegesFinish;

    }

    //
    // The Privileg attribute exists and has a value assigned.  Allocate
    // a buffer for its value.
    //

    PrivilegeSet = MIDL_user_allocate ( PrivilegeSetLength );

    if (PrivilegeSet == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SlowQueryPrivilegesError;
    }

    //
    // Read the Privilgs attribute into the buffer.  Note that although
    // the value of this attribute has a variable length, it is bounded
    // above.
    //

    Status = LsapDbReadAttributeObject(
                 AccountHandle,
                 &LsapDbNames[Privilgs],
                 PrivilegeSet,
                 &PrivilegeSetLength
                 );

    if (!NT_SUCCESS(Status)) {

        MIDL_user_free(PrivilegeSet);
        goto SlowQueryPrivilegesError;
    }

    //
    // Return the Privilege Set or NULL
    //

    *Privileges = (PLSAPR_PRIVILEGE_SET) PrivilegeSet;

SlowQueryPrivilegesFinish:

    return( Status );

SlowQueryPrivilegesError:

    *Privileges = NULL;
    goto SlowQueryPrivilegesFinish;
}

NTSTATUS
LsapDbSlowQueryQuotasAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PQUOTA_LIMITS QuotaLimits
    )

/*++

Routine Description:

    This function is the slow LSA server RPC worker routine for the
    LsarGetQuotasForAccount API.

    The LsaGetQuotasForAccount API obtains the quota limits for pageable and
    non-pageable memory (in Kilobytes) and the maximum execution time (in
    seconds) for any session logged on to the account specified by
    AccountHandle.  For each quota and explicit value is returned.

    Quotas is not supported any more. In the past, we need LSA_ACCOUNT_VIEW
    access to the object, but currently, there is no such access right &
    you don't need any right to call this function. We will return QuotaLimits
    as 0 and return STATUS_NO_QUOTAS_FOR_ACCOUNT.

Arguments:

    AccountHandle - The handle to the open account object whose quotas
        are to be obtained.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    QuotaLimits - Pointer to structure in which the system resource
        quota limits applicable to each session logged on to this account
        will be returned.  Note that all quotas, including those specified
        as being the system default values, are returned as actual values.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.
--*/

{
    //
    // Quotas are defunct.
    //

    QuotaLimits->PagedPoolLimit = 0;
    QuotaLimits->NonPagedPoolLimit = 0;
    QuotaLimits->MinimumWorkingSetSize = 0;
    QuotaLimits->MaximumWorkingSetSize = 0;

    return( STATUS_NO_QUOTAS_FOR_ACCOUNT );

}


NTSTATUS
LsapDbSlowQuerySystemAccessAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PULONG SystemAccess
    )

/*++

Routine Description:

    This function is the Slow worker for the LsaGetSystemAccessAccount()
    API.

Arguments:

    AccountHandle - The handle to the Account object whose system access
        flags are to be read.  This handle will have been returned
        from a preceding LsaOpenAccount() or LsaCreateAccount() call
        an must be open for ACCOUNT_VIEW access.

    SystemAccess - Points to location that will receive the system access
        flags for the account.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call was successful.

        STATUS_ACCESS_DENIED - The AccountHandle does not specify
            ACCOUNT_VIEW access.

        STATUS_INVALID_HANDLE - The specified AccountHandle is invalid.

--*/

{
    NTSTATUS Status;
    ULONG ReturnedSystemAccess;
    ULONG ReturnedSystemAccessLength;

    //
    // Read the Account Object's System Access Flags
    //

    ReturnedSystemAccessLength = sizeof(ULONG);

    Status = LsapDbReadAttributeObject(
                 AccountHandle,
                 &LsapDbNames[ActSysAc],
                 &ReturnedSystemAccess,
                 &ReturnedSystemAccessLength
                 );


    if (!NT_SUCCESS(Status)) {

        //
        // If there is no System Access attribute, return the system default
        // access.
        //
        // NOTE: The Master Default for the System Access attribute is
        //       currently hardwired.
        //

        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

            goto SlowQuerySystemAccessAccountError;
        }

        ReturnedSystemAccess = LSAP_DB_ACCOUNT_DEFAULT_SYS_ACCESS;
        Status = STATUS_SUCCESS;

    } else {

        //
        // Verify that the returned flags are valid
        //

        if (ReturnedSystemAccess != (ReturnedSystemAccess & POLICY_MODE_ALL)) {

            if ( ReturnedSystemAccess == 0 && LsapDsWriteDs ) {

                ReturnedSystemAccess = LSAP_DB_ACCOUNT_DEFAULT_SYS_ACCESS;
                Status = STATUS_SUCCESS;
            } else {

                Status = STATUS_INTERNAL_DB_CORRUPTION;
                goto SlowQuerySystemAccessAccountError;

            }

        }
    }

    *SystemAccess = ReturnedSystemAccess;

SlowQuerySystemAccessAccountFinish:

    return(Status);

SlowQuerySystemAccessAccountError:

    *SystemAccess = 0;
    goto SlowQuerySystemAccessAccountFinish;
}


NTSTATUS
LsapDbLookupAccount(
    IN PSID AccountSid,
    OUT PLSAP_DB_ACCOUNT *Account
    )

/*++

Routine Description:

    This function looks up the Account information for a given Lsa Account.

Arguments:

    AccountSid - Sid of the account

    Account - Receives a pointer to the Account information.

--*/

{
    PLSAP_DB_ACCOUNT NextAccount = NULL;
    ULONG AccountIndex;
    BOOLEAN AccountFound = FALSE;

    ASSERTMSG( "Account Cache is not valid!", LsapDbIsCacheValid( AccountObject ) );

    //
    // Scan the list of Accounts.
    //

    for (AccountIndex = 0, NextAccount = LsapDbFirstAccount();
         AccountIndex < LsapDbAccountList.AccountCount;
         AccountIndex++, NextAccount = LsapDbNextAccount( NextAccount)
         ) {

        //
        // If the Sids match, we've found the account.
        //

        if (RtlEqualSid( AccountSid, NextAccount->Sid )) {

            *Account = NextAccount;
            AccountFound = TRUE;
            break;
        }
    }

    if (AccountFound) {

        return(STATUS_SUCCESS);
    }

    return(STATUS_NO_SUCH_USER);
}


NTSTATUS
LsapDbCreateAccount(
    IN PLSAPR_SID AccountSid,
    OUT OPTIONAL PLSAP_DB_ACCOUNT *Account
    )

/*++

Routine Description:

    This function creates an Account's information block

Arguments:

    AccountSid - Specifies the Sid of the Account

    Account - Optionally receives a pointer to the newly created Account
        information block.

--*/

{
    NTSTATUS Status;
    PLSAPR_SID CopiedSid = NULL;
    PLSAP_DB_ACCOUNT OutputAccount = NULL;

    //
    // Verify that the Account List is valid.
    //

    if ((!LsapDbIsCacheValid(AccountObject)) && LsapInitialized ) {

       Status = STATUS_INVALID_PARAMETER;
       goto CreateAccountError;
    }

    //
    // Make a copy of the Sid.
    //

    Status = LsapRpcCopySid(
                 NULL,
                 (PSID *) &CopiedSid,
                 (PSID) AccountSid
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateAccountError;
    }

    //
    // Allocate memory for the Account information block.
    //

    OutputAccount = MIDL_user_allocate( sizeof(LSAP_DB_ACCOUNT) );

    if (OutputAccount == NULL) {

        Status = STATUS_NO_MEMORY;
        goto CreateAccountError;
    }

    //
    // Zeroise the new block.
    //

    RtlZeroMemory( OutputAccount, sizeof(LSAP_DB_ACCOUNT) );

    //
    // Copy in the Sid.
    //

    OutputAccount->Sid = CopiedSid;

    //
    // Link the Account to the head of the Account List.
    //

    InsertHeadList( &LsapDbAccountList.Links, &OutputAccount->Links );

    //
    // If requested, return a pointer to the Account.
    //

    if (Account != NULL) {

        *Account = OutputAccount;
    }

    LsapDbAccountList.AccountCount++;

    Status = STATUS_SUCCESS;

CreateAccountFinish:

    return(Status);

CreateAccountError:

    //
    // If necessary, free the copied Sid.
    //

    if (CopiedSid != NULL) {

        MIDL_user_free( CopiedSid );
        CopiedSid = NULL;
    }

    //
    // If necessary, free the memory allocated for the Account block.
    //

    if (OutputAccount != NULL) {

        MIDL_user_free( OutputAccount);
        OutputAccount = NULL;
    }

    //
    // If a return pointer was specified, return NULL.
    //

    if (Account != NULL) {

        *Account = NULL;
    }

    goto CreateAccountFinish;
}


NTSTATUS
LsapDbDeleteAccount(
    IN PLSAPR_SID AccountSid
    )

/*++

Routine Description:

    This function deletes an Account's information block

Arguments:

    AccountSid - Specifies the Sid of the Account

--*/

{
    NTSTATUS Status;
    PLSAP_DB_ACCOUNT Account = NULL;

    //
    // Verify that the Account List is valid.
    //


    if (!LsapDbIsCacheValid(AccountObject)) {

        Status = STATUS_INVALID_PARAMETER;
        goto DeleteAccountError;
    }

    //
    // Lookup the Account Information Block to be deleted
    //

    Status = LsapDbLookupAccount( AccountSid, &Account);

    if (!NT_SUCCESS(Status)) {

        goto DeleteAccountError;
    }

    //
    // We found the account.  Unlink it from the Account List
    //

    RemoveEntryList( &Account->Links );

    //
    // Now free the Account Information
    //

    if (Account->Sid != NULL) {

        MIDL_user_free( Account->Sid);
        Account->Sid = NULL;
    }

    if (Account->Info.PrivilegeSet != NULL) {

        MIDL_user_free( Account->Info.PrivilegeSet );
        Account->Info.PrivilegeSet = NULL;
    }

    MIDL_user_free( Account );

    LsapDbAccountList.AccountCount--;

DeleteAccountFinish:

    return(Status);

DeleteAccountError:

    goto DeleteAccountFinish;
}


NTSTATUS
LsapDbUpdateSystemAccessAccount(
    IN PLSAPR_SID AccountSid,
    IN PULONG SystemAccess
    )

/*++

Routine Description:

    This function updates the System Access flags in an Account's information
    block.

Arguments:

    AccountSid - Sid of account

    SystemAccess - Pointer to new System Access flags.  These flags
        will overwrite the old value

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status;
    PLSAP_DB_ACCOUNT Account = NULL;

    //
    // Verify that the Account List is valid.
    //

    if (!LsapDbIsCacheValid(AccountObject)) {

        Status = STATUS_INVALID_PARAMETER;
        goto UpdateSystemAccessAccountError;
    }

    //
    // Lookup the Account
    //

    Status = LsapDbLookupAccount( AccountSid, &Account );

    if (!NT_SUCCESS(Status)) {

        goto UpdateSystemAccessAccountError;
    }

    //
    // Update the System Access Flags
    //

    Account->Info.SystemAccess = *SystemAccess;

UpdateSystemAccessAccountFinish:

    return(Status);

UpdateSystemAccessAccountError:

    goto UpdateSystemAccessAccountFinish;
}


NTSTATUS
LsapDbUpdateQuotasAccount(
    IN PLSAPR_SID AccountSid,
    IN PQUOTA_LIMITS QuotaLimits
    )

/*++

Routine Description:

    This function updates the Quota Limits an Account's information
    block.

Arguments:

    AccountSid - Sid of Account

    Quotas - Pointer to new Quota Limits flags.  These flags
        will overwrite the old value

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status;
    PLSAP_DB_ACCOUNT Account = NULL;

    //
    // Verify that the Account List is valid.
    //

    if (!LsapDbIsCacheValid(AccountObject)) {

        Status = STATUS_INVALID_PARAMETER;
        goto UpdateQuotasAccountError;
    }

    //
    // Lookup the Account
    //

    Status = LsapDbLookupAccount( AccountSid, &Account );

    if (!NT_SUCCESS(Status)) {

        goto UpdateQuotasAccountError;
    }

    //
    // Update the System Access Flags
    //

    Account->Info.QuotaLimits = *QuotaLimits;

UpdateQuotasAccountFinish:

    return(Status);

UpdateQuotasAccountError:

    goto UpdateQuotasAccountFinish;
}


NTSTATUS
LsapDbUpdatePrivilegesAccount(
    IN PLSAPR_SID AccountSid,
    IN OPTIONAL PPRIVILEGE_SET Privileges
    )

/*++

Routine Description:

    This function replates the Privilege Set in an Account's information
    block with the one given.  The existing Privilege Set (if any) in the
    block will be freed.

Arguments:

    AccountSid - Sid of account

    Privileges - Optional pointer to new Privilege Set.  These flags
        will overwrite the old value.  if NULL is specified, a Privilege
        Set containing 0 entries will be written.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status;
    PLSAP_DB_ACCOUNT Account = NULL;
    PPRIVILEGE_SET OutputPrivileges = Privileges;

    //
    // Verify that the Account List is valid.
    //

    if (!LsapDbIsCacheValid( AccountObject)) {

        Status = STATUS_INVALID_PARAMETER;
        goto UpdatePrivilegesAccountError;
    }

    //
    // Lookup the Account
    //

    Status = LsapDbLookupAccount( AccountSid, &Account );

    if (!NT_SUCCESS(Status)) {

        goto UpdatePrivilegesAccountError;
    }

    //
    // If NULL was specified for the Privileges, construct a Privilege Set
    // having 0 entries.
    //

    if (OutputPrivileges == NULL) {

        OutputPrivileges = MIDL_user_allocate( sizeof(PRIVILEGE_SET) );

        if (OutputPrivileges == NULL) {

            Status = STATUS_NO_MEMORY;
            goto UpdatePrivilegesAccountError;
        }

        OutputPrivileges->PrivilegeCount = 0;
        OutputPrivileges->Control = 0;
    }

    //
    // If there is an existing Privilege Set in the cache, free it.
    //

    if (Account->Info.PrivilegeSet != NULL) {

        MIDL_user_free( Account->Info.PrivilegeSet );
        Account->Info.PrivilegeSet = NULL;
    }

    //
    // Update the Privileges
    //

    Account->Info.PrivilegeSet = OutputPrivileges;

UpdatePrivilegesAccountFinish:

    return(Status);

UpdatePrivilegesAccountError:

    if (Account != NULL) {

        if( Account->Info.PrivilegeSet ) {

            MIDL_user_free( Account->Info.PrivilegeSet );
        }
        Account->Info.PrivilegeSet = NULL;
    }

    goto UpdatePrivilegesAccountFinish;
}


NTSTATUS
LsapDbCreateAccountList(
    OUT PLSAP_DB_ACCOUNT_LIST AccountList
    )

/*++

Routine Description:

    This function creates an empty Account List

Arguments

    AccountList - Pointer to Account List structure that will be initialized.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    AccountList->AccountCount = 0;

    InitializeListHead( &AccountList->Links );

    return(Status);
}


NTSTATUS
LsapDbBuildAccountCache(
    )

/*++

Routine Description:

    This function constructs a cache for the Account objects.  The cache
    is a counted doubly linked list of blocks, one for each Account Object
    found in the LSA Policy Database.

Arguments:

    None.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    SID_AND_ATTRIBUTES AccountSidAndAttributes;
    ULONG EnumerationIndex, EnumerationContext;
    LSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer;
    PLSAPR_SID AccountSid = NULL;
    PLSAP_DB_ACCOUNT Account = NULL;

    //
    // Ensure caching of Account objects is turned off.
    //

    LsapDbMakeCacheBuilding( AccountObject );

    //
    // Initialize the Account List header with a skeleton entry for the
    // System Account.
    //

    Status = LsapDbCreateAccountList(&LsapDbAccountList);

    if (!NT_SUCCESS(Status)) {

        goto BuildAccountCacheError;
    }

    LsapDbMakeCacheInvalid( AccountObject );

    //
    // Enumerate each of the LSA Account objects
    //

    Status = STATUS_MORE_ENTRIES;
    EnumerationContext = 0;

    while (Status == STATUS_MORE_ENTRIES) {

        //
        // Enumerate the next bunch of accounts.
        //

        Status = LsarEnumerateAccounts(
                     LsapPolicyHandle,
                     &EnumerationContext,
                     &EnumerationBuffer,
                     LSAP_DB_BUILD_ACCOUNT_LIST_LENGTH
                     );

        if (!NT_SUCCESS(Status)) {

            //
            // We might just have got the warning that there are no more
            // accounts.  Reset to STATUS_SUCCESS and break out.
            //

            if (Status == STATUS_NO_MORE_ENTRIES) {

                Status = STATUS_SUCCESS;
            }

            break;
        }

        //
        // We've got some more accounts.  Add them to the Account List
        //

        for( EnumerationIndex = 0;
             EnumerationIndex < EnumerationBuffer.EntriesRead;
             EnumerationIndex++ ) {

            AccountSid = EnumerationBuffer.Information[ EnumerationIndex ].Sid;

            Status = LsapDbCreateAccount( AccountSid, &Account );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            AccountSidAndAttributes.Sid = (PSID) AccountSid;
            AccountSidAndAttributes.Attributes = 0;

            Status = LsapDbSlowQueryAllInformationAccounts(
                         LsapPolicyHandle,
                         1,
                         &AccountSidAndAttributes,
                         &Account->Info
                         );

            if (!NT_SUCCESS(Status)) {

                if (Status != STATUS_NO_MORE_ENTRIES) {

                    break;
                }

                Status = STATUS_SUCCESS;
            }
        }

        if (!NT_SUCCESS(Status)) {

            break;
        }

        Status = STATUS_MORE_ENTRIES;

        LsaIFree_LSAPR_ACCOUNT_ENUM_BUFFER( &EnumerationBuffer );
    }

    if (!NT_SUCCESS(Status)) {

        goto BuildAccountCacheError;
    }

    //
    // Turn on caching for Account objects.
    //

    LsapDbMakeCacheValid( AccountObject );

    Status = STATUS_SUCCESS;

BuildAccountCacheFinish:

    return(Status);

BuildAccountCacheError:

    LsapDbMakeCacheInvalid(AccountObject);
    LsapDbMakeCacheUnsupported(AccountObject);
    goto BuildAccountCacheFinish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dspolicy\dbattr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbattr.c

Abstract:

    LSA Database Handle Manager - Object Attribute Routines

    These routines manipulate or construct LSA Database Object Attributes
    or their content.

Author:

    Scott Birrell       (ScottBi)     January 21, 1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"

NTSTATUS
LsapDbMakeUnicodeAttribute(
    IN OPTIONAL PUNICODE_STRING UnicodeValue,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )

/*++

Routine Description:

    This function constructs Attribute Information for an attribute value
    that is in Unicode String form.  The Unicode String is converted to
    Self-Relative form after validation and the given Attribute
    structure is filled in.

    If a NULL UnicodeValue, or string of length 0 is specified, NULL is
    propagated as the attribute value.

    WARNING! - This routine allocates memory for the Self-Relative Unicode
    string produced.  This memory must be freed after use by calling
    MIDL_user_free()

Arguments:

    UnicodeValue - Pointer to Unicode String containing the Attribute's
        Value.  NULL may be specified, in which case, NULL will be stored
        in the output Attribute.

    AttributeName - Pointer to the Unicode name of the attribute.

    Attribute - Pointer to structure that will receive the
        attributes's information.  This consists of the attribute's name,
        value and value length.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources such
            as memory to complete the call.

        STATUS_INVALID_PARAMETER - The specified AttributeValue is not a
            pointer to a Unicode String.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING_SR OutputAttributeValue = NULL;
    ULONG OutputAttributeValueLength = 0;

    RtlZeroMemory( Attribute, sizeof( LSAP_DB_ATTRIBUTE ) );

    //
    // Mark attribute initially as not having had memory allocated by
    // setting MemoryAllocated to FALSE.  If routine succeeds and we allocate
    // memory via MIDL_user_allocate() change MemoryAllocated field to TRUE.
    //

    Attribute->MemoryAllocated = FALSE;

    if (ARGUMENT_PRESENT(UnicodeValue) && UnicodeValue->Length != 0) {

        //
        // Validate the string
        //
        if ( !LsapValidateLsaUnicodeString( UnicodeValue ) ) {
            return STATUS_INVALID_PARAMETER;
        }


        //
        //  Calculate the size of memory required for a Self-Relative
        //  Unicode String and allocate the memory.
        //

        OutputAttributeValueLength =
            sizeof(UNICODE_STRING_SR) + (ULONG) UnicodeValue->MaximumLength;
        OutputAttributeValue = MIDL_user_allocate(OutputAttributeValueLength);

        if (OutputAttributeValue == NULL) {

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        Attribute->MemoryAllocated = TRUE;

        //
        // Setup self-relative Unicode String (but with absolute buffer pointer
        // referencing buffer following UNICODE_STRING header)
        // Copy source Unicode Value to Self-relative Unicode String.  Set buffer pointer
        // to NULL as it will not be used here.
        //

        OutputAttributeValue->Length = UnicodeValue->Length;
        OutputAttributeValue->MaximumLength = UnicodeValue->MaximumLength;
        OutputAttributeValue->Offset = sizeof(UNICODE_STRING_SR);

        //
        // Copy the Unicode string Buffer
        //

        RtlCopyMemory( OutputAttributeValue + 1,
                       UnicodeValue->Buffer,
                       UnicodeValue->Length );
    }

    Attribute->AttributeName = AttributeName;
    Attribute->AttributeValue = OutputAttributeValue;
    Attribute->AttributeValueLength = OutputAttributeValueLength;

    return(Status);
}



VOID
LsapDbCopyUnicodeAttributeNoAlloc(
    OUT PUNICODE_STRING OutputString,
    IN PLSAP_DB_ATTRIBUTE Attribute,
    IN BOOLEAN SelfRelative
    )
/*++

Routine Description:

    This function makes a UNICODE_STRING structure reference the value of
    an attribute that has a Unicode String as its value.  No memory is allocated
    for the attribute values's Unicode Buffer.

Arguments:

    OutputString - Pointer to UNICODE_STRING structure that will be made
        to reference the  attribute value's Unicode Buffer.

    Attribute - Pointer to attribute information block whose
        AttributeValue field is a pointer to a Unicode String,
        or NULL.  If NULL or if the string has length 0, the output Unicode
        String is initialized with a buffer pointer equal to NULL and a zero
        length.

    SelfRelative - TRUE if the input Unicode String is expected to be
        in Self-Relative form, else FALSE.
Returns:

    Nothing

--*/
{
    UNICODE_STRING AbsInputUnicodeString;
    PUNICODE_STRING InputUnicodeString;
    PUNICODE_STRING ReturnedUnicodeString = NULL;

    //
    // The Length field will be accessed before we know whether we have
    // a self-relative string structure.
    //

    C_ASSERT( FIELD_OFFSET( UNICODE_STRING, Length ) ==
              FIELD_OFFSET( UNICODE_STRING_SR, Length ));

    //
    // Obtain pointer to input Unicode String contained in Attribute.
    // Convert it to absolute form if necessary.
    //

    InputUnicodeString = (PUNICODE_STRING) Attribute->AttributeValue;

    if ((InputUnicodeString != NULL) && (InputUnicodeString->Length != 0)) {

        if (SelfRelative) {

            PUNICODE_STRING_SR InputUnicodeStringSr;

            InputUnicodeStringSr =
                (PUNICODE_STRING_SR) Attribute->AttributeValue;

            AbsInputUnicodeString.Length = InputUnicodeStringSr->Length;
            AbsInputUnicodeString.MaximumLength =
                InputUnicodeStringSr->MaximumLength;

            AbsInputUnicodeString.Buffer =
                (PWSTR)
                (((PUCHAR)(InputUnicodeStringSr)) +
                InputUnicodeStringSr->Offset);

            InputUnicodeString = &AbsInputUnicodeString;
        }

        OutputString->Buffer = InputUnicodeString->Buffer;
        OutputString->Length = InputUnicodeString->Length;
        OutputString->MaximumLength = InputUnicodeString->MaximumLength;

    } else {

        //
        // The attribute contains a NULL Unicode String or one of length
        // 0.  Set the output Unicode String to NULL.
        //

        OutputString->Length = OutputString->MaximumLength = 0;
        OutputString->Buffer = (PWSTR) NULL;
    }
}



NTSTATUS
LsapDbCopyUnicodeAttribute(
    OUT PUNICODE_STRING OutputString,
    IN PLSAP_DB_ATTRIBUTE Attribute,
    IN BOOLEAN SelfRelative
    )

/*++

Routine Description:

This function makes a UNICODE_STRING structure reference the value of
an attribute that has a Unicode String as its value.  Memory for the
attribute values's Unicode Buffer is allocated via MIDL_user_allocate.

Arguments:

    OutputString - Pointer to UNICODE_STRING structure that will be made
        to reference the  attribute value's Unicode Buffer.

    Attribute - Pointer to attribute information block whose
        AttributeValue field is a pointer to a Unicode String,
        or NULL.  If NULL or if the string has length 0, the output Unicode String is initialized
        with a buffer pointer equal to NULL and a zero length.

    SelfRelative - TRUE if the input Unicode String is expected to be
        in Self-Relative form, else FALSE.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call was successful

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            such as memory to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING AbsInputUnicodeString;
    PUNICODE_STRING InputUnicodeString;
    PUNICODE_STRING_SR InputUnicodeStringSr;
    PUNICODE_STRING ReturnedUnicodeString = NULL;

    //
    // The Length field will be accessed before we know whether we have
    // a self-relative string structure.
    //

    C_ASSERT( FIELD_OFFSET( UNICODE_STRING, Length ) ==
              FIELD_OFFSET( UNICODE_STRING_SR, Length ));

    //
    // Obtain pointer to input Unicode String contained in Attribute.
    // Convert it to absolute form if necessary.
    //

    InputUnicodeString = (PUNICODE_STRING) Attribute->AttributeValue;

    if ((InputUnicodeString != NULL) && (InputUnicodeString->Length != 0)) {

        if (SelfRelative) {

            InputUnicodeStringSr =
                (PUNICODE_STRING_SR) Attribute->AttributeValue;

            AbsInputUnicodeString.Length = InputUnicodeStringSr->Length;
            AbsInputUnicodeString.MaximumLength =
                InputUnicodeStringSr->MaximumLength;

            AbsInputUnicodeString.Buffer =
                (PWSTR)
                (((PUCHAR)(InputUnicodeStringSr)) +
                InputUnicodeStringSr->Offset);

            InputUnicodeString = &AbsInputUnicodeString;
        }

        //
        // Now allocate memory for the Unicode String Buffer.
        //

        OutputString->Buffer =
            MIDL_user_allocate(InputUnicodeString->MaximumLength);

        if (OutputString->Buffer == NULL) {

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        //
        // Initialize UNICODE_STRING header
        //

        OutputString->Length = InputUnicodeString->Length;
        OutputString->MaximumLength = InputUnicodeString->MaximumLength;

        //
        // Copy the input Unicode String
        //

        RtlCopyUnicodeString( OutputString, InputUnicodeString );

    } else {

        //
        // The attribute contains a NULL Unicode String or one of length
        // 0.  Set the output Unicode String to NULL.
        //

        OutputString->Length = OutputString->MaximumLength = 0;
        OutputString->Buffer = (PWSTR) NULL;
    }

    return(Status);
}



NTSTATUS
LsapDbMakeSidAttribute(
    IN OPTIONAL PSID Sid,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )

/*++

Routine Description:

    This function constructs Attribute Information for an attribute value
    that is in Sid form.  The Sid is validated and the given
    Attribute structure is filled in.

Arguments:

    Sid - Pointer to the Sid or NULL.

    AttributeName - Pointer to the Unicode name of the attribute.

    Attribute - Pointer to structure that will receive the
        attributes's information.  This consists of the attribute's name,
        value and value length.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_PARAMETER - The specified AttributeValue is not a
            pointer to a syntactically valid Sid, or NULL.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlZeroMemory( Attribute, sizeof( LSAP_DB_ATTRIBUTE ) );

    Attribute->AttributeName = AttributeName;
    Attribute->MemoryAllocated = FALSE;

    if (ARGUMENT_PRESENT(Sid)) {

        if (RtlValidSid(Sid)) {

            Attribute->AttributeValue = Sid;
            Attribute->AttributeValueLength = RtlLengthSid(Sid);
            return(Status);
        }

        Status = STATUS_INVALID_PARAMETER;
    }

    //
    // The supplied Sid is NULL or invalid.
    //

    Attribute->AttributeValue = NULL;
    Attribute->AttributeValueLength = 0;

    return(Status);
}



NTSTATUS
LsapDbMakeGuidAttribute(
    IN OPTIONAL GUID *Guid,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )

/*++

Routine Description:

    This function constructs Attribute Information for an attribute value
    that is in GUID form.  The given Attribute structure is filled in.

Arguments:

    Guid - Pointer to the GUID or NULL.

    AttributeName - Pointer to the Unicode name of the attribute.

    Attribute - Pointer to structure that will receive the
        attributes's information.  This consists of the attribute's name,
        value and value length.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_PARAMETER - The specified AttributeValue is not a
            pointer to a syntactically valid Sid, or NULL.
--*/

{
     NTSTATUS Status = STATUS_SUCCESS;

    RtlZeroMemory( Attribute, sizeof( LSAP_DB_ATTRIBUTE ) );

    Attribute->AttributeName = AttributeName;
    Attribute->MemoryAllocated = FALSE;

    if (ARGUMENT_PRESENT(Guid)) {

        Attribute->AttributeValue = Guid;
        Attribute->AttributeValueLength = sizeof(GUID);
        return(Status);
    }

    //
    // The supplied GUID is NULL
    //

    Attribute->AttributeValue = NULL;
    Attribute->AttributeValueLength = 0;

    return(Status);
}


NTSTATUS
LsapDbReadAttribute(
    IN LSAPR_HANDLE ObjectHandle,
    IN OUT PLSAP_DB_ATTRIBUTE Attribute
    )

/*++

Routine Description:

    This function reads an attribute of an object, allocating memory if
    requested for the buffer containing the attribute's value.

Arguments:

    ObjectHandle - Handle to object obtained from LsapDbCreateObject or
        LsapDbOpenObject

    Attributes - Pointer to an array of Attribute Information blocks each
        containing pointers to the attribute's Unicode Name, an optional
        pointer to a buffer that will receive the value and an optional
        length of the value expected in bytes.

        If the AttributeValue field in this structure is specified as non-NULL,
        the attribute's data will be returned in the specified buffer.  In
        this case, the AttributeValueLength field must specify a sufficiently
        large buffer size in bytes.  If the specified size is too small,
        a warning is returned and the buffer size required is returned in
        AttributeValueLength.

        If the AttributeValue field in this structure is NULL, the routine
        will allocate memory for the attribute value's buffer, via MIDL_user_allocate().  If
        the AttributeValueLength field is non-zero, the number of bytes specified
        will be allocated.  If the size of buffer allocated is too small to
        hold the attribute's value, a warning is returned.  If the
        AttributeValuelength field is 0, the routine will first query the size
        of buffer required and then allocate its memory.

        In all success cases and buffer overflow cases, the
        AttributeValueLength is set upon exit to the size of data required.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_ATTRIBUTE DsAttribute;

    if (Attribute->AttributeValue != NULL) {

        if (Attribute->AttributeValueLength == 0) {

            return(STATUS_INVALID_PARAMETER);
        }
    }

    //
    // Deal with the Ds case seperately
    //
    if ( LsapDsIsWriteDs( ObjectHandle ) &&
         Attribute->DbNameIndex != SecDesc ) {

        RtlCopyMemory( &DsAttribute, Attribute, sizeof( LSAP_DB_ATTRIBUTE ) );

        //
        // Now, do the read...
        //
        Status = LsapDsReadAttributes( &((LSAP_DB_HANDLE)ObjectHandle)->PhysicalNameDs,
                                       LSAPDS_OP_NO_LOCK,
                                       &DsAttribute,
                                       1 );

        if ( NT_SUCCESS( Status ) ) {

            Attribute->AttributeValueLength = DsAttribute.AttributeValueLength;

            if ( Attribute->AttributeValue != NULL ) {

                if ( Attribute->AttributeValueLength >= DsAttribute.AttributeValueLength ) {

                    RtlCopyMemory( Attribute->AttributeValue, DsAttribute.AttributeValue,
                                   DsAttribute.AttributeValueLength );
                } else {

                    Status = STATUS_BUFFER_OVERFLOW;
                }


            } else {

                Attribute->AttributeValue = DsAttribute.AttributeValue;
                DsAttribute.AttributeValue = NULL;
            }

            MIDL_user_free( DsAttribute.AttributeValue );
        }

        return( Status );
    }

    Attribute->MemoryAllocated = FALSE;

    //
    // If an explicit buffer pointer is given, verify that the length
    // specified is non-zero and attempt to use that buffer.
    //

    if (Attribute->AttributeValue != NULL) {

        if (Attribute->AttributeValueLength == 0) {

            return(STATUS_INVALID_PARAMETER);
        }

        Status = LsapDbReadAttributeObject(
                     ObjectHandle,
                     Attribute->AttributeName,
                     Attribute->AttributeValue,
                     &Attribute->AttributeValueLength
                     );

        if (!NT_SUCCESS(Status)) {

            goto ReadAttributeError;
        }

        return(Status);
    }

    //
    // No output buffer pointer has been given.  If a zero buffer
    // size is given, query size of memory required.  Since the
    // buffer length is 0, STATUS_SUCCESS should be returned rather
    // than STATUS_BUFFER_OVERFLOW.
    //

    if (Attribute->AttributeValueLength == 0) {

        Status = LsapDbReadAttributeObject(
                     ObjectHandle,
                     Attribute->AttributeName,
                     NULL,
                     &Attribute->AttributeValueLength
                     );

        if (!NT_SUCCESS(Status)) {

            goto ReadAttributeError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // If the attribute value size needed is 0, return NULL pointer
    //

    if (Attribute->AttributeValueLength == 0) {

        Attribute->AttributeValue = NULL;
        return(STATUS_SUCCESS);
    }

    //
    // Allocate memory for the buffer.
    //

    Attribute->AttributeValue =
        MIDL_user_allocate(Attribute->AttributeValueLength);

    if (Attribute->AttributeValue == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ReadAttributeError;
    }

    Attribute->MemoryAllocated = TRUE;

    //
    // Now read the attribute into the buffer.
    //

    Status = LsapDbReadAttributeObject(
                 ObjectHandle,
                 Attribute->AttributeName,
                 Attribute->AttributeValue,
                 &Attribute->AttributeValueLength
                 );

    if (!NT_SUCCESS(Status)) {

        goto ReadAttributeError;
    }

ReadAttributeFinish:

    return(Status);

ReadAttributeError:

    //
    // If memory was allocated for any values read, it must be freed.
    //

    if (Attribute->MemoryAllocated) {

        MIDL_user_free( Attribute->AttributeValue );
    }

    goto ReadAttributeFinish;
}


NTSTATUS
LsapDbFreeAttributes(
    IN ULONG Count,
    IN PLSAP_DB_ATTRIBUTE Attributes
    )

/*++

Routine Description:

    This function frees memory allocated for Attribute Values in an
    array of attributes.

Arguments:

    Count - Count of attributes in the array

    Attributes - Pointer to array of attributes.  Only those attributes
        in which MemoryAllocated is set to TRUE will have their
        Attribute Value buffers freed.  For these attributes, MemoryAllocated
        will be set to false.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;

    for (Index = 0; Index < Count; Index++) {

        if (Attributes[Index].MemoryAllocated) {

            MIDL_user_free(Attributes[Index].AttributeValue);
            Attributes[Index].MemoryAllocated = FALSE;
            Attributes[Index].AttributeValue = NULL;
            Attributes[Index].AttributeValueLength = 0;
        }
    }

    return(Status);
}


NTSTATUS
LsapDbMakeUnicodeAttributeDs(
    IN OPTIONAL PUNICODE_STRING UnicodeValue,
    IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )
{
    NTSTATUS Status = LsapDbMakeUnicodeAttribute( UnicodeValue,
                                                  &LsapDbNames[Name],
                                                  Attribute );

    if ( NT_SUCCESS( Status ) ) {

        Attribute->DsAttId    = LsapDbDsAttInfo[Name].AttributeId;
        Attribute->AttribType = LsapDbDsAttInfo[Name].AttributeType;
        Attribute->DbNameIndex = Name;
    }

    return( Status );
}


NTSTATUS
LsapDbMakeSidAttributeDs(
    IN PSID Sid,
    IN IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )
{
    NTSTATUS Status = LsapDbMakeSidAttribute( Sid,
                                              &LsapDbNames[Name],
                                              Attribute );

    if ( NT_SUCCESS( Status ) ) {

        Attribute->DsAttId    = LsapDbDsAttInfo[Name].AttributeId;
        Attribute->AttribType = LsapDbDsAttInfo[Name].AttributeType;
        Attribute->DbNameIndex = Name;
    }

    return( Status );
}



NTSTATUS
LsapDbMakeGuidAttributeDs(
    IN GUID *Guid,
    IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )
{
    NTSTATUS Status = LsapDbMakeGuidAttribute( Guid,
                                               &LsapDbNames[Name],
                                               Attribute );

    if ( NT_SUCCESS( Status ) ) {

        Attribute->DsAttId    = LsapDbDsAttInfo[Name].AttributeId;
        Attribute->AttribType = LsapDbDsAttInfo[Name].AttributeType;
        Attribute->DbNameIndex = Name;
    }

    return( Status );
}


NTSTATUS
LsapDbMakePByteAttributeDs(
    IN OPTIONAL PBYTE Buffer,
    IN ULONG BufferLength,
    IN LSAP_DB_ATTRIB_TYPE AttribType,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )

/*++

Routine Description:

    This function constructs Attribute Information for an attribute value
    that is in Sid form.  The Sid is validated and the given
    Attribute structure is filled in.

Arguments:

    Sid - Pointer to the Sid or NULL.

    AttributeName - Pointer to the Unicode name of the attribute.

    Attribute - Pointer to structure that will receive the
        attributes's information.  This consists of the attribute's name,
        value and value length.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_PARAMETER - The specified AttributeValue is not a
            pointer to a syntactically valid Sid, or NULL.
--*/

{
     NTSTATUS Status = STATUS_SUCCESS;

     Attribute->AttributeName = AttributeName;
     Attribute->MemoryAllocated = FALSE;

     if (ARGUMENT_PRESENT(Buffer)) {

        Attribute->AttributeValue = Buffer;
        Attribute->AttributeValueLength = BufferLength;

     } else {

         //
         // The supplied Sid is NULL or invalid.
         //

         Attribute->AttributeValue = NULL;
         Attribute->AttributeValueLength = 0;

     }

     Attribute->DsAttId    = LsapDbDsAttInfo[Name].AttributeId;
     Attribute->AttribType = AttribType;
     Attribute->DbNameIndex = Name;

     return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dsexe\main.c ===
#include <windows.h>
#include <stdio.h>

int __cdecl main(int, char **, char **);

typedef void (__cdecl *_PVFV)(void);

#pragma data_seg(".CRT$XIA")
_PVFV __xi_a[] = { NULL };


#pragma data_seg(".CRT$XIZ")
_PVFV __xi_z[] = { NULL };


#pragma data_seg(".CRT$XCA")
_PVFV __xc_a[] = { NULL };


#pragma data_seg(".CRT$XCZ")
_PVFV __xc_z[] = { NULL };


#pragma data_seg(".CRT$XPA")
_PVFV __xp_a[] = { NULL };


#pragma data_seg(".CRT$XPZ")
_PVFV __xp_z[] = { NULL };


#pragma data_seg(".CRT$XTA")
_PVFV __xt_a[] = { NULL };


#pragma data_seg(".CRT$XTZ")
_PVFV __xt_z[] = { NULL };

#if defined(_IA64_)
#pragma comment(linker, "/merge:.CRT=.srdata")
#else
#pragma comment(linker, "/merge:.CRT=.rdata")
#endif

#pragma data_seg()  /* reset */

_PVFV *__onexitbegin;
_PVFV *__onexitend;

static void
_initterm (
    _PVFV * pfbegin,
    _PVFV * pfend
    )
{
    /*
     * walk the table of function pointers from the bottom up, until
     * the end is encountered.  Do not skip the first entry.  The initial
     * value of pfbegin points to the first valid entry.  Do not try to
     * execute what pfend points to.  Only entries before pfend are valid.
     */
    while ( pfbegin < pfend ) {
        /*
         * if current table entry is non-NULL, call thru it.
         */
        if ( *pfbegin != NULL )
            (**pfbegin)();
        ++pfbegin;
    }
}

void
mainNoCRTStartup(
    void
    )
{
    __try {

        // do C initializations
        _initterm( __xi_a, __xi_z );
        // do C++ initializations
        _initterm( __xc_a, __xc_z );

        main(1, 0, 0);

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

    }

    __try {
        // Do C++ terminators
        _initterm(__onexitbegin, __onexitend);

        // do pre-terminators
        _initterm(__xp_a, __xp_z);

        // do C terminiators
        _initterm(__xt_a, __xt_z);

    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dspolicy\dbdata.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbdata.c

Abstract:

    Local Security Authority - Database Server Global Data

Author:

    Scott Birrell       (ScottBi)       July 25, 1991

Environment:

    User Mode

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"

OBJECT_ATTRIBUTES  LsapDbObjectAttributes;
STRING  LsapDbNameString;
LARGE_INTEGER LsapDbInitSize;
LARGE_INTEGER LsapDbMaximumSizeOfSection;




//
// LSA Initialized Status
//

BOOLEAN LsapInitialized = FALSE;

//
// Setup Event Existed
// This is necessary to distinguish a psuedo install done
// during a developer's first boot after install (which does
// an auto init) and the case where a real setup was run.
//

BOOLEAN LsapSetupWasRun = FALSE;

//
// Boolean indicating that the Ds is up and running
//
BOOLEAN LsapDsIsRunning = FALSE;

//
// Database initialization has been performed
//

BOOLEAN LsapDatabaseSetupPerformed = FALSE;

//
// Type of product we are running
//

NT_PRODUCT_TYPE LsapProductType;

//
// Product suites available on the current machine
//
WORD LsapProductSuiteMask=0;


//
// LSA Database State information
//

LSAP_DB_STATE LsapDbState;

#ifdef DBG
BOOL g_ScePolicyLocked = FALSE;
#endif

//
// LsaDb object Handle used internally.
// Also one for use throughout LSA.
//

LSAPR_HANDLE LsapDbHandle;
LSAPR_HANDLE LsapPolicyHandle = NULL;

//
// LSA Database Encryption Key
//

PLSAP_CR_CIPHER_KEY LsapDbCipherKey;
PLSAP_CR_CIPHER_KEY LsapDbSP4SecretCipherKey;
PLSAP_CR_CIPHER_KEY LsapDbSecretCipherKeyRead;
PLSAP_CR_CIPHER_KEY LsapDbSecretCipherKeyWrite;
PVOID   LsapDbSysKey = NULL;
PVOID   LsapDbOldSysKey = NULL;

//
// Is this a DC in the root domain?
//

BOOLEAN DcInRootDomain = FALSE;

//
// Queue of name/sid lookup activities.
//

LSAP_DB_LOOKUP_WORK_QUEUE LookupWorkQueue;


//
// LSA Database Object SubKey Unicode name string and attributes array
//

UNICODE_STRING LsapDbNames[DummyLastName];
PLSAP_DB_DS_INFO LsapDbDsAttInfo;

//
// LSA Database Object Type Containing Directory Names
//

UNICODE_STRING LsapDbContDirs[DummyLastObject];

//
// Object Information Requirements.  These arrays, indexed by object
// type id indicated whether objects have Sids or Names.
//
// WARNING! - These arrays must be kept in sync with the LSAP_DB_OBJECT_TYPE_ID
// enumerated type.
//

BOOLEAN LsapDbRequiresSidInfo[DummyLastObject] = {

    FALSE, // NullObject
    FALSE, // LsaDatabaseObject
    FALSE, // BuiltInAccountObject
    TRUE,  // AccountObject
    FALSE  // SecretObject
};

BOOLEAN LsapDbRequiresNameInfo[DummyLastObject] = {

    FALSE, // NullObject,
    TRUE,  // LsaDatabaseObject
    TRUE,  // BuiltInAccountObject
    FALSE, // AccountObject
    TRUE   // SecretObject
};

//
// Table of accesses required to query Policy Information.  This table
// is indexed by Policy Information Class
//

ACCESS_MASK LsapDbRequiredAccessQueryPolicy[PolicyDnsDomainInformationInt + 1] = {

        0,                              // Information classes start at 1
        POLICY_VIEW_AUDIT_INFORMATION,  // PolicyAuditLogInformation
        POLICY_VIEW_AUDIT_INFORMATION,  // PolicyAuditEventsInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyPrimaryDomainInformation
        POLICY_GET_PRIVATE_INFORMATION, // PolicyPdAccountInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyAccountDomainInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyLsaServerRoleInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyReplicaSourceInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyDefaultQuotaInformation
        0,                              // Not settable by non-trusted call
        0,                              // Not applicable
        POLICY_VIEW_AUDIT_INFORMATION,  // PolicyAuditFullQueryInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyDnsDomainInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyDnsDomainInformationInt
};

ACCESS_MASK LsapDbRequiredAccessQueryDomainPolicy[PolicyDomainKerberosTicketInformation + 1] = {

        0,                              // Information classes start at 2
        0,                              // PolicyDomainQualityOfServiceInformation (outdated)
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyDomainEfsInformation
        POLICY_VIEW_LOCAL_INFORMATION   // PolicyDomainKerberosTicketInformation
};

//
// Table of accesses required to set Policy Information.  This table
// is indexed by Policy Information Class
//

ACCESS_MASK LsapDbRequiredAccessSetPolicy[PolicyDnsDomainInformationInt + 1] = {

        0,                              // Information classes start at 1
        POLICY_AUDIT_LOG_ADMIN,         // PolicyAuditLogInformation
        POLICY_SET_AUDIT_REQUIREMENTS,  // PolicyAuditEventsInformation
        POLICY_TRUST_ADMIN,             // PolicyPrimaryDomainInformation
        0,                              // Not settable by non-trusted call
        POLICY_TRUST_ADMIN,             // PolicyAccountDomainInformation
        POLICY_SERVER_ADMIN,            // PolicyLsaServerRoleInformation
        POLICY_SERVER_ADMIN,            // PolicyReplicaSourceInformation
        POLICY_SET_DEFAULT_QUOTA_LIMITS,// PolicyDefaultQuotaInformation
        0,                              // Not settable by non-trusted call
        POLICY_AUDIT_LOG_ADMIN,         // PolicyAuditFullSetInformation
        0,                              // Not applicable
        POLICY_TRUST_ADMIN,             // PolicyDnsDomainInformation
        POLICY_TRUST_ADMIN,             // PolicyDnsDomainInformationInt
};

ACCESS_MASK LsapDbRequiredAccessSetDomainPolicy[PolicyDomainKerberosTicketInformation + 1] = {

        0,                              // Information classes start at 2
        0,                              // PolicyDomainQualityOfServiceInformation (outdated)
        POLICY_SERVER_ADMIN,            // PolicyDomainEfsInformation
        POLICY_SERVER_ADMIN             // PolicyDomainKerberosTicketInformation
};


//
// Table of accesses required to query TrustedDomain Information.  This table
// is indexed by TrustedDomain Information Class
//

ACCESS_MASK LsapDbRequiredAccessQueryTrustedDomain[TrustedDomainFullInformation2Internal + 1] = {

    0,                              // Information classes start at 1
    TRUSTED_QUERY_DOMAIN_NAME,      // TrustedDomainNameInformation
    TRUSTED_QUERY_CONTROLLERS,      // TrustedControllersInformation
    TRUSTED_QUERY_POSIX,            // TrustedPosixOffsetInformation
    TRUSTED_QUERY_AUTH,             // TrustedPasswordInformation
    TRUSTED_QUERY_DOMAIN_NAME,      // TrustedDomainInformationBasic
    TRUSTED_QUERY_DOMAIN_NAME,      // TrustedDomainInformationEx
    TRUSTED_QUERY_AUTH,             // TrustedDomainAuthInformation
    TRUSTED_QUERY_DOMAIN_NAME |
        TRUSTED_QUERY_POSIX |
        TRUSTED_QUERY_AUTH,         // TrustedDomainFullInformation
    TRUSTED_QUERY_AUTH,             // TrustedDomainAuthInformationInternal
    TRUSTED_QUERY_DOMAIN_NAME |
        TRUSTED_QUERY_POSIX |
        TRUSTED_QUERY_AUTH,         // TrustedDomainFullInformationInternal
    TRUSTED_QUERY_DOMAIN_NAME,      // TrustedDomainInformationEx2Internal
    TRUSTED_QUERY_DOMAIN_NAME |
        TRUSTED_QUERY_POSIX |
        TRUSTED_QUERY_AUTH          // TrustedDomainFullInformation2Internal
};

//
// Table of accesses required to set TrustedDomain Information.  This table
// is indexed by TrustedDomain Information Class
//

ACCESS_MASK LsapDbRequiredAccessSetTrustedDomain[TrustedDomainFullInformation2Internal + 1] = {

    0,                              // Information classes start at 1
    0,                              // not settable (TrustedDomainNameInformation)
    TRUSTED_SET_CONTROLLERS,        // TrustedControllersInformation
    TRUSTED_SET_POSIX,              // TrustedPosixOffsetInformation
    TRUSTED_SET_AUTH,               // TrustedPasswordInformation
    TRUSTED_SET_POSIX,              // TrustedDomainInformationBasic  POSIX is a bad bit, but its too late to change it
    TRUSTED_SET_POSIX,              // TrustedDomainInformationEx     POSIX is a bad bit, but its too late to change it
    TRUSTED_SET_AUTH,               // TrustedDomainAuthInformation
    TRUSTED_SET_POSIX |
        TRUSTED_SET_AUTH,           // TrustedDomainFullInformation
    TRUSTED_SET_AUTH,               // TrustedDomainAuthInformationInternal
    TRUSTED_SET_POSIX |
        TRUSTED_SET_POSIX |
        TRUSTED_SET_AUTH,           // TrustedDomainFullInformationInternal
    TRUSTED_SET_POSIX,              // TrustedDomainInformationEx2Internal    POSIX is a bad bit, but its too late to change it
    TRUSTED_SET_POSIX |
        TRUSTED_SET_AUTH            // TrustedDomainFullInformation2Internal
};


//
// Cached Policy Object.  Only default Quota Limits is cached just now.
//

LSAP_DB_POLICY LsapDbPolicy = {0};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dspolicy\dbadmin.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbadmin.c

Abstract:

    Local Security Authority - Database Administration

    This file contains routines that perform general Lsa Database
    administration functions

Author:

    Scott Birrell       (ScottBi)       August 27, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include "adtp.h"

#if DBG
LSADS_THREAD_INFO_NODE LsapDsThreadInfoList[ LSAP_THREAD_INFO_LIST_MAX ];
SAFE_RESOURCE LsapDsThreadInfoListResource;
#endif

LSADS_INIT_STATE LsaDsInitState;



NTSTATUS
LsapDbSetStates(
    IN ULONG DesiredStatesSet,
    IN LSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId
    )

/*++

Routine Description:

    This routine turns on special states in the Lsa Database.  These
    states can be turned off using LsapDbResetStates.

Arguments:

    DesiredStatesSet - Specifies the states to be set.

        LSAP_DB_LOCK - Acquire the Lsa Database lock.

        LSAP_DB_LOG_QUEUE_LOCK - Acquire the Lsa Audit Log
            Queue Lock.

        LSAP_DB_START_TRANSACTION - Start an Lsa Database transaction.  There
            must not already be one in progress.

        LSAP_DB_READ_ONLY_TRANSACTION - Open a transaction for read only

        LSAP_DB_DS_OP_TRANSACTION - Perform a single Ds operation per transaction

    ObjectHandle - Pointer to handle to be validated and referenced.

    ObjectTypeId - Specifies the expected object type to which the handle
        relates.  An error is returned if this type does not match the
        type contained in the handle.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_STATE - The Database is not in the correct state
            to allow this state change.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    ULONG StatesSetHere = 0;
    LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )ObjectHandle;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbSetStates\n" ));

    //
    // If we have an object type that doesn't write to the Ds, make sure we have
    // the options set appropriately
    //

    if ( ObjectTypeId == PolicyObject ||
         ObjectTypeId == AccountObject ) {

        DesiredStatesSet |= LSAP_DB_NO_DS_OP_TRANSACTION;
    }

    if ( ObjectTypeId == TrustedDomainObject ) {

        DesiredStatesSet |= LSAP_DB_READ_ONLY_TRANSACTION;
    }

    //
    // If requested, lock the Audit Log Queue
    //

    if (DesiredStatesSet & LSAP_DB_LOG_QUEUE_LOCK) {

        Status = LsapAdtAcquireLogFullLock();

        if (!NT_SUCCESS(Status)) {

            goto SetStatesError;
        }

        StatesSetHere |= LSAP_DB_LOG_QUEUE_LOCK;
    }

    //
    // If requested, lock the Lsa database
    //

    if (DesiredStatesSet & LSAP_DB_LOCK) {

        LsapDbAcquireLockEx( ObjectTypeId,
                             DesiredStatesSet );

        StatesSetHere |= LSAP_DB_LOCK;
    }

    //
    // If requested, open a database update transaction.
    //

    if ( FLAG_ON( DesiredStatesSet, LSAP_DB_READ_ONLY_TRANSACTION |
                                    LSAP_DB_NO_DS_OP_TRANSACTION |
                                    LSAP_DB_DS_OP_TRANSACTION |
                                    LSAP_DB_START_TRANSACTION ) ) {


        Status = LsapDbOpenTransaction( DesiredStatesSet );

        if (!NT_SUCCESS(Status)) {

            goto SetStatesError;
        }

        StatesSetHere |= LSAP_DB_START_TRANSACTION;
    }

SetStatesFinish:

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbSetStates: 0x%lx\n", Status ));
    return( Status );

SetStatesError:

    //
    // If we started a transaction, abort it.
    //

    if (StatesSetHere & LSAP_DB_START_TRANSACTION) {

        SecondaryStatus = LsapDbAbortTransaction( DesiredStatesSet );
    }

    //
    // If we locked the database, unlock it.
    //

    if (StatesSetHere & LSAP_DB_LOCK) {

        LsapDbReleaseLockEx( ObjectTypeId,
                             DesiredStatesSet );
    }

    //
    // If we locked the Audit Log Queue, unlock it.
    //

    if (StatesSetHere & LSAP_DB_LOG_QUEUE_LOCK) {

        LsapAdtReleaseLogFullLock();
    }

    goto SetStatesFinish;
}



NTSTATUS
LsapDbResetStates(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType,
    IN NTSTATUS PreliminaryStatus
    )

/*++

Routine Description:

    This function resets the Lsa Database states specified.  It is used
    to reset states set by LsapDbSetStates.

Arguments:

    ObjectHandle - Handle to an LSA object.  This is expected to have
        already been validated.

    Options - Specifies optional actions, including states to be reset

        LSAP_DB_LOCK - Lsa Database lock to be released

        LSAP_DB_LOG_QUEUE_LOCK - Lsa Audit Log Queue Lock to
            be released.

        LSAP_DB_FINISH_TRANSACTION - Lsa database transaction open.

        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION - Omit notification to
             Replicators.

    ObjectTypeId - Specifies the expected object type to which the handle
        relates.

    PreliminaryStatus - Indicates the preliminary result code of the
        calling routine.  Allows reset action to vary depending on the
        result code, for example, apply or abort transaction.

Return Value:

    NTSTATUS - Standard Nt Result Code.  This is the final status to be used
        by the caller and is equal to the Preliminary status except in the
        case where that is as success status and this routine fails.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )ObjectHandle;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbResetStates (Prelim: 0x%lx )\n", PreliminaryStatus ));

    //
    // If we have an object type that doesn't write to the Ds, make sure we have
    // the options set appropriately
    //
    if ( ObjectTypeId == PolicyObject ||
         ObjectTypeId == AccountObject ) {

        Options |= LSAP_DB_NO_DS_OP_TRANSACTION;
    }

    if ( ObjectTypeId == TrustedDomainObject ) {

        Options |= LSAP_DB_READ_ONLY_TRANSACTION;
    }

    //
    // If requested, finish a database update transaction.
    //
    if ( !FLAG_ON( Options, LSAP_DB_STANDALONE_REFERENCE ) &&
         FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION |
                              LSAP_DB_NO_DS_OP_TRANSACTION |
                              LSAP_DB_DS_OP_TRANSACTION |
                              LSAP_DB_FINISH_TRANSACTION ) ) {

        if (NT_SUCCESS(PreliminaryStatus)) {

            Status = LsapDbApplyTransaction(
                         ObjectHandle,
                         Options,
                         SecurityDbDeltaType
                         );

        } else {

            Status = LsapDbAbortTransaction( Options );
        }
    }

    //
    // If unlocking requested, unlock the Lsa Database.
    //

    if (Options & LSAP_DB_LOCK) {

        LsapDbReleaseLockEx( ObjectTypeId,
                             Options );
    }

    //
    // If unlocking if the Audit Log Queue requested, unlock the queue.
    //

    if (Options & LSAP_DB_LOG_QUEUE_LOCK) {

        LsapAdtReleaseLogFullLock();
    }

    //
    // The requested reset operations were performed successfully.
    // Propagate the preliminary status back to the caller.
    //

    if ( NT_SUCCESS( Status ))
    {
        Status = PreliminaryStatus;
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbResetStates: 0x%lx\n", Status ));
    return( Status );
}



NTSTATUS
LsapDbOpenTransaction(
    IN ULONG Options
    )

/*++

Routine Description:

    This function starts a transaction within the LSA Database.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    Options - Options to apply when opening the transaction.  Valid values are:
        LSAP_DB_READ_ONLY_TRANSACTION - Open a transaction for read only

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes are those returned from the Registry Transaction
        Package.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  RegTransactionOpened = FALSE;

    if ( !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) ) {

        Status = LsapRegOpenTransaction();
        if (NT_SUCCESS(Status))
        {
            RegTransactionOpened = TRUE;
        }
    }

    if ( NT_SUCCESS( Status ) && LsapDsIsFunctionTableValid() ) {

        ASSERT( LsaDsStateInfo.DsFuncTable.pOpenTransaction );
        Status = (*LsaDsStateInfo.DsFuncTable.pOpenTransaction) ( Options );
        if ((!NT_SUCCESS(Status)) && RegTransactionOpened)
        { 
            NTSTATUS IgnoreStatus;

            IgnoreStatus = LsapRegAbortTransaction();
        }
    }

    return Status;
}



NTSTATUS
LsapDbApplyTransaction(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType
    )

/*++

Routine Description:

    This function applies a transaction within the LSA Database.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    ObjectHandle - Handle to an LSA object.  This is expected to have
        already been validated.

    Options - Specifies optional actions to be taken.  The following
        options are recognized, other options relevant to calling routines
        are ignored.

        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION - Omit notification to
            Replicator.

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes are those returned from the Registry Transaction
        Package.
--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )ObjectHandle;
    BOOLEAN RegApplied = FALSE, Notify = FALSE;
    BOOLEAN RestoreModifiedId = FALSE;
    BOOLEAN RegistryLocked = FALSE;
    LARGE_INTEGER Increment = {1,0},
                  OriginalModifiedId = { 0 };
    PLSADS_PER_THREAD_INFO CurrentThreadInfo;
    ULONG SavedDsOperationCount = 0;

    //
    // Reference the thread state so it doesn't disappear in the middle of this
    //  routine.
    //

    CurrentThreadInfo = LsapQueryThreadInfo();

    if ( CurrentThreadInfo ) {

        SavedDsOperationCount = CurrentThreadInfo->DsOperationCount;
        LsapCreateThreadInfo();
    }

    //
    // Verify that the LSA Database is locked
    // One of many locks is locked
    //
    //ASSERT (LsapDbIsLocked());

    //
    // Apply the DS transaction before grabbing any more locks.
    //
    // Note that this applies the transaction before updating the modified ID.
    // If we crash before updateing the modified ID, NT 4 BDCs won't be notified
    // of this change.
    //

    if ( LsapDsIsFunctionTableValid() ) {

        ASSERT( LsaDsStateInfo.DsFuncTable.pApplyTransaction );
        Status = (*LsaDsStateInfo.DsFuncTable.pApplyTransaction)( Options );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
    }

    //
    // Notify the replicator unless:
    //  We are to omit replicator (e.g. for creation of a local secret), OR
    //  we are installing the Policy Object,
    //  notification globally disabled.
    //

    if ((!(Options & LSAP_DB_OMIT_REPLICATOR_NOTIFICATION)) &&
        (LsapDbHandle != NULL) &&
        (LsapDbState.ReplicatorNotificationEnabled )) {

        BOOLEAN DbChanged = FALSE;

        //
        // If the object is in the DS,
        //  determine if the DS changed.
        //

        if ( LsapDsIsHandleDsHandle( InternalHandle )) {

            //
            // Netlogon notification of DS object change is *ALWAYS* handled
            //  in the DS notification callback routine.  That's the easiest
            //  way to handle things like TDO changes result in both TDO notifications
            //  and the corresponding global secret notification.
            //

            ASSERT( InternalHandle->ObjectTypeId == TrustedDomainObject ||
                    InternalHandle->ObjectTypeId == SecretObject );

        //
        // If the object is a registry object,
        //  determine if the registry has changed.
        //

        } else {

            //
            // Grab the registry lock.
            //  It serializes access to the global ModifiedId
            //

            LsapDbLockAcquire( &LsapDbState.RegistryLock );
            RegistryLocked = TRUE;

            ASSERT( SavedDsOperationCount == 0 ||
                    InternalHandle->ObjectTypeId == PolicyObject );

            if ( LsapDbState.RegistryModificationCount > 0 ) {
                DbChanged = TRUE;

                //
                // No one should change the database on a read only transaction.
                //

                ASSERT( !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION) );
            }
        }

        //
        // If the DbChanged,
        //  increment the NT 4 change serial number.
        //

        if ( DbChanged ) {

            OriginalModifiedId = LsapDbState.PolicyModificationInfo.ModifiedId;
            RestoreModifiedId = TRUE;

            //
            // Increment Modification Count.
            //

            //
            // we want to increment the modification count only if we
            // are running on a DC
            //
            // see bug# 327474
            //

            if (LsapProductType == NtProductLanManNt)
            {
                LsapDbState.PolicyModificationInfo.ModifiedId.QuadPart +=
                    Increment.QuadPart;
            }

            if ( FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) ) {

                Status = LsapRegOpenTransaction();

                if ( !NT_SUCCESS( Status ) ) {

                    goto Cleanup;
                }

                Options &= ~LSAP_DB_READ_ONLY_TRANSACTION;
            }

            Status = LsapDbWriteAttributeObject( LsapDbHandle,
                                                 &LsapDbNames[ PolMod ],
                                                 &LsapDbState.PolicyModificationInfo,
                                                 (ULONG) sizeof (POLICY_MODIFICATION_INFO) );

            if (!NT_SUCCESS(Status)) {

                goto Cleanup;
            }

            Notify = TRUE;

            //
            // Invalidate the cache for the Policy Modification Information
            //

            LsapDbMakeInvalidInformationPolicy( PolicyModificationInformation );
        }

    } else {

        Notify = FALSE;
    }

    //
    // If there is a registry transaction in progress,
    //  apply it.
    //

    if ( !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) ) {

        // Either we locked it or our caller did
        ASSERT( LsapDbIsLocked( &LsapDbState.RegistryLock ));

        //
        // Apply the Registry Transaction.
        //

        Status = LsapRegApplyTransaction( );

        if ( !NT_SUCCESS( Status ) ) {

            goto Cleanup;
        }

        RegApplied = TRUE;
    }

    //
    // Notify the Replicator
    //

    if ( Notify ) {

        Status = LsapDbNotifyChangeObject( ObjectHandle, SecurityDbDeltaType );

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    if ( !NT_SUCCESS(Status) ) {

        //
        // Transaction failed.  Adjust in-memory copy of the Modification
        // Count, noting that backing store copy is unaltered.
        //

        if ( RestoreModifiedId ) {
            LsapDbState.PolicyModificationInfo.ModifiedId = OriginalModifiedId;
        }

        //
        // Abort the registry transaction
        //  (Unless the isn't one or it has already been applied.)
        //

        if ( !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) && !RegApplied ) {
            (VOID) LsapRegAbortTransaction( );
        }
    }

    if ( RegistryLocked ) {
        LsapDbLockRelease( &LsapDbState.RegistryLock );
    }
    if ( CurrentThreadInfo ) {
        LsapClearThreadInfo();
    }

    return( Status );
}



NTSTATUS
LsapDbAbortTransaction(
    IN ULONG Options
    )

/*++

Routine Description:

    This function aborts a transaction within the LSA Database.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes are those returned from the Registry Transaction
        Package.
--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    //
    // Verify that the LSA Database is locked
    //  (One of many locks is locked.)
    // ASSERT (LsapDbIsLocked());

    //
    // Abort the Registry Transaction
    //
    if ( !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) ) {

        ASSERT( LsapDbIsLocked( &LsapDbState.RegistryLock ));

        Status = LsapRegAbortTransaction( );
        ASSERT( NT_SUCCESS( Status ) );
    }

    if ( NT_SUCCESS( Status ) && LsapDsIsFunctionTableValid() ) {

        ASSERT( LsaDsStateInfo.DsFuncTable.pAbortTransaction );
        Status = (*LsaDsStateInfo.DsFuncTable.pAbortTransaction)( Options );

        ASSERT( NT_SUCCESS( Status ) );
    }

    return ( Status );
}



BOOLEAN
LsapDbIsServerInitialized(
    )

/*++

Routine Description:

    This function indicates whether the Lsa Database Server is initialized.

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE if the LSA Database Server is initialized, else FALSE.

--*/

{
    if (LsapDbState.DbServerInitialized) {

        return TRUE;

    } else {

        return FALSE;
    }
}


VOID
LsapDbEnableReplicatorNotification(
    )

/*++

Routine Description:

    This function turns on Replicator Notification.

Arguments:

    None.

Return Value:

    None.
--*/

{
    LsapDbState.ReplicatorNotificationEnabled = TRUE;
}



VOID
LsapDbDisableReplicatorNotification(
    )

/*++

Routine Description:

    This function turns off Replicator Notification.

Arguments:

    None.

Return Value:

    None.
--*/

{
    LsapDbState.ReplicatorNotificationEnabled = FALSE;
}



VOID
LsapDbAcquireLockEx(
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ULONG Options
    )
/*++

Routine Description:

    This function manages the lock status of the LSA database for a given operation.
    The LSA no longer grabs a global lock for all operations.  Instead, access locking only
    occurs for operations involving a write.  Locks can be obtained for read or write, or
    converted between the two.

Arguments:

    ObjectTypeId - Specifies the expected object type to which the handle
        relates.  An error is returned if this type does not match the
        type contained in the handle.

    Options - Specifies optional additional actions including database state
        changes to be made, or actions not to be performed.

        LSAP_DB_READ_ONLY_TRANSACTION    do not lock the registry lock

Return Value:

    None

--*/
{
    BOOLEAN RegLock = FALSE;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbAcquireLockEx(%x,%x)\n",
                        ObjectTypeId, Options ));

    ASSERT( ObjectTypeId == PolicyObject ||
            ObjectTypeId == TrustedDomainObject ||
            ObjectTypeId == AccountObject ||
            ObjectTypeId == SecretObject ||
            ObjectTypeId == NullObject ||
            ObjectTypeId == AllObject );

    //
    // Determine what lock we're talking about
    //
    switch ( ObjectTypeId ) {
    case PolicyObject:
        LsapDbLockAcquire( &LsapDbState.PolicyLock );
        RegLock = TRUE;
        break;

    case TrustedDomainObject:
        LsapDbAcquireWriteLockTrustedDomainList();
        break;

    case AccountObject:
        LsapDbLockAcquire( &LsapDbState.AccountLock );
        RegLock = TRUE;
        break;

    case SecretObject:
        LsapDbAcquireWriteLockTrustedDomainList();
        LsapDbLockAcquire( &LsapDbState.SecretLock );
        RegLock = TRUE;
        break;

    case NullObject:
        break;

    case AllObject:
        LsapDbLockAcquire( &LsapDbState.PolicyLock );
        LsapDbAcquireWriteLockTrustedDomainList();
        LsapDbLockAcquire( &LsapDbState.AccountLock );
        LsapDbLockAcquire( &LsapDbState.SecretLock );
        RegLock = TRUE;
        break;

    default:
        goto AcquireLockExExit;
    }

    //
    // See about the registry lock.  Only take it after holding an object type lock.
    //
    if ( RegLock &&
         !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) ) {

        LsapDbLockAcquire( &LsapDbState.RegistryLock );
    }

AcquireLockExExit:

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbAcquireLockEx\n" ));
    return;
}



VOID
LsapDbReleaseLockEx(
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ULONG Options
    )
/*++

Routine Description:

    This function releases the lock obtained in the previous function.  Depending on the
    state of the preliminary status, the potentially opened transaction is either aborted or
    applied

Arguments:

    ObjectTypeId - Specifies the expected object type to which the handle
        relates.  An error is returned if this type does not match the
        type contained in the handle.

    Options - Specifies optional additional actions including database state
        changes to be made, or actions not to be performed.

        LSAP_DB_READ_ONLY_TRANSACTION    do not release the registry lock

Return Value:

    None

--*/
{
    BOOLEAN RegLock = FALSE;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbReleaseLockEx(%x,%x)\n",
                     ObjectTypeId, Options ));

    //
    // Special-case check until reference count handling logic is fixed,
    // then it should go away.
    //
    if ( FLAG_ON( Options, LSAP_DB_NO_LOCK ) && !FLAG_ON( Options, LSAP_DB_LOCK ) ) {

        goto ReleaseLockExExit;
    }

    ASSERT( ObjectTypeId == PolicyObject ||
            ObjectTypeId == TrustedDomainObject ||
            ObjectTypeId == AccountObject ||
            ObjectTypeId == SecretObject ||
            ObjectTypeId == NullObject ||
            ObjectTypeId == AllObject );

    //
    // Determine what lock we're talking about
    //
    switch ( ObjectTypeId ) {
    case PolicyObject:
        LsapDbLockRelease( &LsapDbState.PolicyLock );
        RegLock = TRUE;
        break;

    case TrustedDomainObject:
        LsapDbReleaseLockTrustedDomainList();
        break;

    case AccountObject:
        LsapDbLockRelease( &LsapDbState.AccountLock );
        RegLock = TRUE;
        break;

    case SecretObject:
        LsapDbReleaseLockTrustedDomainList();
        LsapDbLockRelease( &LsapDbState.SecretLock );
        RegLock = TRUE;
        break;

    case NullObject:
        break;

    case AllObject:
        LsapDbLockRelease( &LsapDbState.PolicyLock );
        LsapDbReleaseLockTrustedDomainList();
        LsapDbLockRelease( &LsapDbState.AccountLock );
        LsapDbLockRelease( &LsapDbState.SecretLock );
        RegLock = TRUE;
        break;

    default:
        goto ReleaseLockExExit;
    }

    //
    // See about the registry lock
    //
    if ( !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) && RegLock ) {

#if DBG
        HANDLE CurrentThread =(HANDLE) (NtCurrentTeb())->ClientId.UniqueThread;
        ASSERT( LsapDbState.RegistryLock.CriticalSection.OwningThread==CurrentThread);
        ASSERT( LsapDbIsLocked(&LsapDbState.RegistryLock));
#endif
        ASSERT( LsapDbState.RegistryTransactionOpen == FALSE );
        LsapDbLockRelease( &LsapDbState.RegistryLock );
    }

ReleaseLockExExit:

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbReleaseLockEx\n" ));
    return;
}



PLSADS_PER_THREAD_INFO
LsapCreateThreadInfo(
    VOID
    )
/*++

Routine Description:

    This function will create a thread info structure to be used to maintain state on
    the current operation while a ds/registry operation is happening

    If a thread info is currently active on the thread, it's ref count is incremented

Arguments:

    NONE

Return Value:

    Created thread info on success

    NULL on failure

--*/
{
    PLSADS_PER_THREAD_INFO CurrentThreadInfo = NULL;

    CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

    //
    // If we have a current operation state, increment it's use count so we know how many
    // times we have been called...
    //
    if ( CurrentThreadInfo ) {

        CurrentThreadInfo->UseCount++;

    } else {

        //
        // Have to allocate one
        //
        CurrentThreadInfo = LsapAllocateLsaHeap( sizeof( LSADS_PER_THREAD_INFO ) );

        if ( CurrentThreadInfo ) {

            if ( TlsSetValue( LsapDsThreadState, CurrentThreadInfo ) == FALSE ) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "TlsSetValue for %p on %lu failed with %lu\n",
                                 CurrentThreadInfo,
                                 GetCurrentThreadId(),
                                 GetLastError() ));

                LsapFreeLsaHeap( CurrentThreadInfo );
                CurrentThreadInfo = NULL;

            } else {

                RtlZeroMemory( CurrentThreadInfo, sizeof( LSADS_PER_THREAD_INFO ) );

                CurrentThreadInfo->UseCount++;

#if DBG
                //
                // Add ourselves to the list
                //
                SafeAcquireResourceExclusive( &LsapDsThreadInfoListResource, TRUE );
                {
                    ULONG i;
                    BOOLEAN Inserted = FALSE;

                    for (i = 0; i < LSAP_THREAD_INFO_LIST_MAX; i++ ) {

                        ASSERT( LsapDsThreadInfoList[ i ].ThreadId != GetCurrentThreadId( ));

                        if ( LsapDsThreadInfoList[ i ].ThreadInfo == NULL ) {

                            LsapDsThreadInfoList[ i ].ThreadInfo = CurrentThreadInfo;
                            LsapDsThreadInfoList[ i ].ThreadId = GetCurrentThreadId( );
                            Inserted = TRUE;
                            break;
                        }
                    }

                    if ( !Inserted ) {

                        LsapDsDebugOut(( DEB_ERROR,
                                         "Failed to insert THREAD_INFO %p in list for %lu: "
                                         "List full\n",
                                         CurrentThreadInfo,
                                         GetCurrentThreadId() ));
                    }
                }

                SafeReleaseResource( &LsapDsThreadInfoListResource );
#endif
            }
        }
    }

    return( CurrentThreadInfo );
}



VOID
LsapClearThreadInfo(
    VOID
    )
/*++

Routine Description:

    This function will remove a thread info structure to be used to maintain state on
    the current operation while a ds/registry operation is happening

    If a thread info's ref count is greater than 1, the ref count is decremented, but the
    thread info remains

Arguments:

    NONE

Return Value:

    VOID

--*/
{
    PLSADS_PER_THREAD_INFO CurrentThreadInfo = NULL;
    NTSTATUS Status;

    CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

    //
    // No thread info, nothing to do
    //
    if ( CurrentThreadInfo ) {

        if ( CurrentThreadInfo->UseCount > 1 ) {

            CurrentThreadInfo->UseCount--;

        } else {

            ASSERT( CurrentThreadInfo->UseCount == 1 );

            if ( CurrentThreadInfo->DsTransUseCount != 0 ) {
                ASSERT( CurrentThreadInfo->DsTransUseCount == 0 );
                LsapDsDebugOut(( DEB_ERROR,
                                 "Aborting transaction inside cleanup!\n" ));
                LsapDsCauseTransactionToCommitOrAbort( FALSE );
            }

            if ( CurrentThreadInfo->DsThreadStateUseCount != 0 ) {
                ASSERT( CurrentThreadInfo->DsThreadStateUseCount == 0 );
                LsapDsDebugOut(( DEB_ERROR,
                                 "Clear DS thread state inside cleanup!\n" ));

                Status = LsapDsMapDsReturnToStatus( THDestroy( ) );
                ASSERT( NT_SUCCESS( Status ) );

                THRestore( CurrentThreadInfo->InitialThreadState );
                CurrentThreadInfo->InitialThreadState = NULL;

                CurrentThreadInfo->DsThreadStateUseCount = 0;
            }

#if DBG
            //
            // Remove ourselves from the list
            //
            SafeAcquireResourceExclusive( &LsapDsThreadInfoListResource, TRUE );
            {
                ULONG i;
                for (i = 0; i < LSAP_THREAD_INFO_LIST_MAX; i++ ) {

                    if ( LsapDsThreadInfoList[ i ].ThreadId == GetCurrentThreadId( ) ) {

                        ASSERT( LsapDsThreadInfoList[ i ].ThreadInfo == CurrentThreadInfo );
                        LsapDsThreadInfoList[ i ].ThreadInfo = NULL;
                        LsapDsThreadInfoList[ i ].ThreadId = 0;
                        break;
                    }
                }
            }

            SafeReleaseResource( &LsapDsThreadInfoListResource );
#endif

            //
            // Clear the entry out of the thread local storage
            //
            if ( TlsSetValue( LsapDsThreadState, NULL ) == FALSE ) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "Failed to remove %p for thread %lu: %lu\n",
                                 CurrentThreadInfo,
                                 GetCurrentThreadId(),
                                 GetLastError() ));
            }

            LsapFreeLsaHeap( CurrentThreadInfo );
        }
    }
}



VOID
LsapSaveDsThreadState(
    VOID
    )
/*++

Routine Description:

    This function will save off the current DS thread state that may exist at the time
    the function is called.  It does not distinguish between a thread state created by
    an outside caller (say SAM), or one created by Lsa itself

    If a thread info block does not exist at the time this function is called, nothing
    is done

    Calling this function refcounts the thread info

Arguments:

    NONE

Return Value:

    VOID

--*/
{
    PLSADS_PER_THREAD_INFO CurrentThreadInfo = NULL;

    CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

    //
    // No thread info, nothing to do
    //
    if ( CurrentThreadInfo ) {

        ASSERT( CurrentThreadInfo->UseCount > 0 );
        CurrentThreadInfo->UseCount++;

        ASSERT( !CurrentThreadInfo->SavedTransactionValid );
        CurrentThreadInfo->SavedTransactionValid = TRUE;
        CurrentThreadInfo->SavedThreadState = THSave();
    }
}



VOID
LsapRestoreDsThreadState(
    VOID
    )
/*++

Routine Description:

    This function will restore a previously saved DS thread state

    If a thread info block does not exist at the time this function is called or there is
    no previously saved state exists, nothing is done

    Calling this function refcounts the thread info

Arguments:

    NONE

Return Value:

    VOID

--*/
{
    PLSADS_PER_THREAD_INFO CurrentThreadInfo = NULL;

    CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

    //
    // No thread info, nothing to do
    //
    if ( CurrentThreadInfo ) {

        CurrentThreadInfo->UseCount--;
        ASSERT( CurrentThreadInfo->UseCount > 0 );

        if ( CurrentThreadInfo->SavedTransactionValid == TRUE ) {

            CurrentThreadInfo->SavedTransactionValid = FALSE;
            if ( CurrentThreadInfo->SavedThreadState ) {

                THRestore( CurrentThreadInfo->SavedThreadState );
            }

            CurrentThreadInfo->SavedThreadState = NULL;
        }
    }
}



VOID
LsapServerRpcThreadReturnNotify(
    LPWSTR CallingFunction
    )
/*++

Routine Description:

    This API is called when an RPC thread which has a notify routine specified in the servers
    ACF file.


Arguments:

    NONE

Return Values:

    NONE

--*/
{
#if DBG
    static BOOLEAN CleanAsRequired = TRUE;
    PLSADS_PER_THREAD_INFO CurrentThreadInfo = NULL;
    NTSTATUS Status;
    HANDLE ThreadHandle = GetCurrentThread();

    if ( ( LsaDsInitState == LsapDsNoDs ) ||
         ( LsaDsInitState == LsapDsUnknown ) )
    {
        return ;
    }

    CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

    ASSERT( CurrentThreadInfo == NULL );

    if ( CurrentThreadInfo ) {

        LsapDsDebugOut(( DEB_ERROR, "ThreadInfo left by %ws\n", CallingFunction ));
        LsapClearThreadInfo();
    }

    ASSERT( !THQuery() );

    if ( THQuery() ) {

        LsapDsDebugOut(( DEB_ERROR,
                         "Open threadstate in cleanup.  Aborting...\n" ));

        if ( SampExistsDsTransaction() ) {

            LsapDsDebugOut(( DEB_ERROR, "Ds transaction left by %ws\n", CallingFunction ));
            LsapDsCauseTransactionToCommitOrAbort( FALSE );
            THDestroy( );
        }
    }

    //
    // Make sure we are not holding any of the locks when we exit
    //
#if 0
    ASSERT( ThreadHandle != LsapDbState.AccountLock.ExclusiveOwnerThread );
    ASSERT( ThreadHandle != LsapDbState.PolicyLock.ExclusiveOwnerThread );
    ASSERT( ThreadHandle != LsapDbState.SecretLock.ExclusiveOwnerThread );
    ASSERT( ThreadHandle != LsapDbState.RegistryLock.ExclusiveOwnerThread );
#endif

#endif

    UNREFERENCED_PARAMETER( CallingFunction );
}


NTSTATUS
LsaIHealthCheck(
    IN OPTIONAL LSAPR_HANDLE DomainHandle,
    IN ULONG StateChange,
    IN OUT PVOID StateChangeData,
    IN OUT PULONG StateChangeDataLength
    )

/*++

Routine Description:

    This function is actually invoked by Sam to indicate that state of interest to the Lsa
    has changed, and provide that state to the Lsa.  Specifically, currently, it is the Sam
    SessionKey

    This function USED to perform sanity checks within LSA.  It was invoked from
    SAM on a regular basis.  However, it was no longer needed.  Instead, we took the
    function, leaving the appropriate export from lsasrv.dll, to obsfucate the fact that
    we are now using to pass the Sam encryption key back and forth...

Arguments:

    DomainHandle - What domain this refers to.  Null means the root domain

    StateChange - What Sam/other in process client state changed that LSA cares about.  Can be:
        LSAI_SAM_STATE_SESS_KEY -   SAM's session key has changed

    StateChangeData - What data has changed.  Dependent on the type of the state change.  The
        data format must be pre-agreed upon by the Lsa and the invoker.


Return Values:

    None.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING CipherKey;

    LsapEnterFunc( "LsaIHealthCheck" );

    UNREFERENCED_PARAMETER( DomainHandle );

    switch ( StateChange ) {
    case LSAI_SAM_STATE_SESS_KEY:

        //
        // Copy the syskey into memory
        //

        ASSERT(LSAP_SYSKEY_SIZE==*StateChangeDataLength);
        
        LsapDbSetSyskey(StateChangeData, LSAP_SYSKEY_SIZE);

        //
        // Now do a database upgrade if necessary
        //

        Status = LsapDbUpgradeRevision(TRUE, FALSE);
        break;

    case LSAI_SAM_STATE_UNROLL_SP4_ENCRYPTION:

        CipherKey.Length = CipherKey.MaximumLength = (USHORT)*StateChangeDataLength;
        CipherKey.Buffer = StateChangeData;
        Status = LsapDbInitializeCipherKey( &CipherKey,
                                            &LsapDbSP4SecretCipherKey );

        break;

    case LSAI_SAM_STATE_RETRIEVE_SESS_KEY:

        //
        // Return the syskey as part of state change data
        //
        
        if (NULL!=LsapDbSysKey)
        {
            RtlCopyMemory(StateChangeData, LsapDbSysKey, LSAP_SYSKEY_SIZE);
            *StateChangeDataLength = LSAP_SYSKEY_SIZE;
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
        }
        break;

    case LSAI_SAM_STATE_CLEAR_SESS_KEY:

        //
        // Clear the syskey in memory
        //

        RtlZeroMemory(LsapDbSysKey,LSAP_SYSKEY_SIZE);
        LsapDbSysKey = NULL;
        break;

    case LSAI_SAM_GENERATE_SESS_KEY:

        //
        // Generate a new syskey and perform the database upgrade
        //
        
        Status = LsapDbUpgradeRevision(TRUE,TRUE);
        break;

    case LSAI_SAM_STATE_OLD_SESS_KEY:

        //
        // Return the old syskey as part of state change data
        //
        
        if (NULL!=LsapDbOldSysKey)
        {
            RtlCopyMemory(StateChangeData, LsapDbOldSysKey, LSAP_SYSKEY_SIZE);
            *StateChangeDataLength = LSAP_SYSKEY_SIZE;
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
        }
        break;

    default:
        LsapDsDebugOut(( DEB_ERROR,
                         "Unhandled state change %lu\n", StateChange ));
        break;

    }

    LsapExitFunc( "LsaIHealthCheck", Status );

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dsexe\lsass.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsass.c

Abstract:

    Local Security Authority Subsystem - Main Program.

Author:

    Scott Birrell       (ScottBi)    Mar 12, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "ntrpcp.h"
#include "lmcons.h"
#include "lmalert.h"
#include "alertmsg.h"
#include <samisrv.h>
#include "safemode.h"



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Shared Global Variables                                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



#if DBG

#ifdef _X86_
extern DWORD_PTR    __security_cookie;  /* /GS security cookie */
extern PVOID __safe_se_handler_table[]; /* base of safe handler entry table */
extern BYTE  __safe_se_handler_count;   /* absolute symbol whose address is
                                           the count of table entries */
#endif

IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    sizeof(_load_config_used),  // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // GlobalFlagsClear
    0,                          // GlobalFlagsSet
    900000,                     // CriticalSectionTimeout (milliseconds)
    0,                          // DeCommitFreeBlockThreshold
    0,                          // DeCommitTotalFreeThreshold
    0,                          // LockPrefixTable
    0, 0, 0, 0, 0, 0, 0,         // Reserved
#ifdef _X86_
    (DWORD)&__security_cookie,
    (DWORD)__safe_se_handler_table,
    (DWORD)&__safe_se_handler_count
#else
    0, 0, 0
#endif
};


#endif \\DBG



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Internal routine prototypes                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



VOID
LsapNotifyInitializationFinish(
   IN NTSTATUS CompletionStatus
   );




/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Routines                                                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

LONG
WINAPI
LsaTopLevelExceptionHandler(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )

/*++

Routine Description:

    The Top Level exception filter for lsass.exe.

    This ensures the entire process will be cleaned up if any of
    the threads fail.  Since lsass.exe is a distributed application,
    it is better to fail the entire process than allow random threads
    to continue executing.

Arguments:

    ExceptionInfo - Identifies the exception that occurred.


Return Values:

    EXCEPTION_EXECUTE_HANDLER - Terminate the process.

    EXCEPTION_CONTINUE_SEARCH - Continue processing as though this filter
        was never called.


--*/
{
    return RtlUnhandledExceptionFilter(ExceptionInfo);
}



VOID __cdecl
main ()
{
    NTSTATUS  Status = STATUS_SUCCESS;
    KPRIORITY BasePriority;
    BOOLEAN   EnableAlignmentFaults = TRUE;
    LSADS_INIT_STATE    LsaDsInitState;


    //
    // Define a top-level exception handler for the entire process.
    //

    SetErrorMode( SEM_FAILCRITICALERRORS );

    SetUnhandledExceptionFilter( &LsaTopLevelExceptionHandler );

    RtlSetProcessIsCritical(TRUE, NULL, TRUE);


    //
    // Run the LSA in the foreground.
    //
    // Several processes which depend on the LSA (like the lanman server)
    // run in the foreground.  If we don't run in the foreground, they'll
    // starve waiting for us.
    //

    BasePriority = FOREGROUND_BASE_PRIORITY;

    Status = NtSetInformationProcess(
                NtCurrentProcess(),
                ProcessBasePriority,
                &BasePriority,
                sizeof(BasePriority)
                );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // Do the following:
    //
    //
    //      Check the boot environment
    //          If this is a DC booted into safe mode, set the appropriate
    //          flag so LsaISafeBoot returns TRUE.
    //
    //      Initialize the service-controller service
    //      dispatcher.
    //
    //      Initialize LSA Pass-1
    //          This starts the RPC server.
    //          Does not do product type-specific initialization.
    //
    //      Pause for installation if necessary
    //          Allows product type-specific information to be
    //          collected.
    //
    //      Initialize LSA Pass-2
    //          Product type-specific initialization.
    //
    //      Initialize SAM
    //

    //
    // Analyse the boot environment
    //
    Status = LsapCheckBootMode();
    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }


    //
    // Initialize the service dispatcher.
    //
    // We initialize the service dispatcher before the sam
    // service is started.  This will make the service controller
    // start successfully even if SAM takes a long time to initialize.
    //

    Status = ServiceInit();

    if (!NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    //
    // Initialize the LSA.
    // If unsuccessful, we must exit with status so that the SM knows
    // something has gone wrong.
    //

    Status = LsapInitLsa();

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // Initialize SAM
    //

    Status = SamIInitialize();

    if (!NT_SUCCESS(Status) ) {

        goto Cleanup;
    }


    //
    // Do the second phase of the dc promote/demote API initialization
    //
    Status = LsapDsInitializePromoteInterface();
    if (!NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    //
    // Open a Trusted Handle to the local SAM server.
    //

    Status = LsapAuOpenSam( TRUE );

    if (!NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    //
    // Handle the LsaDs initialization
    //

    if ( NT_SUCCESS( Status ) ) {

        if ( SampUsingDsData() ) {

            LsaDsInitState = LsapDsDs;

        } else {

            LsaDsInitState = LsapDsNoDs;

        }

        Status = LsapDsInitializeDsStateInfo( LsaDsInitState );
        if ( !NT_SUCCESS( Status ) ) {

            goto Cleanup;
        }
    }


Cleanup:

    LsapNotifyInitializationFinish(Status);

    ExitThread( Status );

}

VOID
LsapNotifyInitializationFinish(
   IN NTSTATUS CompletionStatus
   )

/*++

Routine Description:

    This function handles the notification of successful or
    unsuccessful completion of initialization of the Security Process
    lsass.exe.  If initialization was unsuccessful, a popup appears.  If
    setup was run, one of two events is set.  The SAM_SERVICE_STARTED event
    is set if LSA and SAM started OK and the SETUP_FAILED event is set if LSA
    or SAM server setup failed.  Setup waits multiple on this object pair so
    that it can detect either event being set and notify the user if necessary
    that setup failed.

Arguments:

    CompletionStatus - Contains a standard Nt Result Code specifying
        the success or otherwise of the initialization/installation.

Return Values:

    None.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Response;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES EventAttributes;
    HANDLE EventHandle = NULL;

    if (NT_SUCCESS(CompletionStatus)) {

        //
        // Set an event telling anyone wanting to call SAM that we're initialized.
        //

        RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
        InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

        Status = NtCreateEvent(
                     &EventHandle,
                     SYNCHRONIZE|EVENT_MODIFY_STATE,
                     &EventAttributes,
                     NotificationEvent,
                     FALSE                // The event is initially not signaled
                     );


        if ( !NT_SUCCESS(Status)) {

            //
            // If the event already exists, a waiting thread beat us to
            // creating it.  Just open it.
            //

            if( Status == STATUS_OBJECT_NAME_EXISTS ||
                Status == STATUS_OBJECT_NAME_COLLISION ) {

                Status = NtOpenEvent(
                             &EventHandle,
                             SYNCHRONIZE|EVENT_MODIFY_STATE,
                             &EventAttributes
                             );
            }

            if ( !NT_SUCCESS(Status)) {

                KdPrint(("SAMSS:  Failed to open SAM_SERVICE_STARTED event. %lX\n",
                     Status ));
                KdPrint(("        Failing to initialize SAM Server.\n"));
                goto InitializationFinishError;
            }
        }

        //
        // Set the SAM_SERVICE_STARTED event.  Except when an error occurs,
        // don't close the event.  Closing it would delete the event and
        // a future waiter would never see it be set.
        //

        Status = NtSetEvent( EventHandle, NULL );

        if ( !NT_SUCCESS(Status)) {

            KdPrint(("SAMSS:  Failed to set SAM_SERVICE_STARTED event. %lX\n",
                Status ));
            KdPrint(("        Failing to initialize SAM Server.\n"));
            NtClose(EventHandle);
            goto InitializationFinishError;

        }

    } else {

        //
        // The initialization/installation of Lsa and/or SAM failed.  Handle errors returned
        // from the initialization/installation of LSA or SAM.  Issue a popup
        // and, if installing, set an event so that setup will continue and
        // clean up.
        //

        ULONG_PTR Parameters[1];

        //
        // don't reboot unless LSA was running as SYSTEM.
        // this prevents a user who runs lsass.exe from causing an instant reboot.
        //

        if(ImpersonateSelf( SecurityImpersonation ))
        {
            HANDLE hThreadToken;

            if(OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadToken))
            {
                BOOL DoShutdown = TRUE;
                BOOL fIsMember;
                PSID psidSystem = NULL;
                SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;


                if(AllocateAndInitializeSid(
                                &sia,
                                1,
                                SECURITY_LOCAL_SYSTEM_RID,
                                0,0,0,0,0,0,0,
                                &psidSystem
                                ))
                {
                    if(CheckTokenMembership(hThreadToken, psidSystem, &fIsMember))
                    {
                        DoShutdown = fIsMember;
                    }

                    if( psidSystem != NULL )
                    {
                        FreeSid( psidSystem );
                    }
                }

                CloseHandle( hThreadToken );
                RevertToSelf();

                if( !DoShutdown )
                {
                    goto InitializationFinishFinish;
                }
            } else {
                RevertToSelf();
            }
        }

        
        Parameters[0] = MB_OK | MB_ICONSTOP | MB_SETFOREGROUND;

        Status = NtRaiseHardError(
                     CompletionStatus | HARDERROR_OVERRIDE_ERRORMODE,
                     1,
                     0,
                     Parameters,
                     OptionOk,
                     &Response
                     );

        //
        // If setup.exe was run, signal the SETUP_FAILED event.  setup.exe
        // waits multiple on the SAM_SERVICE_STARTED and SETUP_FAILED events
        // so setup will resume and cleanup/continue as appropriate if
        // either of these events are set.
        //

        if (LsaISetupWasRun()) {

            //
            // Once the user has clicked OK in response to the popup, we come
            // back to here.  Set the event SETUP_FAILED.  The Setup
            // program (if running) waits multiple on the SAM_SERVICE_STARTED
            // and SETUP_FAILED events.
            //

            RtlInitUnicodeString( &EventName, L"\\SETUP_FAILED");
            InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

            //
            // Open the SETUP_FAILED event (exists if setup.exe is running).
            //

            Status = NtOpenEvent(
                           &EventHandle,
                           SYNCHRONIZE|EVENT_MODIFY_STATE,
                           &EventAttributes
                           );

            if ( !NT_SUCCESS(Status)) {

                //
                // Something is inconsistent.  We know that setup was run
                // so the event should exist.
                //

                KdPrint(("LSA Server:  Failed to open SETUP_FAILED event. %lX\n",
                    Status ));
                KdPrint(("        Failing to initialize Lsa Server.\n"));
                goto InitializationFinishError;
            }

            Status = NtSetEvent( EventHandle, NULL );

        } else if ( NT_SUCCESS( Status )) {

            //
            // This is not setup, so the only option is to shut down the system
            //

            BOOLEAN WasEnabled;

            //
            // issue shutdown request
            //
            RtlAdjustPrivilege(
                SE_SHUTDOWN_PRIVILEGE,
                TRUE,       // enable shutdown privilege.
                FALSE,
                &WasEnabled
                );

            //
            // Shutdown and Reboot now.
            // Note: use NtRaiseHardError to shutdown the machine will result Bug C
            //

            NtShutdownSystem( ShutdownReboot );

            //
            // if Shutdown request failed, (returned from above API)
            // reset shutdown privilege to previous value.
            //

            RtlAdjustPrivilege(
                SE_SHUTDOWN_PRIVILEGE,
                WasEnabled,   // reset to previous state.
                FALSE,
                &WasEnabled
                );
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto InitializationFinishError;
    }

InitializationFinishFinish:

    return;

InitializationFinishError:

    goto InitializationFinishFinish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dspolicy\dbdomain.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbdomain.c

Abstract:

    LSA Database - Trusted Domain Object Private API Workers

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.

Author:

    Scott Birrell       (ScottBi)      January 13, 1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include <dns.h>
#include <dnsapi.h>
#include <names.h>
#include <malloc.h>
#include "lsawmi.h"
#include <logonmsv.h>

LSAP_DB_TRUSTED_DOMAIN_LIST LsapDbTrustedDomainList;
BOOLEAN LsapDbReturnAuthData;

//
// Local function prototypes
//
VOID
LsapDbBuildTrustInfoExForTrustInfo(
    IN PLSAPR_UNICODE_STRING Domain,
    IN PLSAPR_SID Sid,
    IN OUT PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustInfoEx
    )
/*++

Routine Description:

    This takes the equivalent of a TRUST_INFORMATION structure and converts
    it to a TRUSTED_DOMAIN_INFORMATION_EX structure

Arguments:

    Domain -- Domain name

    Sid -- Domain sid

    TrustInfoEx -- Pointer to a structure to initialize

--*/
{
    RtlCopyMemory( &TrustInfoEx->Name,
                   Domain,
                   sizeof( UNICODE_STRING ) );
    RtlCopyMemory( &TrustInfoEx->FlatName,
                   Domain,
                   sizeof( UNICODE_STRING ) );
    TrustInfoEx->Sid = Sid;
    TrustInfoEx->TrustDirection = TRUST_DIRECTION_OUTBOUND;
    TrustInfoEx->TrustType = TRUST_TYPE_DOWNLEVEL;
    TrustInfoEx->TrustAttributes = 0;


}

NTSTATUS
LsapNotifyNetlogonOfTrustChange(
    IN  PSID pChangeSid,
    IN  SECURITY_DB_DELTA_TYPE ChangeType
    )
/*++

Routine Description:

    This function will notify netlogon when a trusted domain object comes or
    goes into or out of existence


Arguments:

    pChangeSid - The sid of the trusted domain object that changed

    IsDeletion - Indicates whether the trusted domain was added or removed

--*/
{
    NTSTATUS Status;

    Status = I_NetNotifyTrustedDomain (
                 NULL,
                 pChangeSid,
                 ( BOOLEAN )(ChangeType == SecurityDbDelete)
                 );

    if ( LsapKerberosTrustNotificationFunction ) {

        LsaIRegisterNotification( ( SEC_THREAD_START )LsapKerberosTrustNotificationFunction,
                                  ( PVOID ) ChangeType,
                                  NOTIFIER_TYPE_IMMEDIATE,
                                  0,
                                  NOTIFIER_FLAG_ONE_SHOT,
                                  0,
                                  0 );
    }

    return(Status);
}





NTSTATUS
LsarCreateTrustedDomain(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_TRUST_INFORMATION TrustedDomainInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaCreateTrustedDomain API.

    The LsaCreateTrustedDomain API creates a new TrustedDomain object.  The
    caller must have POLICY_TRUST_ADMIN access to the Policy Object.

    Note that NO verification is done to check that the given domain name
    matches the given SID or that the SID or name represent an actual domain.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainInformation - Pointer to structure containing the name and
        SID of the new Trusted Domain.

    DesiredAccess - Specifies the accesses to be granted for the newly
        created object.

    TrustedDomainHandle - receives a handle referencing the newly created
        object.  This handle is used on subsequent accesses to the object.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX ExInfo;

    LsarpReturnCheckSetup();

    LsapDbBuildTrustInfoExForTrustInfo( &TrustedDomainInformation->Name,
                                        TrustedDomainInformation->Sid,
                                        &ExInfo );

    Status = LsapCreateTrustedDomain2( PolicyHandle, &ExInfo, NULL,
                                       DesiredAccess,
                                       TrustedDomainHandle );

    LsarpReturnPrologue();

    return( Status );
}



NTSTATUS
LsapDbVerifyTrustLocation(
    IN OUT PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation
    )
/*++

Routine Description:

    Verifies that a trust described by TrustedDomainInformation is pointing
    either entirely within, or entirely outside this forest

    If appropriate, sets the TRUST_ATTRIBUTE_WITHIN_FOREST attribute

Arguments:

    TrustedDomainInformation        trust attributes to examine

Returns:

    STATUS_SUCCESS if happy
    STATUS_INVALID_PARAMETER if TrustedDomainInformation was inconsistent
    STATUS_INSUFFICIENT_RESOURCES not enough memory

--*/
{
    NTSTATUS Status;
    PSID MatchDnsName = NULL, MatchNetbiosName = NULL, MatchSid = NULL;
    BOOLEAN TrustInternal = FALSE, TrustExternal = FALSE;

    typedef enum {
        ExternalTrust,
        InternalTrust,
        UndeterminedTrust,
    } TRUST_LOCATION;

    TRUST_LOCATION SidLocation = UndeterminedTrust,
                   DnsLocation = UndeterminedTrust,
                   NbLocation = UndeterminedTrust;

    if ( TrustedDomainInformation->Sid ) {

        Status = LsapForestTrustFindMatch(
                     RoutingMatchDomainSid,
                     TrustedDomainInformation->Sid,
                     TRUE,
                     NULL,
                     &MatchSid
                     );

        if ( Status == STATUS_NO_MATCH ) {

            SidLocation = ExternalTrust;
            Status = STATUS_SUCCESS;

        } else if ( !NT_SUCCESS( Status )) {

            goto Cleanup;

        } else {

            SidLocation = InternalTrust;
        }
    }

    Status = LsapForestTrustFindMatch(
                 RoutingMatchDomainName,
                 &TrustedDomainInformation->Name,
                 TRUE,
                 NULL,
                 &MatchDnsName
                 );

    if ( Status == STATUS_NO_MATCH ) {

        DnsLocation = ExternalTrust;
        Status = STATUS_SUCCESS;

    } else if ( !NT_SUCCESS( Status )) {

        goto Cleanup;

    } else {

        DnsLocation = InternalTrust;
    }

    if ( TrustedDomainInformation->FlatName.Buffer != NULL ) {

        Status = LsapForestTrustFindMatch(
                     RoutingMatchDomainName,
                     &TrustedDomainInformation->FlatName,
                     TRUE,
                     NULL,
                     &MatchNetbiosName
                     );

        if ( Status == STATUS_NO_MATCH ) {

            NbLocation = ExternalTrust;
            Status = STATUS_SUCCESS;

        } else if ( !NT_SUCCESS( Status )) {

            goto Cleanup;

        } else {

            NbLocation = InternalTrust;
        }
    }

    if ( SidLocation == InternalTrust ||
         DnsLocation == InternalTrust ||
         NbLocation == InternalTrust ) {

        TrustInternal = TRUE;
    }

    if ( SidLocation == ExternalTrust ||
         DnsLocation == ExternalTrust ||
         NbLocation == ExternalTrust ) {

        TrustExternal = TRUE;
    }

    if ( TrustInternal && TrustExternal ) {

        //
        // Portions of the trust information point inside, portions - outside
        //

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( TrustInternal ) {

        TrustedDomainInformation->TrustAttributes |= TRUST_ATTRIBUTE_WITHIN_FOREST;
    }

    //
    // For things that matched internally, perform pairwise SID comparisons
    // so that one trust points to one location only
    //

    if ( MatchDnsName &&
         MatchSid &&
         !RtlEqualSid( MatchDnsName, MatchSid )) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( MatchDnsName &&
         MatchNetbiosName &&
         !RtlEqualSid( MatchDnsName, MatchNetbiosName )) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( MatchSid &&
         MatchNetbiosName &&
         !RtlEqualSid( MatchSid, MatchNetbiosName )) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

Cleanup:

    MIDL_user_free( MatchNetbiosName );
    MIDL_user_free( MatchDnsName );
    MIDL_user_free( MatchSid );

    return Status;
}


NTSTATUS
LsapCreateTrustedDomain2(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle
    )
/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaCreateTrustedDomain API.

    The LsaCreateTrustedDomain API creates a new TrustedDomain object.  The
    caller must have POLICY_TRUST_ADMIN access to the Policy Object.

    Note that NO verification is done to check that the given domain name
    matches the given SID or that the SID or name represent an actual domain.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainInformation - Pointer to structure containing the name and
        SID of the new Trusted Domain.

    DesiredAccess - Specifies the accesses to be granted for the newly
        created object.

    TrustedDomainHandle - receives a handle referencing the newly created
        object.  This handle is used on subsequent accesses to the object.

        The returned handle has a reference to the passed in PolicyHandle. So,
        when the TrustedDomainHandle is closed, either call LsapCloseHandle or at least
        call LsapDbDereferenceObject passing in LSAP_DB_DEREFERENCE_CONTR.

Returns:

    STATUS_SUCCESS - Success

    STATUS_DIRECTORY_SERVICE_REQUIRED - An attempt was made to create a trusted domain
        object on a non-DC

    STATUS_INVALID_SID - An invalid sid was specified

    STATUS_UNSUCCESSFUL - Unable to obtain the product type

    STATUS_CURRENT_DOMAIN_NOT_ALLOWED - Can not add the current domain to the trusted domain list

    STATUS_INVALID_DOMAIN_STATE - Forest transitive bit can not be specified on this DC

    STATUS_ACCESS_DENIED - Do not have enough rights to create a trusted domain

--*/
{
    NTSTATUS Status = STATUS_SUCCESS, SecondaryStatus = STATUS_SUCCESS;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_DOMAIN];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    UNICODE_STRING LogicalNameU;
    BOOLEAN AcquiredListWriteLock = FALSE;
    DNS_STATUS DnsStatus;
    BOOLEAN AllLocksLocked = FALSE;
    BOOLEAN ClientPolicyHandleReferenced = FALSE;
    PSID DomainSid;
    ULONG AttributeCount = 0;
    LSAP_DB_HANDLE InternalTrustedDomainHandle = NULL;
    PVOID TrustedDomainNameAttributeValue = NULL;
    ULONG TrustedDomainPosixOffset;
    BOOLEAN TrustCreated = FALSE;
    PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF AuthHalf;
    LSAPR_TRUST_INFORMATION InputTrustInformation;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;
    ULONG   CriticalValue = 0;
    PPOLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo = NULL;

    LsarpReturnCheckSetup();
    LsapEnterFunc( "LsapCreateTrustedDomain2" );

    LogicalNameU.Length = 0;

    RtlZeroMemory(Attributes, sizeof(Attributes));

    if (LsapProductSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED)
    {
        Status = STATUS_NOT_SUPPORTED_ON_SBS;
        goto CreateTrustedDomainError;
    }

    if (!ARGUMENT_PRESENT( TrustedDomainInformation )) {

        Status = STATUS_INVALID_PARAMETER;
        goto CreateTrustedDomainError;
    }

    //
    // Creating a trust with the forest transitive bit set is not legal
    // outside of the root domain of the forest
    //

    if ( !LsapDbDcInRootDomain() &&
         ( TrustedDomainInformation->TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE )) {

        Status = STATUS_INVALID_DOMAIN_STATE;
        goto CreateTrustedDomainError;
    }

    //
    // Creating a trust with the forest transitive bit set is not legal
    // until all domains are upgraded to Whistler
    //

    if ( FLAG_ON( TrustedDomainInformation->TrustAttributes,
                  TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
         !LsapDbNoMoreWin2KForest()) {

        Status = STATUS_INVALID_DOMAIN_STATE;
        goto CreateTrustedDomainError;
    }

    //
    // Creating a trust with the cross-federation bit set is not legal
    // until this domain is upgraded to Whistler
    //

    if ( FLAG_ON( TrustedDomainInformation->TrustAttributes,
                  TRUST_ATTRIBUTE_CROSS_ORGANIZATION ) &&
         !LsapDbNoMoreWin2KDomain()) {

        Status = STATUS_INVALID_DOMAIN_STATE;
        goto CreateTrustedDomainError;
    }

    //
    // If this is not a Dc, then return an error.  Creating trust on a client is
    // not supported
    //

    //
    // We allow this API to be called before we're completely initialized
    // for installation reasons.  However, it is the responsibility of the
    // installation program to not call it before the Product Type is
    // obtainable from the Registry.
    //

    if (!LsapDbIsServerInitialized()) {

        if ( !RtlGetNtProductType(&LsapProductType) ) {

            Status = STATUS_UNSUCCESSFUL;
            goto CreateTrustedDomainError;
        }
    }

    if ( !LsaDsStateInfo.UseDs ) {

        Status = STATUS_DIRECTORY_SERVICE_REQUIRED;
        goto CreateTrustedDomainError;
    }

    //
    // Validate the input argument formats
    //

    if ( !LsapValidateLsaUnicodeString( &TrustedDomainInformation->Name ) ||
         !LsapValidateLsaUnicodeString( &TrustedDomainInformation->FlatName ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto CreateTrustedDomainError;
    }

    //
    // Fix the name to ensure that it doesn't have a trailing period
    //

    if ( TrustedDomainInformation->TrustType == TRUST_TYPE_UPLEVEL ) {

        if ( TrustedDomainInformation->Name.Length == 0 ||
             TrustedDomainInformation->Name.Buffer == NULL ) {

            Status = STATUS_INVALID_PARAMETER;
            goto CreateTrustedDomainError;
        }

        if ( TrustedDomainInformation->Name.Buffer[
                    (TrustedDomainInformation->Name.Length - 1) / sizeof(WCHAR)] == L'.' ) {

            TrustedDomainInformation->Name.Buffer[
                    (TrustedDomainInformation->Name.Length - 1) / sizeof(WCHAR)] = UNICODE_NULL;
            TrustedDomainInformation->Name.Length -= sizeof(WCHAR);
        }
    }

    //
    // Check to make sure the NetBIOS name is actually valid
    //

    if ( TrustedDomainInformation->TrustType == TRUST_TYPE_DOWNLEVEL ||
         TrustedDomainInformation->TrustType == TRUST_TYPE_UPLEVEL ) {

        BOOLEAN Valid;

        Status = LsapValidateNetbiosName(
                     ( UNICODE_STRING * )&TrustedDomainInformation->FlatName,
                     &Valid
                     );

        if ( NT_SUCCESS( Status ) && !Valid ) {

            Status = STATUS_OBJECT_NAME_INVALID;
        }

        if ( !NT_SUCCESS( Status )) {

            goto CreateTrustedDomainError;
        }
    }

    //
    // Now, do the same for the DNS name
    //

    if ( TrustedDomainInformation->TrustType == TRUST_TYPE_UPLEVEL ) {

        BOOLEAN Valid;

        Status = LsapValidateDnsName(
                     ( UNICODE_STRING * )&TrustedDomainInformation->Name,
                     &Valid
                     );

        if ( NT_SUCCESS( Status ) && !Valid ) {

            Status = STATUS_OBJECT_NAME_INVALID;
        }

        if ( !NT_SUCCESS( Status )) {

            goto CreateTrustedDomainError;
        }
    }

    //
    // Validate the Trusted Domain Sid.
    //

    DomainSid = TrustedDomainInformation->Sid;

    if ( DomainSid ) {

        //
        // SIDs passed in should be valid domain SIDs
        //

        Status = LsapIsValidDomainSid( DomainSid );

        if ( !NT_SUCCESS( Status )) {

            goto CreateTrustedDomainError;
        }
    }

    if ( !((LSAP_DB_HANDLE)PolicyHandle)->Trusted && DomainSid == NULL &&
         ( TrustedDomainInformation->TrustType == TRUST_TYPE_DOWNLEVEL ||
           TrustedDomainInformation->TrustType == TRUST_TYPE_UPLEVEL ) ) {

        Status = STATUS_INVALID_SID;
        goto CreateTrustedDomainError;
    }

    //
    // Guard against adding self to the trusted domain list
    //

    Status = LsapDbQueryInformationPolicy(
                 LsapPolicyHandle,
                 PolicyDnsDomainInformation,
                 ( PLSAPR_POLICY_INFORMATION *)&PolicyDnsDomainInfo );

    if ( !NT_SUCCESS( Status ) ) {

        goto CreateTrustedDomainError;
    }

    //
    // Catch attempts to create a TDO with the same SID as the SID of this domain
    //

    if ( DomainSid != NULL && PolicyDnsDomainInfo->Sid != NULL &&
         RtlEqualSid( DomainSid, PolicyDnsDomainInfo->Sid ) ) {

        Status = STATUS_CURRENT_DOMAIN_NOT_ALLOWED;
        goto CreateTrustedDomainError;
    }

    //
    // Catch attempts to create a TDO with the same name as this domain
    //

    if ( TrustedDomainInformation->Name.Buffer != NULL ) {

        if ( PolicyDnsDomainInfo->Name.Buffer != NULL &&
             RtlEqualUnicodeString(
                 ( PUNICODE_STRING )&TrustedDomainInformation->Name,
                 ( PUNICODE_STRING )&PolicyDnsDomainInfo->Name, TRUE ) ) {

            Status = STATUS_CURRENT_DOMAIN_NOT_ALLOWED;
            goto CreateTrustedDomainError;

        } else if ( PolicyDnsDomainInfo->DnsDomainName.Buffer != NULL &&
                    RtlEqualUnicodeString(
                        ( PUNICODE_STRING )&TrustedDomainInformation->Name,
                        ( PUNICODE_STRING )&PolicyDnsDomainInfo->DnsDomainName, TRUE ) ) {

            Status = STATUS_CURRENT_DOMAIN_NOT_ALLOWED;
            goto CreateTrustedDomainError;
        }
    }

    if ( TrustedDomainInformation->FlatName.Buffer != NULL ) {

        if ( PolicyDnsDomainInfo->Name.Buffer != NULL &&
             RtlEqualUnicodeString(
                 ( PUNICODE_STRING )&TrustedDomainInformation->FlatName,
                 ( PUNICODE_STRING )&PolicyDnsDomainInfo->Name, TRUE ) ) {

            Status = STATUS_CURRENT_DOMAIN_NOT_ALLOWED;
            goto CreateTrustedDomainError;

        } else if ( PolicyDnsDomainInfo->DnsDomainName.Buffer != NULL &&
                    RtlEqualUnicodeString(
                        ( PUNICODE_STRING )&TrustedDomainInformation->FlatName,
                        ( PUNICODE_STRING )&PolicyDnsDomainInfo->DnsDomainName, TRUE ) ) {

            Status = STATUS_CURRENT_DOMAIN_NOT_ALLOWED;
            goto CreateTrustedDomainError;
        }
    }

    //
    // Almost done with the checks - see if this domain is within our forest
    // and if so, set the TRUST_ATTRIBUTE_WITHIN_FOREST bit
    //

    Status = LsapDbVerifyTrustLocation( TrustedDomainInformation );

    if ( !NT_SUCCESS( Status )) {

        goto CreateTrustedDomainError;
    }

    //
    // A trust can not be both "within forest" and either external or cross-org
    //

    if ( FLAG_ON( TrustedDomainInformation->TrustAttributes,
                  TRUST_ATTRIBUTE_WITHIN_FOREST ) &&
         ( FLAG_ON( TrustedDomainInformation->TrustAttributes,
                    TRUST_ATTRIBUTE_CROSS_ORGANIZATION ) ||
           FLAG_ON( TrustedDomainInformation->TrustAttributes,
                    TRUST_ATTRIBUTE_FOREST_TRANSITIVE ))) {

        Status = STATUS_INVALID_PARAMETER;
        goto CreateTrustedDomainError;
    }

    //
    // Grab all of the locks.
    //
    // There are code paths where we lock Policy, secret, trusted domain and
    // registry locks, there is no convenient order.  So grab them all.
    //

    LsapDbAcquireLockEx( AllObject, 0 );

    AllLocksLocked = TRUE;

    //
    // Verify that the PolicyHandle is valid.
    // Reference the Policy Object handle (as container object).
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 0,
                 PolicyObject,
                 TrustedDomainObject,
                 LSAP_DB_LOCK );

    if (!NT_SUCCESS(Status)) {

        goto CreateTrustedDomainError;
    }

    ClientPolicyHandleReferenced = TRUE;

    //
    // Validate whether the name/flat name is not already in use
    //

    Status = LsapDbAcquireReadLockTrustedDomainList();

    if (!NT_SUCCESS(Status)) {
        goto CreateTrustedDomainError;
    }

    RtlCopyMemory(&InputTrustInformation.Name,&TrustedDomainInformation->Name,sizeof(UNICODE_STRING));
    InputTrustInformation.Sid = NULL;

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry
                 );

    if (STATUS_SUCCESS==Status)
    {
        LsapDbReleaseLockTrustedDomainList();
        Status = STATUS_OBJECT_NAME_COLLISION;
        goto CreateTrustedDomainError;
    }

    RtlCopyMemory(&InputTrustInformation.Name,&TrustedDomainInformation->FlatName,sizeof(UNICODE_STRING));
    InputTrustInformation.Sid = NULL;

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry
                 );
    LsapDbReleaseLockTrustedDomainList();

    if (STATUS_SUCCESS==Status)
    {
        Status = STATUS_OBJECT_NAME_COLLISION;
        goto CreateTrustedDomainError;
    }

    //
    // Construct the Trusted Domain Name attribute info.
    //

    NextAttribute = Attributes;

    Status = LsapDbMakeUnicodeAttributeDs(
                     (PUNICODE_STRING) &TrustedDomainInformation->Name,
                     TrDmName,
                     NextAttribute );

    if (!NT_SUCCESS(Status)) {

        goto CreateTrustedDomainError;
    }


    NextAttribute++;
    AttributeCount++;

    //
    // Construct the Trusted Domain Sid attribute info
    //

    if ( DomainSid ) {

        Status = LsapDbMakeSidAttributeDs(
                     DomainSid,
                     Sid,
                     NextAttribute
                     );
        if (!NT_SUCCESS(Status)) {

            goto CreateTrustedDomainError;
        }

        NextAttribute++;
        AttributeCount++;
    }

    //
    // Set critical system object for the trusted domain
    //

    CriticalValue = 1;
    LsapDbInitializeAttributeDs( NextAttribute,
                                 PseudoSystemCritical,
                                 &CriticalValue,
                                 sizeof( ULONG ),
                                 FALSE );
    NextAttribute++;
    AttributeCount++;

    //
    // Set the Posix Offset for this Trusted Domain.
    //
    // The rules are as follows:
    //
    // For a PDC, set the Posix Offset to the value.
    //
    // For a BDC, set the Posix Offset to the null Posix offset.  It will be
    // set on the PDC when the TDO is replicated there.
    //

    TrustedDomainPosixOffset = SE_NULL_POSIX_OFFSET;

    if ( LsapNeedPosixOffset( TrustedDomainInformation->TrustDirection,
                              TrustedDomainInformation->TrustType ) ) {
        DOMAIN_SERVER_ROLE ServerRole = DomainServerRolePrimary;

        //
        // Query the server role, PDC/BDC
        //

        Status = SamIQueryServerRole(
                    LsapAccountDomainHandle,
                    &ServerRole
                    );

        if (!NT_SUCCESS(Status)) {
            goto CreateTrustedDomainError;
        }

        if ( ServerRole == DomainServerRolePrimary ) {

            //
            // Need to grab the TDL write lock while allocating a Posix Offset
            //

            Status = LsapDbAcquireWriteLockTrustedDomainList();

            if ( !NT_SUCCESS(Status)) {
                goto CreateTrustedDomainError;
            }

            AcquiredListWriteLock = TRUE;

            //
            // Allocate the next available Posix Offset.
            //

            Status = LsapDbAllocatePosixOffsetTrustedDomainList(
                         &TrustedDomainPosixOffset );

            if ( !NT_SUCCESS(Status)) {
                goto CreateTrustedDomainError;
            }
        }
    }

    //
    // Add a transaction to write the Posix Offset to the Trusted Domain
    // object when it is created.
    //

    LsapDbInitializeAttributeDs(
        NextAttribute,
        TrDmPxOf,
        &TrustedDomainPosixOffset,
        sizeof(TrustedDomainPosixOffset),
        FALSE
        );

    NextAttribute++;
    AttributeCount++;

    //
    // Construct the Logical Name (Internal LSA Database Name) of the
    // Trusted Domain object.
    //

    if ( LsapDsWriteDs ) {

        //
        // Create the object name as the domain name.  There will be another mechanism in
        // place to ensure that the object name is kept in synch with the Dns domain Name
        //
        RtlCopyMemory( &LogicalNameU,
                       (PUNICODE_STRING) &TrustedDomainInformation->Name,
                       sizeof( UNICODE_STRING ) );

    } else {

        // The Logical Name is constructed from the Domain Sid by converting it into
        // a Unicode Sstring
        Status = LsapDbSidToLogicalNameObject( DomainSid, &LogicalNameU );
    }

    if (!NT_SUCCESS(Status)) {

        goto CreateTrustedDomainError;
    }

    //
    // Fill in the ObjectInformation structure.  Initialize the
    // embedded Object Attributes with the PolicyHandle as the
    // Root Directory (Container Object) handle and the Logical Name (Rid)
    // of the Trusted Domain. Store the types of the object and its container.
    //

    InitializeObjectAttributes(
        &ObjectInformation.ObjectAttributes,
        &LogicalNameU,
        OBJ_CASE_INSENSITIVE,
        PolicyHandle,
        NULL
        );

    ObjectInformation.ObjectTypeId = TrustedDomainObject;
    ObjectInformation.ContainerTypeId = PolicyObject;
    ObjectInformation.Sid = DomainSid;
    ObjectInformation.ObjectAttributeNameOnly = FALSE;
    ObjectInformation.DesiredObjectAccess = DesiredAccess;

    if ( LsapDsWriteDs ) {

        ULONG TrustAttributesValue;
        PBYTE AuthBuffer;
        ULONG AuthSize;

        //
        // Set the Netbios domain name
        //

        Status = LsapDbMakeUnicodeAttributeDs(
                     (PUNICODE_STRING) &TrustedDomainInformation->FlatName,
                     TrDmTrPN,
                     NextAttribute
                     );
        if ( !NT_SUCCESS( Status ) ) {

            goto CreateTrustedDomainError;
        }

        NextAttribute++;
        AttributeCount++;

        //
        // Set the trust type and direction
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrTy,
            &TrustedDomainInformation->TrustType,
            sizeof( TrustedDomainInformation->TrustType ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrDi,
            &TrustedDomainInformation->TrustDirection,
            sizeof( TrustedDomainInformation->TrustDirection ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // When setting trust attributes, mask off all but the supported bits
        //

        TrustAttributesValue =
            TrustedDomainInformation->TrustAttributes & TRUST_ATTRIBUTES_VALID;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrLA,
            &TrustAttributesValue,
            sizeof( TrustAttributesValue ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Authentication data
        //
        AuthHalf = LsapDsAuthHalfFromAuthInfo( AuthenticationInformation, TRUE );

        Status = LsapDsBuildAuthInfoAttribute( PolicyHandle,
                                               AuthHalf,
                                               NULL,
                                               &AuthBuffer,
                                               &AuthSize );

        if ( NT_SUCCESS( Status ) ) {

            if ( AuthBuffer != NULL ) {

                LsapDbInitializeAttributeDs(
                    NextAttribute,
                    TrDmSAI,
                    AuthBuffer,
                    AuthSize,
                    TRUE );

                NextAttribute++;
                AttributeCount++;
            }
        }

        if ( NT_SUCCESS( Status ) ) {

            AuthHalf = LsapDsAuthHalfFromAuthInfo( AuthenticationInformation, FALSE );

            Status = LsapDsBuildAuthInfoAttribute( PolicyHandle,
                                                   AuthHalf,
                                                   NULL,
                                                   &AuthBuffer,
                                                   &AuthSize );

            if ( NT_SUCCESS( Status ) ) {

                if ( AuthBuffer ) {

                    LsapDbInitializeAttributeDs(
                        NextAttribute,
                        TrDmSAO,
                        AuthBuffer,
                        AuthSize,
                        TRUE );

                    NextAttribute++;
                    AttributeCount++;
                }
            }
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto CreateTrustedDomainError;
    }

    ASSERT( AttributeCount <= LSAP_DB_ATTRS_INFO_CLASS_DOMAIN );

    //
    // Save a copy of the trust direction for the fixup routines
    //
    //  The DS does two fixup notifications.  One for the DirAddEntry and
    //  one for the DirModifyEntry.  If the second one didn't exist (or was otherwise
    //  distinguishable from a LsarSetInformationTrustedDomain), then we wouldn't
    //  need to save the OldTrustDirection here.
    //

    {
        PLSADS_PER_THREAD_INFO CurrentThreadInfo;

        CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

        ASSERT( CurrentThreadInfo != NULL );

        if ( CurrentThreadInfo != NULL ) {
            CurrentThreadInfo->OldTrustDirection = TrustedDomainInformation->TrustDirection;
            CurrentThreadInfo->OldTrustType = TrustedDomainInformation->TrustType;
        }
    }

    //
    // Create the Trusted Domain Object.  We fail if the object already exists.
    // Note that the object create routine performs a Database transaction.
    //

    Status = LsapDbCreateObject(
                 &ObjectInformation,
                 DesiredAccess,
                 LSAP_DB_OBJECT_CREATE,
                 0,
                 Attributes,
                 &AttributeCount,
                 RTL_NUMBER_OF(Attributes),
                 TrustedDomainHandle
                 );

    InternalTrustedDomainHandle = (LSAP_DB_HANDLE) *TrustedDomainHandle;

    //
    // This approach must be changed later. Goto LsapDbOpenObject and search for
    // Bug #340164 for the cause.
    //
    // LsapDbCreateObject returns STATUS_OBJECT_NAME_NOT_FOUND for secrets
    // in case of anonymous access not to reveal secrets. We should correct the error
    //

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND &&
        LsapGlobalRestrictAnonymous &&
       ((( LSAP_DB_HANDLE )PolicyHandle)->Options & LSAP_DB_OPENED_BY_ANONYMOUS )){

        Status = STATUS_ACCESS_DENIED;
    }

    //
    // If object creation failed, dereference the container object.
    //
    if (!NT_SUCCESS(Status)) {

        goto CreateTrustedDomainError;
    }

    TrustCreated = TRUE;

    //
    // Create the interdomain trust account, if required
    //

    if ( NT_SUCCESS( Status ) &&
         FLAG_ON( TrustedDomainInformation->TrustDirection, TRUST_DIRECTION_INBOUND ) &&
         ((TrustedDomainInformation->TrustType == TRUST_TYPE_UPLEVEL) ||
          (TrustedDomainInformation->TrustType == TRUST_TYPE_DOWNLEVEL)) &&
         !FLAG_ON( ( ( LSAP_DB_HANDLE )PolicyHandle )->Options, LSAP_DB_HANDLE_UPGRADE ) ) {

         Status = LsapDsCreateInterdomainTrustAccount( *TrustedDomainHandle );

         if ( !NT_SUCCESS( Status ) ) {

             goto CreateTrustedDomainError;
         }
    }

    //
    // Add the Trusted Domain to the Trusted Domain List, unless we're doing an upgrade
    //

    if ( !FLAG_ON( ( ( LSAP_DB_HANDLE )PolicyHandle )->Options, LSAP_DB_HANDLE_UPGRADE  ) ) {

        LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustedDomainInformation2;

        RtlCopyMemory(
            &TrustedDomainInformation2,
            TrustedDomainInformation,
            sizeof( LSAPR_TRUSTED_DOMAIN_INFORMATION_EX )
            );

        //
        // New domains are always created without forest trust information
        //

        TrustedDomainInformation2.ForestTrustLength = 0;
        TrustedDomainInformation2.ForestTrustInfo = NULL;

        Status = LsapDbAcquireWriteLockTrustedDomainList();

        if ( NT_SUCCESS( Status )) {

            Status = LsapDbInsertTrustedDomainList(
                         &TrustedDomainInformation2,
                         TrustedDomainPosixOffset
                         );

            LsapDbReleaseLockTrustedDomainList();
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto CreateTrustedDomainError;
    }

    if (LsapAdtAuditingEnabledHint(
            AuditCategoryPolicyChange,
            EVENTLOG_AUDIT_SUCCESS
            )) {

        (void) LsapAdtTrustedDomainAdd(
                   EVENTLOG_AUDIT_SUCCESS,
                   (PUNICODE_STRING) &TrustedDomainInformation->Name,
                   TrustedDomainInformation->Sid,
                   TrustedDomainInformation->TrustType,
                   TrustedDomainInformation->TrustDirection,
                   TrustedDomainInformation->TrustAttributes
                   );
    }

    //
    // If necessary, release the LSA Database lock.  Note that we don't
    // call LsapDbDereferenceObject() because we want to leave the
    // reference count incremented by default in this success case.
    // In the error case, we call LsapDbDereferenceObject().
    //

    if (ClientPolicyHandleReferenced) {

        LsapDbApplyTransaction( PolicyHandle,
                                LSAP_DB_READ_ONLY_TRANSACTION,
                                (SECURITY_DB_DELTA_TYPE) 0 );

        LsapDbReleaseLockEx( TrustedDomainObject,
                             0 );

        ClientPolicyHandleReferenced = FALSE;
    }

CreateTrustedDomainFinish:

    //
    // If necessary, free the Policy DNS Domain Information
    //

    if (PolicyDnsDomainInfo != NULL) {

        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            (PLSAPR_POLICY_INFORMATION) PolicyDnsDomainInfo
            );

        PolicyDnsDomainInfo = NULL;
    }

    //
    // If we locked all of the locks,
    //  drop them now.
    //

    if ( AllLocksLocked ) {

        LsapDbReleaseLockEx( AllObject, 0 );
    }

    //
    // Free any Attribute Value buffers allocated.
    //
    SecondaryStatus = LsapDbFreeAttributes( AttributeCount, Attributes );
    if (!NT_SUCCESS(SecondaryStatus)) {

        goto CreateTrustedDomainError;
    }

    //
    // If necessary, free the Unicode String buffer allocated for the
    // Logical Name.
    //

    if ( !LsapDsWriteDs && LogicalNameU.Length > 0 ) {

        RtlFreeUnicodeString(&LogicalNameU);
        LogicalNameU.Length = 0;
    }

    //
    // If necessary, release the Trusted Domain List Write Lock.
    //

    if (AcquiredListWriteLock) {

        LsapDbReleaseLockTrustedDomainList();
        AcquiredListWriteLock = FALSE;
    }

    LsapExitFunc( "LsapCreateTrustedDomain2", Status );
    LsarpReturnPrologue();

    return(Status);

CreateTrustedDomainError:

    //
    // If necessary, dereference the client Policy Handle and release the
    // LSA Database lock.
    //

    LsapDbSetStatusFromSecondary( Status, SecondaryStatus );

    if (ClientPolicyHandleReferenced) {

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     TrustedDomainObject,
                     LSAP_DB_LOCK,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );

        ClientPolicyHandleReferenced = FALSE;
    }

    //
    // If necessary, delete the trusted domain object
    //
    if ( TrustCreated ) {

        //
        // We don't want to dereference the container handle. Because we already did!
        //  Just delete it and replace it back.
        //
        LSAP_DB_HANDLE Container = InternalTrustedDomainHandle->ContainerHandle;

        InternalTrustedDomainHandle->ContainerHandle = NULL;

        LsarDeleteObject( TrustedDomainHandle );

        InternalTrustedDomainHandle->ContainerHandle = Container;
    }

    goto CreateTrustedDomainFinish;
}


NTSTATUS
LsarOpenTrustedDomain(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID TrustedDomainSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle
    )

/*++

Routine Description:

    The LsaOpenTrustedDomain API opens an existing TrustedDomain object
    using the SID as the primary key value.

Arguments:

    PolicyHandle - An open handle to a Policy object.

    TrustedDomainSid - Pointer to the trust's Sid.

    DesiredAccess - This is an access mask indicating accesses being
        requested to the target object.

    TrustedDomainHandle - Receives a handle to be used in future requests.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_TRUSTED_DOMAIN_NOT_FOUND - There is no TrustedDomain object in the
            target system's LSA Database having the specified AccountSid.

--*/

{
    NTSTATUS Status;

    LsarpReturnCheckSetup();

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_OpenTrustedDomain);

    //
    // Call the internal routine.  Caller is not trusted and the Database
    // lock needs to be acquired.
    //

    Status = LsapDbOpenTrustedDomain(
                 PolicyHandle,
                 (PSID) TrustedDomainSid,
                 DesiredAccess,
                 TrustedDomainHandle,
                 LSAP_DB_LOCK |
                    LSAP_DB_READ_ONLY_TRANSACTION   |
                    LSAP_DB_DS_OP_TRANSACTION
                 );

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_OpenTrustedDomain);
    LsarpReturnPrologue();

    return(Status);
}


NTSTATUS
LsapDbOpenTrustedDomain(
    IN LSAPR_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle,
    IN ULONG Options
    )

/*++

Routine Description:

    This function opens a Trusted Domain Object, optionally with
    trusted access.

Arguments:

    PolicyHandle - An open handle to a Policy object.

    TrustedDomainSid - Pointer to the account's Sid.

    DesiredAccess - This is an access mask indicating accesses being
        requested to the target object.

    TrustedDomainHandle - Receives a handle to be used in future requests.

    Options - Specifies option flags

        LSAP_DB_LOCK - Acquire the Lsa Database lock for the
           duration of the open operation.

        LSAP_DB_TRUSTED - Always generate a Trusted Handle to the opened
            object.  If not specified, the trust status of the returned
            handle is inherited from the PolicyHandle as container object.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_TRUSTED_DOMAIN_NOT_FOUND - There is no TrustedDomain object in the
            target system's LSA Database having the specified AccountSid.

--*/

{
    NTSTATUS Status, SecondaryStatus;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    UNICODE_STRING LogicalNameU;
    BOOLEAN ContainerReferenced = FALSE;
    BOOLEAN AcquiredLock = FALSE;
    ULONG DerefOptions = 0;

    RtlZeroMemory(&LogicalNameU,sizeof(UNICODE_STRING));

    //
    // Validate that the Ds is up and running.  If it isn't, there aren't any trusted domains
    //
    if ( !LsaDsStateInfo.UseDs &&
         !FLAG_ON( ( ( LSAP_DB_HANDLE )PolicyHandle )->Options, LSAP_DB_HANDLE_UPGRADE ) ) {

        Status = STATUS_DIRECTORY_SERVICE_REQUIRED;
        goto OpenTrustedDomainError;
    }

    //
    // Validate the Trusted Domain Sid.
    //


    if (!RtlValidSid( TrustedDomainSid )) {
        Status = STATUS_INVALID_PARAMETER;
        goto OpenTrustedDomainError;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the connection handle
    // (container object handle) is valid, and is of the expected type.
    // Reference the container object handle.  This reference remains in
    // effect until the child object handle is closed.
    //
    DerefOptions |= Options;

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 0,
                 PolicyObject,
                 TrustedDomainObject,
                 Options
                 );

    if (!NT_SUCCESS(Status)) {

        goto OpenTrustedDomainError;
    }

    ContainerReferenced =TRUE;

    if (Options & LSAP_DB_LOCK) {

        DerefOptions |= LSAP_DB_LOCK;
        AcquiredLock = TRUE;
    }

    //
    // Setup Object Information prior to calling the Object
    // Open routine.  The Object Type, Container Object Type and
    // Logical Name (derived from the Sid) need to be filled in.
    //

    ObjectInformation.ObjectTypeId = TrustedDomainObject;
    ObjectInformation.ContainerTypeId = PolicyObject;
    ObjectInformation.Sid = TrustedDomainSid;
    ObjectInformation.ObjectAttributeNameOnly = FALSE;
    ObjectInformation.DesiredObjectAccess = DesiredAccess;

    //
    // Construct the Logical Name of the Trusted Domain object.  The Logical
    // Name is constructed from the Trusted Domain Sid by extracting the
    // Relative Id (lowest subauthority) and converting it to an 8-digit
    // numeric Unicode String in which leading zeros are added if needed.
    //

    if ( LsapDsWriteDs ) {

        LSAPR_TRUST_INFORMATION InputTrustInformation;
        PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;


        //
        // Lookup the cache to find the domain
        //
        Status = LsapDbAcquireReadLockTrustedDomainList();

        if (!NT_SUCCESS(Status)) {
            goto OpenTrustedDomainError;
        }

        RtlZeroMemory(&InputTrustInformation.Name,sizeof(UNICODE_STRING));
        InputTrustInformation.Sid = TrustedDomainSid;

        Status = LsapDbLookupEntryTrustedDomainList(
                    &InputTrustInformation,
                    &TrustEntry
                    );

        if (!NT_SUCCESS(Status))
        {
            LsapDbReleaseLockTrustedDomainList();
            goto OpenTrustedDomainError;
        }

        LogicalNameU.Buffer = LsapAllocateLsaHeap(TrustEntry->TrustInfoEx.Name.MaximumLength);
        if (NULL==LogicalNameU.Buffer)
        {
            LsapDbReleaseLockTrustedDomainList();
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto OpenTrustedDomainError;
        }

        LogicalNameU.Length = TrustEntry->TrustInfoEx.Name.Length;
        LogicalNameU.MaximumLength = TrustEntry->TrustInfoEx.Name.MaximumLength;
        RtlCopyMemory(LogicalNameU.Buffer,TrustEntry->TrustInfoEx.Name.Buffer,LogicalNameU.Length);
        LsapDbReleaseLockTrustedDomainList();

    } else {

        Status = LsapDbSidToLogicalNameObject( TrustedDomainSid, &LogicalNameU );

    }

    if (!NT_SUCCESS(Status)) {

        goto OpenTrustedDomainError;
    }

    //
    // Initialize the Object Attributes.  The Container Object Handle and
    // Logical Name (Internal Name) of the object must be set up.
    //

    InitializeObjectAttributes(
        &ObjectInformation.ObjectAttributes,
        &LogicalNameU,
        0,
        PolicyHandle,
        NULL
        );

    //
    // Open the specific Trusted Domain object.  Note that the
    // handle returned is an RPC Context Handle.
    //

    Status = LsapDbOpenObject(
                 &ObjectInformation,
                 DesiredAccess,
                 Options,
                 TrustedDomainHandle
                 );

    RtlFreeUnicodeString( &LogicalNameU );

    if (!NT_SUCCESS(Status)) {

        goto OpenTrustedDomainError;
    }

OpenTrustedDomainFinish:

    //
    // If necessary, release the LSA Database lock. Note that object
    // remains referenced unless we came here via error.
    //

    if (AcquiredLock) {

        LsapDbApplyTransaction( PolicyHandle,
                                LSAP_DB_DS_OP_TRANSACTION |
                                    LSAP_DB_READ_ONLY_TRANSACTION,
                                (SECURITY_DB_DELTA_TYPE) 0 );

        LsapDbReleaseLockEx( TrustedDomainObject,
                             DerefOptions );
    }

    return( Status );

OpenTrustedDomainError:

    //
    // If necessary, dereference the Container Object handle.  Note that
    // this is only done in the error case.  In the non-error case, the
    // Container handle stays referenced until the TrustedDomain object is
    // closed.
    //

    if ( ContainerReferenced ) {

        *TrustedDomainHandle = NULL;

        SecondaryStatus = LsapDbDereferenceObject(
                              &PolicyHandle,
                              PolicyObject,
                              TrustedDomainObject,
                              DerefOptions,
                              (SECURITY_DB_DELTA_TYPE) 0,
                              Status
                              );

        if ( FLAG_ON( Options, LSAP_DB_LOCK ) ) {

            DerefOptions &= ~LSAP_DB_LOCK;
            DerefOptions |= LSAP_DB_NO_LOCK;
        }

        LsapDbSetStatusFromSecondary( Status, SecondaryStatus );
    }

    goto OpenTrustedDomainFinish;
}


NTSTATUS
LsarQueryInfoTrustedDomain(
    IN LSAPR_HANDLE TrustedDomainHandle,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_TRUSTED_DOMAIN_INFO *Buffer
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaQueryInfoTrustedDomain API.

    The LsaQueryInfoTrustedDomain API obtains information from a
    TrustedDomain object.  The caller must have access appropriate to the
    information being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        TrustedDomainNameInformation      TRUSTED_QUERY_ACCOUNT_NAME
        TrustedControllersInformation     TRUSTED_QUERY_CONTROLLERS
        TrustedPosixInformation           TRUSTED_QUERY_POSIX

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status, ReadAttributesStatus;

    PTRUSTED_DOMAIN_NAME_INFO TrustedDomainNameInfo;
    PTRUSTED_POSIX_OFFSET_INFO TrustedPosixOffsetInfo;
    PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInfoEx;
    PTRUSTED_DOMAIN_AUTH_INFORMATION TrustedDomainAuthInfo;
    PTRUSTED_DOMAIN_FULL_INFORMATION TrustedDomainFullInfo;
    PTRUSTED_DOMAIN_FULL_INFORMATION2 TrustedDomainFullInfo2;
    LSAPR_TRUST_DOMAIN_AUTH_INFO_HALF AuthInfoHalf;

    BOOLEAN ObjectReferenced = FALSE;

    ACCESS_MASK DesiredAccess;
    ULONG AttributeCount = 0;
    ULONG AttributeNumber = 0;
    PVOID InformationBuffer = NULL;
    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_INFO_CLASS_DOMAIN];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    BOOLEAN InfoBufferInAttributeArray = TRUE;
    ULONG TrustedPosixOffset = 0, TrustDirection = 0, TrustType = 0, TrustAttributes = 0;


    LsarpReturnCheckSetup();
    LsapEnterFunc( "LsarQueryInfoTrustedDomain\n" );
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_QueryInfoTrustedDomain);

    //
    // Validate the Information Class and determine the access required to
    // query this Trusted Domain Information Class.
    //

    Status = LsapDbVerifyInfoQueryTrustedDomain(
                 InformationClass,
                 FALSE,
                 &DesiredAccess
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryInfoTrustedDomainError;
    }

    //
    // We don't currently allow querying of the auth data, so there's no need
    //  to support returning encrypted auth data.
    //
    if ( InformationClass == TrustedDomainAuthInformationInternal ||
         InformationClass == TrustedDomainFullInformationInternal ) {
        Status = STATUS_INVALID_INFO_CLASS;
        goto QueryInfoTrustedDomainError;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the handle is a valid
    // handle to a TrustedDomain object and has the necessary access granted.
    // Reference the handle.
    //

    //
    // If this is the open handle to a trusted domain object being treated as a secret object,
    // we already have a transaction going, so don't start one here.
    //
    if ( !FLAG_ON( ((LSAP_DB_HANDLE)TrustedDomainHandle)->Options,
                     LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET )) {

        Status = LsapDbReferenceObject(
                     TrustedDomainHandle,
                     DesiredAccess,
                     TrustedDomainObject,
                     TrustedDomainObject,
                     LSAP_DB_LOCK |
                         LSAP_DB_READ_ONLY_TRANSACTION |
                         LSAP_DB_DS_OP_TRANSACTION );

        if (!NT_SUCCESS(Status)) {

            goto QueryInfoTrustedDomainError;
        }

        ObjectReferenced = TRUE;
    }


    //
    // Compile a list of the attributes that hold the Trusted Domain Information of
    // the specified class.
    //

    NextAttribute = Attributes;

    switch (InformationClass) {

    case TrustedDomainNameInformation:

        //
        // Request read of the Trusted Account Name Information.
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrPN,
            NULL,
            0,
            FALSE
            );

        AttributeCount++;
        break;

    case TrustedPosixOffsetInformation:

        //
        // Request read of the Trusted Posix Offset Information.
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmPxOf,
            &TrustedPosixOffset,
            sizeof(ULONG),
            FALSE
            );

        AttributeCount++;
        break;

    case TrustedDomainInformationEx:

        //
        // Request just about everything...
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmName,
            NULL,
            0,
            FALSE
            );
        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            LsapDsIsWriteDs( TrustedDomainHandle ) ? TrDmTrPN : TrDmName,
            NULL,
            0,
            FALSE
            );
        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            LsapDsIsWriteDs( TrustedDomainHandle ) ? TrDmSid : Sid,
            NULL,
            0,
            FALSE
            );
        //
        // In the DS, it is possible to have an entry with a NULL sid.  If FULL info is
        // being collected, make sure to allow the read to happen if a NULL is encountered
        //
        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            NextAttribute->CanDefaultToZero = TRUE;
        }

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmPxOf,
            &TrustedPosixOffset,
            sizeof(ULONG),
            FALSE
            );

        AttributeCount++;
        NextAttribute++;

        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrTy,
                &TrustType,
                sizeof( TrustType ),
                FALSE
                );
            NextAttribute++;
            AttributeCount++;


            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrDi,
                &TrustDirection,
                sizeof( TrustDirection ),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrLA,
                &TrustAttributes,
                sizeof( TrustAttributes ),
                FALSE
                );

            LsapDbAttributeCanNotExist( NextAttribute );

            NextAttribute++;
            AttributeCount++;

        }
        break;

    case TrustedDomainAuthInformation:

        //
        // Only allow query of AuthInformation by trusted client.
        //
        //  (And global not set for debugging purposes.)
        //

        if ( !((LSAP_DB_HANDLE)TrustedDomainHandle)->Trusted &&
             !LsapDbReturnAuthData ) {

            Status = STATUS_INVALID_INFO_CLASS;
            goto QueryInfoTrustedDomainError;
        }

        //
        // Get the auth info...
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmSAI,
            NULL,
            0,
            FALSE
            );

        LsapDbAttributeCanNotExist( NextAttribute );
        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmSAO,
            NULL,
            0,
            FALSE
            );
        LsapDbAttributeCanNotExist( NextAttribute );
        AttributeCount++;
        NextAttribute++;
        break;

    case TrustedDomainFullInformation:
        //
        // Request read of the Trusted Posix Offset Information.
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmPxOf,
            &TrustedPosixOffset,
            sizeof(ULONG),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Request just about everything...
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmName,
            NULL,
            0,
            FALSE
            );
        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            LsapDsIsWriteDs( TrustedDomainHandle ) ? TrDmTrPN : TrDmName,
            NULL,
            0,
            FALSE
            );
        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            LsapDsIsWriteDs( TrustedDomainHandle ) ? TrDmSid : Sid,
            NULL,
            0,
            FALSE
            );

        //
        // In the DS, it is possible to have an entry with a NULL sid.  If FULL info is
        // being collected, make sure to allow the read to happen if a NULL is encountered
        //
        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            NextAttribute->CanDefaultToZero = TRUE;
        }
        AttributeCount++;
        NextAttribute++;

        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrTy,
                &TrustType,
                sizeof( TrustType ),
                FALSE
                );
            NextAttribute++;
            AttributeCount++;


            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrDi,
                &TrustDirection,
                sizeof( TrustDirection ),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrLA,
                &TrustAttributes,
                sizeof( TrustAttributes ),
                FALSE
                );

            LsapDbAttributeCanNotExist( NextAttribute );

            NextAttribute++;
            AttributeCount++;

        }

        //
        // Get the auth info...
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmSAI,
            NULL,
            0,
            FALSE
            );
        LsapDbAttributeCanNotExist( NextAttribute );
        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmSAO,
            NULL,
            0,
            FALSE
            );

        LsapDbAttributeCanNotExist( NextAttribute );
        AttributeCount++;
        NextAttribute++;
        break;

    case TrustedDomainFullInformation2Internal:

        //
        // Request read of the Trusted Posix Offset Information.
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmPxOf,
            &TrustedPosixOffset,
            sizeof(ULONG),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Request just about everything...
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmName,
            NULL,
            0,
            FALSE
            );

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            LsapDsIsWriteDs( TrustedDomainHandle ) ? TrDmTrPN : TrDmName,
            NULL,
            0,
            FALSE
            );

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            LsapDsIsWriteDs( TrustedDomainHandle ) ? TrDmSid : Sid,
            NULL,
            0,
            FALSE
            );

        //
        // In the DS, it is possible to have an entry with a NULL sid.  If FULL info is
        // being collected, make sure to allow the read to happen if a NULL is encountered
        //
        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            NextAttribute->CanDefaultToZero = TRUE;
        }

        AttributeCount++;
        NextAttribute++;

        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrTy,
                &TrustType,
                sizeof( TrustType ),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrDi,
                &TrustDirection,
                sizeof( TrustDirection ),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrLA,
                &TrustAttributes,
                sizeof( TrustAttributes ),
                FALSE
                );

            LsapDbAttributeCanNotExist( NextAttribute );

            NextAttribute++;
            AttributeCount++;

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmForT,
                NULL,
                0,
                FALSE
                );

            LsapDbAttributeCanNotExist( NextAttribute );

            AttributeCount++;
            NextAttribute++;
        }

        //
        // Get the auth info...
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmSAI,
            NULL,
            0,
            FALSE
            );

        LsapDbAttributeCanNotExist( NextAttribute );

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmSAO,
            NULL,
            0,
            FALSE
            );

        LsapDbAttributeCanNotExist( NextAttribute );

        AttributeCount++;
        NextAttribute++;

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto QueryInfoTrustedDomainError;
    }

    ASSERT( AttributeCount <= LSAP_DB_ATTRS_INFO_CLASS_DOMAIN );

    //
    //
    // Read the attributes corresponding to the given Policy Information
    // Class.  Memory will be allocated where required via MIDL_user_allocate
    // for attribute values.
    //

    Status = LsapDbReadAttributesObject(
                 TrustedDomainHandle,
                 0,
                 Attributes,
                 AttributeCount
                 );

    ReadAttributesStatus = Status;

    if (!NT_SUCCESS(Status)) {

        //
        // If the error was that one or more of the attributes holding
        // the information of the given class was not found, continue.
        // Otherwise, return an error.
        //
        goto QueryInfoTrustedDomainError;
    }

    //
    // If we are not in .NET forest mode, behave as if the forest transitive
    // bit did not exist
    //

    if ( !LsapDbNoMoreWin2KForest()) {

        TrustAttributes &= ~TRUST_ATTRIBUTE_FOREST_TRANSITIVE;
    }

    //
    // Now copy the information read to the output.  For certain information
    // classes where the information is stored as the value of a single
    // attribute of the Policy object and is in the form required by the
    // caller, we can just return the pointer to this buffer.  For all
    // other cases, an output buffer structure tree of the form desired
    // must be allocated via MIDL_user_allocate() and the information read from the attribute(s) of
    // the Policy object must be copied in.  These buffers must then be freed
    // by this routine before exit.  The array of attribute information
    // filled in by LsapDbReadAttributes() has MemoryAllocated = TRUE
    // in all cases.  We reset this flag to FALSE in the simple cases where
    // we can use the buffer as is.  The Finish section of the routine
    // will free up any buffers referenced by the AttributeValue pointer
    // in the attribute array where MemoryAllocated is still TRUE.  If
    // we go to error, the error processing is responsible for freeing
    // those buffers which would be passed to the calling RPC server stub
    // in the non-error case.
    //

    NextAttribute = Attributes;

    switch (InformationClass) {

    case TrustedDomainNameInformation:

        //
        // Allocate memory for output buffer top-level structure.
        //

        TrustedDomainNameInfo =
            MIDL_user_allocate(sizeof(TRUSTED_DOMAIN_NAME_INFO));

        if (TrustedDomainNameInfo == NULL) {

            Status = STATUS_NO_MEMORY;
            goto QueryInfoTrustedDomainError;
        }

        InfoBufferInAttributeArray = FALSE;
        InformationBuffer = TrustedDomainNameInfo;

        //
        // Copy the Unicode Name field to the output. Original buffer will
        // be freed in Finish section.
        //

        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainNameInfo->Name,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;
        break;

    case TrustedPosixOffsetInformation:

        //
        // Allocate memory for top-level output buffer.
        //

        InformationBuffer = NextAttribute->AttributeValue;

        TrustedPosixOffsetInfo = MIDL_user_allocate(sizeof(TRUSTED_POSIX_OFFSET_INFO));

        if (TrustedPosixOffsetInfo == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        InfoBufferInAttributeArray = FALSE;

        //
        // Copy Posix Offset value to output.
        //

        TrustedPosixOffsetInfo->Offset = TrustedPosixOffset;

        InformationBuffer = TrustedPosixOffsetInfo;
        break;

    case TrustedDomainInformationEx:

        //
        // Allocate memory for output buffer top-level structure.
        //

        TrustedDomainInfoEx =
            MIDL_user_allocate( sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) );

        if (TrustedDomainInfoEx == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto QueryInfoTrustedDomainError;
        }

        InfoBufferInAttributeArray = FALSE;

        //
        // Copy the Unicode Name field to the output. Original buffer will
        // be freed in Finish section.
        //

        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainInfoEx->Name,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            MIDL_user_free( TrustedDomainInfoEx );
            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;

        //
        // Netbios name
        //
        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainInfoEx->FlatName,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            MIDL_user_free( TrustedDomainInfoEx->Name.Buffer );
            MIDL_user_free( TrustedDomainInfoEx );
            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;

        if ( NextAttribute->AttributeValueLength != 0 ) {

            TrustedDomainInfoEx->Sid = MIDL_user_allocate( NextAttribute->AttributeValueLength );

            if ( TrustedDomainInfoEx->Sid == NULL ) {

                MIDL_user_free( TrustedDomainInfoEx->Name.Buffer );
                MIDL_user_free( TrustedDomainInfoEx->FlatName.Buffer );
                MIDL_user_free( TrustedDomainInfoEx );
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto QueryInfoTrustedDomainError;
            }

            RtlCopyMemory( TrustedDomainInfoEx->Sid, NextAttribute->AttributeValue,
                           NextAttribute->AttributeValueLength );

        } else {

            TrustedDomainInfoEx->Sid = NULL;
        }

        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            TrustedDomainInfoEx->TrustDirection = TrustDirection;
            TrustedDomainInfoEx->TrustType = TrustType;
            TrustedDomainInfoEx->TrustAttributes = TrustAttributes;

        } else {

            TrustedDomainInfoEx->TrustDirection = TRUST_DIRECTION_OUTBOUND;
            TrustedDomainInfoEx->TrustType = TRUST_TYPE_DOWNLEVEL;
            TrustedDomainInfoEx->TrustAttributes = 0;
        }

        InformationBuffer = TrustedDomainInfoEx;
        NextAttribute++;
        break;

    case TrustedDomainAuthInformation:

        TrustedDomainAuthInfo = (PTRUSTED_DOMAIN_AUTH_INFORMATION)
                            MIDL_user_allocate( sizeof( TRUSTED_DOMAIN_AUTH_INFORMATION ) );

        if ( TrustedDomainAuthInfo == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto QueryInfoTrustedDomainError;
        }

        Status = LsapDsBuildAuthInfoFromAttribute( TrustedDomainHandle,
                                                   NextAttribute->AttributeValue,
                                                   NextAttribute->AttributeValueLength,
                                                   &AuthInfoHalf );

        if ( NT_SUCCESS( Status ) ) {

            RtlCopyMemory( TrustedDomainAuthInfo, &AuthInfoHalf, sizeof( AuthInfoHalf ) );

            NextAttribute++;

            Status = LsapDsBuildAuthInfoFromAttribute( TrustedDomainHandle,
                                                       NextAttribute->AttributeValue,
                                                       NextAttribute->AttributeValueLength,
                                                       &AuthInfoHalf );

            if ( NT_SUCCESS( Status ) ) {

                TrustedDomainAuthInfo->OutgoingAuthInfos = AuthInfoHalf.AuthInfos;
                TrustedDomainAuthInfo->OutgoingAuthenticationInformation =
                         (PLSA_AUTH_INFORMATION)AuthInfoHalf.AuthenticationInformation;
                TrustedDomainAuthInfo->OutgoingPreviousAuthenticationInformation =
                         (PLSA_AUTH_INFORMATION)AuthInfoHalf.PreviousAuthenticationInformation;

            } else {

                LsapDsFreeUnmarshaledAuthInfo(
                    TrustedDomainAuthInfo->IncomingAuthInfos,
                    (PLSAPR_AUTH_INFORMATION)TrustedDomainAuthInfo->
                                                IncomingAuthenticationInformation );

            }

        }

        if ( !NT_SUCCESS( Status ) ) {

            MIDL_user_free( TrustedDomainAuthInfo );
            goto QueryInfoTrustedDomainError;
        }

        InformationBuffer = TrustedDomainAuthInfo;

        break;

    case TrustedDomainFullInformation:


        //
        // Allocate memory for top-level output buffer.
        //

        InformationBuffer = NextAttribute->AttributeValue;

        TrustedDomainFullInfo = MIDL_user_allocate(sizeof( TRUSTED_DOMAIN_FULL_INFORMATION ));

        if (TrustedDomainFullInfo == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto QueryInfoTrustedDomainError;
        }

        InfoBufferInAttributeArray = FALSE;

        //
        // Copy Posix Offset value to output.
        //

        TrustedDomainFullInfo->PosixOffset.Offset = TrustedPosixOffset;
        NextAttribute++;

        InformationBuffer = TrustedDomainFullInfo;

        //
        // Copy the Unicode Name field to the output. Original buffer will
        // be freed in Finish section.
        //

        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainFullInfo->Information.Name,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;

        //
        // Netbios name
        //
        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainFullInfo->Information.FlatName,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            MIDL_user_free( TrustedDomainFullInfo->Information.Name.Buffer );
            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;

        if ( NextAttribute->AttributeValueLength != 0 ) {

            TrustedDomainFullInfo->Information.Sid =
                                        MIDL_user_allocate( NextAttribute->AttributeValueLength );

            if ( TrustedDomainFullInfo->Information.Sid == NULL ) {

                MIDL_user_free( TrustedDomainFullInfo->Information.Name.Buffer );
                MIDL_user_free( TrustedDomainFullInfo->Information.FlatName.Buffer );
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto QueryInfoTrustedDomainError;
            }

            RtlCopyMemory( TrustedDomainFullInfo->Information.Sid, NextAttribute->AttributeValue,
                           NextAttribute->AttributeValueLength );
        } else {

            TrustedDomainFullInfo->Information.Sid = NULL;
        }

        NextAttribute++;

        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            TrustedDomainFullInfo->Information.TrustDirection = TrustDirection;
            NextAttribute++;
            TrustedDomainFullInfo->Information.TrustType = TrustType;
            NextAttribute++;
            TrustedDomainFullInfo->Information.TrustAttributes = TrustAttributes;
            NextAttribute++;

        } else {

            TrustedDomainFullInfo->Information.TrustDirection = TRUST_DIRECTION_OUTBOUND;
            TrustedDomainFullInfo->Information.TrustType = TRUST_TYPE_DOWNLEVEL;
            TrustedDomainFullInfo->Information.TrustAttributes = 0;
        }

        //
        // Only return Auth data to trusted client.
        //  (or if we're debugging auth data)
        //

        if ( !((LSAP_DB_HANDLE)TrustedDomainHandle)->Trusted &&
             !LsapDbReturnAuthData ) {

            RtlZeroMemory( &TrustedDomainFullInfo->AuthInformation,
                           sizeof( TrustedDomainFullInfo->AuthInformation ) );

        } else {

            //
            // Finally, the AuthInfo...
            Status = LsapDsBuildAuthInfoFromAttribute( TrustedDomainHandle,
                                                       NextAttribute->AttributeValue,
                                                       NextAttribute->AttributeValueLength,
                                                       &AuthInfoHalf );

            if ( NT_SUCCESS( Status ) ) {

                RtlCopyMemory( &TrustedDomainFullInfo->AuthInformation, &AuthInfoHalf, sizeof( AuthInfoHalf ) );

                NextAttribute++;

                Status = LsapDsBuildAuthInfoFromAttribute( TrustedDomainHandle,
                                                           NextAttribute->AttributeValue,
                                                           NextAttribute->AttributeValueLength,
                                                           &AuthInfoHalf );

                if ( NT_SUCCESS( Status ) ) {

                    TrustedDomainFullInfo->AuthInformation.OutgoingAuthInfos = AuthInfoHalf.AuthInfos;
                    TrustedDomainFullInfo->AuthInformation.OutgoingAuthenticationInformation =
                             (PLSA_AUTH_INFORMATION)AuthInfoHalf.AuthenticationInformation;
                    TrustedDomainFullInfo->AuthInformation.OutgoingPreviousAuthenticationInformation =
                             (PLSA_AUTH_INFORMATION)AuthInfoHalf.PreviousAuthenticationInformation;

                } else {

                    LsapDsFreeUnmarshaledAuthInfo(
                        TrustedDomainFullInfo->AuthInformation.IncomingAuthInfos,
                        (PLSAPR_AUTH_INFORMATION)TrustedDomainFullInfo->AuthInformation.
                                                               IncomingAuthenticationInformation );

                }
            }

            if ( !NT_SUCCESS ( Status ) ) {

                MIDL_user_free( TrustedDomainFullInfo->Information.Name.Buffer );
                MIDL_user_free( TrustedDomainFullInfo->Information.FlatName.Buffer );
                MIDL_user_free( TrustedDomainFullInfo->Information.Sid );
            }
        }

        break;

    case TrustedDomainFullInformation2Internal:

        //
        // Allocate memory for top-level output buffer.
        //

        InformationBuffer = NextAttribute->AttributeValue;

        TrustedDomainFullInfo2 = MIDL_user_allocate(sizeof( TRUSTED_DOMAIN_FULL_INFORMATION2 ));

        if ( TrustedDomainFullInfo2 == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto QueryInfoTrustedDomainError;
        }

        InfoBufferInAttributeArray = FALSE;

        //
        // Copy Posix Offset value to output.
        //

        TrustedDomainFullInfo2->PosixOffset.Offset = TrustedPosixOffset;
        NextAttribute++;

        InformationBuffer = TrustedDomainFullInfo2;

        //
        // Copy the Unicode Name field to the output. Original buffer will
        // be freed in Finish section.
        //

        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainFullInfo2->Information.Name,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;

        //
        // Netbios name
        //
        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainFullInfo2->Information.FlatName,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            MIDL_user_free( TrustedDomainFullInfo2->Information.Name.Buffer );
            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;

        if ( NextAttribute->AttributeValueLength != 0 ) {

            TrustedDomainFullInfo2->Information.Sid =
                                        MIDL_user_allocate( NextAttribute->AttributeValueLength );

            if ( TrustedDomainFullInfo2->Information.Sid == NULL ) {

                MIDL_user_free( TrustedDomainFullInfo2->Information.Name.Buffer );
                MIDL_user_free( TrustedDomainFullInfo2->Information.FlatName.Buffer );
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto QueryInfoTrustedDomainError;
            }

            RtlCopyMemory( TrustedDomainFullInfo2->Information.Sid, NextAttribute->AttributeValue,
                           NextAttribute->AttributeValueLength );
        } else {

            TrustedDomainFullInfo2->Information.Sid = NULL;
        }

        NextAttribute++;

        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            TrustedDomainFullInfo2->Information.TrustDirection = TrustDirection;
            NextAttribute++;
            TrustedDomainFullInfo2->Information.TrustType = TrustType;
            NextAttribute++;
            TrustedDomainFullInfo2->Information.TrustAttributes = TrustAttributes;
            NextAttribute++;

            if ( NextAttribute->AttributeValueLength != 0 ) {

                TrustedDomainFullInfo2->Information.ForestTrustLength = NextAttribute->AttributeValueLength;
                TrustedDomainFullInfo2->Information.ForestTrustInfo =
                    MIDL_user_allocate( NextAttribute->AttributeValueLength );

                if ( TrustedDomainFullInfo2->Information.ForestTrustInfo == NULL ) {

                    MIDL_user_free( TrustedDomainFullInfo2->Information.Name.Buffer );
                    MIDL_user_free( TrustedDomainFullInfo2->Information.FlatName.Buffer );
                    MIDL_user_free( TrustedDomainFullInfo2->Information.Sid );

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto QueryInfoTrustedDomainError;
                }

                RtlCopyMemory(
                    TrustedDomainFullInfo2->Information.ForestTrustInfo,
                    NextAttribute->AttributeValue,
                    NextAttribute->AttributeValueLength
                    );

            } else {

                TrustedDomainFullInfo2->Information.ForestTrustLength = 0;
                TrustedDomainFullInfo2->Information.ForestTrustInfo = NULL;
            }

            NextAttribute++;

        } else {

            TrustedDomainFullInfo2->Information.TrustDirection = TRUST_DIRECTION_OUTBOUND;
            TrustedDomainFullInfo2->Information.TrustType = TRUST_TYPE_DOWNLEVEL;
            TrustedDomainFullInfo2->Information.TrustAttributes = 0;
            TrustedDomainFullInfo2->Information.ForestTrustLength = 0;
            TrustedDomainFullInfo2->Information.ForestTrustInfo = NULL;
        }

        //
        // Only return Auth data to trusted client.
        //  (or if we're debugging auth data)
        //

        if ( !((LSAP_DB_HANDLE)TrustedDomainHandle)->Trusted &&
             !LsapDbReturnAuthData ) {

            RtlZeroMemory( &TrustedDomainFullInfo2->AuthInformation,
                           sizeof( TrustedDomainFullInfo2->AuthInformation ) );

        } else {

            //
            // Finally, the AuthInfo...
            Status = LsapDsBuildAuthInfoFromAttribute( TrustedDomainHandle,
                                                       NextAttribute->AttributeValue,
                                                       NextAttribute->AttributeValueLength,
                                                       &AuthInfoHalf );

            if ( NT_SUCCESS( Status ) ) {

                RtlCopyMemory( &TrustedDomainFullInfo2->AuthInformation, &AuthInfoHalf, sizeof( AuthInfoHalf ) );

                NextAttribute++;

                Status = LsapDsBuildAuthInfoFromAttribute( TrustedDomainHandle,
                                                           NextAttribute->AttributeValue,
                                                           NextAttribute->AttributeValueLength,
                                                           &AuthInfoHalf );

                if ( NT_SUCCESS( Status ) ) {

                    TrustedDomainFullInfo2->AuthInformation.OutgoingAuthInfos = AuthInfoHalf.AuthInfos;
                    TrustedDomainFullInfo2->AuthInformation.OutgoingAuthenticationInformation =
                             (PLSA_AUTH_INFORMATION)AuthInfoHalf.AuthenticationInformation;
                    TrustedDomainFullInfo2->AuthInformation.OutgoingPreviousAuthenticationInformation =
                             (PLSA_AUTH_INFORMATION)AuthInfoHalf.PreviousAuthenticationInformation;

                } else {

                    LsapDsFreeUnmarshaledAuthInfo(
                        TrustedDomainFullInfo2->AuthInformation.IncomingAuthInfos,
                        (PLSAPR_AUTH_INFORMATION)TrustedDomainFullInfo2->AuthInformation.
                                                               IncomingAuthenticationInformation );
                }
            }

            if ( !NT_SUCCESS ( Status ) ) {

                MIDL_user_free( TrustedDomainFullInfo2->Information.ForestTrustInfo );
                MIDL_user_free( TrustedDomainFullInfo2->Information.Name.Buffer );
                MIDL_user_free( TrustedDomainFullInfo2->Information.FlatName.Buffer );
                MIDL_user_free( TrustedDomainFullInfo2->Information.Sid );
            }
        }

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto QueryInfoTrustedDomainError;
    }

    //
    // Verify that the returned Trusted Domain Information is valid.  If not,
    // the Policy Database is corrupt.
    //

    if (!LsapDbValidInfoTrustedDomain(InformationClass, InformationBuffer)) {

        Status = STATUS_INTERNAL_DB_CORRUPTION;
    }

    //
    // Return a pointer to the output buffer to the caller
    //

    *Buffer = (PLSAPR_TRUSTED_DOMAIN_INFO) InformationBuffer;

QueryInfoTrustedDomainFinish:

    //
    // Free any unwanted buffers that were allocated by
    // LsapDbReadAttributesObject() and that are not being returned to the
    // caller server stub.  The server stub will free the buffers that we
    // do return after copying them to the return RPC transmit buffer.
    //

    for (NextAttribute = Attributes, AttributeNumber = 0;
         AttributeNumber < AttributeCount;
         NextAttribute++, AttributeNumber++) {

        //
        // If buffer holding attribute is marked as allocated, it is
        // to be freed here.
        //

        if (NextAttribute->MemoryAllocated) {

            if (NextAttribute->AttributeValue != NULL) {

                MIDL_user_free(NextAttribute->AttributeValue);
                NextAttribute->AttributeValue = NULL;
                NextAttribute->MemoryAllocated = FALSE;
            }
        }
    }

    //
    // If necessary, dereference the Trusted Domain Object, release the LSA Database lock and
    // return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &TrustedDomainHandle,
                     TrustedDomainObject,
                     TrustedDomainObject,
                     LSAP_DB_LOCK |
                        LSAP_DB_READ_ONLY_TRANSACTION |
                        LSAP_DB_DS_OP_TRANSACTION |
                        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_QueryInfoTrustedDomain);
    LsapExitFunc( "LsarQueryInfoTrustedDomain", Status );
    LsarpReturnPrologue();

    return(Status);

QueryInfoTrustedDomainError:

    //
    // If necessary, free the memory allocated for the output buffer.
    // We only do this free if the buffer is not referenced by the
    // attribute array, since all buffers so referenced will be freed
    // here or in the Finish section.
    //

    if ((InformationBuffer != NULL) && !InfoBufferInAttributeArray) {

        MIDL_user_free(InformationBuffer);
        InformationBuffer = NULL;
    }

    goto QueryInfoTrustedDomainFinish;
}



NTSTATUS
LsarSetInformationTrustedDomain(
    IN LSAPR_HANDLE TrustedDomainHandle,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaSetInfoTrustedDomain API.

    The LsaSetInformationTrustedDomain API modifies information in the Trusted
    Domain Object.  The caller must have access appropriate to the
    information to be changed in the Policy Object, see the InformationClass
    parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        TrustedDomainNameInformation          ( Cannot be set )
        TrustedControllersInformation     TRUSTED_SET_CONTROLLERS
        TrustedPosixOffsetInformation     TRUSTED_POSIX_INFORMATION

    Buffer - Points to a structure containing the information appropriate
        to the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        Others TBS
--*/

{
    NTSTATUS Status;
    ACCESS_MASK DesiredAccess;

    BOOLEAN ObjectReferenced = FALSE;
    BOOLEAN AcquiredListWriteLock = FALSE;
    PTRUSTED_POSIX_OFFSET_INFO TrustedPosixOffsetInfo;
    PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInfoEx = NULL;
    PTRUSTED_DOMAIN_AUTH_INFORMATION TrustedDomainAuthInfo;
    PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL TrustedDomainAuthInfoInternal;
    PTRUSTED_DOMAIN_FULL_INFORMATION TrustedDomainFullInfo;
    PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL TrustedDomainFullInfoInternal;
    PTRUSTED_DOMAIN_FULL_INFORMATION2 CurrentTrustedDomainFullInfo2 = NULL;
    TRUSTED_DOMAIN_INFORMATION_EX2 UpdateInfoEx2 = { 0 };

    TRUSTED_DOMAIN_AUTH_INFORMATION DecryptedTrustedDomainAuthInfo;
    TRUSTED_DOMAIN_FULL_INFORMATION DecryptedTrustedDomainFullInfo;

    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_INFO_CLASS_DOMAIN];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    ULONG AttributeCount = 0;
    ULONG AttributeNumber;

    BOOLEAN CreateInterdomainTrustAccount = FALSE;
    BOOLEAN UpdateTrustedDomainList = FALSE;
    PULONG UpdatePosixOffset = NULL;
    ULONG TrustedDomainPosixOffset = 0;

    PBYTE IncomingAuth = NULL, OutgoingAuth = NULL;
    ULONG IncomingSize = 0, OutgoingSize = 0;
    ULONG ReferenceOptions = LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION;
    ULONG DereferenceOptions = LSAP_DB_LOCK | LSAP_DB_FINISH_TRANSACTION;
    BOOLEAN HandleReferenced = FALSE;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;
    ULONG TrustAttributesValue;


    BOOLEAN SavedTrusted;
    LSAP_DB_HANDLE InternalTdoHandle = (LSAP_DB_HANDLE) TrustedDomainHandle;

    LsarpReturnCheckSetup();

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_SetInformationTrustedDomain);

    //
    // Initialization
    //

    RtlZeroMemory( &DecryptedTrustedDomainAuthInfo, sizeof(DecryptedTrustedDomainAuthInfo) );
    RtlZeroMemory( &DecryptedTrustedDomainFullInfo, sizeof(DecryptedTrustedDomainFullInfo) );

    //
    // Validate the Information Class and Trusted Domain Information provided and
    // if valid, return the mask of accesses required to update this
    // class of Trusted Domain information.
    //

    Status = LsapDbVerifyInfoSetTrustedDomain(
                 InformationClass,
                 TrustedDomainInformation,
                 FALSE,
                 &DesiredAccess
                 );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // Verify the handle before using it.
    //

    Status =  LsapDbVerifyHandle( TrustedDomainHandle, 0, TrustedDomainObject, TRUE );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    HandleReferenced = TRUE;

    //
    // If this is the open handle to a trusted domain object being treated as a secret object,
    // we already have a transaction going, so don't start one here.
    //
    if ( FLAG_ON( ((LSAP_DB_HANDLE)TrustedDomainHandle)->Options,
                    LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET )) {

        ReferenceOptions &= ~LSAP_DB_START_TRANSACTION;
        DereferenceOptions &= ~LSAP_DB_FINISH_TRANSACTION;
    }

    //
    // Get the session key.
    //
    // Do this before grabbing any locks.  Getting the session key is a kernel call.
    // The kernel will call back up to the LSA in another thread to get the key.
    // That thread may need locks this thread has locked.
    //

    if ( InformationClass == TrustedDomainAuthInformationInternal ||
         InformationClass == TrustedDomainFullInformationInternal ) {

        Status = LsapCrServerGetSessionKeySafe(
                    LsapDbContainerFromHandle( TrustedDomainHandle ),
                    PolicyObject,
                    &SessionKey );

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }
    }

    //
    // Acquire the Lsa Database lock.  Verify that the handle is
    // valid, is a handle to a TrustedDomain Object and has the necessary accesses
    // granted.  Reference the handle and start an Lsa Database transaction.
    //

    //
    // If this is the open handle to a trusted domain object being treated as a secret object,
    // we already have a transaction going, so don't start one here.
    //
    if ( !FLAG_ON( ((LSAP_DB_HANDLE)TrustedDomainHandle)->Options,
                     LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET )) {

        Status = LsapDbReferenceObject(
                     TrustedDomainHandle,
                     DesiredAccess,
                     TrustedDomainObject,
                     TrustedDomainObject,
                     ReferenceOptions
                     );

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }

        ObjectReferenced = TRUE;
    }

    //
    // Update the specified information in the Policy Object.
    //

    NextAttribute = Attributes;


    //
    // Grab a copy of the current information on the object.
    //

    SavedTrusted = ((LSAP_DB_HANDLE) TrustedDomainHandle)->Trusted;

    ((LSAP_DB_HANDLE) TrustedDomainHandle)->Trusted = TRUE;

    Status = LsarQueryInfoTrustedDomain( TrustedDomainHandle,
                                         TrustedDomainFullInformation2Internal,
                                         (PLSAPR_TRUSTED_DOMAIN_INFO *)
                                                &CurrentTrustedDomainFullInfo2 );

    ((LSAP_DB_HANDLE) TrustedDomainHandle)->Trusted = SavedTrusted;

    if ( !NT_SUCCESS( Status ) ) {

        goto Cleanup;
    }

    RtlCopyMemory( &UpdateInfoEx2, &CurrentTrustedDomainFullInfo2->Information, sizeof( TRUSTED_DOMAIN_INFORMATION_EX2 ) );

    //
    // Save a copy of the trust direction for the fixup routines
    //

    {
        PLSADS_PER_THREAD_INFO CurrentThreadInfo;

        CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

        ASSERT( CurrentThreadInfo != NULL );

        if ( CurrentThreadInfo != NULL ) {

            CurrentThreadInfo->OldTrustDirection = CurrentTrustedDomainFullInfo2->Information.TrustDirection;
            CurrentThreadInfo->OldTrustType = CurrentTrustedDomainFullInfo2->Information.TrustType;
        }
    }

    //
    // If we have a Ds object, we might be coming from the *ByName functions, which have a
    // cobbled handle that doesn't include the sid.  As such, we'll go ahead and read it here.
    //

    if ( LsapDsWriteDs ) {

        if ( ((LSAP_DB_HANDLE) TrustedDomainHandle)->Sid == NULL ) {

            if ( CurrentTrustedDomainFullInfo2->Information.Sid ) {
                ULONG SidLength;

                SidLength = RtlLengthSid( CurrentTrustedDomainFullInfo2->Information.Sid );

                ((LSAP_DB_HANDLE)TrustedDomainHandle)->Sid = LsapAllocateLsaHeap( SidLength );

                if (((LSAP_DB_HANDLE)TrustedDomainHandle)->Sid == NULL) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;

                }

                RtlCopySid( SidLength,
                            ((LSAP_DB_HANDLE)TrustedDomainHandle)->Sid,
                            CurrentTrustedDomainFullInfo2->Information.Sid );
            }
        }
    }

    switch (InformationClass) {

    case TrustedDomainNameInformation:

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;

    case TrustedControllersInformation:

        //
        // Obsolete info level.  Do nothing
        //
        break;

    case TrustedPosixOffsetInformation:

        TrustedPosixOffsetInfo = (PTRUSTED_POSIX_OFFSET_INFO) TrustedDomainInformation;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmPxOf,
            &TrustedPosixOffsetInfo->Offset,
            sizeof(ULONG),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Update the cache, too.
        //

        UpdatePosixOffset = &TrustedPosixOffsetInfo->Offset;
        break;

    case TrustedDomainInformationBasic:

        Status = STATUS_INVALID_INFO_CLASS;
        goto Cleanup;

    case TrustedDomainInformationEx:

        TrustedDomainInfoEx = (PTRUSTED_DOMAIN_INFORMATION_EX)TrustedDomainInformation;

        RtlCopyMemory( &UpdateInfoEx2,
                       TrustedDomainInfoEx,
                       sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) );

        UpdateInfoEx2.ForestTrustLength = CurrentTrustedDomainFullInfo2->Information.ForestTrustLength;
        UpdateInfoEx2.ForestTrustInfo = CurrentTrustedDomainFullInfo2->Information.ForestTrustInfo;

        //
        // If the client attempts to set the forest transitive bit,
        // verify that this is a domain in the root DC and that all
        // domains have been upgraded to Whistler before allowing the operation
        //

        if ( !FLAG_ON( CurrentTrustedDomainFullInfo2->Information.TrustAttributes,
                       TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
              FLAG_ON( TrustedDomainInfoEx->TrustAttributes,
                       TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
             ( !LsapDbDcInRootDomain() ||
               !LsapDbNoMoreWin2KForest())) {

            Status = STATUS_INVALID_DOMAIN_STATE;
            goto Cleanup;
        }

        //
        // If the client attempts to set the cross-federation bit,
        // verify that this domain is in Whistler mode before allowing the operation
        //

        if ( !FLAG_ON( CurrentTrustedDomainFullInfo2->Information.TrustAttributes,
                       TRUST_ATTRIBUTE_CROSS_ORGANIZATION ) &&
              FLAG_ON( TrustedDomainInfoEx->TrustAttributes,
                       TRUST_ATTRIBUTE_CROSS_ORGANIZATION ) &&
             !LsapDbNoMoreWin2KDomain()) {

            Status = STATUS_INVALID_DOMAIN_STATE;
            goto Cleanup;
        }

        //
        // Verify that trust points to the right place
        //

        Status = LsapDbVerifyTrustLocation(( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )TrustedDomainInfoEx );

        if ( !NT_SUCCESS( Status )) {

            goto Cleanup;
        }

        //
        // A trust can not be both "within forest" and either external or cross-org
        //

        if ( FLAG_ON( TrustedDomainInfoEx->TrustAttributes,
                      TRUST_ATTRIBUTE_WITHIN_FOREST ) &&
             ( FLAG_ON( TrustedDomainInfoEx->TrustAttributes,
                        TRUST_ATTRIBUTE_CROSS_ORGANIZATION ) ||
               FLAG_ON( TrustedDomainInfoEx->TrustAttributes,
                        TRUST_ATTRIBUTE_FOREST_TRANSITIVE ))) {

            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        UpdateTrustedDomainList = TRUE;

        //
        // Can't set domain names via this interface
        //

        //
        // Set the trust type and direction
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrTy,
            &TrustedDomainInfoEx->TrustType,
            sizeof( TrustedDomainInfoEx->TrustType ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrDi,
            &TrustedDomainInfoEx->TrustDirection,
            sizeof( TrustedDomainInfoEx->TrustDirection ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // For outbound up- and down-level TDO's, only allow the operation if either
        //    -- either a SID is specified as part of TrustedDomainInfoEx or
        //    -- a SID is specified as part of
        //

        if ( ( TrustedDomainInfoEx->TrustType == TRUST_TYPE_DOWNLEVEL ||
               TrustedDomainInfoEx->TrustType == TRUST_TYPE_UPLEVEL ) &&
             FLAG_ON( TrustedDomainInfoEx->TrustDirection, TRUST_DIRECTION_OUTBOUND ) &&
             TrustedDomainInfoEx->Sid == NULL &&
             CurrentTrustedDomainFullInfo2->Information.Sid == NULL ) {

            Status = STATUS_INVALID_SID;
            goto Cleanup;
        }

        //
        // If a SID was provided as part of TrustedDomainInfoEx, use it
        // but first verify that it is a valid domain SID
        //

        if ( TrustedDomainInfoEx->Sid != NULL ) {

            //
            // Trusted domain SIDs passsed in my be valid domain SIDs
            //

            Status = LsapIsValidDomainSid(
                         TrustedDomainInfoEx->Sid
                         );

            if ( !NT_SUCCESS( Status )) {

                goto Cleanup;
            }

            Status = LsapDbMakeSidAttributeDs(
                         TrustedDomainInfoEx->Sid,
                         TrDmSid,
                         NextAttribute );

            if ( !NT_SUCCESS( Status )) {

                goto Cleanup;
            }

            NextAttribute++;
            AttributeCount++;
        }

        //
        // Create the interdomain trust account for inbound TDOs
        //

        if ( FLAG_ON( TrustedDomainInfoEx->TrustDirection, TRUST_DIRECTION_INBOUND )) {

            CreateInterdomainTrustAccount = TRUE;
        }

        //
        // When setting trust attributes, mask off all but the supported bits
        //

        TrustAttributesValue =
            TrustedDomainInfoEx->TrustAttributes & TRUST_ATTRIBUTES_VALID;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrLA,
            &TrustAttributesValue,
            sizeof( TrustAttributesValue ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // If the forest trust bit is being cleared,
        // remove forest trust information from the TDO
        //

        if ( FLAG_ON( CurrentTrustedDomainFullInfo2->Information.TrustAttributes,
                      TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
            !FLAG_ON( TrustedDomainInfoEx->TrustAttributes,
                      TRUST_ATTRIBUTE_FOREST_TRANSITIVE )) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmForT,
                NULL,
                0,
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            UpdateInfoEx2.ForestTrustLength = 0;
            UpdateInfoEx2.ForestTrustInfo = NULL;

            LsapDsDebugOut(( DEB_FTINFO, "Removing forest trust information because forest trust bit is being cleared\n" ));
        }

        break;

    case TrustedDomainAuthInformationInternal:

        TrustedDomainAuthInfoInternal = (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL)TrustedDomainInformation;

        //
        // Build a decrypted Auth Info structure.
        //

        Status = LsapDecryptAuthDataWithSessionKey(
                            SessionKey,
                            TrustedDomainAuthInfoInternal,
                            &DecryptedTrustedDomainAuthInfo );

        if ( !NT_SUCCESS(Status) ) {

            goto Cleanup;
        }

        //
        // Use the decrypted information as though cleartext was passed from the caller.
        //

        TrustedDomainInformation = (PLSAPR_TRUSTED_DOMAIN_INFO) &DecryptedTrustedDomainAuthInfo;

        /* Drop through */

    case TrustedDomainAuthInformation:

        TrustedDomainAuthInfo = (PTRUSTED_DOMAIN_AUTH_INFORMATION)TrustedDomainInformation;

        //
        // Incoming...
        //  Use zero AuthInfos as our hint to not change the auth info.
        //

        if ( TrustedDomainAuthInfo->IncomingAuthInfos != 0 ) {

            //
            // There's a bug in the idl definition LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION where
            //  it doesn't allow more than one auth info to be passed over the wire.
            //  So, short circuit it here.
            //

            if ( InformationClass == TrustedDomainAuthInformation &&
                 !InternalTdoHandle->Trusted &&
                 TrustedDomainAuthInfo->IncomingAuthInfos > 1 ) {
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            Status = LsapDsBuildAuthInfoAttribute( TrustedDomainHandle,
                                                   LsapDsAuthHalfFromAuthInfo(
                                                            TrustedDomainAuthInfo, TRUE ),
                                                   LsapDsAuthHalfFromAuthInfo(
                                                            &CurrentTrustedDomainFullInfo2->AuthInformation, TRUE ),
                                                   &IncomingAuth,
                                                   &IncomingSize );

            if ( !NT_SUCCESS( Status ) ) {

                goto Cleanup;
            }
        }

        //
        // Same thing with the outgoing
        //

        if ( TrustedDomainAuthInfo->OutgoingAuthInfos != 0 ) {

            //
            // There's a bug in the idl definition LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION where
            //  it doesn't allow more than one auth info to be passed over the wire.
            //  So, short circuit it here.
            //

            if ( !InternalTdoHandle->Trusted &&
                 TrustedDomainAuthInfo->OutgoingAuthInfos > 1 ) {

                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            Status = LsapDsBuildAuthInfoAttribute( TrustedDomainHandle,
                                               LsapDsAuthHalfFromAuthInfo(
                                                        TrustedDomainAuthInfo, FALSE ),
                                               LsapDsAuthHalfFromAuthInfo(
                                                        &CurrentTrustedDomainFullInfo2->AuthInformation, FALSE ),
                                               &OutgoingAuth,
                                               &OutgoingSize );

            if ( !NT_SUCCESS( Status ) ) {

                goto Cleanup;
            }
        }

        if ( TrustedDomainAuthInfo->IncomingAuthInfos != 0 ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmSAI,
                IncomingAuth,
                IncomingSize,
                FALSE);

            NextAttribute++;
            AttributeCount++;
        }

        if ( TrustedDomainAuthInfo->OutgoingAuthInfos != 0 ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmSAO,
                OutgoingAuth,
                OutgoingSize,
                FALSE);

            NextAttribute++;
            AttributeCount++;
        }

        if ( FLAG_ON( CurrentTrustedDomainFullInfo2->Information.TrustDirection, TRUST_DIRECTION_INBOUND ) ) {

            CreateInterdomainTrustAccount = TRUE;
        }

        break;

    case TrustedDomainFullInformationInternal:

        TrustedDomainFullInfoInternal = (PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL)TrustedDomainInformation;

        //
        // Build a decrypted Auth Info structure.
        //

        Status = LsapDecryptAuthDataWithSessionKey(
                            SessionKey,
                            &TrustedDomainFullInfoInternal->AuthInformation,
                            &DecryptedTrustedDomainFullInfo.AuthInformation );

        if ( !NT_SUCCESS(Status) ) {

            goto Cleanup;
        }

        //
        // Copy over the other fields into a single structure
        //

        DecryptedTrustedDomainFullInfo.Information = *((PTRUSTED_DOMAIN_INFORMATION_EX)&(TrustedDomainFullInfoInternal->Information));
        DecryptedTrustedDomainFullInfo.PosixOffset = TrustedDomainFullInfoInternal->PosixOffset;

        //
        // Use the decrypted information as though cleartext was passed from the caller.
        //

        TrustedDomainInformation = (PLSAPR_TRUSTED_DOMAIN_INFO) &DecryptedTrustedDomainFullInfo;

        /* Drop through */

    case TrustedDomainFullInformation:

        TrustedDomainFullInfo = ( PTRUSTED_DOMAIN_FULL_INFORMATION )TrustedDomainInformation;

        RtlCopyMemory( &UpdateInfoEx2,
                       &TrustedDomainFullInfo->Information,
                       sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) );

        UpdateInfoEx2.ForestTrustLength = CurrentTrustedDomainFullInfo2->Information.ForestTrustLength;
        UpdateInfoEx2.ForestTrustInfo = CurrentTrustedDomainFullInfo2->Information.ForestTrustInfo;

        //
        // If the client attempts to set the forest transitive bit,
        // verify that this is a domain in the root DC and that all
        // domains have been upgraded to Whistler before allowing the operation
        //

        if ( !FLAG_ON( CurrentTrustedDomainFullInfo2->Information.TrustAttributes,
                       TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
              FLAG_ON( TrustedDomainFullInfo->Information.TrustAttributes,
                       TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
             ( !LsapDbDcInRootDomain() ||
               !LsapDbNoMoreWin2KForest())) {

            Status = STATUS_INVALID_DOMAIN_STATE;
            goto Cleanup;
        }

        //
        // If the client attempts to set the cross-federation bit,
        // verify that this domain is in Whistler mode before allowing the operation
        //

        if ( !FLAG_ON( CurrentTrustedDomainFullInfo2->Information.TrustAttributes,
                       TRUST_ATTRIBUTE_CROSS_ORGANIZATION ) &&
              FLAG_ON( TrustedDomainFullInfo->Information.TrustAttributes,
                       TRUST_ATTRIBUTE_CROSS_ORGANIZATION ) &&
             !LsapDbNoMoreWin2KDomain()) {

            Status = STATUS_INVALID_DOMAIN_STATE;
            goto Cleanup;
        }

        //
        // Verify that trust points to the right place
        //

        Status = LsapDbVerifyTrustLocation(
                     ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )&TrustedDomainFullInfo->Information );

        if ( !NT_SUCCESS( Status )) {

            goto Cleanup;
        }

        //
        // A trust can not be both "within forest" and either external or cross-org
        //

        if ( FLAG_ON( TrustedDomainFullInfo->Information.TrustAttributes,
                      TRUST_ATTRIBUTE_WITHIN_FOREST ) &&
             ( FLAG_ON( TrustedDomainFullInfo->Information.TrustAttributes,
                        TRUST_ATTRIBUTE_CROSS_ORGANIZATION ) ||
               FLAG_ON( TrustedDomainFullInfo->Information.TrustAttributes,
                        TRUST_ATTRIBUTE_FOREST_TRANSITIVE ))) {

            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        UpdateTrustedDomainList = TRUE;

        //
        // Update the Posix Offset in the cache, too.
        //

        UpdatePosixOffset = &TrustedDomainFullInfo->PosixOffset.Offset;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmPxOf,
            &TrustedDomainFullInfo->PosixOffset.Offset,
            sizeof(ULONG),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Can't set domain names via this interface
        //

        //
        // Set the trust type and direction
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrTy,
            &TrustedDomainFullInfo->Information.TrustType,
            sizeof( TrustedDomainFullInfo->Information.TrustType ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrDi,
            &TrustedDomainFullInfo->Information.TrustDirection,
            sizeof( TrustedDomainFullInfo->Information.TrustDirection ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // For outbound up- and down-level TDO's, only allow the operation if either
        //    -- either a SID is specified as part of TrustedDomainInfoEx or
        //    -- a SID is specified as part of
        //

        if ( ( TrustedDomainFullInfo->Information.TrustType == TRUST_TYPE_DOWNLEVEL ||
               TrustedDomainFullInfo->Information.TrustType == TRUST_TYPE_UPLEVEL ) &&
             FLAG_ON( TrustedDomainFullInfo->Information.TrustDirection, TRUST_DIRECTION_OUTBOUND ) &&
             TrustedDomainFullInfo->Information.Sid == NULL &&
             CurrentTrustedDomainFullInfo2->Information.Sid == NULL ) {

            Status = STATUS_INVALID_SID;
            goto Cleanup;
        }

        //
        // If a SID was provided as part of TrustedDomainFullInfo->Information, use it
        //

        if ( TrustedDomainFullInfo->Information.Sid != NULL ) {

            Status = LsapDbMakeSidAttributeDs(
                         TrustedDomainFullInfo->Information.Sid,
                         TrDmSid,
                         NextAttribute );

            if ( !NT_SUCCESS( Status )) {

                goto Cleanup;
            }

            NextAttribute++;
            AttributeCount++;
        }

        //
        // Create the interdomain trust account for inbound TDOs
        //

        if ( FLAG_ON( TrustedDomainFullInfo->Information.TrustDirection, TRUST_DIRECTION_INBOUND )) {

            CreateInterdomainTrustAccount = TRUE;
        }

        //
        // When setting trust attributes, mask off all but the supported bits
        //

        TrustAttributesValue =
            TrustedDomainFullInfo->Information.TrustAttributes & TRUST_ATTRIBUTES_VALID;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrLA,
            &TrustAttributesValue,
            sizeof( TrustAttributesValue ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Incoming...
        //  Use zero AuthInfos as our hint to not change the auth info.
        //

        if ( TrustedDomainFullInfo->AuthInformation.IncomingAuthInfos != 0 ) {

            //
            // There's a bug in the idl definition LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION where
            //  it doesn't allow more than one auth info to be passed over the wire.
            //  So, short circuit it here.
            //

            if ( InformationClass == TrustedDomainFullInformation &&
                 !InternalTdoHandle->Trusted &&
                 TrustedDomainFullInfo->AuthInformation.IncomingAuthInfos > 1 ) {

                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            Status = LsapDsBuildAuthInfoAttribute( TrustedDomainHandle,
                                                   LsapDsAuthHalfFromAuthInfo(
                                                            &TrustedDomainFullInfo->AuthInformation, TRUE ),
                                                   LsapDsAuthHalfFromAuthInfo(
                                                            &CurrentTrustedDomainFullInfo2->AuthInformation, TRUE ),
                                                   &IncomingAuth,
                                                   &IncomingSize );

            if ( !NT_SUCCESS(Status) ) {

                goto Cleanup;
            }
        }

        //
        // Same thing with the outgoing
        //

        if ( TrustedDomainFullInfo->AuthInformation.OutgoingAuthInfos != 0 ) {

            //
            // There's a bug in the idl definition LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION where
            //  it doesn't allow more than one auth info to be passed over the wire.
            //  So, short circuit it here.
            //

            if ( !InternalTdoHandle->Trusted &&
                 TrustedDomainFullInfo->AuthInformation.OutgoingAuthInfos > 1 ) {

                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            Status = LsapDsBuildAuthInfoAttribute( TrustedDomainHandle,
                                               LsapDsAuthHalfFromAuthInfo(
                                                        &TrustedDomainFullInfo->AuthInformation, FALSE ),
                                               LsapDsAuthHalfFromAuthInfo(
                                                        &CurrentTrustedDomainFullInfo2->AuthInformation, FALSE ),
                                               &OutgoingAuth,
                                               &OutgoingSize );
            if ( !NT_SUCCESS(Status) ) {

                goto Cleanup;
            }
        }

        if ( TrustedDomainFullInfo->AuthInformation.IncomingAuthInfos != 0 ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmSAI,
                IncomingAuth,
                IncomingSize,
                FALSE);

            NextAttribute++;
            AttributeCount++;
        }

        if ( TrustedDomainFullInfo->AuthInformation.OutgoingAuthInfos != 0 ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmSAO,
                OutgoingAuth,
                OutgoingSize,
                FALSE);

            NextAttribute++;
            AttributeCount++;
        }

        //
        // If the forest trust bit is being cleared,
        // remove forest trust information from the TDO
        //

        if ( FLAG_ON( CurrentTrustedDomainFullInfo2->Information.TrustAttributes,
                      TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
            !FLAG_ON( TrustedDomainFullInfo->Information.TrustAttributes,
                      TRUST_ATTRIBUTE_FOREST_TRANSITIVE )) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmForT,
                NULL,
                0,
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            UpdateInfoEx2.ForestTrustLength = 0;
            UpdateInfoEx2.ForestTrustInfo = NULL;

            LsapDsDebugOut(( DEB_FTINFO, "Removing forest trust information because forest trust bit is being cleared\n" ));
        }

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ASSERT( AttributeCount <= LSAP_DB_ATTRS_INFO_CLASS_DOMAIN );

    //
    // Update the TrustedDomain Object attributes
    //

    if ( AttributeCount > 0 ) {

        //
        // If we're might be changing trust direction or type,
        //  or we're changing the Posix Offset,
        //  check if we need to compute the Posix Offset.
        //

        if ( UpdateTrustedDomainList || UpdatePosixOffset != NULL ) {
            DOMAIN_SERVER_ROLE ServerRole;

            //
            // Only change the Posix Offset on the PDC.
            //  (Changes made on BDCs will have their Posix offset updated
            //  when the change is replicated onto the PDC.)
            //

            Status = SamIQueryServerRole(
                        LsapAccountDomainHandle,
                        &ServerRole
                        );


            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            //
            // Only allocate a Posix offset on the PDC.
            //

            if ( ServerRole == DomainServerRolePrimary ) {
                ULONG CurrentPosixOffset;
                BOOLEAN PosixOffsetChanged = FALSE;


                //
                // Get the current PosixOffset
                //

                if ( UpdatePosixOffset == NULL ) {
                    CurrentPosixOffset = CurrentTrustedDomainFullInfo2->PosixOffset.Offset;
                } else {
                    CurrentPosixOffset = *UpdatePosixOffset;
                }

                //
                // If we should have a Posix Offset,
                //  ensure we have one.
                //

                if ( LsapNeedPosixOffset( UpdateInfoEx2.TrustDirection,
                                          UpdateInfoEx2.TrustType ) ) {


                    if ( CurrentPosixOffset == 0 ) {

                       //
                       // Need to grab the TDL write lock while allocating a Posix Offset
                       //

                       Status = LsapDbAcquireWriteLockTrustedDomainList();

                       if ( !NT_SUCCESS(Status)) {
                           goto Cleanup;
                       }

                       AcquiredListWriteLock = TRUE;


                       //
                       // Allocate the next available Posix Offset.
                       //

                       Status = LsapDbAllocatePosixOffsetTrustedDomainList(
                                    &TrustedDomainPosixOffset );

                       if ( !NT_SUCCESS(Status)) {
                           goto Cleanup;
                       }

                       PosixOffsetChanged = TRUE;
                    }
                //
                // If we shouldn't have a Posix Offset,
                //  ensure we don't have one.
                //

                } else {
                    if ( CurrentPosixOffset != 0 ) {
                        TrustedDomainPosixOffset = 0;
                        PosixOffsetChanged = TRUE;
                    }
                }

                //
                // If we're forcing the Posix Offset to change,
                //  do it now.
                //

                if ( PosixOffsetChanged ) {

                    //
                    // If we're already writing the Posix Offset to the DS,
                    //  simply put the new value in that location.
                    //

                    if ( UpdatePosixOffset != NULL ) {
                        *UpdatePosixOffset = TrustedDomainPosixOffset;

                    //
                    // Otherwise, add it to the list of attributes to write.
                    //
                    } else {
                        UpdatePosixOffset = &TrustedDomainPosixOffset;

                        LsapDbInitializeAttributeDs(
                            NextAttribute,
                            TrDmPxOf,
                            UpdatePosixOffset,
                            sizeof(ULONG),
                            FALSE
                            );

                        NextAttribute++;
                        AttributeCount++;
                    }
                }
            }
        }


        //
        // Write the attributes to the DS.
        //

        Status = LsapDbWriteAttributesObject(
                     TrustedDomainHandle,
                     Attributes,
                     AttributeCount
                     );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // If we need it, create the interdomain trust account
        //
        if ( CreateInterdomainTrustAccount ) {

            Status = LsapDsCreateInterdomainTrustAccount( TrustedDomainHandle );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }
        }


        //
        // Finally, update the trust info in the trusted domain list
        //

        if ( UpdateTrustedDomainList ) {

            Status = LsapDbFixupTrustedDomainListEntry(
                        CurrentTrustedDomainFullInfo2->Information.Sid,
                        ( PLSAPR_UNICODE_STRING )&CurrentTrustedDomainFullInfo2->Information.Name,
                        ( PLSAPR_UNICODE_STRING )&CurrentTrustedDomainFullInfo2->Information.FlatName,
                        ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 )&UpdateInfoEx2,
                        UpdatePosixOffset );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

        } else if ( UpdatePosixOffset != NULL ) {

            Status = LsapDbFixupTrustedDomainListEntry(
                        ((LSAP_DB_HANDLE)TrustedDomainHandle)->Sid,
                        NULL,
                        NULL,
                        NULL,   // No other trust info to update
                        UpdatePosixOffset );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

        }
    }

    Status = STATUS_SUCCESS;


Cleanup:

    if (NT_SUCCESS(Status) && LsapAdtAuditingEnabledHint(AuditCategoryPolicyChange, EVENTLOG_AUDIT_SUCCESS)) {

        (void) LsapAdtTrustedDomainMod(
                   EVENTLOG_AUDIT_SUCCESS,
                   CurrentTrustedDomainFullInfo2->Information.Sid,
                   &CurrentTrustedDomainFullInfo2->Information.Name,
                   CurrentTrustedDomainFullInfo2->Information.TrustType,
                   CurrentTrustedDomainFullInfo2->Information.TrustDirection,
                   CurrentTrustedDomainFullInfo2->Information.TrustAttributes,
                   &UpdateInfoEx2.Name,
                   UpdateInfoEx2.TrustType,
                   UpdateInfoEx2.TrustDirection,
                   UpdateInfoEx2.TrustAttributes
                   );
    }

    if ( HandleReferenced ) {
        LsapDbDereferenceHandle( TrustedDomainHandle, NT_SUCCESS( Status ) );
    }
    if ( SessionKey != NULL ) {
        MIDL_user_free( SessionKey );
    }


    //
    // Free memory allocated by this routine for attribute buffers.
    // These have MemoryAllocated = TRUE in their attribute information.
    // Leave alone buffers allocated by calling RPC stub.
    //

    for( NextAttribute = Attributes, AttributeNumber = 0;
         AttributeNumber < AttributeCount;
         NextAttribute++, AttributeNumber++) {

        if (NextAttribute->MemoryAllocated) {

            ASSERT(NextAttribute->AttributeValue != NULL);
            MIDL_user_free(NextAttribute->AttributeValue);
        }
    }

    //
    // If necessary, dereference the Trusted Domain Object, release the LSA Database lock and
    // return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &TrustedDomainHandle,
                     TrustedDomainObject,
                     TrustedDomainObject,
                     DereferenceOptions,
                     SecurityDbChange,
                     Status
                     );
    }

    if ( CurrentTrustedDomainFullInfo2 != NULL ) {
        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
            TrustedDomainFullInformation2Internal,
            (PLSAPR_TRUSTED_DOMAIN_INFO) CurrentTrustedDomainFullInfo2 );
    }


    //
    // If necessary, release the Trusted Domain List Write Lock.
    //

    if (AcquiredListWriteLock) {

        LsapDbReleaseLockTrustedDomainList();
        AcquiredListWriteLock = FALSE;
    }



    //
    // Free the auth info we might have allocated
    //
    if ( IncomingAuth ) {

        LsapFreeLsaHeap( IncomingAuth );
    }

    if ( OutgoingAuth ) {

        LsapFreeLsaHeap( OutgoingAuth );
    }

    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &DecryptedTrustedDomainAuthInfo, TRUE ) );
    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &DecryptedTrustedDomainAuthInfo, FALSE ) );

    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &DecryptedTrustedDomainFullInfo.AuthInformation, TRUE ) );
    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &DecryptedTrustedDomainFullInfo.AuthInformation, FALSE ) );

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_SetInformationTrustedDomain);
    LsarpReturnPrologue();

    return(Status);

}


NTSTATUS
LsarEnumerateTrustedDomains(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaEnumerateTrustedDomains API.

    The LsaEnumerateTrustedDomains API returns information about
    TrustedDomain objects.  This call requires POLICY_VIEW_LOCAL_INFORMATION
    access to the Policy object.  Since there may be more information than
    can be returned in a single call of the routine, multiple calls can be
    made to get all of the information.  To support this feature, the caller
    is provided with a handle that can be used across calls to the API.  On
    the initial call, EnumerationContext should point to a variable that has
    been initialized to 0.  On each subsequent call, the value returned by
    the preceding call should be passed in unchanged.  The enumeration is
    complete when the warning STATUS_NO_MORE_ENTRIES is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    EnumerationBuffer - Pointer to an enumeration structure that will receive
        a count of the Trusted Domains enumerated on this call and a pointer to
        an array of entries containing information for each enumerated
        Trusted Domain.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.
            Some entries may have been returned.
            The caller need not call again.

        STATUS_MORE_ENTRIES - The call completed successfully.
            Some entries have been returned.  The caller should call again to
            get additional entries.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects have been enumerated because the
            EnumerationContext value is too high.

--*/

{
    NTSTATUS Status;
    PLSA_TRUST_INFORMATION XrefDomainTrustList = NULL;
    ULONG XrefEntriesReturned;
    ULONG XrefDomainTrustListLength;
    ULONG XrefDomainTrustCount = 0;
    PLSAPR_POLICY_INFORMATION PolicyAccountDomainInfo = NULL;

    // PSID *Sids = NULL;
    // LSAPR_HANDLE TrustedDomainHandle = NULL;
    // ULONG MaxLength;

    ULONG XrefIndex;
    ULONG CurrentIndex;

    LIST_ENTRY RootList, TrustList;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY NextEntry;
    BOOLEAN TdosEnumerated = FALSE;
    // BOOLEAN SomeTdosReturned = FALSE;

    PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC FullTrustedDomainList = NULL;
    ULONG FullTrustedDomainCount = 0 ;
    ULONG i;

#define LSAP_XREF_ENUMERATION_CONTEXT 0x80000000

    LsarpReturnCheckSetup();

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_EnumerateTrustedDomains);

    //
    // If no Enumeration Structure is provided, return an error.
    //

    if (!ARGUMENT_PRESENT(EnumerationBuffer)) {
        Status = STATUS_INVALID_PARAMETER;
        goto FunctionReturn;
    }

    EnumerationBuffer->EntriesRead = 0;
    EnumerationBuffer->Information = NULL;

    InitializeListHead( &RootList );
    InitializeListHead( &TrustList );

    if ( PreferedMaximumLength == 0 ) {
        PreferedMaximumLength = 1;
    }


    //
    // If the enumeration context indicates we've already progress past the TDOs,
    //  skip them
    //

    if ( (*EnumerationContext & LSAP_XREF_ENUMERATION_CONTEXT) == 0 ) {

        //
        // Call the worker routine that's shared with the Ex version.
        //

        Status = LsapEnumerateTrustedDomainsEx(
                         PolicyHandle,
                         EnumerationContext,
                         TrustedDomainInformationBasic,
                         (PLSAPR_TRUSTED_DOMAIN_INFO *)&(EnumerationBuffer->Information),
                         PreferedMaximumLength,
                         &EnumerationBuffer->EntriesRead,
                         LSAP_DB_ENUMERATE_AS_NT4 );

        //
        // If we're not done with the TDOs,
        //  return to the caller.
        //
        if ( Status != STATUS_SUCCESS && Status != STATUS_NO_MORE_ENTRIES ) {
            goto Cleanup;
        }

        //
        // Indicate that we're just starting to enumerate the XREF objects.
        //
        *EnumerationContext = LSAP_XREF_ENUMERATION_CONTEXT;
    } else {
        Status = STATUS_NO_MORE_ENTRIES;
    }

    //
    // On native mode domains,
    //  return all of the domains in the forest.
    //
    // This ensures that downlevel clients see the indirectly trusted domains.
    // The downlevel client can then authenticate using accounts in such domains
    // using NTLM transitive trust.
    //

    //
    // If we're not hosting a DS,
    //  or this is a mixed domain,
    //  we're done enumerating.
    //
    // The only trusted called of this is replication to an NT 4 BDC.
    // It only wants the directly trusted domains.
    //

    if ( !LsapDsWriteDs ||
         ((LSAP_DB_HANDLE)PolicyHandle)->Trusted ||
         SamIMixedDomain( LsapAccountDomainHandle ) ) {
        *EnumerationContext = 0xFFFFFFFF;

        // Status is already set.
        goto Cleanup;
    }

    //
    // Enumerate the XREF objects
    //

    Status = LsapBuildForestTrustInfoLists(
                        NULL,   // Use global policy handle
                        &TrustList );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Loop through the XREFS determining how many we should return to the caller.
    //
    // Assert: at this point RootList is empty and TrustList contains all XREFs
    //
    // This loop will move a subset of the XREFs to the RootList.  Those XREFs
    //  represent the ones to be returned to the caller.
    //

    XrefIndex = (*EnumerationContext) & ~LSAP_XREF_ENUMERATION_CONTEXT;
    CurrentIndex = 0;
    XrefEntriesReturned = 0;

    for ( ListEntry = TrustList.Flink ;
          ListEntry != &TrustList ;
          ListEntry = NextEntry ) {

        PLSAPDS_FOREST_TRUST_BLOB TrustBlob;

        NextEntry = ListEntry->Flink;

        TrustBlob = CONTAINING_RECORD( ListEntry,
                                       LSAPDS_FOREST_TRUST_BLOB,
                                       Next );

        //
        // Only consider entries greater or equal to our current enumeration context.
        //

        if ( CurrentIndex >= XrefIndex ) {

            //
            // Ignore entries without a DomainSid.
            //

            if ( TrustBlob->DomainSid != NULL &&
                 TrustBlob->FlatName.Length != 0 ) {

                BOOLEAN AlreadyDone;

                //
                // If we haven't yet read a complete list of all the TDOs we've
                //  returned to the caller in the past,
                //  do so now.
                //

                if ( !TdosEnumerated ) {
                    LSA_ENUMERATION_HANDLE LocalEnumHandle = 0;

                    //
                    // Get to complete trusted domain list.
                    //  Use global handle to avoid list length limitations.
                    //

                    Status = LsapEnumerateTrustedDomainsEx(
                                     LsapPolicyHandle,
                                     &LocalEnumHandle,
                                     TrustedDomainInformationBasic,
                                     (PLSAPR_TRUSTED_DOMAIN_INFO *)&FullTrustedDomainList,
                                     0xFFFFFFFF,
                                     &FullTrustedDomainCount,
                                     LSAP_DB_ENUMERATE_AS_NT4 );

                    // Handle the zero trusted domain case
                    if ( Status == STATUS_NO_MORE_ENTRIES ) {
                        Status = STATUS_SUCCESS;
                        FullTrustedDomainCount = 0;
                        FullTrustedDomainList = NULL;
                    }

                    if ( Status != STATUS_SUCCESS ) {
                        if ( Status == STATUS_MORE_ENTRIES ) {
                            Status = STATUS_INTERNAL_DB_CORRUPTION;
                        }
                        goto Cleanup;
                    }

                    //
                    // Get the Sid of this domain, too
                    //

                    Status = LsapDbQueryInformationPolicy(
                                    LsapPolicyHandle,
                                    PolicyAccountDomainInformation,
                                    &PolicyAccountDomainInfo );

                    if ( !NT_SUCCESS(Status) ) {
                        goto Cleanup;
                    }

                    TdosEnumerated = TRUE;

                }

                //
                // Check if this is the XREF for this domain.
                //

                AlreadyDone = FALSE;
                if ( RtlEqualSid( PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid,
                             TrustBlob->DomainSid ) ) {
                    AlreadyDone = TRUE;
                }

                //
                // Determine if the XREF object matches one of the TDOs.
                //

                if ( !AlreadyDone ) {
                    for ( i=0; i<FullTrustedDomainCount; i++ ) {
                        if ( FullTrustedDomainList[i].Sid != NULL &&
                             RtlEqualSid( FullTrustedDomainList[i].Sid,
                                          TrustBlob->DomainSid ) ) {
                            AlreadyDone = TRUE;
                            break;
                        }
                    }
                }

                //
                // If the XREF object doesn't match any of the TDOs,
                //  return it to the caller.
                //

                if ( !AlreadyDone ) {

                    //
                    // Add the entry to the list of entries to return to the caller
                    //

                    RemoveEntryList( ListEntry );
                    InsertTailList( &RootList, ListEntry );

                    XrefEntriesReturned++;
                }
            }
        }

        //
        // Account for the entry
        //

        CurrentIndex++;
    }

    XrefIndex = CurrentIndex | LSAP_XREF_ENUMERATION_CONTEXT;

    //
    // If the passed in enumeration context was too large,
    //  tell the caller.
    //

    XrefDomainTrustListLength = (XrefEntriesReturned + EnumerationBuffer->EntriesRead) * sizeof(LSA_TRUST_INFORMATION);

    if ( XrefDomainTrustListLength == 0 ) {
        if ( *EnumerationContext == 0 ) {
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_NO_MORE_ENTRIES;
        }
        goto Cleanup;
    }

    //
    // Allocate a buffer to returned to the caller.
    //

    XrefDomainTrustList = MIDL_user_allocate( XrefDomainTrustListLength );

    if ( XrefDomainTrustList == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory ( XrefDomainTrustList, XrefDomainTrustListLength );

    //
    // If there were any TDOs returned on this call,
    //  copy them over now.
    //

    XrefDomainTrustCount = 0;
    if ( EnumerationBuffer->EntriesRead != 0 ) {

        //
        // Indicate where the first XREF will be returned.
        //
        XrefDomainTrustCount = EnumerationBuffer->EntriesRead;

        RtlCopyMemory( XrefDomainTrustList,
                       EnumerationBuffer->Information,
                       EnumerationBuffer->EntriesRead * sizeof(LSA_TRUST_INFORMATION) );

        //
        // Free the old buffer since it is no longer needed.
        //

        MIDL_user_free( EnumerationBuffer->Information );
        EnumerationBuffer->Information = NULL;
        EnumerationBuffer->EntriesRead = 0;

    }


    //
    // Loop through the XREFS returning them
    //
    // Assert: at this point RootList contains the entries to return and
    //  TrustList contain the other XREFs
    //

    // XrefEntriesReturned = 0;

    for ( ListEntry = RootList.Flink ;
          ListEntry != &RootList ;
          ListEntry = ListEntry->Flink ) {

        PLSAPDS_FOREST_TRUST_BLOB TrustBlob;

        TrustBlob = CONTAINING_RECORD( ListEntry,
                                       LSAPDS_FOREST_TRUST_BLOB,
                                       Next );

        //
        // Copy the Name.
        //

        Status = LsapRpcCopyUnicodeString(
                     NULL,
                     (PUNICODE_STRING) &XrefDomainTrustList[XrefDomainTrustCount].Name,
                     &TrustBlob->FlatName );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Copy the Sid.
        //

        Status = LsapRpcCopySid(
                     NULL,
                     (PSID) &XrefDomainTrustList[XrefDomainTrustCount].Sid,
                     TrustBlob->DomainSid );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        XrefDomainTrustCount ++;
    }

    *EnumerationContext = XrefIndex;
    EnumerationBuffer->Information = (PLSAPR_TRUST_INFORMATION)XrefDomainTrustList;
    EnumerationBuffer->EntriesRead = XrefDomainTrustCount;
    XrefDomainTrustList = NULL;

    Status = STATUS_SUCCESS;

Cleanup:

    //
    // Delete the trust lists
    //
    LsapDsForestFreeTrustBlobList( &TrustList );
    LsapDsForestFreeTrustBlobList( &RootList );

    if ( PolicyAccountDomainInfo != NULL ) {
        LsaIFree_LSAPR_POLICY_INFORMATION ( PolicyAccountDomainInformation,
                                            PolicyAccountDomainInfo );
    }

    if ( FullTrustedDomainList != NULL ) {
        LsapFreeTrustedDomainsEx( TrustedDomainInformationBasic,
                                  (PLSAPR_TRUSTED_DOMAIN_INFO)FullTrustedDomainList,
                                  FullTrustedDomainCount );
    }

    if ( XrefDomainTrustList != NULL ) {
        LsapFreeTrustedDomainsEx( TrustedDomainInformationBasic,
                                  (PLSAPR_TRUSTED_DOMAIN_INFO)XrefDomainTrustList,
                                  XrefDomainTrustCount );
    }

FunctionReturn:
    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_EnumerateTrustedDomains);
    LsarpReturnPrologue();

    return(Status);
}


NTSTATUS
LsapDbSlowEnumerateTrustedDomains(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN TRUSTED_INFORMATION_CLASS InfoClass,
    OUT PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function performs the same actions as LsarEnumerateTrustedDomains()
    except that the Trusted Domain List is not used.

    This routine is called internally by the LSA only.  Since there
    may be more information than can be returned in a single call of the
    routine, multiple calls can be made to get all of the information.  To
    support this feature, the caller is provided with a handle that can
    be used across calls to the API.  On the initial call, EnumerationContext
    should point to a variable that has been initialized to 0.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    InfoClass - The class of information to return
        Must be TrustedDomainInformationEx, TrustedDomainInformatinBasic or
        TrustedDomainInformationEx2Internal

    EnumerationBuffer - Pointer to an enumeration structure that will receive
        a count of the Trusted Domains enumerated on this call and a pointer to
        an array of entries containing information for each enumerated
        Trusted Domain.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if there are no more objects to enumerate.  Note that
            one or more objects may be enumerated on a call that returns this
            reply.
--*/

{
    NTSTATUS Status;
    LSAP_DB_SID_ENUMERATION_BUFFER DbEnumerationBuffer;
    PVOID AllocatedBuffer = NULL;
    //PLSA_TRUST_INFORMATION DomainTrustInfo = NULL;
    LSAP_DB_ATTRIBUTE DomainNameAttribute;
    ULONG DomainTrustInfoLength;
    LSAPR_HANDLE TrustedDomainHandle = NULL;
    ULONG EntriesRead = 0;
    ULONG Index;

    ASSERT( InfoClass == TrustedDomainInformationEx ||
            InfoClass == TrustedDomainInformationEx2Internal ||
            InfoClass == TrustedDomainInformationBasic );

    //
    // Initialization.
    //

    DbEnumerationBuffer.EntriesRead = 0;
    DbEnumerationBuffer.Sids = NULL;
    EnumerationBuffer->EntriesRead = 0;
    EnumerationBuffer->Information = NULL;
    DomainNameAttribute.AttributeValue = NULL;

    //
    // If no Enumeration Structure is provided, return an error.
    //

    if (!ARGUMENT_PRESENT(EnumerationBuffer)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Call general Sid enumeration routine.  This will return an array
    // of pointers to Sids of Trusted Domains referenced from the
    // Enumeration Buffer.
    //

    Status = LsapDbEnumerateSids(
                 PolicyHandle,
                 TrustedDomainObject,
                 EnumerationContext,
                 &DbEnumerationBuffer,
                 PreferedMaximumLength
                 );

    if ((Status != STATUS_NO_MORE_ENTRIES) && !NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Return the number of entries read.  Note that the Enumeration Buffer
    // returned from LsapDbEnumerateSids is expected to be non-null
    // in all non-error cases.
    //

    EntriesRead = DbEnumerationBuffer.EntriesRead;

    if (EntriesRead == 0) {
        goto Cleanup;
    }


    //
    // Allocate a buffer to return to our caller
    //

    switch (InfoClass ) {
    case TrustedDomainInformationBasic:
        DomainTrustInfoLength = EntriesRead * sizeof(LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC);
        break;

    case TrustedDomainInformationEx:
        DomainTrustInfoLength = EntriesRead * sizeof(LSAPR_TRUSTED_DOMAIN_INFORMATION_EX);
        break;

    case TrustedDomainInformationEx2Internal:
        DomainTrustInfoLength = EntriesRead * sizeof(LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2);
        break;

    default:
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;

    }

    AllocatedBuffer = MIDL_user_allocate( DomainTrustInfoLength );

    if ( AllocatedBuffer == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Initialize all pointers to Sids and Unicode buffers in the
    // DomainTrustInfo array to zero.  The error path of this routine
    // assumes that a non-zero value of a Sid or Unicode buffer indicates
    // that memory is to be freed.
    //

    RtlZeroMemory( AllocatedBuffer, DomainTrustInfoLength );

    //
    // Loop through the trusted domains returning the information the caller
    //  requested.
    //

    for ( Index=0; Index<EntriesRead; Index++ ) {


        //
        // Grab the Sid of the trusted domain.
        //


        //
        // Open the Trusted Domain object.  This call is trusted, i.e.
        // no access validation or impersonation is required.  Also,
        // the Lsa Database is already locked so we do not need to
        // lock it again.
        //

        Status = LsapDbOpenTrustedDomain(
                     PolicyHandle,
                     DbEnumerationBuffer.Sids[Index],
                     (ACCESS_MASK) 0,
                     &TrustedDomainHandle,
                     LSAP_DB_TRUSTED );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Read the Domain Name
        //

        LsapDbInitializeAttributeDs(
            &DomainNameAttribute,
            TrDmName,
            NULL,
            0L,
            FALSE
            );

        Status = LsapDbReadAttribute(TrustedDomainHandle, &DomainNameAttribute);

        (VOID) LsapDbCloseObject(
                   &TrustedDomainHandle,
                   LSAP_DB_DEREFERENCE_CONTR,
                   Status
                   );

        if (!NT_SUCCESS(Status)) {

#if DBG
            DbgPrint( "LsarEnumerateTrustedDomains - Reading Domain Name\n" );

            DbgPrint( "    failed.  Error 0x%lx reading Trusted Domain Name attribute\n",
                Status);
#endif //DBG

            goto Cleanup;
        }

        //
        // Return the information to the caller.
        //
        switch (InfoClass ) {
        case TrustedDomainInformationBasic:
        {
            PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC DomainTrust;

            DomainTrust = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC)AllocatedBuffer)[Index];

            // Grab the Sid
            DomainTrust->Sid = DbEnumerationBuffer.Sids[Index];
            DbEnumerationBuffer.Sids[Index] = NULL;

            // Grab the Domain Name
            Status = LsapDbCopyUnicodeAttribute(
                         (PUNICODE_STRING)&DomainTrust->Name,
                         &DomainNameAttribute,
                         TRUE );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            break;
        }

        case TrustedDomainInformationEx2Internal:
        {
            PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustInfoEx2;

            TrustInfoEx2 = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2)AllocatedBuffer)[Index];

            // Grab the Sid
            TrustInfoEx2->Sid = DbEnumerationBuffer.Sids[Index];
            DbEnumerationBuffer.Sids[Index] = NULL;

            // Grab the Domain Name
            Status = LsapDbCopyUnicodeAttribute(
                         (PUNICODE_STRING)&TrustInfoEx2->Name,
                         &DomainNameAttribute,
                         TRUE );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            // Grab the Flat Domain Name
            Status = LsapDbCopyUnicodeAttribute(
                         (PUNICODE_STRING)&TrustInfoEx2->FlatName,
                         &DomainNameAttribute,
                         TRUE );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            // Fill in the constant info
            TrustInfoEx2->TrustDirection = TRUST_DIRECTION_OUTBOUND;
            TrustInfoEx2->TrustType = TRUST_TYPE_DOWNLEVEL;
            TrustInfoEx2->TrustAttributes = 0;
            TrustInfoEx2->ForestTrustLength = 0;
            TrustInfoEx2->ForestTrustInfo = NULL;

            break;
        }

        case TrustedDomainInformationEx:
        {
            PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustInfoEx;

            TrustInfoEx = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX)AllocatedBuffer)[Index];

            // Grab the Sid
            TrustInfoEx->Sid = DbEnumerationBuffer.Sids[Index];
            DbEnumerationBuffer.Sids[Index] = NULL;

            // Grab the Domain Name
            Status = LsapDbCopyUnicodeAttribute(
                         (PUNICODE_STRING)&TrustInfoEx->Name,
                         &DomainNameAttribute,
                         TRUE );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            // Grab the Flat Domain Name
            Status = LsapDbCopyUnicodeAttribute(
                         (PUNICODE_STRING)&TrustInfoEx->FlatName,
                         &DomainNameAttribute,
                         TRUE );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            // Fill in the constant info
            TrustInfoEx->TrustDirection = TRUST_DIRECTION_OUTBOUND;
            TrustInfoEx->TrustType = TRUST_TYPE_DOWNLEVEL;
            TrustInfoEx->TrustAttributes = 0;

            break;
        }
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    //
    // On error,
    //  free any buffer we allocated.
    //

    if ( !NT_SUCCESS(Status) ) {
        if (AllocatedBuffer != NULL) {
            for ( Index=0; Index<EntriesRead; Index++ ) {
                switch (InfoClass ) {
                case TrustedDomainInformationBasic:
                {
                    PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC DomainTrust;

                    DomainTrust = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC)AllocatedBuffer)[Index];

                    if ( DomainTrust->Sid != NULL ) {
                        MIDL_user_free( DomainTrust->Sid );
                    }

                    if ( DomainTrust->Name.Buffer != NULL ) {
                        MIDL_user_free( DomainTrust->Name.Buffer );
                    }

                    break;
                }

                case TrustedDomainInformationEx:
                {
                    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustInfoEx;

                    TrustInfoEx = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX)AllocatedBuffer)[Index];

                    if ( TrustInfoEx->Sid != NULL ) {
                        MIDL_user_free( TrustInfoEx->Sid );
                    }

                    if ( TrustInfoEx->Name.Buffer != NULL ) {
                        MIDL_user_free( TrustInfoEx->Name.Buffer );
                    }

                    if ( TrustInfoEx->FlatName.Buffer != NULL ) {
                        MIDL_user_free( TrustInfoEx->FlatName.Buffer );
                    }

                    break;
                }


                case TrustedDomainInformationEx2Internal:
                {
                    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustInfoEx2;

                    TrustInfoEx2 = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2)AllocatedBuffer)[Index];

                    if ( TrustInfoEx2->Sid != NULL ) {
                        MIDL_user_free( TrustInfoEx2->Sid );
                    }

                    if ( TrustInfoEx2->Name.Buffer != NULL ) {
                        MIDL_user_free( TrustInfoEx2->Name.Buffer );
                    }

                    if ( TrustInfoEx2->FlatName.Buffer != NULL ) {
                        MIDL_user_free( TrustInfoEx2->FlatName.Buffer );
                    }

                    break;
                }

                }
            }
            MIDL_user_free( AllocatedBuffer );
            AllocatedBuffer = NULL;
            DbEnumerationBuffer.EntriesRead = 0;
        }
    }

    //
    // Fill in returned Enumeration Structure, returning 0 or NULL for
    // fields in the error case.
    //

    EnumerationBuffer->Information = (PLSAPR_TRUST_INFORMATION) AllocatedBuffer;
    EnumerationBuffer->EntriesRead = DbEnumerationBuffer.EntriesRead;

    //
    // If necessary, free the Domain Name Attribute Value buffer which
    // holds a self relative Unicode String.
    //

    if (DomainNameAttribute.AttributeValue != NULL) {

        MIDL_user_free( DomainNameAttribute.AttributeValue );
        DomainNameAttribute.AttributeValue = NULL;
    }

    //
    // Free the SID enumeration buffer.
    //

    if ( DbEnumerationBuffer.Sids != NULL ) {
        for ( Index=0; Index<EntriesRead; Index++ ) {
            if ( DbEnumerationBuffer.Sids[Index] != NULL ) {
                MIDL_user_free( DbEnumerationBuffer.Sids[Index] );
            }
        }
        MIDL_user_free( DbEnumerationBuffer.Sids );

    }

    return(Status);

}


NTSTATUS
LsapDbVerifyInfoQueryTrustedDomain(
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN BOOLEAN Trusted,
    OUT PACCESS_MASK RequiredAccess
    )

/*++

Routine Description:

    This function validates a TrustedDomain Information Class.  If valid, a mask
    of the accesses required to set the TrustedDomain Information of the class is
    returned.

Arguments:

    InformationClass - Specifies a TrustedDomain Information Class.

    Trusted - TRUE if client is trusted, else FALSE.  A trusted client
        is allowed to query TrustedDomain for all Information Classes, whereas
        a non-trusted client is restricted.

    RequiredAccess - Points to variable that will receive a mask of the
        accesses required to query the given class of TrustedDomain Information.
        If an error is returned, this value is cleared to 0.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The TrustedDomain Information Class provided is
            valid and the information provided is consistent with this
            class.

        STATUS_INVALID_PARAMETER - Invalid parameter:

            Information Class is invalid
            TrustedDomain  Information not valid for the class
--*/

{
    if (LsapDbValidInfoTrustedDomain( InformationClass, NULL)) {

        *RequiredAccess = LsapDbRequiredAccessQueryTrustedDomain[InformationClass];
        return(STATUS_SUCCESS);
    }

    return(STATUS_INVALID_PARAMETER);

    //
    // Currently, all TrustedDomain information classes may be queried
    // by non-trusted callers, so the Trusted parameter is not accessed.
    //

    UNREFERENCED_PARAMETER(Trusted);
}


NTSTATUS
LsapDbVerifyInfoSetTrustedDomain(
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation,
    IN BOOLEAN Trusted,
    OUT PACCESS_MASK RequiredAccess
    )

/*++

Routine Description:

    This function validates a TrustedDomain Information Class and verifies
    that the provided TrustedDomain Information is valid for the class.
    If valid, a mask of the accesses required to set the TrustedDomain
    Information of the class is returned.

Arguments:

    InformationClass - Specifies a TrustedDomain Information Class.

    TrustedDomainInformation - Points to TrustedDomain Information to be set.

    Trusted - TRUE if client is trusted, else FALSE.  A trusted client
        is allowed to set TrustedDomain for all Information Classes, whereas
        a non-trusted client is restricted.

    RequiredAccess - Points to variable that will receive a mask of the
        accesses required to set the given class of TrustedDomain Information.
        If an error is returned, this value is cleared to 0.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The TrustedDomain Information Class provided is
            valid and the information provided is consistent with this
            class.

        STATUS_INVALID_PARAMETER - Invalid parameter:

            Information Class is invalid
            Information Class is invalid for non-trusted clients
            TrustedDomain Information not valid for the class
--*/

{
    //
    // Verify that the information class is valid and that the TrustedDomain
    // Information provided is valid for the class.
    //

    if (LsapDbValidInfoTrustedDomain( InformationClass, TrustedDomainInformation)) {

        //
        // Non-trusted callers are not allowed to set the
        // TrustedDomainNameInformation information class.
        //

        if (!Trusted) {

            if (InformationClass == TrustedDomainNameInformation) {

                return(STATUS_INVALID_PARAMETER);
            }
        }

//        ASSERT( InformationClass <=
//                   sizeof( LsapDbRequiredAccessSetTrustedDomain ) / sizeof( ACCESS_MASK ) + 1);

        *RequiredAccess = LsapDbRequiredAccessSetTrustedDomain[InformationClass];
        return(STATUS_SUCCESS);
    }

    return(STATUS_INVALID_PARAMETER);
}


BOOLEAN
LsapDbValidInfoTrustedDomain(
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN OPTIONAL PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation
    )

/*++

Routine Description:

    This function validates a TrustedDomain Information Class and optionally verifies
    that provided TrustedDomain Information is valid for the class.

Arguments:

    InformationClass - Specifies a TrustedDomain Information Class.

    TrustedDomainInformation - Optionally points to TrustedDomain Information.  If
        NULL is specified, no TrustedDomain Information checking takes place.

Return Values:

    BOOLEAN - TRUE if the TrustedDomain information class provided is
        valid, else FALSE.
--*/

{
    BOOLEAN BooleanStatus = FALSE;

    //
    // Validate the Information Class
    //

    if ((InformationClass >= TrustedDomainNameInformation) &&
        (InformationClass <= TrustedDomainFullInformation2Internal)) {

        if (TrustedDomainInformation == NULL) {

            return(TRUE);
        }

        switch (InformationClass) {

        case TrustedDomainNameInformation: {
            PTRUSTED_DOMAIN_NAME_INFO TrustedDomainNameInfo = (PTRUSTED_DOMAIN_NAME_INFO) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainNameInfo->Name )) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedPosixOffsetInformation: {
            PTRUSTED_POSIX_OFFSET_INFO TrustedPosixOffsetInfo = (PTRUSTED_POSIX_OFFSET_INFO) TrustedDomainInformation;

            BooleanStatus = TRUE;
            break;
        }


        case TrustedPasswordInformation: {
            PLSAPR_TRUSTED_PASSWORD_INFO TrustedPasswordInfo =  (PLSAPR_TRUSTED_PASSWORD_INFO) TrustedDomainInformation;      TrustedPasswordInfo;
            if ( TrustedPasswordInfo->Password != NULL &&
                 !LsapValidateLsaCipherValue( TrustedPasswordInfo->Password )) {
                break;
            }
            if ( TrustedPasswordInfo->OldPassword != NULL &&
                 !LsapValidateLsaCipherValue( TrustedPasswordInfo->OldPassword )) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainInformationBasic: {
            PTRUSTED_DOMAIN_INFORMATION_BASIC TrustedDomainBasicInfo = (PTRUSTED_DOMAIN_INFORMATION_BASIC) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainBasicInfo->Name )) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainInformationEx: {
            PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainExInfo = (PTRUSTED_DOMAIN_INFORMATION_EX) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainExInfo->Name )) {
                break;
            }
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainExInfo->FlatName )) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainAuthInformation: {
            PTRUSTED_DOMAIN_AUTH_INFORMATION TrustedDomainAuthInfo = (PTRUSTED_DOMAIN_AUTH_INFORMATION) TrustedDomainInformation;

            if ( TrustedDomainAuthInfo->IncomingAuthInfos != 0 &&
                 TrustedDomainAuthInfo->IncomingAuthenticationInformation == NULL ) {
                break;
            }

            if ( TrustedDomainAuthInfo->OutgoingAuthInfos != 0 &&
                 TrustedDomainAuthInfo->OutgoingAuthenticationInformation == NULL ) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainFullInformation: {
            PTRUSTED_DOMAIN_FULL_INFORMATION TrustedDomainFullInfo = (PTRUSTED_DOMAIN_FULL_INFORMATION) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainFullInfo->Information.Name )) {
                break;
            }
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainFullInfo->Information.FlatName )) {
                break;
            }

            if ( TrustedDomainFullInfo->AuthInformation.IncomingAuthInfos != 0 &&
                 TrustedDomainFullInfo->AuthInformation.IncomingAuthenticationInformation == NULL ) {
                break;
            }

            if ( TrustedDomainFullInfo->AuthInformation.OutgoingAuthInfos != 0 &&
                 TrustedDomainFullInfo->AuthInformation.OutgoingAuthenticationInformation == NULL ) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainAuthInformationInternal: {
            PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL TrustedDomainAuthInfo = (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL) TrustedDomainInformation;

            if ( TrustedDomainAuthInfo->AuthBlob.AuthSize != 0 &&
                 TrustedDomainAuthInfo->AuthBlob.AuthBlob == NULL ) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainFullInformationInternal: {
            PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL TrustedDomainFullInfo = (PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainFullInfo->Information.Name )) {
                break;
            }
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainFullInfo->Information.FlatName )) {
                break;
            }

            if ( TrustedDomainFullInfo->AuthInformation.AuthBlob.AuthSize != 0 &&
                 TrustedDomainFullInfo->AuthInformation.AuthBlob.AuthBlob == NULL ) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainInformationEx2Internal: {
            PTRUSTED_DOMAIN_INFORMATION_EX2 TrustedDomainExInfo2 = (PTRUSTED_DOMAIN_INFORMATION_EX2) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainExInfo2->Name )) {
                break;
            }
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainExInfo2->FlatName )) {
                break;
            }
            if ( TrustedDomainExInfo2->ForestTrustLength == 0 ||
                 TrustedDomainExInfo2->ForestTrustInfo == NULL ) {

                if ( TrustedDomainExInfo2->ForestTrustLength != 0 ||
                     TrustedDomainExInfo2->ForestTrustInfo != NULL ) {

                    break;
                }
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainFullInformation2Internal: {
            PTRUSTED_DOMAIN_FULL_INFORMATION2 TrustedDomainFullInfo2 = (PTRUSTED_DOMAIN_FULL_INFORMATION2) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainFullInfo2->Information.Name )) {
                break;
            }
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainFullInfo2->Information.FlatName )) {
                break;
            }

            if ( TrustedDomainFullInfo2->AuthInformation.IncomingAuthInfos != 0 &&
                 TrustedDomainFullInfo2->AuthInformation.IncomingAuthenticationInformation == NULL ) {
                break;
            }

            if ( TrustedDomainFullInfo2->AuthInformation.OutgoingAuthInfos != 0 &&
                 TrustedDomainFullInfo2->AuthInformation.OutgoingAuthenticationInformation == NULL ) {
                break;
            }

            if ( TrustedDomainFullInfo2->Information.ForestTrustLength == 0 ||
                 TrustedDomainFullInfo2->Information.ForestTrustInfo == NULL ) {

                if ( TrustedDomainFullInfo2->Information.ForestTrustLength != 0 ||
                     TrustedDomainFullInfo2->Information.ForestTrustInfo != NULL ) {

                    break;
                }
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedControllersInformation: // No longer supported
        default:

            BooleanStatus = FALSE;
            break;
        }
    }

    return(BooleanStatus);
}


NTSTATUS
LsapDbLookupSidTrustedDomainList(
    IN PLSAPR_SID DomainSid,
    OUT PLSAPR_TRUST_INFORMATION *TrustInformation
    )

/*++

Routine Description:

    This function looks up a given Trusted Domain Sid in the Trusted
    Domain List and returns Trust Information consisting of its
    Sid and Name.

Arguments:

    DomainSid - Pointer to a Sid that will be compared with the list of
        Sids of Trusted Domains.

    TrustInformation - Receives the a pointer to the Trust Information
        (Sid and Name) of the Trusted Domain specified by DomainSid
        within the Trusted Domain List.

        NOTE: The trust information returned will always be the trusted
        domain objects domain name.  Not the flat name.  That means that
        for uplevel trusts, a DNS domain name will be returned.

        NOTE: This routine assumes that the Trusted Domain List
        will not be updated while any Lookup operations are pending.
        Thus, the pointer returned for TrustInformation will remain
        valid.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The domain was found.

        STATUS_NO_SUCH_DOMAIN - The domain was not found.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SectionIndex;
    LSAPR_TRUST_INFORMATION InputTrustInformation;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;

    //
    // Don't try to lookup by sid if we don't have a sid
    //
    if ( DomainSid == NULL ) {

        Status = STATUS_NO_SUCH_DOMAIN;
        goto LookupSidTrustedDomainListError;

    }

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto LookupSidTrustedDomainListError;
        }
    }

    InputTrustInformation.Sid = DomainSid;
    InputTrustInformation.Name.Buffer = NULL;
    InputTrustInformation.Name.Length = 0;
    InputTrustInformation.Name.MaximumLength = 0;

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupSidTrustedDomainListError;
    }

    //
    // Return pointer to Trust Information
    //

    *TrustInformation = &TrustEntry->ConstructedTrustInfo;

LookupSidTrustedDomainListFinish:

    return(Status);

LookupSidTrustedDomainListError:

    *TrustInformation = NULL;
    goto LookupSidTrustedDomainListFinish;
}


NTSTATUS
LsapDbLookupNameTrustedDomainList(
    IN PLSAPR_UNICODE_STRING DomainName,
    OUT PLSAPR_TRUST_INFORMATION *TrustInformation
    )

/*++

Routine Description:

    This function looks up a given Trusted Domain Name in the Trusted
    Domain List and returns Trust Information consisting of its
    Sid and Name.

Arguments:

    DomainName - Pointer to a Unicode Name that will be compared with the
        list of Names of Trusted Domains.

    TrustInformation - Receives the a pointer to the Trust Information
        (Sid and Name) of the Trusted Domain described by DomainName
        within the Trusted Domain List.

        NOTE: This name will be looked up as both the trusted domain objects
        domain name and the flat name

        NOTE: This routine assumes that the Trusted Domain List
        will not be updated while any Lookup operations are pending.
        Thus, the pointer returned for TrustInformation will remain
        valid.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The domain was found.

        STATUS_NO_SUCH_DOMAIN - The domain was not found.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SectionIndex;
    LSAPR_TRUST_INFORMATION InputTrustInformation;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto LookupNameTrustedDomainListError;
        }
    }

    InputTrustInformation.Sid = NULL;
    InputTrustInformation.Name = *DomainName;

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNameTrustedDomainListError;
    }

    //
    // Return pointer to Trust Information
    //

    *TrustInformation = &TrustEntry->ConstructedTrustInfo;

LookupNameTrustedDomainListFinish:

    return(Status);

LookupNameTrustedDomainListError:

    *TrustInformation = NULL;
    goto LookupNameTrustedDomainListFinish;
}

NTSTATUS
LsapDbLookupSidTrustedDomainListEx(
    IN PSID DomainSid,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainListEntry
    )

/*++

Routine Description:

    This function looks up a given Trusted Domain Name in the Trusted
    Domain List and returns Trust Information consisting of its
    Sid and Name.

Arguments:

    DomainSid - sid of the domain to lookup

    TrustInformation - Receives the a pointer to the Trust Information
        (Sid and Name) of the Trusted Domain described by DomainName
        within the Trusted Domain List.

        NOTE: This name will be looked up as both the trusted domain objects
        domain name and the flat name

        NOTE: This routine assumes that the Trusted Domain List
        will not be updated while any Lookup operations are pending.
        Thus, the pointer returned for TrustInformation will remain
        valid.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The domain was found.

        STATUS_NO_SUCH_DOMAIN - The domain was not found.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SectionIndex;
    LSAPR_TRUST_INFORMATION InputTrustInformation;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto LookupSidTrustedDomainListError;
        }
    }

    InputTrustInformation.Sid = DomainSid;
    RtlInitUnicodeString( (UNICODE_STRING*)&InputTrustInformation.Name, NULL );

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry );

    if (!NT_SUCCESS(Status)) {

        goto LookupSidTrustedDomainListError;
    }

    //
    // Return pointer to Trust Information
    //

    *TrustedDomainListEntry = TrustEntry;

LookupSidTrustedDomainListFinish:

    return(Status);

LookupSidTrustedDomainListError:

    *TrustedDomainListEntry = NULL;
    goto LookupSidTrustedDomainListFinish;
}



NTSTATUS
LsapDbLookupNameTrustedDomainListEx(
    IN PLSAPR_UNICODE_STRING DomainName,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainListEntry
    )

/*++

Routine Description:

    This function looks up a given Trusted Domain Name in the Trusted
    Domain List and returns Trust Information consisting of its
    Sid and Name.

Arguments:

    DomainName - Pointer to a Unicode Name that will be compared with the
        list of Names of Trusted Domains.

    TrustInformation - Receives the a pointer to the Trust Information
        (Sid and Name) of the Trusted Domain described by DomainName
        within the Trusted Domain List.

        NOTE: This name will be looked up as both the trusted domain objects
        domain name and the flat name

        NOTE: This routine assumes that the Trusted Domain List
        will not be updated while any Lookup operations are pending.
        Thus, the pointer returned for TrustInformation will remain
        valid.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The domain was found.

        STATUS_NO_SUCH_DOMAIN - The domain was not found.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SectionIndex;
    LSAPR_TRUST_INFORMATION InputTrustInformation;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto LookupNameTrustedDomainListError;
        }
    }

    InputTrustInformation.Sid = NULL;
    InputTrustInformation.Name = *DomainName;

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry );

    if (!NT_SUCCESS(Status)) {

        goto LookupNameTrustedDomainListError;
    }

    //
    // Return pointer to Trust Information
    //

    *TrustedDomainListEntry = TrustEntry;

LookupNameTrustedDomainListFinish:

    return(Status);

LookupNameTrustedDomainListError:

    *TrustedDomainListEntry = NULL;
    goto LookupNameTrustedDomainListFinish;
}




NTSTATUS
LsapDbLookupEntryTrustedDomainList(
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainListEntry
    )

/*++

Routine Decsription:

    This function locates an entry for a Trusted Domain in the Trusted
    Domain List, given Trust Information containing either a Domain Sid
    or a Domain Name.

Arguments:

    TrustInformation - Points to the Sid and Name of a Trusted Domain.

    TrustedDomainListEntry - Receives pointer to the trusted domain list
        entry that statisfies the request

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The domain was found.

        STATUS_NO_SUCH_DOMAIN - The domain was not found.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY ListEntry;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY PossibleMatch = NULL, BestMatch = NULL, Current;

    ULONG ScanSectionIndex;

    BOOLEAN LookupSid = TRUE;

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            *TrustedDomainListEntry = NULL;
            goto Cleanup;
        }
    }

    //
    // Decide if we're to lookup a Domain Sid or a Domain Name.
    //

    if (TrustInformation->Sid == NULL) {

        LookupSid = FALSE;
    }

    for ( ListEntry = LsapDbTrustedDomainList.ListHead.Flink;
          ListEntry != &LsapDbTrustedDomainList.ListHead;
          ListEntry = ListEntry->Flink ) {

        Current = CONTAINING_RECORD( ListEntry, LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, NextEntry );

        //
        // Find the best match.  Note that if we find an entry without a SID, we'll mark it
        // as a possible match, but see if we can do better.
        if (LookupSid) {

            if ( Current->TrustInfoEx.Sid &&
                 RtlEqualSid( ( PSID )TrustInformation->Sid,
                              ( PSID )Current->TrustInfoEx.Sid ) ) {

                BestMatch = Current;
                break;
            }

        } else {

            //
            // Check domain name first
            //
            if ( LsapCompareDomainNames(
                    (PUNICODE_STRING) &(TrustInformation->Name),
                    (PUNICODE_STRING) &(Current->TrustInfoEx.Name),
                    (PUNICODE_STRING) &(Current->TrustInfoEx.FlatName))
                ) {

                //
                // If we have a full domain object, just return the info.  Otherwise,
                // we'll see if we don't have a better match down the line
                //
                if ( Current->TrustInfoEx.Sid ) {

                    BestMatch = Current;
                    break;

                } else {

                    //
                    // There might be duplicate objects in the DS
                    // The best we can do is pick one
                    //

                    PossibleMatch = Current;
                }
            }
        }
    }

    //
    // Now, see what to return
    //
    if ( BestMatch == NULL ) {

        BestMatch = PossibleMatch;
    }

    if ( BestMatch ) {

        *TrustedDomainListEntry = BestMatch;

    } else {

        *TrustedDomainListEntry = NULL;
        Status = STATUS_NO_SUCH_DOMAIN;

    }

Cleanup:

    return(Status);
}


NTSTATUS
LsapDbInitializeTrustedDomainListEntry(
    IN PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustListEntry,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 DomainInfo,
    IN ULONG PosixOffset
    )
/*++

Routine Description:

    This function will initialize a trusted domain list entry to the
    information contained in the TRUSTED_DOMAIN_INFORMATION_EX structure

Arguments:

    TrustListEntry - The TRUSTED_DOMAIN_LIST_ENTRY node to initialize

    DomainInfo - Points to a LSAPR_TRUSTED_DOMAIN_INFORMATION_EX
        structure which contains information on the trusted domain.

    PosixOffset - Posix offset for this trusted domain

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Intialize the Trust List entry first to all 0's
    //

    RtlZeroMemory(TrustListEntry,sizeof(LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY));

    //
    // Copy the information over
    //
    Status = LsapRpcCopyUnicodeString( NULL,
                                       ( PUNICODE_STRING )&TrustListEntry->TrustInfoEx.Name,
                                       ( PUNICODE_STRING )&DomainInfo->Name );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsapRpcCopyUnicodeString( NULL,
                                           ( PUNICODE_STRING )&TrustListEntry->TrustInfoEx.FlatName,
                                           ( PUNICODE_STRING )&DomainInfo->FlatName );

        if ( NT_SUCCESS( Status ) && DomainInfo->Sid ) {

            Status = LsapRpcCopySid( NULL,
                                     ( PSID )&TrustListEntry->TrustInfoEx.Sid,
                                     ( PSID )DomainInfo->Sid );

        } else {

            TrustListEntry->TrustInfoEx.Sid = NULL;
        }
    }

    //
    // See if this entry contains forest trust information, and if so, insert it
    //

    if ( NT_SUCCESS( Status ) &&
         LsapHavingForestTrustMakesSense(
             DomainInfo->TrustDirection,
             DomainInfo->TrustType,
             DomainInfo->TrustAttributes
             ) &&
         DomainInfo->ForestTrustInfo != NULL &&
         DomainInfo->ForestTrustLength > 0 ) {

        LSA_FOREST_TRUST_INFORMATION ForestTrustInfo;

        Status = LsapForestTrustUnmarshalBlob(
                     DomainInfo->ForestTrustLength,
                     DomainInfo->ForestTrustInfo,
                     ForestTrustRecordTypeLast,
                     &ForestTrustInfo
                     );

        if ( NT_SUCCESS( Status )) {

            Status = LsapForestTrustCacheInsert(
                         ( PUNICODE_STRING )&DomainInfo->Name,
                         ( PSID )DomainInfo->Sid,
                         &ForestTrustInfo,
                         FALSE
                         );

            LsapFreeForestTrustInfo( &ForestTrustInfo );
        }
    }

    if ( NT_SUCCESS( Status ) ) {

        TrustListEntry->TrustInfoEx.TrustAttributes = DomainInfo->TrustAttributes;
        TrustListEntry->TrustInfoEx.TrustDirection = DomainInfo->TrustDirection;
        TrustListEntry->TrustInfoEx.TrustType = DomainInfo->TrustType;
        TrustListEntry->PosixOffset = PosixOffset;

        //
        // Construct the TRUST_INFO that most of the lookup routines return
        //
        TrustListEntry->ConstructedTrustInfo.Sid = TrustListEntry->TrustInfoEx.Sid;
        RtlCopyMemory( &TrustListEntry->ConstructedTrustInfo.Name,
                       &TrustListEntry->TrustInfoEx.FlatName,
                       sizeof( UNICODE_STRING ) );

    } else {

        //
        // Something failed... clean up
        //

        MIDL_user_free( TrustListEntry->TrustInfoEx.Sid );
        MIDL_user_free( TrustListEntry->TrustInfoEx.Name.Buffer );
        MIDL_user_free( TrustListEntry->TrustInfoEx.FlatName.Buffer );

        RtlZeroMemory(TrustListEntry,sizeof(LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY));
    }

    return( Status );
}

NTSTATUS
LsapDbReconcileDuplicateTrusts(
    IN PUNICODE_STRING   Name,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *WinningEntry
    )
/*++

  Routine Description

    This function searches the DS for the occurance of any duplicates
    and using appropriate criteria chooses a winner. The object guid
    of the winner is stamped on the winning entry

  Arguments:

    ExistingEntry
    NewEntry

  Return Values

    STATUS_SUCCESS
    Other error codes to indicate resource failures

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRVAL SearchAttrVal;
    ATTR   AttrToMatch = {ATT_TRUST_PARTNER, {1,&SearchAttrVal}};
    DSNAME *WinningObject = NULL;
    WCHAR szRDN[MAX_RDN_SIZE+1];
    ULONG Rdnlength = MAX_RDN_SIZE;
    ATTRTYP RDNtype;
    ULONG i,j;
    BOOLEAN CloseTransaction = FALSE;
    BOOLEAN ActiveThreadState = FALSE;
    PDSNAME  * FoundNames = NULL;
    ULONG   cFoundNames=0;


    //
    // Duplicates can occur legally in DS mode only
    //


    *WinningEntry = NULL;

    if (!LsaDsStateInfo.UseDs)
    {
        ASSERT(FALSE && "Duplicate Trust in Registry Mode");
        return(STATUS_SUCCESS);
    }

    //
    // At this point we cannot say whether we are in a transaction
    // therefore handle both cases
    //



    if (!SampExistsDsTransaction())
    {
        //
        // Begin a Transaction
        //

        Status = LsapDsInitAllocAsNeededEx(
                        LSAP_DB_NO_LOCK,
                        TrustedDomainObject,
                        &CloseTransaction
                        );

        if (!NT_SUCCESS(Status))
            goto Error;

        ActiveThreadState = TRUE;
    }


    SearchAttrVal.valLen = Name->Length;
    SearchAttrVal.pVal = (PVOID) Name->Buffer;

    Status = LsapDsSearchNonUnique(
                0,
                LsaDsStateInfo.DsSystemContainer,
                &AttrToMatch,
                1, // num attrs to match
                &FoundNames,
                &cFoundNames
                );

    if(!NT_SUCCESS(Status))
    {
        goto Error;
    }

    for (i=0;i<cFoundNames;i++)
    {


        //
        // Get the RDN
        //

        if (0!=GetRDNInfoExternal(
                    FoundNames[i],
                    szRDN,
                    &Rdnlength,
                    &RDNtype
                    ))
        {
            Status = STATUS_OBJECT_NAME_INVALID;
            goto Error;
        }


        //
        // Test if mangled
        //

        if (!IsMangledRDNExternal(szRDN,Rdnlength,NULL))
        {
            WinningObject = FoundNames[i];
            break;
        }
    }


    if (NULL!=WinningObject)
    {
         ATTRBLOCK Read, Results;
         UNICODE_STRING FlatName;
         ULONG TrustType = 0,TrustDirection=0,TrustAttributes = 0;
         ULONG ForestTrustLength = 0;
         PBYTE ForestTrustInfo = NULL;
         ULONG PosixOffset = 0;
         PSID TrustedDomainSid = NULL;
         LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 NewTrustInfo;

        //
        // Winning object can legally be null here as the above logic is not necessarily in
        // the same transaction
        //

        RtlZeroMemory(&FlatName,sizeof(UNICODE_STRING));
        RtlZeroMemory(&NewTrustInfo, sizeof(NewTrustInfo));


        Read.attrCount = LsapDsTrustedDomainFixupAttributeCount;
        Read.pAttr = LsapDsTrustedDomainFixupAttributes;
        Status = LsapDsReadByDsName( WinningObject,
                                 0,
                                 &Read,
                                 &Results );


        if (!NT_SUCCESS(Status))
        {
            goto Error;
        }

        //
        // Walk the results
        //

         for ( j = 0; j < Results.attrCount; j++ ) {

            switch ( Results.pAttr[ j ].attrTyp ) {

                case ATT_TRUST_TYPE:

                        TrustType = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[ j ] );
                        break;

                case ATT_TRUST_DIRECTION:

                        TrustDirection = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[ j ] );
                        break;

                case ATT_TRUST_ATTRIBUTES:

                        TrustAttributes = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[ j ] );
                        break;

                case ATT_TRUST_POSIX_OFFSET:
                    PosixOffset = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[j] );
                    break;

                case ATT_FLAT_NAME:

                        FlatName.Length = ( USHORT) LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results.pAttr[ j ] );
                        FlatName.MaximumLength =  FlatName.Length;
                        FlatName.Buffer =  LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR( &Results.pAttr[ j ] );
                        break;

                case ATT_SECURITY_IDENTIFIER:

                        TrustedDomainSid = (PSID)LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR(&Results.pAttr[j]);
                        break;

                case ATT_MS_DS_TRUST_FOREST_TRUST_INFO:

                        ForestTrustLength = ( ULONG )LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results.pAttr[ j ] );
                        ForestTrustInfo = LSAP_DS_GET_DS_ATTRIBUTE_AS_PBYTE( &Results.pAttr[ j ] );
                        break;
            }
        }


        RtlCopyMemory(&NewTrustInfo.Name,Name, sizeof(UNICODE_STRING));

        RtlCopyMemory(&NewTrustInfo.FlatName,&FlatName,sizeof(UNICODE_STRING));

        NewTrustInfo.Sid = TrustedDomainSid;
        NewTrustInfo.TrustType = TrustType;
        NewTrustInfo.TrustDirection = TrustDirection;
        NewTrustInfo.TrustAttributes = TrustAttributes;
        NewTrustInfo.ForestTrustLength = ForestTrustLength;
        NewTrustInfo.ForestTrustInfo = ForestTrustInfo;

        *WinningEntry = MIDL_user_allocate( sizeof( LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY ) );

        if ( *WinningEntry == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlZeroMemory(*WinningEntry,sizeof( LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY));

        Status = LsapDbInitializeTrustedDomainListEntry( *WinningEntry,
                                                         &NewTrustInfo,
                                                         PosixOffset );

        if (!NT_SUCCESS(Status))
        {
            goto Error;
        }


        //
        // Set the GUID on the object
        //

        RtlCopyMemory(&(*WinningEntry)->ObjectGuidInDs,&WinningObject->Guid,sizeof(GUID));

    }
    else
    {
        //
        // Its O.K to find no entry for the name
        //

        Status = STATUS_SUCCESS;
    }

Error:

    if (ActiveThreadState)
    {

        LsapDsDeleteAllocAsNeededEx2(
            LSAP_DB_NO_LOCK,
            TrustedDomainObject,
            CloseTransaction,
            FALSE // rollback transaction
            );

        ASSERT(!SampExistsDsTransaction());


    }

    if (!NT_SUCCESS(Status))
    {
        if (NULL!=*WinningEntry)
        {
             _fgu__LSAPR_TRUSTED_DOMAIN_INFO (
                              ( PLSAPR_TRUSTED_DOMAIN_INFO )&(*WinningEntry)->TrustInfoEx,
                               TrustedDomainInformationEx
                               );

            MIDL_user_free( *WinningEntry );
            *WinningEntry = NULL;
        }
    }

    if(NULL!=FoundNames)
    {
        //
        // Search non unique allocates only one big chunk,
        // so no need to free individual members
        //

        LsapFreeLsaHeap(FoundNames);
    }

    return(Status);
}



NTSTATUS
LsapDbInsertTrustedDomainList(
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 DomainInfo,
    IN ULONG PosixOffset
    )
/*++

Routine Description:

    This function inserts a Trusted Domain in the Trusted Domain List.
    It is called when a Trusted Domain object is created in the Lsa
    Policy Database.  The List will not be altered while it is active.

Arguments:

    DomainInfo - Points to a LSAPR_TRUSTED_DOMAIN_INFORMATION_EX
        structure which contains information on the trusted domain.

    ObjectGuidInDs - Indicates the ObjectGuid in the DS.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY NewEntry = NULL;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY ExistingEntry = NULL;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY EntryToFree = NULL;

    //
    // If we are actually upgrading from NT4, do not touch any in memory structures
    //

    if ( LsaDsStateInfo.Nt4UpgradeInProgress ) {

        return STATUS_SUCCESS;
    }

    if ( DomainInfo == NULL ) {

        return STATUS_SUCCESS;
    }

    ASSERT( LsapDbIsLockedTrustedDomainList());

    //
    // If the Trusted Domain List is not valid, attempt to rebuild the cache
    // One exception: the cache is being built just now, then no need to rebuild
    //

    if ( !LsapDbIsValidTrustedDomainList()) {

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto InsertTrustedDomainListError;
        }
    }

    //
    // Check for Duplicates. Duplicates can legally occur in a multi master system
    //

    Status = LsapDbLookupNameTrustedDomainListEx(
                 &DomainInfo->Name,
                 &ExistingEntry
                 );

    if ( STATUS_NO_SUCH_DOMAIN == Status ) {

        //
        // Good ! There are no duplicates. Simply insert into the list
        //

        //
        // The Trusted Domain List is referenced by us, but otherwise inactive
        // so we can update it.  Create a new Trusted Domain List section for
        // all of the Trusted Domains to be added to the list.
        //

        NewEntry = MIDL_user_allocate( sizeof( LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY ));

        if ( NewEntry == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto InsertTrustedDomainListError;
        }

        Status = LsapDbInitializeTrustedDomainListEntry(
                     NewEntry,
                     DomainInfo,
                     PosixOffset
                     );

        if ( Status == STATUS_INVALID_PARAMETER ) {

            SpmpReportEventU(
                EVENTLOG_ERROR_TYPE,
                LSA_TRUST_INSERT_ERROR,
                0,
                sizeof( ULONG ),
                &Status,
                1,
                &NewEntry->TrustInfoEx.Name
                );

            _fgu__LSAPR_TRUSTED_DOMAIN_INFO (
                ( PLSAPR_TRUSTED_DOMAIN_INFO )&NewEntry->TrustInfoEx,
                TrustedDomainInformationEx
                );

            MIDL_user_free( NewEntry );

            NewEntry = NULL;

        } else if ( !NT_SUCCESS( Status )) {

            EntryToFree = NewEntry;
            goto InsertTrustedDomainListError;

        } else {

            //
            // Remember a sequence number for this trusted domain
            //

            LsapDbTrustedDomainList.TrustedDomainCount++;
            LsapDbTrustedDomainList.CurrentSequenceNumber++;
            NewEntry->SequenceNumber = LsapDbTrustedDomainList.CurrentSequenceNumber;

            InsertTailList(
                &LsapDbTrustedDomainList.ListHead,
                &NewEntry->NextEntry
                );
        }

        Status = STATUS_SUCCESS;

    } else if ( STATUS_SUCCESS == Status ) {

        PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY WinningEntry = NULL;

        //
        // We found an entry already in the trusted domain list
        // we now need to reconcile and make only one of the 2 entries win.
        // Our reconciliation logic is very simple

        //
        // 1. We handle only duplicates via name.
        // 2. We assume that both duplicates are identical in terms of domain
        //    SID, trust type, trust attributes etc. This covers us for the case
        //    where a duplicate has been created inverdantly by an admin who ended
        //    up creating the same trust on different DC's
        //


        Status = LsapDbReconcileDuplicateTrusts(
                     ( PUNICODE_STRING )&DomainInfo->Name,
                     &WinningEntry
                     );

         if ( !NT_SUCCESS( Status )) {

             goto InsertTrustedDomainListError;
         }

         RemoveEntryList( &ExistingEntry->NextEntry );
         LsapDbTrustedDomainList.TrustedDomainCount--;
         EntryToFree = ExistingEntry;

         if ( NULL != WinningEntry ) {

            //
            // It is legal to expect WinningEntry to be NULL, this
            // can occur if out of band all duplicates were deleted
            //

            //
            // Remember a sequence number for this trusted domain
            //

            LsapDbTrustedDomainList.TrustedDomainCount++;
            LsapDbTrustedDomainList.CurrentSequenceNumber++;
            WinningEntry->SequenceNumber = LsapDbTrustedDomainList.CurrentSequenceNumber;

            InsertTailList(
                &LsapDbTrustedDomainList.ListHead,
                &WinningEntry->NextEntry
                );
         }
    }

InsertTrustedDomainListFinish:

    if ( NULL != EntryToFree ) {

        NTSTATUS Ignore;

        //
        // We will remove the entry from the cache iff we are in the root domain. If not,
        //  we don't want to touch the FT Cache.
        //
        if( LsapDbDcInRootDomain() ) {

            Ignore = LsapForestTrustCacheRemove(( UNICODE_STRING * )&EntryToFree->TrustInfoEx.Name );

            ASSERT( Ignore == STATUS_SUCCESS ||
                    Ignore == STATUS_NOT_FOUND );
        }

        _fgu__LSAPR_TRUSTED_DOMAIN_INFO (
            ( PLSAPR_TRUSTED_DOMAIN_INFO )&EntryToFree->TrustInfoEx,
            TrustedDomainInformationEx
            );

        MIDL_user_free( EntryToFree );
    }

    return Status;

InsertTrustedDomainListError:

    LsapDbMakeCacheInvalid( TrustedDomainObject );
    goto InsertTrustedDomainListFinish;
}


NTSTATUS
LsapDbDeleteTrustedDomainList(
    IN PLSAPR_TRUST_INFORMATION TrustInformation
    )

/*++

Routine Description:

    This function deletes a Trusted Domain from the Trusted Domain List
    if that list is marked as valid.  The Trusted Domain List will not
    be altered while there are Lookup operations pending.

Arguments:

    TrustInformation - Points to the Sid and Name of a Trusted Domain.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS Ignore;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;

    ASSERT( LsapDbIsLockedTrustedDomainList());

    //
    // If the Trusted Domain List is not valid, quit and do nothing.
    //

    if (!LsapDbIsValidTrustedDomainList()) {

        goto DeleteTrustedDomainListFinish;
    }

    //
    // The Trusted Domain List is referenced by us, but otherwise inactive.
    // Update the List.  First, we need to locate the entry to be deleted.
    //

    Status = LsapDbLookupEntryTrustedDomainList(
                 TrustInformation,
                 &TrustEntry );

    if (!NT_SUCCESS(Status)) {

        goto DeleteTrustedDomainListError;
    }

    RemoveEntryList( &TrustEntry->NextEntry );
    LsapDbTrustedDomainList.TrustedDomainCount--;

    //
    // We will remove the entry from the cache iff we are in the root domain. If not,
    //  we don't want to touch the FT Cache.
    //
    if( LsapDbDcInRootDomain() ) {

        Ignore = LsapForestTrustCacheRemove(( UNICODE_STRING * )&TrustEntry->TrustInfoEx.Name );

        ASSERT( Ignore == STATUS_SUCCESS ||
                Ignore == STATUS_NOT_FOUND );
    }

    _fgu__LSAPR_TRUSTED_DOMAIN_INFO ( ( PLSAPR_TRUSTED_DOMAIN_INFO )&TrustEntry->TrustInfoEx,
                                      TrustedDomainInformationEx );

    MIDL_user_free( TrustEntry );

DeleteTrustedDomainListFinish:

    return(Status);

DeleteTrustedDomainListError:

    LsapDbMakeCacheInvalid( TrustedDomainObject );
    goto DeleteTrustedDomainListFinish;
}



NTSTATUS
LsapDbFixupTrustedDomainListEntry(
    IN OPTIONAL PSID TrustedDomainSid,
    IN OPTIONAL PLSAPR_UNICODE_STRING Name,
    IN OPTIONAL PLSAPR_UNICODE_STRING FlatName,
    IN OPTIONAL PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 NewTrustInfo,
    IN OPTIONAL PULONG PosixOffset
    )
/*++

Routine Description:

    This function will update the information in the trusted domain list that
    corresponds to the given trust item.  This is mostly useful for SetTrustedDomainInformation
    calls

Arguments:

    TrustedDomainSid - If specified, is used to identify which TDL entry to update.
        In not specified, NewTrustInfo is used.

    NewTrustInfo - Points to the full information regarding the trusted domain
        If specified, TDL entry is updated to reflect this information.

    PosixOffset - Points to the Posix Offset to set on the entry
        If not specified, the Posix Offset will not be changed.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry = NULL;
    LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TempTrustEntry;
    BOOLEAN AcquiredListWriteLock = FALSE;
    LSAPR_TRUST_INFORMATION TrustInformation;

    //
    // If we are upgrading from NT4, then do nothing
    //

    if  (LsaDsStateInfo.Nt4UpgradeInProgress)
    {
        return ( STATUS_SUCCESS);
    }

    //
    // Acquire exclusive write lock for the Trusted Domain List.
    //

    Status = LsapDbAcquireWriteLockTrustedDomainList();

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    //
    // If the Trusted Domain List is not marked
    // as a valid cache, do nothing.
    //

    if (!LsapDbIsCacheValid(TrustedDomainObject)) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // If the Trusted Domain List is not valid, quit and do nothing.
    //

    if (!LsapDbIsValidTrustedDomainList()) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Find the TDL entry using trusted domain sid.
    //

    if ( TrustedDomainSid != NULL || Name != NULL || FlatName != NULL ) {

        RtlZeroMemory( &TrustInformation, sizeof( TrustInformation ));

        TrustInformation.Sid = TrustedDomainSid;

        if ( Name != NULL ) {

            TrustInformation.Name = *Name;
        }

        Status = LsapDbLookupEntryTrustedDomainList( &TrustInformation,
                                                     &TrustEntry );

        if ( Status == STATUS_NO_SUCH_DOMAIN &&
             FlatName != NULL ) {

            TrustInformation.Name = *FlatName;

            Status = LsapDbLookupEntryTrustedDomainList( &TrustInformation,
                                                         &TrustEntry );
        }

        if ( !NT_SUCCESS( Status )) {

            goto Cleanup;
        }

    } else {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ASSERT( TrustEntry );

    //
    // If new trust info is to be updated,
    //  update it.
    //

    if ( NewTrustInfo != NULL ) {

        UNICODE_STRING * RemovingFtInfo = NULL;

        if ( NewTrustInfo->ForestTrustInfo == NULL ) {

            //
            // We will remove the entry from the cache iff we are in the root domain. If not,
            //  we don't want to touch the FT Cache.
            //
            if( LsapDbDcInRootDomain() ) {

                RemovingFtInfo = ( UNICODE_STRING * )&TrustEntry->TrustInfoEx.Name;
            }
        }

        //
        // Use a temp variable for the entry (so if we fail to initialize it,
        // we won't have trashed our current data)
        //

        Status = LsapDbInitializeTrustedDomainListEntry( &TempTrustEntry,
                                                         NewTrustInfo,
                                                         0 );   // Ignore Posix Offset

        if ( NT_SUCCESS( Status ) ) {

            if ( RemovingFtInfo ) {

                NTSTATUS Ignore;

                Ignore = LsapForestTrustCacheRemove( RemovingFtInfo );

                ASSERT( Ignore == STATUS_SUCCESS ||
                        Ignore == STATUS_NOT_FOUND );
            }

            //
            // Delete the contents of the current item...
            //

            _fgu__LSAPR_TRUSTED_DOMAIN_INFO ( ( PLSAPR_TRUSTED_DOMAIN_INFO )&TrustEntry->TrustInfoEx,
                                              TrustedDomainInformationEx );
            //
            // Copy in the fields that need updating
            //

            RtlCopyMemory( &TrustEntry->TrustInfoEx, &TempTrustEntry.TrustInfoEx, sizeof(LSAPR_TRUSTED_DOMAIN_INFORMATION_EX) );
            RtlCopyMemory(&TrustEntry->ConstructedTrustInfo, &TempTrustEntry.ConstructedTrustInfo,sizeof(LSAPR_TRUST_INFORMATION));
        }
    }

    //
    // If Posix offset is to be updated,
    //  update it.
    //

    if ( PosixOffset != NULL ) {
        TrustEntry->PosixOffset = *PosixOffset;
    }


Cleanup:

    if( !NT_SUCCESS( Status ) ) {

        LsapDbMakeCacheInvalid( TrustedDomainObject );
    }

    LsapDbReleaseLockTrustedDomainList();

    return(Status);

}



NTSTATUS
LsapDbTraverseTrustedDomainList(
    IN OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainEntry,
    OUT OPTIONAL PLSAPR_TRUST_INFORMATION *TrustInformation
    )

/*++

Routine Description:

    This function is used to traverse the Trusted Domain List.  Each call
    yields a pointer to the Trust Information for the next Trusted Domain
    on the list.

Arguments:

    TrustedDomainEntry - A pointer to the relevant trusted domain entry.  Prior to the
        first call to the routine, this location must be initialized to
        NULL.

    TrustInformation - If specified, receives a pointer to the Trust
        Information for the next Trusted Domain, or NULL if there are no more.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - This is returned when the final entry is being
            returned.

        STATUS_MORE_ENTRIES - There are more entries in the list, so call
            again.

        STATUS_NO_MORE_ENTRIES - There are no more entries after the
            one returned.

        STATUS_INVALID_PARAMETER -- An invalid TrustedDomainEntry pointer was given

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry = NULL;

    ASSERT( TrustedDomainEntry );

    if ( TrustedDomainEntry == NULL ) {

        return( STATUS_INVALID_PARAMETER );
    }

    ASSERT( LsapDbIsLockedTrustedDomainList());

    //
    // If there is a present section selected, examine it.
    //
    if ( *TrustedDomainEntry == NULL ) {

        //
        // Handle the empty list case first...
        //
        if ( IsListEmpty( &LsapDbTrustedDomainList.ListHead ) ) {

            Status = STATUS_NO_MORE_ENTRIES;

            TrustEntry = NULL;

        } else {

            TrustEntry = CONTAINING_RECORD( LsapDbTrustedDomainList.ListHead.Flink,
                                            LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, NextEntry );
            ASSERT( TrustEntry );
        }

    } else {

        TrustEntry = *TrustedDomainEntry;

        if ( TrustEntry->NextEntry.Flink == &LsapDbTrustedDomainList.ListHead ) {

            Status = STATUS_NO_MORE_ENTRIES;

            TrustEntry = NULL;

        } else {

            TrustEntry = CONTAINING_RECORD( TrustEntry->NextEntry.Flink,
                                            LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, NextEntry );
            ASSERT( TrustEntry );

        }
    }

    //
    // Set our return status
    //
    if ( Status == STATUS_SUCCESS ) {

        ASSERT( TrustEntry );
        if ( TrustEntry->NextEntry.Flink == &LsapDbTrustedDomainList.ListHead ) {

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_MORE_ENTRIES;
        }
    }

    //
    // Return the trust information
    //
    if ( TrustEntry != NULL && TrustInformation != NULL ) {

        *TrustInformation = &TrustEntry->ConstructedTrustInfo;
    }

    *TrustedDomainEntry = TrustEntry;


    return(Status);

}


NTSTATUS
LsapDbEnumerateTrustedDomainList(
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG InfoLevel,
    IN BOOLEAN AllowNullSids
    )

/*++

Routine Description:

    This function enumerates zero or more Trusted Domains on the
    Trusted Domain List.  Since there may be more information than can be
    returned in a single call of the routine, multiple calls can be made to
    get all of the information.  To support this feature, the caller is
    provided with a handle that can be used across calls to the API.  On the
    initial call, EnumerationContext should point to a variable that has
    been initialized to 0.

Arguments:

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    EnumerationBuffer - Pointer to an enumeration structure that will receive
        a count of the Trusted Domains enumerated on this call and a pointer to
        an array of entries containing information for each enumerated
        Trusted Domain.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.



Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_MORE_ENTRIES - The call completed successfully.  There
            are more entries so call again.  This is a success status.

        STATUS_NO_MORE_ENTRIES - No entries have been returned because there
            are no more entries in the list.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, EnumerationStatus = STATUS_SUCCESS;
    NTSTATUS InitialEnumerationStatus = STATUS_SUCCESS;
    ULONG LengthEnumeratedInfo = 0;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustedDomainEntry;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY StartingEntry;
    BOOLEAN AcquiredTrustedDomainListReadLock = FALSE;
    ULONG EntriesRead, DomainTrustInfoLength, ValidEntries, ValidInserted;
    PLSAPR_TRUST_INFORMATION TrustInformation = NULL;
    PLSAPR_TRUST_INFORMATION StartingTrustInformation = NULL;
    PLSAPR_TRUST_INFORMATION DomainTrustInfo = NULL;
    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX   DomainTrustInfoEx = NULL;

    LsapEnterFunc( "LsapDbEnumerateTrustedDomainList" );

    EntriesRead = 0;
    ValidEntries = 0;

    //
    // Always allow us to return at least one object.
    //
    if ( PreferedMaximumLength == 0 ) {
        PreferedMaximumLength = 1;
    }

    //
    // Acquire the Read Lock for the Trusted Domain List
    //

    Status = LsapDbAcquireReadLockTrustedDomainList();

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto EnumerateTrustedDomainListError;
        }
    }

    //
    // Find the starting point using the Enumeration Context Variable.
    // This variable specifies an unsigned integer, which is the
    // number of the entry in the list at which to begin the enumeration.
    //

    Status = LsapDbLocateEntryNumberTrustedDomainList(
                 *EnumerationContext,
                 &StartingEntry,
                 &StartingTrustInformation
                 );

    if (!NT_SUCCESS(Status)) {

        goto EnumerateTrustedDomainListError;
    }

    InitialEnumerationStatus = Status;

    //
    // Now scan the Trusted Domain List to calculate how many
    // entries we can return and the length of the buffer required.
    // We use the PreferedMaximumLength value as a guide by accumulating
    // the actual length of Trust Information structures and their
    // contents until we either reach the end of the Trusted Domain List
    // or until we first exceed the PreferedMaximumLength value.  Thus,
    // the amount of information returned typically exceeds the
    // PreferedmaximumLength value by a smail amount, namely the
    // size of the Trust Information for a single domain.
    //
    TrustedDomainEntry = StartingEntry;
    TrustInformation = StartingTrustInformation;

    EnumerationStatus = InitialEnumerationStatus;

    for (;;) {

        //
        // Add in the length of the data to be returned for this
        // Domain's Trust Information.  We count the length of the
        // Trust Information structure plus the length of the unicode
        // Domain Name and Sid within it.
        //
        if ( InfoLevel == TrustedDomainInformationEx ) {

            if ( TrustedDomainEntry->TrustInfoEx.Sid ) {

                LengthEnumeratedInfo += sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) +
                                      RtlLengthSid(( PSID )TrustedDomainEntry->TrustInfoEx.Sid ) +
                                      TrustedDomainEntry->TrustInfoEx.Name.MaximumLength +
                                      TrustedDomainEntry->TrustInfoEx.FlatName.MaximumLength;

                ValidEntries++;

            } else if ( AllowNullSids ) {

                LengthEnumeratedInfo += sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) +
                                      TrustedDomainEntry->TrustInfoEx.Name.MaximumLength +
                                      TrustedDomainEntry->TrustInfoEx.FlatName.MaximumLength;

                ValidEntries++;
            }

        } else {

            //
            // If it's an incoming only trust, don't return it...
            //
            if ( FLAG_ON( TrustedDomainEntry->TrustInfoEx.TrustDirection,
                          TRUST_DIRECTION_OUTBOUND ) &&
                 NULL != TrustInformation->Sid ) {

                LengthEnumeratedInfo += sizeof(LSA_TRUST_INFORMATION) +
                                            RtlLengthSid(( PSID )TrustInformation->Sid ) +
                                            TrustInformation->Name.MaximumLength;

                ValidEntries++;
            }
        }

        EntriesRead++;

        //
        // If we've returned all of the entries the caller wants,
        //  quit.
        //

        if (LengthEnumeratedInfo >= PreferedMaximumLength) {

            break;
        }

        //
        // If there are no more entries to enumerate, quit.
        //

        if (EnumerationStatus != STATUS_MORE_ENTRIES) {

            break;
        }


        //
        // Point at the next entry in the Trusted Domain List
        //

        Status = LsapDbTraverseTrustedDomainList(
                     &TrustedDomainEntry,
                     &TrustInformation
                     );

        EnumerationStatus = Status;

        if (!NT_SUCCESS(Status)) {
            goto EnumerateTrustedDomainListError;
        }

    }


    //
    // Allocate memory for the array of TrustInformation entries to be
    // returned.
    //

    if ( InfoLevel == TrustedDomainInformationEx ) {

        DomainTrustInfoLength = ValidEntries * sizeof(LSAPR_TRUSTED_DOMAIN_INFORMATION_EX);

    } else {

        DomainTrustInfoLength = ValidEntries * sizeof(LSA_TRUST_INFORMATION);

    }

    //
    // Now construct the information to be returned to the caller.  We
    // first need to allocate an array of structures of type
    // LSA_TRUST_INFORMATION each entry of which will be filled in with
    // the Sid of the domain and its Unicode Name.
    //

    DomainTrustInfo = (( DomainTrustInfoLength > 0 ) ? MIDL_user_allocate( DomainTrustInfoLength ) : 0);

    if ( DomainTrustInfo == NULL && DomainTrustInfoLength > 0 ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto EnumerateTrustedDomainListError;

    } else if ( DomainTrustInfo != NULL ) {

        RtlZeroMemory ( DomainTrustInfo, DomainTrustInfoLength );
    }

    DomainTrustInfoEx = ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )DomainTrustInfo;

    //
    // Now read through the Trusted Domains again to copy the output
    // information.
    //

    TrustedDomainEntry = StartingEntry;
    TrustInformation = StartingTrustInformation;

    EnumerationStatus = InitialEnumerationStatus;
    ValidInserted = 0;

    for (;;) {

        //
        // Copy in the Trust Information.
        //

        if ( InfoLevel == TrustedDomainInformationEx ) {

            if ( TrustedDomainEntry->TrustInfoEx.Sid || AllowNullSids ) {

                if (ValidInserted == ValidEntries) {

                    //
                    // We'd like to return more, but it won't fit
                    //

                    EnumerationStatus = STATUS_MORE_ENTRIES;
                    break;

                } else {

                    Status = LsapRpcCopyTrustInformationEx(
                                 NULL,
                             ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )&DomainTrustInfoEx[ ValidInserted ],
                                 &TrustedDomainEntry->TrustInfoEx );

                    if (!NT_SUCCESS(Status)) {
                        goto EnumerateTrustedDomainListError;
                    }

                    ValidInserted++;
                    *EnumerationContext = TrustedDomainEntry->SequenceNumber;
                }
            }

        } else {

            //
            // If it's an incoming only trust, don't return it...
            //
            if ( FLAG_ON( TrustedDomainEntry->TrustInfoEx.TrustDirection,
                          TRUST_DIRECTION_OUTBOUND ) &&
                 NULL != TrustInformation->Sid ) {

                if (ValidInserted == ValidEntries) {

                    //
                    // We'd like to return more, but it won't fit
                    //

                    EnumerationStatus = STATUS_MORE_ENTRIES;
                    break;

                } else {

                    Status = LsapRpcCopyTrustInformation( NULL,
                                                          &DomainTrustInfo[ ValidInserted ],
                                                          TrustInformation );

                    if (!NT_SUCCESS(Status)) {
                        goto EnumerateTrustedDomainListError;
                    }

                    ValidInserted++;
                    *EnumerationContext = TrustedDomainEntry->SequenceNumber;
                }
            }
        }

        //
        // If there are no more entries to enumerate, quit.
        //

        if (EnumerationStatus != STATUS_MORE_ENTRIES) {
            break;
        }

        //
        // Point at the next entry in the Trusted Domain List
        //
        Status = LsapDbTraverseTrustedDomainList(
                     &TrustedDomainEntry,
                     &TrustInformation );

        EnumerationStatus = Status;

        if (!NT_SUCCESS(Status)) {
            goto EnumerateTrustedDomainListError;
        }

    }

    //
    // Make sure that we are actually returning something...
    //
    if ( EntriesRead == 0 || ValidEntries == 0 ) {

        Status = STATUS_NO_MORE_ENTRIES;
        goto EnumerateTrustedDomainListError;

    } else {

        Status = EnumerationStatus;

    }

EnumerateTrustedDomainListFinish:

    LsapDbReleaseLockTrustedDomainList();

    //
    // Fill in returned Enumeration Structure, returning 0 or NULL for
    // fields in the error case.
    //

    EnumerationBuffer->Information = (PLSAPR_TRUST_INFORMATION) DomainTrustInfo;
    EnumerationBuffer->EntriesRead = ValidEntries;

    LsapExitFunc( "LsapDbEnumerateTrustedDomainList", Status );

    return(Status);

EnumerateTrustedDomainListError:

    //
    // If necessary, free the DomainTrustInfo array and all of its entries.
    //

    if (DomainTrustInfo != NULL) {


        if ( InfoLevel == TrustedDomainInformationEx ) {

            LSAPR_TRUSTED_ENUM_BUFFER_EX FreeEnum;

            FreeEnum.EnumerationBuffer = ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )DomainTrustInfo;
            FreeEnum.EntriesRead = ValidEntries;

            LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER_EX ( &FreeEnum );

        } else {

            LSAPR_TRUSTED_ENUM_BUFFER FreeEnum;

            FreeEnum.Information = ( PLSAPR_TRUST_INFORMATION )DomainTrustInfo;
            FreeEnum.EntriesRead = ValidEntries;

            LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER ( &FreeEnum );

        }

        DomainTrustInfo = NULL;
        EntriesRead = (ULONG) 0;
    }

    goto EnumerateTrustedDomainListFinish;
}


NTSTATUS
LsapDbLocateEntryNumberTrustedDomainList(
    IN ULONG EntryNumber,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainEntry,
    OUT PLSAPR_TRUST_INFORMATION *TrustInformation
    )

/*++

Routine Description:

    Given an Entry Number n, this function obtains the pointer to the nth
    entry (if any) in a Trusted Domain List.  The first entry in the
    list is entry number 0.

    Given an Entry Number n, this function obtains a pointer to the
        first entry with a sequence number greater than n.
        0: returns the first entry.

    WARNING:  The caller of this function must hold a lock for the
        Trusted Domain List.  The valditiy of the returned pointers
        is guaranteed only while that lock is held.

Arguments:

    EntryNumber - Specifies the sequence number. The returned entry will
        be the first entry with a sequence number greater than this.
        0: returns the first entry.

    TrustedDomainEntry - Receives a pointer to the Trusted
        Domain entry.  If no such entry exists, NULL is returned.

    TrustInformation - Receives a pointer to the Trust
        Information for the entry being returned.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - Call completed successfully and there are no
            entries beyond the entry returned.

        STATUS_MORE_ENTRIES - Call completed successfully and there are
            more entries beyond the entry returned.

        STATUS_NO_MORE_ENTRIES - There is no entry to return.
--*/

{
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY Current = NULL;

    //
    // Initialization
    //

    *TrustInformation = NULL;
    *TrustedDomainEntry = NULL;

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            return Status;
        }
    }

    //
    // Find the first entry with a sequence number greater than the
    //  specified number.
    //

    for ( ListEntry = LsapDbTrustedDomainList.ListHead.Flink;
          ListEntry != &LsapDbTrustedDomainList.ListHead;
          ListEntry = ListEntry->Flink ) {

        Current = CONTAINING_RECORD( ListEntry, LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, NextEntry );

        //
        // See if we have the entry we require
        //
        if ( EntryNumber < Current->SequenceNumber ) {

            if ( ListEntry->Flink != &LsapDbTrustedDomainList.ListHead ) {
                Status = STATUS_MORE_ENTRIES;
            } else {
                Status = STATUS_SUCCESS;
            }

            *TrustInformation = &Current->ConstructedTrustInfo;
            *TrustedDomainEntry  = Current;

            return Status;
        }
    }

    //
    // If no entry was found,
    //  return an error to the caller.
    //

    return STATUS_NO_MORE_ENTRIES;

}

BYTE LdapSwapBitTable[256] = {
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

ULONG
LdapSwapBits(
    ULONG Bits
)
/*++

Routine Description:

    Swaps the bits of a ULONG end to end.

    That is, the LSB becomes the MSB, etc.

Arguments:

    Bits - bits to swap

Return Value:

    ULONG with bits swapped.

--*/
{
    ULONG ReturnBits = 0;
    LPBYTE BitPtr = (LPBYTE)&Bits;

    return (LdapSwapBitTable[BitPtr[3]] << 0) |
           (LdapSwapBitTable[BitPtr[2]] << 8) |
           (LdapSwapBitTable[BitPtr[1]] << 16) |
           (LdapSwapBitTable[BitPtr[0]] << 24);


}



ULONG
__cdecl
CompareUlongs(
    const void * Param1,
    const void * Param2
    )

/*++

Routine Description:

    Qsort comparison routine for sorting ULONGs

--*/
{
    return *((PULONG)Param1) - *((PULONG)Param2);
}



NTSTATUS
LsapDbAllocatePosixOffsetTrustedDomainList(
    OUT PULONG PosixOffset
    )

/*++

Routine Description:

    This function return the next available PosixOffset based on the
    current Posix Offsets in the trusted domain list.

    Posix offsets are allocated on the PDC.  Each outbound trust has one.  A TDO
    is given a Posix Offset as it becomes an outbound trust.  If that happens on a
    BDC, the TDO is given a Posix Offset when the TDO is replicated to the PDC.

    This routine must be entered with the trusted domain list write locked.

Arguments:

    PosixOffset - On STATUS_SUCCESS, returns the next available Posix Offset

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status;

    PULONG SwappedPosixOffsets = NULL;
    ULONG SwappedPosixOffsetCount;
    ULONG TargetSwappedPosixOffset;

    PLIST_ENTRY ListEntry;
    ULONG i;

    //
    // If the Trusted Domain List is not valid, rebuild it before continuing
    //

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto Cleanup;
        }
    }

    //
    // Build an array of all the existing Posix Offsets.
    //

    SwappedPosixOffsets = LsapAllocateLsaHeap( LsapDbTrustedDomainList.TrustedDomainCount * sizeof(ULONG) );

    if ( SwappedPosixOffsets == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Walk the list filling in the array.
    //

    SwappedPosixOffsetCount = 0;

    for ( ListEntry = LsapDbTrustedDomainList.ListHead.Flink;
          ListEntry != &LsapDbTrustedDomainList.ListHead;
          ListEntry = ListEntry->Flink ) {

        PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY Current;

        Current = CONTAINING_RECORD( ListEntry, LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, NextEntry );

        //
        // Only grab the Posix Offset from those TDOs that need one.
        //
        if ( LsapNeedPosixOffset( Current->TrustInfoEx.TrustDirection, Current->TrustInfoEx.TrustType ) ) {
            SwappedPosixOffsets[SwappedPosixOffsetCount] = LdapSwapBits( Current->PosixOffset );
            SwappedPosixOffsetCount++;
        }

    }

    //
    // Sort the list.
    //

    qsort( SwappedPosixOffsets,
           SwappedPosixOffsetCount,
           sizeof(ULONG),
           CompareUlongs );

    //
    // Walk the list finding the first free entry.
    //


#define SE_BUILT_IN_DOMAIN_SWAPPED_POSIX_OFFSET          ((ULONG) 0x4000)
#define SE_ACCOUNT_DOMAIN_SWAPPED_POSIX_OFFSET           ((ULONG) 0xC000)
#define SE_PRIMARY_DOMAIN_SWAPPED_POSIX_OFFSET           ((ULONG) 0x0800)

    ASSERT( SE_BUILT_IN_DOMAIN_SWAPPED_POSIX_OFFSET == LdapSwapBits( SE_BUILT_IN_DOMAIN_POSIX_OFFSET ) );
    ASSERT( SE_ACCOUNT_DOMAIN_SWAPPED_POSIX_OFFSET == LdapSwapBits( SE_ACCOUNT_DOMAIN_POSIX_OFFSET ) );
    ASSERT( SE_PRIMARY_DOMAIN_SWAPPED_POSIX_OFFSET == LdapSwapBits( SE_PRIMARY_DOMAIN_POSIX_OFFSET ) );

    TargetSwappedPosixOffset = 1;
    for ( i=0; i<SwappedPosixOffsetCount; i++ ) {

        //
        // If the target is free,
        //  we've found the free Posix Offset.
        //

        if ( SwappedPosixOffsets[i] > TargetSwappedPosixOffset ) {
            break;

        //
        // If the current entry is the target,
        //  move the target.
        //

        } else if ( SwappedPosixOffsets[i] == TargetSwappedPosixOffset ) {

            //
            // Loop avoiding well known Posix Offsets.
            //
            while ( TRUE ) {
                TargetSwappedPosixOffset++;

                if ( TargetSwappedPosixOffset != SE_PRIMARY_DOMAIN_SWAPPED_POSIX_OFFSET &&
                     TargetSwappedPosixOffset != SE_ACCOUNT_DOMAIN_SWAPPED_POSIX_OFFSET &&
                     TargetSwappedPosixOffset != SE_BUILT_IN_DOMAIN_SWAPPED_POSIX_OFFSET ) {
                    break;
                }
            }
        }

    }

    //
    // Return the first free Posix Offset to the caller.
    //

    *PosixOffset = LdapSwapBits( TargetSwappedPosixOffset );
    Status = STATUS_SUCCESS;

Cleanup:

    if ( SwappedPosixOffsets != NULL ) {
        LsapFreeLsaHeap( SwappedPosixOffsets );
    }

    return Status;

}


NTSTATUS
LsapDbBuildTrustedDomainCache(
    )

/*++

Routine Description:

    This function initializes a Trusted Domain List by enumerating all
    of the Trusted Domain objects in the specified target system's
    Policy Database.  For a Windows Nt system (Workstation) the list
    contains only the Primary Domain.  For a LanManNt system (DC), the
    list contains zero or more Trusted Domain objects.  Note that the
    list contains only those domains for which Trusted Domain objects
    exist in the local LSA Policy Database.  If for example, a DC
    trusted Domain A which in turn trusts Domain B, the list will not
    contain an entry for Domain B unless there is a direct relationship.

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS EnumerationStatus = STATUS_SUCCESS;
    LSAPR_TRUSTED_ENUM_BUFFER TrustedDomains;
    ULONG EnumerationContext = 0, i;
    BOOLEAN LookupDs = LsapDsWriteDs;
    BOOLEAN CloseTransaction = FALSE;

    LsapEnterFunc( "LsapDbBuildTrustedDomainCache" );

    ASSERT( LsapDbIsLockedTrustedDomainList());
    ASSERT( !LsapDbIsValidTrustedDomainList());

    //
    // Verify input parameters
    //

    if ( LsapDsWriteDs ) {

        Status = LsapDsInitAllocAsNeededEx(
                     LSAP_DB_DS_OP_TRANSACTION |
                        LSAP_DB_NO_LOCK,
                     TrustedDomainObject,
                     &CloseTransaction
                     );

        if ( !NT_SUCCESS( Status ) ) {

            return Status;
        }
    }

    LsapDbMakeCacheBuilding( TrustedDomainObject );

    //
    // Initialize the Trusted Domain List to the empty state.
    //

    LsapDbPurgeTrustedDomainCache();

    //
    // Register for UPN list notifications first (only on DCs)
    //

    if ( LsaDsStateInfo.DsInitializedAndRunning ) {

        Status = LsapRegisterForUpnListNotifications();

        if ( !NT_SUCCESS( Status )) {

            goto BuildTrustedDomainListError;
        }

        //
        // Continue the transaction
        //

        LsapDsContinueTransaction();
    }

    //
    // DCs in the root domain must not allow other forests to claim SIDs
    // and namespaces that conflict with their own forest
    // For that, the information about the current forest is inserted
    // into the forest trust cache as just another (though special) entry
    //

    Status = LsapForestTrustInsertLocalInfo();

    if ( !NT_SUCCESS( Status )) {

        goto BuildTrustedDomainListError;
    }

    //
    // Loop round, enumerating groups of Trusted Domain objects.
    //

    do {

        //
        // Enumerate the next group of Trusted Domains
        //

        if ( LookupDs ) {

            EnumerationStatus = Status = LsapDsEnumerateTrustedDomainsEx(
                                             &EnumerationContext,
                                             TrustedDomainFullInformation2Internal,
                                             (PLSAPR_TRUSTED_DOMAIN_INFO *)&(TrustedDomains.Information),
                                             LSAP_DB_ENUM_DOMAIN_LENGTH * 100,
                                             &TrustedDomains.EntriesRead,
                                             LSAP_DB_ENUMERATE_NO_OPTIONS
                                             );

        } else {

            EnumerationStatus = Status = LsapDbSlowEnumerateTrustedDomains(
                                             LsapPolicyHandle,
                                             &EnumerationContext,
                                             TrustedDomainInformationEx2Internal,
                                             &TrustedDomains,
                                             LSAP_DB_ENUM_DOMAIN_LENGTH
                                             );
        }

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_NO_MORE_ENTRIES) {

                break;
            }

            Status = STATUS_SUCCESS;
        }

        //
        // If the number of entries returned was zero, quit.
        //

        if (TrustedDomains.EntriesRead == (ULONG) 0) {

            break;
        }

        //
        // Otherwise, add them to our list
        //
        for ( i = 0; i < TrustedDomains.EntriesRead && NT_SUCCESS( Status ); i++ ) {
            PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustInfoEx2;
            ULONG PosixOffset;

            if ( LookupDs ) {
                PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 TrustFullInfo2;
                TrustFullInfo2 = &((PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2)TrustedDomains.Information)[i];
                TrustInfoEx2 = &TrustFullInfo2->Information;
                PosixOffset = TrustFullInfo2->PosixOffset.Offset;
            } else {
                TrustInfoEx2 = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2)TrustedDomains.Information)[i];

                //
                // This is only used during upgrade.  This Posix Offset will be recomputed.
                PosixOffset = 0;
            }

            //
            // Now, add it to the list
            //
            Status = LsapDbInsertTrustedDomainList(
                         TrustInfoEx2,
                         PosixOffset
                         );
        }


    } while ( NT_SUCCESS( Status ) && EnumerationStatus != STATUS_NO_MORE_ENTRIES );

    if (!NT_SUCCESS(Status)) {

        //
        // If STATUS_NO_MORE_ENTRIES was returned, there are no more
        // trusted domains.  Discard this status.
        //

        if (Status != STATUS_NO_MORE_ENTRIES) {

            goto BuildTrustedDomainListError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // The forest trust cache is only marked "external valid" for
    // DCs in root domain and GCs outside of the root domain
    //

    if ( LsapDbDcInRootDomain()) {

        LsapForestTrustCacheSetExternalValid();

    } else if ( SamIAmIGC()) {

        Status = LsapRebuildFtCacheGC();

        if ( !NT_SUCCESS( Status )) {

            goto BuildTrustedDomainListError;
        }

        // LsapRebuildFtCacheGC will set the cache "external valid"
    }

    //
    // Mark the Trusted Domain List as valid.
    //

    LsapDbMakeCacheValid( TrustedDomainObject );

BuildTrustedDomainListFinish:

    if ( LsapDsWriteDs ) {

        LsapDsDeleteAllocAsNeededEx(
            LSAP_DB_DS_OP_TRANSACTION |
               LSAP_DB_NO_LOCK,
            TrustedDomainObject,
            CloseTransaction
            );
    }

    LsapExitFunc( "LsapEnumerateTrustedDomainsEx", Status );

    return(Status);

BuildTrustedDomainListError:

    LsapDbMakeCacheInvalid( TrustedDomainObject );
    LsapDbPurgeTrustedDomainCache();

    goto BuildTrustedDomainListFinish;
}


VOID
LsapDbPurgeTrustedDomainCache(
    )

/*++

Routine Description:

    This function is the opposite of LsapDbBuildTrustedDomainCache().

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

--*/

{
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY Current;

    //
    // Caller must already have the trusted domain list locked
    // Convert the read lock to exclusive to be sure
    //

    ASSERT( LsapDbIsLockedTrustedDomainList());

    //
    // Purge the forest trust cache
    //

    LsapForestTrustCacheSetInvalid();

    while( !IsListEmpty( &LsapDbTrustedDomainList.ListHead ) ) {

        Current = CONTAINING_RECORD( LsapDbTrustedDomainList.ListHead.Flink,
                                     LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, NextEntry );

        RemoveEntryList( &Current->NextEntry );
        LsapDbTrustedDomainList.TrustedDomainCount--;

        _fgu__LSAPR_TRUSTED_DOMAIN_INFO( ( PLSAPR_TRUSTED_DOMAIN_INFO )&Current->TrustInfoEx,
                                         TrustedDomainInformationEx );

        MIDL_user_free( Current );
    }

    //
    // Initialize the Trusted Domain List to the empty state.
    //

    InitializeListHead( &LsapDbTrustedDomainList.ListHead );
    LsapDbTrustedDomainList.TrustedDomainCount = 0;
    LsapDbTrustedDomainList.CurrentSequenceNumber = 0;

    if ( !LsapDbIsCacheBuilding( TrustedDomainObject )) {

        LsapDbMakeCacheInvalid( TrustedDomainObject );
    }

    return;
}

#ifdef DBG // this is a macro in FRE builds

BOOLEAN
LsapDbIsValidTrustedDomainList(
    )

/*++

Routine Description:

    This function checks if the Trusted Domain List is valid.

Arguments:

    None

Return Values:

    BOOLEAN - TRUE if the list is valid, else FALSE

--*/

{
    ASSERT( LsapDbIsLockedTrustedDomainList());

    return( LsapDbIsCacheValid( TrustedDomainObject ) ||
             LsapDbIsCacheBuilding( TrustedDomainObject ));
}
#endif


NTSTATUS
LsarEnumerateTrustedDomainsEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_TRUSTED_ENUM_BUFFER_EX TrustedDomainInformation,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaEnumerateTrustedDomains API.

    The LsaEnumerateTrustedDomains API returns information about
    TrustedDomain objects.  This call requires POLICY_VIEW_LOCAL_INFORMATION
    access to the Policy object.  Since there may be more information than
    can be returned in a single call of the routine, multiple calls can be
    made to get all of the information.  To support this feature, the caller
    is provided with a handle that can be used across calls to the API.  On
    the initial call, EnumerationContext should point to a variable that has
    been initialized to 0.  On each subsequent call, the value returned by
    the preceding call should be passed in unchanged.  The enumeration is
    complete when the warning STATUS_NO_MORE_ENTRIES is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    EnumerationBuffer - Pointer to an enumeration structure that will receive
        a count of the Trusted Domains enumerated on this call and a pointer to
        an array of entries containing information for each enumerated
        Trusted Domain.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.
            Some entries may have been returned.
            The caller need not call again.

        STATUS_MORE_ENTRIES - The call completed successfully.
            Some entries have been returned.  The caller should call again to
            get additional entries.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects have been enumerated because the
            EnumerationContext value is too high.

--*/

{
    NTSTATUS Status;
    ULONG Items = 0;
    PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomInfo;

    LsarpReturnCheckSetup();
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_EnumerateTrustedDomainsEx);

    Status = LsapEnumerateTrustedDomainsEx( PolicyHandle,
                                                EnumerationContext,
                                                TrustedDomainInformationEx,
                                                &TrustedDomInfo,
                                                PreferedMaximumLength,
                                                &Items,
                                                LSAP_DB_ENUMERATE_NO_OPTIONS |
                                                    LSAP_DB_ENUMERATE_NULL_SIDS );


    if ( NT_SUCCESS( Status ) || Status == STATUS_NO_MORE_ENTRIES ) {

        TrustedDomainInformation->EntriesRead = Items;
        TrustedDomainInformation->EnumerationBuffer =
                                            (PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX)TrustedDomInfo;
    }


    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_EnumerateTrustedDomainsEx);
    LsarpReturnPrologue();

    return( Status );
}


NTSTATUS
LsapEnumerateTrustedDomainsEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN TRUSTED_INFORMATION_CLASS InfoClass,
    OUT PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned,
    IN ULONG EnumerationFlags
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaEnumerateTrustedDomains API.

    The LsaEnumerateTrustedDomains API returns information about
    TrustedDomain objects.  This call requires POLICY_VIEW_LOCAL_INFORMATION
    access to the Policy object.  Since there may be more information than
    can be returned in a single call of the routine, multiple calls can be
    made to get all of the information.  To support this feature, the caller
    is provided with a handle that can be used across calls to the API.  On
    the initial call, EnumerationContext should point to a variable that has
    been initialized to 0.  On each subsequent call, the value returned by
    the preceding call should be passed in unchanged.  The enumeration is
    complete when the warning STATUS_NO_MORE_ENTRIES is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    InfoClass - The class of information to return
        Must be TrustedDomainInformationEx or TrustedDomainInformatinBasic

    TrustedDomainInformation - Returns a pointer to an array of entries
        containing information for each enumerated Trusted Domain.

        Free using LsapFreeTrustedDomainsEx()

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

    CountReturned - Number of elements returned in TrustedDomainInformation

    EnumerationFlags -- Controls how the enumeration is done.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects have been enumerated because the
            EnumerationContext value is too high.

--*/

{
    NTSTATUS Status, SecondaryStatus;
    ULONG MaxLength, i;
    BOOLEAN ObjectReferenced = FALSE, CloseTransaction = FALSE;

    LsapEnterFunc( "LsapEnumerateTrustedDomainsEx" );

    ASSERT( InfoClass == TrustedDomainInformationEx ||
            InfoClass == TrustedDomainInformationBasic );
    *TrustedDomainInformation = NULL;
    *CountReturned = 0;

    //
    // If no Enumeration Structure is provided, return an error.
    //

    if ( !ARGUMENT_PRESENT(TrustedDomainInformation) ||
                                    !ARGUMENT_PRESENT( EnumerationContext ) ) {

        LsapExitFunc( "LsapEnumerateTrustedDomainsEx", STATUS_INVALID_PARAMETER );
        return( STATUS_INVALID_PARAMETER );

    }

    //
    // Acquire the Lsa Database lock.  Verify that the connection handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 PolicyObject,
                 TrustedDomainObject,
                 LSAP_DB_LOCK |
                   LSAP_DB_READ_ONLY_TRANSACTION |
                   LSAP_DB_NO_DS_OP_TRANSACTION );

    if ( NT_SUCCESS( Status ) ) {

        ObjectReferenced = TRUE;

        //
        // Limit the enumeration length except for trusted callers
        //

        if ( !((LSAP_DB_HANDLE)PolicyHandle)->Trusted   &&
              (PreferedMaximumLength > LSA_MAXIMUM_ENUMERATION_LENGTH) ) {

            MaxLength = LSA_MAXIMUM_ENUMERATION_LENGTH;

        } else {

            MaxLength = PreferedMaximumLength;

        }


        //
        // If the data is cached,
        //  use the cache.
        //

        if (LsapDbIsCacheValid(TrustedDomainObject)) {
            LSAPR_TRUSTED_ENUM_BUFFER CacheEnum;

            Status = LsapDbEnumerateTrustedDomainList(
                            EnumerationContext,
                            &CacheEnum,
                            PreferedMaximumLength,
                            InfoClass,
                            (BOOLEAN)(FLAG_ON( EnumerationFlags, LSAP_DB_ENUMERATE_NULL_SIDS ) ?
                                TRUE :
                                FALSE) );

            if ( NT_SUCCESS( Status ) ) {
                *CountReturned = CacheEnum.EntriesRead;
                *TrustedDomainInformation = ( PLSAPR_TRUSTED_DOMAIN_INFO )CacheEnum.Information;
            }

        //
        // If the data is in the registry,
        //  enumerate it from there.
        //
        } else if ( !LsapDsWriteDs ) {
            LSAPR_TRUSTED_ENUM_BUFFER RegEnum;

            //
            // Use slow method of enumeration, by accessing backing storage.
            // Later, we'll implement rebuilding of the cache.

            Status = LsapDbSlowEnumerateTrustedDomains(
                         PolicyHandle,
                         EnumerationContext,
                         InfoClass,
                         &RegEnum,
                         PreferedMaximumLength );

            if ( NT_SUCCESS( Status ) ) {
                *CountReturned = RegEnum.EntriesRead;
                *TrustedDomainInformation = ( PLSAPR_TRUSTED_DOMAIN_INFO )RegEnum.Information;
            }

        //
        // If the data is in the DS,
        //  enumerate it from there.
        //
        } else {

            BOOLEAN Reset = FALSE;

            Status = LsapDsInitAllocAsNeededEx(
                         LSAP_DB_LOCK |
                            LSAP_DB_READ_ONLY_TRANSACTION |
                            LSAP_DB_DS_OP_TRANSACTION,
                         TrustedDomainObject,
                         &Reset);

            if ( NT_SUCCESS( Status )) {

                //
                // LsapDsEnumerateTrustedDomainsEx increments the EnumerationContext as necessary
                //
                Status = LsapDsEnumerateTrustedDomainsEx(
                             EnumerationContext,
                             InfoClass,
                             TrustedDomainInformation,
                             MaxLength,
                             CountReturned,
                             EnumerationFlags
                             );

                LsapDsDeleteAllocAsNeededEx(
                    LSAP_DB_LOCK |
                       LSAP_DB_READ_ONLY_TRANSACTION |
                       LSAP_DB_DS_OP_TRANSACTION,
                    TrustedDomainObject,
                    Reset
                    );
            }
        }

    }

    if ( ObjectReferenced == TRUE ) {

        //
        // Don't lose the results of the Enumeration
        //
        SecondaryStatus = LsapDbDereferenceObject(
                              &PolicyHandle,
                              PolicyObject,
                              TrustedDomainObject,
                              LSAP_DB_LOCK |
                                 LSAP_DB_READ_ONLY_TRANSACTION |
                                 LSAP_DB_NO_DS_OP_TRANSACTION,
                              (SECURITY_DB_DELTA_TYPE) 0,
                              Status
                              );

        LsapDbSetStatusFromSecondary( Status, SecondaryStatus );

    }

    //
    // Deallocate any memory if we failed
    //
    if ( !NT_SUCCESS( Status ) && Status != STATUS_NO_MORE_ENTRIES ) {

        //
        // Free it up.
        //
        LsapFreeTrustedDomainsEx( InfoClass,
                                  *TrustedDomainInformation,
                                  *CountReturned );

        *TrustedDomainInformation = NULL;
        *CountReturned = 0;
    }

    //
    // Map the status into what LsarEnumerateTrustedDomains normally returns...
    //
    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        Status = STATUS_NO_MORE_ENTRIES;
    }


    LsapExitFunc( "LsapEnumerateTrustedDomainsEx", Status );

    return( Status );
}

VOID
LsapFreeTrustedDomainsEx(
    IN TRUSTED_INFORMATION_CLASS InfoClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation,
    IN ULONG TrustedDomainCount
    )

/*++

Routine Description:

    This function frees a buffer returned from LsapEnumerateTrustedDomainsEx

Arguments:

    InfoClass - The class of information in the buffer.
        Must be TrustedDomainInformationEx or TrustedDomainInformatinBasic

    TrustedDomainInformation - A pointer to an array of entries
        containing information for each enumerated Trusted Domain.

    TrustedDomainCount - Number of elements in TrustedDomainInformation

Return Values:

    None.

--*/

{
    switch ( InfoClass ) {
    case TrustedDomainInformationEx:
        {
            LSAPR_TRUSTED_ENUM_BUFFER_EX TrustedDomainInfoEx;


            TrustedDomainInfoEx.EntriesRead = TrustedDomainCount;
            TrustedDomainInfoEx.EnumerationBuffer =
                (PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX) TrustedDomainInformation;

            _fgs__LSAPR_TRUSTED_ENUM_BUFFER_EX( &TrustedDomainInfoEx );
            break;
        }

    case TrustedDomainInformationBasic:
        {
            LSAPR_TRUSTED_ENUM_BUFFER TrustedDomainInfoBasic;


            TrustedDomainInfoBasic.EntriesRead = TrustedDomainCount;
            TrustedDomainInfoBasic.Information =
                (PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC) TrustedDomainInformation;

            _fgs__LSAPR_TRUSTED_ENUM_BUFFER( &TrustedDomainInfoBasic );
            break;
        }
    default:
        ASSERT( FALSE );
        break;
    }
}



NTSTATUS
LsarQueryTrustedDomainInfoByName(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaQueryInfoTrustedDomain API.

    The LsaQueryInfoTrustedDomain API obtains information from a
    TrustedDomain object.  The caller must have access appropriate to the
    information being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        TrustedDomainNameInformation      TRUSTED_QUERY_DOMAIN_NAME
        TrustedControllersInformation     TRUSTED_QUERY_CONTROLLERS
        TrustedPosixOffsetInformation     TRUSTED_QUERY_POSIX

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status, SecondaryStatus;
    LSAP_DB_OBJECT_INFORMATION ObjInfo;
    LSAPR_HANDLE TrustedDomainHandle;
    BOOLEAN ObjectReferenced = FALSE;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustInfoForName;
    PUNICODE_STRING ActualTDName = ( PUNICODE_STRING )TrustedDomainName;
    ACCESS_MASK DesiredAccess;
    BOOLEAN AcquiredTrustedDomainListReadLock = FALSE;


    LsarpReturnCheckSetup();
    LsapEnterFunc( "LsarQueryTrustedDomainInfoByName" );
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_QueryTrustedDomainInfoByName);

    //
    // Validate the input buffer
    //
    if ( !LsapValidateLsaUnicodeString( TrustedDomainName ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto GetInfoByNameError;
    }

    //
    // Validate the Information Class and determine the access required to
    // query this Trusted Domain Information Class.
    //

    Status = LsapDbVerifyInfoQueryTrustedDomain(
                 InformationClass,
                 (BOOLEAN)(((LSAP_DB_HANDLE)PolicyHandle)->Options & LSAP_DB_TRUSTED),
                 &DesiredAccess );

    if (!NT_SUCCESS(Status)) {

        goto GetInfoByNameError;
    }




    Status = LsapDbReferenceObject( PolicyHandle,
                                    0,
                                    PolicyObject,
                                    TrustedDomainObject,
                                    LSAP_DB_LOCK |
                                        LSAP_DB_READ_ONLY_TRANSACTION   |
                                        LSAP_DB_DS_OP_TRANSACTION );


    if ( NT_SUCCESS( Status ) ) {

        ObjectReferenced = TRUE;


        //
        // Acquire the Read Lock for the Trusted Domain List
        //

        Status = LsapDbAcquireReadLockTrustedDomainList();

        if (!NT_SUCCESS(Status)) {
            goto GetInfoByNameError;
        }

        AcquiredTrustedDomainListReadLock = TRUE;

        //
        // Get the right name
        //
        Status = LsapDbLookupNameTrustedDomainListEx( TrustedDomainName,
                                                      &TrustInfoForName );

        if ( NT_SUCCESS( Status ) ) {

            ActualTDName = ( PUNICODE_STRING )&TrustInfoForName->TrustInfoEx.Name;

        } else {

            LsapDsDebugOut(( DEB_ERROR,
                         "No trust entry found for %wZ: 0x%lx\n",
                         ( PUNICODE_STRING )TrustedDomainName,
                         Status ));
            Status = STATUS_SUCCESS;
        }

        //
        // Build a temporary handle
        //
        RtlZeroMemory( &ObjInfo, sizeof( ObjInfo ) );
        ObjInfo.ObjectTypeId = TrustedDomainObject;
        ObjInfo.ContainerTypeId = 0;
        ObjInfo.Sid = NULL;
        ObjInfo.DesiredObjectAccess = DesiredAccess;

        InitializeObjectAttributes( &ObjInfo.ObjectAttributes,
                                    ActualTDName,
                                    0L,
                                    PolicyHandle,
                                    NULL );


        //
        // Get a handle to the TDO
        //

        Status = LsapDbOpenObject( &ObjInfo,
                                   DesiredAccess,
                                   0,
                                   &TrustedDomainHandle );

        if ( AcquiredTrustedDomainListReadLock ) {
            LsapDbReleaseLockTrustedDomainList();
            AcquiredTrustedDomainListReadLock = FALSE;
        }


        if ( NT_SUCCESS( Status ) ) {

            Status = LsarQueryInfoTrustedDomain( TrustedDomainHandle,
                                                 InformationClass,
                                                 TrustedDomainInformation );

            LsapDbCloseObject( &TrustedDomainHandle,
                               0,
                               Status );
        }

    }


    //
    // If we got a DNS name to lookup and it wasn't found and it was an absolute DNS name
    // try hacking off the trailing period and trying it again...
    //
    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        if ( TrustedDomainName->Length == 0 || TrustedDomainName->Buffer == NULL ) {

            goto GetInfoByNameError;
        }

        if ( TrustedDomainName->Buffer[ (TrustedDomainName->Length - 1) / sizeof(WCHAR)] == L'.' ) {

            TrustedDomainName->Buffer[ (TrustedDomainName->Length - 1) / sizeof(WCHAR)] =
                                                                                     UNICODE_NULL;
            TrustedDomainName->Length -= sizeof(WCHAR);

            if ( TrustedDomainName->Length > 0 &&
                 TrustedDomainName->Buffer[ ( TrustedDomainName->Length - 1) / sizeof(WCHAR)] !=
                                                                                             L'.') {

                LsapDsDebugOut(( DEB_WARN,
                                 "GetTrustedDomainInfoByName tried with absolute DNS name.  "
                                 "Retrying with %wZ\n",
                                 TrustedDomainName ));

                Status = LsarQueryTrustedDomainInfoByName( PolicyHandle,
                                                           TrustedDomainName,
                                                           InformationClass,
                                                           TrustedDomainInformation );

            }

        }
    }

GetInfoByNameError:
    if ( AcquiredTrustedDomainListReadLock ) {
        LsapDbReleaseLockTrustedDomainList();
    }

    //
    // Dereference the object
    //
    if ( ObjectReferenced ) {

        SecondaryStatus = LsapDbDereferenceObject(
                              &PolicyHandle,
                              PolicyObject,
                              TrustedDomainObject,
                              LSAP_DB_LOCK |
                                LSAP_DB_READ_ONLY_TRANSACTION   |
                                LSAP_DB_DS_OP_TRANSACTION,
                              (SECURITY_DB_DELTA_TYPE) 0,
                              Status );


    }



    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_QueryTrustedDomainInfoByName);
    LsapExitFunc( "LsarQueryTrustedDomainInfoByName", Status );
    LsarpReturnPrologue();


    return( Status );
}



NTSTATUS
LsarSetTrustedDomainInfoByName(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation)
{
    NTSTATUS Status, SecondaryStatus;
    LSAP_DB_OBJECT_INFORMATION ObjInfo;
    LSAPR_HANDLE TrustedDomainHandle;
    ACCESS_MASK DesiredAccess;


    LsarpReturnCheckSetup();
    LsapEnterFunc( "LsarSetTrustedDomainInfoByName" );
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_SetTrustedDomainInfoByName);

    //
    // Validate the input buffer
    //
    if ( !LsapValidateLsaUnicodeString( TrustedDomainName ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto SetInfoByNameError;
    }

    //
    // Validate the Information Class and Trusted Domain Information provided and
    // if valid, return the mask of accesses required to update this
    // class of Trusted Domain information.
    //

    Status = LsapDbVerifyInfoSetTrustedDomain(
                 InformationClass,
                 TrustedDomainInformation,
                 (BOOLEAN)(((LSAP_DB_HANDLE)PolicyHandle)->Options & LSAP_DB_TRUSTED),
                 &DesiredAccess );

    if (!NT_SUCCESS(Status)) {

        goto SetInfoByNameError;
    }

    //
    // Build a temporary handle
    //

    RtlZeroMemory( &ObjInfo, sizeof( ObjInfo ) );
    ObjInfo.ObjectTypeId = TrustedDomainObject;
    ObjInfo.ContainerTypeId = 0;
    ObjInfo.Sid = NULL;
    ObjInfo.DesiredObjectAccess = DesiredAccess;

    InitializeObjectAttributes(
        &ObjInfo.ObjectAttributes,
        (UNICODE_STRING *)TrustedDomainName,
        0L,
        PolicyHandle,
        NULL
        );

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 0,
                 PolicyObject,
                 TrustedDomainObject,
                 LSAP_DB_LOCK
                 );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Get a handle to the TDO
        //

        Status = LsapDbOpenObject( &ObjInfo,
                                   DesiredAccess,
                                   0,
                                   &TrustedDomainHandle );

        //
        // Unlock the lock.
        //
        // We can't enter LsarSetInformationTrustedDomain with any locks locked since
        //  it goes out of process to get the session key.
        //
        // We can't dereference the PolicyHandle since this reference also
        //  serves as the ContainerHandle reference.
        //

        LsapDbReleaseLockEx( TrustedDomainObject,
                             0 );

        //
        // Set the info on the TDO.
        //

        if ( NT_SUCCESS( Status ) ) {

            Status = LsarSetInformationTrustedDomain(
                         TrustedDomainHandle,
                         InformationClass,
                         TrustedDomainInformation );

            LsapDbCloseObject( &TrustedDomainHandle,
                               0,
                               Status );
        }

        //
        // Dereference the object.
        //

        SecondaryStatus = LsapDbDereferenceObject(
                              &PolicyHandle,
                              PolicyObject,
                              TrustedDomainObject,
                              LSAP_DB_OMIT_REPLICATOR_NOTIFICATION,
                              (SECURITY_DB_DELTA_TYPE) 0,
                              Status
                              );

        LsapDbSetStatusFromSecondary( Status, SecondaryStatus );
    }

    //
    // If we got a DNS name to lookup and it wasn't found and it was an absolute DNS name
    // try hacking off the trailing period and trying it again...
    //

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        if ( TrustedDomainName->Length == 0 || TrustedDomainName->Buffer == NULL ) {

            goto SetInfoByNameError;
        }

        if ( TrustedDomainName->Buffer[ (TrustedDomainName->Length - 1) / sizeof(WCHAR)] == L'.' ) {

            TrustedDomainName->Buffer[ (TrustedDomainName->Length - 1) / sizeof(WCHAR)] =
                                                                                     UNICODE_NULL;
            TrustedDomainName->Length -= sizeof(WCHAR);

            if ( TrustedDomainName->Length > 0 &&
                 TrustedDomainName->Buffer[ ( TrustedDomainName->Length - 1) / sizeof(WCHAR)] !=
                                                                                             L'.') {

                LsapDsDebugOut(( DEB_WARN,
                                 "SetTrustedDomainInfoByName tried with absolute DNS name.  "
                                 "Retrying with %wZ\n",
                                 TrustedDomainName ));

                Status = LsarSetTrustedDomainInfoByName( PolicyHandle,
                                                         TrustedDomainName,
                                                         InformationClass,
                                                         TrustedDomainInformation );
            }
        }
    }

SetInfoByNameError:

    LsapExitFunc( "LsarSetTrustedDomainInfoByName", Status );
    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_SetTrustedDomainInfoByName);
    LsarpReturnPrologue();

    return( Status );
}


NTSTATUS
LsarCreateTrustedDomainEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *TrustedDomainHandle
    )
/*++

Routine Description:

    The LsaCreateTrustedDomainEx function creates a new TrustedDomain object.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainInformation - Pointer to a TRUSTED_DOMAIN_INFORMATION_EX structure
        containing the name and SID of the new trusted domain.

    AuthenticationInformation - Pointer to a TRUSTED_DOMAIN_AUTH_INFORMATION
        structure containing authentication information for the new trusted domain.

    DesiredAccess  - An ACCESS_MASK structure that specifies the accesses to
        be granted for the new trusted domain.

    TrustedDomainHandle  - Receives the LSA policy handle of the remote
        trusted domain. You can use pass this handle into LSA function calls
        in order to query and/or manage the LSA policy of the remote machine.

        When your application no longer needs this handle, it should call
        LsaClose to delete the handle.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status;

    LsarpReturnCheckSetup();
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_CreateTrustedDomainEx);

    //
    // Former LSA implementations didn't enforce TRUSTED_SET_AUTH.
    //  So some callers were lured into a false sense of security and didn't
    //  ask for it.  Ask here.
    //

    DesiredAccess |= TRUSTED_SET_AUTH;

    //
    // There's a bug in the definition LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION where
    //  it doesn't allow more than one auth info to be passed over the wire.
    //  So, short circuit it here.
    //
    // We could let trusted callers thru, but we haven't validated the handle yet.
    //

    if ( AuthenticationInformation->IncomingAuthInfos > 1 ||
         AuthenticationInformation->OutgoingAuthInfos > 1 ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Call the worker routine to do the job.
    //

    Status = LsapCreateTrustedDomain2( PolicyHandle,
                                       TrustedDomainInformation,
                                       AuthenticationInformation,
                                       DesiredAccess,
                                       TrustedDomainHandle );

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_CreateTrustedDomainEx);
    LsarpReturnPrologue();

    return( Status );
}

NTSTATUS
LsarCreateTrustedDomainEx2(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *TrustedDomainHandle
    )

/*++

Routine Description:

    Same as LsarCreateTrustedDomainEx except the AuthenticationInformation is
        encrypted on the wire.

Arguments:

    Same as LsarCreateTrustedDomainEx except the AuthenticationInformation is
        encrypted on the wire.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status;
    TRUSTED_DOMAIN_AUTH_INFORMATION DecryptedTrustedDomainAuthInfo;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;

    LsarpReturnCheckSetup();
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_CreateTrustedDomainEx);
    RtlZeroMemory( &DecryptedTrustedDomainAuthInfo, sizeof(DecryptedTrustedDomainAuthInfo) );

    //
    // Check the parameters
    //  (AuthenticationInformation->AuthBlob.AuthBlob is a unique pointer therefore needs to be
    //   checked for null before reference)
    //

    if( ( AuthenticationInformation->AuthBlob.AuthBlob == NULL &&
           AuthenticationInformation->AuthBlob.AuthSize != 0 ) ||
        ( AuthenticationInformation->AuthBlob.AuthBlob != NULL &&
           AuthenticationInformation->AuthBlob.AuthSize == 0 ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Get the session key.
    //

    Status = LsapCrServerGetSessionKeySafe( PolicyHandle,
                                            PolicyObject,
                                            &SessionKey );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    //
    // Build a decrypted Auth Info structure.
    //

    Status = LsapDecryptAuthDataWithSessionKey(
                        SessionKey,
                        AuthenticationInformation,
                        &DecryptedTrustedDomainAuthInfo );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Former LSA implementations didn't enforce TRUSTED_SET_AUTH.
    //  So some callers were lured into a false sense of security and didn't
    //  ask for it.  Ask here.
    //

    DesiredAccess |= TRUSTED_SET_AUTH;

    //
    // Call the worker routine to do the job.
    //

    Status = LsapCreateTrustedDomain2( PolicyHandle,
                                       TrustedDomainInformation,
                                       (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION)&DecryptedTrustedDomainAuthInfo,
                                       DesiredAccess,
                                       TrustedDomainHandle );

Cleanup:

    if ( SessionKey != NULL ) {
        MIDL_user_free( SessionKey );
    }

    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &DecryptedTrustedDomainAuthInfo, TRUE ) );
    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &DecryptedTrustedDomainAuthInfo, FALSE ) );

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_CreateTrustedDomainEx);
    LsarpReturnPrologue();

    return( Status );
}


NTSTATUS
LsapDbOpenTrustedDomainByName(
    IN OPTIONAL LSAPR_HANDLE PolicyHandle,
    IN PUNICODE_STRING TrustedDomainName,
    OUT PLSAPR_HANDLE TrustedDomainHandle,
    IN ULONG AccessMask,
    IN ULONG Options,
    IN BOOLEAN Trusted
    )
/*++

Routine Description:

    This function opens a Trusted Domain Object by the name.  This name can be either the
    DomainName or FlatName
Arguments:

    PolicyHandle - Policy handle.
        If NULL, the LSA's global policy handle will be used.

    TrustedDomainName - Pointer to the domains name

    TrustedDomainHandle - Receives a handle to be used in future requests.

    AccessMask - Access mask to open the object with

    Options - Specifies option flags

        LSAP_DB_LOCK - Acquire the Lsa Database lock for the
           duration of the open operation.

        LSAP_DB_START_TRANSACTION -- Begin a transaction before access the database
            Ignored if LSAP_DB_LOCK isn't specified.

    Trusted - If TRUE, the open request is coming from a trusted client

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no TrustedDomain object in the
            target system's LSA Database having the specified Name.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDSNAME FoundTrustObject = NULL;
    LSAP_DB_OBJECT_INFORMATION ObjInfo;
    UNICODE_STRING ObjectName;
    BOOLEAN DbLocked = FALSE;
    BOOLEAN HandleReferenced = FALSE;
    ULONG DereferenceOptions = 0, ReferenceOptions = 0, i;
    LSAPR_HANDLE PolicyHandleToUse;

    LsapEnterFunc( "LsapDbOpenTrustedDomainByName" );

    if ((NULL==TrustedDomainName) || (NULL==TrustedDomainName->Buffer))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Validate the Policy Handle
    //
    // Don't both verifying the global handle (it's fine).
    // Increment the reference count.  We'll be using this reference as the ContainerHandle on
    //  the open trusted domain handle.
    //
    // This mechanism for ref counting the ContainerHandle is bogus throughout the code.
    // The code that does the reference (LsapDbCreateHandle) to the ContainerHandle should
    // increment the ref count.  The code that removes the reference (???) should decrement
    // the ref count.
    //

    if ( PolicyHandle == NULL ) {
        PolicyHandleToUse = LsapPolicyHandle;

    } else {
        PolicyHandleToUse = PolicyHandle;

        Status =  LsapDbVerifyHandle( PolicyHandle, 0, PolicyObject, TRUE );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        HandleReferenced = TRUE;
    }

    //
    // Do our opens as needed
    //
    if ( FLAG_ON( Options, LSAP_DB_LOCK ) ) {

        ReferenceOptions |= LSAP_DB_LOCK;
        DereferenceOptions |= LSAP_DB_LOCK;

        if ( FLAG_ON( Options, LSAP_DB_START_TRANSACTION ) ) {

            ReferenceOptions |= LSAP_DB_START_TRANSACTION;
            DereferenceOptions |= LSAP_DB_FINISH_TRANSACTION;
        }


        Status = LsapDbReferenceObject( PolicyHandleToUse,
                                        (ACCESS_MASK) 0,
                                        PolicyObject,
                                        TrustedDomainObject,
                                        Trusted ? ReferenceOptions | LSAP_DB_TRUSTED :
                                                  ReferenceOptions );

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        DbLocked = TRUE;
    }

    RtlZeroMemory( &ObjInfo, sizeof( ObjInfo ) );
    ObjInfo.ObjectTypeId = TrustedDomainObject;
    ObjInfo.ContainerTypeId = PolicyObject;
    ObjInfo.Sid = NULL;
    ObjInfo.DesiredObjectAccess = AccessMask;


    InitializeObjectAttributes(
        &ObjInfo.ObjectAttributes,
        TrustedDomainName,
        OBJ_CASE_INSENSITIVE,
        PolicyHandle,   // If NULL, we simply won't have a container handle.
        NULL
        );



    Status = LsapDbOpenObject( &ObjInfo,
                             AccessMask,
                             Trusted ? LSAP_DB_TRUSTED : 0,
                             TrustedDomainHandle );


Cleanup:
    if (DbLocked) {


         Status = LsapDbDereferenceObject(
                              &PolicyHandleToUse,
                              PolicyObject,
                              TrustedDomainObject,
                              DereferenceOptions,
                              (SECURITY_DB_DELTA_TYPE) 0,
                              Status
                              );

    }


    if ( !NT_SUCCESS(Status) ) {
        //
        // On Success, the reference to the Policy object is used as the ContainerHandle reference.
        //
        if ( HandleReferenced ) {
            LsapDbDereferenceHandle( PolicyHandle, FALSE );
        }
    }


    LsapExitFunc( "LsapDbOpenTrustedDomainByName", Status );

    return( Status );
}




NTSTATUS
LsarOpenTrustedDomainByName(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING TrustedDomainName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle
    )

/*++

Routine Description:

    The LsaOpenTrustedDomain API opens an existing TrustedDomain object
    using the SID as the primary key value.

Arguments:

    PolicyHandle - An open handle to a Policy object.

    TrustedDomainName - Name of the trusted domain object

    DesiredAccess - This is an access mask indicating accesses being
        requested to the target object.

    TrustedDomainHandle - Receives a handle to be used in future requests.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_TRUSTED_DOMAIN_NOT_FOUND - There is no TrustedDomain object in the
            target system's LSA Database having the specified TrustedDomainName

--*/

{
    NTSTATUS Status;

    LsarpReturnCheckSetup();

    LsapEnterFunc( "LsarOpenTrustedDomainByName" );
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_OpenTrustedDomainByName);

    //
    // Call the internal routine.  Caller is not trusted and the Database
    // lock needs to be acquired.
    //
    Status = LsapDbOpenTrustedDomainByName( PolicyHandle,
                                            (PUNICODE_STRING)TrustedDomainName,
                                            TrustedDomainHandle,
                                            DesiredAccess,
                                            LSAP_DB_LOCK,
                                            FALSE );    // Untrusted

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_OpenTrustedDomainByName);
    LsapExitFunc( "LsarOpenTrustedDomainByName", Status );
    LsarpReturnPrologue();

    return(Status);
}

NTSTATUS
LsapSidOnFtInfo(
    IN PUNICODE_STRING TrustedDomainName,
    IN PSID Sid
    )

/*++

Routine description:

    Determines whether the specified SID is on the FTINFO structure for the specified
    TDO.

Arguments:

    TrustedDomainName - Netbios name or DNS name of the trusted domain.

    Sid - SID to test

Return values:

    STATUS_SUCCESS              Match was found - SID is on the FTINFO

    STATUS_NO_MATCH             Match was not found - SID is not on the FTINFO

    STATUS_INVALID_DOMAIN_STATE Machine must be a GC or a DC in the root domain

    STATUS_INVALID_PARAMETER    Check the inputs

    STATUS_INTERNAL_ERROR       Cache is internally inconsistent

    STATUS_INSUFFICIENT_RESOURCES  Out of memory
--*/

{
    NTSTATUS Status;
    UNICODE_STRING MatchingDomain;

    //
    // Find the TDO that maps to this SID.
    //

    RtlInitUnicodeString( &MatchingDomain, NULL );

    Status = LsaIForestTrustFindMatch(
                    RoutingMatchDomainSid,
                    Sid,
                    &MatchingDomain );

    if ( Status != STATUS_SUCCESS ) {
        return Status;
    }

    //
    // If that TDO is not the named TDO,
    //  indicate that there was no match.
    //

    if ( !RtlEqualUnicodeString( TrustedDomainName,
                                 &MatchingDomain,
                                 TRUE ) ) {
        Status = STATUS_NO_MATCH;
    }


    LsaIFree_LSAPR_UNICODE_STRING_BUFFER( (PLSAPR_UNICODE_STRING) &MatchingDomain );

    return Status;

}

#ifdef TESTING_MATCHING_ROUTINE

#include <sddl.h> // ConvertStringSidToSidW

NTSTATUS
LsarForestTrustFindMatch(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Type,
    IN PLSA_UNICODE_STRING Name,
    OUT PLSA_UNICODE_STRING * Match
    )
{
    NTSTATUS Status;
    PLSA_UNICODE_STRING _Match = MIDL_user_allocate( sizeof( LSA_UNICODE_STRING ));
    PVOID Data;

    UNREFERENCED_PARAMETER( PolicyHandle );

    if ( _Match == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( Type == RoutingMatchDomainSid ) {

        if ( FALSE == ConvertStringSidToSidW(
                         Name->Buffer,
                         &Data )) {

            Data = NULL;
        }

    } else {

        Data = Name;
    }

    if ( Data != NULL ) {

        Status = LsaIForestTrustFindMatch(
                     ( LSA_ROUTING_MATCH_TYPE )Type,
                     Data,
                     _Match
                     );

        if ( NT_SUCCESS( Status )) {

            *Match = _Match;

        } else {

            *Match = NULL;
        }

    } else {

        Status = STATUS_INVALID_PARAMETER;
    }

    if ( Type == RoutingMatchDomainSid ) {

        LocalFree( Data );
    }

    return Status;
}

#endif

VOID
LsaIFree_LSA_FOREST_TRUST_INFORMATION(
    IN PLSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
    )
/*++

Routine Description:

    Frees up a structure pointed to by ForestTrustInfo

Arguments:

    ForestTrustInfo         structure to free

Returns:

    Nothing

--*/
{
    if ( ForestTrustInfo ) {

        LsapFreeForestTrustInfo( *ForestTrustInfo );
        MIDL_user_free( *ForestTrustInfo );
        *ForestTrustInfo = NULL;
    }

}


VOID
LsaIFree_LSA_FOREST_TRUST_COLLISION_INFORMATION(
    IN PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
    )
/*++

Routine Description:

    Frees up a structure pointed to by CollisionInfo

Arguments:

    CollisionInfo         structure to free

Returns:

    Nothing

--*/
{
    if ( CollisionInfo ) {

        LsapFreeCollisionInfo( CollisionInfo );
    }
}


BOOLEAN
LsapDbDcInRootDomain()
/*++

Routine Description:

    Tells if the system is running as a domain controller
    in the root domain of the forest

Arguments:

    None

Returns:

    TRUE or FALSE

--*/
{
    //
    // The determination is done at startup time and
    // the results are assumed to remain constant for
    // as long as the server stays up.
    //

    return DcInRootDomain;
}

BOOLEAN
LsapDbNoMoreWin2KForest()
/*++

Routine Description:

    Determines whether all domain controllers in the forest have been upgraded
    to Whistler (a requirement for forest trust operation) by querying
    the msDS-Behavior-Version attribute from the Partitions container in the DS

Arguments:

    None

Returns:

    TRUE or FALSE

--*/
{
    LONG ForestBehaviorVersion;
    DWORD Size = sizeof( ForestBehaviorVersion );
    static BOOLEAN Result = FALSE;
    NTSTATUS Status;

    //
    // Make sure the DS is installed
    //

    if ( !LsaDsStateInfo.UseDs ) {

        return FALSE;
    }

    //
    // Once true - always true
    //

    if ( !Result ) {

        Status = GetConfigurationInfo(
                     DSCONFIGINFO_FORESTVERSION,
                     &Size,
                     &ForestBehaviorVersion
                     );

        ASSERT( NT_SUCCESS( Status ));

        Result = ( ForestBehaviorVersion >= DS_BEHAVIOR_WIN2003 );
    }

    return Result;
}

BOOLEAN
LsaINoMoreWin2KDomain()
{
    return LsapDbNoMoreWin2KDomain();
}

BOOLEAN
LsapDbNoMoreWin2KDomain()
/*++

Routine Description:

    Determines whether all domain controllers in the current domain have been
    upgraded to Whistler by querying the msDS-Behavior-Version attribute from
    the root domain object in the DS

Arguments:

    None

Returns:

    TRUE or FALSE

--*/
{
    LONG DomainBehaviorVersion;
    DWORD Size = sizeof( DomainBehaviorVersion );
    static BOOLEAN Result = FALSE;
    NTSTATUS Status;

    //
    // Make sure the DS is installed
    //

    if ( !LsaDsStateInfo.UseDs ) {

        return FALSE;
    }

    //
    // Once true - always true
    //

    if ( !Result ) {

        Status = GetConfigurationInfo(
                     DSCONFIGINFO_DOMAINVERSION,
                     &Size,
                     &DomainBehaviorVersion
                     );

        ASSERT( NT_SUCCESS( Status ));

        Result = ( DomainBehaviorVersion >= DS_BEHAVIOR_WIN2003 );
    }

    return Result;
}

NTSTATUS
LsaIIsDomainWithinForest(
    IN UNICODE_STRING * TrustedDomainName,
    OUT BOOL * WithinForest,
    OUT OPTIONAL BOOL * ThisDomain,
    OUT OPTIONAL PSID * TrustedDomainSid,
    OUT OPTIONAL ULONG * TrustDirection,
    OUT OPTIONAL ULONG * TrustType,
    OUT OPTIONAL ULONG * TrustAttributes
    )
/*++

Routine Description:

    Figures out whether a given domain name is within our forest

Arguments:

    TrustedDomainName       DNS or Netbios domain name
    WithinForest            used to return TRUE if this domain is within forest
    ThisDomain              used to return TRUE if TrustedDomainName refers to
                            the name of this domain and not some other domain
                            in the forest
    TrustedDomainSid        used to return SID of the trusted domain

  The following return values are returned if the caller asked for them _and_
  there exists a direct trust relationship with the domain in question.

  The routine will be faster if the caller does not ask for the following parameters

    TrustDirection          Direction of the trust
    TrustType               Type of the trust
    TrustAttributes         Attributes of the trust

Returns:

    STATUS_SUCCESS          was able to determine the result
    STATUS_ error code      some error has occurred

--*/
{
    NTSTATUS Status;
    PPOLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo = NULL;
    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation = NULL;
    PSID Sid = NULL;
    PSID MatchSid = NULL;
    ULONG Direction = 0, Type = 0, Attributes = 0;

    *WithinForest = FALSE;

    if ( ThisDomain ) {

        *ThisDomain = FALSE;
    }

    //
    // First quickly check whether the caller specified the name of this domain
    //

    Status = LsapDbQueryInformationPolicy(
                 LsapPolicyHandle,
                 PolicyDnsDomainInformation,
                 ( PLSAPR_POLICY_INFORMATION *)&PolicyDnsDomainInfo
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    if ( LsapCompareDomainNames(
             TrustedDomainName,
             (PUNICODE_STRING)&PolicyDnsDomainInfo->DnsDomainName,
             (PUNICODE_STRING)&PolicyDnsDomainInfo->Name )) {

        *WithinForest = TRUE;

        if ( ThisDomain ) {

            *ThisDomain = TRUE;
        }

        Sid = PolicyDnsDomainInfo->Sid;

        goto Cleanup;
    }

    //
    // First find out if the domain is within our forest.  As a side effect,
    // retrieve the SID of the domain
    //

    Status = LsapForestTrustFindMatch(
                 RoutingMatchDomainName,
                 TrustedDomainName,
                 TRUE,
                 NULL,
                 TrustedDomainSid ? &MatchSid : NULL
                 );

    if ( NT_SUCCESS( Status )) {

        *WithinForest = TRUE;
        Sid = MatchSid;

    } else if ( Status == STATUS_NO_MATCH ) {

        *WithinForest = FALSE;
        Status = STATUS_SUCCESS;
    }

    if ( !NT_SUCCESS( Status ) ||
         !*WithinForest ) {

        goto Cleanup;
    }

    //
    // If the caller also asked for the attributes of the trust, look up the
    // domain in the list of directly trusted domains
    //

    if ( TrustDirection ||
         TrustType ||
         TrustAttributes ) {

        Status = LsarQueryTrustedDomainInfoByName(
                     LsapPolicyHandle,
                     (PLSAPR_UNICODE_STRING)TrustedDomainName,
                     TrustedDomainInformationEx,
                     (PLSAPR_TRUSTED_DOMAIN_INFO *)&TrustedDomainInformation
                     );

        if ( NT_SUCCESS( Status )) {

            Type = TrustedDomainInformation->TrustType;
            Direction = TrustedDomainInformation->TrustDirection;
            Attributes = TrustedDomainInformation->TrustAttributes;

        } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

            Status = STATUS_SUCCESS;
        }
    }

Cleanup:

    if ( NT_SUCCESS( Status ) &&
         *WithinForest ) {

        if ( TrustDirection ) {

            *TrustDirection = Direction;
        }

        if ( TrustType ) {

            *TrustType = Type;
        }

        if ( TrustAttributes ) {

            *TrustAttributes = Attributes;
        }

        if ( TrustedDomainSid && Sid ) {

            Status = LsapDuplicateSid(
                         TrustedDomainSid,
                         Sid
                         );
        }

    } else {

        if ( TrustedDomainSid ) {

            *TrustedDomainSid = NULL;
        }

        if ( TrustDirection ) {

            *TrustDirection = 0;
        }

        if ( TrustType ) {

            *TrustType = 0;
        }

        if ( TrustAttributes ) {

            *TrustAttributes = 0;
        }
    }

    MIDL_user_free( MatchSid );

    LsaIFree_LSAPR_POLICY_INFORMATION(
        PolicyDnsDomainInformation,
        ( PLSAPR_POLICY_INFORMATION )PolicyDnsDomainInfo
        );

    LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
        TrustedDomainInformationEx,
        (PLSAPR_TRUSTED_DOMAIN_INFO)TrustedDomainInformation
        );

    return Status;
}



NTSTATUS
LsapIsValidDomainSid(
    IN PSID DomainSid
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BYTE TempDomainSid[ SECURITY_MAX_SID_SIZE ];
    DWORD SidLength = sizeof( TempDomainSid );

    if( !RtlValidSid( DomainSid ) ) {

        Status = STATUS_INVALID_SID;
        goto Error;
    }

    if ( FALSE == GetWindowsAccountDomainSid(
                      DomainSid,
                      ( PSID ) TempDomainSid,
                      &SidLength )) {

        DWORD ErrorCode = GetLastError();

        switch( ErrorCode ) {

        case ERROR_INVALID_SID:
            //
            // We have already checked the SID for validity
            //
            ASSERT( FALSE );
            //
            // fall through
            //
        case ERROR_NON_ACCOUNT_SID:
        case ERROR_NON_DOMAIN_SID:

            Status = STATUS_INVALID_SID;
            break;

        case ERROR_INVALID_PARAMETER:

            //
            // What invalid parameter?
            //
            ASSERT( FALSE );
            Status = STATUS_INVALID_PARAMETER;
            break;

        case ERROR_INSUFFICIENT_BUFFER:

            //
            // The buffer we supplied must be enough
            //
            ASSERT( FALSE );
            Status = STATUS_BUFFER_OVERFLOW;
            break;

        default:

            //
            // map the error
            //
            ASSERT( FALSE );
            Status = STATUS_INTERNAL_ERROR;
            break;
        }

        goto Error;

    } else {

        //
        // For domain SIDs, GetWindowsAccountDomainSid returns a SID equal to the one passed in.
        // If the two SIDs are not equal, the SID passed in is not a true domain SID
        //

        if ( !RtlEqualSid(
                  ( PSID )DomainSid,
                  ( PSID )TempDomainSid )) {

            Status = STATUS_INVALID_SID;
            goto Error;
        }
    }

Cleanup:

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));

    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dspolicy\dbftrust.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbftrust.h

Abstract:

    Forest trust cache class declaration

--*/

#ifndef __FTCACHE_H
#define __FTCACHE_H

class FTCache
{
friend NTSTATUS
       LsarSetForestTrustInformation(
           IN LSAPR_HANDLE PolicyHandle,
           IN LSA_UNICODE_STRING * TrustedDomainName,
           IN LSA_FOREST_TRUST_RECORD_TYPE HighestRecordType,
           IN LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo,
           IN BOOLEAN CheckOnly,
           OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo );

friend NTSTATUS
       LsapForestTrustCacheInsert(
           IN UNICODE_STRING * TrustedDomainName,
           IN OPTIONAL PSID TrustedDomainSid,
           IN LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo,
           IN BOOLEAN LocalForestEntry );

public:

     FTCache();
    ~FTCache();

    NTSTATUS Initialize();

    void SetLocalValid() { m_LocalValid = TRUE; }
    void SetExternalValid() { m_ExternalValid = TRUE; }
    void SetInvalid();
    BOOLEAN IsLocalValid() { return m_LocalValid; }
    BOOLEAN IsExternalValid() { return m_ExternalValid; }

    NTSTATUS
    Remove(
        IN UNICODE_STRING * TrustedDomainName );

    NTSTATUS
    Retrieve(
        IN UNICODE_STRING * TrustedDomainName,
        OUT LSA_FOREST_TRUST_INFORMATION * * ForestTrustInfo );

    NTSTATUS
    Match(
        IN LSA_ROUTING_MATCH_TYPE Type,
        IN PVOID Data,
        IN BOOLEAN SearchLocal,
        OUT OPTIONAL UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL PSID * TrustedDomainSid );

#if !defined(LSAEXTS) // anything in lsaexts.cxx gets full access
private:
#endif

    BOOLEAN m_Initialized;
    BOOLEAN m_LocalValid;
    BOOLEAN m_ExternalValid;

    RTL_AVL_TABLE m_TdoTable;
    RTL_AVL_TABLE m_TopLevelNameTable;
    RTL_AVL_TABLE m_DomainSidTable;
    RTL_AVL_TABLE m_DnsNameTable;
    RTL_AVL_TABLE m_NetbiosNameTable;

    //
    // Every TDO the forest trust information for which is stored in the
    // cache is going to have an entry like this created for it.
    // This way, retrieving and setting information for a particular TDO
    // can be performed efficiently.
    //

    struct TDO_ENTRY {

        UNICODE_STRING TrustedDomainName; // name of the corresponding TDO
        PSID TrustedDomainSid;      // SID of the corresponding TDO
        LIST_ENTRY TlnList;         // list of top level name entries for this TDO list entry
        LIST_ENTRY DomainInfoList;  // list of domain info entries for this TDO
        LIST_ENTRY BinaryList;      // list of unrecognized entries for this TDO list entry
        ULONG RecordCount;          // combined number of records
        BOOLEAN LocalForestEntry;   // does this entry correspond to the local forest?

        BOOLEAN Excludes( IN const UNICODE_STRING * Name );

#pragma warning(disable:4200)
        WCHAR TrustedDomainNameBuffer[];
#pragma warning(default:4200)
    };

    //
    // Top level name key for AVL tree lookups
    // Contains a top level name and a list of entries matching this TLN
    //

    struct TLN_KEY {

        UNICODE_STRING TopLevelName; // MUST be the first field
        ULONG Count;                 // Number of entries under this key
        LIST_ENTRY List;             // List of entries under this key

#pragma warning(disable:4200)
        WCHAR TopLevelNameBuffer[];
#pragma warning(default:4200)
    };

    //
    // Top level name entry for AVL tree lookups
    //

    struct TLN_ENTRY {

        //
        // This 'friend' relationship is a work-around for an ia64 compiler
        // bug that causes FTCache::TDO_ENTRY::Excludes to fail access control
        //

        friend BOOLEAN
        TDO_ENTRY::Excludes( IN const UNICODE_STRING * Name );

        LIST_ENTRY TdoListEntry;
        LIST_ENTRY AvlListEntry;
        LARGE_INTEGER Time;
        BOOLEAN Excluded;
        ULONG Index;
        TDO_ENTRY * TdoEntry;
        union {
            TLN_ENTRY * SubordinateEntry; // for regular entries
            TLN_ENTRY * SuperiorEntry;    // for excluded entries
        };
        TLN_KEY * TlnKey;

        BOOLEAN Enabled() {

            return Excluded ?
                       FALSE :
                       SubordinateEntry ?
                          SubordinateEntry->Enabled() :
                          (( m_Flags & LSA_FTRECORD_DISABLED_REASONS ) == 0 );
        }

        ULONG Flags() {

            return Excluded ?
                       m_Flags :
                       SubordinateEntry ?
                          SubordinateEntry->Flags() :
                          m_Flags;
        }

        void SetFlags( IN ULONG NewValue ) {

            if ( Excluded ) {

                m_Flags = NewValue; // value ignored for excluded entries

            } else if ( SubordinateEntry ) {

                SubordinateEntry->SetFlags( NewValue );

            } else {

                m_Flags = NewValue;
            }
        }

        static TLN_ENTRY *
        EntryFromTdoEntry( IN LIST_ENTRY * ListEntry ) {

            return CONTAINING_RECORD(
                       ListEntry,
                       TLN_ENTRY,
                       TdoListEntry
                       );
        }

        static TLN_ENTRY *
        EntryFromAvlEntry( IN LIST_ENTRY * ListEntry ) {

            return CONTAINING_RECORD(
                       ListEntry,
                       TLN_ENTRY,
                       AvlListEntry
                       );
        }

#if !defined(LSAEXTS) // anything in lsaexts.cxx gets full access
        private:
#endif

        ULONG m_Flags;
    };

    //
    // Domain SID key for AVL tree lookups
    // Contains a domain SID and a list of entries matching this domain SID
    //

    struct DOMAIN_SID_KEY {

        SID * DomainSid;    // MUST be the first field
        ULONG Count;        // Number of entries under this key
        LIST_ENTRY List;    // List of entries under this key

#pragma warning(disable:4200)
        ULONG SidBuffer[];
#pragma warning(default:4200)
    };

    //
    // DNS name key for AVL tree lookups
    // Contains a domain name and a list of entries matching this DNS name
    //

    struct DNS_NAME_KEY {

        UNICODE_STRING DnsName;   // MUST be the first field
        ULONG Count;              // Number of entries under this key
        LIST_ENTRY List;          // List of entries under this key

#pragma warning(disable:4200)
        WCHAR DnsNameBuffer[];
#pragma warning(default:4200)
    };

    //
    // Netbios name key for AVL tree lookups
    // Contains a Netbios name and a list of entries matching this Netbios name
    //

    struct NETBIOS_NAME_KEY {

        UNICODE_STRING NetbiosName; // MUST be the first field
        ULONG Count;                // Number of entries under this key
        LIST_ENTRY List;            // List of entries under this key

#pragma warning(disable:4200)
        WCHAR NetbiosNameBuffer[];
#pragma warning(default:4200)
    };

    //
    // Domain info entry for AVL tree lookups
    //

    struct DOMAIN_INFO_ENTRY {

        LIST_ENTRY TdoListEntry;
        LIST_ENTRY SidAvlListEntry;
        LIST_ENTRY DnsAvlListEntry;
        LIST_ENTRY NetbiosAvlListEntry;
        LARGE_INTEGER Time;
        ULONG Index;
        SID * Sid;
        TDO_ENTRY * TdoEntry;
        TLN_ENTRY * SubordinateTo;
        DOMAIN_SID_KEY * SidKey;
        DNS_NAME_KEY * DnsKey;
        NETBIOS_NAME_KEY * NetbiosKey;

#define SID_DISABLED_MASK ( LSA_SID_DISABLED_ADMIN | LSA_SID_DISABLED_CONFLICT )
        BOOLEAN SidEnabled() { return (( m_Flags & SID_DISABLED_MASK ) == 0 ); }

#define NETBIOS_DISABLED_MASK ( LSA_NB_DISABLED_ADMIN | LSA_NB_DISABLED_CONFLICT )
        BOOLEAN NetbiosEnabled() { return (( m_Flags & ( SID_DISABLED_MASK | NETBIOS_DISABLED_MASK )) == 0 ); }

        ULONG Flags() { return m_Flags; }

        void SetFlags( IN ULONG NewValue ) {

            m_Flags = NewValue;
        }

        void SetSidConflict() {

            SetFlags( Flags() | LSA_SID_DISABLED_CONFLICT );
        }

        void SetNetbiosConflict() {

            SetFlags( Flags() | LSA_NB_DISABLED_CONFLICT );
        }

        BOOLEAN IsSidAdminDisabled() {

            return ( 0 != ( Flags() && LSA_SID_DISABLED_ADMIN ));
        }

        BOOLEAN IsNbAdminDisabled() {

            return ( 0 != ( Flags() && LSA_NB_DISABLED_ADMIN ));
        }

        static DOMAIN_INFO_ENTRY *
        EntryFromTdoEntry( IN LIST_ENTRY * ListEntryTdo ) {

            return CONTAINING_RECORD(
                       ListEntryTdo,
                       DOMAIN_INFO_ENTRY,
                       TdoListEntry
                       );
        }

        static DOMAIN_INFO_ENTRY *
        EntryFromSidEntry( IN LIST_ENTRY * ListEntrySid ) {

            return CONTAINING_RECORD(
                       ListEntrySid,
                       DOMAIN_INFO_ENTRY,
                       SidAvlListEntry
                       );
        }

        static DOMAIN_INFO_ENTRY *
        EntryFromDnsEntry( IN LIST_ENTRY * ListEntryDns ) {

            return CONTAINING_RECORD(
                       ListEntryDns,
                       DOMAIN_INFO_ENTRY,
                       DnsAvlListEntry
                       );
        }

        static DOMAIN_INFO_ENTRY *
        EntryFromNetbiosEntry( IN LIST_ENTRY * ListEntryNB ) {

            return CONTAINING_RECORD(
                       ListEntryNB,
                       DOMAIN_INFO_ENTRY,
                       NetbiosAvlListEntry
                       );
        }

#if !defined(LSAEXTS) // anything in lsaexts.cxx gets full access
        private:
#endif

        ULONG m_Flags;
    };

    struct BINARY_ENTRY {

        LIST_ENTRY TdoListEntry;
        LARGE_INTEGER Time;
        LSA_FOREST_TRUST_RECORD_TYPE Type;
        LSA_FOREST_TRUST_BINARY_DATA Data;

        BOOLEAN Enabled() { return (( m_Flags & LSA_FTRECORD_DISABLED_REASONS ) == 0 ); }

        ULONG Flags() { return m_Flags; }

        void SetFlags( IN ULONG NewValue ) {

            m_Flags = NewValue;
        }

        static BINARY_ENTRY *
        EntryFromTdoEntry( IN LIST_ENTRY * ListEntry ) {

            return CONTAINING_RECORD(
                       ListEntry,
                       BINARY_ENTRY,
                       TdoListEntry
                       );
        }

#if !defined(LSAEXTS) // anything in lsaexts.cxx gets full access
        private:
#endif

        ULONG m_Flags;
    };

    struct CONFLICT_PAIR {

        LSA_FOREST_TRUST_RECORD_TYPE EntryType1;

        union {
            void * Entry1;
            TLN_ENTRY * TlnEntry1;
            DOMAIN_INFO_ENTRY * DomainInfoEntry1;
        };

        ULONG Flag1;

        LSA_FOREST_TRUST_RECORD_TYPE EntryType2;

        union {
            void * Entry2;
            TLN_ENTRY * TlnEntry2;
            DOMAIN_INFO_ENTRY * DomainInfoEntry2;
        };

        ULONG Flag2;

        TDO_ENTRY * TdoEntry1() {

            switch ( EntryType1 ) {

            case ForestTrustTopLevelName:
            case ForestTrustTopLevelNameEx:

                ASSERT( TlnEntry1 );
                ASSERT( TlnEntry1->TdoEntry );

                return TlnEntry1->TdoEntry;

            case ForestTrustDomainInfo:

                ASSERT( DomainInfoEntry1 );
                ASSERT( DomainInfoEntry1->TdoEntry );

                return DomainInfoEntry1->TdoEntry;

            default:

                ASSERT( FALSE ); // who created this entry??? it makes no sense.
                return NULL;
            }
        }

        TDO_ENTRY * TdoEntry2() {

            switch ( EntryType2 ) {

            case ForestTrustTopLevelName:
            case ForestTrustTopLevelNameEx:

                ASSERT( TlnEntry2 );
                ASSERT( TlnEntry2->TdoEntry );

                return TlnEntry2->TdoEntry;

            case ForestTrustDomainInfo:

                ASSERT( DomainInfoEntry2 );
                ASSERT( DomainInfoEntry2->TdoEntry );

                return DomainInfoEntry2->TdoEntry;

            default:

                ASSERT( FALSE ); // who created this entry??? it makes no sense.
                return NULL;
            }
        }

        void DisableEntry1() {

            switch ( EntryType1 ) {

            case ForestTrustTopLevelName:
            case ForestTrustTopLevelNameEx:

                TlnEntry1->SetFlags( TlnEntry1->Flags() | Flag1 );
                break;

            case ForestTrustDomainInfo:

                DomainInfoEntry1->SetFlags( DomainInfoEntry1->Flags() | Flag1 );
                break;

            default:
                ASSERT( FALSE ); // who created this entry??? it makes no sense.
                break;
            }
        }

        void DisableEntry2() {

            switch ( EntryType2 ) {

            case ForestTrustTopLevelName:
            case ForestTrustTopLevelNameEx:

                TlnEntry2->SetFlags( TlnEntry2->Flags() | Flag2 );
                break;

            case ForestTrustDomainInfo:

                DomainInfoEntry2->SetFlags( DomainInfoEntry2->Flags() | Flag2 );
                break;

            default:
                ASSERT( FALSE ); // who created this entry??? it makes no sense.
                break;
            }
        }
    };

    BOOLEAN
    IsEmpty() { return NULL != RtlEnumerateGenericTableAvl( &m_TdoTable, TRUE ); }

    NTSTATUS
    Insert(
        IN UNICODE_STRING * TrustedDomainName,
        IN OPTIONAL PSID TrustedDomainSid,
        IN LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo,
        IN BOOLEAN LocalForestEntry,
        OUT TDO_ENTRY * TdoEntryOld,
        OUT TDO_ENTRY * * TdoEntryNew,
        OUT CONFLICT_PAIR * * ConflictPairs,
        OUT ULONG * ConflictPairsTotal );

    static
    void
    ReconcileConflictPairs(
        IN OPTIONAL const TDO_ENTRY * TdoEntry,
        IN CONFLICT_PAIR * ConflictPairs,
        IN ULONG ConflictPairsTotal );

    static
    NTSTATUS
    GenerateConflictInfo(
        IN CONFLICT_PAIR * ConflictPairs,
        IN ULONG ConflictPairsTotal,
        IN TDO_ENTRY * TdoEntry,
        OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo );

    static
    NTSTATUS
    MarshalBlob(
        IN TDO_ENTRY * TdoEntry,
        OUT ULONG * MarshaledSize,
        OUT PBYTE * MarshaledBlob );

    void Purge();

    void
    RollbackChanges(
        IN TDO_ENTRY * TdoEntryNew,
        IN TDO_ENTRY * TdoEntryOld );

    void
    PurgeTdoEntry( IN TDO_ENTRY * TdoEntry );

    void
    RemoveTdoEntry( IN TDO_ENTRY * TdoEntry );

    static
    void
    CopyTdoEntry(
        IN TDO_ENTRY * Destination,
        IN TDO_ENTRY * Source );

    LSA_FOREST_TRUST_RECORD * RecordFromTopLevelNameEntry( IN TLN_ENTRY * Entry );
    LSA_FOREST_TRUST_RECORD * RecordFromDomainInfoEntry( IN DOMAIN_INFO_ENTRY * Entry );
    LSA_FOREST_TRUST_RECORD * RecordFromBinaryEntry( IN BINARY_ENTRY * Entry );

    NTSTATUS
    MatchSid(
        IN SID * Sid,
        OUT BOOLEAN * IsLocal,
        OUT OPTIONAL UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL PSID * TrustedDomainSid );

    NTSTATUS
    MatchDnsName(
        IN UNICODE_STRING * String,
        OUT BOOLEAN * IsLocal,
        OUT OPTIONAL UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL PSID * TrustedDomainSid );

    NTSTATUS
    MatchNetbiosName(
        IN UNICODE_STRING * String,
        OUT BOOLEAN * IsLocal,
        OUT OPTIONAL UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL PSID * TrustedDomainSid );

    NTSTATUS
    MatchUpn(
        IN UNICODE_STRING * String,
        OUT BOOLEAN * IsLocal,
        OUT OPTIONAL UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL PSID * TrustedDomainSid );

    NTSTATUS
    MatchSpn(
        IN UNICODE_STRING * String, 
        OUT BOOLEAN * IsLocal,
        OUT OPTIONAL UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL PSID * TrustedDomainSid );

    NTSTATUS
    MatchNamespace(
        IN UNICODE_STRING * String, 
        OUT BOOLEAN * IsLocal,
        OUT OPTIONAL UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL PSID * TrustedDomainSid );

    TLN_ENTRY *
    LongestSubstringMatchTln(
        OUT BOOLEAN * IsLocal,
        IN UNICODE_STRING * String );

    static
    NTSTATUS
    AddConflictPair(
        IN OUT CONFLICT_PAIR * * ConflictPairs,
        IN OUT ULONG * ConflictPairTotal,
        IN LSA_FOREST_TRUST_RECORD_TYPE Type1,
        IN void * Conflict1,
        IN ULONG Flag1,
        IN LSA_FOREST_TRUST_RECORD_TYPE Type2,
        IN void * Conflict2,
        IN ULONG Flag2 );

    void
    AuditChanges(
        IN const TDO_ENTRY * OldEntry,
        IN const TDO_ENTRY * NewEntry );

    void
    AuditCollisions(
        IN CONFLICT_PAIR * ConflictPairs,
        IN ULONG ConflictPairsTotal );

#if DBG

    //
    // Debug-only statistics
    //

    static DWORD sm_TdoEntries;
    static DWORD sm_TlnEntries;
    static DWORD sm_DomainInfoEntries;
    static DWORD sm_BinaryEntries;
    static DWORD sm_TlnKeys;
    static DWORD sm_SidKeys;
    static DWORD sm_DnsNameKeys;
    static DWORD sm_NetbiosNameKeys;

#endif
};

#endif // __FTCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dspolicy\dbinstal.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbinstal.c

Abstract:

    LSA Protected Subsystem - Database Installation.

    This module contains code which will create an initial LSA Database
    if none exists.  Temporarily, this code is executed from within
    LSA Initialization.  This code will form part of the Security
    Installation applet when implemented.

    WARNING!  THE CODE IN THIS MODULE IS TEMPORARY.  IT WILL BE REPLACED
    BY SYSTEM INSTALLATION FUNCTIONALITY.

Author:

    Scott Birrell       (ScottBi)       August 2, 1991

Environment:

    User mode - Does not depend on Windows.

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"

VOID
LsapDbSetDomainInfo(
    IN PLSAP_DB_ATTRIBUTE *NextAttribute,
    IN ULONG              *AttributeCount
    );

NTSTATUS
LsapDbGetNextValueToken(
    IN PUNICODE_STRING Value,
    IN OUT PULONG ParseContext,
    OUT PUNICODE_STRING *ReturnString
    );

NTSTATUS
LsapDbInstallLsaDatabase(
    ULONG Pass
    )

/*++

Routine Description:

    This function installs an initial LSA Database.  Any existing database
    will be reset to have its initial attributes.

Arguments:

    Pass - Either 1 or 2.  During pass 1 all information that is
        not product type-specific is initialized.  In pass 2,
        the product type-specific stuff is initialized.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status;

    //
    // Install the LSA Database Policy Object.
    //

    Status = LsapDbInstallPolicyObject(Pass);

    return(Status);
}


NTSTATUS
LsapDbInstallPolicyObject(
    IN ULONG Pass
    )

/*++

Routine Description:

    This function installs the LSA Database Policy Object, setting its attributes
    to the default state.  It is called as part of the LSA Database
    Installation Procedure.

Arguments:

    Pass - Either 1 or 2.  During pass 1 all information that is
        not product type-specific is initialized.  In pass 2,
        the product type-specific stuff is initialized.

Return Value:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    LSAP_DB_HANDLE Handle;
    POLICY_LSA_SERVER_ROLE ServerRole;
    LSAP_DB_POLICY_PRIVATE_DATA PolicyPrivateData;
    LSARM_POLICY_AUDIT_EVENTS_INFO InitialAuditEventInformation;
    POLICY_AUDIT_LOG_INFO InitialAuditLogInformation;
    LSAP_DB_ATTRIBUTE Attributes[21];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    ULONG AttributeCount = 0;
    BOOLEAN ObjectReferenced = FALSE;
    ULONG Revision;
    LSAP_DB_ENCRYPTION_KEY NewEncryptionKey;
    ULONG                  SyskeyLength;
    PVOID                  Syskey;
    QUOTA_LIMITS InstalledQuotaLimits;

    NextAttribute = Attributes;

    LsapDiagPrint( DB_INIT,
                   ("LSA (init): Performing pass %d of LSA Policy Initialization\n",
                    Pass ) );

    if (Pass == 1) {

        //
        // Set up the Object Information for creating the Policy Object.
        // Note that we put NULL for Security Quality Of Service since this
        // open does not involve impersonation.
        //

        ObjectInformation.ObjectTypeId = PolicyObject;
        ObjectInformation.Sid = NULL;
        ObjectInformation.ObjectAttributeNameOnly = FALSE;

        InitializeObjectAttributes(
            &ObjectInformation.ObjectAttributes,
            &LsapDbNames[Policy],
            0L,
            NULL,
            NULL
        );

        Handle = LsapDbHandle;

        //
        // Create the revision attribute
        //

        Revision = LSAP_DB_REVISION_1_7;
        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolRevision],
            &Revision,
            sizeof (ULONG),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Install initial Private Data.  For now, just one ULONG is stored.
        //

        PolicyPrivateData.NoneDefinedYet = 0;

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolState],
            &PolicyPrivateData,
            sizeof (LSAP_DB_POLICY_PRIVATE_DATA),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Initialize the Policy Modification Info.  Set the Modification
        // Id to 1 and set the Database Creation Time to the current time.
        //

        LsapDbState.PolicyModificationInfo.ModifiedId =
            RtlConvertUlongToLargeInteger( (ULONG) 1 );

        Status = NtQuerySystemTime(
                     &LsapDbState.PolicyModificationInfo.DatabaseCreationTime
                     );

        if (!NT_SUCCESS(Status)) {
            goto InstallPolicyObjectError;
        }

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolMod],
            &LsapDbState.PolicyModificationInfo,
            sizeof (POLICY_MODIFICATION_INFO),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Initialize Default Event Auditing Options.  No auditing is specified
        // for any event type.  These will be set in the Policy Database later
        // when the Policy Object is created.
        //

        Status = LsapAdtInitializeDefaultAuditing(
                     (ULONG) 0,
                     &InitialAuditEventInformation
                     );

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolAdtEv],
            &InitialAuditEventInformation,
            sizeof (LSARM_POLICY_AUDIT_EVENTS_INFO),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Create the Containing Directory "Accounts" for the user and group
        // accounts objects.
        //

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[Accounts],
            NULL,
            0L,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Create the Containing Directory "Domains" for the Trusted Domain
        // objects.
        //

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[Domains],
            NULL,
            0L,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Create the Containing Directory "Secrets" for the Secret objects.
        //

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[Secrets],
            NULL,
            0L,
            FALSE
            );

        //
        // Create the Lsa Database Policy Object, opening the existing one if
        // it exists.
        //

        NextAttribute++;
        AttributeCount++;

        //////////////////////////////////////////////////
        //                                              //
        // ATTRIBUTES BELOW THIS POINT ARE INITIALIZED  //
        // IN PASS 1, BUT MAY BE CHANGED IN PASS 2.     //
        // IN GENERAL, THINGS ARE SET FOR A WIN-NT PROD //
        // AND CHANGED IN PASS 2 IF NECESSARY.          //
        //                                              //
        //////////////////////////////////////////////////

        //
        // Initialize the default installed quota limit values
        // ALL THIS QUOTA STUFF SHOULD REALLY BE PULLED - it's not used for anything
        //

#define LSAP_DB_WINNT_PAGED_POOL            (0x02000000L)
#define LSAP_DB_WINNT_NON_PAGED_POOL        (0x00100000L)
#define LSAP_DB_WINNT_MIN_WORKING_SET       (0x00010000L)
#define LSAP_DB_WINNT_MAX_WORKING_SET       (0x0f000000L)
#define LSAP_DB_WINNT_PAGEFILE              (0x0f000000L)

        InstalledQuotaLimits.PagedPoolLimit = LSAP_DB_WINNT_PAGED_POOL;
        InstalledQuotaLimits.NonPagedPoolLimit = LSAP_DB_WINNT_NON_PAGED_POOL;
        InstalledQuotaLimits.MinimumWorkingSetSize = LSAP_DB_WINNT_MIN_WORKING_SET;
        InstalledQuotaLimits.MaximumWorkingSetSize = LSAP_DB_WINNT_MAX_WORKING_SET;

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[DefQuota],
            &InstalledQuotaLimits,
            sizeof (QUOTA_LIMITS),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Initialize the audit log information.
        //

        InitialAuditLogInformation.MaximumLogSize = 8*1024;
        InitialAuditLogInformation.AuditLogPercentFull = 0;
        InitialAuditLogInformation.AuditRetentionPeriod.LowPart = 0x823543;
        InitialAuditLogInformation.AuditRetentionPeriod.HighPart = 0;
        InitialAuditLogInformation.AuditLogFullShutdownInProgress = FALSE;
        InitialAuditLogInformation.TimeToShutdown.LowPart = 0x46656;
        InitialAuditLogInformation.TimeToShutdown.HighPart = 0;

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolAdtLg],
            &InitialAuditLogInformation,
            sizeof (POLICY_AUDIT_LOG_INFO),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Initialize the syskey
        //

        Status =  LsapDbSetupInitialSyskey(
                        &SyskeyLength,
                        &Syskey
                        );

        if (!NT_SUCCESS(Status)) {
            LsapLogError(
                "LsapDbInstallPolicyObject: Syskey setup failed 0x%lx\n",
                 Status
                );

            goto InstallPolicyObjectError;
        }

        //
        // Initialize the key for secret encryption
        //

        Status = LsapDbGenerateNewKey(
                    &NewEncryptionKey
                    );

        if (!NT_SUCCESS(Status)) {
            LsapLogError(
                "LsapDbInstallPolicyObject: New key generation failed 0x%lx\n",
                Status
                );

            goto InstallPolicyObjectError;
        }

        //
        // Encrypt the key with syskey
        //

        LsapDbEncryptKeyWithSyskey(
                &NewEncryptionKey,
                Syskey,
                SyskeyLength
                );

        //
        // Set the global variable LsapDbSyskey to reflect this value
        //

        LsapDbSysKey = Syskey;

        //
        // Add the attribute for the list of attributes to be added to the database.
        //

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolSecretEncryptionKey],
            &NewEncryptionKey,
            sizeof (NewEncryptionKey),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        Status = LsapDbCreateObject(
                     &ObjectInformation,
                     GENERIC_ALL,
                     LSAP_DB_OBJECT_OPEN_IF,
                     LSAP_DB_TRUSTED,
                     Attributes,
                     &AttributeCount,
                     RTL_NUMBER_OF(Attributes),
                     &LsapDbHandle
                     );

        if (!NT_SUCCESS(Status)) {

            LsapLogError(
                "LsapDbInstallPolicyObject: Create Policy object failed 0x%lx\n",
                Status
                );

            LsapDiagPrint( DB_INIT,
                           ("LSA (init): Attributes passed to CreateObject call:\n\n"
                            "                      Count: %d\n"
                            "              Array Address: 0x%lx",
                            AttributeCount, Attributes) );

            ASSERT(NT_SUCCESS(Status));     // Provide a debug opportunity

            goto InstallPolicyObjectError;
        }

    } else if (Pass == 2) {

        //
        // Set up the account objects necessary to implement the default
        // Microsoft Policy for privilege assignment and system access
        // capabilities.
        //

        Status = LsapDbInstallAccountObjects();

        if (!NT_SUCCESS(Status)) {

            KdPrint(("LSA DB INSTALL: Installation of account objects failed.\n"
                    "               Status: 0x%lx\n", Status));
            goto InstallPolicyObjectError;
        }

        //
        // Set up the account domain and primary domain information
        // ONLY if the real setup wasn't run.  In that case, we are
        // doing a pseudo setup as part of a developer's first boot.
        //

        if (!LsapSetupWasRun) {

            LsapDbSetDomainInfo( &NextAttribute, &AttributeCount );
        }

        if (LsapProductType == NtProductLanManNt) {

            //
            // Audit log information was set for WinNt product
            // in pass 1.  Change if necessary in this pass.
            //

            InitialAuditLogInformation.MaximumLogSize = 20*1024;
            InitialAuditLogInformation.AuditLogPercentFull = 0;
            InitialAuditLogInformation.AuditRetentionPeriod.LowPart = 0x823543;
            InitialAuditLogInformation.AuditRetentionPeriod.HighPart = 0;
            InitialAuditLogInformation.AuditLogFullShutdownInProgress = FALSE;
            InitialAuditLogInformation.TimeToShutdown.LowPart = 0x46656;
            InitialAuditLogInformation.TimeToShutdown.HighPart = 0;

            LsapDbInitializeAttribute(
                NextAttribute,
                &LsapDbNames[PolAdtLg],
                &InitialAuditLogInformation,
                sizeof (POLICY_AUDIT_LOG_INFO),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;
        }

        if (AttributeCount > 0) {

            Status = LsapDbReferenceObject(
                        LsapDbHandle,
                        0,
                        PolicyObject,
                        PolicyObject,
                        LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION
                        );

            if (!NT_SUCCESS(Status)) {

                LsapDiagPrint( DB_INIT,
                               ("LSA (init): Internal reference of Policy object failed.\n"
                                "            Status of LsapDbReferenceObject == 0x%lx\n",
                                Status) );
                goto InstallPolicyObjectError;
            }

            ObjectReferenced = TRUE;

            Status = LsapDbWriteAttributesObject(
                         LsapDbHandle,
                         Attributes,
                         AttributeCount
                         );

            if (!NT_SUCCESS(Status)) {

                LsapDiagPrint( DB_INIT,
                               ("LSA (init): Update of Policy attributes failed.\n"
                                "            Attributes:\n\n"
                                "                      Count: %d\n"
                                "              Array Address: 0x%lx",
                                AttributeCount, Attributes) );
                goto InstallPolicyObjectError;
            }

            Status = LsapDbDereferenceObject(
                         &LsapDbHandle,
                         PolicyObject,
                         PolicyObject,
                         (LSAP_DB_LOCK |
                         LSAP_DB_FINISH_TRANSACTION),
                         (SECURITY_DB_DELTA_TYPE) 0,
                         STATUS_SUCCESS
                         );

            if (!NT_SUCCESS(Status)) {

                LsapLogError(
                    "LsapDbInstallPolicyObject: Pass 2 DB init failed. 0x%lx\n",
                    Status
                    );

                goto InstallPolicyObjectError;
            }

            ObjectReferenced = FALSE;
        }
    }

InstallPolicyObjectFinish:

    //
    // If necessary, dereference the Policy Object.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &LsapDbHandle,
                     PolicyObject,
                     PolicyObject,
                     (LSAP_DB_LOCK |
                     LSAP_DB_FINISH_TRANSACTION),
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    return(Status);

InstallPolicyObjectError:

    if (Pass == 1) {

        LsapLogError(
            "LsapDbInstallPolicyObject: Pass 1 DB init failed. 0x%lx\n",
            Status
            );

    } else {

        LsapLogError(
            "LsapDbInstallPolicyObject: Pass 2 DB init failed. 0x%lx\n",
            Status
            );
    }

    goto InstallPolicyObjectFinish;
}



NTSTATUS
LsapDbGetConfig (
    IN HANDLE KeyHandle,
    IN PWSTR Name,
    OUT PUNICODE_STRING Value
    )

/*++

Routine Description:

    This routine obtains configuration information from the registry.

Arguments:

    KeyHandle - handle to registry key node containing value.

    Name - The name of a value under the specifed key node.

    Value - Fills in the string with the value of the parameter.  The
        returned string is zero terminated.  The buffer is allocated in
        Process Heap and should be deallocated by the caller.

Return Value:

    STATUS_SUCCESS - If the operation was successful.

    STATUS_NO_MEMORY - There wasn't enough memory to allocate a buffer
        to contain the returned information.

    STATUS_OBJECT_NAME_NOT_FOUND - The specifed section or the specified
        keyword could not be found.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING ValueName;
    ULONG Length, ResultLength;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;

    RtlInitUnicodeString( &ValueName, Name );
    Length = 512;
    KeyValueInformation = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    if (KeyValueInformation == NULL) {
        Status = STATUS_NO_MEMORY;
    } else {
        Status = NtQueryValueKey( KeyHandle,
                                  &ValueName,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  Length,
                                  &ResultLength
                                );
        if (NT_SUCCESS( Status )) {
            if (KeyValueInformation->Type != REG_SZ) {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }
        }
    }

    if (NT_SUCCESS( Status )) {
        Value->MaximumLength = (USHORT)(KeyValueInformation->DataLength);
        if (Value->MaximumLength >= sizeof(UNICODE_NULL)) {
            Value->Length = (USHORT)KeyValueInformation->DataLength -
                             sizeof( UNICODE_NULL);
        } else {
            Value->Length = 0;
        }
        Value->Buffer = (PWSTR)KeyValueInformation;
        RtlMoveMemory( Value->Buffer,
                       KeyValueInformation->Data,
                       Value->Length
                     );
        Value->Buffer[ Value->Length / sizeof( WCHAR ) ] = UNICODE_NULL;
        KeyValueInformation = NULL;
    } else {
#if DEVL
        DbgPrint( "LSA DB INSTALL: No '%wZ' value in registry - Status == %x\n", &ValueName, Status);
#endif //DEVL
    }

    if ( KeyValueInformation != NULL ) {
        RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInformation );
    }

    return Status;
}



NTSTATUS
LsapDbGetNextValueToken(
    IN PUNICODE_STRING Value,
    IN OUT PULONG ParseContext,
    OUT PUNICODE_STRING *ReturnString
    )

/*++

Routine Description:

    This routine is used to isolate the next token in a registry value.

    The token is returned in a single heap buffer containing both the
    STRING and the Buffer of that string containing the token.  The
    caller of this routine is responsible for deallocating the buffer
    when it is no longer needed.

    The string, although counted, will also be null terminated.

Arguments:

    Value - Supplies the value line being parsed.

    ParseContext - Is a pointer to a context state value.
        The first time this routine is called for a particular
        Value line, the value pointed to should be zero.  Thereafter,
        the value returned from the previous call should be passed.

    ReturnString - Returns a pointer to the allocated string.


Return Value:

    STATUS_SUCCESS - indicates the next token has been isolated.

    STATUS_INVALID_PARAMTER_1 - Indicates there were no more tokens in
            the Value line.

    STATUS_NO_MEMORY - memory could not be allocated for the token.

--*/

{
    ULONG i, j;
    ULONG TokenLength;
    ULONG AllocSize;

    //
    // Get to the beginning of the next token
    //

    for ( i = *ParseContext;
          i < (Value->Length/sizeof(WCHAR)) &&
            (Value->Buffer[i] == L' ' || Value->Buffer[i] == L'\t');
          i++ )
        ;

    //
    // see if we ran off the end of the string..
    //

    if (i >= (Value->Length/sizeof(WCHAR))) {
        return STATUS_INVALID_PARAMETER_1;
    }

    //
    // Now search for the end of the token
    //

    for ( j = i + 1;
          j < (Value->Length/sizeof(WCHAR)) &&
            Value->Buffer[j] != L' ' && Value->Buffer[j] != L'\t';
          j++ )
        ;

    *ParseContext = j;

    //
    // We've either reached the end of the string, or found the end of the
    // token.
    //

    //
    // If the caller actually wants the string returned,
    //  allocate and copy it.
    //

    if ( ARGUMENT_PRESENT( ReturnString ) ) {
        UNICODE_STRING SourceString;
        PUNICODE_STRING LocalString;

        TokenLength = (j-i) * sizeof(WCHAR);
        AllocSize = sizeof(UNICODE_STRING) + (TokenLength + sizeof( UNICODE_NULL ) + 4);

        LocalString = RtlAllocateHeap( RtlProcessHeap(), 0, AllocSize );
        if ( LocalString == NULL ) {
            DbgPrint("LSA DB INSTALL: LsapDbGetNextValueToken: Not enough memory %ld\n",
                AllocSize);
            return STATUS_NO_MEMORY;
        }
        LocalString->MaximumLength = (USHORT)(TokenLength + sizeof( UNICODE_NULL ));
        LocalString->Length = (USHORT)TokenLength;
        LocalString->Buffer = (PWCHAR)(LocalString + 1);

        //
        // Now copy the token
        //

        SourceString.MaximumLength = LocalString->Length;
        SourceString.Length = LocalString->Length;
        SourceString.Buffer = &Value->Buffer[i];

        RtlCopyUnicodeString( LocalString, &SourceString );

        //
        // Add a null terminator
        //

        LocalString->Buffer[LocalString->Length / sizeof( UNICODE_NULL )] = UNICODE_NULL;
        *ReturnString = LocalString;
    }

    return STATUS_SUCCESS;
}


VOID
LsapDbSetDomainInfo(
    IN PLSAP_DB_ATTRIBUTE *NextAttribute,
    IN ULONG              *AttributeCount
    )

/*

    This routine is only used for the pseudo setup for internal
    developer's use.  In a real product installation/setup
    situation, The functionality performed by this routine is
    performed by the text-mode setup supplemented by the network
    setup.

    This routine must establish values for the AccountDomain and
    PrimaryDomain attributes of the Policy object.  These
    attributes must be configured as follows:

    I.   Standalone Win-NT product

            AccountDomainName = "Account"
            AccountDomainSid  = (value assigned by user)
            PrimaryDomainName = Name of domain to use for browsing
                                (this is optional in this case)
            PrimaryDomainSid  = (None)

    II.  Non-Standalone Win-NT product

            AccountDomainName = "Account"
            AccountDomainSid  = (value assigned by user)
            PrimaryDomainName = (Primary domain's name)
            PrimaryDomainSid  = (Primary domain's SID)

    III. LanMan-NT product

            AccountDomainName = (Primary domain's name)
            AccountDomainSid  = (Primary domain's SID)
            PrimaryDomainName = (Primary domain's name)
            PrimaryDomainSid  = (Primary domain's SID)

    This routine only does (II) and (III).  The real setup must
    be capable of doing (I) as well.

*/

{
    NTSTATUS Status;
    NT_PRODUCT_TYPE ProductType;
    BOOLEAN ProductExplicitlySpecified;

    UNICODE_STRING PrimaryDomainName, AccountDomainName;
    PSID PrimaryDomainSid, AccountDomainSid;

    HANDLE KeyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyName;
    ULONG TempULong = 0 ;

    SID_IDENTIFIER_AUTHORITY TmppAuthority;
    ULONG DomainSubAuthorities[SID_MAX_SUB_AUTHORITIES];
    UCHAR DomainSubAuthorityCount = 0;

    ULONG i;
    ULONG Context = 0;
    PUNICODE_STRING Rid;
    ULONG Size;

    UNICODE_STRING DomainId;

    PrimaryDomainSid = NULL;
    AccountDomainSid = NULL;

    PrimaryDomainName.Buffer = NULL;
    DomainId.Buffer = NULL;

    //
    // Get the product type
    //

    ProductExplicitlySpecified =
        RtlGetNtProductType( &ProductType );

#if DBG
if (ProductType == NtProductLanManNt) {
    DbgPrint("LSA DB INSTALL:  Configuring LSA database for LanManNt system.\n");
} else {
    DbgPrint("LSA DB INSTALL:  Configuring LSA database for WinNt or Dedicated Server product.\n");
}
#endif //DBG

    //
    // Open a handle to the registry key node that contains the
    // interesting domain values (name, id, and account id)
    //

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters" );

    InitializeObjectAttributes(
                            &ObjectAttributes,
                            &KeyName,
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL);

    Status = NtOpenKey( &KeyHandle, KEY_READ, &ObjectAttributes );

    if (!NT_SUCCESS( Status )) {
#if DEVL
        DbgPrint( "LSA DB INSTALL: Unable to access registry key (%wZ) - Status == %x\n", &KeyName, Status );
#endif // DBG
        goto Exit;
    }

    //
    // Get the primary domain name from the registry
    //

    Status = LsapDbGetConfig(KeyHandle,
                           L"Domain",
                           &PrimaryDomainName);

    if ( !NT_SUCCESS( Status ) ) {
        goto Exit;
    }

    //
    // get the primary domain's SID
    //

    Status = LsapDbGetConfig(KeyHandle,
                           L"DomainId",
                           &DomainId );

    if ( !NT_SUCCESS( Status ) ) {
        goto Exit;
    }

    //
    // Get the Authority ID from the registry
    //

    for (i=0; i < sizeof(TmppAuthority.Value)/sizeof(TmppAuthority.Value[0]); i++ ) {

        Status = LsapDbGetNextValueToken( &DomainId, &Context, &Rid );

        if (NT_SUCCESS( Status )) {
            Status = RtlUnicodeStringToInteger(Rid, 10, &TempULong );
            RtlFreeHeap( RtlProcessHeap(), 0, Rid );
        }

        if ( !NT_SUCCESS( Status ) ) {
#if DBG
            DbgPrint("LSA DB INSTALL: domainid - must have at least %ld subauthorities\n",
                     sizeof(TmppAuthority.Value)/sizeof(TmppAuthority.Value[0]));
#endif //DBG

            goto Exit;
        }

        TmppAuthority.Value[i] = (UCHAR)TempULong;
    }

    //
    // Get some subauthorities from the registry
    //

    for (i=0; ; i++ ) {

        Status = LsapDbGetNextValueToken( &DomainId, &Context, &Rid );

        if (NT_SUCCESS( Status )) {
            Status = RtlUnicodeStringToInteger(Rid, 10, &TempULong );
            RtlFreeHeap( RtlProcessHeap(), 0, Rid );
        }

        if ( Status == STATUS_INVALID_PARAMETER_1 ) {
            break;
        }

        if ( !NT_SUCCESS( Status )) {
            goto Exit;
        }

        if ( i >= sizeof(DomainSubAuthorities)/sizeof(DomainSubAuthorities[0]) ) {
#if DBG
            DbgPrint("LSA DB INSTALL: domainid - "
              "Too many Domain subauthorities specified (%ld maximum).\n",
              sizeof(DomainSubAuthorities)/sizeof(DomainSubAuthorities[0]));
#endif //DBG

            goto Exit;
        }

        DomainSubAuthorities[i] = TempULong;
        DomainSubAuthorityCount ++;
    }

    //
    // Allocate memory to put the domain id in.
    //

    Size = RtlLengthRequiredSid( DomainSubAuthorityCount );

    PrimaryDomainSid = RtlAllocateHeap( RtlProcessHeap(), 0, Size );

    if (PrimaryDomainSid == NULL) {
        goto Exit;
    }

    Status = RtlInitializeSid( PrimaryDomainSid,
                              &TmppAuthority,
                               DomainSubAuthorityCount );

    if ( !NT_SUCCESS( Status )) {
        goto Exit;
    }

    for ( i=0; i < (ULONG) DomainSubAuthorityCount; i++ ) {
        *(RtlSubAuthoritySid(PrimaryDomainSid, i)) =
            DomainSubAuthorities[i];
    }

    if (ProductType != NtProductLanManNt) {

        DomainSubAuthorityCount = 0;
        Context = 0;

        //
        //  if the system is a WinNt product, then get the account domain
        //  SID from the registry info and set a well known name ("ACCOUNT").
        //

        RtlInitUnicodeString(&AccountDomainName,L"Account");

        //
        //  Free old DomainId data if it has been allocated previously
        //

        if (DomainId.Buffer != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, DomainId.Buffer );
            DomainId.Buffer = NULL;
        }

        Status = LsapDbGetConfig(KeyHandle,
                               L"AccountDomainId",
                               &DomainId );

        if ( !NT_SUCCESS( Status ) ) {
            goto Exit;
        }

        //
        // Get the Authority ID from the registry
        //

        for (i=0; i<sizeof(TmppAuthority.Value)/sizeof(TmppAuthority.Value[0]); i++ ) {

            Status = LsapDbGetNextValueToken( &DomainId, &Context, &Rid );
            if (NT_SUCCESS( Status )) {
                Status = RtlUnicodeStringToInteger(Rid, 10, &TempULong );
                RtlFreeHeap( RtlProcessHeap(), 0, Rid );
            }

            if ( !NT_SUCCESS( Status ) ) {
#if DBG
                DbgPrint("LSA DB INSTALL: AccountDomainId - must have at least %ld subauthorities\n",
                    sizeof(TmppAuthority.Value)/sizeof(TmppAuthority.Value[0]));
#endif //DBG
                goto Exit;
            }

            TmppAuthority.Value[i] = (UCHAR)TempULong;
        }

        //
        // Get some subauthorities from the registry
        //

        for (i=0; ; i++ ) {

            Status = LsapDbGetNextValueToken( &DomainId, &Context, &Rid );
            if (NT_SUCCESS( Status )) {
                Status = RtlUnicodeStringToInteger(Rid, 10, &TempULong );
                RtlFreeHeap( RtlProcessHeap(), 0, Rid );
            }

            if ( Status == STATUS_INVALID_PARAMETER_1 ) {
                break;
            }

            if ( !NT_SUCCESS( Status )) {
                goto Exit;
            }

            if ( i >=
                sizeof(DomainSubAuthorities)/sizeof(DomainSubAuthorities[0]) ) {
#if DBG
                DbgPrint("MsV1_0: NT.CFG: domainid - Too many Domain subauthorities specified (%ld maximum).\n",
                  sizeof(DomainSubAuthorities)/sizeof(DomainSubAuthorities[0]));
#endif //DBG
                goto Exit;
            }

            DomainSubAuthorities[i] = TempULong;
            DomainSubAuthorityCount ++;
        }

        //
        // Allocate memory to put the domain id in.
        //

        Size = RtlLengthRequiredSid( DomainSubAuthorityCount );

        AccountDomainSid = RtlAllocateHeap( RtlProcessHeap(), 0, Size );

        if (AccountDomainSid == NULL) {
            goto Exit;
        }

        RtlInitializeSid( AccountDomainSid,
                          &TmppAuthority,
                          DomainSubAuthorityCount );

        for ( i=0; i < (ULONG) DomainSubAuthorityCount; i++ ) {
            *(RtlSubAuthoritySid(AccountDomainSid, i)) =
                DomainSubAuthorities[i];
        }

    } else {

        //
        // Otherwise, the account domain is set up just like the
        // primary domain
        //

        AccountDomainName = PrimaryDomainName;

        Size = RtlLengthSid(PrimaryDomainSid);

        AccountDomainSid = RtlAllocateHeap( RtlProcessHeap(), 0, Size );

        if (AccountDomainSid == NULL) {
            goto Exit;
        }

        Status = RtlCopySid(
            Size,
            AccountDomainSid,
            PrimaryDomainSid);

        if ( !NT_SUCCESS( Status ) ) {
            goto Exit;
        }
    }

    //
    // Now add the attributes to be initialized in the policy object...
    //

    //
    // Primary domain name/sid
    //

    Status = LsapDbMakeUnicodeAttribute(
                 &PrimaryDomainName,
                 &LsapDbNames[PolPrDmN],
                 (*NextAttribute)
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Exit;
    }

    (*NextAttribute)++;
    (*AttributeCount)++;

    Status = LsapDbMakeSidAttribute(
                 PrimaryDomainSid,
                 &LsapDbNames[PolPrDmS],
                 (*NextAttribute)
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Exit;
    }

    PrimaryDomainSid = NULL;

    (*NextAttribute)++;
    (*AttributeCount)++;

    //
    // Account domain name/sid
    //

    Status = LsapDbMakeUnicodeAttribute(
                 &AccountDomainName,
                 &LsapDbNames[PolAcDmN],
                 (*NextAttribute)
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Exit;
    }

    (*NextAttribute)++;
    (*AttributeCount)++;

    Status = LsapDbMakeSidAttribute(
                 AccountDomainSid,
                 &LsapDbNames[PolAcDmS],
                 (*NextAttribute)
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Exit;
    }

    AccountDomainSid = NULL;

    (*NextAttribute)++;
    (*AttributeCount)++;

Exit:
    if (KeyHandle != NULL) {
        NtClose(KeyHandle);
    }

    if (DomainId.Buffer != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, DomainId.Buffer );
    }

    if (PrimaryDomainName.Buffer != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, PrimaryDomainName.Buffer);
    }

    if (PrimaryDomainSid != NULL) {
        RtlFreeHeap (RtlProcessHeap(), 0, PrimaryDomainSid);
    }

    if (AccountDomainSid != NULL) {
        RtlFreeHeap (RtlProcessHeap(), 0, AccountDomainSid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dspolicy\dbluname.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dblookup.c

Abstract:

    LSA Database - Lookup Sid and Name routines

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.

Author:

    Scott Birrell       (ScottBi)      November 27, 1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include <sidcache.h>
#include <bndcache.h>
#include <malloc.h>

#include <ntdsa.h>
#include <ntdsapi.h>
#include <ntdsapip.h>
#include "lsawmi.h"
#include <samisrv.h>

#include <lmapibuf.h>
#include <dsgetdc.h>

//
// Local function prototypes
//
#define LOOKUP_MATCH_NONE         0
#define LOOKUP_MATCH_LOCALIZED    1
#define LOOKUP_MATCH_HARDCODED    2
#define LOOKUP_MATCH_BOTH         3

BOOLEAN
LsapDbLookupIndexWellKnownName(
    IN OPTIONAL PLSAPR_UNICODE_STRING Name,
    OUT PLSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex,
    IN DWORD dwMatchType
    );


//
// Hardcoded english strings for LocalService, NetworkService,
// and LocalSystem since the account names may come from the
// registry (which isn't localized).
//

#define  LOCALSERVICE_NAME    L"LocalService"
#define  NETWORKSERVICE_NAME  L"NetworkService"
#define  SYSTEM_NAME          L"SYSTEM"
#define  NTAUTHORITY_NAME     L"NT AUTHORITY"

struct {
    UNICODE_STRING  KnownName;
    LSAP_WELL_KNOWN_SID_INDEX LookupIndex;
} LsapHardcodedNameLookupList[] = {
    { { sizeof(LOCALSERVICE_NAME) - 2, sizeof(LOCALSERVICE_NAME), LOCALSERVICE_NAME },
        LsapLocalServiceSidIndex },
    { { sizeof(NETWORKSERVICE_NAME) - 2, sizeof(NETWORKSERVICE_NAME), NETWORKSERVICE_NAME },
        LsapNetworkServiceSidIndex },
    { { sizeof(SYSTEM_NAME) - 2, sizeof(SYSTEM_NAME), SYSTEM_NAME },
        LsapLocalSystemSidIndex }
};

//
// Handy macros for iterating over static arrays
//
#define NELEMENTS(x) (sizeof(x)/sizeof(x[0]))

NTSTATUS
LsapDbLookupNamesInTrustedForests(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupNamesInTrustedForestsWorker(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    OUT BOOLEAN* fAllocateAllNodes,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapLookupNames(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    );

NTSTATUS
LsapDomainHasForestTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    );

NTSTATUS
LsapDomainHasDirectTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    );

NTSTATUS
LsapDomainHasTransitiveTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    OUT LSA_TRUST_INFORMATION *TrustInfo OPTIONAL
    );

NTSTATUS
LsapDomainHasDirectExternalTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    );

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Lsa Lookup Name Routines                                             //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

NTSTATUS
LsarLookupNames(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount
    )
/*++

Routine Description:

    See LsapLookupNames.

    Note that in Extended Sid Mode, requests to this API are denied since
    only the RID is returned.


--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Size;
    LSAPR_TRANSLATED_SIDS_EX2 TranslatedSidsEx2 = {0, NULL};

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames(%ws) start\n", LsapDbLookupGetLevel(LookupLevel)) );

    //
    // Open SAM
    //
    Status = LsapOpenSam();
    ASSERT(NT_SUCCESS(Status));
    if ( !NT_SUCCESS( Status ) ) {

        return( Status );
    }

    if (SamIIsExtendedSidMode(LsapAccountDomainHandle)) {
        return STATUS_NOT_SUPPORTED;
    }

    if ( Count > LSA_MAXIMUM_LOOKUP_NAMES_COUNT ) {
        //
        // We shouldn't be getting this much names to lookup
        //  after the change by BUG 501798
        //
        ASSERT( FALSE );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Note that due to the IN/OUT nature of TranslatedSids, it is
    // possible that a client can pass something into the Sids field.
    // However, NT clients do not so it is safe, and correct to free
    // any values at this point.  Not doing so would mean a malicious
    // client could cause starve the server.
    //
    if ( TranslatedSids->Sids ) {
        MIDL_user_free( TranslatedSids->Sids );
        TranslatedSids->Sids = NULL;
    }

    //
    // Allocate the TranslatedName buffer to return
    //
    TranslatedSids->Entries = 0;
    Size = Count * sizeof(LSA_TRANSLATED_SID);
    TranslatedSids->Sids = midl_user_allocate( Size );
    if ( !TranslatedSids->Sids ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlZeroMemory( TranslatedSids->Sids, Size );
    TranslatedSids->Entries = Count;

    Status = LsapLookupNames( PolicyHandle,
                               Count,
                               Names,
                               ReferencedDomains,
                               (PLSAPR_TRANSLATED_SIDS_EX2) &TranslatedSidsEx2,
                               LookupLevel,
                               MappedCount,
                               0,  // no options
                               LSA_CLIENT_PRE_NT5 );

    if ( TranslatedSidsEx2.Sids != NULL ) {

        //
        // Map the new data structure back to the old one
        //
        ULONG i;

        ASSERT( TranslatedSidsEx2.Entries == TranslatedSids->Entries );

        for (i = 0; i < TranslatedSidsEx2.Entries; i++ ) {

            PSID Sid = TranslatedSidsEx2.Sids[i].Sid;
            ULONG Rid = 0;

            if ( SidTypeDomain == TranslatedSidsEx2.Sids[i].Use ) {

                Rid = LSA_UNKNOWN_ID;

            } else if ( NULL != Sid ) {

                ULONG SubAuthCount = (ULONG) *RtlSubAuthorityCountSid(Sid);
                Rid = *RtlSubAuthoritySid(Sid, (SubAuthCount - 1));

            }

            TranslatedSids->Sids[i].Use = TranslatedSidsEx2.Sids[i].Use;
            TranslatedSids->Sids[i].RelativeId = Rid;
            TranslatedSids->Sids[i].DomainIndex = TranslatedSidsEx2.Sids[i].DomainIndex;

            if (TranslatedSidsEx2.Sids[i].Sid) {
                // N.B.  The SID is not an embedded field server side
                midl_user_free(TranslatedSidsEx2.Sids[i].Sid);
                TranslatedSidsEx2.Sids[i].Sid = NULL;
            }

        }

        //
        // Free the Ex structure
        //
        midl_user_free( TranslatedSidsEx2.Sids );

    } else {

        TranslatedSids->Entries = 0;
        midl_user_free( TranslatedSids->Sids );
        TranslatedSids->Sids = NULL;
    }

Cleanup:

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames(%ws) end (0x%x)\n", LsapDbLookupGetLevel(LookupLevel), Status) );

    return Status;

}


NTSTATUS
LsarLookupNames2(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    )
/*++

Routine Description:

    See LsapLookupNames.

    Note that in Extended Sid Mode, requests to this API are denied since
    only the RID is returned.


--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Size;
    LSAPR_TRANSLATED_SIDS_EX2 TranslatedSidsEx2 = {0, NULL};

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames2(%ws) start\n", LsapDbLookupGetLevel(LookupLevel)) );

    //
    // Open SAM
    //
    Status = LsapOpenSam();
    ASSERT(NT_SUCCESS(Status));
    if ( !NT_SUCCESS( Status ) ) {

        return( Status );
    }

    if (SamIIsExtendedSidMode(LsapAccountDomainHandle)) {
        return STATUS_NOT_SUPPORTED;
    }

    if ( Count > LSA_MAXIMUM_LOOKUP_NAMES_COUNT ) {
        //
        // We shouldn't be getting this much names to lookup
        //  after the change by BUG 501798
        //
        ASSERT( FALSE );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Note that due to the IN/OUT nature of TranslatedSids, it is
    // possible that a client can pass something into the Sids field.
    // However, NT clients do not so it is safe, and correct to free
    // any values at this point.  Not doing so would mean a malicious
    // client could cause starve the server.
    //
    if ( TranslatedSids->Sids ) {
        MIDL_user_free( TranslatedSids->Sids );
        TranslatedSids->Sids = NULL;
    }

    //
    // Allocate the TranslatedName buffer to return
    //
    TranslatedSids->Entries = 0;
    Size = Count * sizeof(LSA_TRANSLATED_SID_EX);
    TranslatedSids->Sids = midl_user_allocate( Size );
    if ( !TranslatedSids->Sids ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlZeroMemory( TranslatedSids->Sids, Size );
    TranslatedSids->Entries = Count;

    Status = LsapLookupNames( PolicyHandle,
                               Count,
                               Names,
                               ReferencedDomains,
                               (PLSAPR_TRANSLATED_SIDS_EX2) &TranslatedSidsEx2,
                               LookupLevel,
                               MappedCount,
                               0,  // no options
                               LSA_CLIENT_NT5 );

    if ( TranslatedSidsEx2.Sids != NULL ) {

        //
        // Map the new data structure back to the old one
        //
        ULONG i;

        ASSERT( TranslatedSidsEx2.Entries == TranslatedSids->Entries );

        for (i = 0; i < TranslatedSidsEx2.Entries; i++ ) {

            PSID Sid = TranslatedSidsEx2.Sids[i].Sid;
            ULONG Rid = 0;

            if ( SidTypeDomain == TranslatedSidsEx2.Sids[i].Use ) {

                Rid = LSA_UNKNOWN_ID;

            } else if ( NULL != Sid ) {

                ULONG SubAuthCount = (ULONG) *RtlSubAuthorityCountSid(Sid);
                Rid = *RtlSubAuthoritySid(Sid, (SubAuthCount - 1));

            }

            TranslatedSids->Sids[i].Use = TranslatedSidsEx2.Sids[i].Use;
            TranslatedSids->Sids[i].RelativeId = Rid;
            TranslatedSids->Sids[i].DomainIndex = TranslatedSidsEx2.Sids[i].DomainIndex;
            TranslatedSids->Sids[i].Flags = TranslatedSidsEx2.Sids[i].Flags;

            if (TranslatedSidsEx2.Sids[i].Sid) {
                // N.B.  The SID is not an embedded field server side
                midl_user_free(TranslatedSidsEx2.Sids[i].Sid);
                TranslatedSidsEx2.Sids[i].Sid = NULL;
            }
        }

        //
        // Free the Ex structure
        //
        midl_user_free( TranslatedSidsEx2.Sids );

    } else {

        TranslatedSids->Entries = 0;
        midl_user_free( TranslatedSids->Sids );
        TranslatedSids->Sids = NULL;

    }

Cleanup:

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames2(%ws) end (0x%x)\n", LsapDbLookupGetLevel(LookupLevel), Status) );

    return Status;
}



NTSTATUS
LsarLookupNames3(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    )
/*++

Routine Description:

    See LsapLookupNames

    This function does not take an LSA RPC Context handle.  The access check
    performed is that the caller is NETLOGON.

--*/
{
    //
    // Access check is performed in LsarLookupNames3 when a NULL is passed in.
    //
    NTSTATUS Status;

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames3(%ws) start\n", LsapDbLookupGetLevel(LookupLevel)) );

    Status = LsapLookupNames (PolicyHandle,
                              Count,
                              Names,
                              ReferencedDomains,
                              TranslatedSids,
                              LookupLevel,
                              MappedCount,
                              LookupOptions,
                              ClientRevision );


    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames3(%ws) end (0x%x)\n", LsapDbLookupGetLevel(LookupLevel), Status) );

    return Status;
}


NTSTATUS
LsarLookupNames4(
    IN handle_t RpcHandle,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    )
/*++

Routine Description:

    See LsapLookupNames

    This function does not take an LSA RPC Context handle.  The access check
    performed is that the caller is NETLOGON.

--*/
{
    //
    // Access check is performed in LsarLookupNames3 when a NULL is passed in.
    //
    NTSTATUS Status;

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames4(%ws) start\n", LsapDbLookupGetLevel(LookupLevel)) );

    Status = LsapLookupNames(NULL,
                             Count,
                             Names,
                             ReferencedDomains,
                             TranslatedSids,
                             LookupLevel,
                             MappedCount,
                             LookupOptions,
                             ClientRevision );


    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames4(%ws) end (0x%x)\n", LsapDbLookupGetLevel(LookupLevel), Status) );

    return Status;
}


NTSTATUS
LsapLookupNames(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    )

/*++

Routine Description:

    This function is the LSA server worker routine for the LsaLookupNames
    API.

    The LsaLookupNames API attempts to translate names of domains, users,
    groups or aliases to Sids.  The caller must have POLICY_LOOKUP_NAMES
    access to the Policy object.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.
       /
    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    This function is the LSA server RPC worker routine for the
    LsaLookupNames API.

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    ReferencedDomains - Receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for
        each translated name, this structure will only contain one
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    TranslatedSids - Pointer to a structure which will (or already) references an array of
        records describing each translated Sid.  The nth entry in this array
        provides a translation for the nth element in the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupWksta - First Level Lookup performed on a workstation
            normally configured for Windows-Nt.   The lookup searches the
            Well-Known Sids/Names, and the Built-in Domain and Account Domain
            in the local SAM Database.  If not all Sids or Names are
            identified, performs a "handoff" of a Second level Lookup to the
            LSA running on a Controller for the workstation's Primary Domain
            (if any).

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

     MappedCount - Pointer to location that contains a count of the Names
         mapped so far. On exit, this will be updated.


     LookupOptions --

            LSA_LOOKUP_ISOLATED_AS_LOCAL

            This flags controls the lookup API's such that isolated names, including
            UPN's are not searched for off the machine.  Composite names
            (domain\username) are still sent off machine if necessary.


     ClientRevision -- the revision, wrt to lookup code, of the client

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and all Names have
            been translated to Sids.

        STATUS_SOME_NOT_MAPPED - At least one of the names provided was
            trasnlated to a Sid, but not all names could be translated. This
            is a success status.

        STATUS_NONE_MAPPED - None of the names provided could be translated
            to Sids.  This is an error status, but output is returned.  Such
            output includes partial translations of names whose domain could
            be identified.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, SecondaryStatus = STATUS_SUCCESS;
    NTSTATUS TempStatus;
    ULONG DomainIndex;
    LSAPR_TRUST_INFORMATION TrustInformation;
    LSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation;
    LSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation;
    LSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation;
    ULONG NullNameCount = 0;
    ULONG NameIndex;
    PLSAPR_TRANSLATED_SID_EX2 OutputSids;
    PLSAPR_TRUST_INFORMATION Domains = NULL;
    ULONG OutputSidsLength;
    ULONG CompletelyUnmappedCount = Count;
    ULONG LocalDomainsToSearch = 0;

    PLSAPR_UNICODE_STRING PrefixNames = NULL;
    PLSAPR_UNICODE_STRING SuffixNames = NULL;
    LSAPR_UNICODE_STRING BackSlash;
    BOOLEAN fDownlevelSecureChannel = FALSE;

    ULONG DomainLookupScope = 0;
    ULONG PreviousMappedCount = 0;


    LsarpReturnCheckSetup();

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_LookupNames);

    BuiltInDomainTrustInformation.Name.Buffer = NULL;
    BuiltInDomainTrustInformation.Sid = NULL;

    AccountDomainTrustInformation.DomainName.Buffer = NULL;
    AccountDomainTrustInformation.FlatName.Buffer = NULL;
    AccountDomainTrustInformation.Sid = NULL;

    PrimaryDomainTrustInformation.DomainName.Buffer = NULL;
    PrimaryDomainTrustInformation.FlatName.Buffer = NULL;
    PrimaryDomainTrustInformation.Sid = NULL;

    ASSERT( Count <= LSA_MAXIMUM_LOOKUP_NAMES_COUNT );

    //
    // If there are no completely unmapped Names remaining, return.
    //

    if (CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupNamesFinish;
    }

    if ((LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL) != 0
     &&  LookupLevel != LsapLookupWksta  ) {

        //
        // LSA_LOOKUP_ISOLATED_AS_LOCAL is only valid on workstation lookups
        //
        Status = STATUS_INVALID_PARAMETER;
        goto LookupNamesFinish;
    }


    //
    // Validate that all of the names are valid.  Unfortunately, we must do it here, since
    // we actually process each of the entries before we loop through them below.
    //
    for (NameIndex = 0; NameIndex < Count; NameIndex++) {

        if ( !LsapValidateLsaUnicodeString( &Names[ NameIndex ] ) ) {

            Status = STATUS_INVALID_PARAMETER;
            goto LookupNamesError;
        }
    }

    //
    // Perform an access check
    //
    Status =  LsapDbLookupAccessCheck( PolicyHandle );
    if (!NT_SUCCESS(Status)) {
        goto LookupNamesError;
    }


    //
    // Determine what scope of resolution to use
    //
    DomainLookupScope = LsapGetDomainLookupScope(LookupLevel,
                                                 ClientRevision);


    //
    // Names provided are either Isolated, consisting of a single
    // component, or composite, having the form
    //
    // <DomainName>\<SuffixName>
    //
    // Split the list of names into two separate arrays, one containing
    // the Domain Prefixes (or NULL strings) and the other array
    // containing the Terminal Names.  Both arrays are the same size
    // as the original.  First, allocate memory for the output arrays
    // of UNICODE_STRING structures.
    //

    Status = STATUS_INSUFFICIENT_RESOURCES;

    PrefixNames = MIDL_user_allocate( Count * sizeof( UNICODE_STRING ));

    if (PrefixNames == NULL) {

        goto LookupNamesError;
    }

    SuffixNames = MIDL_user_allocate( Count * sizeof( UNICODE_STRING ));

    if (SuffixNames == NULL) {

        goto LookupNamesError;
    }

    RtlInitUnicodeString( (PUNICODE_STRING) &BackSlash, L"\\" );

    LsapRtlSplitNames(
        (PUNICODE_STRING) Names,
        Count,
        (PUNICODE_STRING) &BackSlash,
        (PUNICODE_STRING) PrefixNames,
        (PUNICODE_STRING) SuffixNames
        );

    //
    // Note that due to the IN/OUT nature of TranslatedSids, it is
    // possible that a client can pass something into the Sids field.
    // However, NT clients do not so it is safe, and correct to free
    // any values at this point.  Not doing so would mean a malicious
    // client could cause starve the server.
    //
    if ( TranslatedSids->Sids ) {

        MIDL_user_free( TranslatedSids->Sids );
    }

    TranslatedSids->Sids = NULL;
    TranslatedSids->Entries = 0;
    *ReferencedDomains = NULL;

    ASSERT( (LookupLevel == LsapLookupWksta)
         || (LookupLevel == LsapLookupPDC)
         || (LookupLevel == LsapLookupTDL)
         || (LookupLevel == LsapLookupGC)
         || (LookupLevel == LsapLookupXForestReferral)
         || (LookupLevel == LsapLookupXForestResolve) );

    //
    // Now that parameter checks have been done, fork off if this
    // is an XForest request
    //
    if (LookupLevel == LsapLookupXForestReferral) {

        BOOLEAN fAllocateAllNodes = FALSE;
        NTSTATUS Status2;

        //
        // Note that LsapDbLookupNamesInTrustedForestsWorker will allocate
        // the OUT parameters
        //
        *MappedCount = 0;

        Status = LsapDbLookupNamesInTrustedForestsWorker(Count,
                                                         Names,
                                                         PrefixNames,
                                                         SuffixNames,
                                                         ReferencedDomains,
                                                         TranslatedSids,
                                                         &fAllocateAllNodes,
                                                         MappedCount,
                                                         LookupOptions,
                                                         &SecondaryStatus);

        if (fAllocateAllNodes) {

            //
            // Reallocate the memory in a form the server can return to RPC
            //
            Status2 = LsapLookupReallocateTranslations((PLSA_REFERENCED_DOMAIN_LIST *)ReferencedDomains,
                                                       Count,
                                                       NULL,
                                                       (PLSA_TRANSLATED_SID_EX2 * ) &TranslatedSids->Sids);
            if (!NT_SUCCESS(Status2)) {
                //
                // This is a fatal resource error - free the memory that
                // was returned to us by the chaining call
                //
                if (*ReferencedDomains) {
                    midl_user_free(*ReferencedDomains);
                    *ReferencedDomains = NULL;
                }
                if (TranslatedSids->Sids) {
                    midl_user_free(TranslatedSids->Sids);
                    TranslatedSids->Sids = NULL;
                    TranslatedSids->Entries = 0;
                }
                Status = Status2;
            }
        }

        //
        // There is nothing more to do
        //
        goto LookupNamesFinish;
    }


    //
    // Allocate Output Sids array buffer.
    //

    OutputSidsLength = Count * sizeof(LSA_TRANSLATED_SID_EX2);
    OutputSids = MIDL_user_allocate(OutputSidsLength);

    if (OutputSids == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupNamesError;
    }

    TranslatedSids->Entries = Count;
    TranslatedSids->Sids = OutputSids;

    //
    // Initialize the Output Sids array.  Zeroise all fields, then
    // Mark all of the Output Sids as being unknown initially and
    // set the DomainIndex fields to a negative number meaning
    // "no domain"
    //

    RtlZeroMemory( OutputSids, OutputSidsLength);

    for (NameIndex = 0; NameIndex < Count; NameIndex++) {

        OutputSids[NameIndex].Use = SidTypeUnknown;
        OutputSids[NameIndex].DomainIndex = LSA_UNKNOWN_INDEX;
    }

    //
    // Create an empty Referenced Domain List.
    //

    Status = LsapDbLookupCreateListReferencedDomains( ReferencedDomains, 0 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesError;
    }

    //
    // Obtain the Trust Information for the
    // Built-in, Account and Primary Domains.
    //

    Status = LsapDbLookupLocalDomains(
                 &BuiltInDomainTrustInformation,
                 &AccountDomainTrustInformation,
                 &PrimaryDomainTrustInformation
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesError;
    }

    if ( ((DomainLookupScope & LSAP_LOOKUP_DNS_SUPPORT) == 0)
      && (LookupLevel == LsapLookupPDC)  ) {
        //
        // We don't want to expose dns names to downlevel
        // clients
        //
        RtlInitUnicodeString( (UNICODE_STRING*) &AccountDomainTrustInformation.DomainName, NULL );
        RtlInitUnicodeString( (UNICODE_STRING*) &PrimaryDomainTrustInformation.DomainName, NULL );

    }

    //
    // The local domains to be searched always include the Accounts
    // domain.  For initial lookup targets only, the BUILT_IN domain is
    // also searched.
    //

    LocalDomainsToSearch = LSAP_DB_SEARCH_ACCOUNT_DOMAIN;

    if (LookupLevel == LsapLookupWksta) {


        LocalDomainsToSearch |= LSAP_DB_SEARCH_BUILT_IN_DOMAIN;

        //
        // This is the lowest Lookup Level, normally targeted at a
        // Workstation.
        //

    }

    ASSERT( (LookupLevel == LsapLookupWksta)
         || (LookupLevel == LsapLookupPDC)
         || (LookupLevel == LsapLookupTDL)
         || (LookupLevel == LsapLookupGC)
         || (LookupLevel == LsapLookupXForestResolve) );

    Status = LsapDbLookupSimpleNames(
                 Count,
                 LookupLevel,
                 Names,
                 PrefixNames,
                 SuffixNames,
                 &BuiltInDomainTrustInformation,
                 &AccountDomainTrustInformation,
                 &PrimaryDomainTrustInformation,
                 *ReferencedDomains,
                 TranslatedSids,
                 MappedCount,
                 &CompletelyUnmappedCount
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesError;
    }


    //
    // If all Names are now mapped or partially mapped, or only zero
    // length names remain, finish.
    //

    NullNameCount = 0;

    for( NameIndex = 0; NameIndex < Count; NameIndex++) {

        if (Names[NameIndex].Length == 0) {

            NullNameCount++;
        }
    }

    if (CompletelyUnmappedCount == NullNameCount) {

        goto LookupNamesFinish;
    }

    //
    // There are some remaining unmapped Names.  They may belong to a
    // local SAM Domain.  Currently, there are two such domains, the
    // Built-in Domain and the Accounts Domain.  Search these
    // domains now, excluding the BUILT_IN domain from higher level
    // searches.
    //

    if ( LookupLevel != LsapLookupGC ) {

        ASSERT( (LookupLevel == LsapLookupWksta)
             || (LookupLevel == LsapLookupPDC)
             || (LookupLevel == LsapLookupTDL)
             || (LookupLevel == LsapLookupXForestResolve) );

        Status = LsapDbLookupNamesInLocalDomains(
                     Count,
                     Names,
                     PrefixNames,
                     SuffixNames,
                     &BuiltInDomainTrustInformation,
                     &AccountDomainTrustInformation,
                     *ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     LocalDomainsToSearch
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupNamesError;
        }
    }

    //
    // If all Names apart from NULL names are now mapped, finish.
    //

    if (CompletelyUnmappedCount == NullNameCount) {

        goto LookupNamesFinish;
    }

    //
    // Not all of the Names have been identified in the local domain(s).
    // The next step in the search depends on the level of this lookup
    // and how we are configured as follows:
    //
    // Lookup Level         Configuration       Lookup search next
    //
    // LsapLookupWksta      Win Nt              Primary Domain
    //                      LanMan Nt           Trusted Domains
    //
    // LsapLookupPDC        Win Nt              error
    //                      LanMan Nt           Trusted Domains
    //
    // LsaLookupTDL         Win Nt              error
    //                      LanMan Nt           none
    //

    if (LookupLevel == LsapLookupWksta) {

        if (LsapProductType != NtProductLanManNt) {

            ULONG MappedByCache = *MappedCount;

            //
            // Try the cache first
            //
            Status = LsapDbMapCachedNames(
                        LookupOptions,
                        (PUNICODE_STRING) SuffixNames,
                        (PUNICODE_STRING) PrefixNames,
                        Count,
                        FALSE,          // don't use old entries
                        *ReferencedDomains,
                        TranslatedSids,
                        MappedCount
                        );
            if (!NT_SUCCESS(Status)) {
                goto LookupNamesError;
            }

            MappedByCache = *MappedCount - MappedByCache;
            CompletelyUnmappedCount -= MappedByCache;

            if (*MappedCount == Count) {
                goto LookupNamesFinish;
            }

            //
            // If there is no Primary Domain as in the case of a WORKGROUP,
            // just finish up.  Set a default result code STATUS_SUCCESS.
            //
            Status = STATUS_SUCCESS;
            if (PrimaryDomainTrustInformation.Sid == NULL) {

                goto LookupNamesFinish;
            }

            //
            // There is a Primary Domain.  Search it for Names.  Since a
            // Primary Domain is also a Trusted Domain, we use the
            // Trusted Domain search routine.  This routine will "hand off"
            // the search to a Domain Controller's LSA.
            //
            Status = LsapDbLookupNamesInPrimaryDomain(
                         LookupOptions,
                         Count,
                         Names,
                         PrefixNames,
                         SuffixNames,
                         &PrimaryDomainTrustInformation,
                         *ReferencedDomains,
                         TranslatedSids,
                         LsapLookupPDC,
                         MappedCount,
                         &CompletelyUnmappedCount,
                         &fDownlevelSecureChannel,
                         &TempStatus
                         );

            if (!NT_SUCCESS(Status)) {

                goto LookupNamesError;
            }

            if (TempStatus == STATUS_TRUSTED_RELATIONSHIP_FAILURE) {

                //
                // We could not talk to a DC -- Hit the cache again
                // looking for non-expired entries
                //
                MappedByCache = *MappedCount;

                Status = LsapDbMapCachedNames(LookupOptions,
                                              (PUNICODE_STRING) SuffixNames,
                                              (PUNICODE_STRING) PrefixNames,
                                              Count,
                                              TRUE,               // Use old entries
                                             *ReferencedDomains,
                                              TranslatedSids,
                                              MappedCount);

                if (!NT_SUCCESS(Status)) {
                    //
                    // This is a fatal resource error
                    //
                    goto LookupNamesError;

                }

                MappedByCache = *MappedCount - MappedByCache;
                CompletelyUnmappedCount -= MappedByCache;

            }

            if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
                SecondaryStatus = TempStatus;
            }


            //
            // If we are talking to a downlevel server and we are in an
            // nt5 domain, then attempt to resolve the unresolved names at a GC
            //
            if ( fDownlevelSecureChannel
              && PrimaryDomainTrustInformation.DomainName.Length > 0  ) {

                Status = LsapDbLookupNamesInGlobalCatalogWks(
                             LookupOptions,
                             Count,
                             Names,
                             PrefixNames,
                             SuffixNames,
                             *ReferencedDomains,
                             TranslatedSids,
                             MappedCount,
                             &CompletelyUnmappedCount,
                             &TempStatus
                             );

                if (!NT_SUCCESS(Status)) {

                    goto LookupNamesError;
                }

                if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
                    SecondaryStatus = TempStatus;
                }

            }

            goto LookupNamesFinish;
        }
    }

    //
    // We reach here in two cases:
    //
    // * Initial Level lookups targeted at DC's
    // * Higher Level Lookups (must be targeted at DC's)
    //
    // For the highest level lookup, that on an individual TDC, there
    // is no more searching to do, since we have already searched the
    // Accounts Domain and we do not follow trust relationships on DC's
    // beyond one level.
    //

    if (LookupLevel == LsapLookupTDL) {

        goto LookupNamesFinish;
    }

    ASSERT( (LookupLevel == LsapLookupWksta)
         || (LookupLevel == LsapLookupPDC)
         || (LookupLevel == LsapLookupGC)
         || (LookupLevel == LsapLookupXForestResolve) );

    //
    // We are either the initial target of the lookup but not configured
    // as a workstation, or we are the target of a Primary Domain
    // level lookup.  In either case, we must be configured as a DC.
    //

    if (LsapProductType != NtProductLanManNt) {

        Status = STATUS_DOMAIN_CTRLR_CONFIG_ERROR;
        goto LookupNamesError;
    }


    if (DomainLookupScope & LSAP_LOOKUP_RESOLVE_ISOLATED_DOMAINS) {

        //
        // Check for isolated domain names
        //

        PreviousMappedCount = *MappedCount;
        Status =  LsapDbLookupNamesAsDomainNames(DomainLookupScope,
                                                 Count,
                                                 Names,
                                                 PrefixNames,
                                                 SuffixNames,
                                                 *ReferencedDomains,
                                                 TranslatedSids,
                                                 MappedCount);

        if (!NT_SUCCESS(Status)) {
            goto LookupNamesError;
        }
        CompletelyUnmappedCount -= (*MappedCount - PreviousMappedCount);

        //
        // If all of the Names have now been mapped, finish.
        //

        if (*MappedCount == Count) {

            goto LookupNamesFinish;
        }
    }

    if (DomainLookupScope & LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE) {

        //
        // Search in a global catalog for names that belong to post nt4 domains
        //
        Status = LsapDbLookupNamesInGlobalCatalog(
                     LookupOptions,
                     Count,
                     Names,
                     PrefixNames,
                     SuffixNames,
                     *ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     &TempStatus
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupNamesError;
        }

        if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
            SecondaryStatus = TempStatus;
        }
    }

    if (DomainLookupScope & LSAP_LOOKUP_TRUSTED_FOREST) {

        ASSERT( (LookupLevel == LsapLookupWksta)
             || (LookupLevel == LsapLookupPDC)
             || (LookupLevel == LsapLookupGC));

        Status = LsapDbLookupNamesInTrustedForests(
                     LookupOptions,
                     Count,
                     Names,
                     PrefixNames,
                     SuffixNames,
                     *ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     &TempStatus
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupNamesError;
        }

        if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
            SecondaryStatus = TempStatus;
        }

    }

    if (DomainLookupScope & LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT) {

        ASSERT((LookupLevel == LsapLookupWksta)
            || (LookupLevel == LsapLookupPDC));

        //
        // Search all of the Trusted Domains
        //
        Status = LsapDbLookupNamesInTrustedDomains(
                     LookupOptions,
                     Count,
                     !(DomainLookupScope & LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE),
                                          // if we didn't go the GC, then
                                          // include intraforest trusts
                     Names,
                     PrefixNames,
                     SuffixNames,
                     *ReferencedDomains,
                     TranslatedSids,
                     LsapLookupTDL,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     &TempStatus
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupNamesError;
        }

        if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
            SecondaryStatus = TempStatus;
        }
    }

LookupNamesFinish:

    //
    // If some but not all Names were mapped, return informational status
    // STATUS_SOME_NOT_MAPPED.  If no Names were mapped, return error
    // STATUS_NONE_MAPPED. Note that we expect and STATUS_NONE_MAPPED
    // errors returned by called routines to have been suppressed before
    // we get here.  The reason for this is that we need to calculate
    // the return Status based on the whole set of Names, not some subset
    //

    if (NT_SUCCESS(Status)) {

        if (*MappedCount < Count) {

            Status = STATUS_SOME_NOT_MAPPED;

            if (*MappedCount == 0) {

                Status = STATUS_NONE_MAPPED;
            }
        }
    }

    //
    // If no names could be mapped it is likely due to the
    // secondary status
    //
    if (  (STATUS_NONE_MAPPED == Status)
       && (STATUS_NONE_MAPPED != SecondaryStatus)
       && LsapRevisionCanHandleNewErrorCodes( ClientRevision )
       && !NT_SUCCESS( SecondaryStatus ) ) {

        Status = SecondaryStatus;
        goto LookupNamesError;
    }


    //
    // If necessary, free the arrays of PrefixNames and SuffixNames
    //

    if (PrefixNames != NULL) {

        MIDL_user_free(PrefixNames);
    }

    if (SuffixNames != NULL) {

        MIDL_user_free(SuffixNames);
    }


    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_LookupNames);
    LsarpReturnPrologue();

    return(Status);

LookupNamesError:

    //
    // If the LookupLevel is the lowest (Workstation Level) free up
    // the Sids and Referenced Domains arrays.
    //

    if (LookupLevel == LsapLookupWksta) {

        //
        // If necessary, free the Sids array.
        //

        if (TranslatedSids->Sids != NULL) {

            ULONG i;
            for (i = 0; i < TranslatedSids->Entries; i++) {
                if (TranslatedSids->Sids[i].Sid) {
                    // N.B.  The SID is not an embedded field server side
                    MIDL_user_free(TranslatedSids->Sids[i].Sid);
                    TranslatedSids->Sids[i].Sid = NULL;
                }
            }
            MIDL_user_free( TranslatedSids->Sids );
            TranslatedSids->Sids = NULL;
        }

        //
        // If necessary, free the Referenced Domain List.
        //

        if (*ReferencedDomains != NULL) {

            Domains = (*ReferencedDomains)->Domains;

            if (Domains != NULL) {

                for (DomainIndex = 0;
                     DomainIndex < (*ReferencedDomains)->Entries;
                     DomainIndex++) {

                    if (Domains[ DomainIndex ].Name.Buffer != NULL) {

                        MIDL_user_free( Domains[ DomainIndex ].Name.Buffer );
                        Domains[ DomainIndex ].Name.Buffer = NULL;
                    }

                    if (Domains[ DomainIndex ].Sid != NULL) {

                        MIDL_user_free( Domains[ DomainIndex ].Sid );
                        Domains[ DomainIndex ].Sid = NULL;
                    }
                }

                MIDL_user_free( ( *ReferencedDomains)->Domains );

            }

            MIDL_user_free( *ReferencedDomains );
            *ReferencedDomains = NULL;
        }
    }

    //
    // If the primary status was a success code, but the secondary
    // status was an error, propagate the secondary status.
    //

    if ((!NT_SUCCESS(SecondaryStatus)) && NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupNamesFinish;
}


NTSTATUS
LsapDbEnumerateNames(
    IN LSAPR_HANDLE ContainerHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAP_DB_NAME_ENUMERATION_BUFFER DbEnumerationBuffer,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function enumerates Names of objects of a given type within a container
    object.  Since there may be more information than can be returned in a
    single call of the routine, multiple calls can be made to get all of the
    information.  To support this feature, the caller is provided with a
    handle that can be used across calls.  On the initial call,
    EnumerationContext should point to a variable that has been initialized
    to 0.

Arguments:

    ContainerHandle -  Handle to a container object.

    ObjectTypeId - Type of object to be enumerated.  The type must be one
        for which all objects have Names.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    DbEnumerationBuffer - Receives a pointer to a structure that will receive
        the count of entries returned in an enumeration information array, and
        a pointer to the array.  Currently, the only information returned is
        the object Names.  These Names may be used together with object type to
        open the objects and obtain any further information available.

    PreferedMaximumLength - prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

    CountReturned - Pointer to variable which will receive a count of the
        entries returned.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if there are no more objects to enumerate.  Note that
            zero or more objects may be enumerated on a call that returns this
            reply.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_ENUMERATION_ELEMENT LastElement;
    PLSAP_DB_ENUMERATION_ELEMENT FirstElement, NextElement = NULL, FreeElement;
    ULONG DataLengthUsed;
    ULONG ThisBufferLength;
    PUNICODE_STRING Names = NULL;
    BOOLEAN PreferedMaximumReached = FALSE;
    ULONG EntriesRead;
    ULONG Index, EnumerationIndex;
    BOOLEAN TrustedClient = ((LSAP_DB_HANDLE) ContainerHandle)->Trusted;

    LastElement.Next = NULL;
    FirstElement = &LastElement;

    //
    // If no enumeration buffer provided, return an error.
    //

    if ( (!ARGUMENT_PRESENT(DbEnumerationBuffer)) ||
         (!ARGUMENT_PRESENT(EnumerationContext ))  ) {

        return(STATUS_INVALID_PARAMETER);
    }


    //
    // Enumerate objects, stopping when the length of data to be returned
    // reaches or exceeds the Prefered Maximum Length, or reaches the
    // absolute maximum allowed for LSA object enumerations.  We allow
    // the last object enumerated to bring the total amount of data to
    // be returned beyond the Prefered Maximum Length, but not beyond the
    // absolute maximum length.
    //

    EnumerationIndex = *EnumerationContext;

    for(DataLengthUsed = 0, EntriesRead = 0;
        DataLengthUsed < PreferedMaximumLength;
        DataLengthUsed += ThisBufferLength, EntriesRead++) {

        //
        // If the absolute maximum length has been exceeded, back off
        // the last object enumerated.
        //

        if ((DataLengthUsed > LSA_MAXIMUM_ENUMERATION_LENGTH) &&
            (!TrustedClient)) {

            //
            // If PrefMaxLength is zero, NextElement may be NULL.
            //

            if (NextElement != NULL) {
                FirstElement = NextElement->Next;
                MIDL_user_free(NextElement);
            }
            break;
        }

        //
        // Allocate memory for next enumeration element.  Set the Name
        // field to NULL for cleanup purposes.
        //

        NextElement = MIDL_user_allocate(sizeof (LSAP_DB_ENUMERATION_ELEMENT));

        if (NextElement == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Find the next object's Name, and fill in its object information.
        // Note that memory will be allocated via MIDL_user_allocate
        // and must be freed when no longer required.
        //

        Status = LsapDbFindNextName(
                     ContainerHandle,
                     &EnumerationIndex,
                     ObjectTypeId,
                     (PLSAPR_UNICODE_STRING) &NextElement->Name
                     );

        //
        // Stop the enumeration if any error or warning occurs.  Note
        // that the warning STATUS_NO_MORE_ENTRIES will be returned when
        // we've gone beyond the last index.
        //

        if (Status != STATUS_SUCCESS) {

            break;
        }

        //
        // Get the length of the data allocated for the object's Name
        //

        ThisBufferLength = NextElement->Name.Length;

        //
        // Link the object just found to the front of the enumeration list
        //

        NextElement->Next = FirstElement;
        FirstElement = NextElement;
    }

    //
    // If an error other than STATUS_NO_MORE_ENTRIES occurred, return it.
    //

    if ((Status != STATUS_NO_MORE_ENTRIES) && !NT_SUCCESS(Status)) {

        goto EnumerateNamesError;
    }

    //
    // The enumeration is complete or has terminated because of return
    // buffer limitations.  If no entries were read, return.
    //

    if (EntriesRead != 0) {


        //
        // Some entries were read, allocate an information buffer for returning
        // them.
        //

        Names = MIDL_user_allocate( sizeof (UNICODE_STRING) * EntriesRead );

        if (Names == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto EnumerateNamesError;
        }

        //
        // Memory was successfully allocated for the return buffer.
        // Copy in the enumerated Names.
        //

        for (NextElement = FirstElement, Index = 0;
            NextElement != &LastElement;
            NextElement = NextElement->Next, Index++) {

            ASSERT(Index < EntriesRead);

            Names[Index] = NextElement->Name;
        }

        Status = STATUS_SUCCESS;

    } else {

        //
        // No entries available this call.
        //

        Status = STATUS_NO_MORE_ENTRIES;

    }

EnumerateNamesFinish:

    //
    // Free the enumeration element structures (if any).
    //

    for (NextElement = FirstElement; NextElement != &LastElement;) {

        //
        // If an error has occurred, dispose of memory allocated
        // for any Names.
        //

        if (!(NT_SUCCESS(Status) || (Status == STATUS_NO_MORE_ENTRIES))) {

            if (NextElement->Name.Buffer != NULL) {

                MIDL_user_free(NextElement->Name.Buffer);
            }
        }

        //
        // Free the memory allocated for the enumeration element.
        //

        FreeElement = NextElement;
        NextElement = NextElement->Next;

        MIDL_user_free(FreeElement);
    }

    //
    // Fill in return enumeration structure (0 and NULL in error case).
    //

    DbEnumerationBuffer->EntriesRead = EntriesRead;
    DbEnumerationBuffer->Names = Names;
    *EnumerationContext = EnumerationIndex;

    return(Status);

EnumerateNamesError:

    //
    // If necessary, free memory allocated for returning the Names.
    //

    if (Names != NULL) {

        MIDL_user_free( Names );
        Names = NULL;
    }

    goto EnumerateNamesFinish;
}


VOID
LsapDbUpdateCountCompUnmappedNames(
    OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function updates the count of completely unmapped names in a
    name lookup operation.  A name is completely unmapped if its domain
    is unknown.

Arguments:

    TranslatedSids - Pointer to a structure which will be initialized to
        reference an array of records describing each translated Sid.  The
        nth entry in this array provides a translation for the nth element in
        the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    CompletelyUnmappedCount - Pointer to location that will receive
        a count of completely unmapped Sids.  A Name is completely unmapped
        if it is isolated and unknown, or is composite and its Domain Prefix
        component is not recognized as a Domain Name.

Return Values:

    None

--*/

{
    ULONG Count = TranslatedSids->Entries;
    ULONG SidIndex;
    ULONG UpdatedCompletelyUnmappedCount = 0;

    for (SidIndex = 0; SidIndex < Count; SidIndex++) {

        if (TranslatedSids->Sids[SidIndex].DomainIndex == LSA_UNKNOWN_INDEX) {

            UpdatedCompletelyUnmappedCount++;
        }
    }

    ASSERT(UpdatedCompletelyUnmappedCount <= *CompletelyUnmappedCount);
    *CompletelyUnmappedCount = UpdatedCompletelyUnmappedCount;
}


NTSTATUS
LsapDbFindNextName(
    IN LSAPR_HANDLE ContainerHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PLSAPR_UNICODE_STRING NextName
    )

/*++

Routine Description:

    This function finds the next Name of object of a given type within a
    container object.  The given object type must be one where objects
    have Names.  The Names returned can be used on subsequent open calls to
    access the objects.

Arguments:

    ContainerHandle - Handle to container object.

    EnumerationContext - Pointer to a variable containing the index of
        the object to be found.  A zero value indicates that the first
        object is to be found.

    ObjectTypeId - Type of the objects whose Names are being enumerated.
        Ccurrently, this is restricted to objects (such as Secret Objects)
        that are accessed by Name only.

    NextName - Pointer to Unicode String that will be initialized to
        reference the next Name found.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - Invalid ContainerHandle specified

        STATUS_NO_MORE_ENTRIES - Warning that no more entries exist.
--*/

{
    NTSTATUS Status, SecondaryStatus;
    ULONG NameKeyValueLength = 0;
    LSAPR_UNICODE_STRING SubKeyNameU;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ContDirKeyHandle = NULL;


    //
    // Setup object attributes for opening the appropriate Containing
    // Directory.  For example, if we're looking for Account objects,
    // the containing Directory is "Accounts".  The Unicode strings for
    // containing Directories are set up during Lsa Initialization.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &LsapDbContDirs[ObjectTypeId],
        OBJ_CASE_INSENSITIVE,
        ((LSAP_DB_HANDLE) ContainerHandle)->KeyHandle,
        NULL
        );

    //
    // If the object type is not accessed by Name only, return an error.
    // Currently, only Secret objects have this property.
    //


    if (ObjectTypeId != SecretObject) {
        return(STATUS_INVALID_PARAMETER);
    }

    Status = RtlpNtOpenKey(
                 &ContDirKeyHandle,
                 KEY_READ,
                 &ObjectAttributes,
                 0
                 );

    if (NT_SUCCESS(Status)) {

        //
        // Initialize the Unicode String in which the next object's Logical Name
        // will be returned.  The Logical Name of an object equals its Registry
        // Key relative to its Containing Directory, and is also equal to
        // the Relative Id of the object represented in character form as an
        // 8-digit number with leading zeros.
        //
        // NOTE: The size of buffer allocated for the Logical Name must be
        // calculated dynamically when the Registry supports long names, because
        // it is possible that the Logical Name of an object will be equal to a
        // character representation of the full Name, not just the Relative Id
        // part.
        //

        SubKeyNameU.MaximumLength = (USHORT) LSAP_DB_LOGICAL_NAME_MAX_LENGTH;
        SubKeyNameU.Length = 0;
        SubKeyNameU.Buffer = MIDL_user_allocate(SubKeyNameU.MaximumLength);

        if (SubKeyNameU.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {

            //
            // Now enumerate the next subkey.
            //

            Status = RtlpNtEnumerateSubKey(
                         ContDirKeyHandle,
                         (PUNICODE_STRING) &SubKeyNameU,
                         *EnumerationContext,
                         NULL
                         );

            if (NT_SUCCESS(Status)) {

                (*EnumerationContext)++;

                //
                // Return the Name.
                //

                *NextName = SubKeyNameU;

            } else {

                //
                // Not successful - free the subkey name buffer
                // Note that STATUS_NO_MORE_ENTRIES is a warning
                // (not a success) code.
                //

                MIDL_user_free( SubKeyNameU.Buffer );

                //
                // Set the out parameter so RPC doesn't try
                // to return anything.
                //

                NextName->Length = NextName->MaximumLength = 0;
                NextName->Buffer = NULL;

            }

        }

        //
        // Close the containing directory handle
        //

        SecondaryStatus = NtClose(ContDirKeyHandle);
        ASSERT(NT_SUCCESS(SecondaryStatus));
    }

    return(Status);

}


NTSTATUS
LsapDbLookupSimpleNames(
    IN ULONG Count,
    IN ULONG LookupLevel,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function attempts to identify isolated names as the names of well known
    Sids or Domains present on the Lookup Path.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is the name of one of the Primary Domain's Trusted Domains,
    then that domain's Sid will be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a structure in which the list of domains
        used in the translation is maintained.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for each
        translated name, this structure will only contain one component for
        each domain utilized in the translation.

    TranslatedSids - Pointer to a structure in which the translations to Sids
        corresponding to the Names specified on Names is maintained.  The
        nth entry in this array provides a translation (where known) for the
        nth element in the Names parameter.

    MappedCount - Pointer to location in which a count of the Names that
        have been completely translated is maintained.

    CompletelyUnmappedCount - Pointer to a location in which a count of the
        Names that have not been translated (either partially, by identification
        of a Domain Prefix, or completely) is maintained.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;


    //
    // First, lookup any Well Known Names
    //
    if ( LookupLevel == LsapLookupWksta ) {

        //
        // This lookup should only be done once and be done at the first
        // level
        //
        Status = LsapDbLookupWellKnownNames(
                     Count,
                     Names,
                     PrefixNames,
                     SuffixNames,
                     ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     CompletelyUnmappedCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupSimpleNamesError;
        }

        //
        // If all of the Names have now been mapped, finish.
        //

        if (*MappedCount == Count) {

            goto LookupSimpleNamesFinish;
        }
    }


    //
    // Next, attempt to identify Isolated Names as Domain Names
    //
    if (  (LookupLevel == LsapLookupWksta)
       || (LookupLevel == LsapLookupPDC) ) {

        //
        // This step should be done once at the first level to findstr
        // local domain names (ie local accounts at a workstation) and
        // then again at second level to find trusted domain names
        //

        Status = LsapDbLookupIsolatedDomainNames(
                     Count,
                     Names,
                     PrefixNames,
                     SuffixNames,
                     BuiltInDomainTrustInformation,
                     AccountDomainTrustInformation,
                     PrimaryDomainTrustInformation,
                     ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     CompletelyUnmappedCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupSimpleNamesError;
        }
    }

LookupSimpleNamesFinish:

    return(Status);

LookupSimpleNamesError:

    goto LookupSimpleNamesFinish;
}


NTSTATUS
LsapDbLookupWellKnownNames(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function attempts to identify names as the names of well known Sids.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is the name of one of the Primary Domain's Trusted Domains,
    then that domain's Sid will be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a structure in which the list of domains
        used in the translation is maintained.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for each
        translated name, this structure will only contain one component for
        each domain utilized in the translation.

    TranslatedSids - Pointer to a structure in which the translations to Sids
        corresponding to the Names specified on Names is maintained.  The
        nth entry in this array provides a translation (where known) for the
        nth element in the Names parameter.

    MappedCount - Pointer to location in which a count of the Names that
        have been completely translated is maintained.

    CompletelyUnmappedCount - Pointer to a location in which a count of the
        Names that have not been translated (either partially, by identification
        of a Domain Prefix, or completely) is maintained.

Return Values:

    NTSTATUS - Standard Nt Result Code

    STATUS_SUCCESS - The call completed successfully.  Note that some
        or all of the Names may remain partially or completely unmapped.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
        to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG UpdatedMappedCount;
    ULONG NameNumber;
    ULONG UnmappedNamesRemaining;
    PLSAPR_TRANSLATED_SID_EX2 OutputSids;
    LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex;
    LSAPR_TRUST_INFORMATION TrustInformation;
    UCHAR SubAuthorityCount;
    PLSAPR_SID Sid = NULL;
    PLSAPR_SID PrefixSid = NULL;
    ULONG PrefixSidLength;
    ULONG RelativeId;
    OutputSids = TranslatedSids->Sids;

    //
    // Initialize output parameters.
    //

    *MappedCount = UpdatedMappedCount = 0;
    UnmappedNamesRemaining = Count - UpdatedMappedCount;

    //
    // Attempt to identify Names as Well Known Isolated Names
    //

    for (NameNumber = 0;
         (NameNumber < Count) && (UnmappedNamesRemaining > 0);
         NameNumber++) {

        //
        // Examine the next entry in the Names array.  If the corresponding
        // translated Sid entry has SidTypeUnknown for its Use field, the
        // name has not been translated.
        //

        if (OutputSids[NameNumber].Use == SidTypeUnknown) {

            //
            // Attempt to identify the name as the name of a Well Known Sid
            // by using the Well Known Sids table.  We skip entries in the
            // table for Sids that are also in the Built In domain.  For
            // those, we drop through to the Built in Domain search.  Note
            // that only one of these, the Administrators alias is currently
            // present in the table.
            //

            DWORD   dwMatchType = LOOKUP_MATCH_NONE;

            UNICODE_STRING  NTAuthorityName = { sizeof(NTAUTHORITY_NAME) - 2,
                                                sizeof(NTAUTHORITY_NAME),
                                                NTAUTHORITY_NAME };

            if (PrefixNames[NameNumber].Length == 0)
            {
                dwMatchType = LOOKUP_MATCH_BOTH;
            }
            else if (RtlEqualUnicodeString( (PUNICODE_STRING) &PrefixNames[NameNumber],
                                             &WellKnownSids[LsapLocalSystemSidIndex].DomainName,
                                             TRUE) )
            {
                dwMatchType = LOOKUP_MATCH_LOCALIZED;
            }


            if (RtlEqualUnicodeString( (PUNICODE_STRING) &PrefixNames[NameNumber],
                                       &NTAuthorityName,
                                       TRUE) )
            {
                if (dwMatchType == LOOKUP_MATCH_NONE)
                {
                    dwMatchType = LOOKUP_MATCH_HARDCODED;
                }
                else
                {
                    ASSERT(dwMatchType == LOOKUP_MATCH_LOCALIZED);
                    dwMatchType = LOOKUP_MATCH_BOTH;
                }
            }


            //
            // Ignore SIDs from the BUILTIN domain since their names may
            // change (i.e., we always want SAM to resolve those with the
            // most up-to-date information).
            //

            if ((dwMatchType != LOOKUP_MATCH_NONE)
                 &&
                LsapDbLookupIndexWellKnownName(
                    &SuffixNames[NameNumber],
                    &WellKnownSidIndex,
                    dwMatchType)
                 &&
                !SID_IS_RESOLVED_BY_SAM(WellKnownSidIndex))
            {
                //
                // Name is identified.  Obtain its Sid.  If the
                // SubAuthorityCount for the Sid is positive, extract the
                // Relative Id and place in the translated Sid entry,
                // otherwise store LSA_UNKNOWN_INDEX there.
                //

                Sid = LsapDbWellKnownSid(WellKnownSidIndex);

                SubAuthorityCount = *RtlSubAuthorityCountSid((PSID) Sid);

                RelativeId = LSA_UNKNOWN_ID;

                PrefixSid = NULL;

                //
                // Get the Sid's Use.
                //

                OutputSids[NameNumber].Use =
                    LsapDbWellKnownSidNameUse(WellKnownSidIndex);

                //
                // If the Sid is a Domain Sid, store pointer to
                // it in the Trust Information.
                //

                if (OutputSids[NameNumber].Use == SidTypeDomain) {

                    TrustInformation.Sid = Sid;

                } else {

                    //
                    // The Sid is not a domain Sid.  Construct the Relative Id
                    // and Prefix Sid.  This is equal to the original Sid
                    // excluding the lowest subauthority (Relative id).
                    //

                    if (SubAuthorityCount > 0) {

                        RelativeId = *RtlSubAuthoritySid((PSID) Sid, SubAuthorityCount - 1);
                    }

                    PrefixSidLength = RtlLengthRequiredSid(
                                          SubAuthorityCount - 1
                                          );


                    PrefixSid = MIDL_user_allocate( PrefixSidLength );

                    if (PrefixSid == NULL) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }


                    RtlCopyMemory( PrefixSid, Sid, PrefixSidLength );

                    (*RtlSubAuthorityCountSid( (PSID) PrefixSid ))--;

                    TrustInformation.Sid = PrefixSid;
                }

                //
                // Set the Relative Id.  For a Domain Sid this is set to the
                // Unknown Value.
                //
                Status = LsapRpcCopySid(NULL,
                                       &OutputSids[NameNumber].Sid,
                                        Sid);
                if (!NT_SUCCESS(Status)) {
                    break;
                }

                //
                // Lookup this Domain Sid or Prefix Sid in the Referenced Domain
                // List.  If it is already there, return the DomainIndex for the
                // existing entry and free up the memory allocated for the
                // Prefix Sid (if any).
                //

                if (LsapDbLookupListReferencedDomains(
                        ReferencedDomains,
                        TrustInformation.Sid,
                        (PLONG) &OutputSids[NameNumber].DomainIndex
                        )) {

                    UnmappedNamesRemaining--;

                    if (PrefixSid != NULL) {

                        MIDL_user_free( PrefixSid );
                        PrefixSid = NULL;
                    }

                    continue;
                }

                //
                // This Domain or Prefix Sid is not currently on the
                // Referenced Domain List.  Complete a Trust Information
                // entry and add it to the List.  Copy in the Domain Name
                // (Domain Sids) or NULL string.  Note that we use
                // RtlCopyMemory to copy a UNICODE_STRING structure onto
                // a LSAPR_UNICODE_STRING structure.
                //

                RtlCopyMemory(
                    &TrustInformation.Name,
                    &WellKnownSids[WellKnownSidIndex].DomainName,
                    sizeof(UNICODE_STRING)
                    );

                //
                // Make an entry in the list of Referenced Domains.  Note
                // that in the case of well-known Sids, the Prefix Sid
                // may or may not be the Sid of a Domain.  For those well
                // known Sids whose Prefix Sid is not a domain Sid, the
                // Name field in the Trust Information has been set to the
                // NULL string.
                //

                Status = LsapDbLookupAddListReferencedDomains(
                             ReferencedDomains,
                             &TrustInformation,
                             (PLONG) &OutputSids[NameNumber].DomainIndex
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }

                //
                // If we allocated memory for a Prefix Sid, free it.
                //

                if (PrefixSid != NULL) {

                    MIDL_user_free( PrefixSid );
                    PrefixSid = NULL;
                }

                UnmappedNamesRemaining--;
            }
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupIsolatedWellKnownNamesError;
    }

    //
    // Set the output parameters in the success case..
    //

    TranslatedSids->Sids = OutputSids;
    TranslatedSids->Entries = Count;
    *MappedCount = Count - UnmappedNamesRemaining;
    *CompletelyUnmappedCount = UnmappedNamesRemaining;

LookupIsolatedWellKnownNamesFinish:

    //
    // If we still have memory allocated for the a Prefix Sid, free it.
    //

    if (PrefixSid != NULL) {

        MIDL_user_free( PrefixSid );
        PrefixSid = NULL;
    }

    return(Status);

LookupIsolatedWellKnownNamesError:

    goto LookupIsolatedWellKnownNamesFinish;
}


BOOLEAN
LsapDbLookupIndexWellKnownName(
    IN OPTIONAL PLSAPR_UNICODE_STRING Name,
    OUT PLSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex,
    IN DWORD dwMatchType
    )

/*++

Routine Description:

    This function looks up a Name to determine if it is well-known.  If so,
    an index into the table of well-known Sids is returned.

Arguments:

    Name - Pointer to Name to be looked up.  If a NULL pointer or
        pointer to a zero length string is specified, FALSE will
        always be returned.

    WellKnownSidIndex - Pointer to variable that will receive the
        index of the Name if well known.

    dwMatchType - Constant indicating that the name's prefix matched
        a well-known hardcoded prefix or both the hardcoded and
        localized prefixes.

Return Value:

    BOOLEAN - TRUE if the Name is well-known, else FALSE

--*/

{
    LSAP_WELL_KNOWN_SID_INDEX Index;
    PLSAPR_UNICODE_STRING MatchName = NULL;
    BOOLEAN BooleanStatus = FALSE;

    if ((!ARGUMENT_PRESENT(Name)) || Name->Length == 0 ) {

        return(FALSE);
    }

    if (dwMatchType == LOOKUP_MATCH_HARDCODED
         ||
        dwMatchType == LOOKUP_MATCH_BOTH)
    {
        //
        // This means the domain name was "NT AUTHORITY" -- check
        // the suffix for LocalService, NetworkService, or System
        //

        UINT i;

        for (i = 0;
             i < NELEMENTS(LsapHardcodedNameLookupList);
             i++)
        {
            if (RtlEqualUnicodeString((PUNICODE_STRING) Name,
                                      &LsapHardcodedNameLookupList[i].KnownName,
                                      TRUE))
            {
                *WellKnownSidIndex = LsapHardcodedNameLookupList[i].LookupIndex;
                return TRUE;
            }
        }

        if (dwMatchType == LOOKUP_MATCH_HARDCODED)
        {
            //
            // No hardcoded match.  Don't check the localized names since the
            // prefix name itself didn't match the localized prefix.
            //
            *WellKnownSidIndex = LsapDummyLastSidIndex;
            return FALSE;
        }
    }

    //
    // Scan the table of well-known Sids looking for a match on Name.
    //

    for(Index = LsapNullSidIndex; Index<LsapDummyLastSidIndex; Index++) {

        //
        // Allow NULL entries in the table of well-known Sids for now.
        //

        if (WellKnownSids[Index].Sid == NULL) {

            continue;
        }

        //
        // If the current entry in the table of Well Known Sids
        // is for a Domain Sid, match the name with the DomainName
        // field.  Otherwise, match it with the Name field.
        //

        if (WellKnownSids[Index].Use == SidTypeDomain) {

            MatchName = (PLSAPR_UNICODE_STRING) &WellKnownSids[Index].DomainName;

            if (RtlEqualUnicodeString(
                   (PUNICODE_STRING) Name,
                   (PUNICODE_STRING) MatchName,
                   TRUE
                   )) {

                //
                // If a match is found, return the index to the caller.
                //

                BooleanStatus = TRUE;
                break;
            }

        } else {

            MatchName = (PLSAPR_UNICODE_STRING) &WellKnownSids[Index].Name;

            if (RtlEqualUnicodeString(
                   (PUNICODE_STRING) Name,
                   (PUNICODE_STRING) MatchName,
                   TRUE
                   )) {

                //
                // If a match is found, return the index to the caller.
                //

                BooleanStatus = TRUE;
                break;
            }
        }
    }

    *WellKnownSidIndex = Index;

    return(BooleanStatus);
}

BOOLEAN
LsaILookupWellKnownName(
    IN PUNICODE_STRING WellKnownName
    )
/*++

RoutineDescription:

    This routine returns TRUE if the supplied name is a well known name.

Arguments:

    WellKnownName - The name to check against the list of well known names

Return Values:

    TRUE - The supplied name is a well known name
    FALSE - The supplied name is not a well known name

--*/
{
    LSAP_WELL_KNOWN_SID_INDEX Index;

    return(LsapDbLookupIndexWellKnownName(
                (PLSAPR_UNICODE_STRING) WellKnownName,
                &Index,
                LOOKUP_MATCH_NONE
                ));

}


PUNICODE_STRING
LsapDbWellKnownSidName(
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex
    )

/*++

Routine Description:

    This function returns the Unicode Name of a Well Known Sid.

Arguments:

    WellKnownSidIndex - Index into the Well Known Sid information table.
    It is the caller's responsibility to ensure that the given index
    is valid.

Return Value:

    PUNICODE_STRING Pointer to the name of the Well Known Sid.

--*/

{
    //
    // If the Sid is a Domain Sid, its name is contained within the
    // DomainName field in the Well Known Sids table.  If the Sid is not a
    // Domain Sid, its name is contained within the Name field of the entry.
    //

    if (WellKnownSids[WellKnownSidIndex].Use == SidTypeDomain) {

        return(&WellKnownSids[WellKnownSidIndex].DomainName);

    } else {

        return(&WellKnownSids[WellKnownSidIndex].Name);
    }
}


NTSTATUS
LsapDbLookupIsolatedDomainNames(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function attempts to identify isolated names as the names of Domains.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is the name of one of the Primary Domain's Trusted Domains,
    then that domain's Sid will be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a structure in which the list of domains
        used in the translation is maintained.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for each
        translated name, this structure will only contain one component for
        each domain utilized in the translation.

    TranslatedSids - Pointer to a structure in which the translations to Sids
        corresponding to the Names specified on Names is maintained.  The
        nth entry in this array provides a translation (where known) for the
        nth element in the Names parameter.

    MappedCount - Pointer to location in which a count of the Names that
        have been completely translated is maintained.

    CompletelyUnmappedCount - Pointer to a location in which a count of the
        Names that have not been translated (either partially, by identification
        of a Domain Prefix, or completely) is maintained.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus;
    LSAPR_TRUST_INFORMATION LocalTrustInfo;
    ULONG NameIndex;

    //
    // Search for Isolated Names that match the Built-In Domain Name,
    // Account Domain Name or one of the Primary Domain's Trusted Domain
    // Names.
    //


    for (NameIndex = 0;
         (NameIndex < Count);
         NameIndex++) {

        //
        // Skip this name if already mapped or partially mapped.
        //

        if (!LsapDbCompletelyUnmappedSid(&TranslatedSids->Sids[NameIndex])) {

            continue;
        }

        //
        // Skip this name if composite.
        //

        if (PrefixNames[ NameIndex ].Length != (USHORT) 0) {

            continue;
        }

        //
        // We've found an Isolated Name.  First check if it is the
        // name of the Built In Domain.
        //

        Status = LsapDbLookupIsolatedDomainName(
                     NameIndex,
                     &SuffixNames[NameIndex],
                     BuiltInDomainTrustInformation,
                     ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     CompletelyUnmappedCount
                     );

        if (NT_SUCCESS(Status)) {

            continue;
        }

        if (Status != STATUS_NONE_MAPPED) {

            break;
        }

        Status = STATUS_SUCCESS;

        //
        // Isolated Name is not the name of the Built-in Domain.  See if
        // it is the name of the Accounts Domain.
        //
        Status = LsapDbLookupIsolatedDomainNameEx(
                     NameIndex,
                     &SuffixNames[NameIndex],
                     AccountDomainTrustInformation,
                     ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     CompletelyUnmappedCount
                     );

        if (NT_SUCCESS(Status)) {

            continue;
        }

        Status = STATUS_SUCCESS;

        //
        // If we are configured as a member of a Work Group, there is
        // no Primary or Trusted Domain List to search, so skip to next
        // name.  We are configured as a member of a Work Group if and
        // only if out PolicyPrimaryDomainInformation contains a NULL Sid.
        //

        if (PrimaryDomainTrustInformation->Sid == NULL) {

            continue;
        }

        //
        // Isolated Name is not the name of either the Built-in or Accounts
        // Domain.  Try the Primary Domain if this is different from the
        // Accounts Domain.
        //
        ASSERT(PrimaryDomainTrustInformation->FlatName.Length > 0);

        if (!RtlEqualDomainName(
                (PUNICODE_STRING) &PrimaryDomainTrustInformation->FlatName,
                (PUNICODE_STRING) &AccountDomainTrustInformation->FlatName
            )) {


            Status = LsapDbLookupIsolatedDomainNameEx(
                         NameIndex,
                         &SuffixNames[NameIndex],
                         PrimaryDomainTrustInformation,
                         ReferencedDomains,
                         TranslatedSids,
                         MappedCount,
                         CompletelyUnmappedCount
                         );

            if (NT_SUCCESS(Status)) {

                continue;
            }

            if (Status != STATUS_NONE_MAPPED) {

                break;
            }

            Status = STATUS_SUCCESS;
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupIsolatedDomainNamesError;
    }

LookupIsolatedDomainNamesFinish:



    return(Status);

LookupIsolatedDomainNamesError:

    goto LookupIsolatedDomainNamesFinish;
}


NTSTATUS
LsapDbLookupNamesInLocalDomains(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    IN ULONG Options
    )

/*++

Routine Description:

    This function looks up Names in the local SAM domains and attempts to
    translate them to Sids.  Currently, there are two local SAM domains,
    the Built-in domain (which has a well-known Sid and name) and the
    Account Domain (which has a configurable Sid and name).

Arguments:

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Names - Pointer to array of Unicode Names to be translated.
        Zero or all of the Names may already have been translated
        elsewhere.  If any of the Names have been translated, the
        TranslatedSids parameter will point to a location containing a non-NULL
        array of Sid translation structures corresponding to the
        Names.  If the nth Name has been translated, the nth Sid
        translation structure will contain either a non-NULL RelativeId
        or a non-negative offset into the Referenced Domain List.  If
        the nth Name has not yet been translated, the nth Sid
        translation structure will contain SidTypeUnknown in its
        Use field.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a location containing either NULL
        or a pointer to a Referenced Domain List structure.  If an
        existing Referenced Domain List structure is supplied, it
        will be appended/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Sids.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.

    Options - Specifies optional actions.

        LSAP_DB_SEARCH_BUILT_IN_DOMAIN - Search the Built In Domain

        LSAP_DB_SEARCH_ACCOUNT_DOMAIN - Search the Account Domain

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INTERNAL_DB_ERROR - A corruption has been detected in
            the LSA Database.

        STATUS_INVALID_PARAMETER - Invalid parameter

            - No handle to the Policy object was provided on a request
              to search the Account Domain.
--*/

{
    NTSTATUS
        Status = STATUS_SUCCESS,
        SecondaryStatus = STATUS_SUCCESS;

    ULONG
        UpdatedMappedCount = *MappedCount;

    LSAPR_HANDLE
        TrustedPolicyHandle = NULL;

    PLSAPR_POLICY_ACCOUNT_DOM_INFO
        PolicyAccountDomainInfo = NULL;

    LSAPR_TRUST_INFORMATION LookupInfo;


    //
    // If there are no completely unmapped Names remaining, return.
    //

    if (*CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupNamesInLocalDomainsFinish;
    }


    //
    // If requested, lookup Names in the BUILT-IN Domain.
    //

    if (Options & LSAP_DB_SEARCH_BUILT_IN_DOMAIN) {

        Status = LsapDbLookupNamesInLocalDomain(
                     LSAP_DB_SEARCH_BUILT_IN_DOMAIN,
                     Count,
                     PrefixNames,
                     SuffixNames,
                     BuiltInDomainTrustInformation,
                     ReferencedDomains,
                     TranslatedSids,
                     &UpdatedMappedCount,
                     CompletelyUnmappedCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupNamesInLocalDomainsError;
        }

        //
        // If all Names are now mapped or partially mapped, finish.
        //

        if (*CompletelyUnmappedCount == (ULONG) 0) {

            goto LookupNamesInLocalDomainsFinish;
        }
    }

    //
    // If requested, search the Account Domain.
    //

    if (Options & LSAP_DB_SEARCH_ACCOUNT_DOMAIN) {

        Status = LsapDbLookupNamesInLocalDomainEx(
                     LSAP_DB_SEARCH_ACCOUNT_DOMAIN,
                     Count,
                     PrefixNames,
                     SuffixNames,
                     AccountDomainTrustInformation,
                     ReferencedDomains,
                     TranslatedSids,
                     &UpdatedMappedCount,
                     CompletelyUnmappedCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupNamesInLocalDomainsError;
        }

    }

LookupNamesInLocalDomainsFinish:


    //
    // Return the updated total count of Names mapped.
    //

    *MappedCount = UpdatedMappedCount;
    return(Status);

LookupNamesInLocalDomainsError:

    if (NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupNamesInLocalDomainsFinish;
}



NTSTATUS
LsapDbLookupNamesInLocalDomain(
    IN ULONG LocalDomain,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )
{

    LSAPR_TRUST_INFORMATION_EX ex;

    LsapConvertTrustToEx( &ex, TrustInformation );

    return LsapDbLookupNamesInLocalDomainEx( LocalDomain,
                                             Count,
                                             PrefixNames,
                                             SuffixNames,
                                             &ex,
                                             ReferencedDomains,
                                             TranslatedSids,
                                             MappedCount,
                                             CompletelyUnmappedCount );

}


NTSTATUS
LsapDbLookupNamesInLocalDomainEx(
    IN ULONG LocalDomain,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function looks up Names in a SAM domain on the local system and
    attempts to translate them to Sids.

Arguments:

    LocalDomain - Indicates which local domain to look in.  Valid values
        are:
                LSAP_DB_SEARCH_BUILT_IN_DOMAIN
                LSAP_DB_SEARCH_ACCOUNT_DOMAIN

    Count - Number of Names in the PrefixNames and SuffixNames arrays,
        Note that some of these may already have been mapped elsewhere, as
        specified by the MappedCount parameter.

    PrefixNames - Pointer to array of Prefix Names.  These are Domain
        Names or NULL Unicode Strings.  Only those Names whose Prefix
        Names are NULL or the same as the Domain Name specified in the
        TrustInformation parameter are eligible for the search.

    SuffixNames - Pointer to array of Terminal Names to be translated.
        Terminal Names are the last component of the name.
        Zero or all of the Names may already have been translated
        elsewhere.  If any of the Names have been translated, the
        Sids parameter will point to a location containing a non-NULL
        array of Sid translation structures corresponding to the
        Sids.  If the nth Sid has been translated, the nth Sid
        translation structure will contain either a non-NULL Sid
        or a non-negative offset into the Referenced Domain List.  If
        the nth Sid has not yet been translated, the nth name
        translation structure will contain a zero-length name string
        and a negative value for the Referenced Domain List index.

    TrustInformation - Pointer to Trust Information specifying a Domain Sid
        and Name.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to location containing NULL or a pointer to a
        array of Sid translation structures.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Sids.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS
        Status = STATUS_SUCCESS,
        SecondaryStatus = STATUS_SUCCESS,
        IgnoreStatus;

    ULONG
        UnmappedNameCount = 0,
        OutputSidsLength,
        NameLookupCount,
        NameLookupIndex,
        SidIndex;

    LONG
        DomainIndex = LSA_UNKNOWN_INDEX;

    PULONG
        SidIndices = NULL;

    PLSA_TRANSLATED_SID_EX2
        OutputSids = NULL;

    SAMPR_HANDLE
        LocalSamDomainHandle = NULL,
        LocalSamUserHandle = NULL;

    PLSAPR_UNICODE_STRING
        SamLookupSuffixNames = NULL;

    PLSAPR_SID
        DomainSid = TrustInformationEx->Sid;

    SAMPR_ULONG_ARRAY
        SamReturnedIds,
        SamReturnedUses;

    PLSAPR_TRUST_INFORMATION
        FreeTrustInformation = NULL;

    PUSER_CONTROL_INFORMATION
        UserControlInfo;

    LSAPR_TRUST_INFORMATION Dummy;
    PLSAPR_TRUST_INFORMATION TrustInformation = &Dummy;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbLookupNamesInLocalDomain\n" ));

    LsapConvertExTrustToOriginal( TrustInformation, TrustInformationEx );

    SamReturnedIds.Count = 0;
    SamReturnedIds.Element = NULL;
    SamReturnedUses.Count = 0;
    SamReturnedUses.Element = NULL;


    //
    // Make sure the SAM handles have been established.
    //

    Status = LsapOpenSam();
    ASSERT( NT_SUCCESS( Status ) );

    if ( !NT_SUCCESS( Status ) ) {

        LsapDsDebugOut(( DEB_FTRACE, "LsapDbLookupNamesInLocalDomain: 0x%lx\n", Status ));
        return( Status );
    }


    //
    // It is an internal error if the TranslatedSids or ReferencedDomains
    // parameters have not been specified.  Further, The TranslatedSids->Sids
    // pointer must be non-NULL.
    //

    ASSERT(ARGUMENT_PRESENT(TranslatedSids));
    ASSERT(TranslatedSids->Sids != NULL);
    ASSERT(ARGUMENT_PRESENT(ReferencedDomains));

    //
    // Validate the Count and MappedCount parameters.
    //


    if (*MappedCount + *CompletelyUnmappedCount > Count) {

        Status = STATUS_INVALID_PARAMETER;
        goto LookupNamesInLocalDomainError;
    }


    if (*CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupNamesInLocalDomainFinish;
    }

    //
    // Not all of the Names have yet been mapped.  We'll try to map the
    // remaining names by searching the designated SAM domain on this
    // machine.
    //

    UnmappedNameCount = Count - *MappedCount;
    OutputSids = (PLSA_TRANSLATED_SID_EX2) TranslatedSids->Sids;
    OutputSidsLength = Count * sizeof (LSA_TRANSLATED_SID_EX2);

    //
    // Allocate memory for array of names to be presented to SAM.  Note
    // that, for simplicity, we allocate an array for the maximal case
    // in which all of the reamining unmapped names are eligible
    // for the search in this domain.  This avoids having to scan the
    // names array twice, once to compute the number of eligible names.
    //

    SamLookupSuffixNames = LsapAllocateLsaHeap( UnmappedNameCount * sizeof(UNICODE_STRING));


    if (SamLookupSuffixNames == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupNamesInLocalDomainError;
    }

    //
    // Allocate an array to record indices of eligible names.  This is
    // used upon return from SAM to locate the entries in the
    // OutputSids array that are to be updated.  For simplicity, we
    // allocate the array with sufficient entries for all of the remaining
    // unmapped names.
    //

    SidIndices = LsapAllocateLsaHeap( UnmappedNameCount * sizeof(ULONG));

    if (SidIndices == NULL) {

        goto LookupNamesInLocalDomainError;
    }


    //
    // Scan the output array of Sid translations to locate entries for names
    // that have not yet been mapped.  For each unmapped name, check
    // eligibility of the name for the search of this domain.
    //
    // - All isolated names are eligible for the search
    // - All composite names having this domain name as prefix are
    //   eligible.
    //
    // Copy in each eligible suffix or isolated name to the SAM buffer.
    //

    for (NameLookupIndex = 0, SidIndex = 0; SidIndex < Count; SidIndex++) {

        if (OutputSids[SidIndex].Use == SidTypeUnknown) {

            //
            // Found a name that has not yet been mapped.  Check for a name
            // Prefix.  If none has been specified, the whole name may either
            // be NULL, the name of the domain itself or an isolated name.
            //

            if (PrefixNames[SidIndex].Length == 0) {

                //
                // Name is isolated.  If whole name is NULL, skip.
                //

                if (SuffixNames[SidIndex].Length == 0) {

                    continue;
                }

                //
                // If name is the name of the domain itself, use the
                // Trust Information to translate it, and fill in the
                // appropriate Translated Sids entry.  The name will
                // then be excluded from further searches.
                //

                if (LsapCompareDomainNames(
                        (PUNICODE_STRING) &(SuffixNames[SidIndex]),
                        (PUNICODE_STRING) &(TrustInformationEx->DomainName),
                        (PUNICODE_STRING) &(TrustInformationEx->FlatName))
                   ) {

                    Status = LsapDbLookupTranslateNameDomain(
                                 TrustInformation,
                                 &OutputSids[SidIndex],
                                 ReferencedDomains,
                                 &DomainIndex
                                 );

                    if (!NT_SUCCESS(Status)) {

                        break;
                    }

                    //
                    // Update mapped count for this isolated domain Sid
                    //
                    (*MappedCount)++;
                    continue;
                }

                //
                // Name is an isolated name not equal to the domain name and
                // so is eligible for the search.  Reference it from the SAM buffer,
                // remember its index and increment the buffer index.  The
                // SAM buffer is an IN parameter to a further lookup call.
                //

                SamLookupSuffixNames[NameLookupIndex] = SuffixNames[SidIndex];


                //
                // We should never have an index that equals or exceeds the
                // UnmappedNameCount.
                //

                ASSERT(NameLookupIndex < UnmappedNameCount);

                SidIndices[NameLookupIndex] = SidIndex;
                NameLookupIndex++;
                continue;
            }

            //
            // Name has a non-NULL Prefix Name.  Compare the name with the
            // name of the Domain being searched.
            //

            if (LsapCompareDomainNames(
                    (PUNICODE_STRING) &(PrefixNames[SidIndex]),
                    (PUNICODE_STRING) &(TrustInformationEx->DomainName),
                    (PUNICODE_STRING) &(TrustInformationEx->FlatName))

                ) {

                //
                // Prefix name matches the name of the Domain.  If the
                // Suffix Name is NULL, the name of the domain itself
                // has been specified (in the form <DomainName> "\").
                //

                if (SuffixNames[SidIndex].Length == 0) {

                    Status = LsapDbLookupTranslateNameDomain(
                                 TrustInformation,
                                 &OutputSids[SidIndex],
                                 ReferencedDomains,
                                 &DomainIndex
                                 );

                    if (!NT_SUCCESS(Status)) {

                        break;
                    }

                    //
                    // Update mapped count for this isolated domain Sid
                    //
                    (*MappedCount)++;
                    continue;
                }

                //
                // Name is composite and the Prefix name matches the name of
                // this domain.  We will at least be able to partially translate
                // name, so add this domain to the Referenced Domain List if not
                // already there.  Then reference the Suffix Name from the SAM buffer,
                // remember its index and increment the buffer index. The
                // SAM buffer is an IN parameter to a further lookup call.
                //

                if (DomainIndex == LSA_UNKNOWN_INDEX) {

                    Status = LsapDbLookupAddListReferencedDomains(
                                 ReferencedDomains,
                                 TrustInformation,
                                 &DomainIndex
                                 );

                    if (!NT_SUCCESS(Status)) {

                        break;
                    }
                }

                SamLookupSuffixNames[NameLookupIndex] = SuffixNames[SidIndex];

                SidIndices[NameLookupIndex] = SidIndex;
                OutputSids[SidIndex].DomainIndex = DomainIndex;
                NameLookupIndex++;
            }
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInLocalDomainError;
    }

    //
    // If none of the remaining Names are eligible for searching in this
    // domain, finish up.
    //

    NameLookupCount = NameLookupIndex;

    if (NameLookupCount == 0) {

        goto LookupNamesInLocalDomainFinish;
    }

    //
    //
    // Lookup the Sids in the specified SAM Domain.
    //

    if (LocalDomain == LSAP_DB_SEARCH_BUILT_IN_DOMAIN ) {
        LocalSamDomainHandle = LsapBuiltinDomainHandle;
    } else {
        ASSERT(LocalDomain == LSAP_DB_SEARCH_ACCOUNT_DOMAIN);
        LocalSamDomainHandle = LsapAccountDomainHandle;
    }

    //
    // Call SAM to lookup the Names in the Domain.
    //

    Status = SamrLookupNamesInDomain(
                 LocalSamDomainHandle,
                 NameLookupCount,
                 (PRPC_UNICODE_STRING) SamLookupSuffixNames,
                 &SamReturnedIds,
                 &SamReturnedUses
                 );

    if (!NT_SUCCESS(Status)) {

        if ( Status == STATUS_INVALID_SERVER_STATE ) {

            Status = SamrLookupNamesInDomain(
                         LocalSamDomainHandle,
                         NameLookupCount,
                         (PRPC_UNICODE_STRING) SamLookupSuffixNames,
                         &SamReturnedIds,
                         &SamReturnedUses
                         );
        }
        //
        // The only error allowed is STATUS_NONE_MAPPED.  Filter this out.
        //

        if (Status != STATUS_NONE_MAPPED) {

            goto LookupNamesInLocalDomainError;
        }

        Status = STATUS_SUCCESS;
        goto LookupNamesInLocalDomainFinish;
    }

#ifdef notdef
    //
    // Filter through the returned Ids to eliminate user accounts that are
    // not marked NORMAL.
    //

    for (NameLookupIndex = 0;
         NameLookupIndex < SamReturnedIds.Count;
         NameLookupIndex++) {

        //
        // If this account is a User Account, check its User Control
        // Information.  If the account control information indicates
        // that the account is not a Normal User Account, for example
        // it is a machine account, do not return information about
        // the account.  Mark it as unknown.
        //

        if (SamReturnedUses.Element[ NameLookupIndex ] !=  SidTypeUser) {

            continue;
        }

        Status = SamrOpenUser(
                     LocalSamDomainHandle,
                     USER_READ_ACCOUNT,
                     SamReturnedIds.Element[ NameLookupIndex ],
                     &LocalSamUserHandle
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        UserControlInfo = NULL;

        Status = SamrQueryInformationUser(
                     LocalSamUserHandle,
                     UserControlInformation,
                     (PSAMPR_USER_INFO_BUFFER *) &UserControlInfo
                     );
        IgnoreStatus = SamrCloseHandle(&LocalSamUserHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        LocalSamUserHandle = NULL;


        if (!NT_SUCCESS(Status)) {
            MIDL_user_free( UserControlInfo );
            break;
        }

        if (!(UserControlInfo->UserAccountControl & USER_NORMAL_ACCOUNT) &&
            !(UserControlInfo->UserAccountControl & USER_TEMP_DUPLICATE_ACCOUNT)) {
            SamReturnedUses.Element[NameLookupIndex] = SidTypeUnknown;
        }

        MIDL_user_free( UserControlInfo );
    }

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInLocalDomainError;
    }
#endif

    //
    // SAM found at least one eligible name in the specified domain.
    // Add the domain to the Referenced Domain List.
    //

    Status = LsapDbLookupTranslateNameDomain(
                 TrustInformation,
                 NULL,
                 ReferencedDomains,
                 &DomainIndex
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInLocalDomainError;
    }

    //
    // Now copy the information returned from SAM into the output
    // Translated Sids array.
    //

    for (NameLookupIndex = 0;
         NameLookupIndex < SamReturnedIds.Count;
         NameLookupIndex++) {

        SidIndex =  SidIndices[NameLookupIndex];

        //
        // If we have newly translated a Name, increment the mapped
        // count and copy information returned by SAM.
        //

        if ((OutputSids[SidIndex].Use == SidTypeUnknown) &&
            SamReturnedUses.Element[NameLookupIndex] != (ULONG) SidTypeUnknown) {

            PSID TempSid;

            (*MappedCount)++;
            OutputSids[SidIndex].Use = (SID_NAME_USE) SamReturnedUses.Element[NameLookupIndex];
            Status = SamrRidToSid(LocalSamDomainHandle,
                                  SamReturnedIds.Element[NameLookupIndex],
                                 (PRPC_SID*) &TempSid);
            if (NT_SUCCESS(Status)) {

                Status = LsapRpcCopySid( NULL,
                                         &OutputSids[SidIndex].Sid,
                                         TempSid);

                SamIFreeVoid(TempSid);
            }

            if ( !NT_SUCCESS(Status) ) {
                goto LookupNamesInLocalDomainError;
            }

            OutputSids[SidIndex].DomainIndex = DomainIndex;
        }
    }

LookupNamesInLocalDomainFinish:

    //
    // If successful, update count of completely unmapped names provided.
    // Note that STATUS_NONE_MAPPED errors are suppressed before we get here.
    //

    if (NT_SUCCESS(Status)) {

        LsapDbUpdateCountCompUnmappedNames(TranslatedSids, CompletelyUnmappedCount);
    }

    //
    // If necessary, free the Lsa Heap buffer allocated for the
    // SamLookupSuffixNames and SidIndices arrays.
    //

    if (SamLookupSuffixNames != NULL) {
        LsapFreeLsaHeap( SamLookupSuffixNames );
    }

    if (SidIndices != NULL) {
        LsapFreeLsaHeap( SidIndices );
    }

    //
    // If necessary, free the Relative Ids array returned from SAM.
    //

    if ( SamReturnedIds.Count != 0 ) {
        SamIFree_SAMPR_ULONG_ARRAY ( &SamReturnedIds );
    }

    //
    // If necessary, free the Uses array returned from SAM.
    //

    if ( SamReturnedUses.Count != 0 ) {
        SamIFree_SAMPR_ULONG_ARRAY ( &SamReturnedUses );
    }


    LsapDsDebugOut(( DEB_FTRACE, "LsapDbLookupNamesInLocalDomain: 0x%lx\n", Status ));

    return(Status);

LookupNamesInLocalDomainError:

    //
    // If necessary, free memory for the OutputTrustInformation Domain
    // Name Buffer and Sid Buffer.
    //

    if (DomainIndex >= 0) {

        FreeTrustInformation = &ReferencedDomains->Domains[DomainIndex];

        if (FreeTrustInformation->Sid != NULL) {

            MIDL_user_free( FreeTrustInformation->Sid );
            FreeTrustInformation->Sid = NULL;
        }

        if (FreeTrustInformation->Name.Buffer != NULL) {

            MIDL_user_free( FreeTrustInformation->Name.Buffer );
            FreeTrustInformation->Name.Buffer = NULL;
            FreeTrustInformation->Name.Length = 0;
            FreeTrustInformation->Name.MaximumLength = 0;
        }
    }

    //
    // Reset the Use field for each of the entries written to back to
    // SidTypeUnknown and set the DomainIndex back to LSA_UNKNOWN_INDEX.
    //

    for (NameLookupIndex = 0;
         NameLookupIndex < SamReturnedIds.Count;
         NameLookupIndex++) {

        SidIndex =  SidIndices[NameLookupIndex];
        OutputSids[SidIndex].Use = SidTypeUnknown;
        OutputSids[SidIndex].DomainIndex = LSA_UNKNOWN_INDEX;
    }


    //
    // If the last User Account handle is still open, close it..
    //

    if (LocalSamUserHandle != NULL) {
        SecondaryStatus = SamrCloseHandle(&LocalSamUserHandle);
        LocalSamUserHandle = NULL;
    }

    goto LookupNamesInLocalDomainFinish;
}


NTSTATUS
LsapDbLookupNamesInPrimaryDomain(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT BOOLEAN *fDownlevelSecureChannel,
    IN NTSTATUS *NonFatalStatus
    )

/*++

Routine Description:

    This function attempts to translate Names by searching the Primary
    Domain.

Arguments:

    LookupOptions -- LSA_LOOKUP_ISOLATED_AS_LOCAL

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Names - Pointer to array of Names to be translated.
        Zero or all of the Names may already have been translated
        elsewhere.  If any of the Names have been translated, the
        TranslatedSids parameter will point to a location containing a non-NULL
        array of Sid translation structures corresponding to the
        Names.  If the nth Name has been translated, the nth Sid
        translation structure will contain either a non-NULL Sid
        or a non-negative offset into the Referenced Domain List.  If
        the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string
        and a negative value for the Referenced Domain List index.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    TrustInformation - Specifies the name and Sid of the Primary Domain.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        NOTE:  LsapLookupWksta is not valid for this parameter.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.


    NonFatalStatus - a status to indicate reasons why no names could have been
                     resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    ULONG NextLevelCount;
    ULONG NextLevelMappedCount;
    ULONG NameIndex;
    ULONG NextLevelNameIndex;
    PLSAPR_REFERENCED_DOMAIN_LIST NextLevelReferencedDomains = NULL;
    PLSAPR_REFERENCED_DOMAIN_LIST OutputReferencedDomains = NULL;
    PLSAPR_TRANSLATED_SID_EX2 NextLevelSids = NULL;
    PLSAPR_UNICODE_STRING NextLevelNames = NULL;
    PLSAPR_UNICODE_STRING NextLevelPrefixNames = NULL;
    PLSAPR_UNICODE_STRING NextLevelSuffixNames = NULL;
    LONG FirstEntryIndex;
    PULONG NameIndices = NULL;
    BOOLEAN PartialNameTranslationsAttempted = FALSE;
    ULONG ServerRevision = 0;

    LSAPR_TRUST_INFORMATION Dummy;
    PLSAPR_TRUST_INFORMATION TrustInformation = &Dummy;

    LsapConvertExTrustToOriginal( TrustInformation, TrustInformationEx );

    *NonFatalStatus = STATUS_SUCCESS;

    //
    // If there are no completely unmapped Names remaining, just return.
    //

    if (*CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupNamesInPrimaryDomainFinish;
    }

    //
    // We have successfully opened a Domain Controller's Policy
    // Database.  Now prepare to hand off a Name lookup for the
    // remaining unmapped Names to that Controller.  Here, this
    // server side of the LSA is a client of the LSA on the
    // target controller.  We will construct an array of the
    // remianing unmapped Names, look them up and then merge the
    // resulting ReferencedDomains and Translated Sids into
    // our existing list.
    //

    NextLevelCount = *CompletelyUnmappedCount;

    //
    // Allocate an array to hold the indices of unmapped Names
    // relative to the original Names and TranslatedSids->Sids
    // arrays.
    //

    NameIndices = MIDL_user_allocate(NextLevelCount * sizeof(ULONG));

    Status = STATUS_INSUFFICIENT_RESOURCES;

    if (NameIndices == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }

    //
    // Allocate an array of UNICODE_STRING structures for the
    // names to be looked up at the Domain Controller.
    //

    NextLevelNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelNames == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }

    //
    // Allocate an array of UNICODE_STRING structures for the
    // prefix names to be cached.
    //

    NextLevelPrefixNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelPrefixNames == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }
    //
    // Allocate an array of UNICODE_STRING structures for the
    // suffix names to be cached.
    //

    NextLevelSuffixNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelSuffixNames == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }

    Status = STATUS_SUCCESS;

    //
    // Now scan the original array of Names and its parallel
    // Translated Sids array.  Copy over any names that are completely
    // unmapped.
    //

    NextLevelNameIndex = (ULONG) 0;

    for (NameIndex = 0;
         NameIndex < Count && NextLevelNameIndex < NextLevelCount;
         NameIndex++) {

        if (LsapDbCompletelyUnmappedSid(&TranslatedSids->Sids[NameIndex])) {

            if ( (LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL)
              && (PrefixNames[NameIndex].Length == 0)  ) {

               //
               // Don't lookup isolated names off machine
               //
               continue;
            }

            NextLevelNames[NextLevelNameIndex] = Names[NameIndex];
            NextLevelPrefixNames[NextLevelNameIndex] = PrefixNames[NameIndex];
            NextLevelSuffixNames[NextLevelNameIndex] = SuffixNames[NameIndex];

            NameIndices[NextLevelNameIndex] = NameIndex;
            NextLevelNameIndex++;

        }
    }

    if (NextLevelNameIndex == 0) {

        // Nothing to do
        Status = STATUS_SUCCESS;
        goto LookupNamesInPrimaryDomainFinish;
    }

    NextLevelMappedCount = (ULONG) 0;

    Status = LsapDbLookupNameChainRequest(TrustInformationEx,
                                          NextLevelCount,
                                          (PUNICODE_STRING)NextLevelNames,
                                          (PLSA_REFERENCED_DOMAIN_LIST *)&NextLevelReferencedDomains,
                                          (PLSA_TRANSLATED_SID_EX2 * )&NextLevelSids,
                                          LookupLevel,
                                          &NextLevelMappedCount,
                                          &ServerRevision
                                          );

    if ( 0 != ServerRevision ) {
        if ( ServerRevision & LSA_CLIENT_PRE_NT5 ) {
             *fDownlevelSecureChannel = TRUE;
        }
    }

    //
    // If the callout to LsaLookupNames() was unsuccessful, disregard
    // the error and set the domain name for any Sids having this
    // domain Sid as prefix sid.
    //

    if (!NT_SUCCESS(Status) && Status != STATUS_NONE_MAPPED) {

        //
        // Let the caller know there is a trust problem
        //
        if ( LsapDbIsStatusConnectionFailure(Status) ) {
            *NonFatalStatus = Status;
        }

        Status = STATUS_SUCCESS;
        goto LookupNamesInPrimaryDomainFinish;
    }

    //
    // Cache any sids that came back
    //

    (void) LsapDbUpdateCacheWithNames(
            (PUNICODE_STRING) NextLevelSuffixNames,
            (PUNICODE_STRING) NextLevelPrefixNames,
            NextLevelCount,
            NextLevelReferencedDomains,
            NextLevelSids
            );

    //
    // The callout to LsaLookupNames() was successful.  We now have
    // an additional list of Referenced Domains containing the
    // Primary Domain and/or one or more of its Trusted Domains.
    // Merge the two Referenced Domain Lists together, noting that
    // since they are disjoint, the second list is simply
    // concatenated with the first.  The index of the first entry
    // of the second list will be used to adjust all of the
    // Domain Index entries in the Translated Names entries.
    // Note that since the memory for the graph of the first
    // Referenced Domain list has been allocated as individual
    // nodes, we specify that the nodes in this graph can be
    // referenced by the output Referenced Domain list.
    //

    Status = LsapDbLookupMergeDisjointReferencedDomains(
                 ReferencedDomains,
                 NextLevelReferencedDomains,
                 &OutputReferencedDomains,
                 LSAP_DB_USE_FIRST_MERGAND_GRAPH
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInPrimaryDomainError;
    }

    FirstEntryIndex = ReferencedDomains->Entries;

    //
    // Now update the original list of Translated Names.  We
    // update each entry that has newly been translated by copying
    // the entry from the new list and adjusting its
    // Referenced Domain List Index upwards by adding the index
    // of the first entry in the Next level List..
    //

    for( NextLevelNameIndex = 0;
         NextLevelNameIndex < NextLevelCount;
         NextLevelNameIndex++ ) {

        if ( !LsapDbCompletelyUnmappedSid(&NextLevelSids[NextLevelNameIndex]) ) {

            NameIndex = NameIndices[NextLevelNameIndex];

            TranslatedSids->Sids[NameIndex]
            = NextLevelSids[NextLevelNameIndex];

            Status = LsapRpcCopySid(NULL,
                                    &TranslatedSids->Sids[NameIndex].Sid,
                                    NextLevelSids[NextLevelNameIndex].Sid);

            if (!NT_SUCCESS(Status)) {
                goto LookupNamesInPrimaryDomainError;
            }

            TranslatedSids->Sids[NameIndex].DomainIndex =
                FirstEntryIndex +
                NextLevelSids[NextLevelNameIndex].DomainIndex;

            (*CompletelyUnmappedCount)--;
        }
    }

    //
    // Update the Referenced Domain List if a new one was produced
    // from the merge.  We retain the original top-level structure.
    //

    if (OutputReferencedDomains != NULL) {

        if (ReferencedDomains->Domains != NULL) {

            MIDL_user_free( ReferencedDomains->Domains );
            ReferencedDomains->Domains = NULL;
        }

        *ReferencedDomains = *OutputReferencedDomains;
        MIDL_user_free( OutputReferencedDomains );
        OutputReferencedDomains = NULL;
    }

    //
    // Update the Mapped Count and close the Controller Policy
    // Handle.
    //

    *MappedCount += NextLevelMappedCount;

    //
    // Any error status that has not been suppressed must be reported
    // to the caller.  Errors such as connection failures to other LSA's
    // are suppressed.
    //

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInPrimaryDomainError;
    }

LookupNamesInPrimaryDomainFinish:

    //
    // If necessary, update count of completely unmapped names.
    //

    if (*CompletelyUnmappedCount > (ULONG) 0) {

        LsapDbUpdateCountCompUnmappedNames(TranslatedSids, CompletelyUnmappedCount);
    }

    //
    // We can return partial translations for composite Names in which the
    // domain component is known.  We do this provided there has been
    // no reported error.  Errors resulting from callout to another
    // LSA will have been suppressed.
    //

    if (NT_SUCCESS(Status) &&
        (*MappedCount < Count) &&
        !PartialNameTranslationsAttempted) {

        SecondaryStatus = LsapDbLookupTranslateUnknownNamesInDomain(
                              Count,
                              Names,
                              PrefixNames,
                              SuffixNames,
                              TrustInformationEx,
                              ReferencedDomains,
                              TranslatedSids,
                              LookupLevel,
                              MappedCount,
                              CompletelyUnmappedCount
                              );

        PartialNameTranslationsAttempted = TRUE;

        if (!NT_SUCCESS(SecondaryStatus)) {

            goto LookupNamesInPrimaryDomainError;
        }
    }

    //
    // If necessary, free the Next Level Referenced Domain List.
    // Note that this structure is allocated(all_nodes) since it was
    // allocated by the client side of the Domain Controller LSA.
    //

    if (NextLevelReferencedDomains != NULL) {

        MIDL_user_free( NextLevelReferencedDomains );
        NextLevelReferencedDomains = NULL;
    }

    //
    // If necessary, free the Next Level Names array.  We only free the
    // top level, since the names therein were copied from the input
    // TranslatedNames->Names array.
    //

    if (NextLevelNames != NULL) {

        MIDL_user_free( NextLevelNames );
        NextLevelNames = NULL;
    }

    if (NextLevelPrefixNames != NULL) {

        MIDL_user_free( NextLevelPrefixNames );
        NextLevelPrefixNames = NULL;
    }

    if (NextLevelSuffixNames != NULL) {

        MIDL_user_free( NextLevelSuffixNames );
        NextLevelSuffixNames = NULL;
    }

    //
    // If necessary, free the Next Level Translated Sids array.  Note
    // that this array is allocated(all_nodes).
    //

    if (NextLevelSids != NULL) {

        MIDL_user_free( NextLevelSids );
        NextLevelSids = NULL;
    }

    //
    // If necessary, free the array that maps Name Indices from the
    // Next Level to the Current Level.
    //

    if (NameIndices != NULL) {

        MIDL_user_free( NameIndices );
        NameIndices = NULL;
    }

    return(Status);

LookupNamesInPrimaryDomainError:

    //
    // If the primary status was a success code, but the secondary
    // status was an error, propagate the secondary status.
    //

    if ((!NT_SUCCESS(SecondaryStatus)) && NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupNamesInPrimaryDomainFinish;
}


NTSTATUS
LsapDbLookupNamesInTrustedDomains(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN BOOLEAN fIncludeIntraforest,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    IN NTSTATUS   *NonFatalStatus
    )

/*++

Routine Description:

    This function attempts to lookup Names to see if they belong to
    any of the Domains that are trusted by the Domain for which this
    machine is a DC.

Arguments:

    LookupOptions - LSA_LOOKUP_ISOLATED_AS_LOCAL

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    fIncludeIntraforest -- if TRUE, trusted domains in our local forest
                           are searched.

    Names - Pointer to array of Names to be translated.  Zero or all of the
        Names may already have been translated elsewhere.  If any of the
        Names have been translated, the TranslatedSids parameter will point
        to a location containing a non-NULL array of Sid translation
        structures corresponding to the Names.  If the nth Name has been
        translated, the nth Sid translation structure will contain either a
        non-NULL Sid or a non-negative offset into the Referenced Domain
        List.  If the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string and a
        negative value for the Referenced Domain List index.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

        NOTE:  LsapLookupWksta is not valid for this parameter.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.

    NonFatalStatus - a status to indicate reasons why no names could have been
                    resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_LOOKUP_WORK_LIST WorkList = NULL;

    *NonFatalStatus = STATUS_SUCCESS;
    //
    // Build a WorkList for this Lookup and put it on the Work Queue.
    //
    // NOTE: This routine does not need to hold the Lookup Work Queue
    //       lock to ensure validity of the WorkList pointer, because the
    //       pointer remains valid until this routine frees it via
    //       LsapDbLookupDeleteWorkList().  Although other threads may
    //       process the WorkList, do not delete it.
    //
    //       A called routine must acquire the lock in order to access
    //       the WorkList after it has been added to the Work Queue.
    //

    Status = LsapDbLookupNamesBuildWorkList(
                 LookupOptions,
                 Count,
                 fIncludeIntraforest,
                 Names,
                 PrefixNames,
                 SuffixNames,
                 ReferencedDomains,
                 TranslatedSids,
                 LookupLevel,
                 MappedCount,
                 CompletelyUnmappedCount,
                 &WorkList
                 );

    if (!NT_SUCCESS(Status)) {

        //
        // If no Work List has been built because there are no
        // eligible domains to search, exit, suppressing the error.

        if (Status == STATUS_NONE_MAPPED) {

            Status = STATUS_SUCCESS;
            goto LookupNamesInTrustedDomainsFinish;
        }

        goto LookupNamesInTrustedDomainsError;
    }

    //
    // Start the work, by dispatching one or more worker threads
    // if necessary.
    //

    Status = LsapDbLookupDispatchWorkerThreads( WorkList );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInTrustedDomainsError;
    }

    //
    // Wait for completion/termination of all items on the Work List.
    //

    Status = LsapDbLookupAwaitCompletionWorkList( WorkList );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInTrustedDomainsError;
    }

LookupNamesInTrustedDomainsFinish:


    if ( WorkList &&
         !NT_SUCCESS( WorkList->NonFatalStatus ) )
    {
        //
        // Propogate the error as non fatal
        //
        *NonFatalStatus = WorkList->NonFatalStatus;
    }

    //
    // If a Work List was created, delete it from the Work Queue
    //

    if (WorkList != NULL) {

        Status = LsapDbLookupDeleteWorkList( WorkList );
        WorkList = NULL;
    }

    return(Status);

LookupNamesInTrustedDomainsError:

    goto LookupNamesInTrustedDomainsFinish;
}


NTSTATUS
LsapDbLookupTranslateNameDomain(
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OPTIONAL PLSA_TRANSLATED_SID_EX2 TranslatedSid,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    OUT PLONG DomainIndex
    )

/*++

Routine Description:

    This function optionally produces a Translated Sid entry for Domain
    from its Name and Sid, and adds Trust Information for the Domain to
    a Referenced Domain List.  The index of the new (or existing) entry
    in the Referenced Domain List is returned.

Arguments:

    TrustInformation - Pointer to Trust Information for the Domain consisting
        of its Name and Sid.

    TranslatedSid - Optional pointer to Translated Sid entry which will
        be filled in with the translation for this Domain.  If NULL
        is specified, no entry is fiiled in.

    ReferencedDomains - Pointer to Referenced Domain List in which an
        entry consisting of the Trust Information for the Domain will be
        made if one does not already exist.

    DomainIndex - Receives the index of the existing or new entry for the
        Domain in the Referenced Domain List.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status;


    Status = LsapDbLookupAddListReferencedDomains(
                 ReferencedDomains,
                 TrustInformation,
                 DomainIndex
                 );

    if (!NT_SUCCESS(Status)) {

        goto TranslateNameDomainError;
    }

    //
    // If requested, fill in a Sid translation entry for the domain.
    //

    if (TranslatedSid != NULL) {

        Status = LsapRpcCopySid(
                     NULL,
                     (PSID) &TranslatedSid->Sid,
                     (PSID) TrustInformation->Sid
                     );
        if (!NT_SUCCESS(Status)) {
            goto TranslateNameDomainError;
        }
        TranslatedSid->Use = SidTypeDomain;
        TranslatedSid->DomainIndex = *DomainIndex;
    }

TranslateNameDomainFinish:

    return(Status);

TranslateNameDomainError:

    goto TranslateNameDomainFinish;
}


NTSTATUS
LsapDbLookupTranslateUnknownNamesInDomain(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function looks among the unknown Sids in the given list and
    translates the Domain Name for any whose Domain Prefix Sid matches
    the given Domain Sid.

Arguments:

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Names - Pointer to array of Names to be translated.
        Zero or all of the Names may already have been translated
        elsewhere.  If any of the Names have been translated, the
        TranslatedSids parameter will point to a location containing a non-NULL
        array of Sid translation structures corresponding to the
        Names.  If the nth Name has been translated, the nth Sid
        translation structure will contain either a non-NULL Sid
        or a non-negative offset into the Referenced Domain List.  If
        the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string
        and a negative value for the Referenced Domain List index.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    TrustInformation - Pointer to Trust Information specifying a Domain Sid
        and Name.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

        NOTE:  LsapLookupWksta is not valid for this parameter.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG RemainingCompletelyUnmappedCount;
    ULONG NameIndex;
    PLSAPR_UNICODE_STRING DomainName = &TrustInformationEx->FlatName;
    PLSAPR_UNICODE_STRING DnsDomainName = &TrustInformationEx->DomainName;
    BOOLEAN DomainAlreadyAdded = FALSE;
    LONG DomainIndex = 0;
    LSAPR_TRUST_INFORMATION Dummy;
    PLSAPR_TRUST_INFORMATION TrustInformation = &Dummy;

    LsapConvertExTrustToOriginal( TrustInformation, TrustInformationEx );


    //
    // Scan the array of Names looking for composite ones whose domain has
    // not been found.
    //

    for( NameIndex = 0,
         RemainingCompletelyUnmappedCount = *CompletelyUnmappedCount;
         (RemainingCompletelyUnmappedCount > 0) && (NameIndex < Count);
         NameIndex++) {

        //
        // Check if this Name is completely unmapped (i.e. its domain
        // has not yet been identified).
        //

        if (TranslatedSids->Sids[NameIndex].DomainIndex == LSA_UNKNOWN_INDEX) {

            //
            // Found a completely unmapped Name.  If it belongs to the
            // specified Domain, add the Domain to the Referenced Domain
            // list if we have not already done so.
            //

            if (LsapRtlPrefixName(
                    (PUNICODE_STRING) DomainName,
                    (PUNICODE_STRING) &Names[NameIndex])
             || LsapRtlPrefixName(
                    (PUNICODE_STRING) DnsDomainName,
                    (PUNICODE_STRING) &Names[NameIndex])
                    ) {

                if (!DomainAlreadyAdded) {

                    Status = LsapDbLookupAddListReferencedDomains(
                                 ReferencedDomains,
                                 TrustInformation,
                                 &DomainIndex
                                 );

                    if (!NT_SUCCESS(Status)) {

                        break;
                    }

                    DomainAlreadyAdded = TRUE;
                }

                //
                // Reference the domain from the TranslatedNames entry
                //

                TranslatedSids->Sids[NameIndex].DomainIndex = DomainIndex;

                //
                // This name is now partially translated, so reduce the
                // count of completely unmapped names.
                //

                (*CompletelyUnmappedCount)--;
            }

            //
            // Decrement count of completely unmapped Names scanned.
            //

            RemainingCompletelyUnmappedCount--;
        }
    }

    return(Status);
}


NTSTATUS
LsapDbLookupIsolatedDomainName(
    IN ULONG NameIndex,
    IN PLSAPR_UNICODE_STRING IsolatedName,
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )
{
    LSAPR_TRUST_INFORMATION_EX ex;

    LsapConvertTrustToEx( &ex, TrustInformation );

    return LsapDbLookupIsolatedDomainNameEx( NameIndex,
                                             IsolatedName,
                                             &ex,
                                             ReferencedDomains,
                                             TranslatedSids,
                                             MappedCount,
                                             CompletelyUnmappedCount);
}


NTSTATUS
LsapDbLookupIsolatedDomainNameEx(
    IN ULONG NameIndex,
    IN PLSAPR_UNICODE_STRING IsolatedName,
    IN PLSAPR_TRUST_INFORMATION_EX TrustInformationEx,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function translates an Isolated Name if it matches a
    given Domain Name.

Arguments:

    NameIndex - Specifies the index of the entry for the Name within
        the TranslatedSids array, which will be updated if the Name
        matches the Domain Name contained in the TrusteInformation parameter.

    IsolatedName - Specifies the Name to be compared with the Domain Name
        contained in the TrustInformation parameter.

    TrustInformation - Specifies the Name and Sid of a Domain.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_NONE_MAPPED - The specified name is not the same as the
                             name of the specified domain.

        Result codes from called routines.

--*/

{
    NTSTATUS Status = STATUS_NONE_MAPPED;

    LSAPR_TRUST_INFORMATION  Dummy;
    PLSAPR_TRUST_INFORMATION TrustInformation = &Dummy;
    ULONG Length;

    LsapConvertExTrustToOriginal( TrustInformation, TrustInformationEx );

    //
    // See if the names match.  If they don't, return error.
    //
    if (!LsapCompareDomainNames(
            (PUNICODE_STRING) IsolatedName,
            (PUNICODE_STRING) &(TrustInformationEx->DomainName),
            (PUNICODE_STRING) &(TrustInformationEx->FlatName))
        )
    {
        goto LookupIsolatedDomainNameError;

    }

    //
    // Name matches the name of the given Domain.  Add that
    // Domain to the Referenced Domain List and translate it.
    //

    Status = LsapDbLookupAddListReferencedDomains(
                 ReferencedDomains,
                 TrustInformation,
                 (PLONG) &TranslatedSids->Sids[NameIndex].DomainIndex
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupIsolatedDomainNameError;
    }

    //
    // Fill in the Translated Sids entry.
    //

    TranslatedSids->Sids[NameIndex].Use = SidTypeDomain;

    Length = RtlLengthSid(TrustInformation->Sid);
    TranslatedSids->Sids[NameIndex].Sid = MIDL_user_allocate(Length);
    if (TranslatedSids->Sids[NameIndex].Sid == NULL) {
        Status = STATUS_NO_MEMORY;
        goto LookupIsolatedDomainNameError;
    }
    RtlCopySid(Length,
               TranslatedSids->Sids[NameIndex].Sid,
               TrustInformation->Sid);

    Status = STATUS_SUCCESS;
    (*MappedCount)++;
    (*CompletelyUnmappedCount)--;

LookupIsolatedDomainNameFinish:

    return(Status);

LookupIsolatedDomainNameError:

    goto LookupIsolatedDomainNameFinish;
}

NTSTATUS
LsarGetUserName(
    IN PLSAPR_SERVER_NAME ServerName,
    IN OUT PLSAPR_UNICODE_STRING * UserName,
    OUT OPTIONAL PLSAPR_UNICODE_STRING * DomainName
    )

/*++

Routine Description:

    This routine is the LSA Server worker routine for the LsaGetUserName
    API.


    WARNING:  This routine allocates memory for its output.  The caller is
    responsible for freeing this memory after use.  See description of the
    Names parameter.

Arguments:

    ServerName - the name of the server the client asked to execute
        this API on, or NULL for the local machine.

    UserName - Receives name of the current user.

    DomainName - Optionally receives domain name of the current user.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and all Sids have
            been translated to names.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            such as memory to complete the call.
--*/

{
    LUID LogonId;
    LUID SystemLogonId = SYSTEM_LUID ;
    PUNICODE_STRING AccountName;
    PUNICODE_STRING AuthorityName;
    PSID UserSid;
    PSID DomainSid = NULL;
    ULONG Rid;
    PLSAP_LOGON_SESSION LogonSession = NULL ;
    PTOKEN_USER TokenUserInformation = NULL;
    NTSTATUS Status;

    LsarpReturnCheckSetup();

    //
    // Sanity check the input arguments
    //
    if ( *UserName != NULL ) {
        return STATUS_INVALID_PARAMETER;
    }


    if (ARGUMENT_PRESENT(DomainName)) {

        if ( *DomainName != NULL ) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Let's see if we're trying to look up the currently logged on
    // user.
    //
    //
    // TokenUserInformation from this call must be freed by calling
    // LsapFreeLsaHeap().
    //

    Status = LsapQueryClientInfo(
                &TokenUserInformation,
                &LogonId
                );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the user ID is Anonymous then there is no name and domain in the
    // logon session
    //

    if (RtlEqualSid(
            TokenUserInformation->User.Sid,
            LsapAnonymousSid
            )) {
        AccountName = &WellKnownSids[LsapAnonymousSidIndex].Name;
        AuthorityName = &WellKnownSids[LsapAnonymousSidIndex].DomainName;

    } else if (RtlEqualLuid( &LogonId, &SystemLogonId ) ) {

        AccountName = LsapDbWellKnownSidName( LsapLocalSystemSidIndex );
        AuthorityName = LsapDbWellKnownSidDescription( LsapLocalSystemSidIndex );

    } else {

        LogonSession = LsapLocateLogonSession ( &LogonId );

        //
        // During setup, we may get NULL returned for the logon session.
        //

        if (LogonSession == NULL) {

            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto Cleanup;
        }

        //
        // Got a match.  Get the username and domain information
        // from the LogonId
        //


        AccountName   = &LogonSession->AccountName;
        AuthorityName = &LogonSession->AuthorityName;

    }

    *UserName = MIDL_user_allocate(sizeof(LSAPR_UNICODE_STRING));

    if (*UserName == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsapRpcCopyUnicodeString(
                NULL,
                (PUNICODE_STRING) *UserName,
                AccountName
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Optionally copy the domain name
    //

    if (ARGUMENT_PRESENT(DomainName)) {

        *DomainName = MIDL_user_allocate(sizeof(LSAPR_UNICODE_STRING));

        if (*DomainName == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = LsapRpcCopyUnicodeString(
                    NULL,
                    (PUNICODE_STRING) *DomainName,
                    AuthorityName
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

    }




Cleanup:

    if ( LogonSession )
    {
        LsapReleaseLogonSession( LogonSession );
    }

    if (TokenUserInformation != NULL) {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if (!NT_SUCCESS(Status)) {
        if (*UserName != NULL) {
            if ((*UserName)->Buffer != NULL) {
                MIDL_user_free((*UserName)->Buffer);
            }
            MIDL_user_free(*UserName);
            *UserName = NULL;
        }

        if ( ARGUMENT_PRESENT(DomainName) ){
            if (*DomainName != NULL) {
                if ((*DomainName)->Buffer != NULL) {
                    MIDL_user_free((*DomainName)->Buffer);
                }
                MIDL_user_free(*DomainName);
                *DomainName = NULL;
            }
        }
    }

    LsarpReturnPrologue();

    return(Status);
}




VOID
LsapDbFreeEnumerationBuffer(
    IN PLSAP_DB_NAME_ENUMERATION_BUFFER DbEnumerationBuffer
    )
/*++

Routine Description:

    This routine will free the memory associated with an enumeration buffer

Arguments:

    DbEnumerationBuffer - Enumeration buffer to free

Return Values:

    VOID
--*/
{
    ULONG i;

    if ( DbEnumerationBuffer == NULL || DbEnumerationBuffer->EntriesRead == 0 ||
         DbEnumerationBuffer->Names == NULL ) {

         return;
    }

    for ( i = 0; i < DbEnumerationBuffer->EntriesRead; i++) {

        MIDL_user_free( DbEnumerationBuffer->Names[ i ].Buffer );
    }

    MIDL_user_free( DbEnumerationBuffer->Names );
}


NTSTATUS
LsapDbLookupNamesInGlobalCatalog(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    )
/*++

Routine Description:

    This routine looks at the list of name that have yet to be resolved.
    If the any of the names belong to domain that are stored in the DS,
    then these sids are packaged up and sent to a GC for translation.

    Note: this will resolve names from domains that we trust directly and
    indirectly

    Note: names with no domain name are also sent to the GC

Arguments:

    LookupOptions - LSA_LOOKUP_ISOLATED_AS_LOCAL

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Names - Pointer to array of Names to be translated.  Zero or all of the
        Names may already have been translated elsewhere.  If any of the
        Names have been translated, the TranslatedSids parameter will point
        to a location containing a non-NULL array of Sid translation
        structures corresponding to the Names.  If the nth Name has been
        translated, the nth Sid translation structure will contain either a
        non-NULL Sid or a non-negative offset into the Referenced Domain
        List.  If the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string and a
        negative value for the Referenced Domain List index.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.


    NonFatalStatus - a status to indicate reasons why no names could have been
                      resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;

    ULONG          cGcNames = 0;
    BOOLEAN        *PossibleGcNames = NULL;
    SID_NAME_USE   *GcSidNameUse = NULL;
    UNICODE_STRING *GcNames = NULL;
    ULONG          *GcNameOriginalIndex = NULL;
    PSAMPR_PSID_ARRAY SidArray = NULL;
    ULONG          *GcNamesFlags = NULL;
    ULONG           Length;

    ULONG i;

    *NonFatalStatus = STATUS_SUCCESS;

    //
    // Determine what sids are part of known nt5 domains
    // and package into an array
    //
    ASSERT( Count == TranslatedSids->Entries );

    if ( !SampUsingDsData() ) {

        //
        // Only useful if the ds is running
        //
        return STATUS_SUCCESS;

    }

    PossibleGcNames = MIDL_user_allocate( Count * sizeof(BOOLEAN) );
    if ( !PossibleGcNames ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( PossibleGcNames, Count * sizeof(BOOLEAN) );

    for ( i = 0; i < Count; i++ ) {

        if ( LsapDbCompletelyUnmappedSid(&TranslatedSids->Sids[i]) ) {

            //
            // If the name
            //
            // 1. has a domain portion and
            // 2. the domain is not in the forest and
            // 3. the domain is a directly trusted domain
            //
            // then don't look up at the GC -- use the direct
            // trust link instead
            //
            if ( PrefixNames[i].Length != 0 ) {

                NTSTATUS Status2;

                Status2 = LsapDomainHasDirectExternalTrust((PUNICODE_STRING)&PrefixNames[i],
                                                            NULL,
                                                            NULL,
                                                            NULL);
                if (NT_SUCCESS(Status2)) {
                    continue;
                }
            }

            //
            // If the name is isolated are we are asked not to lookup isolated
            // names, then don't send to the GC
            //

            if ((LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL)
             &&  PrefixNames[i].Length == 0  ) {
               continue;
            }

            //
            // Can no longer filter since some names might belog to trusted
            // forest.  Note this also fixes 196280.
            //
            cGcNames++;
            PossibleGcNames[i] = TRUE;
        }
    }

    // We should no more than the number of unmapped sids!
    ASSERT( cGcNames <= *CompletelyUnmappedCount );

    if ( 0 == cGcNames ) {
        // nothing to do
        goto Finish;
    }

    //
    // Allocate lots of space to hold the resolved names; this space will
    // be freed at the end of the routine
    //
    GcNames = MIDL_user_allocate( cGcNames * sizeof(UNICODE_STRING) );
    if ( !GcNames ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( GcNames, cGcNames * sizeof(UNICODE_STRING) );

    GcNameOriginalIndex = MIDL_user_allocate( cGcNames * sizeof(ULONG) );
    if ( !GcNameOriginalIndex ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( GcNameOriginalIndex, cGcNames * sizeof(ULONG) );

    cGcNames = 0;
    for ( i = 0; i < Count; i++ ) {

        if ( PossibleGcNames[i] ) {

            ASSERT( sizeof(GcNames[cGcNames]) == sizeof(Names[i]) );
            memcpy( &GcNames[cGcNames], &Names[i], sizeof(UNICODE_STRING) );
            GcNameOriginalIndex[cGcNames] = i;
            cGcNames++;

        }
    }

    // we are done with this
    MIDL_user_free( PossibleGcNames );
    PossibleGcNames = NULL;

    GcSidNameUse = MIDL_user_allocate( cGcNames * sizeof(SID_NAME_USE) );
    if ( !GcSidNameUse ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( GcSidNameUse, cGcNames * sizeof(SID_NAME_USE) );


    GcNamesFlags = MIDL_user_allocate( cGcNames * sizeof(ULONG) );
    if ( !GcNamesFlags ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }
    RtlZeroMemory( GcNamesFlags, cGcNames * sizeof(ULONG) );

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Chaining a name request to a GC\n"));

    //
    // Call into SAM to resolve the sids at a GC
    //
    Status = SamIGCLookupNames( cGcNames,
                                GcNames,
                                SAMP_LOOKUP_BY_UPN,
                                GcNamesFlags,
                                GcSidNameUse,
                                &SidArray );

    if (!NT_SUCCESS(Status)) {
        LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Chain to GC request failed  (0x%x)\n", Status));
    }

    if ( STATUS_DS_GC_NOT_AVAILABLE == Status ) {


        //
        // Ok, don't update the mapped count since no names were
        // resolved
        //
        LsapDbLookupReportEvent0( 1,
                                  EVENTLOG_WARNING_TYPE,
                                  LSAEVENT_LOOKUP_GC_FAILED,
                                  sizeof( ULONG ),
                                  &Status);
        *NonFatalStatus = Status;
        Status = STATUS_SUCCESS;
        goto Finish;

    }

    // Any other error is fatal
    if ( !NT_SUCCESS( Status ) ) {
        goto Finish;
    }

    //
    // For each name resolved, put back in the original array and update
    // the referenced domain's list
    //
    for ( i = 0; i < cGcNames; i++ ) {

        BOOLEAN fStatus;
        ULONG OriginalIndex;
        LSAPR_TRUST_INFORMATION TrustInformation;
        PSID  DomainSid = NULL;
        ULONG Rid = 0;
        ULONG DomainIndex = LSA_UNKNOWN_INDEX;

        RtlZeroMemory( &TrustInformation, sizeof(TrustInformation) );

        if (GcNamesFlags[i] & SAMP_FOUND_XFOREST_REF) {

            //
            // Flag this entry to be resolved in a trusted forest
            //
            OriginalIndex = GcNameOriginalIndex[i];
            TranslatedSids->Sids[OriginalIndex].Flags |= LSA_LOOKUP_NAME_XFOREST_REF;
       }

        if ( SidTypeUnknown == GcSidNameUse[i] ) {

            // go on to the next one right away
            goto IterationCleanup;
        }

        //
        // This name was resolved!
        //
        if ( GcSidNameUse[i] != SidTypeDomain ) {

            // This is not a domain object, so make sure there
            // is a domain reference for this object

            Status = LsapSplitSid( SidArray->Sids[i].SidPointer,
                                   &DomainSid,
                                   &Rid );

            if ( !NT_SUCCESS( Status ) ) {
                goto IterationCleanup;
            }

        } else {

            DomainSid = SidArray->Sids[i].SidPointer;
        }

        if ( LsapIsBuiltinDomain( DomainSid ) ) {
            // don't map this since all searches are implicitly
            // over the account domain, not the builtin domain
            Status = STATUS_SUCCESS;
            goto IterationCleanup;
        }

        fStatus = LsapDbLookupListReferencedDomains( ReferencedDomains,
                                                     DomainSid,
                                                     &DomainIndex );

        if ( FALSE == fStatus ) {

            //
            // No entry for this domain -- add it
            //

            // Set the sid
            TrustInformation.Sid = DomainSid;
            DomainSid = NULL;

            // Allocate and set the name
            Status = LsapGetDomainNameBySid(  TrustInformation.Sid,
                                             (PUNICODE_STRING) &TrustInformation.Name );

            if ( STATUS_NO_SUCH_DOMAIN == Status ) {
                //
                // We longer know about this domain, though we did
                // before we sent the name off to the GC.
                // Don't resolve this name, but do continue on with
                // the next name
                //
                Status = STATUS_SUCCESS;
                goto IterationCleanup;
            }

            // Any other error is a resource error
            if ( !NT_SUCCESS( Status ) ) {
                goto IterationCleanup;
            }

            //
            // Add the entry
            //
            Status = LsapDbLookupAddListReferencedDomains( ReferencedDomains,
                                                           &TrustInformation,
                                                           &DomainIndex );
            if ( !NT_SUCCESS( Status ) ) {
                goto IterationCleanup;
            }
        }

        // We should now have a domain index
        ASSERT( LSA_UNKNOWN_INDEX != DomainIndex );

        // Set the information
        OriginalIndex = GcNameOriginalIndex[i];
        TranslatedSids->Sids[OriginalIndex].Use = GcSidNameUse[i];

        Length = RtlLengthSid(SidArray->Sids[i].SidPointer);
        TranslatedSids->Sids[OriginalIndex].Sid = MIDL_user_allocate(Length);
        if (TranslatedSids->Sids[OriginalIndex].Sid == NULL) {
            Status = STATUS_NO_MEMORY;
            goto IterationCleanup;
        }
        RtlCopySid(Length,
                   TranslatedSids->Sids[OriginalIndex].Sid,
                   SidArray->Sids[i].SidPointer);

        TranslatedSids->Sids[OriginalIndex].DomainIndex = DomainIndex;
        if ( !(GcNamesFlags[i] & SAMP_FOUND_BY_SAM_ACCOUNT_NAME) ) {
            TranslatedSids->Sids[OriginalIndex].Flags |= LSA_LOOKUP_NAME_NOT_SAM_ACCOUNT_NAME;
        }
        (*MappedCount) += 1;
        (*CompletelyUnmappedCount) -= 1;

IterationCleanup:

        if (  TrustInformation.Sid
          && (VOID*)TrustInformation.Sid != (VOID*)SidArray->Sids[i].SidPointer  ) {

            MIDL_user_free( TrustInformation.Sid );
        }
        if ( TrustInformation.Name.Buffer ) {
            MIDL_user_free( TrustInformation.Name.Buffer );
        }

        if ( DomainSid && DomainSid != SidArray->Sids[i].SidPointer ) {
            MIDL_user_free( DomainSid );
        }

        if ( !NT_SUCCESS( Status ) ) {
            break;
        }

    }  // iterate over names returned from the GC search

Finish:

    SamIFreeSidArray( SidArray );

    if ( PossibleGcNames ) {
        MIDL_user_free( PossibleGcNames );
    }
    if ( GcSidNameUse ) {
        MIDL_user_free( GcSidNameUse );
    }
    if ( GcNames ) {
        MIDL_user_free( GcNames );
    }
    if ( GcNameOriginalIndex ) {
        MIDL_user_free( GcNameOriginalIndex );
    }
    if ( GcNamesFlags ) {
        MIDL_user_free( GcNamesFlags );
    }

    //
    // Note: on error, higher level should will free the memory
    // in the returned arrays
    //

    return Status;

}


NTSTATUS
LsapDbLookupNamesInGlobalCatalogWks(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    )
/*++

Routine Description:

   This routine is called from a non-DC when the secure channel DC is a pre
   windows 2000 DC and thus can't talk to a GC.  This routine finds a GC
   and lookups up the remaining unresolved names at that GC.

Arguments:

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    LookupOptions - LSA_LOOKUP_ISOLATED_AS_LOCAL

    Names - Pointer to array of Names to be translated.  Zero or all of the
        Names may already have been translated elsewhere.  If any of the
        Names have been translated, the TranslatedSids parameter will point
        to a location containing a non-NULL array of Sid translation
        structures corresponding to the Names.  If the nth Name has been
        translated, the nth Sid translation structure will contain either a
        non-NULL Sid or a non-negative offset into the Referenced Domain
        List.  If the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string and a
        negative value for the Referenced Domain List index.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.


    NonFatalStatus - a status to indicate reasons why no names could have been
                      resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    LSA_HANDLE ControllerPolicyHandle = NULL;
    ULONG NextLevelCount;
    ULONG NextLevelMappedCount;
    ULONG NameIndex;
    ULONG NextLevelNameIndex;
    PLSAPR_REFERENCED_DOMAIN_LIST NextLevelReferencedDomains = NULL;
    PLSAPR_REFERENCED_DOMAIN_LIST OutputReferencedDomains = NULL;
    PLSAPR_TRANSLATED_SID_EX2 NextLevelSids = NULL;
    PLSAPR_UNICODE_STRING NextLevelNames = NULL;
    PLSAPR_UNICODE_STRING NextLevelPrefixNames = NULL;
    PLSAPR_UNICODE_STRING NextLevelSuffixNames = NULL;
    LONG FirstEntryIndex;
    PULONG NameIndices = NULL;
    BOOLEAN PartialNameTranslationsAttempted = FALSE;
    LPWSTR ServerName = NULL;
    LPWSTR ServerPrincipalName = NULL;
    PVOID ClientContext = NULL;
    ULONG ServerRevision;

    *NonFatalStatus = STATUS_SUCCESS;

    //
    // If there are no completely unmapped Names remaining, just return.
    //

    if (*CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupNamesInPrimaryDomainFinish;
    }

    //
    // Open the Policy object on some GC in the forest.
    //
    Status = LsapDbOpenPolicyGc( &ControllerPolicyHandle );

    if (!NT_SUCCESS(Status)) {

        //
        // We cannot access the Global Catalog. Suppress the error
        // and translate Domain Prefix Sids for Sids belonging to
        // the Primary Domain.
        //

        //
        // If we can't open a open a secure channel if a DC call
        // this a trust relationship problem
        //
        *NonFatalStatus =  STATUS_DS_GC_NOT_AVAILABLE;

        Status = STATUS_SUCCESS;
        goto LookupNamesInPrimaryDomainFinish;
    }

    //
    // We have successfully opened a Domain Controller's Policy
    // Database.  Now prepare to hand off a Name lookup for the
    // remaining unmapped Names to that Controller.  Here, this
    // server side of the LSA is a client of the LSA on the
    // target controller.  We will construct an array of the
    // remianing unmapped Names, look them up and then merge the
    // resulting ReferencedDomains and Translated Sids into
    // our existing list.
    //

    NextLevelCount = *CompletelyUnmappedCount;

    //
    // Allocate an array to hold the indices of unmapped Names
    // relative to the original Names and TranslatedSids->Sids
    // arrays.
    //

    NameIndices = MIDL_user_allocate(NextLevelCount * sizeof(ULONG));

    Status = STATUS_INSUFFICIENT_RESOURCES;

    if (NameIndices == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }

    //
    // Allocate an array of UNICODE_STRING structures for the
    // names to be looked up at the Domain Controller.
    //

    NextLevelNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelNames == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }

    //
    // Allocate an array of UNICODE_STRING structures for the
    // prefix names to be cached.
    //

    NextLevelPrefixNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelPrefixNames == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }
    //
    // Allocate an array of UNICODE_STRING structures for the
    // suffix names to be cached.
    //

    NextLevelSuffixNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelSuffixNames == NULL) {

        goto LookupNamesInPrimaryDomainError;
    }

    Status = STATUS_SUCCESS;

    //
    // Now scan the original array of Names and its parallel
    // Translated Sids array.  Copy over any names that are completely
    // unmapped.
    //

    NextLevelNameIndex = (ULONG) 0;

    for (NameIndex = 0;
         NameIndex < Count && NextLevelNameIndex < NextLevelCount;
         NameIndex++) {

        if ( (LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL)
          && (PrefixNames[NameIndex].Length == 0)  ) {

           //
           // Don't lookup isolated names off machine
           //
           continue;

        }

        if (LsapDbCompletelyUnmappedSid(&TranslatedSids->Sids[NameIndex])) {


            NextLevelNames[NextLevelNameIndex] = Names[NameIndex];
            NextLevelPrefixNames[NextLevelNameIndex] = PrefixNames[NameIndex];
            NextLevelSuffixNames[NextLevelNameIndex] = SuffixNames[NameIndex];

            NameIndices[NextLevelNameIndex] = NameIndex;
            NextLevelNameIndex++;
        }
    }

    if (NameIndex == 0) {

        // Nothing to do
        Status = STATUS_SUCCESS;
        goto LookupNamesInPrimaryDomainFinish;
    }

    NextLevelMappedCount = (ULONG) 0;

    Status = LsaICLookupNames(
                 ControllerPolicyHandle,
                 0, // no flags necessary
                 NextLevelCount,
                 (PUNICODE_STRING) NextLevelNames,
                 (PLSA_REFERENCED_DOMAIN_LIST *) &NextLevelReferencedDomains,
                 (PLSA_TRANSLATED_SID_EX2 *) &NextLevelSids,
                 LsapLookupGC,
                 0,
                 &NextLevelMappedCount,
                 &ServerRevision
                 );

    //
    // If the callout to LsaLookupNames() was unsuccessful, disregard
    // the error and set the domain name for any Sids having this
    // domain Sid as prefix sid.
    //

    if (!NT_SUCCESS(Status)) {

        //
        // Let the caller know there is a trust problem
        //
        if ( (STATUS_TRUSTED_DOMAIN_FAILURE == Status)
          || (STATUS_DS_GC_NOT_AVAILABLE == Status)  ) {
            *NonFatalStatus = Status;
        }

        Status = STATUS_SUCCESS;
        goto LookupNamesInPrimaryDomainFinish;
    }

    //
    // Cache any sids that came back
    //

    (void) LsapDbUpdateCacheWithNames(
            (PUNICODE_STRING) NextLevelSuffixNames,
            (PUNICODE_STRING) NextLevelPrefixNames,
            NextLevelCount,
            NextLevelReferencedDomains,
            NextLevelSids
            );

    //
    // The callout to LsaLookupNames() was successful.  We now have
    // an additional list of Referenced Domains containing the
    // Primary Domain and/or one or more of its Trusted Domains.
    // Merge the two Referenced Domain Lists together, noting that
    // since they are disjoint, the second list is simply
    // concatenated with the first.  The index of the first entry
    // of the second list will be used to adjust all of the
    // Domain Index entries in the Translated Names entries.
    // Note that since the memory for the graph of the first
    // Referenced Domain list has been allocated as individual
    // nodes, we specify that the nodes in this graph can be
    // referenced by the output Referenced Domain list.
    //

    Status = LsapDbLookupMergeDisjointReferencedDomains(
                 ReferencedDomains,
                 NextLevelReferencedDomains,
                 &OutputReferencedDomains,
                 LSAP_DB_USE_FIRST_MERGAND_GRAPH
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInPrimaryDomainError;
    }

    FirstEntryIndex = ReferencedDomains->Entries;

    //
    // Now update the original list of Translated Names.  We
    // update each entry that has newly been translated by copying
    // the entry from the new list and adjusting its
    // Referenced Domain List Index upwards by adding the index
    // of the first entry in the Next level List..
    //

    for( NextLevelNameIndex = 0;
         NextLevelNameIndex < NextLevelCount;
         NextLevelNameIndex++ ) {

        if ( !LsapDbCompletelyUnmappedSid(&NextLevelSids[NextLevelNameIndex]) ) {

            NameIndex = NameIndices[NextLevelNameIndex];

            TranslatedSids->Sids[NameIndex]
            = NextLevelSids[NextLevelNameIndex];

            Status = LsapRpcCopySid(NULL,
                                    &TranslatedSids->Sids[NameIndex].Sid,
                                    NextLevelSids[NextLevelNameIndex].Sid);

            if (!NT_SUCCESS(Status)) {
                goto LookupNamesInPrimaryDomainError;
            }

            TranslatedSids->Sids[NameIndex].DomainIndex =
                FirstEntryIndex +
                NextLevelSids[NextLevelNameIndex].DomainIndex;

            (*CompletelyUnmappedCount)--;
        }
    }

    //
    // Update the Referenced Domain List if a new one was produced
    // from the merge.  We retain the original top-level structure.
    //

    if (OutputReferencedDomains != NULL) {

        if (ReferencedDomains->Domains != NULL) {

            MIDL_user_free( ReferencedDomains->Domains );
            ReferencedDomains->Domains = NULL;
        }

        *ReferencedDomains = *OutputReferencedDomains;
        MIDL_user_free( OutputReferencedDomains );
        OutputReferencedDomains = NULL;
    }

    //
    // Update the Mapped Count and close the Controller Policy
    // Handle.
    //

    *MappedCount += NextLevelMappedCount;
    SecondaryStatus = LsaClose( ControllerPolicyHandle );
    ControllerPolicyHandle = NULL;

    //
    // Any error status that has not been suppressed must be reported
    // to the caller.  Errors such as connection failures to other LSA's
    // are suppressed.
    //

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInPrimaryDomainError;
    }

LookupNamesInPrimaryDomainFinish:

    //
    // If necessary, update count of completely unmapped names.
    //

    if (*CompletelyUnmappedCount > (ULONG) 0) {

        LsapDbUpdateCountCompUnmappedNames(TranslatedSids, CompletelyUnmappedCount);
    }

    //
    // If necessary, free the Next Level Referenced Domain List.
    // Note that this structure is allocated(all_nodes) since it was
    // allocated by the client side of the Domain Controller LSA.
    //

    if (NextLevelReferencedDomains != NULL) {

        MIDL_user_free( NextLevelReferencedDomains );
        NextLevelReferencedDomains = NULL;
    }

    //
    // If necessary, free the Next Level Names array.  We only free the
    // top level, since the names therein were copied from the input
    // TranslatedNames->Names array.
    //

    if (NextLevelNames != NULL) {

        MIDL_user_free( NextLevelNames );
        NextLevelNames = NULL;
    }

    if (NextLevelPrefixNames != NULL) {

        MIDL_user_free( NextLevelPrefixNames );
        NextLevelPrefixNames = NULL;
    }

    if (NextLevelSuffixNames != NULL) {

        MIDL_user_free( NextLevelSuffixNames );
        NextLevelSuffixNames = NULL;
    }

    //
    // If necessary, free the Next Level Translated Sids array.  Note
    // that this array is allocated(all_nodes).
    //

    if (NextLevelSids != NULL) {

        MIDL_user_free( NextLevelSids );
        NextLevelSids = NULL;
    }

    //
    // If necessary, free the array that maps Name Indices from the
    // Next Level to the Current Level.
    //

    if (NameIndices != NULL) {

        MIDL_user_free( NameIndices );
        NameIndices = NULL;
    }

    //
    // If necessary, close the Controller Policy Handle.
    //

    if ( ControllerPolicyHandle != NULL) {

        SecondaryStatus = LsaClose( ControllerPolicyHandle );
        ControllerPolicyHandle = NULL;

        if (!NT_SUCCESS(SecondaryStatus)) {

            goto LookupNamesInPrimaryDomainError;
        }
    }

    return(Status);

LookupNamesInPrimaryDomainError:

    //
    // If the primary status was a success code, but the secondary
    // status was an error, propagate the secondary status.
    //

    if ((!NT_SUCCESS(SecondaryStatus)) && NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupNamesInPrimaryDomainFinish;
}


NTSTATUS
LsapDbLookupNamesInTrustedForests(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    )
/*++

Routine Description:

    This routine looks at the list of name that have yet to be resolved.
    If the any of the names are marked as belowing to outside of the
    current forest, package up these entries and sent off to the root via
    the trust chain.

    N.B. Isolated names not are resolved at this point.

    N.B. This routine must be called after the names have been resolved
    at a GC, since it is this call to the GC that marks the names as
    exisiting outside of the local forest.

Arguments:

    LookupOptions - LSA_LOOKUP_ISOLATED_AS_LOCAL

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Names - Pointer to array of Names to be translated.  Zero or all of the
        Names may already have been translated elsewhere.  If any of the
        Names have been translated, the TranslatedSids parameter will point
        to a location containing a non-NULL array of Sid translation
        structures corresponding to the Names.  If the nth Name has been
        translated, the nth Sid translation structure will contain either a
        non-NULL Sid or a non-negative offset into the Referenced Domain
        List.  If the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string and a
        negative value for the Referenced Domain List index.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.


    NonFatalStatus - a status to indicate reasons why no names could have been
                      resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS NextLevelSecondaryStatus = STATUS_SUCCESS;
    ULONG NextLevelCount;
    ULONG NextLevelMappedCount;
    ULONG NameIndex;
    ULONG NextLevelNameIndex;
    PLSAPR_REFERENCED_DOMAIN_LIST NextLevelReferencedDomains = NULL;
    PLSAPR_REFERENCED_DOMAIN_LIST OutputReferencedDomains = NULL;
    PLSAPR_TRANSLATED_SID_EX2 NextLevelSids = NULL;
    LSAPR_TRANSLATED_SIDS_EX2 NextLevelSidsStruct;
    PLSAPR_UNICODE_STRING NextLevelNames = NULL;
    LONG FirstEntryIndex;
    PULONG NameIndices = NULL;
    PLSAPR_UNICODE_STRING NextLevelPrefixNames = NULL;
    PLSAPR_UNICODE_STRING NextLevelSuffixNames = NULL;
    BOOLEAN fAllocateAllNodes = FALSE;


    *NonFatalStatus = STATUS_SUCCESS;

    //
    // Get a count of how many names need to be passed on
    //
    NextLevelCount = 0;
    ASSERT(Count == TranslatedSids->Entries);
    for (NameIndex = 0; NameIndex < Count; NameIndex++) {

        if ( (LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL)
          && (PrefixNames[NameIndex].Length == 0)  ) {
           //
           // Don't lookup isolated names off machine
           //
           continue;
        }
        if (TranslatedSids->Sids[NameIndex].Flags & LSA_LOOKUP_NAME_XFOREST_REF) {
            NextLevelCount++;
        }
    }

    if (0 == NextLevelCount) {
        //
        // There is nothing to resolve
        //
        goto LookupNamesInTrustedForestsFinish;
    }

    //
    // Allocate an array to hold the indices of unmapped Names
    // relative to the original Names and TranslatedSids->Sids
    // arrays.
    //
    NameIndices = MIDL_user_allocate(NextLevelCount * sizeof(ULONG));
    if (NameIndices == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupNamesInTrustedForestsError;
    }

    //
    // Allocate an array of UNICODE_STRING structures for the
    // names to be looked up at the Domain Controller.
    //

    NextLevelNames = MIDL_user_allocate(
                         sizeof(UNICODE_STRING) * NextLevelCount
                         );

    if (NextLevelNames == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupNamesInTrustedForestsError;
    }

    NextLevelPrefixNames = MIDL_user_allocate( NextLevelCount * sizeof( UNICODE_STRING ));

    if (NextLevelPrefixNames == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupNamesInTrustedForestsError;
    }

    NextLevelSuffixNames = MIDL_user_allocate( NextLevelCount * sizeof( UNICODE_STRING ));

    if (NextLevelSuffixNames == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupNamesInTrustedForestsError;
    }

    //
    // Now scan the original array of Names and its parallel
    // Translated Sids array.  Copy over any names that need to be resolved
    // in an ex-forest.
    //

    NextLevelNameIndex = (ULONG) 0;
    for (NameIndex = 0;
         NameIndex < Count && NextLevelNameIndex < NextLevelCount;
         NameIndex++) {

        if ( (LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL)
          && (PrefixNames[NameIndex].Length == 0)  ) {
           //
           // Don't lookup isolated names off machine
           //
           continue;
        }

        if (TranslatedSids->Sids[NameIndex].Flags & LSA_LOOKUP_NAME_XFOREST_REF) {

            NextLevelNames[NextLevelNameIndex] = Names[NameIndex];
            NextLevelPrefixNames[NextLevelNameIndex] = PrefixNames[NameIndex];
            NextLevelSuffixNames[NextLevelNameIndex] = SuffixNames[NameIndex];
            NameIndices[NextLevelNameIndex] = NameIndex;
            NextLevelNameIndex++;
        }
    }

    NextLevelMappedCount = (ULONG) 0;
    NextLevelSidsStruct.Entries = 0;
    NextLevelSidsStruct.Sids = NULL;


    Status = LsapDbLookupNamesInTrustedForestsWorker(NextLevelCount,
                                                     NextLevelNames,
                                                     NextLevelPrefixNames,
                                                     NextLevelSuffixNames,
                                                     &NextLevelReferencedDomains,
                                                     &NextLevelSidsStruct,
                                                     &fAllocateAllNodes,
                                                     &NextLevelMappedCount,
                                                     0, // no options,
                                                     &NextLevelSecondaryStatus);

    if (NextLevelSidsStruct.Sids) {
        NextLevelSids = NextLevelSidsStruct.Sids;
        NextLevelSidsStruct.Sids = NULL;
        NextLevelSidsStruct.Entries = 0;
    }

    if (!NT_SUCCESS(Status)
     && LsapDbIsStatusConnectionFailure(Status)) {

        *NonFatalStatus = Status;
        Status = STATUS_SUCCESS;
        goto LookupNamesInTrustedForestsFinish;

    } else if (NT_SUCCESS(Status)
            && !NT_SUCCESS(NextLevelSecondaryStatus)) {

        *NonFatalStatus = NextLevelSecondaryStatus;
        goto LookupNamesInTrustedForestsFinish;

    } else if (!NT_SUCCESS(Status)
            && Status != STATUS_NONE_MAPPED) {
        //
        // Unhandled error; STATUS_NONE_MAPPED is handled to get
        // partially resolved names.
        //
        goto LookupNamesInTrustedForestsError;
    }
    ASSERT(NT_SUCCESS(Status) || Status == STATUS_NONE_MAPPED);
    Status = STATUS_SUCCESS;


    //
    // Merge the results back in
    //
    Status = LsapDbLookupMergeDisjointReferencedDomains(
                 ReferencedDomains,
                 NextLevelReferencedDomains,
                 &OutputReferencedDomains,
                 LSAP_DB_USE_FIRST_MERGAND_GRAPH
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInTrustedForestsError;
    }

    FirstEntryIndex = ReferencedDomains->Entries;

    //
    // Now update the original list of Translated Names.  We
    // update each entry that has newly been translated by copying
    // the entry from the new list and adjusting its
    // Referenced Domain List Index upwards by adding the index
    // of the first entry in the Next level List.
    //

    for( NextLevelNameIndex = 0;
         NextLevelNameIndex < NextLevelCount;
         NextLevelNameIndex++ ) {

        if ( !LsapDbCompletelyUnmappedSid(&NextLevelSids[NextLevelNameIndex]) ) {

            NameIndex = NameIndices[NextLevelNameIndex];

            TranslatedSids->Sids[NameIndex]
            = NextLevelSids[NextLevelNameIndex];

            Status = LsapRpcCopySid(NULL,
                                    &TranslatedSids->Sids[NameIndex].Sid,
                                    NextLevelSids[NextLevelNameIndex].Sid);

            if (!NT_SUCCESS(Status)) {
                goto LookupNamesInTrustedForestsError;
            }

            TranslatedSids->Sids[NameIndex].DomainIndex =
                FirstEntryIndex +
                NextLevelSids[NextLevelNameIndex].DomainIndex;

            (*CompletelyUnmappedCount)--;
        }
    }

    //
    // Update the Referenced Domain List if a new one was produced
    // from the merge.  We retain the original top-level structure.
    //

    if (OutputReferencedDomains != NULL) {

        if (ReferencedDomains->Domains != NULL) {

            MIDL_user_free( ReferencedDomains->Domains );
            ReferencedDomains->Domains = NULL;
        }

        *ReferencedDomains = *OutputReferencedDomains;
        MIDL_user_free( OutputReferencedDomains );
        OutputReferencedDomains = NULL;
    }

    //
    // Update the Mapped Count
    //

    *MappedCount += NextLevelMappedCount;

    //
    // Any error status that has not been suppressed must be reported
    // to the caller.  Errors such as connection failures to other LSA's
    // are suppressed.
    //

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesInTrustedForestsError;
    }

LookupNamesInTrustedForestsFinish:

    //
    // If necessary, update count of completely unmapped names.
    //

    if (*CompletelyUnmappedCount > (ULONG) 0) {

        LsapDbUpdateCountCompUnmappedNames(TranslatedSids, CompletelyUnmappedCount);
    }

    //
    // If necessary, free the Next Level Referenced Domain List.
    // Note the structure is not allocate_all_nodes
    //
    if (NextLevelReferencedDomains != NULL) {
        if (!fAllocateAllNodes) {
            if (NextLevelReferencedDomains->Domains) {
                for (NextLevelNameIndex = 0;
                        NextLevelNameIndex < NextLevelReferencedDomains->Entries;
                            NextLevelNameIndex++) {
                    if (NextLevelReferencedDomains->Domains[NextLevelNameIndex].Name.Buffer) {
                        MIDL_user_free(NextLevelReferencedDomains->Domains[NextLevelNameIndex].Name.Buffer);
                    }
                    if (NextLevelReferencedDomains->Domains[NextLevelNameIndex].Sid) {
                        MIDL_user_free(NextLevelReferencedDomains->Domains[NextLevelNameIndex].Sid);
                    }
                }
                MIDL_user_free(NextLevelReferencedDomains->Domains);
            }
        }
        MIDL_user_free( NextLevelReferencedDomains );
        NextLevelReferencedDomains = NULL;
    }

    //
    // If necessary, free the Next Level Names array.  We only free the
    // top level, since the names therein were copied from the input
    // TranslatedNames->Names array.
    //

    if (NextLevelNames != NULL) {

        MIDL_user_free( NextLevelNames );
        NextLevelNames = NULL;
    }

    //
    // If necessary, free the Next Level Translated Sids array.  Note
    // the structure is not allocate_all_nodes
    //
    if (NextLevelSids != NULL) {
        if (!fAllocateAllNodes) {
            for (NextLevelNameIndex = 0;
                    NextLevelNameIndex < NextLevelCount;
                        NextLevelNameIndex++) {
                if (NextLevelSids[NextLevelNameIndex].Sid) {
                    MIDL_user_free(NextLevelSids[NextLevelNameIndex].Sid);
                }
            }
        }
        MIDL_user_free( NextLevelSids );
        NextLevelSids = NULL;
    }

    if (NextLevelPrefixNames != NULL) {

        MIDL_user_free( NextLevelPrefixNames );
        NextLevelSids = NULL;
    }

    if (NextLevelSuffixNames != NULL) {

        MIDL_user_free( NextLevelSuffixNames );
        NextLevelSids = NULL;
    }

    //
    // If necessary, free the array that maps Name Indices from the
    // Next Level to the Current Level.
    //

    if (NameIndices != NULL) {

        MIDL_user_free( NameIndices );
        NameIndices = NULL;
    }

    return(Status);

LookupNamesInTrustedForestsError:

    goto LookupNamesInTrustedForestsFinish;

}

NTSTATUS
LsapDbLookupNamesInTrustedForestsWorker(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2  TranslatedSids,
    OUT BOOLEAN * fAllocateAllNodes,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    OUT NTSTATUS *NonFatalStatus
    )
/*++

Routine Description:

    This routine takes a set of names that are to be resolved at an
    external forest and either 1) sends of to the external forest if
    this is the root of a domain or 2) sends to request of to a DC
    in the root of domain (via the trust path).

    N.B.  This routine is called from the LsarLookupName request of levels
    LsapLookupXForestReferral and LsaLookupPDC.

    N.B. Both ReferencedDomains and TranslatedSids.Sids are allocated
    on output.

Arguments:

    Count - Number of Names in the Names array,  Note that some of these
        may already have been mapped elsewhere, as specified by the
        MappedCount parameter.

    Names - Pointer to array of Names to be translated.  Zero or all of the
        Names may already have been translated elsewhere.  If any of the
        Names have been translated, the TranslatedSids parameter will point
        to a location containing a non-NULL array of Sid translation
        structures corresponding to the Names.  If the nth Name has been
        translated, the nth Sid translation structure will contain either a
        non-NULL Sid or a non-negative offset into the Referenced Domain
        List.  If the nth Name has not yet been translated, the nth Sid
        translation structure will contain a zero-length Sid string and a
        negative value for the Referenced Domain List index.

    ReferencedDomains - Pointer to a Referenced Domain List.  This
        list references an array of zero or more Trust Information
        entries describing each of the domains referenced by the names.
        This array will be appended to/reallocated if necessary.

    TranslatedSids - Pointer to structure that optionally references a list
        of Sid translations for some of the Names in the Names array.

    fAllocateAllNodes -- describes how ReferencedDomains and TranslatesSids are
        allocated.

    MappedCount - Pointer to location containing the number of Names
        in the Names array that have already been mapped.  This number
        will be updated to reflect additional mapping done by this
        routine.

    CompletelyUnmappedCount - Pointer to location containing the
        count of completely unmapped Names.  A Name is completely unmapped
        if it is unknown and non-composite, or composite but with an
        unrecognized Domain component.  This count is updated on exit, the
        number of completely unmapped Namess whose Domain Prefices are
        identified by this routine being subtracted from the input value.


    NonFatalStatus - a status to indicate reasons why no names could have been
                      resolved

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.  Note that some
            or all of the Names may remain partially or completely unmapped.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_LOOKUP_LEVEL LookupLevel;
    ULONG i;
    PLSAP_DB_LOOKUP_WORK_LIST WorkList = NULL;


    *NonFatalStatus = STATUS_SUCCESS;
    *fAllocateAllNodes = FALSE;

    if (!LsapDbDcInRootDomain()) {

        //
        // We are not at the root domain -- forward request
        //
        PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
        LSAPR_TRUST_INFORMATION_EX TrustInfoEx;

        //
        // Get our forest name
        //
        Status = LsapDbLookupGetDomainInfo(NULL,
                                           &DnsDomainInfo);
        if (!NT_SUCCESS(Status)) {
            goto LookupNamesInTrustedForestFinish;
        }

        RtlZeroMemory(&TrustInfoEx, sizeof(TrustInfoEx));
        TrustInfoEx.DomainName = *((LSAPR_UNICODE_STRING*)&DnsDomainInfo->DnsForestName);
        Status = LsapDbLookupNameChainRequest(&TrustInfoEx,
                                              Count,
                                              (PUNICODE_STRING)Names,
                                              (PLSA_REFERENCED_DOMAIN_LIST *)ReferencedDomains,
                                              (PLSA_TRANSLATED_SID_EX2 * )&TranslatedSids->Sids,
                                              LsapLookupXForestReferral,
                                              MappedCount,
                                              NULL);

        if (TranslatedSids->Sids) {
            TranslatedSids->Entries = Count;
            *fAllocateAllNodes = TRUE;
        }

        if (!NT_SUCCESS(Status)) {

            //
            // The attempt to chain failed; record the error
            // if it is interesting
            //
            if (LsapDbIsStatusConnectionFailure(Status)) {
                *NonFatalStatus = Status;
            }

            //
            // This should not fail the overall request
            //
            Status = STATUS_SUCCESS;
        }

    } else {

        //
        // Split the names up into different forests and issue a work
        // request for each one
        //
        ULONG i;
        ULONG CompletelyUnmappedCount = Count;

        TranslatedSids->Sids = MIDL_user_allocate(Count * sizeof(LSA_TRANSLATED_SID_EX2));
        if (TranslatedSids->Sids == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto LookupNamesInTrustedForestFinish;
        }
        TranslatedSids->Entries = Count;

        //
        // Initialize the Output Sids array.  Zeroise all fields, then
        // Mark all of the Output Sids as being unknown initially and
        // set the DomainIndex fields to a negative number meaning
        // "no domain"
        //

        RtlZeroMemory( TranslatedSids->Sids, Count * sizeof(LSA_TRANSLATED_SID_EX2));
        for (i = 0; i < Count; i++) {
            TranslatedSids->Sids[i].Use = SidTypeUnknown;
            TranslatedSids->Sids[i].DomainIndex = LSA_UNKNOWN_INDEX;
        }

        //
        // Create an empty Referenced Domain List.
        //
        Status = LsapDbLookupCreateListReferencedDomains( ReferencedDomains, 0 );
        if (!NT_SUCCESS(Status)) {

            goto LookupNamesInTrustedForestFinish;
        }

        //
        // Build a WorkList for this Lookup and put it on the Work Queue.
        //
        // NOTE: This routine does not need to hold the Lookup Work Queue
        //       lock to ensure validity of the WorkList pointer, because the
        //       pointer remains valid until this routine frees it via
        //       LsapDbLookupDeleteWorkList().  Although other threads may
        //       process the WorkList, do not delete it.
        //
        //       A called routine must acquire the lock in order to access
        //       the WorkList after it has been added to the Work Queue.
        //

        Status = LsapDbLookupXForestNamesBuildWorkList(
                     Count,
                     Names,
                     PrefixNames,
                     SuffixNames,
                     *ReferencedDomains,
                     TranslatedSids,
                     LsapLookupXForestResolve,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     &WorkList
                     );

        if (!NT_SUCCESS(Status)) {

            //
            // If no Work List has been built because there are no
            // eligible domains to search, exit, suppressing the error.

            if (Status == STATUS_NONE_MAPPED) {

                Status = STATUS_SUCCESS;
                goto LookupNamesInTrustedForestFinish;
            }

            goto LookupNamesInTrustedForestFinish;
        }

        //
        // Start the work, by dispatching one or more worker threads
        // if necessary.
        //

        Status = LsapDbLookupDispatchWorkerThreads( WorkList );

        if (!NT_SUCCESS(Status)) {

            goto LookupNamesInTrustedForestFinish;
        }

        //
        // Wait for completion/termination of all items on the Work List.
        //

        Status = LsapDbLookupAwaitCompletionWorkList( WorkList );

        if (!NT_SUCCESS(Status)) {

            goto LookupNamesInTrustedForestFinish;
        }

        if ( !NT_SUCCESS(WorkList->NonFatalStatus) ) {
            //
            // Propogate the error as non fatal
            //
            *NonFatalStatus = WorkList->NonFatalStatus;
        }

    }

LookupNamesInTrustedForestFinish:

    //
    // If a Work List was created, delete it from the Work Queue
    //

    if (WorkList != NULL) {

        Status = LsapDbLookupDeleteWorkList( WorkList );
        WorkList = NULL;
    }

    return Status;
}



NTSTATUS
LsapDbLookupNamesAsDomainNames(
    IN ULONG Flags,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount
    )
/*++

Routine Description:

    This routine tries to match entries in Names to domain names of
    trusted domains.

    There are three kinds of trusted domains:

    1) domains we directly trusts (both in and out of forest).  The LSA TDL
    is used for this.

    2) domains we trust transitively.  The DS cross-ref is used for this.

    3) domains we trust via a forest trust. The LSA TDL is used
    for this.

Arguments:

    Flags -- LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT
             LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE
             LSAP_LOOKUP_TRUSTED_DOMAIN_FOREST_NAMES

    Count -- the number of entries in Names

    Names/PrefixNames/SuffixName  -- the requested Names

    ReferencedDomains -- the domains of Names

    TranslatedSids -- the SIDs and characteristics of Names

    MappedCount -- the number of names that have been fully mapped

Return Values:

    STATUS_SUCCESS, or resource error otherwise

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    NameIndex;
    BOOLEAN               fTDLLock = FALSE;
    LSA_TRUST_INFORMATION TrustInfo;

    RtlZeroMemory(&TrustInfo, sizeof(TrustInfo));
    for (NameIndex = 0; NameIndex < Count; NameIndex++) {

        PLSAPR_TRUST_INFORMATION_EX TrustInfoEx = NULL;
        LSAPR_TRUST_INFORMATION_EX  TrustInfoBuffer;
        PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY   TrustEntry = NULL;


        RtlZeroMemory(&TrustInfo, sizeof(TrustInfo));
        RtlZeroMemory(&TrustInfoBuffer, sizeof(TrustInfoBuffer));

        if (!LsapDbCompletelyUnmappedSid(&TranslatedSids->Sids[NameIndex])) {
            // Already resolved
            continue;
        }

        if (PrefixNames[NameIndex].Length != 0) {
            // Not in isolated name, so can't be just a domain name
            continue;
        }

        if (Flags & LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE) {

            Status = LsapDomainHasTransitiveTrust((PUNICODE_STRING)&SuffixNames[NameIndex],
                                                   NULL,
                                                  &TrustInfo);

            if (NT_SUCCESS(Status)) {
                TrustInfoEx = &TrustInfoBuffer;
                TrustInfoEx->FlatName = *(LSAPR_UNICODE_STRING*)&TrustInfo.Name;
                TrustInfoEx->Sid = TrustInfo.Sid;
            } else if (Status == STATUS_NO_SUCH_DOMAIN) {
                Status = STATUS_SUCCESS;
            } else {
                // This is fatal
                goto Exit;
            }
        }

        if ((NULL == TrustInfoEx)
         && (Flags & LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT)) {

            Status = LsapDomainHasDirectTrust((PUNICODE_STRING)&SuffixNames[NameIndex],
                                               NULL,
                                               &fTDLLock,
                                               &TrustEntry);

            if (NT_SUCCESS(Status)) {
                TrustInfoEx = &TrustInfoBuffer;
                TrustInfoEx->FlatName = TrustEntry->TrustInfoEx.FlatName;
                TrustInfoEx->Sid = TrustEntry->TrustInfoEx.Sid;
            } else if (Status == STATUS_NO_SUCH_DOMAIN) {
                Status = STATUS_SUCCESS;
            } else {
                // This is fatal
                goto Exit;
            }
        }

        if ((NULL == TrustInfoEx)
         && (Flags & LSAP_LOOKUP_TRUSTED_FOREST_ROOT) ) {

            Status = LsapDomainHasForestTrust((PUNICODE_STRING)&SuffixNames[NameIndex],
                                              NULL,
                                              &fTDLLock,
                                              &TrustEntry);

            if (NT_SUCCESS(Status)) {
                TrustInfoEx = &TrustInfoBuffer;
                TrustInfoEx->FlatName = TrustEntry->TrustInfoEx.FlatName;
                TrustInfoEx->Sid = TrustEntry->TrustInfoEx.Sid;
            } else if (Status == STATUS_NO_SUCH_DOMAIN) {
                Status = STATUS_SUCCESS;
            } else {
                // This is fatal
                goto Exit;
            }
        }

        if (TrustInfoEx) {

            BOOLEAN fStatus;
            ULONG DomainIndex;

            fStatus = LsapDbLookupListReferencedDomains( ReferencedDomains,
                                                         TrustInfoEx->Sid,
                                                         &DomainIndex );
            if ( FALSE == fStatus ) {

                LSA_TRUST_INFORMATION TempTrustInfo;

                //
                // No entry for this domain -- add it
                //
                RtlZeroMemory(&TempTrustInfo, sizeof(TempTrustInfo));

                // Set the sid
                TempTrustInfo.Sid = TrustInfoEx->Sid;
                TempTrustInfo.Name = *(PUNICODE_STRING)&TrustInfoEx->FlatName;

                //
                // Add the entry
                //
                Status = LsapDbLookupAddListReferencedDomains( ReferencedDomains,
                                                               (PLSAPR_TRUST_INFORMATION) &TempTrustInfo,
                                                               &DomainIndex );
                if ( !NT_SUCCESS( Status ) ) {
                    goto Exit;
                }
            }

            // We should now have a domain index
            ASSERT( LSA_UNKNOWN_INDEX != DomainIndex );

            // Set the information in the returned array
            TranslatedSids->Sids[NameIndex].Use = SidTypeDomain;
            TranslatedSids->Sids[NameIndex].DomainIndex = DomainIndex;
            Status = LsapRpcCopySid(NULL,
                                   &TranslatedSids->Sids[NameIndex].Sid,
                                    TrustInfoEx->Sid);
            if ( !NT_SUCCESS( Status ) ) {
                goto Exit;
            }

            //
            // Increment the number of items mapped
            //
            (*MappedCount) += 1;

        }

        if (fTDLLock) {
            LsapDbReleaseLockTrustedDomainList();
            fTDLLock = FALSE;
        }

        if (TrustInfo.Name.Buffer) {
            midl_user_free(TrustInfo.Name.Buffer);
            TrustInfo.Name.Buffer = NULL;
        }
        if (TrustInfo.Sid) {
            midl_user_free(TrustInfo.Sid);
            TrustInfo.Sid = NULL;
        }

        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }
    }

Exit:

    if (fTDLLock) {
        LsapDbReleaseLockTrustedDomainList();
        fTDLLock = FALSE;
    }

    if (TrustInfo.Name.Buffer) {
        midl_user_free(TrustInfo.Name.Buffer);
        TrustInfo.Name.Buffer = NULL;
    }
    if (TrustInfo.Sid) {
        midl_user_free(TrustInfo.Sid);
        TrustInfo.Sid = NULL;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dspolicy\dbhandle.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbhandle.c

Abstract:

    LSA Database Handle Manager

    Access to an LSA database object involves a sequence of API calls
    which involve the following:

    o  A call to an object-type dependent "open" API
    o  One or more calls to API that manipulate the object
    o  A call to the LsaClose API

    It is necessary to track context for each open of an object, for example,
    the accesses granted and the underlying LSA database handle to the
    object.  Lsa handles provide this mechanism:  an Lsa handle is simply a
    pointer to a data structure containing this context.

Author:

    Scott Birrell       (ScottBi)       May 29, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include "adtp.h"


//
// Handle Table anchor.  The handle table is just a linked list
//

struct _LSAP_DB_HANDLE LsapDbHandleTable;
LSAP_DB_HANDLE_TABLE LsapDbHandleTableEx;

NTSTATUS
LsapDbInitHandleTables(
    VOID
    )
/*++

Routine Description:

    This function initializes the LSA Database Handle Tables.  It initializes the table members
    and the locks, so it must be called before the table is accessed.

Arguments:

    None.

Return Value:

    VOID

--*/
{
    LsapDbHandleTableEx.UserCount = 0;
    InitializeListHead( &LsapDbHandleTableEx.UserHandleList );

    LsapDbHandleTableEx.FreedUserEntryCount = 0;

    //
    // Now, also initialize the flat list
    //
    LsapDbHandleTable.Next = &LsapDbHandleTable;
    LsapDbHandleTable.Previous = &LsapDbHandleTable;

    return STATUS_SUCCESS;
}

NTSTATUS
LsapDbInsertHandleInTable(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN LSAPR_HANDLE NewHandle,
    IN PLUID UserId,
    IN HANDLE UserToken
    )
/*++

Routine Description:

    This routine will enter a new handle into the lsa global policy handle table.


Arguments:

    ObjectInformation - Information on the object being created.

    NewHandle - New handle to be inserted

    UserId - LUID of the user creating the handle.
        0: means trusted handle

    UserToken - Token handle of the user creating the handle.  NULL means local system

Return Value:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed


--*/
{
    NTSTATUS Status;
    PLIST_ENTRY HandleEntry;
    PLSAP_DB_HANDLE_TABLE_USER_ENTRY CurrentUserEntry = NULL;
    BOOLEAN UserAdded = FALSE;
    BOOLEAN PolicyHandleCountIncremented = FALSE;
    LSAP_DB_HANDLE DbHandle = ( LSAP_DB_HANDLE )NewHandle;

    LsapEnterFunc( "LsapDbInsertHandleInTable" );

    //
    // First, grab the handle table lock.
    //
    LsapDbLockAcquire( &LsapDbState.HandleTableLock );

    //
    // Find the entry that corresponds to our given user.
    //

    for ( HandleEntry = LsapDbHandleTableEx.UserHandleList.Flink;
          HandleEntry != &LsapDbHandleTableEx.UserHandleList;
          HandleEntry = HandleEntry->Flink ) {

        CurrentUserEntry = CONTAINING_RECORD( HandleEntry,
                                              LSAP_DB_HANDLE_TABLE_USER_ENTRY,
                                              Next );

        if ( RtlEqualLuid( &CurrentUserEntry->LogonId, UserId )  ) {

            LsapDsDebugOut(( DEB_HANDLE, "Handle 0x%lp belongs to entry 0x%lp\n",
                            NewHandle,
                            CurrentUserEntry ));
            break;

        }

        CurrentUserEntry = NULL;
    }

    //
    // Allocate a new entry if necessary.
    //
    if ( CurrentUserEntry == NULL ) {

        LsapDsDebugOut(( DEB_HANDLE, "Handle list not found for user %x:%x\n",
                        UserId->HighPart,
                        UserId->LowPart ));

        //
        // See if we can grab one off the lookaside list
        //
        if ( LsapDbHandleTableEx.FreedUserEntryCount ) {

            CurrentUserEntry = LsapDbHandleTableEx.FreedUserEntryList[
                                                LsapDbHandleTableEx.FreedUserEntryCount - 1 ];
            LsapDsDebugOut(( DEB_HANDLE,
                             "Using user entry 0x%lp from free list spot %lu\n",
                             CurrentUserEntry,
                             LsapDbHandleTableEx.FreedUserEntryCount-1 ));
            LsapDbHandleTableEx.FreedUserEntryCount--;

            ASSERT( CurrentUserEntry );


        } else {

            CurrentUserEntry = LsapAllocateLsaHeap( sizeof( LSAP_DB_HANDLE_TABLE_USER_ENTRY ) );

            if ( CurrentUserEntry == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto InsertHandleInTableEntryExit;
            }
        }


        LsapDsDebugOut(( DEB_HANDLE,
                         "Allocated user entry 0x%lp\n", CurrentUserEntry ));

        //
        // Set the information in the new entry, and then insert it into the lists
        //
        InitializeListHead( &CurrentUserEntry->PolicyHandles );
        InitializeListHead( &CurrentUserEntry->ObjectHandles );
        CurrentUserEntry->PolicyHandlesCount = 0;
        RtlCopyLuid( &CurrentUserEntry->LogonId, UserId );
        CurrentUserEntry->MaxPolicyHandles = LSAP_DB_MAXIMUM_HANDLES_PER_USER ;

        if ( RtlEqualLuid( UserId, &LsapSystemLogonId ) ||
             RtlEqualLuid( UserId, &LsapZeroLogonId ) )
        {

            CurrentUserEntry->MaxPolicyHandles = 0x7FFFFFFF ;

        }
        else if ( UserToken != NULL )
        {
            UCHAR   Buffer[ 128 ];
            PTOKEN_USER User ;
            NTSTATUS Status2 ;
            ULONG Size ;

            User = (PTOKEN_USER) Buffer ;

            Status2 = NtQueryInformationToken(
                            UserToken,
                            TokenUser,
                            User,
                            sizeof( Buffer ),
                            &Size );

            if ( NT_SUCCESS( Status2 ) )
            {
                if ( RtlEqualSid( User->User.Sid, LsapAnonymousSid ) )
                {
                    CurrentUserEntry->MaxPolicyHandles = 0x7FFFFFFF ;
                }
            }

        }
#if DBG
        if ( UserToken != NULL ) {

            OBJECT_ATTRIBUTES ObjAttrs;
            SECURITY_QUALITY_OF_SERVICE SecurityQofS;
            NTSTATUS Status2;

            //
            // Duplicate the token
            //
            InitializeObjectAttributes( &ObjAttrs, NULL, 0L, NULL, NULL );
            SecurityQofS.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
            SecurityQofS.ImpersonationLevel = SecurityImpersonation;
            SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
            SecurityQofS.EffectiveOnly = FALSE;
            ObjAttrs.SecurityQualityOfService = &SecurityQofS;

            Status2 = NtDuplicateToken( UserToken,
                                        TOKEN_READ | TOKEN_WRITE | TOKEN_EXECUTE,
                                        &ObjAttrs,
                                        FALSE,
                                        TokenImpersonation,
                                        &CurrentUserEntry->UserToken );
            if ( !NT_SUCCESS( Status2 ) ) {

                LsapDsDebugOut(( DEB_HANDLE,
                                 "Failed to duplicate the token for handle 0x%lp: 0x%lx\n",
                                 NewHandle,
                                 Status2 ));

                CurrentUserEntry->UserToken = NULL;
            }

            //
            // A failure to copy the token doesn constitute a failure to add the entry
            //

        }
#endif

        InsertTailList( &LsapDbHandleTableEx.UserHandleList,
                        &CurrentUserEntry->Next );
        LsapDbHandleTableEx.UserCount++;
        UserAdded = TRUE;
    }


    //
    // Ok, now that we have the entry, let's add it to the appropriate list...
    //
    if ( ObjectInformation->ObjectTypeId == PolicyObject ) {
        ASSERT( DbHandle->ObjectTypeId == PolicyObject );

        if ( CurrentUserEntry->PolicyHandlesCount >= CurrentUserEntry->MaxPolicyHandles ) {

            LsapDsDebugOut(( DEB_HANDLE,
                             "Quota exceeded for user %x:%x, handle 0x%lp\n",
                             UserId->HighPart,
                             UserId->LowPart,
                             NewHandle ));
            Status = STATUS_QUOTA_EXCEEDED;
            goto InsertHandleInTableEntryExit;

        } else {

            InsertTailList( &CurrentUserEntry->PolicyHandles, &DbHandle->UserHandleList );
            CurrentUserEntry->PolicyHandlesCount++;
            PolicyHandleCountIncremented = TRUE;
        }

    } else {
        ASSERT( DbHandle->ObjectTypeId != PolicyObject );

        InsertTailList( &CurrentUserEntry->ObjectHandles, &DbHandle->UserHandleList );
    }

    //
    // Finally, make sure to insert it in the flat list
    //
    DbHandle->Next = LsapDbHandleTable.Next;
    DbHandle->Previous = &LsapDbHandleTable;
    DbHandle->Next->Previous = DbHandle;
    DbHandle->Previous->Next = DbHandle;

    DbHandle->UserEntry = ( PVOID )CurrentUserEntry;
    Status = STATUS_SUCCESS;

InsertHandleInTableEntryExit:

    //
    // If we succesfully created the entry, make sure we remove it...
    //
    if ( !NT_SUCCESS( Status ) && UserAdded ) {

        RemoveEntryList( &DbHandle->UserHandleList );
        if ( PolicyHandleCountIncremented ) {
            CurrentUserEntry->PolicyHandlesCount--;
        }

        if ( CurrentUserEntry->UserToken ) {

            NtClose( CurrentUserEntry->UserToken );
        }

        LsapDbHandleTableEx.UserCount--;
        RemoveEntryList( &CurrentUserEntry->Next );
        LsapFreeLsaHeap( CurrentUserEntry );

    }

    LsapDbLockRelease( &LsapDbState.HandleTableLock );

    LsapExitFunc( "LsapDbInsertHandleInTable", Status );
    return( Status );
}


BOOLEAN
LsapDbFindIdenticalHandleInTable(
    IN OUT PLSAPR_HANDLE OriginalHandle
    )
/*++

Routine Description:

    This routine will find an existing handle in the lsa global policy handle
    table that matches the passed in handle.  If a matching handle is found,
    the passed in handle is dereferenced and the matching handle is returned.

    If no matching handle is found, the original passed in handle is returned.

Arguments:

    OriginalHandle - Passes in the original handle to compare with.
        Returns the handle that is to be used.

Return Value:

    TRUE - Original handle was returned or new handle was returned.

    FALSE - New handle would exceed maximum allowed reference count if it were used.
        Original handle is returned.

--*/
{
    BOOLEAN RetBool = TRUE;
    LSAP_DB_HANDLE InputHandle;
    LSAP_DB_HANDLE DbHandle;
    PLIST_ENTRY HandleEntry;
    PLSAP_DB_HANDLE_TABLE_USER_ENTRY CurrentUserEntry = NULL;

    LsapEnterFunc( "LsapDbFindIndenticalHandleInTable" );

    //
    // Return immediately if the handle isn't a policy handle
    //

    InputHandle = (LSAP_DB_HANDLE) *OriginalHandle;
    if  ( InputHandle->ObjectTypeId != PolicyObject ) {
        LsapExitFunc( "LsapDbFindIdenticalHandleInTable", 0 );
        return TRUE;
    }

    CurrentUserEntry = (PLSAP_DB_HANDLE_TABLE_USER_ENTRY) InputHandle->UserEntry;
    ASSERT( CurrentUserEntry != NULL );

    //
    // First, grab the handle table lock.
    //
    LsapDbLockAcquire( &LsapDbState.HandleTableLock );



    //
    // If this is not a trusted handle,
    //  try to share the handle.
    //

    if ( !RtlEqualLuid( &CurrentUserEntry->LogonId, &LsapZeroLogonId )  ) {

        //
        // Now, walk the appropriate list to find one for the matching access.
        //

        for ( HandleEntry = CurrentUserEntry->PolicyHandles.Flink;
              HandleEntry != &CurrentUserEntry->PolicyHandles;
              HandleEntry = HandleEntry->Flink ) {

            //
            // See if the access masks match.  If so, we have a winner
            //
            DbHandle = CONTAINING_RECORD( HandleEntry,
                                          struct _LSAP_DB_HANDLE,
                                          UserHandleList );

            //
            // Ignore the original handle
            //

            if ( DbHandle == InputHandle ) {
                /* Do nothing here */


            //
            // The handles are considered identical if the GrantedAccess matches.
            //

            } else if ( DbHandle->GrantedAccess == InputHandle->GrantedAccess ) {

                //
                // Don't let this handle be cloned too many times
                //

                if ( DbHandle->ReferenceCount >= LSAP_DB_MAXIMUM_REFERENCE_COUNT ) {
                    RetBool = FALSE;
                    break;
                }

                DbHandle->ReferenceCount++;


#if DBG
                GetSystemTimeAsFileTime( (LPFILETIME) &DbHandle->HandleLastAccessTime );
#endif // DBG

                LsapDsDebugOut(( DEB_HANDLE,
                                 "Found handle 0x%lp for user %x:%x using access 0x%lx (%ld)\n",
                                 DbHandle,
                                 CurrentUserEntry->LogonId.HighPart,
                                 CurrentUserEntry->LogonId.LowPart,
                                 DbHandle->GrantedAccess,
                                 DbHandle->ReferenceCount ));

                *OriginalHandle = (LSAPR_HANDLE)DbHandle;

                //
                // Dereference the original handle.
                //

                LsapDbDereferenceHandle( (LSAPR_HANDLE)InputHandle, TRUE );
                break;

            } else {

                LsapDsDebugOut(( DEB_HANDLE,
                                 "Handle 0x%lp for user %x:%x has access 0x%lx, need 0x%lx\n",
                                 DbHandle,
                                 CurrentUserEntry->LogonId.HighPart,
                                 CurrentUserEntry->LogonId.LowPart,
                                 DbHandle->GrantedAccess,
                                 InputHandle->GrantedAccess ));

            }
        }
    }

    LsapDbLockRelease( &LsapDbState.HandleTableLock );

    LsapExitFunc( "LsapDbFindIdenticalHandleInTable", 0 );
    return RetBool;
}


NTSTATUS
LsapDbRemoveHandleFromTable(
    IN PLSAPR_HANDLE Handle
    )
/*++

Routine Description:

    This routine removes an existing handle from all tables it is in.

    Enter with LsapDbState.HandleTableLock locked.

Arguments:

    Handle - Handle to remove.

Return Value:

    STATUS_SUCCESS - Success

    STATUS_OBJECT_NAME_NOT_FOUND - The handle for the specified user cannot be found

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY HandleList, HandleEntry;
    PLSAP_DB_HANDLE_TABLE_USER_ENTRY CurrentUserEntry = NULL;
    LSAP_DB_HANDLE DbHandle = ( LSAP_DB_HANDLE )Handle, FoundHandle;
    PULONG EntryToDecrement ;

    LsapEnterFunc( "LsapDbRemoveHandleFromTable" );

    CurrentUserEntry = DbHandle->UserEntry;
    ASSERT( CurrentUserEntry != NULL );


    if ( DbHandle->ObjectTypeId == PolicyObject ) {

        HandleList = &CurrentUserEntry->PolicyHandles;
        EntryToDecrement = &CurrentUserEntry->PolicyHandlesCount;

    } else {

        HandleList = &CurrentUserEntry->ObjectHandles;
        EntryToDecrement = NULL ;
    }

    Status = STATUS_NOT_FOUND;

    for ( HandleEntry = HandleList->Flink;
          HandleEntry != HandleList;
          HandleEntry = HandleEntry->Flink ) {


        FoundHandle = CONTAINING_RECORD( HandleEntry,
                                         struct _LSAP_DB_HANDLE,
                                         UserHandleList );

        if ( FoundHandle == DbHandle ) {

            RemoveEntryList( &FoundHandle->UserHandleList );
            FoundHandle->Next->Previous = FoundHandle->Previous;
            FoundHandle->Previous->Next = FoundHandle->Next;

            if ( EntryToDecrement ) {
                *EntryToDecrement -= 1 ;
            }

            //
            // See if we can remove the entry itself
            //
            if ( IsListEmpty( &CurrentUserEntry->PolicyHandles ) &&
                 IsListEmpty( &CurrentUserEntry->ObjectHandles ) ) {

                LsapDsDebugOut(( DEB_HANDLE,
                                 "Removing empty user list 0x%lp\n",
                                 CurrentUserEntry ));

                RemoveEntryList( &CurrentUserEntry->Next );

                LsapDbHandleTableEx.UserCount--;

                if ( CurrentUserEntry->UserToken ) {

                    NtClose( CurrentUserEntry->UserToken );
                }

                LsapDsDebugOut(( DEB_HANDLE,
                                 "Removing user entry 0x%lp\n", CurrentUserEntry ));

                if ( LsapDbHandleTableEx.FreedUserEntryCount < LSAP_DB_HANDLE_FREE_LIST_SIZE ) {

                    LsapDbHandleTableEx.FreedUserEntryList[
                                    LsapDbHandleTableEx.FreedUserEntryCount ] = CurrentUserEntry;
                    LsapDsDebugOut(( DEB_HANDLE,
                                     "Moving user entry 0x%lp to free list spot %lu\n",
                                     CurrentUserEntry,
                                     LsapDbHandleTableEx.FreedUserEntryCount ));
                    LsapDbHandleTableEx.FreedUserEntryCount++;

                } else {

                    LsapFreeLsaHeap( CurrentUserEntry );
                }
            }
            Status = STATUS_SUCCESS;
            break;

        } else {

            LsapDsDebugOut(( DEB_HANDLE,
                             "Looking for user entry 0x%lp against 0x%lp\n",
                             FoundHandle,
                             DbHandle ));
        }
    }


    LsapExitFunc( "LsapDbRemoveHandleFromTable", Status );
    return( Status );
}


NTSTATUS
LsapDbCreateHandle(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ULONG Options,
    IN ULONG CreateHandleOptions,
    OUT LSAPR_HANDLE *CreatedHandle
    )

/*++

Routine Description:

    This function creates and initializes a handle for an LSA Database object.
    The handle is allocated from the LSA Heap and added to the handle table.
    Using the Object Type, and either the Sid or Name provided in
    ObjectInformation, the Logical and Physical Names of the object are
    constructed and pointers to them are stored in the handle.  The LSA
    Database must be locked before calling this function.

    If there is a Container Handle specified in the ObjectInformation, the
    newly created handle inherits its trusted status (TRUE if trusted, else
    FALSE).  If there is no container handle, the trusted status is set
    to FALSE by default.  When a non-trusted handle is used to access an
    object, impersonation and access validation occurs.

Arguments:

    ObjectInformation - Pointer to object information structure which must
        have been validated by a calling routine.  The following information
        items must be specified:

        o Object Type Id
        o Object Logical Name (as ObjectAttributes->ObjectName, a pointer to
             a Unicode string)
        o Container object handle (for any object except the Policy object).
        o Object Sid (if any)
        All other fields in ObjectAttributes portion of ObjectInformation
        such as SecurityDescriptor are ignored.

    Options - Optional actions

        LSAP_DB_TRUSTED - Handle is to be marked as Trusted.
            handle is use, access checking will be bypassed.  If the
            handle is used to create or open a lower level object, that
            object's handle will by default inherit the Trusted property.

        LSAP_DB_NON_TRUSTED - Handle is to be marked as Non-Trusted.

        If neither of the above options is specified, the handle will
        either inherit the trusted status of the Container Handle
        provilde in ObjectInformation, or, if none, the handle will
        be marked non-trusted.

    CreateHandleOptions - Options used to control the behavior of the CreateHandle function.

    CreatedHandle - Where the created handle is returned

Return Value:

    STATUS_SUCCESS -- Success

    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed

    STATUS_INVALID_SID - A bogus sid was encountered

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_HANDLE Handle = NULL;
    PSID Sid = NULL;
    ULONG SidLength;
    BOOLEAN ObjectInReg = TRUE, ObjectInDs = FALSE, NewTrustObject = FALSE;
    HANDLE ClientToken;
    LUID UserId;
    TOKEN_STATISTICS TokenStats;
    ULONG InfoReturned;
    BOOL Locked = FALSE ;
    HANDLE ClientTokenToFree = NULL;

    //
    // First, grab the handle table lock.
    //
    LsapDbLockAcquire( &LsapDbState.HandleTableLock );

    Locked = TRUE ;


    //
    // Get the current users token, unless we are trusted...
    //

    UserId = LsapZeroLogonId;
    if ( ObjectInformation->ObjectAttributes.RootDirectory == NULL ||
         !( (LSAP_DB_HANDLE)ObjectInformation->ObjectAttributes.RootDirectory )->Trusted ) {

        Status = I_RpcMapWin32Status( RpcImpersonateClient( 0 ) );

        if ( NT_SUCCESS( Status )  ) {

            Status = NtOpenThreadToken( NtCurrentThread(),
                                        TOKEN_QUERY | TOKEN_DUPLICATE,
                                        TRUE,
                                        &ClientToken );

            if ( NT_SUCCESS( Status ) ) {

                Status = NtQueryInformationToken( ClientToken,
                                                  TokenStatistics,
                                                  &TokenStats,
                                                  sizeof( TokenStats ),
                                                  &InfoReturned );

                if ( NT_SUCCESS( Status ) ) {

                    UserId = TokenStats.AuthenticationId;
                }

                ClientTokenToFree = ClientToken;
            }

            Status = I_RpcMapWin32Status( RpcRevertToSelf() );

        }

    }

    LsapDbLockRelease( &LsapDbState.HandleTableLock );

    Locked = FALSE ;

    //
    // Allocate memory for the new handle from the process heap.
    //

    Handle = LsapAllocateLsaHeap(sizeof(struct _LSAP_DB_HANDLE));

    if (Handle == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CreateHandleError;
    }

    //
    // Mark the handle as allocated and initialize the reference count
    // to one.  Initialize other fields based on the object information
    // supplied.
    //

    Handle->Allocated = TRUE;
    Handle->KeyHandle = NULL;
    Handle->ReferenceCount = 1;
    Handle->ObjectTypeId = ObjectInformation->ObjectTypeId;
    Handle->ContainerHandle = ( LSAP_DB_HANDLE )ObjectInformation->ObjectAttributes.RootDirectory;
    Handle->Sid = NULL;
    Handle->Trusted = FALSE;
    Handle->DeletedObject = FALSE;
    Handle->GenerateOnClose = FALSE;
    Handle->Options = Options;
    Handle->LogicalNameU.Buffer = NULL;
    Handle->PhysicalNameU.Buffer = NULL;
    Handle->PhysicalNameDs.Buffer = NULL;
    Handle->RequestedAccess = ObjectInformation->DesiredObjectAccess;
    InitializeListHead( &Handle->UserHandleList );
    Handle->UserEntry = NULL;
    Handle->SceHandle = (( Options & LSAP_DB_SCE_POLICY_HANDLE ) != 0 );
    Handle->SceHandleChild = (( ObjectInformation->ObjectAttributes.RootDirectory != NULL ) &&
                              ((( LSAP_DB_HANDLE )ObjectInformation->ObjectAttributes.RootDirectory)->SceHandle ));
#ifdef DBG

    //
    // ScePolicy lock must be held when opening an SCE Policy handle
    //

    if ( Handle->SceHandle ) {

        ASSERT( LsapDbResourceIsLocked( ( PSAFE_RESOURCE )&LsapDbState.ScePolicyLock ));
    }

    RtlZeroMemory( &Handle->HandleLastAccessTime, sizeof( LARGE_INTEGER ) );

    GetSystemTimeAsFileTime( (LPFILETIME) &Handle->HandleCreateTime );

#endif

    //
    // By default, the handle inherits the Trusted status of the
    // container handle.
    //

    if (Handle->ContainerHandle != NULL) {

        Handle->Trusted = Handle->ContainerHandle->Trusted;
    }

    //
    // If Trusted/Non-Trusted status is explicitly specified, set the
    // status to that specified.
    //

    if (Options & LSAP_DB_TRUSTED) {

        Handle->Trusted = TRUE;

    }

    //
    // Capture the object's Logical and construct Physical Names from the
    // Object Information and store them in the handle.  These names are
    // internal to the Lsa Database.  Note that the input Logical Name
    // cannot be directly stored in the handle because it will be in
    // storage that is scoped only to the underlying server API call if
    // the object for which this create handle is being done is of a type
    // that is opened or created by name rather than by Sid.
    //

    //
    // Set the objects location
    //
    Handle->PhysicalNameDs.Length = 0;

    switch ( ObjectInformation->ObjectTypeId ) {

    case TrustedDomainObject:
    case NewTrustedDomainObject:

        ObjectInReg = !LsapDsWriteDs;
        ObjectInDs = LsapDsWriteDs;
        Handle->ObjectTypeId = TrustedDomainObject;
        break;

    case AccountObject:
    case PolicyObject:

        ObjectInReg = TRUE;
        ObjectInDs = FALSE;
        break;

    case SecretObject:

        ObjectInReg = TRUE;
        if ( LsapDsWriteDs && FLAG_ON( Options, LSAP_DB_OBJECT_SCOPE_DS ) ) {

            ObjectInDs = TRUE;
        }

        break;

    }

    Status = LsapDbGetNamesObject( ObjectInformation,
                                   CreateHandleOptions,
                                   &Handle->LogicalNameU,
                                   ObjectInReg ? &Handle->PhysicalNameU : NULL,
                                   ObjectInDs ? &Handle->PhysicalNameDs : NULL );

    if (!NT_SUCCESS(Status)) {

        goto CreateHandleError;
    }

    //
    // Make a copy of the object's Sid and store pointer to it in
    // the handle.
    //

    if (ObjectInformation->Sid != NULL) {

        Sid = ObjectInformation->Sid;

        if (!RtlValidSid( Sid )) {

            Status = STATUS_INVALID_SID;
            goto CreateHandleError;
        }

        SidLength = RtlLengthSid( Sid );

        Handle->Sid = LsapAllocateLsaHeap( SidLength );

        if (Handle->Sid == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto CreateHandleError;
        }

        RtlCopySid( SidLength, Handle->Sid, Sid );
    }

    //
    // Append the handle to the linked list
    //


    LsapDbLockAcquire( &LsapDbState.HandleTableLock );

    Locked = TRUE ;

    Status = LsapDbInsertHandleInTable( ObjectInformation,
                                        Handle,
                                        &UserId,
                                        ClientTokenToFree
                                        );
    if ( !NT_SUCCESS( Status ) ) {

        goto CreateHandleError;
    }

    //
    // Increment the handle table count
    //

    LsapDbState.OpenHandleCount++;

CreateHandleFinish:

    if ( ClientTokenToFree ) {

        NtClose( ClientTokenToFree );
    }

    *CreatedHandle = ( LSAPR_HANDLE )Handle;

    LsapDsDebugOut(( DEB_HANDLE, "Handle Created 0x%lp\n",
                    Handle ));

    if ( Locked )
    {
        LsapDbLockRelease( &LsapDbState.HandleTableLock );
    }

    return( Status );

CreateHandleError:

    //
    // If necessary, free the handle and contents.
    //

    if (Handle != NULL) {

        //
        // If a Sid was allocated, free it.
        //

        if (Handle->Sid != NULL) {

            LsapFreeLsaHeap( Handle->Sid );
        }

        //
        // If a Logical Name Buffer was allocated, free it.
        //

        if ((Handle->LogicalNameU.Length != 0) &&
            (Handle->LogicalNameU.Buffer != NULL)) {

            RtlFreeUnicodeString( &Handle->LogicalNameU );
        }

        //
        // If a Physical Name Buffer was allocated, free it.
        //

        if ((Handle->PhysicalNameU.Length != 0) &&
            (Handle->PhysicalNameU.Buffer != NULL)) {

            LsapFreeLsaHeap( Handle->PhysicalNameU.Buffer );
        }

        //
        // Free the handle itself.
        //

        LsapFreeLsaHeap( Handle );
        Handle = NULL;
    }

    Handle = NULL;
    goto CreateHandleFinish;
}


NTSTATUS
LsapDbVerifyHandle(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ExpectedObjectTypeId,
    IN BOOLEAN ReferenceHandle
    )

/*++

Routine Description:

    This function verifies that a handle has a valid address and is of valid
    format.  The handle must be allocated and have a positive reference
    count within the valid range.  The object type id must be within range
    and optionally equal to a specified type.  The Lsa Database must be
    locked before calling this function.

Arguments:

    ObjectHandle - Handle to be validated.

    Options - Specifies optional actions to be taken

        LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES - Allow handles for
            deleted objects to pass the validation.

        Other option flags may be specified.  They will be ignored.

    ExpectedObjectTypeId - Expected object type.  If NullObject is
        specified, the object type id is only range checked.

    ReferenceHandle - True if handle reference count is to be incemented

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - Invalid address or handle contents
--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) ObjectHandle;

    //
    // Lock the handle table.
    //

    LsapDbLockAcquire( &LsapDbState.HandleTableLock );


    //
    // First verify that the handle's address is valid.
    //

    if (!LsapDbLookupHandle( ObjectHandle )) {

        goto VerifyHandleError;
    }

    //
    // Verify that the handle is allocated
    //

    if (!Handle->Allocated) {

        goto VerifyHandleError;
    }

    //
    // If the handle is marked as invalid, return an error unless
    // these are admissible, e.g when validating for a close option
    //

    if (Handle->DeletedObject) {

        if (!(Options & LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES)) {

            goto VerifyHandleError;
        }
    }

    //
    // Verify that the handle contains a non-NULL handle to a Registry
    // Key
    //

    if (!Handle->fWriteDs && Handle->KeyHandle == NULL) {

        goto VerifyHandleError;
    }

    //
    // Now either range-check or match the handle type
    //

    if (ExpectedObjectTypeId == NullObject) {

        if ((Handle->ObjectTypeId < PolicyObject) ||
            (Handle->ObjectTypeId >= DummyLastObject)) {

            goto VerifyHandleError;
        }

    } else {

        ASSERT (ExpectedObjectTypeId >= PolicyObject &&
                ExpectedObjectTypeId < DummyLastObject);

        if (Handle->ObjectTypeId != ExpectedObjectTypeId) {

            //
            // For a secret object, it's possible that we were given a trusted domain
            // handle as well.
            //
            if ( !(ExpectedObjectTypeId == SecretObject &&
                   Handle->ObjectTypeId == TrustedDomainObject &&
                   FLAG_ON( Handle->Options, LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET ) ) ) {

                goto VerifyHandleError;
            }
        }
    }

    //
    // Verify that the handle's reference count is valid and positive
    //

    if (Handle->ReferenceCount == 0) {
        goto VerifyHandleError;
    }

#ifdef LSAP_TRACK_HANDLE
    GetSystemTimeAsFileTime( (LPFILETIME) &Handle->HandleLastAccessTime );
#endif

    Status = STATUS_SUCCESS;

VerifyHandleFinish:

    //ASSERT( Status != STATUS_INVALID_HANDLE );


    //
    // Reference the handle
    //
    if ( ReferenceHandle && NT_SUCCESS(Status) ) {

        //
        // This is an internal reference.
        //  Don't enforce LSAP_DB_MAXIMUM_REFERENCE_COUNT.
        //

        Handle->ReferenceCount++;
        LsapDsDebugOut(( DEB_HANDLE, "Handle Rref 0x%lp (%ld)\n",
                         Handle,
                         Handle->ReferenceCount ));
    }

    LsapDbLockRelease( &LsapDbState.HandleTableLock );
    return(Status);

VerifyHandleError:
    Status = STATUS_INVALID_HANDLE;
    goto VerifyHandleFinish;
}


BOOLEAN
LsapDbLookupHandle(
    IN LSAPR_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This function checks if a handle address is valid.  The Lsa Database must
    be locked before calling this function.

Arguments:

    ObjectHandle - handle to be validated.

Return Value:

    BOOLEAN - TRUE if handle is valid. FALSE if handle does not exist or
        is invalid.

--*/

{
    BOOLEAN ReturnValue = FALSE;
    LSAP_DB_HANDLE ThisHandle;

    LsapDbLockAcquire( &LsapDbState.HandleTableLock );

    //
    // Simply do a linear scan of the small list of handles.  Jazz this
    // up later if needed.
    //

    for (ThisHandle = LsapDbHandleTable.Next;
         ThisHandle != &LsapDbHandleTable && ThisHandle != NULL;
         ThisHandle = ThisHandle->Next) {

        if (ThisHandle == (LSAP_DB_HANDLE) ObjectHandle) {

            ReturnValue = TRUE;
            break;
        }
    }

    ASSERT( ThisHandle );

    LsapDbLockRelease( &LsapDbState.HandleTableLock );

    return( ReturnValue );
}


NTSTATUS
LsapDbCloseHandle(
    IN LSAPR_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This function closes an LSA Handle.  The memory for the handle is
    freed.  The LSA database must be locked before calling this function.

    NOTE:  Currently, handles do not have reference counts since they
    are not shared among client threads.

Arguments:

    ObjectHandle - Handle to be closed.

Return Value:

    NTSTATUS - Return code.

--*/

{
    NTSTATUS Status;

    LSAP_DB_HANDLE TempHandle;

    //
    // Verify that the handle exists.  It may be marked invalid
    //

    LsapDbLockAcquire( &LsapDbState.HandleTableLock );
    Status = LsapDbVerifyHandle(
                 ObjectHandle,
                 LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES,
                 NullObject,
                 FALSE );

    if (!NT_SUCCESS(Status)) {
        LsapDbDereferenceHandle( ObjectHandle, FALSE );
    }

    LsapDbLockRelease( &LsapDbState.HandleTableLock );

    return Status;
}


BOOLEAN
LsapDbDereferenceHandle(
    IN LSAPR_HANDLE ObjectHandle,
    IN BOOLEAN CalledInSuccessPath
    )

/*++

Routine Description:

    This function decrement the reference count on the handle.
    If the reference count is decremented to zero,
    this function unlinks a handle and frees its memory.  If the handle
    contains a non-NULL Registry Key handle that handle is closed.

Arguments:

    ObjectHandle - handle to be dereferenced

    CalledInSuccessPath - TRUE if this function is called in a success path.
        With this information, we can decide if we will crash the server if auditing
        fails when LsapCrashOnAuditFail is TRUE.

Return Value:

    TRUE if the reference count reached zero.

--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) ObjectHandle;
    BOOLEAN RetVal = FALSE;
    BOOL RevertResult = FALSE;
    BOOL Impersonating = FALSE;
    //
    // Dereference the handle
    //
    LsapDbLockAcquire( &LsapDbState.HandleTableLock );
    Handle->ReferenceCount --;
    if ( Handle->ReferenceCount != 0 ) {

        LsapDsDebugOut(( DEB_HANDLE, "Handle Deref 0x%lp %ld\n",
                        Handle,
                        Handle->ReferenceCount ));
        goto Cleanup;
    }

    //
    // Avoid freeing the global policy handle
    //
    if ( ObjectHandle == LsapPolicyHandle ) {

        ASSERT( Handle->ReferenceCount != 0 );
        if ( Handle->ReferenceCount == 0 ) {
            Handle->ReferenceCount++;
        }
#ifdef DBG
        DbgPrint("Freeing global policy handle\n");
#endif
        goto Cleanup;
    }

    LsapDsDebugOut(( DEB_HANDLE, "Handle Freed 0x%lp\n",
                    Handle ));

    //
    // Unhook the handle from the linked list
    //
    Status = LsapDbRemoveHandleFromTable( ObjectHandle );
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "LSASRV:Failed to remove handle 0x%lp from the global table!\n", ObjectHandle );
        goto Cleanup;
    }

    //
    // Free the Registry Key Handle (if any).
    //

    if (Handle->KeyHandle != NULL) {

        Status = NtClose(Handle->KeyHandle);
        ASSERT(NT_SUCCESS(Status));
        Handle->KeyHandle = NULL;
    }

    //
    // we generate the audit only when we are being called in sucess path
    // in the failure path, the open audit was not generated thus there is
    // no point in generating the close audit either
    //

    if ( CalledInSuccessPath ) {
        
        //
        // impersonate the client so that audit event shows correct user
        // Do this only for untrusted clients

        if ( !Handle->Trusted ) {

            if ( Handle->Options & LSAP_DB_USE_LPC_IMPERSONATE ) {

                Status = LsapImpersonateClient( );

            } else {

                Status = I_RpcMapWin32Status(RpcImpersonateClient(0));
            }

            if ( NT_SUCCESS(Status) ) {

                Impersonating = TRUE;
            }
            else if ( ( Status == RPC_NT_NO_CALL_ACTIVE )  ||
                      ( Status == RPC_NT_NO_CONTEXT_AVAILABLE ) ) {

                //
                // we dont want to fail the audit if
                // -- the call is not over RPC (RPC_NT_NO_CALL_ACTIVE)
                // -- the client died prematurely (RPC_NT_NO_CONTEXT_AVAILABLE)
                //

                Status = STATUS_SUCCESS;
            }

            DsysAssertMsg( NT_SUCCESS(Status), "LsapDbDereferenceHandle: failed to impersonate" );

            if (!NT_SUCCESS( Status )) {
                LsapAuditFailed( Status );
            }
        }


        //
        // Audit that we're closing the handle
        //

        Status = NtCloseObjectAuditAlarm (
                     &LsapState.SubsystemName,
                     ObjectHandle,
                     Handle->GenerateOnClose );

        if (!NT_SUCCESS( Status )) {
            LsapAuditFailed( Status );
        }

        if ( !Handle->Trusted ) {

            //
            // unimpersonate
            //

            if ( Impersonating ) {

                if ( Handle->Options & LSAP_DB_USE_LPC_IMPERSONATE ) {

                    RevertResult = RevertToSelf();
                    DsysAssertMsg( RevertResult, "LsapDbDereferenceHandle: RevertToSelf() failed" );

                } else {

                    Status = I_RpcMapWin32Status(RpcRevertToSelf());

                    DsysAssertMsg( NT_SUCCESS(Status), "LsapDbDereferenceHandle: RpcRevertToSelf() failed" );

                }
            }
        }
    }
    
    //
    // Mark the handle as not allocated.
    //

    Handle->Allocated = FALSE;

    //
    // Free fields of the handle
    //

    if (Handle->LogicalNameU.Buffer != NULL) {

        RtlFreeUnicodeString( &Handle->LogicalNameU );
    }

    if (Handle->PhysicalNameU.Buffer != NULL) {

        LsapFreeLsaHeap( Handle->PhysicalNameU.Buffer );
    }

    if (Handle->PhysicalNameDs.Buffer != NULL) {

        LsapFreeLsaHeap( Handle->PhysicalNameDs.Buffer );
    }

    if (Handle->Sid != NULL) {

        LsapFreeLsaHeap( Handle->Sid );
    }

    if (Handle->SceHandle) {

#ifdef DBG
        ASSERT( WAIT_TIMEOUT == WaitForSingleObject( LsapDbState.SceSyncEvent, 0 ));
        ASSERT( g_ScePolicyLocked );
        g_ScePolicyLocked = FALSE;
#endif

        RtlReleaseResource( &LsapDbState.ScePolicyLock );
        SetEvent( LsapDbState.SceSyncEvent );
    }

    //
    // Decrement the count of open handles.
    //

    ASSERT(LsapDbState.OpenHandleCount > 0);
    LsapDbState.OpenHandleCount--;

#ifdef LSAP_TRACK_HANDLE
    if ( Handle->ClientToken ) {

        NtClose( Handle->ClientToken );
    }
#endif

    //
    // Free the handle structure itself

    LsapFreeLsaHeap( ObjectHandle );
    RetVal = TRUE;

Cleanup:
    LsapDbLockRelease( &LsapDbState.HandleTableLock );

    return RetVal;

}


NTSTATUS
LsapDbMarkDeletedObjectHandles(
    IN LSAPR_HANDLE ObjectHandle,
    IN BOOLEAN MarkSelf
    )

/*++

Routine Description:

    This function invalidates open handles to an object.  It is used
    by object deletion code.  Once an object has been deleted, the only
    operation permitted on open handles remaining is to close them.

Arguments:

    ObjectHandle - Handle to an Lsa object.

    MarkSelf -  If TRUE, all handles to the object will be marked to
        indicate that the object to which they relate has been deleted.
        including the passed handle.  If FALSE, all handles to the object
        except the passed handle will be so marked.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_HANDLE ThisHandle;
    LSAP_DB_HANDLE Handle = ObjectHandle;

    LsapDbLockAcquire( &LsapDbState.HandleTableLock );

    ThisHandle = LsapDbHandleTable.Next;

    while (ThisHandle != &LsapDbHandleTable) {

        //
        // Match on Object Type Id.
        //

        if (ThisHandle->ObjectTypeId == Handle->ObjectTypeId) {

            //
            // Object Type Id's match.  If the Logical Names also
            // match, invalidate the handle unless the handle is the
            // passed one and we're to leave it valid.
            //

            if (RtlEqualUnicodeString(
                    &(ThisHandle->LogicalNameU),
                    &(Handle->LogicalNameU),
                    FALSE
                    )) {

                if (MarkSelf || ThisHandle != (LSAP_DB_HANDLE) ObjectHandle) {

                    ThisHandle->DeletedObject = TRUE;
                }
            }
        }

        ThisHandle = ThisHandle->Next;
    }

    LsapDbLockRelease( &LsapDbState.HandleTableLock );


    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dspolicy\dbinstac.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbinstac.c

Abstract:

    LSA Protected Subsystem - Account object Initialization.

    This module sets up account objects to establish the default
    Microsoft policy regarding privilege assignment, system access
    rights (interactive, network, service), and abnormal quotas.

Author:

    Jim Kelly   (JimK)  May 3, 1992.

Environment:

    User mode - Does not depend on Windows.

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"


NTSTATUS
LsapDbInitializeAccount(
    IN PSID AccountSid,
    IN PLSAPR_PRIVILEGE_SET Privileges,
    IN ULONG SystemAccess
    );

OLD_LARGE_INTEGER
ConvertLongToOldLargeInteger(
    ULONG u
    )
/*++

Routine Description:

    Coverts a long to old style large interger


Arguments:

    u - unsigned long.


Return Value:

    converted old style large integer.


--*/
{
    LARGE_INTEGER NewLargeInteger;
    OLD_LARGE_INTEGER OldLargeInteger;

    NewLargeInteger = RtlConvertLongToLargeInteger(u);

    NEW_TO_OLD_LARGE_INTEGER(
        NewLargeInteger,
        OldLargeInteger );

    return( OldLargeInteger );

}




NTSTATUS
LsapDbInstallAccountObjects(
    VOID
    )

/*++

Routine Description:

    This function establishes ACCOUNT objects and initializes them
    to contain the default Microsoft policy.

Arguments:

    None.


Return Value:


--*/

{

    NTSTATUS
        Status = STATUS_SUCCESS;

    ULONG
        i,
        Index,
        SystemAccess;


    SID_IDENTIFIER_AUTHORITY
        WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY,
        NtAuthority = SECURITY_NT_AUTHORITY;

    PSID
        WorldSid = NULL,
        BuiltinAccountSid = NULL ;

    PLSAPR_PRIVILEGE_SET
        Privileges;

    UCHAR
        PrivilegesBuffer[ sizeof(LSAPR_PRIVILEGE_SET) +
                          20 * sizeof(LUID_AND_ATTRIBUTES)];






    //
    // Initialize our privilege set buffer
    // (Room for 100 privileges)
    //

    Privileges = (PLSAPR_PRIVILEGE_SET)(&PrivilegesBuffer);
    Privileges->Control = 0;  //Not used here.
    for (i=0; i<20; i++) {
        Privileges->Privilege[i].Attributes = 0; //Disabled, DisabledByDefault
    }



    //
    // Set up the SIDs we need.
    // All builtin domain sids are the same length.  We'll just create
    // one and change its RID as necessary.
    //


    if (NT_SUCCESS(Status)) {
        Status = RtlAllocateAndInitializeSid(
                     &WorldSidAuthority,
                     1,                      //Sub authority count
                     SECURITY_WORLD_RID,     //Sub authorities (up to 8)
                     0, 0, 0, 0, 0, 0, 0,
                     &WorldSid
                     );
    }

    if (NT_SUCCESS(Status)) {
        Status = RtlAllocateAndInitializeSid(
                     &NtAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0, 0, 0, 0, 0, 0,
                     &BuiltinAccountSid
                     );
    }








    //
    // Now create each account and assign the appropriate set of privileges
    // And logon capabilities.  Some of these are product type-specific.
    //


    if (NT_SUCCESS(Status)) {

        //
        // World account
        //      Logon types: Network
        //      Privileges:
        //          ChangeNotify    (ENABLED)
        //

        Privileges->Privilege[0].Luid =
            ConvertLongToOldLargeInteger(SE_CHANGE_NOTIFY_PRIVILEGE);
        Privileges->Privilege[0].Attributes = SE_PRIVILEGE_ENABLED |
                                              SE_PRIVILEGE_ENABLED_BY_DEFAULT;

        Privileges->PrivilegeCount = 1;

        SystemAccess = SECURITY_ACCESS_NETWORK_LOGON;

        //
        // If a WinNt installation, give WORLD Interactive logon in
        // and SHUTDOWN privilege in addition to Network Logon.
        //

        if (LsapProductType == NtProductWinNt) {

            SystemAccess |= SECURITY_ACCESS_INTERACTIVE_LOGON |
                            SECURITY_ACCESS_REMOTE_INTERACTIVE_LOGON ;

            Privileges->Privilege[1].Luid =
                ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);
            Privileges->Privilege[1].Attributes =
                SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;
            Privileges->PrivilegeCount = 2;

        }

        Status = LsapDbInitializeAccount(WorldSid, Privileges, SystemAccess);

        Privileges->Privilege[0].Attributes = 0;
    }

    if (NT_SUCCESS(Status)) {

        //
        // Admin Alias account
        //      Logon types: Interactive, Network
        //      Privileges:
        //          Security
        //          Backup
        //          Restore
        //          SetTime
        //          Shutdown
        //          RemoteShutdown
        //          Debug
        //          TakeOwnership
        //          SystemEnvironment
        //          SystemProfile
        //          SingleProcessProfile
        //          LoadDriver
        //          CreatePagefile
        //          IncreaseQuota
        //


        SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON |
                       SECURITY_ACCESS_NETWORK_LOGON;
        Index = 0;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_SECURITY_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_BACKUP_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_RESTORE_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_SYSTEMTIME_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_REMOTE_SHUTDOWN_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_TAKE_OWNERSHIP_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_DEBUG_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_SYSTEM_ENVIRONMENT_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_SYSTEM_PROFILE_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_PROF_SINGLE_PROCESS_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_INC_BASE_PRIORITY_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_LOAD_DRIVER_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_CREATE_PAGEFILE_PRIVILEGE);
        Index++;

        Privileges->Privilege[Index].Luid =
            ConvertLongToOldLargeInteger(SE_INCREASE_QUOTA_PRIVILEGE);
        Index++;

        // to add another privilege, and add another group of lines ^^^

        Privileges->PrivilegeCount    = Index;

        (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_ADMINS;
        Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);
        if (!NT_SUCCESS(Status)) {
            KdPrint(("LSA DB INSTALL: Creation of Administrators privileged account failed.\n"
                     "                Status: 0x%lx\n", Status));
        }

    }

    if (NT_SUCCESS(Status)) {

        //
        // Backup Operators Alias account
        //      Logon types: Interactive
        //      Privileges:
        //          Backup
        //          Restore
        //          Shutdown
        //


        SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

        Privileges->Privilege[0].Luid =
            ConvertLongToOldLargeInteger(SE_BACKUP_PRIVILEGE);

        Privileges->Privilege[1].Luid =
            ConvertLongToOldLargeInteger(SE_RESTORE_PRIVILEGE);

        Privileges->Privilege[2].Luid =
            ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);

        // to add another privilege, vvvv increment this, and add a line ^^^

        Privileges->PrivilegeCount    = 3;

        (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_BACKUP_OPS;
        Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

    }

    if (LsapProductType == NtProductLanManNt) {

        if (NT_SUCCESS(Status)) {

            //
            // System Operators Alias account
            //      Logon types: Interactive
            //      Privileges:
            //          Backup
            //          Restore
            //          SetTime
            //          Shutdown
            //          RemoteShutdown
            //


            SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

            Privileges->Privilege[0].Luid =
                ConvertLongToOldLargeInteger(SE_BACKUP_PRIVILEGE);

            Privileges->Privilege[1].Luid =
                ConvertLongToOldLargeInteger(SE_RESTORE_PRIVILEGE);

            Privileges->Privilege[2].Luid =
                ConvertLongToOldLargeInteger(SE_SYSTEMTIME_PRIVILEGE);

            Privileges->Privilege[3].Luid =
                ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);

            Privileges->Privilege[4].Luid =
                ConvertLongToOldLargeInteger(SE_REMOTE_SHUTDOWN_PRIVILEGE);

            // to add another privilege, vvvv increment this, and add a line ^^^

            Privileges->PrivilegeCount    = 5;

            (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_SYSTEM_OPS;
            Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

        }

        if (NT_SUCCESS(Status)) {

            //
            // Account Operators Alias account
            //      Logon types: Interactive
            //      Privileges:
            //          Shutdown
            //


            SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

            Privileges->Privilege[0].Luid =
                ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);

            // to add another privilege, vvvv increment this, and add a line ^^^

            Privileges->PrivilegeCount    = 1;

            (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_ACCOUNT_OPS;
            Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

        }

        if (NT_SUCCESS(Status)) {

            //
            // Print Operators Alias account
            //      Logon types: Interactive
            //      Privileges:
            //          Shutdown
            //


            SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

            Privileges->Privilege[0].Luid =
                ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);

            // to add another privilege, vvvv increment this, and add a line ^^^

            Privileges->PrivilegeCount    = 1;

            (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_PRINT_OPS;
            Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

        }



    } else {


        if (NT_SUCCESS(Status)) {

            //
            // Power Users Alias account
            //      Logon types: Interactive, Network
            //      Privileges:
            //          Shutdown
            //          Set System Time
            //          SystemProfile
            //          SingleProcessProfile
            //          Debug (for developer installs ONLY!).
            //


            SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON |
                           SECURITY_ACCESS_NETWORK_LOGON |
                           SECURITY_ACCESS_REMOTE_INTERACTIVE_LOGON ;

            Privileges->Privilege[0].Luid =
                ConvertLongToOldLargeInteger(SE_SYSTEMTIME_PRIVILEGE);

            Privileges->Privilege[1].Luid =
                ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);

            Privileges->Privilege[2].Luid =
                ConvertLongToOldLargeInteger(SE_REMOTE_SHUTDOWN_PRIVILEGE);

            Privileges->Privilege[3].Luid =
                ConvertLongToOldLargeInteger(SE_SYSTEM_PROFILE_PRIVILEGE);

            Privileges->Privilege[3].Luid =
                ConvertLongToOldLargeInteger(SE_PROF_SINGLE_PROCESS_PRIVILEGE);

            Privileges->Privilege[4].Luid =
                ConvertLongToOldLargeInteger(SE_INC_BASE_PRIORITY_PRIVILEGE);

            // to add another privilege, vvvv increment this, and add a line ^^^

            Privileges->PrivilegeCount    = 5;


            //
            // Add privileges assigned for developer install
            //
            if (LsapSetupWasRun != TRUE) {

                Privileges->Privilege[Privileges->PrivilegeCount].Luid =
                    ConvertLongToOldLargeInteger(SE_DEBUG_PRIVILEGE);
                    Privileges->PrivilegeCount++;
            }



            (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_POWER_USERS;
            Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

        }

        if (NT_SUCCESS(Status)) {

            //
            // Users Alias account
            //      Logon types: Interactive
            //      Privileges:
            //          Shutdown
            //


            SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

            Privileges->Privilege[0].Luid =
                ConvertLongToOldLargeInteger(SE_SHUTDOWN_PRIVILEGE);

            // to add another privilege, vvvv increment this, and add a line ^^^

            Privileges->PrivilegeCount    = 1;

            (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_USERS;
            Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

        }


        if (NT_SUCCESS(Status)) {

            //
            // Guests Alias account
            //      Logon types: Interactive
            //      Privileges:
            //          None
            //


            SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON;

            // to add another privilege, vvvv increment this, and add a line ^^^

            Privileges->PrivilegeCount    = 0;

            (*RtlSubAuthoritySid(BuiltinAccountSid, 1)) = DOMAIN_ALIAS_RID_GUESTS;
            Status = LsapDbInitializeAccount(BuiltinAccountSid, Privileges, SystemAccess);

        }


    }






    //
    // Free up SID buffers
    //

    RtlFreeSid( WorldSid );
    RtlFreeSid( BuiltinAccountSid );




    return(Status);


}




NTSTATUS
LsapDbInitializeAccount(
    IN PSID AccountSid,
    IN PLSAPR_PRIVILEGE_SET Privileges,
    IN ULONG SystemAccess
    )

/*++

Routine Description:

    This function creates a single ACCOUNT object and assigns it the
    privileges and system access specified.

Arguments:

    AccountSid - The SID of the account to create.

    Privileges - The privileges, if any, to assign to the account.

    SystemAccess - The logon capabilities, if any, to assign to the account.


Return Value:


--*/

{

    NTSTATUS
        Status = STATUS_SUCCESS,
        LocalStatus;

    LSAPR_HANDLE
        AccountHandle = NULL;

    if ((Privileges->PrivilegeCount == 0) &&
        (NT_SUCCESS(Status) && SystemAccess == 0) ) {
        return(STATUS_SUCCESS);
    }


    Status = LsarCreateAccount( LsapDbHandle, AccountSid, 0, &AccountHandle);

    if (NT_SUCCESS(Status)) {

        if (Privileges->PrivilegeCount > 0) {
            Status = LsarAddPrivilegesToAccount( AccountHandle, Privileges );
        }

        if (NT_SUCCESS(Status) && SystemAccess != 0) {
            Status = LsarSetSystemAccessAccount( AccountHandle, SystemAccess);
        }

        LocalStatus = LsapCloseHandle( &AccountHandle, Status );
    }

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\dspolicy\dbinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbinit.c

Abstract:

    Local Security Authority - Database Server Initialization

    This module contains functions which perform initialization of
    the Database Server.  Certain information is obtained from the
    LSA database and is set up in global data for easy retrieval.

Author:

    Scott Birrell       (ScottBi)       July 25, 1991

Environment:

    User Mode

Revision History:

    12-Nov-1997         MikeSw
        Added lsa policy handle cache for interdomain lookups

--*/

//
// Define this to allocate all globals in this module
//

#include <lsapch2.h>
#include "lsasrvp.h"
#include "dbp.h"
#include <bndcache.h>
#include <wincrypt.h>
#include <lsapmsgs.h>
#include <ntddnfs.h>
#include <remboot.h>
#ifdef DS_LOOKUP
#include <dslookup.h>
#endif
#include <sertlp.h>
#include <cryptdll.h>
#include <md5.h>
#include <rc4.h>
#include <wxlpc.h>
#include <dnsapi.h>
   
//
// Well known Sids for security packages include a subauthority equal to
// the associated package's RPC Id.  We'll cause a compile time error if 
// these numbers ever change.
//

#if (SECURITY_PACKAGE_NTLM_RID != RPC_C_AUTHN_WINNT)
    #error SECURITY_PACKAGE_NTLM_RID definition must be equal to \
RPC_C_AUTHN_WINNT
#endif

#if (SECURITY_PACKAGE_DIGEST_RID != RPC_C_AUTHN_DIGEST)
    #error SECURITY_PACKAGE_DIGEST_RID definition must equal RPC_C_AUTHN_DIGEST
#endif
    
#if (SECURITY_PACKAGE_SCHANNEL_RID != RPC_C_AUTHN_GSS_SCHANNEL)  
    #error SECURITY_PACKAGE_SCHANNEL_RID definition must equal \
RPC_C_AUTHN_GSS_SCHANNEL
#endif
         
             
extern LSAP_DB_TRUSTED_DOMAIN_LIST LsapDbTrustedDomainList;


NTSTATUS
LsapDbBuildObjectCaches(
    );

NTSTATUS
LsapAssignInitialHiveProtection(
    HANDLE HiveRoot
    );

NTSTATUS
LsapCreateDatabaseProtection(
    PISECURITY_DESCRIPTOR   Sd
    );

NTSTATUS
LsapGenerateRandomDomainSid(
    OUT PSID NewDomainSid
    );

NTSTATUS
LsapSetupInitialize(
    VOID
    );

NTSTATUS
LsapUpdateDatabaseProtection(
    IN ULONG Revision
    );

NTSTATUS
LsapDsInitFixupQueue(
    VOID
    );

static  UCHAR SyskeyBuffer[LSAP_SYSKEY_SIZE];
static  UCHAR OldSyskeyBuffer[LSAP_SYSKEY_SIZE];


NTSTATUS
LsapDbInitializeServer(
    IN ULONG Pass
    )
/*++

Routine Description:

    This function initializes the LSA Database Server.  The following
    steps are performed:

    o Initialize the LSA Database Lock
    o Acquire the LSA Database Lock
    o Initialize the Unicode Strings for the fixed names within the
      LSA Database, e.g. LSA Database object attributes and well-known
      object names.
    o Initialize the Unicode Strings for the LSA Database Object constant
      and well known names, e.g SubKeys, fixed object names.
    o Initialize the Unicode Strings for LSA Object Containing Dirs
    o Initialize the Generic Mappings for Database Object Types
    o Initialize the Lsa Database Handle Table
    o Install the LSA Database if necessary - Creates the Lsa Database
    o    and Manager account objects, and initializes the transaction
         subtree
    o Initialize the abs min, abs max and installation default quota limits
    o Release the LSA Database Lock

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus;
    BOOL BooleanStatus = TRUE;
    BOOLEAN AcquiredLock = FALSE;
    BOOLEAN FreeComputerName = FALSE;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    PLSAPR_POLICY_ACCOUNT_DOM_INFO PolicyAccountDomainInfo = NULL;
    PLSAPR_POLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo = NULL;
    UNICODE_STRING ComputerName, CipherKey;
    ULONG Length;
    ULONG Revision, RevisionLength = sizeof( ULONG );
    DWORD WinStatus;

    //
    // Initialize the LSA Database Lock and set it into the locked state
    //

    if (Pass == 1 ) {

        LsapDsDebugInitialize();

        RtlZeroMemory( &LsaDsStateInfo, sizeof( LsaDsStateInfo ) );
        LsapDbState.DbServerInitialized = FALSE;
#if DBG
        LsapDbState.RegistryTransactionOpen = FALSE;
#endif

        //
        // Disable Replicator Notifications.
        //

        LsapDbDisableReplicatorNotification();

        //
        // This function call will initialize all of the global or well known locks used by
        // the Lsa
        //
        Status = LsapDbInitializeLock();

        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }

        Status = LsapDbInitHandleTables();

        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }

        //
        // Initialize the forest trust cache.
        // The cache is not usable until populated.
        //

        Status = LsapForestTrustCacheInitialize();

        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }

        //
        // Initialize the policy change notification mechanism
        //

        Status = LsapInitializeNotifiyList();

        if ( !NT_SUCCESS( Status ) ) {
            goto InitializeServerError ;
        }

        //
        // Initialize the Fixup queue
        //

        Status = LsapDsInitFixupQueue();
        if ( !NT_SUCCESS( Status ))
        {
            goto InitializeServerError ;
        }

        //
        // Initialize the binding handle cache
        //

        Status = LsapInitBindingCache();
        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }
    }

    //
    // Acquire the LSA Database Lock.  This allows subroutines to
    // assert that the LSA Database is locked.  Otherwise, it is
    // not actually necessary, given that no other thread can access the
    // LSA until initialization is complete.
    //

    if (Pass == 1) {

        //
        // Initialize the Unicode Strings for the fixed names within the
        // LSA Database, e.g. LSA Database object attributes and well-known
        // object names.
        //

        Status = LsapDbInitializeUnicodeNames();

        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Initialize the Unicode Strings for the Containing Directories for
        // each LSA Database Object Type.
        //

        Status = LsapDbInitializeContainingDirs();

        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Initialize the LSA Subsystem name string.  This is needed for
        // NtAccessCheckAuditAlarm calls
        //

        RtlInitUnicodeString(&LsapState.SubsystemName, L"LSA");

        //
        // Initialize the Shutdown Pending state.
        //

        LsapState.SystemShutdownPending = FALSE;

        //
        // Initialize the Database Object Types.  Information stored
        // includes the Generic mappings and Object Counts.
        //

        Status = LsapDbInitializeObjectTypes();

        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Open the LSA Database root Registry subkey.  This stays
        // open for use in adding transactions.
        //

        Status = LsapDbOpenRootRegistryKey();

        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Initialize the Lsa Database Cipher Key
        // This hard-coded key is used for retrieving old pre-NT4 SP4
        // encrypted keys only
        //

        RtlInitUnicodeString( &CipherKey, L"823543" );

        Status = LsapDbInitializeCipherKey( &CipherKey,
                                            &LsapDbCipherKey );

        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Initialize the LSA Database Transaction Subtree, creating it if
        // one does not already exist.  If the Transaction Subtree exists,
        // commit any partially committed transaction if appropriate.
        //

        Status = RtlInitializeRXact(
                     LsapDbState.DbRootRegKeyHandle,
                     TRUE,
                     (PRTL_RXACT_CONTEXT *) &LsapDbState.RXactContext
                     );

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_RXACT_STATE_CREATED) {

                LsapLogError(
                    "LsapDbInitializeServer: Registry Transaction Init returned 0x%lx\n",
                    Status
                    );

                goto InitializeServerError;
            }

            LsapLogError(
                "LsapDbInitializeServer: Registry Transaction State Did Not Exist\n",
                Status
                );

            goto InitializeServerError;
        }

        //
        // Setup attributes for opening the Policy object.
        //

        ObjectInformation.ObjectTypeId = PolicyObject;
        ObjectInformation.ContainerTypeId = 0;
        ObjectInformation.Sid = NULL;
        ObjectInformation.ObjectAttributeNameOnly = FALSE;
        ObjectInformation.DesiredObjectAccess = 0;

        InitializeObjectAttributes(
            &ObjectInformation.ObjectAttributes,
            &LsapDbNames[Policy],
            0L,
            NULL,
            NULL
            );

        //
        // Now try to open the root LSA Database object (Policy).  This is a
        // trusted call, so no access checking or impersonation will be done.
        // Note that the handle obtained will remain open indefinitely.  It is
        // used after initialization for all internally generated accesses to
        // the Policy object
        //

        Status = LsapDbOpenObject(
                     &ObjectInformation,
                     0L,
                     LSAP_DB_TRUSTED,
                     &LsapDbHandle
                     );

        if (!NT_SUCCESS(Status)) {

            //
            // Open of LSA Database object failed.  If any error other than
            // object not found, there is a serious error which prevents the
            // LSA from functioning, so abort.
            //

            if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

                LsapLogError(
                    "LsapDbInitializeServer: Open failed 0x%lx\n"
                    "The Lsa Database must be reinstalled or manually\n"
                    "erased before using the system\n",
                    Status
                    );

                goto InitializeServerError;
            }

            //
            // The Lsa Database object was not found.  Run the database installation
            // routine so that people can boot without having to run the
            // installation applet first.
            //

            LsapDatabaseSetupPerformed = TRUE;

            Status = LsapDbInstallLsaDatabase(1);

            if (!NT_SUCCESS(Status)) {

                goto InitializeServerError;
            }
        }

        //
        // The Lsa Database object was successfully opened, possibly after
        // having just been created.  Proceed with the rest of server
        // initialization.  First, setup in-memory copies of the Installation
        // Default, Absolute Min and Absolute Max system quota limits.
        //

        //
        // Make the policy handle available throughout LSA
        //

        LsapPolicyHandle = LsapDbHandle;

        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }

        //
        // Bring the database up to the current revision level,
        // if necessary. This is not a syskey upgrade.
        //

        Status = LsapDbUpgradeRevision(FALSE,FALSE);
        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }

        //
        // Read the revision attribute. If the revision is greater than
        // LSAP_DB_REVSION_1_5 then obtain the syskey from winlogon. In previous
        // revisions SAM would have obtained the syskey from winlogon if the machine
        // had been syskey'd
        //

        Status = LsapDbReadAttributeObject(
                     LsapDbHandle,
                     &LsapDbNames[PolRevision],
                     (PVOID) &Revision,
                     &RevisionLength
                     );

        if ( !NT_SUCCESS(Status) ) {
            goto InitializeServerError;
        }

        //
        // Query the syskey from winlogon. Do so only if the revision is greater than 1_5.
        // This is because in previous builds SAM used to manage the syskey. From this
        // release onwards. The below routine also intializes the LSA encryption key
        //

        if (Revision >= LSAP_DB_REVISION_1_5)
        {
            Status = LsapDbGetSyskeyFromWinlogon();
            if (!NT_SUCCESS(Status))
            {
                goto InitializeServerError;
            }
        }

        //
        // Initialize privilege object related code
        //

        Status = LsapDbInitializePrivilegeObject();

        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }

        //
        // Perform initialization for the Replicator.  Replications
        // are still disabled at this point.
        //

        Status = LsapDbInitializeReplication();
        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Initialize the data for the new APIs (user rights)
        //

        Status = LsapDbInitializeRights();
        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

    } else if (Pass == 2) {

        BOOLEAN ExpectTrue;
        OSVERSIONINFOEX OsVersionInfoEx = { 0 };

        //
        // Perform the second stage of database initialization.
        // This is the initialization that depends on the product type.
        // First, get the product type.  Note that the Product Type may
        // have already been retrieved from a number of routines that
        // may be called during early installation, including
        // LsarSetInformationPolicy() and LsarCreateTrustedDomain().
        //

        ExpectTrue = RtlGetNtProductType(&LsapProductType);
        ASSERT( ExpectTrue == TRUE );

        //
        // find out the product suite mask.
        // this is used later to determine if we are running
        // on a specific product suite such the small business server
        //
        OsVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        ExpectTrue = (BOOLEAN) GetVersionEx((OSVERSIONINFO*) &OsVersionInfoEx);
        ASSERT( ExpectTrue == TRUE );
        LsapProductSuiteMask = OsVersionInfoEx.wSuiteMask;

        //
        // If necessary, install the rest of our database.
        //

        if (LsapDatabaseSetupPerformed == TRUE) {

            Status = LsapDbInstallLsaDatabase(2);

            if (!NT_SUCCESS(Status)) {
                goto InitializeServerError;
            }
        }

        //
        // If this is a Win Nt product, set the SAM Accounts Domain
        // Name equal to the Computer Name, which may have been changed
        // since the last boot.
        //

        //
        // If this is setup, do nothing, since we've set it elsewhere..
        // If this is safe mode mode, don't set it either
        //

        if ( !LsaISetupWasRun() ) {
            if ( ((LsapProductType == NtProductWinNt) ||
                (LsapProductType == NtProductServer)) &&
                !LsaISafeMode() ) {

                Status = LsarQueryInformationPolicy(
                             LsapPolicyHandle,
                             PolicyAccountDomainInformation,
                             (PLSAPR_POLICY_INFORMATION *) &PolicyAccountDomainInfo
                             );

                if (!NT_SUCCESS(Status)) {
                    goto InitializeServerError;
                }

                Length = (ULONG) 0;

                ComputerName.Buffer = UNICODE_NULL;
                FreeComputerName = FALSE;

                BooleanStatus = GetComputerNameW(
                                    (LPWSTR) ComputerName.Buffer,
                                    (LPDWORD) &Length
                                    );

                WinStatus = GetLastError();

                if (WinStatus != ERROR_BUFFER_OVERFLOW) {

                    KdPrint(("LsapDbInitializeServer: Failed to get Computer Name Length\n"
                         "Using default MACHINENAME instead\n"));

                    RtlInitUnicodeString( &ComputerName, LSAP_DB_DEFAULT_COMPUTER_NAME );
                    Length = (ULONG) ComputerName.Length;

                } else if (Length <= 1) {

                    KdPrint(("LsapDbInitializeServer: Null Computer Name\n"
                         "Using default MACHINENAME instead\n"));

                    RtlInitUnicodeString( &ComputerName, LSAP_DB_DEFAULT_COMPUTER_NAME );
                    Length = (ULONG) ComputerName.Length;

                } else {

                    ComputerName.Length = (USHORT) ((Length - 1) * sizeof (WCHAR));
                    ComputerName.MaximumLength = (USHORT) (Length * sizeof(WCHAR));
                    ComputerName.Buffer = MIDL_user_allocate( ComputerName.MaximumLength );

                    if ( ComputerName.Buffer == NULL ) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto InitializeServerError;
                    }

                    FreeComputerName = TRUE;
                }

                if (!GetComputerNameW(
                        (LPWSTR) ComputerName.Buffer,
                        (LPDWORD) &Length
                        )) {

                    KdPrint(("LsapDbInitializeServer: Failed to get Computer Name\n"
                             "Using default MACHINENAME instead\n"));

                    RtlInitUnicodeString( &ComputerName, LSAP_DB_DEFAULT_COMPUTER_NAME );
                }

                PolicyAccountDomainInfo->DomainName = *((PLSAPR_UNICODE_STRING) &ComputerName);

                Status = LsarSetInformationPolicy(
                             LsapPolicyHandle,
                             PolicyAccountDomainInformation,
                             (PLSAPR_POLICY_INFORMATION) PolicyAccountDomainInfo
                             );

                if ( FreeComputerName ) {

                    MIDL_user_free( ComputerName.Buffer );
                }

                if (!NT_SUCCESS(Status)) {

                    goto InitializeServerError;
                }
            }

            Status = RpcMgmtEnableIdleCleanup();

            if ( !NT_SUCCESS( Status )) {

                goto InitializeServerError;
            }

        } else {

            Status = LsapSetupInitialize();
            if (!NT_SUCCESS(Status)) {

                goto InitializeServerError;
            }
        }

        // Perform initialization for Lookup Sids and Names, including
        // initialization of the Trusted Domain List.
        //

        Status = LsapDbLookupInitialize();

        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Load the object caches.  Any that fail to load have caching
        // permanently turned off.
        //

        IgnoreStatus = LsapDbBuildObjectCaches();

        //
        // Find out if this machine is a DC in a root domain
        //

        Status = LsapDbQueryInformationPolicy(
                     LsapPolicyHandle,
                     PolicyDnsDomainInformation,
                     ( PLSAPR_POLICY_INFORMATION * )&PolicyDnsDomainInfo
                     );

        if ( !NT_SUCCESS( Status )) {

            goto InitializeServerError;
        }

        if ( DnsNameCompareEqual == DnsNameCompareEx_W(
                                        PolicyDnsDomainInfo->DnsDomainName.Buffer,
                                        PolicyDnsDomainInfo->DnsForestName.Buffer,
                                        0 )) {

            DcInRootDomain = TRUE;

        } else {

            DcInRootDomain = FALSE;
        }

        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            ( PLSAPR_POLICY_INFORMATION )PolicyDnsDomainInfo
            );

        //
        // Mark the Server as being completely initialized.
        //

        LsapDbState.DbServerInitialized = TRUE;

        LsapDbEnableReplicatorNotification();
    }

InitializeServerFinish:

    return(Status);

InitializeServerError:

    goto InitializeServerFinish;
}


NTSTATUS
LsapDbUpgradeRevision(
    IN BOOLEAN SyskeyUpgrade,
    IN BOOLEAN GenerateNewSyskey
    )

/*++

Routine Description:

    This function brings the LSA policy database up to date if necessary.

Arguments:

    SyskeyUpgrade -- This paramter is set to true when this function is called a second
                     time around when upgrading NT4 or Win2K B3 machines from LsaIHealthCheck

    GenerateNewSyskey -- This parameter is set to true when this function is called a second
                         time around when upgrading NT4 or Win2k B3 machines from LsaIHealthCheck
                         and the system is not already syskey'd

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status;

    ULONG Revision = LSAP_DB_REVISION_1_0, RevisionLength = sizeof( ULONG );

    LSAP_DB_ATTRIBUTE Attributes[20];

    PLSAP_DB_ATTRIBUTE NextAttribute;

    ULONG AttributeCount = 0;
    BOOLEAN PolRevisionWritten = FALSE;

    NextAttribute = Attributes;

    //
    // Read the Revision Info from the PolRevision attribute
    // of the Policy object in the LSA Database.
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[PolRevision],
                 (PVOID) &Revision,
                 &RevisionLength
                 );

    if ( !NT_SUCCESS(Status) ) {
        Revision = LSAP_DB_REVISION_1_0;
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // attribute doesn't exist.
            // This means the database is an NT1.0 format.
            // Upgrade it to the current revision.
            //

            Status = STATUS_SUCCESS;
        }
    }

    //
    // Revison 1_1 created the ModifiedIdAtLastPromotion attribute on the policy object.
    // This attribute is no longer used for anything so don't create it.
    //

    //
    // Revision 1_2 corresponded to an encryption of secrets that shipped with NT4 that was
    // incompatible with NT5. Therefore skip this revision level. The incompatible encryption
    // of secrets would be handled by revision number update
    //

    //
    // Update the security descriptor to revision 1.3
    //

    if ( NT_SUCCESS( Status ) && (Revision < LSAP_DB_REVISION_1_3) ) {

        Status = LsapUpdateDatabaseProtection( LSAP_DB_REVISION_1_3 );

        if ( NT_SUCCESS( Status ) ) {

            Revision = LSAP_DB_REVISION_1_3;

            if ( !PolRevisionWritten ) {

                LsapDbInitializeAttribute(
                    NextAttribute,
                    &LsapDbNames[PolRevision],
                    &Revision,
                    sizeof (ULONG),
                    FALSE
                    );

                NextAttribute++;
                AttributeCount++;
                PolRevisionWritten = TRUE;

                ASSERT( AttributeCount < ( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) ) );
            }

        } else {

            Status = STATUS_SUCCESS;
        }
    }

    if ( NT_SUCCESS( Status )  && (Revision < LSAP_DB_REVISION_1_5) && (SyskeyUpgrade)) {

        BOOLEAN                IsUpgrade = FALSE;
        PVOID                  Syskey = NULL;
        ULONG                  SyskeyLength = 0;
        LSAP_DB_ENCRYPTION_KEY NewEncryptionKey;

        //
        // NT4 SP4 shipped with an encryption of secret's that is incompatible with
        // NT5 if the syskey'd setting was turned on.
        // Therefore we walk over all secrets and patch them back. It is not necessary
        // that we have all the key's setup at this point. The way this works is we attempt,
        // to patch back all the secrets, and if we did not have the right key to decrypt them
        // we will error out. In Syskey'd machines , SAM will have the right key and will call back
        // into LSA when it has obtained the key. During SAM's callback this routine will be executed
        // again and we will call upgrade all secrets.
        //

        // This upgrade involves a secret upgrade only.  We simply have to read them and
        // write them back out and everything will be kosher...
        // Note if the secret upgrade fails for any reason, we will not update the database revision.
        //

        //
        // First obtain the syskey from the SAM hive. Admittedly and ahsamedly this does read the SAM
        // hive directly
        //

        //
        // If we are a syskey'd machine the syskey should have been passed to us by now.
        //

        ASSERT((NULL!=LsapDbSysKey) || (GenerateNewSyskey));

        //
        // Initialize the key for secret encryption
        //

        Status = LsapDbGenerateNewKey(
                    &NewEncryptionKey
                    );

        if (NT_SUCCESS(Status))
        {
            if (GenerateNewSyskey)
            {
                ULONG SyskeyLength = sizeof(SyskeyBuffer);

                // Boot option is WxStored.
                NewEncryptionKey.BootType = WxStored;

                //
                // A new syskey is being generated
                //

                Status =  LsapDbSetupInitialSyskey(
                                &SyskeyLength,
                                &LsapDbSysKey
                                );
            }
            else
            {
                //
                // Since we are upgrading from a syskey'd machine, get the boot option from SAM
                // SAM is initialized enough at this point as it makes the callout to LSA supplying it with
                // the syskey. It is O.K to pass in a value of 0, because then the default account domain
                // is used.
                //

                Status = SamIGetBootKeyInformation(
                                (SAMPR_HANDLE) 0,
                                 (SAMPR_BOOT_TYPE*)&NewEncryptionKey.BootType
                                 );
            }
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Setup the secret cipher key
            // Ordinarily, the key used for reading equals the key used for writing
            //

            LsapDbInitializeSecretCipherKeyRead( &NewEncryptionKey );
            LsapDbInitializeSecretCipherKeyWrite( &NewEncryptionKey );

            //
            // Encrypt the key with syskey
            //

            LsapDbEncryptKeyWithSyskey(
                        &NewEncryptionKey,
                        LsapDbSysKey,
                        LSAP_SYSKEY_SIZE
                        );

            LsapDbInitializeAttribute(
                NextAttribute,
                &LsapDbNames[PolSecretEncryptionKey],
                &NewEncryptionKey,
                sizeof (NewEncryptionKey),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;
        }

        //
        // The secret upgrade is executed only during GUI setup upgrade of a workstation, or a DC being upgraded
        // from NT4. In all other cases we simply patch the revision number up to the correct value.
        //

        if ((NT_SUCCESS(Status)) && ( (SamIIsDownlevelDcUpgrade()) ||
             ((LsapProductType != NtProductLanManNt) && (SamIIsSetupInProgress(&IsUpgrade)) && (IsUpgrade))))
        {
            //
            // Ignore the return code below, we still want to move the revision
            // level to 1.5, and this code will not be retried anyways
            //

            LsapDbUpgradeSecretForKeyChange();
        }

        if ( NT_SUCCESS( Status ) ) {

            Revision = LSAP_DB_REVISION_1_5;

            if ( !PolRevisionWritten ) {

                LsapDbInitializeAttribute(
                    NextAttribute,
                    &LsapDbNames[PolRevision],
                    &Revision,
                    sizeof (ULONG),
                    FALSE
                    );

                NextAttribute++;
                AttributeCount++;
                PolRevisionWritten = TRUE;

                //
                // Revision is now 1.5
                //

                ASSERT( AttributeCount < ( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) ) );
            }
        }
    }

    //
    // Only upgrade past revision 1.5 if we've upgraded to revison 1.5.
    //
    // We don't upgrade to revision 1.5 in the mainline LSA initialization code.
    // Rather, we upgrade to revision 1.5 in a callback from SAM.  If then we moved on
    // to revisions greater than 1.5 during LSA initialization, we'd never have a chance to
    // do the revision 1.5 upgrade code.
    //

    if ( Revision >= LSAP_DB_REVISION_1_5 ) {

        //
        // Update the security descriptor to revision 1.6
        //

        if ( NT_SUCCESS( Status ) && (Revision < LSAP_DB_REVISION_1_6) ) {

            Status = LsapUpdateDatabaseProtection( LSAP_DB_REVISION_1_6 );
            if ( NT_SUCCESS( Status ) ) {

                Revision = LSAP_DB_REVISION_1_6;

                if ( !PolRevisionWritten ) {

                    LsapDbInitializeAttribute(
                        NextAttribute,
                        &LsapDbNames[PolRevision],
                        &Revision,
                        sizeof (ULONG),
                        FALSE
                        );

                    NextAttribute++;
                    AttributeCount++;
                    PolRevisionWritten = TRUE;

                    //
                    // Revision is now 1.6
                    //

                    ASSERT( AttributeCount < ( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) ) );
                }

            } else {

                Status = STATUS_SUCCESS;
            }
        }

        //
        // Update the security descriptor to revision 1.7
        //

        if ( NT_SUCCESS( Status ) && (Revision < LSAP_DB_REVISION_1_7) ) {

            Status = LsapUpdateDatabaseProtection( LSAP_DB_REVISION_1_7 );
            if ( NT_SUCCESS( Status ) ) {

                Revision = LSAP_DB_REVISION_1_7;

                if ( !PolRevisionWritten ) {

                    LsapDbInitializeAttribute(
                        NextAttribute,
                        &LsapDbNames[PolRevision],
                        &Revision,
                        sizeof (ULONG),
                        FALSE
                        );

                    NextAttribute++;
                    AttributeCount++;
                    PolRevisionWritten = TRUE;

                    //
                    // Revision is now 1.7
                    //

                    ASSERT( AttributeCount < ( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) ) );
                }

            } else {

                Status = STATUS_SUCCESS;
            }
        }

        //
        // In the future, revision updates can be made
        // by adding "if" blocks similar to the one above.
        //
        // Remember, however, that the attributes are pointing
        // to values in local variables.  Any local variable
        // value changed before the attribute is written out
        // will cause that attribute value to be changed.
        //
        //
    }

    //
    // Now write out all attributes that have been added (if any)
    //

    if (AttributeCount > 0) {

        Status = LsapDbReferenceObject(
                    LsapDbHandle,
                    0,
                    PolicyObject,
                    PolicyObject,
                    LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION
                    );

        if (NT_SUCCESS(Status)) {

            ASSERT( AttributeCount < ( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) ) );
            Status = LsapDbWriteAttributesObject(
                         LsapDbHandle,
                         Attributes,
                         AttributeCount
                         );

            //
            // No attributes are replicatable.
            //  (That's good, too, since SAM hasn't told Netlogon our role yet.)

            Status = LsapDbDereferenceObject(
                         &LsapDbHandle,
                         PolicyObject,
                         PolicyObject,
                         (LSAP_DB_LOCK |
                            LSAP_DB_FINISH_TRANSACTION |
                            LSAP_DB_OMIT_REPLICATOR_NOTIFICATION ),
                         SecurityDbChange,
                         Status
                         );
        }
    }

    return( Status );
}


NTSTATUS
LsapDbBuildObjectCaches(
    )

/*++

Routine Description:

    This function builds caches for Lsa objects.  These caches contain a
    subset of the information for some object types.

Arguments:

    None

Return Values:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS IgnoreStatus;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;

    //
    // Initialize all the caches.
    //

    for (ObjectTypeId = PolicyObject;
         ObjectTypeId <= SecretObject;
         ObjectTypeId++) {

        IgnoreStatus = LsapDbRebuildCache( ObjectTypeId );
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
LsapDbInitializeObjectTypes(
    )

/*++

Routine Description:

    This function initializes the information pertinent to each object
    type in the LSA Database.  This information includes the following:

    o Generic Mapping Arrays

    The Generic Mapping array for each object defines the list of
    object-type-specific access types that correspond to the generic
    access types GENERIC_READ, GENERIC_WRITE, GENERIC_EXECUTE and
    GENERIC_ALL for the object type.

    o Object Count Information

    The Object Count Information includes a count of the number of objects
    that exist for each type, the upper limit on this number (if any) for
    each object type, and the error code to return when that limit is
    reached.

    o Write Operation Masks

    These specify which access types are update operations

    o Default accesses granted to World and Admin aliases

    o Invalid access masks for each object type

    These masks specify the bits in an access mask that are invalid for
    a given object type.

    o Initial owners of each object type

    o Object caching supported for each object type.



Arguments:

    None. The Generic Mapping arrays are held the LsapDbState structure.

Return Value:

    NTSTATUS - Standard Nt Result Code.  Currently, there are no error
        situations in this code, so STATUS_SUCCESS is always returned.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PGENERIC_MAPPING GenericMapping;
    PLSAP_DB_OBJECT_TYPE ObjectType;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;

    //
    // Initialize the Generic Mapping Array for the PolicyObject Object Type
    // Note that there is only one object of this type and objects of this
    // type can neither be created nor destroyed.
    //

    GenericMapping =
        &LsapDbState.DbObjectTypes[PolicyObject].GenericMapping;
    GenericMapping->GenericRead =
        STANDARD_RIGHTS_READ |
        POLICY_VIEW_AUDIT_INFORMATION |
        POLICY_GET_PRIVATE_INFORMATION;

    GenericMapping->GenericWrite =
        STANDARD_RIGHTS_WRITE |
        POLICY_TRUST_ADMIN |
        POLICY_CREATE_ACCOUNT |
        POLICY_CREATE_SECRET |
        POLICY_CREATE_PRIVILEGE |
        POLICY_SET_DEFAULT_QUOTA_LIMITS |
        POLICY_SET_AUDIT_REQUIREMENTS |
        POLICY_AUDIT_LOG_ADMIN |
        POLICY_SERVER_ADMIN;

    GenericMapping->GenericExecute =
        STANDARD_RIGHTS_EXECUTE |
        POLICY_VIEW_LOCAL_INFORMATION |
        POLICY_LOOKUP_NAMES;

    GenericMapping->GenericAll = POLICY_ALL_ACCESS | POLICY_NOTIFICATION;

    //
    // Initialize the Generic Mapping Array for the Account Object Type
    // Note that Account Objects can be created and destroyed.
    //

    GenericMapping =
        &LsapDbState.DbObjectTypes[AccountObject].GenericMapping;

    GenericMapping->GenericRead =
        STANDARD_RIGHTS_READ |
        ACCOUNT_VIEW;

    GenericMapping->GenericWrite =
        STANDARD_RIGHTS_WRITE |
        ACCOUNT_ADJUST_PRIVILEGES |
        ACCOUNT_ADJUST_QUOTAS |
        ACCOUNT_ADJUST_SYSTEM_ACCESS;

    GenericMapping->GenericExecute =
        STANDARD_RIGHTS_EXECUTE;

    GenericMapping->GenericAll = ACCOUNT_ALL_ACCESS;

    //
    // Initialize the Generic Mapping Array for the TrustedDomain Object
    // Type.
    //

    GenericMapping =
        &LsapDbState.DbObjectTypes[TrustedDomainObject].GenericMapping;

    GenericMapping->GenericRead =
        STANDARD_RIGHTS_READ |
        TRUSTED_QUERY_DOMAIN_NAME;

    GenericMapping->GenericWrite =
        STANDARD_RIGHTS_WRITE |
        TRUSTED_SET_CONTROLLERS |
        TRUSTED_SET_POSIX;

    GenericMapping->GenericExecute =
        STANDARD_RIGHTS_EXECUTE |
        TRUSTED_QUERY_CONTROLLERS |
        TRUSTED_QUERY_POSIX;

    GenericMapping->GenericAll = TRUSTED_ALL_ACCESS;

    //
    // Initialize the Generic Mapping Array for the Secret Object
    // Type.
    //

    GenericMapping =
        &LsapDbState.DbObjectTypes[SecretObject].GenericMapping;

    GenericMapping->GenericRead =
        STANDARD_RIGHTS_READ |
        SECRET_QUERY_VALUE;

    GenericMapping->GenericWrite =
        STANDARD_RIGHTS_WRITE |
        SECRET_SET_VALUE;

    GenericMapping->GenericExecute =
        STANDARD_RIGHTS_EXECUTE;

    GenericMapping->GenericAll = SECRET_ALL_ACCESS;

    //
    // Initialize the Object Count Information to defaults
    //

    ObjectType = &(LsapDbState.DbObjectTypes[PolicyObject]);

    for (ObjectTypeId = PolicyObject;
         ObjectTypeId < DummyLastObject;
         ObjectTypeId++) {

        ObjectType->ObjectCount = 0;
        ObjectType->ObjectCountLimited = FALSE;
        ObjectType->ObjectCountError = STATUS_SUCCESS;
        ObjectType->MaximumObjectCount = 0;
    }

    //
    // Set specific limits for Secret Object Type.  This is the only
    // object type so far to have limits.
    //

    ObjectType = &(LsapDbState.DbObjectTypes[SecretObject]);
    ObjectType->ObjectCountLimited = TRUE;
    ObjectType->ObjectCountError = STATUS_TOO_MANY_SECRETS;
    ObjectType->MaximumObjectCount = LSA_SECRET_MAXIMUM_COUNT;

    //
    // Initialize the write operations for each object type
    //

    LsapDbState.DbObjectTypes[PolicyObject].WriteOperations = LSAP_POLICY_WRITE_OPS;
    LsapDbState.DbObjectTypes[TrustedDomainObject].WriteOperations = LSAP_TRUSTED_WRITE_OPS;
    LsapDbState.DbObjectTypes[AccountObject].WriteOperations = LSAP_ACCOUNT_WRITE_OPS;
    LsapDbState.DbObjectTypes[SecretObject].WriteOperations = LSAP_SECRET_WRITE_OPS;

    //
    // Initialize the default accesses granted to Domain Admins alias
    //

    LsapDbState.DbObjectTypes[PolicyObject].AliasAdminsAccess = GENERIC_ALL;
    LsapDbState.DbObjectTypes[TrustedDomainObject].AliasAdminsAccess = GENERIC_ALL | DELETE;
    LsapDbState.DbObjectTypes[AccountObject].AliasAdminsAccess = GENERIC_ALL | DELETE;
    LsapDbState.DbObjectTypes[SecretObject].AliasAdminsAccess = GENERIC_ALL | DELETE;

    //
    // Initialize the default accesses granted to World alias
    //

    LsapDbState.DbObjectTypes[PolicyObject].WorldAccess = GENERIC_EXECUTE;
    LsapDbState.DbObjectTypes[TrustedDomainObject].WorldAccess = GENERIC_EXECUTE;
    LsapDbState.DbObjectTypes[AccountObject].WorldAccess = GENERIC_EXECUTE;
    LsapDbState.DbObjectTypes[SecretObject].WorldAccess = GENERIC_EXECUTE;

    //
    // Initialize the default accesses granted to AnonymousLogon alias
    //

    LsapDbState.DbObjectTypes[PolicyObject].AnonymousLogonAccess = POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES;
    LsapDbState.DbObjectTypes[TrustedDomainObject].AnonymousLogonAccess = 0;
    LsapDbState.DbObjectTypes[AccountObject].AnonymousLogonAccess = 0;
    LsapDbState.DbObjectTypes[SecretObject].AnonymousLogonAccess = 0;

    //
    // Initialize the default accesses granted to LocalService and NetworkService
    //

    LsapDbState.DbObjectTypes[PolicyObject].LocalServiceAccess = POLICY_NOTIFICATION;
    LsapDbState.DbObjectTypes[TrustedDomainObject].LocalServiceAccess = 0;
    LsapDbState.DbObjectTypes[AccountObject].LocalServiceAccess = 0;
    LsapDbState.DbObjectTypes[SecretObject].LocalServiceAccess = 0;

    LsapDbState.DbObjectTypes[PolicyObject].NetworkServiceAccess = POLICY_NOTIFICATION;
    LsapDbState.DbObjectTypes[TrustedDomainObject].NetworkServiceAccess = 0;
    LsapDbState.DbObjectTypes[AccountObject].NetworkServiceAccess = 0;
    LsapDbState.DbObjectTypes[SecretObject].NetworkServiceAccess = 0;

    //
    // Initialize the Invalid Access masks for each object type
    //

    LsapDbState.DbObjectTypes[PolicyObject].InvalidMappedAccess =
         ((ACCESS_MASK)(~(POLICY_ALL_ACCESS | POLICY_NOTIFICATION | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED)));
    LsapDbState.DbObjectTypes[TrustedDomainObject].InvalidMappedAccess =
         ((ACCESS_MASK)(~(TRUSTED_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED)));
    LsapDbState.DbObjectTypes[AccountObject].InvalidMappedAccess =
         ((ACCESS_MASK)(~(ACCOUNT_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED)));
    LsapDbState.DbObjectTypes[SecretObject].InvalidMappedAccess =
         ((ACCESS_MASK)(~(SECRET_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED)));

    //
    // Initialize the Initial Owners for new objects of each type
    //

    LsapDbState.DbObjectTypes[PolicyObject].InitialOwnerSid = LsapAliasAdminsSid;
    LsapDbState.DbObjectTypes[TrustedDomainObject].InitialOwnerSid = LsapAliasAdminsSid;
    LsapDbState.DbObjectTypes[AccountObject].InitialOwnerSid = LsapAliasAdminsSid;
    LsapDbState.DbObjectTypes[SecretObject].InitialOwnerSid = LsapAliasAdminsSid;

    //
    // Specify method of access to objects of the type.  Currently, all objects
    // of a given type are accessed in the same way, either by Sid or by Name
    // but not both.
    //

    LsapDbState.DbObjectTypes[PolicyObject].AccessedByName = TRUE;
    LsapDbState.DbObjectTypes[TrustedDomainObject].AccessedByName = FALSE;
    LsapDbState.DbObjectTypes[AccountObject].AccessedByName = FALSE;
    LsapDbState.DbObjectTypes[SecretObject].AccessedByName = TRUE;

    LsapDbState.DbObjectTypes[PolicyObject].AccessedBySid = FALSE;
    LsapDbState.DbObjectTypes[TrustedDomainObject].AccessedBySid = TRUE;
    LsapDbState.DbObjectTypes[AccountObject].AccessedBySid = TRUE;
    LsapDbState.DbObjectTypes[SecretObject].AccessedBySid = FALSE;

    //
    // Specify the object types for which caching is supported (in full
    // or in part) and turn caching off initially for all object types.
    // Object types for which caching is supported have ther caches set
    // to the "Invalid" state.  Automatic restore is allowed for caches
    // in this state.  Object types for which caching is not supported
    // are set to the "Not supported" state.  Note that a cache is
    // also placed in the "not supported" state if an attempt to restore
    // it fails.
    //

    LsapDbMakeCacheInvalid( PolicyObject );
    LsapDbMakeCacheInvalid( TrustedDomainObject );
    LsapDbMakeCacheInvalid( AccountObject );
    LsapDbMakeCacheUnsupported( SecretObject );

    return(Status);
}


NTSTATUS
LsapDbInitializeUnicodeNames()

/*++

Routine Description:

    This function initializes two arrays of Unicode Strings.  The
    LsapDbNames array contains Unicode Strings for all of the constant
    names in the Lsa Database.  The LsapDbObjectTypeNames is indexed
    by Object Type Id and contains the Unicode Strings for all of the
    LSA Database object types.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_NAMES Index;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;

    PCWSTR UnicodeNames[DummyLastName + 1] = {

        L"SecDesc",
        L"Privilgs",
        L"Sid",
        L"Name",
        L"AdminMod",
        L"OperMode",
        L"QuotaLim",
        L"DefQuota",
        L"PrDomain",
        L"Policy",
        L"Accounts",
        L"Domains",
        L"Secrets",
        L"CurrVal",
        L"OldVal",
        L"CupdTime",
        L"OupdTime",
        L"PolAdtLg",
        L"PolAdtEv",
        L"PolAcDmN",
        L"PolAcDmS",
        L"PolDnDDN",
        L"PolDnTrN",
        L"PolDnDmG",
        L"PolEfDat",
        L"PolPrDmN",
        L"PolPrDmS",
        L"PolPdAcN",
        L"PolRepSc",
        L"PolRepAc",
        L"PolRevision",
        L"PolMod",
        L"PolState",
        L"ActSysAc",
        L"TrDmName",
        L"TrDmTrPN",    // Netbios name of trust partner
        L"TrDmSid",
        L"TrDmAcN",
        L"TrDmCtN",
        L"TrDmPxOf",
        L"TrDmCtEn",
        NULL,           // TrDmTrTy
        NULL,           // TrDmTrDi
        L"TrDmTrLA",    // TrDmTrLA
        L"TrDmTrPr",    // Trust partner
        L"TrDmTrRt",    // Root partner
        L"TrDmSAI",     // Incoming auth. info
        L"TrDmSAO",     // Outgoing auth. info
        L"TrDmForT",    // Forest trust info
        L"TrDmCrSid",   // Creator Sid
        L"KerOpts",     // Kerberos authentication options
        L"KerMinT",     // Kerberos Minimum ticket age
        L"KerMaxT",     // Kerberos maximum ticket age
        L"KerMaxR",     // Kerberos maximum renewal age
        L"KerProxy",    // Kerberos proxy lifetime
        L"KerLogoff",   // Kerberos force logoff duration
        L"BhvrVers",    // Behavior-Version
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Eventlog\\Security",
        L"MaxSize",
        L"Retention",
        L"PseudoSystemCritical",
        L"PolSecretEncryptionKey",
        L"XRefDnsRoot",
        L"XRefNetbiosName",
        L"DummyLastName"
    };

    PCWSTR UnicodeObjectTypeNames[DummyLastObject] = {

        L"NullObject",
        L"PolicyObject",
        L"TrustedDomainObject",
        L"UserAccountObject",
        L"SecretObject",
        L"AllObject",
        L"NewTrustedDomainObject"
    };

    //
    // Referenced by LsapDbDsAttInfo
    //
    static LSAP_DB_DS_INFO StaticLsapDbDsAttInfo[DummyLastName + 1]  = {
        {ATT_NT_SECURITY_DESCRIPTOR,    LsapDbAttribSecDesc, LsapDsLocDs}, // Security Descriptor
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown }, // Privileges
        {ATT_SECURITY_IDENTIFIER,       LsapDbAttribSid,     LsapDsLocDs},     // Sid
        {0,                             LsapDbAttribUnknown, LsapDsLocDs}, // Name
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // AdminMod
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // OperMode
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // QuotaLim
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // DefQuota
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // PrDomain
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Policy
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Accounts
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Domains
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Secrets
        {ATT_CURRENT_VALUE,             LsapDbAttribPByte,   LsapDsLocDs},   // CurrVal
        {ATT_PRIOR_VALUE,               LsapDbAttribPByte,   LsapDsLocDs},   // OldVal
        {ATT_LAST_SET_TIME,             LsapDbAttribPByte,   LsapDsLocDs},   // CupdTime
        {ATT_PRIOR_SET_TIME,            LsapDbAttribPByte,   LsapDsLocDs},   // OupdTime
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // PolAdtLg
        {ATT_AUDITING_POLICY,           LsapDbAttribPByte,   LsapDsLocRegistry}, // PolAdtEv
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolAcDmN
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolAcDmS
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolDnDDN
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolDnTrN
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolDnDmG
        {ATT_EFSPOLICY,                 LsapDbAttribPByte,   LsapDsLocRegistry}, // PolEfDat
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolPrDmN
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolPrDmS
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolPdAcN
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolRepSc
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolRepAc
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // PolRevision
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolMod
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolState
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // ActSysAc
        {ATT_TRUST_PARTNER,             LsapDbAttribUnicode, LsapDsLocDs}, // TrDmName
        {ATT_FLAT_NAME,                 LsapDbAttribUnicode, LsapDsLocDs}, // TrDmTrPN
        {ATT_SECURITY_IDENTIFIER,       LsapDbAttribSid,     LsapDsLocDs},     // TrDmSid
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // TrDmAcN
        {0,                             LsapDbAttribUnicode, LsapDsLocRegistry}, // TrDmCtN
        {ATT_TRUST_POSIX_OFFSET,        LsapDbAttribULong,   LsapDsLocDs},   // TrDmPxOf
        {0,                             LsapDbAttribUnicode, LsapDsLocRegistry}, // TrDmCtEn
        {ATT_TRUST_TYPE,                LsapDbAttribULong,   LsapDsLocDs},   // TrDmTrTy
        {ATT_TRUST_DIRECTION,           LsapDbAttribULong,   LsapDsLocDs},   // TrDmTrDi
        {ATT_TRUST_ATTRIBUTES,          LsapDbAttribULong,   LsapDsLocDs},   // TrDmTrLA
        {ATT_DOMAIN_CROSS_REF,          LsapDbAttribDsName,  LsapDsLocDs},  // TrDmTrPr
        {ATT_ROOT_TRUST,                LsapDbAttribDsName,  LsapDsLocDs},  // TrDmTrRt
        {ATT_TRUST_AUTH_INCOMING,       LsapDbAttribPByte,   LsapDsLocDs},   // TrDmSAI
        {ATT_TRUST_AUTH_OUTGOING,       LsapDbAttribPByte,   LsapDsLocDs},   // TrDmSAO
        {ATT_MS_DS_TRUST_FOREST_TRUST_INFO, LsapDbAttribPByte, LsapDsLocDs}, // TrDmForT
        {ATT_MS_DS_CREATOR_SID,         LsapDbAttribSid,     LsapDsLocDs},   // TrDmCrSid
        {ATT_AUTHENTICATION_OPTIONS,    LsapDbAttribULong,   LsapDsLocRegistry}, // KerOpts,
        {ATT_MIN_TICKET_AGE,            LsapDbAttribPByte,   LsapDsLocRegistry}, // KerMinT,
        {ATT_MAX_TICKET_AGE,            LsapDbAttribPByte,   LsapDsLocRegistry}, // KerMaxT,
        {ATT_MAX_RENEW_AGE,             LsapDbAttribPByte,   LsapDsLocRegistry}, // KerMaxR,
        {ATT_PROXY_LIFETIME,            LsapDbAttribPByte,   LsapDsLocRegistry}, // KerProxy,
        {ATT_FORCE_LOGOFF,              LsapDbAttribPByte,   LsapDsLocRegistry}, // KerLogoff
        {ATT_MS_DS_BEHAVIOR_VERSION,    LsapDbAttribULong,   LsapDsLocDs},       // BhvrVers
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Audit log
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Audit log size
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Audit Recored Retention Period
        {ATT_IS_CRITICAL_SYSTEM_OBJECT, LsapDbAttribULong,   LsapDsLocDs}, // system critical component.
        {0,                             LsapDbAttribPByte,   LsapDsLocRegistry},//PolSecretEncryptionKey
        {ATT_DNS_ROOT,                  LsapDbAttribUnicode, LsapDsLocDs}, // DNS name of cross-ref
        {ATT_NETBIOS_NAME,              LsapDbAttribUnicode, LsapDsLocDs}, // Netbios domain of cross-ref
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}  // Dummy Last Name
    };

    //
    // Initialize general array of Unicode Names
    //

    for (Index = SecDesc; Index < DummyLastName; Index++) {

        RtlInitUnicodeString( &LsapDbNames[Index], UnicodeNames[Index] );
    }

    //
    // Initialize array of Unicode Names for Lsa Database Object Types
    //

    for (ObjectTypeId = NullObject;
         ObjectTypeId < DummyLastObject;
         ObjectTypeId++) {

        RtlInitUnicodeString(
            &LsapDbObjectTypeNames[ObjectTypeId],
            UnicodeObjectTypeNames[ObjectTypeId]
            );
    }

    LsapDbDsAttInfo = StaticLsapDbDsAttInfo;
    return(Status);
}


NTSTATUS
LsapDbInitializeContainingDirs()

/*++

Routine Description:

    This function initializes Unicode strings for the names of the Containing
    directories for each object type.  The Containing Directory is the
    Registry Key under which all objects of the given type are created and is
    relative to the LSA Database root.  Note that objects of a given type all
    exist under a single Registry node, that is, the type of an object
    uniquely determines the name of its containing directory.

    NOTE:  Containing Directories are used to produce Physical Object Names
           from Logical Object Names.  The Physical Object Name is simply
           the Logical Object Name prepended with the Containing Directory
           Name and a "\".

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;

    PWSTR ContainingDirectories[DummyLastObject] = {

        L"",
        L"",
        L"Domains",
        L"Accounts",
        L"Secrets"
    };

    //
    // Initialize the array of Unicode Strings indexed by object type setting
    // the Containing Directory name for each object type.
    //

    for (ObjectTypeId = PolicyObject;
         ObjectTypeId < DummyLastObject;
         ObjectTypeId++) {

        RtlInitUnicodeString(
            &LsapDbContDirs[ObjectTypeId],
            ContainingDirectories[ ObjectTypeId ]
            );
    }

    return(Status);
}


NTSTATUS
LsapDbInitializeReplication(
    )

/*++

Routine Description:

    This function performes LSA initialization for replication and turns
    on notification of LSA Database updates to the LSA Database Replicator.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status;
    ULONG PolicyModificationInfoLength  = sizeof (POLICY_MODIFICATION_INFO);
    ULONG PolicyLsaServerRoleInfoLength = sizeof(POLICY_LSA_SERVER_ROLE_INFO);
    ULONG LargeIntegerLength            = sizeof( LARGE_INTEGER );

    //
    // Read the Policy Modification Info from the PolMod attribute
    // of the Policy object in the LSA Database.
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[PolMod],
                 (PVOID) &LsapDbState.PolicyModificationInfo,
                 &PolicyModificationInfoLength
                 );

    if (!NT_SUCCESS(Status)) {
        goto InitializeReplicationError;
    }

InitializeReplicationFinish:

     return(Status);

InitializeReplicationError:

     goto InitializeReplicationFinish;
}


NTSTATUS
LsapDbInitializeCipherKey(
    IN PUNICODE_STRING CipherSeed,
    IN PLSAP_CR_CIPHER_KEY *CipherKey
    )

/*++

Routine Description:

    This function initializes the LSA Database Cipher Key.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status;
    LSAP_CR_CLEAR_VALUE ClearCipherKey;
    PLSAP_CR_CIPHER_VALUE CipherCipherKey;

    *CipherKey = NULL;

    //
    // Initialize the Cipher key to a hardwired constant
    // encrypted with itself.
    //
    LsapCrUnicodeToClearValue( CipherSeed, &ClearCipherKey);

    Status = LsapCrEncryptValue(
                 &ClearCipherKey,
                 (PLSAP_CR_CIPHER_KEY) &ClearCipherKey,
                 &CipherCipherKey
                 );

    if (!NT_SUCCESS(Status)) {

        LsapLogError( "LsapDbInitializeReplication: NtQuerySystemTime returned 0x%lx\n",
                      Status );

    } else {

        *CipherKey = ( PLSAP_CR_CIPHER_KEY )CipherCipherKey;
    }

    return(Status);

}


NTSTATUS
LsapDbOpenRootRegistryKey(
    )

/*++

Routine Description:

    This function opens the LSA Database Root Registry Key.  This has
    the fixed name \Registry\Machine\Security.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status;
    UNICODE_STRING DbRootRegKeyNameU;
    OBJECT_ATTRIBUTES DbAttributes;

    RtlInitUnicodeString( &DbRootRegKeyNameU, LSAP_DB_ROOT_REG_KEY_NAME );

    InitializeObjectAttributes(
        &DbAttributes,
        &DbRootRegKeyNameU,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = RtlpNtOpenKey(
                 (PHANDLE) &LsapDbState.DbRootRegKeyHandle,
                 (KEY_READ | KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | WRITE_DAC),
                 &DbAttributes,
                 0
                 );


    if (!NT_SUCCESS(Status)) {
        LsapLogError(
            "LsapDbOpenRootRegistryKey: Open Root Key for LSA Policy Database returned 0x%lx\n",
            Status
            );
        goto OpenRootRegistryKeyError;
    }


    //
    // If there are no sub-keys, then we are in system-install.
    // Assign the initial protection of this hive.
    //

    Status = LsapAssignInitialHiveProtection( LsapDbState.DbRootRegKeyHandle );

    if (!NT_SUCCESS(Status)) {
        LsapLogError(
            "LsapDbOpenRootRegistryKey: Couldn't assign initial hive protection 0x%lx\n",
            Status
            );
        goto OpenRootRegistryKeyError;
    }



OpenRootRegistryKeyFinish:

    return(Status);

OpenRootRegistryKeyError:

    goto OpenRootRegistryKeyFinish;
}


NTSTATUS
LsapAssignInitialHiveProtection(
    HANDLE HiveRoot
    )


/*++

Routine Description:

    This function assigns inheritable protection to the hive root key.
    It will only do this if the hive root has no sub-keys.
    This condition will only exist during system installation.

    WARNING -

    THIS ROUTINE IS TAILORED TO OPERATE ON THE \REGISTRY\SECURITY HIVE.
    As such, it expects the Root key to have exactly one sub-key (a
    link to the SAM hive) if the the database has NOT been initialized.
    Otherwise, it expects the LSA policy database keys to be present.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Everything went fine.  No indication of whether
        protection was necessarily assigned or not.

    All other status values are generated by called routines.

--*/

{
    NTSTATUS
        Status;

    KEY_BASIC_INFORMATION
        DummyBuffer;

    ULONG
        IgnoreRequiredLength;

    SECURITY_DESCRIPTOR
        Sd;


    //
    // See if the hive has more than 1 sub-keys.
    //
    //

    Status = NtEnumerateKey(
                 HiveRoot,
                 1,                     // Index - 0 is the SAM link, 1 is LSA policy database stuff
                 KeyBasicInformation,   // Name of key
                 &DummyBuffer,
                 sizeof(DummyBuffer),
                 &IgnoreRequiredLength
                 );

    if (Status == STATUS_NO_MORE_ENTRIES) {

        //
        // We are initializing the system...
        // Apply a reasonable ACL to the hive root.
        //

        Status = LsapCreateDatabaseProtection( &Sd );

        if (NT_SUCCESS(Status)) {
            Status = NtSetSecurityObject(
                         HiveRoot,                  // Object to apply to
                         DACL_SECURITY_INFORMATION, // Information to set
                         (PSECURITY_DESCRIPTOR)&Sd   // Descriptor
                         );
        }

    } else {

        Status = STATUS_SUCCESS;
    }

    return(Status);
}



NTSTATUS
LsapCreateDatabaseProtection(
    PISECURITY_DESCRIPTOR   Sd
    )


/*++

Routine Description:

    This function allocates and initializes protection to assign to
    the SAM database.

    Upon return, any non-zero pointers in the security descriptors
    point to memory allocated from process heap.  It is the caller's
    responsibility to free this memory.


    Protection is:

                        System: All Access
                        Admin:  ReadControl | WriteDac

Arguments:

    Sd - Address of a security descriptor to initialize.

Return Value:

    STATUS_SUCCESS - The Security descriptor has been initialize.

    STATUS_NO_MEMORY - couldn't allocate memory for the protection info.

--*/


{
    NTSTATUS
        Status;

    ULONG
        Length;

    USHORT
        i;

    PACL
        Dacl;

    PACE_HEADER
        Ace;

    //
    // Initialize the security descriptor.
    // This call should not fail.
    //

    Status = RtlCreateSecurityDescriptor( Sd, SECURITY_DESCRIPTOR_REVISION1 );
    ASSERT(NT_SUCCESS(Status));

    Length = (ULONG)sizeof(ACL) +
                 (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                 RtlLengthSid( LsapLocalSystemSid ) +
                 RtlLengthSid( LsapAliasAdminsSid ) +
                 8; // The 8 is just for good measure


    Dacl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

    if (Dacl == NULL) {
        return(STATUS_NO_MEMORY);
    }

    Status = RtlCreateAcl (Dacl, Length, ACL_REVISION2 );
    ASSERT(NT_SUCCESS(Status));

    //
    // Add ACEs to the ACL...
    // These calls should not be able to fail.
    //

    Status = RtlAddAccessAllowedAce(
                 Dacl,
                 ACL_REVISION2,
                 (GENERIC_ALL),
                 LsapLocalSystemSid
                 );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlAddAccessAllowedAce(
                 Dacl,
                 ACL_REVISION2,
                 (READ_CONTROL | WRITE_DAC),
                 LsapAliasAdminsSid
                 );
    ASSERT(NT_SUCCESS(Status));

    //
    // Now mark the ACEs as inheritable...
    //

    for ( i=0; i<Dacl->AceCount; i++) {

        //
        // Get the address of the next ACE
        // (Shouldn't fail)
        //

        Status = RtlGetAce( Dacl, (ULONG)i, &Ace );
        ASSERT(NT_SUCCESS(Status));

        Ace->AceFlags |= (CONTAINER_INHERIT_ACE);
    }

    //
    // And add the ACL to the security descriptor.
    // This call should not fail.
    //

    Status = RtlSetDaclSecurityDescriptor(
                 Sd,
                 TRUE,              // DaclPresent
                 Dacl,              // Dacl OPTIONAL
                 FALSE              // DaclDefaulted OPTIONAL
                 );

    ASSERT(NT_SUCCESS(Status));

    return(STATUS_SUCCESS);
}


NTSTATUS
LsapUpdateDatabaseProtection(
    IN ULONG Revision
    )

/*++

Routine Description:

    This function allocates and updates protection to assign to
    the LSA database.

Arguments:

    Revision  - New database revision level
        LSAP_DB_REVISION_1_3 -- grant POLICY_NOTIFICATION access to Administrators
        LSAP_DB_REVISION_1_6 -- grant POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES to AnonymousLogonSid
        LSAP_DB_REVISION_1_7 -- grant POLICY_NOTIFICATION to LocalService/NetworkService


Return Value:

    STATUS_SUCCESS - The Security descriptor has been initialize.

    STATUS_NO_MEMORY - couldn't allocate memory for the protection info.

--*/

{
    NTSTATUS Status;
    NTSTATUS TempStatus;
    PSECURITY_DESCRIPTOR CurrentSd = NULL;
    PSECURITY_DESCRIPTOR RelativeSd = NULL;
    ULONG RelativeSdLength;
    PSECURITY_DESCRIPTOR NewSd;
    SECURITY_DESCRIPTOR NewSdBuffer;
    USHORT i;
    PACL Dacl, NewDacl = NULL, TempAcl;
    PACE_HEADER Ace;
    PSID AceSid;
    BOOLEAN AdminAceFound = FALSE;
    BOOLEAN UpdatedSd = FALSE;

    //
    // First, read the initial security descriptor...
    //
    Status = LsapRegReadObjectSD( LsapPolicyHandle,
                                  &CurrentSd );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    ASSERT( Revision == LSAP_DB_REVISION_1_3
             ||
            Revision == LSAP_DB_REVISION_1_6
             ||
            Revision == LSAP_DB_REVISION_1_7 );

    NewSd = CurrentSd;

    if ( Revision == LSAP_DB_REVISION_1_3
          ||
         Revision == LSAP_DB_REVISION_1_6
          ||
         Revision == LSAP_DB_REVISION_1_7 )
    {
        Dacl = RtlpDaclAddrSecurityDescriptor( ( PISECURITY_DESCRIPTOR )CurrentSd );

        if ( Dacl ) {

            //
            // We'll have to find the ace for local system
            //

            Ace = ( PACE_HEADER )FirstAce( Dacl );

            for(i = 0; i < Dacl->AceCount; i++, Ace = ( PACE_HEADER )NextAce( Ace ) ) {

                if ( IsObjectAceType( Ace ) ) {

                    AceSid = RtlObjectAceSid( Ace );

                } else {

                    AceSid = &( ( PKNOWN_ACE )Ace )->SidStart;
                }

                //
                // When upgrading to revision 1_3, update the administrators ACE
                //

                if ( Revision == LSAP_DB_REVISION_1_3 &&
                     RtlEqualSid( AceSid, LsapAliasAdminsSid ) ) {

                    //
                    // Get the access mask and or in our new bit
                    //
                    if ( IsObjectAceType( Ace ) ) {

                        if (( ((PKNOWN_OBJECT_ACE)Ace)->Mask & POLICY_NOTIFICATION ) == 0 ) {

                            ((PKNOWN_OBJECT_ACE)Ace)->Mask |= POLICY_NOTIFICATION;
                            UpdatedSd = TRUE;
                        }

                    } else {

                        if (( ((PKNOWN_ACE)Ace)->Mask & POLICY_NOTIFICATION ) == 0 ) {

                            ((PKNOWN_ACE)Ace)->Mask |= POLICY_NOTIFICATION;
                            UpdatedSd = TRUE;
                        }
                    }

                    AdminAceFound = TRUE;
                }
            }
        }

        //
        // If we didn't find an ACE to update, make sure to add it...
        //
        if ( !AdminAceFound )
        {
            ULONG NewDaclLength;

            UpdatedSd = TRUE;

            NewDaclLength = Dacl ? Dacl->AclSize : 0;

            if ( Revision == LSAP_DB_REVISION_1_3 )
            {
                NewDaclLength += ( ULONG )sizeof( ACCESS_ALLOWED_ACE ) +
                          RtlLengthSid( LsapAliasAdminsSid );
            }
            else if ( Revision == LSAP_DB_REVISION_1_6 )
            {
                NewDaclLength += ( ULONG )sizeof( ACCESS_ALLOWED_ACE ) +
                          RtlLengthSid( LsapAnonymousSid );
            }
            else
            {
                ASSERT( Revision == LSAP_DB_REVISION_1_7 );

                NewDaclLength += 2 * ( ULONG )sizeof( ACCESS_ALLOWED_ACE ) +
                          RtlLengthSid( LsapLocalServiceSid ) +
                          RtlLengthSid( LsapNetworkServiceSid );
            }

            NewDacl = LsapAllocateLsaHeap( NewDaclLength );

            if ( NewDacl == NULL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            if ( Dacl ) {

                RtlCopyMemory( NewDacl, Dacl, Dacl->AclSize );
                NewDacl->AclSize = ( USHORT )NewDaclLength;

            } else {

                Status = RtlCreateAcl ( NewDacl, NewDaclLength, ACL_REVISION2 );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }
            }

            //
            // For version 1.3, grant administrators All access and Policy notification access
            //
            if ( Revision == LSAP_DB_REVISION_1_3 ) {

                Status = RtlAddAccessAllowedAce( NewDacl,
                                                 ACL_REVISION2,
                                                 POLICY_ALL_ACCESS |
                                                        POLICY_NOTIFICATION,
                                                 LsapAliasAdminsSid );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }

            //
            // For version 1.6, grant anonymous logon View Local and Lookup names access.
            //

            } else if ( Revision == LSAP_DB_REVISION_1_6) {

                Status = RtlAddAccessAllowedAce( NewDacl,
                                                 ACL_REVISION2,
                                                 POLICY_VIEW_LOCAL_INFORMATION |
                                                        POLICY_LOOKUP_NAMES,
                                                 LsapAnonymousSid );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }

            //
            // For version 1.7, grant Policy notification access to LocalService
            // and NetworkService
            //

            } else {

                ASSERT( Revision == LSAP_DB_REVISION_1_7 );

                Status = RtlAddAccessAllowedAce( NewDacl,
                                                 ACL_REVISION2,
                                                 POLICY_NOTIFICATION,
                                                 LsapLocalServiceSid );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }

                Status = RtlAddAccessAllowedAce( NewDacl,
                                                 ACL_REVISION2,
                                                 POLICY_NOTIFICATION,
                                                 LsapNetworkServiceSid );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }
            }

            //
            // If the current security descriptor is self relative,
            //  convert it to absolute so I can set the DACL on it.
            //
            if ( RtlpAreControlBitsSet( ( PISECURITY_DESCRIPTOR )CurrentSd,
                                        SE_SELF_RELATIVE ) ) {

                NewSd = &NewSdBuffer;

                Status = RtlCreateSecurityDescriptor( NewSd,
                                                      SECURITY_DESCRIPTOR_REVISION );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }


                ((PISECURITY_DESCRIPTOR)NewSd)->Control =
                    ((PISECURITY_DESCRIPTOR)CurrentSd)->Control;


                AceSid = RtlpOwnerAddrSecurityDescriptor(
                                            ( PISECURITY_DESCRIPTOR )CurrentSd );

                if ( AceSid ) {

                    ( (PISECURITY_DESCRIPTOR)NewSd )->Owner = AceSid;
                }

                AceSid = RtlpGroupAddrSecurityDescriptor(
                                            ( PISECURITY_DESCRIPTOR )CurrentSd );

                if ( AceSid ) {

                    ( ( PISECURITY_DESCRIPTOR )NewSd )->Group = AceSid;
                }

                TempAcl = RtlpSaclAddrSecurityDescriptor(
                                            ( PISECURITY_DESCRIPTOR )CurrentSd );

                if ( TempAcl ) {

                    ( ( PISECURITY_DESCRIPTOR )NewSd )->Sacl = TempAcl;
                }

                RtlpClearControlBits( ( PISECURITY_DESCRIPTOR )NewSd,
                                       SE_SELF_RELATIVE );

            }

            //
            // Put the computed DACL onto the SD.
            //
            Status = RtlSetDaclSecurityDescriptor( NewSd,
                                                   TRUE,
                                                   NewDacl,
                                                   FALSE );
            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

            //
            // Convert the SD to self relative before writing it to the database.
            //

            RelativeSdLength = 0;
            Status = RtlMakeSelfRelativeSD( NewSd,
                                            NULL,
                                            &RelativeSdLength );

            if (Status != STATUS_BUFFER_TOO_SMALL) {    // This is the expected case
                if ( NT_SUCCESS(Status) ) {
                    Status = STATUS_INTERNAL_ERROR;
                }
                goto Cleanup;
            }

            RelativeSd = LsapAllocateLsaHeap( RelativeSdLength );

            if ( RelativeSd == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            Status = RtlMakeSelfRelativeSD( NewSd,
                                            RelativeSd,
                                            &RelativeSdLength );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

            NewSd = RelativeSd;
        }
    }

    if ( UpdatedSd ) {
        ULONG NewSdLength;

        //
        // Set the security descriptor back on the object
        //
        NewSdLength = RtlLengthSecurityDescriptor( NewSd );

        //
        // Add a Registry transaction to write the Security Descriptor as the
        // value of the new object's SecDesc subkey.
        //

        Status = LsapDbReferenceObject(
                    LsapDbHandle,
                    0,
                    PolicyObject,
                    PolicyObject,
                    LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION
                    );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        Status = LsapDbWriteAttributeObject( LsapPolicyHandle,
                                             &LsapDbNames[ SecDesc ],
                                             NewSd,
                                             NewSdLength );

        TempStatus = LsapDbDereferenceObject(
                     &LsapDbHandle,
                     PolicyObject,
                     PolicyObject,
                     (LSAP_DB_LOCK |
                      LSAP_DB_OMIT_REPLICATOR_NOTIFICATION | // Each BDC should upgrade its own database
                      LSAP_DB_FINISH_TRANSACTION),
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status );

        if ( !NT_SUCCESS(TempStatus) ) {
            if (NT_SUCCESS(Status) ) {
                Status = TempStatus;
            }
        }
    }

Cleanup:

    //
    // Free the security descriptor
    //
    LsapFreeLsaHeap( CurrentSd );
    LsapFreeLsaHeap( RelativeSd );
    LsapFreeLsaHeap( NewDacl );

    return( Status );
}


NTSTATUS
LsapDbInitializeLock(
    )

/*++

Routine Description:

    This function initializes the LSA Database Lock.  It is called once
    only, during LSA Database initialization.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status;

    Status = SafeInitializeCriticalSection( &LsapDbState.AccountLock, ( DWORD )ACCOUNT_LOCK_ENUM );
    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    Status = SafeInitializeCriticalSection( &LsapDbState.PolicyLock, ( DWORD )POLICY_LOCK_ENUM );
    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    Status = SafeInitializeCriticalSection( &LsapDbState.SecretLock, ( DWORD )SECRET_LOCK_ENUM );
    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    Status = SafeInitializeCriticalSection( &LsapDbState.RegistryLock, ( DWORD )REGISTRY_LOCK_ENUM );
    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    Status = SafeInitializeCriticalSection( &LsapDbState.HandleTableLock, ( DWORD )HANDLE_TABLE_LOCK_ENUM );
    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    try
    {
        SafeInitializeResource( &LsapDbState.PolicyCacheLock, ( DWORD )POLICY_CACHE_LOCK_ENUM );
        Status = STATUS_SUCCESS;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Initialize the Resource for the Trusted Domain List.
    //

    InitializeListHead( &LsapDbTrustedDomainList.ListHead );
    LsapDbTrustedDomainList.TrustedDomainCount = 0;
    LsapDbTrustedDomainList.CurrentSequenceNumber = 0;
    LsapDbMakeCacheInvalid( TrustedDomainObject );

    try
    {
        SafeInitializeResource( &LsapDbTrustedDomainList.Resource, ( DWORD )TRUST_LOCK_ENUM );
        Status = STATUS_SUCCESS ;
    }
    except (EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) ) {

        goto Cleanup;
    }

    try
    {
        //
        // do not use the safelock library for ScePolicyLock
        // because it is usually acquired on one thread and
        // released on another
        //
        RtlInitializeResource( &LsapDbState.ScePolicyLock );
        Status = STATUS_SUCCESS ;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }
    if (!NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    LsapDbState.SceSyncEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
    if ( LsapDbState.SceSyncEvent == NULL ) {
        Status = GetLastError();
        goto Cleanup;
    }

#if DBG
    try
    {
        SafeInitializeResource( &LsapDsThreadInfoListResource, ( DWORD )THREAD_INFO_LIST_LOCK_ENUM );
        Status = STATUS_SUCCESS ;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }
    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }
    RtlZeroMemory( &LsapDsThreadInfoList, sizeof( LSADS_THREAD_INFO_NODE ) * LSAP_THREAD_INFO_LIST_MAX );
#endif
    Status = STATUS_SUCCESS;

Cleanup:
    return( Status );
}


NTSTATUS
LsapDbInitializeWellKnownValues(
    )

/*++

Routine Description:

    This function initializes the well-known values used by LSA.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status;
    BOOLEAN b;

    //
    // Initialize the Well Known Sids
    //

    b = LsapDbInitializeWellKnownSids( &WellKnownSids );

    if (!b ) {

        Status = STATUS_UNSUCCESSFUL;
        goto InitializeWellKnownValuesError;
    }

    //
    // Initialize the well known privilege values
    //

    Status = LsapDbInitializeWellKnownPrivs();

    if (!NT_SUCCESS(Status)) {

        goto InitializeWellKnownValuesError;
    }

InitializeWellKnownValuesFinish:

    return(Status);

InitializeWellKnownValuesError:

    goto InitializeWellKnownValuesFinish;
}


NTSTATUS
LsapDbInitializeWellKnownPrivs(
    )

/*++

Routine Description:

    This function initializes the well-known privilege values.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        Currently, only STATUS_SUCCESS is returned.
--*/

{
    LsapTcbPrivilege = RtlConvertLongToLuid(SE_TCB_PRIVILEGE);

    return STATUS_SUCCESS;
}


BOOLEAN
LsapDbInitializeWellKnownSids(
    OUT PLSAP_WELL_KNOWN_SID_ENTRY *WellKnownSids
    )

/*++

Routine Description:

    This function initializes the Well-Known Sids

Arguments:

    WellKnownSids - Receives a pointer to a newly created table of
        the Well Known Sids.

Return Value:

    BOOLEAN - TRUE if successful, else FALSE.

--*/

{
    NTSTATUS Status;
    BOOLEAN BooleanStatus = TRUE;
    LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex;
    ULONG SubAuthorities[LSAP_WELL_KNOWN_MAX_SUBAUTH_LEVEL];
    ULONG OutputWellKnownSidsLength;
    PLSAP_WELL_KNOWN_SID_ENTRY OutputWellKnownSids = NULL;
    UNICODE_STRING SidName, NtAuthorityName, UsersName;
    HMODULE StringsResource;
    SID_IDENTIFIER_AUTHORITY InternetSiteAuthority
                                            = SECURITY_INTERNETSITE_AUTHORITY;

    //
    // Get the message resource we need to get the SID names from
    //

    StringsResource = (HMODULE) LoadLibrary( L"LSASRV.DLL" );
    if (StringsResource == NULL) {
        return(FALSE);
    }


    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_NT_AUTHORITY,
                &NtAuthorityName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));
    //
    // Allocate memory for the table of Sids.
    //

    OutputWellKnownSidsLength =
        LsapDummyLastSidIndex * sizeof(LSAP_WELL_KNOWN_SID_ENTRY);

    OutputWellKnownSids = RtlAllocateHeap(
                              RtlProcessHeap(),
                              0,
                              OutputWellKnownSidsLength
                              );

    if (OutputWellKnownSids == NULL) {

        goto InitializeWellKnownSidsError;
    }

    //
    //  Allocate and initialize the universal SIDs
    //

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_NULL,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_NULL_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapNullSidIndex,
            &LsapNullSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_WORLD,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_WORLD_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapWorldSidIndex,
            &LsapWorldSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_LOCAL,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_LOCAL_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapLocalSidIndex,
            &LsapLocalSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_CREATOR_OWNER,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_CREATOR_OWNER_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapCreatorOwnerSidIndex,
            &LsapCreatorSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_CREATOR_GROUP,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_CREATOR_GROUP_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapCreatorGroupSidIndex,
            &LsapCreatorSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_CREATOR_OWNER_SERVER,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_CREATOR_OWNER_SERVER_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapCreatorOwnerServerSidIndex,
            &LsapCreatorSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }
    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_CREATOR_GROUP_SERVER,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_CREATOR_GROUP_SERVER_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapCreatorGroupServerSidIndex,
            &LsapCreatorSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }


    //
    // Initialize the Nt well-known Sids
    //

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_NT_DOMAIN,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapNtAuthoritySidIndex,
            &LsapNtAuthority,
            0,
            NULL,
            L"",
            SidName.Buffer,
            SidTypeDomain
            )) {

        goto InitializeWellKnownSidsError;
    }



    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_DIALUP,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_DIALUP_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapDialupSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_NETWORK,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_NETWORK_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapNetworkSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_BATCH,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_BATCH_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapBatchSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_INTERACTIVE,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_INTERACTIVE_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapInteractiveSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_REMOTE_INTERACTIVE,
                &SidName,
                0,
                NULL); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_REMOTE_LOGON_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapRemoteInteractiveSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }
    
    Status = LsapGetMessageStrings(
            StringsResource,
            LSAP_SID_NAME_THIS_ORGANIZATION,
            &SidName,
            0,
            NULL); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_THIS_ORGANIZATION_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapThisOrganizationSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_OTHER_ORGANIZATION,
                &SidName,
                0,
                NULL); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_OTHER_ORGANIZATION_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapOtherOrganizationSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }
    
    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_TERMINAL_SERVER,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_TERMINAL_SERVER_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapTerminalServerSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_SERVICE,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));
    SubAuthorities[0] = SECURITY_SERVICE_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapServiceSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }


    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_ANONYMOUS,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_ANONYMOUS_LOGON_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapAnonymousSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_PROXY,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_PROXY_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapProxySidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_SERVER,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_SERVER_LOGON_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapServerSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_SELF,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_PRINCIPAL_SELF_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapSelfSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_AUTHENTICATED_USER,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_AUTHENTICATED_USER_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapAuthenticatedUserSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    //
    // Add any Logon Id well known sids here.
    //

    SubAuthorities[0] = SECURITY_LOGON_IDS_RID;
    SubAuthorities[1] = 0;
    SubAuthorities[2] = 0;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapLogonSidIndex,
            &LsapNtAuthority,
            3,
            SubAuthorities,
            L"",
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_SYSTEM,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_LOCAL_SYSTEM_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapLocalSystemSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_LOCALSERVICE,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_LOCAL_SERVICE_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapLocalServiceSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_NETWORKSERVICE,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_NETWORK_SERVICE_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapNetworkServiceSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_RESTRICTED,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_RESTRICTED_CODE_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapRestrictedSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_INTERNET,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapInternetDomainIndex,
            &InternetSiteAuthority,
            0,
            SubAuthorities,
            L"",
            SidName.Buffer,
            SidTypeDomain
            )) {

        goto InitializeWellKnownSidsError;
    }

    //
    // Add any security package well known sids
    //

    SubAuthorities[0] = SECURITY_PACKAGE_BASE_RID;
    SubAuthorities[1] = RPC_C_AUTHN_WINNT;
    
    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_NTLM_AUTH,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapNTLMAuthenticationSidIndex,
            &LsapNtAuthority,
            SECURITY_PACKAGE_RID_COUNT,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }  
                                   
    SubAuthorities[1] = RPC_C_AUTHN_DIGEST;
    
    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_DIGEST_AUTH,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapDigestAuthenticationSidIndex,
            &LsapNtAuthority,
            SECURITY_PACKAGE_RID_COUNT,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }  
    
    SubAuthorities[1] = RPC_C_AUTHN_GSS_SCHANNEL;
    
    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_SCHANNEL_AUTH,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapSChannelAuthenticationSidIndex,
            &LsapNtAuthority,
            SECURITY_PACKAGE_RID_COUNT,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }  
                                      
    //
    // Initialize SIDs from the BUILTIN domain.  Leave the Name
    // field blank for the aliases as they can be renamed while
    // the system is running (and the lookup code will fall
    // through to SAM for these).
    //

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_BUILTIN,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_BUILTIN_DOMAIN_RID;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapBuiltInDomainSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            L"",
            SidName.Buffer,
            SidTypeDomain
            )) {

        goto InitializeWellKnownSidsError;
    }

    SubAuthorities[1] = DOMAIN_ALIAS_RID_USERS;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapAliasUsersSidIndex,
            &LsapNtAuthority,
            2,
            SubAuthorities,
            L"",
            SidName.Buffer,
            SidTypeAlias
            )) {

        goto InitializeWellKnownSidsError;
    }

    SubAuthorities[1] = DOMAIN_ALIAS_RID_ADMINS;

    if (!LsapDbInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapAliasAdminsSidIndex,
            &LsapNtAuthority,
            2,
            SubAuthorities,
            L"",
            SidName.Buffer,
            SidTypeAlias
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_USERS,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));


    //
    // Check if all Sids initialized.
    //

#ifdef LSAP_DEBUG_MESSAGE_STRINGS
    DbgPrint("\nLSA (dbinit): Displaying all well known sids...\n\n");
#endif //LSAP_DEBUG_MESSAGE_STRINGS

    for (WellKnownSidIndex = LsapNullSidIndex;
         WellKnownSidIndex < LsapDummyLastSidIndex;
         WellKnownSidIndex++) {

#ifdef LSAP_DEBUG_MESSAGE_STRINGS
    DbgPrint("                *%wZ* : *%wZ*\n",
            &OutputWellKnownSids[WellKnownSidIndex].DomainName,
            &OutputWellKnownSids[WellKnownSidIndex].Name);
#endif //LSAP_DEBUG_MESSAGE_STRINGS

        if (OutputWellKnownSids[WellKnownSidIndex].Sid == NULL) {

#if DBG
            DbgPrint(
                "Well Known Sid Index %d not initialized\n",
                WellKnownSidIndex
                );
#endif //DBG

        }
    }

    *WellKnownSids = OutputWellKnownSids;

    return(TRUE);

InitializeWellKnownSidsError:

    return(FALSE);
}


BOOLEAN
LsapDbInitializeWellKnownSid(
    OUT PLSAP_WELL_KNOWN_SID_ENTRY WellKnownSids,
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex,
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount,
    IN PULONG SubAuthorities,
    IN PWSTR Name,
    IN PWSTR DomainName,
    IN SID_NAME_USE Use
    )

/*++

Routine Description:

    This function initializes an entry in the specified well-known Sid table.
    The entry contains the well known Sid and its name.

Arguments:

    WellKnownSids - Pointer to the first entry in the Well Known Sid table.

    WellKnownSidIndex - Index into table of Well Known Sids.

    Sid - Receives a pointer to a Sid with the correct size for the
       number of subauthorities specified.

    IdentifierAuthority - Pointer to Identifier authority.

    SubAuthorityCount - Count of SubAuthorities

    SubAuthorities - Array of SubAuthorities.

    Name - Pointer to Unicode Name buffer containing the Sid's Name

    DomainName - Pointer to Unicode Name buffer containing the
        Sids Domain Name (if any) or descriptive text, such as
        "Well Known Group" for Sids of Well Known Groups

    SidNameUse - Specifies code for Sid's Use.  The following values
        may be specified:

        SidTypeUser
        SidTypeGroup
        SidTypeDomain
        SidTypeAlias
        SidTypeWellKnownGroup
        SidTypeDeletedAccount
        SidTypeInvalid
        SidTypeUnknown

Return Value:

    BOOLEAN - TRUE if Sid initialized, else FALSE.

--*/

{
    PLSAP_WELL_KNOWN_SID_ENTRY
        WellKnownSidEntry = &WellKnownSids[WellKnownSidIndex];

    PSID OutputSid = NULL;

    OutputSid = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    RtlLengthRequiredSid(SubAuthorityCount)
                    );

    if (OutputSid == NULL) {

        goto InitializeWellKnownSidError;
    }

    RtlInitializeSid( OutputSid, IdentifierAuthority, SubAuthorityCount);

    if (SubAuthorityCount != 0) {

        RtlCopyMemory(
            RtlSubAuthoritySid( OutputSid, 0 ),
            SubAuthorities,
            SubAuthorityCount * sizeof(ULONG)
            );
    }

    WellKnownSidEntry->Sid = OutputSid;

    //
    // Fill in the Domain Name
    //

    RtlInitUnicodeString(
        &WellKnownSidEntry->DomainName,
        DomainName
        );

    //
    // Fill in the Use and Name.
    //

    WellKnownSidEntry->Use = Use;
    RtlInitUnicodeString(
        &WellKnownSidEntry->Name,
        Name
        );

    return(TRUE);

InitializeWellKnownSidError:

#if DBG

    DbgPrint("LSA Initialization of Well Known Sids Failed\n");
    DbgPrint("Insufficient memory resources\n");

#endif // DBG

    return(FALSE);
}


NTSTATUS
LsapGetMessageStrings(
    LPVOID              Resource,
    DWORD               Index1,
    PUNICODE_STRING     String1,
    DWORD               Index2,
    PUNICODE_STRING     String2 OPTIONAL
    )

/*++

Routine Description:

    This gets 1 or 2 message strings values from a resource message table.
    The string buffers are allocated and the strings initialized properly.

    The strings will be NULL terminated.

    The string buffers must be freed using LocalFree() when no longer needed.

Arguments:

    Resource - points to the resource table.

    Index1 - Index of first message to retrieve.

    String1 - Points to a UNICODE_STRING structure to receive the first
        message string.  The string will be null terminated.

    Index2 - Index of second message to retrieve.

    String2 - Points to a UNICODE_STRING structure to receive the first
        message string.  If this parameter is NULL, then only one message
        string is retrieved.  The string will be null terminated.

Return Value:

    None.

--*/

{

#ifdef LSAP_DEBUG_MESSAGE_STRINGS
    DbgPrint("LSA (dbinit): String 1 -\n");
    DbgPrint("                           Index: 0x%lx\n", Index1);
#endif //LSAP_DEBUG_MESSAGE_STRINGS


    String1->Buffer    = NULL;

    String1->MaximumLength = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                          FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                          Resource,
                                          Index1,
                                          0,                 // Use caller's language
                                          (LPWSTR)&(String1->Buffer),
                                          0,
                                          NULL
                                          );

    if (String1->Buffer == NULL) {
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    } else {

        //
        // Note that we are retrieving a message from a message file.
        // This message will have a cr/lf tacked on the end of it
        // (0x0d 0x0a) that we don't want to be part of our returned
        // strings.  However, we do need to null terminate our string
        // so we will convert the 0x0d into a null terminator.
        //
        // Also note that FormatMessage() returns a character count,
        // not a byte count.  So, we have to do some adjusting to make
        // the string lengths correct.
        //

        ASSERT(String1->MaximumLength >= 2);    // We always expect cr/lf on our strings

        //
        // Adjust character count
        //

        String1->MaximumLength -=  1; // For the lf - we'll convert the cr.

        //
        // Set null terminator
        //

        String1->Buffer[String1->MaximumLength - 1] = 0;

        //
        // Change lengths to byte count instead of character count
        //

        String1->MaximumLength *=  sizeof(WCHAR);  // to make it a byte count
        String1->Length = String1->MaximumLength - sizeof(WCHAR);

#ifdef LSAP_DEBUG_MESSAGE_STRINGS
    DbgPrint("                          String: %wZ\n", String1);
    DbgPrint("                             Max: (0x%lx)\n", String1->MaximumLength);
    DbgPrint("                             Cur: (0x%lx)\n", String1->Length);
    DbgPrint("                             ");
    {
        ULONG i;
        for (i=0; i<String1->MaximumLength; i++) {
            DbgPrint("%2x ", (*((PUCHAR)String1->Buffer)+i));
        }
        DbgPrint("\n");
    }
#endif //LSAP_DEBUG_MESSAGE_STRINGS
    }


    if (!ARGUMENT_PRESENT(String2)) {
        return(STATUS_SUCCESS);
    }

    String2->Buffer = NULL;
    String2->MaximumLength = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                          FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                          Resource,
                                          Index2,
                                          0,                 // Use caller's language
                                          (LPWSTR)&(String2->Buffer),
                                          0,
                                          NULL
                                          );

    if (String2->Buffer == NULL) {
        LocalFree( String1->Buffer );
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    } else {

        //
        // Note that we are retrieving a message from a message file.
        // This message will have a cr/lf tacked on the end of it
        // (0x0d 0x0a) that we don't want to be part of our returned
        // strings.  However, we do need to null terminate our string
        // so we will convert the 0x0d into a null terminator.
        //
        // Also note that FormatMessage() returns a character count,
        // not a byte count.  So, we have to do some adjusting to make
        // the string lengths correct.
        //

        ASSERT(String2->MaximumLength >= 2);    // We always expect cr/lf on our strings

        //
        // Adjust character count
        //

        String2->MaximumLength -=  1; // For the lf - we'll convert the cr.

        //
        // Set null terminator
        //

        String2->Buffer[String2->MaximumLength - 1] = 0;

        //
        // Change lengths to byte count instead of character count
        //

        String2->MaximumLength *=  sizeof(WCHAR);  // to make it a byte count
        String2->Length = String2->MaximumLength - sizeof(WCHAR);

#ifdef LSAP_DEBUG_MESSAGE_STRINGS
    DbgPrint("                          String: %wZ\n", String2);
    DbgPrint("                             Max: (0x%lx)\n", String2->MaximumLength);
    DbgPrint("                             Cur: (0x%lx)\n", String2->Length);
    DbgPrint("                             ");
    {
        ULONG i;
        for (i=0; i<String2->MaximumLength; i++) {
            DbgPrint("%2x ", (*((PUCHAR)String2->Buffer)+i));
        }
        DbgPrint("\n");
    }
#endif //LSAP_DEBUG_MESSAGE_STRINGS
    }

    return(STATUS_SUCCESS);
}


#if defined(REMOTE_BOOT)
VOID
LsapDbInitializeRemoteBootState(
    )

/*++

Routine Description:

    This function initializes the remote boot state used by LSA.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status ;
    HANDLE RdrDevice ;
    UNICODE_STRING String ;
    OBJECT_ATTRIBUTES ObjA ;
    IO_STATUS_BLOCK IoStatus ;

    //
    // This is the default if anything goes wrong.
    //

    LsapDbState.RemoteBootState = LSAP_DB_REMOTE_BOOT_NO_NOTIFICATION;

    //
    // Open the redirector device.
    //

    RtlInitUnicodeString( &String, DD_NFS_DEVICE_NAME_U );

    InitializeObjectAttributes( &ObjA,
                                &String,
                                0,
                                0,
                                0);

    Status = NtOpenFile( &RdrDevice,
                         GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                         &ObjA,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         0 );

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_TRACE, "FAILED to open %ws, status %x\n",
                        String.Buffer, Status ));
        return;
    }

    Status = NtFsControlFile(
                    RdrDevice,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    FSCTL_LMMR_RI_IS_PASSWORD_SETTABLE,
                    NULL,
                    0,
                    NULL,
                    0 );

    if ( Status == STATUS_SUCCESS )
    {
        LsapDbState.RemoteBootState = LSAP_DB_REMOTE_BOOT_NOTIFY;
    }
    else if ( Status == STATUS_UNSUCCESSFUL )
    {
        LsapDbState.RemoteBootState = LSAP_DB_REMOTE_BOOT_CANT_NOTIFY;
    }

    NtClose(RdrDevice);

}
#endif // defined(REMOTE_BOOT)




NTSTATUS
LsapGenerateRandomDomainSid(
    OUT PSID NewDomainSid
    )
/*++

Routine Description:

    This function will generate a random sid to be used for the new account domain sid during
    setup.

Arguments:

    NewDomainSid - Where the new domain sid is returned.  Freed via RtlFreeSid()


Return Values:

    STATUS_SUCCESS -- Success.
    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    ULONG SubAuth1, SubAuth2, SubAuth3;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;


    if(!RtlGenRandom( &SubAuth1, sizeof(SubAuth1) ))
    {
        ASSERT( NT_SUCCESS(Status) );
        return Status;
    }

    if(!RtlGenRandom( &SubAuth2, sizeof(SubAuth2) ))
    {
        ASSERT( NT_SUCCESS(Status) );
        return Status;
    }

    if(!RtlGenRandom( &SubAuth3, sizeof(SubAuth3) ))
    {
        ASSERT( NT_SUCCESS(Status) );
        return Status;
    }

    Status = RtlAllocateAndInitializeSid( &IdentifierAuthority,
                                          4,
                                          0x15,
                                          SubAuth1,
                                          SubAuth2,
                                          SubAuth3,
                                          0,
                                          0,
                                          0,
                                          0,
                                          NewDomainSid );

    return( Status );
}


NTSTATUS
LsapSetupInitialize(
    VOID
    )
/*++

Routine Description:

    This function will generate a random sid to be used for the new account domain sid during
    setup.

Arguments:

    NewDomainSid - Where the new domain sid is returned.  Freed via RtlFreeSid()


Return Values:

    STATUS_SUCCESS -- Success.
    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSID NewDomainSid = NULL;
    HMODULE StringsResource;
    LSAPR_POLICY_ACCOUNT_DOM_INFO AccountDomainInfo;

    Status = LsapGenerateRandomDomainSid( &NewDomainSid );

    if ( NT_SUCCESS( Status ) ) {

        //
        // We can use GetModuleHandle, since we are getting it on ourselves.
        //
        StringsResource = (HMODULE) GetModuleHandle( L"LSASRV.DLL" );

        ASSERT( StringsResource );

        Status = LsapGetMessageStrings( StringsResource,
                                        LSAP_DEFAULT_DOMAIN_NAME,
                                        ( PUNICODE_STRING )&AccountDomainInfo.DomainName,
                                        0,
                                        NULL );
    }

    //
    // Ok, if  we got this far, then we can initialize the account domain
    //
    if ( NT_SUCCESS( Status ) ) {

        AccountDomainInfo.DomainSid = NewDomainSid;
        Status = LsarSetInformationPolicy( LsapPolicyHandle,
                                           PolicyAccountDomainInformation,
                                           ( PLSAPR_POLICY_INFORMATION )&AccountDomainInfo );

        LocalFree( AccountDomainInfo.DomainName.Buffer );
    }

    if ( NewDomainSid ) {

        RtlFreeSid( NewDomainSid );
    }

    return( Status );
}

static GUID LsapDbPasswordAuthenticator = {0xf0ce3a80,0x155f,0x11d3,0xb7,0xe6,0x00,0x80,0x5f,0x48,0xca,0xeb};

NTSTATUS
LsapDbGenerateNewKey(
    IN LSAP_DB_ENCRYPTION_KEY * NewEncryptionKey
    )
/*++

  Routine Description

    This routine generates a new Encryption key that can be used for
    encrypting secrets.

  Parameters

    NewEncryptionKey -- Pointer to a structure that contains the new key

  Return Values

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;


    //
    // generate a random number for the key
    //

    if (!RtlGenRandom(NewEncryptionKey->Key,sizeof(NewEncryptionKey->Key)))
    {
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Copy in the GUID for the authenticator
    //

    NewEncryptionKey->Authenticator = LsapDbPasswordAuthenticator;

    //
    // Set the version #
    //

    NewEncryptionKey->Revision = LSAP_DB_ENCRYPTION_KEY_VERSION ;
    NewEncryptionKey->Flags = 0;

    //
    // Generate a Salt
    //

    if (!RtlGenRandom(NewEncryptionKey->Salt,sizeof(NewEncryptionKey->Salt)))
    {
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Generate a random value for the old syskey
    //

    if (!RtlGenRandom(NewEncryptionKey->OldSyskey,sizeof(NewEncryptionKey->OldSyskey)))
    {
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Set the boot type
    //

    NewEncryptionKey->BootType = WxStored;

    return(STATUS_SUCCESS);
}

VOID
LsapDbEncryptKeyWithSyskey(
    OUT LSAP_DB_ENCRYPTION_KEY * KeyToEncrypt,
    IN PVOID                    Syskey,
    IN ULONG                    SyskeyLength
    )
/*++

  This routine encrypts the KeyToEncrypt parameter with
  the syskey passed in

  Arguments

    KeyToEncrypt -- the key to encrypt
    Syskey       -- The syskey passed in
    SyskeyLength -- The length of the syskey

  Return Values

    None, void function
--*/
{
    MD5_CTX Md5Context;
    struct RC4_KEYSTRUCT Rc4Key;
    ULONG  i;

    //
    // Create an MD5 hash of the key and salt
    //

    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        Syskey,
        SyskeyLength
        );

    //
    // Hash in the salt many many times. This slows down
    // attackers employing a brute force approach to attack
    //

    for (i=0;i<1000;i++)
    {
        MD5Update(
            &Md5Context,
            KeyToEncrypt->Salt,
            sizeof(KeyToEncrypt->Salt)
            );
    }

    MD5Final(
        &Md5Context
        );

    //
    // Initialize the RC4 key sequence.
    //

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );

    rc4(
        &Rc4Key,
        sizeof(KeyToEncrypt->Key)+ sizeof(KeyToEncrypt->Authenticator)+sizeof(KeyToEncrypt->OldSyskey),
        (PUCHAR) &KeyToEncrypt->Authenticator
        );
}


NTSTATUS
LsapDbDecryptKeyWithSyskey(
    IN LSAP_DB_ENCRYPTION_KEY * KeyToDecrypt,
    IN PVOID                    Syskey,
    IN ULONG                    SyskeyLength
    )
/*++

  This function provides a decryption using the syskey. Since RC4 is symmetric
  encryption algorithm, this function simply calls the previous encrypt routine

   Arguments

    KeyToDecrypt -- the key to dencrypt
    Syskey       -- The syskey passed in
    SyskeyLength -- The length of the syskey

  Return Values

    STATUS_SUCCESS , on successful decryption
    STATUS_WRONG_PASSWORD on unsuccessful decryption

--*/
{
    LsapDbEncryptKeyWithSyskey(KeyToDecrypt,Syskey,SyskeyLength);

    if (!RtlEqualMemory(&KeyToDecrypt->Authenticator,&LsapDbPasswordAuthenticator,sizeof(GUID)))
    {
        return(STATUS_WRONG_PASSWORD);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
LsapDbSetupInitialSyskey(
    OUT PULONG  SyskeyLength,
    OUT PVOID   *Syskey
    )
/*++

    This generates a new syskey and changes the winlogon state such that
    winlogon recognizes the new syskey and the boot option of system saves
    syskey.

    Arguments

        SyskeyLength -- The length of the syskey is returned in here
        Syskey       -- The syskey itself is returned in here

    Return Values

        STATUS_SUCCESS
        Other resource error codes
--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;

    *Syskey = LsapAllocateLsaHeap(LSAP_SYSKEY_SIZE );
    if (NULL==*Syskey)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    *SyskeyLength = LSAP_SYSKEY_SIZE;

    //
    // Generate the syskey
    //

    if (!RtlGenRandom( *Syskey, *SyskeyLength))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Save the syskey in the registry
    // If this operation fails, then no state is changed, machine remains
    // un syskey-d till next boot
    //

    NtStatus = WxSaveSysKey(*SyskeyLength, *Syskey);

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Set the boot option in the registry
    // If this operation fails, still no problem. Machine remains unsyskey'd
    // and the boot key that has been saved will be reset on next boot.
    //

    NtStatus = WxSaveBootOption(WxStored);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

Error:

    if (!NT_SUCCESS(NtStatus))
    {
        *SyskeyLength = 0;
        if (NULL!=*Syskey)
        {
            MIDL_user_free(*Syskey);
        }
    }

    return(NtStatus);
}


NTSTATUS
LsapDbGetSyskeyFromWinlogon()
/*++

    Routine Description

        This routine obtains the syskey from winlogon and decrypts the
        Password encryption key in the LSA policy database. The global variable
        LsapDbSecretCipherKey is set with the password encryption key and the
        the global variable LsapDbSyskey is set with the syskey. This value is
        then queried by SAM/DS to decrypt their respective password encryption keys
        and then cleared before the end of SamIInitialize.

        The special case handled inside this routine is of the case of a fresh install.
        In this particular case winlogon is not yet setup to expect a query of syskey
        from the lsass process. However since the LSA install code has been called just
        moments, before, that code sets the winlogon state and also fills the global
        LsapDbSyskey. Therefore if LsapDbSyskey is not NULL then this would be the
        fresh install case.

    Arguments

        None

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL

 --*/
{
    NTSTATUS       Status = STATUS_SUCCESS;
    NTSTATUS       DecryptStatus = STATUS_SUCCESS;
    ULONG          DecryptionKeyLength = 0;
    HANDLE         WinlogonHandle=NULL;
    ULONG          Tries = 0;
    LSAP_DB_ENCRYPTION_KEY  StoredEncryptionKeyData;
    ULONG          StoredEncryptionKeyDataLength = sizeof( LSAP_DB_ENCRYPTION_KEY );
    ULONG          SyskeyLen=LSAP_SYSKEY_SIZE;
    BOOLEAN        FreshInstall=FALSE;

    //
    // Read the attribute information in the LSA policy database
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[PolSecretEncryptionKey],
                 (PVOID) &StoredEncryptionKeyData,
                 &StoredEncryptionKeyDataLength
                 );

    if ( !NT_SUCCESS(Status) ) {
       goto Cleanup;
    }

    if (NULL!=LsapDbSysKey)
    {
        //
        // In the fresh install case , code in dbinstal.c already
        // sets LsapDbSyskey to the syskey value.
        //

        FreshInstall = TRUE;
        Status = LsapDbDecryptKeyWithSyskey(
                            &StoredEncryptionKeyData ,
                            LsapDbSysKey,
                            LSAP_SYSKEY_SIZE
                            );
    }
    else
    {
        //
        // because LsapDbDecryptKeyWithSyskey() is an in-place
        // operation, so we'd better save the Encrypted Syskey first
        //

        LSAP_DB_ENCRYPTION_KEY  TempStoredEncryptionKeyData;

        TempStoredEncryptionKeyData = StoredEncryptionKeyData;

        //
        // Call Winlogon to obtain the key information.
        //

        Status = WxConnect(
                    &WinlogonHandle
                    );

        if (!NT_SUCCESS(Status))
        {
            //
            // Winlogon may fail if secret encryption is not enabled. In those
            // cases continue. Else Fail the boot
            //
      