ndows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
#include "mspnutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mtexfilt.h ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void TexFiltBilinear(D3DCOLOR *pOut, INT32 iUFrac, INT32 iVFrac, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\sources.inc ===
TARGETNAME = rcmxspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        $O\matest.cpp\
        $O\mbeadtbl.cpp\
        ..\mbldfncs.cpp\
        ..\mbufread.cpp\
        ..\mbufwrt.cpp\
        $O\mclrbld.cpp\
        $O\mclrgen.cpp\
        $O\mloop.cpp\
        ..\mspnpars.cpp\
        ..\mspnutil.cpp\
        $O\mtest.cpp\
        $O\mtx1addr.cpp\
        $O\mtx2addr.cpp\
        $O\mtxblend.cpp\
        ..\mtexfilt.cpp\
        $O\mtexread.cpp\
        $O\mtstfail.cpp

NTTARGETFILE0 = \
        $O\matest_mh.h\
        $O\mcrbd_mh.h\
        $O\mcrgn_mh.h\
        $O\mtest_mh.h\
        $O\mtx1a_mh.h\
        $O\mtx2a_mh.h\
        $O\mtxbd_mh.h\
        $O\mtxrd_mh.h\
        $O\mtstf_mh.h\
        $O\mbeadtbl.cpp\
        $O\mclrbld.cpp\
        $O\mclrgen.cpp\
        $O\mloop.cpp\
        $O\mtest.cpp\
        $O\mtx1addr.cpp\
        $O\mtx2addr.cpp\
        $O\mtxblend.cpp\
        $O\mtexread.cpp\
        $O\matest.cpp\
        $O\mtstfail.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cbufwrt.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void C_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cbldfncs.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "cbldfncs.h"

//-----------------------------------------------------------------------------
//
// SrcBlendZero
//
// (0, 0, 0, 0) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// SrcBlendOne
//
// (1, 1, 1, 1) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = pCtx->SI.uBR;
    *pG = pCtx->SI.uBG;
    *pB = pCtx->SI.uBB;
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcColor
//
// (Rs, Gs, Bs, As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*(pCtx->SI.uBR>>8);
    *pG = (pCtx->SI.uBG>>8)*(pCtx->SI.uBG>>8);
    *pB = (pCtx->SI.uBB>>8)*(pCtx->SI.uBB>>8);
    *pA = (pCtx->SI.uBA>>8)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*(pCtx->SI.uBR>>8);
    *pG = (0xff - (pCtx->SI.uBG>>8))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (pCtx->SI.uBB>>8))*(pCtx->SI.uBB>>8);
    *pA = (0xff - (pCtx->SI.uBA>>8))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlpha
//
// (As, As, As, As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (UINT16)RGBA_GETRED(DestC)  *(pCtx->SI.uBR>>8);
    *pG = (UINT16)RGBA_GETGREEN(DestC)*(pCtx->SI.uBG>>8);
    *pB = (UINT16)RGBA_GETBLUE(DestC) *(pCtx->SI.uBB>>8);
    *pA = (UINT16)RGBA_GETALPHA(DestC)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*(pCtx->SI.uBR>>8);
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*(pCtx->SI.uBB>>8);
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlphaSat
//
// f = min(as, 1-Ad); (f, f, f, 1) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// DestBlendZero
//
// (0, 0, 0, 0) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// DestBlendOne
//
// (1, 1, 1, 1) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  <<8);
    *pG = ((UINT16)RGBA_GETGREEN(DestC)<<8);
    *pB = ((UINT16)RGBA_GETBLUE(DestC) <<8);
    *pA = ((UINT16)RGBA_GETALPHA(DestC)<<8);
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcColor
//
// (Rs, Gs, Bs, As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (pCtx->SI.uBG>>8)*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (pCtx->SI.uBB>>8)*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (pCtx->SI.uBA>>8)*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (pCtx->SI.uBG>>8))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (pCtx->SI.uBB>>8))*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (pCtx->SI.uBA>>8))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlpha
//
// (As, As, As, As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = ((UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = ((UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = ((UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlphaSat
//
// f = min(As, 1-Ad); (f, f, f, 1) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (UINT16)RGBA_GETALPHA(DestC)<<8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cbufread.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color reading routines for Blending.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "cbufread.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

//-----------------------------------------------------------------------------
//
// Read_B8G8R8
//
// Reads output buffer in BGR-888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8(PUINT8 pBits)
{
    return (*pBits | (*(pBits+1))<<8 | (*(pBits+2))<<16 | 0xff000000);
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8X8
//
// Reads output buffer in BGR-888x8 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8X8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface | 0xff000000;
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8A8
//
// Reads output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8A8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface;
}

//-----------------------------------------------------------------------------
//
// Read_B5G6R5
//
// Reads output in BGR-565 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G6R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 8 ) & 0xf8,
                (( uPixel >> 3) & 0xfc ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5
//
// Reads output in BGR-555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G5R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 7 ) & 0xf8,
                (( uPixel >> 2) & 0xf8 ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5A1
//
// Reads output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G5R5A1(PUINT8 pBits)
{
    INT16 iPixel = *(PINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( iPixel >> 7 ) & 0xf8,
                (( iPixel >> 2) & 0xf8 ),
                (( iPixel << 3) & 0xf8 ),
                (iPixel >> 15) & 0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_Palette8
//
// Reads output in Palette8 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_Palette8(PUINT8 pBits)
{
    // ATTENTION - This is not correct. But We assume Palette8 format will
    // normally not be used for alpha blending.
    return (D3DCOLOR)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cbldfncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void C_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void C_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cloop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void C_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cbufwrt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color writing routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "cbufwrt.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

extern UINT16 g_uDitherTable[16];
//-----------------------------------------------------------------------------
//
// Write_B8G8R8X8_NoDither
//
// Writes output in BGR-888 format, aligned to 32 bits.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, 0x00);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8A8_NoDither
//
// Writes output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, pCtx->SI.uBA>>8);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_NoDither
//
// Writes output in BGR-565 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  0) & 0xf800) |
        ((pCtx->SI.uBG >>  5) & 0x07e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_Dither
//
// Writes output in BGR-565 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 2;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x3f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 11);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_NoDither
//
// Writes output in BGR-555 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_Dither
//
// Writes output in BGR-555 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_NoDither
//
// Writes output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f) |
        ((pCtx->SI.uBA >>  0) & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_Dither
//
// Writes output in BGRA-1555 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10) | (pCtx->SI.uBA & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8_NoDither
//
// Writes output in BGR-888 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    PUINT8 pSurface = (PUINT8)pS->pSurface;
    *pSurface++ = pCtx->SI.uBB>>8;
    *pSurface++ = pCtx->SI.uBG>>8;
    *pSurface++ = pCtx->SI.uBR>>8;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_Palette8_NoDither
//
// Writes output to the RGB8 palette format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uMapIdx = MAKE_RGB8(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8, pCtx->SI.uBB>>8);

    *(PUINT8)pS->pSurface = (UINT8)(pCtx->pRampMap[uMapIdx]);

    // just returns for C, since we really can't loop with function calls
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\ctexfilt.h ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void TexFiltBilinear(D3DCOLOR *pOut, INT32 iUFrac, INT32 iVFrac, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cbufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR C_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR C_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR C_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR C_BufRead_Palette8(PUINT8 pBits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cspnutil.cpp ===
//----------------------------------------------------------------------------
//
// cspnutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cspnpars.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// C_RenderSpansAny
//
// All mode general span routine.
//
//-----------------------------------------------------------------------------
HRESULT C_RenderSpansAny(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            pCtx->pfnBegin(pCtx, pP, pS);

            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cspnpars.h ===
//----------------------------------------------------------------------------
//
// cspnpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

HRESULT C_RenderSpansAny(PD3DI_RASTCTX pCtx);

#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cspnutil.h ===
//----------------------------------------------------------------------------
//
// cspnutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

//-----------------------------------------------------------------------------
//
// imul32h_s20
//
// Returns (x*y)>>20
//
//-----------------------------------------------------------------------------
inline INT32 imul32h_s20(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        shrd eax, edx, 20
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 20);
#endif
}


#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
#include "cspnutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\ctexfilt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "ctexfilt.h"

//-----------------------------------------------------------------------------
//
// TexFiltBilinear
//
// Given the basic bilinear equations
//
// A = C00 + U*(C10 - C00)
// B = C01 + U*(C11 - C01)
// C = A + V*(B-A)
//
// This routine is based on the re-arrangement of this equation into
//
// C = C00*(1-U-V+U*V) + C10*(U-U*V) + C10(V-U*V) + C11*(U*V)
// or
// C = C00*s1 + C10*s2 + C10*s3 + C11*s4
//
//-----------------------------------------------------------------------------
void TexFiltBilinear(D3DCOLOR *pOut, INT32 iU, INT32 iV, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11)
{
#define SIMPLE_BILINEAR 1
#ifdef SIMPLE_BILINEAR
    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    r00 = r00 + ((iU*(r10 - r00)) >> 16);
    g00 = g00 + ((iU*(g10 - g00)) >> 16);
    b00 = b00 + ((iU*(b10 - b00)) >> 16);
    a00 = a00 + ((iU*(a10 - a00)) >> 16);

    r01 = r01 + ((iU*(r11 - r01)) >> 16);
    g01 = g01 + ((iU*(g11 - g01)) >> 16);
    b01 = b01 + ((iU*(b11 - b01)) >> 16);
    a01 = a01 + ((iU*(a11 - a01)) >> 16);

    r00 = r00 + ((iV*(r01 - r00)) >> 16);
    g00 = g00 + ((iV*(g01 - g00)) >> 16);
    b00 = b00 + ((iV*(b01 - b00)) >> 16);
    a00 = a00 + ((iV*(a01 - a00)) >> 16);

#else
    // another potential implementation
    INT32 s1, s2, s3, s4;
    s4 = (iU * iV)>>16;         // (0.16 * 0.16) >> 16 = 0.16
    s3 = iV - s4;
    s2 = iU - s4;
    s1 = 0x10000 - iV - s2;

    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    // 8.0 * 0.16 == 8.16 >> 16 == 8.0
    r00 = (r00*s1 + r10*s2 + r01*s3 + r11*s4)>>16;
    g00 = (g00*s1 + g10*s2 + g01*s3 + g11*s4)>>16;
    b00 = (b00*s1 + b10*s2 + b01*s3 + b11*s4)>>16;
    a00 = (a00*s1 + a10*s2 + a01*s3 + a11*s4)>>16;
#endif

    *pOut = RGBA_MAKE(r00, g00, b00, a00);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\makefile.inc ===
$(GENTGT)\ccrbd_mh.h: ..\ccrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ccrgn_mh.h: ..\ccrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctest_mh.h: ..\ctest_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctx1a_mh.h: ..\ctx1a_mh.mh ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctx2a_mh.h: ..\ctx2a_mh.mh ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctxbd_mh.h: ..\ctxbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctxrd_mh.h: ..\ctxrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctstf_mh.h: ..\ctstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\catest_mh.h: ..\catest_mh.mh $(RAST_STD_M4)

$(GENTGT)\cbeadtbl.cpp: ..\cbeadtbl.mcp $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\cclrbld.cpp: ..\cclrbld.mcp $(RAST_STD_M4)

$(GENTGT)\cclrgen.cpp: ..\cclrgen.mcp $(RAST_STD_M4)

$(GENTGT)\cloop.cpp: ..\cloop.mcp ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctest.cpp: ..\ctest.mcp $(RAST_STD_M4)

$(GENTGT)\ctx1addr.cpp: ..\ctx1addr.mcp ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctx2addr.cpp: ..\ctx2addr.mcp ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctxblend.cpp: ..\ctxblend.mcp $(RAST_STD_M4)

$(GENTGT)\ctexread.cpp: ..\ctexread.mcp $(RAST_STD_M4)

$(GENTGT)\catest.cpp: ..\catest.mcp $(RAST_STD_M4)

$(GENTGT)\ctstfail.cpp: ..\ctstfail.mcp ..\ctexaddr.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\makefile.inc ===
$(GENTGT)\pmfns_mh.h: ..\pmfns_mh.mh $(RAST_STD_M4)

$(GENTGT)\pmfns.cpp: ..\pmfns.mcp $(RAST_STD_M4)

$(GENTGT)\dprim2.cpp: ..\dprim2.mcp $(RAST_STD_M4)

$(GENTGT)\refif.cpp: ..\refif.mcp $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\getcaps.h ===
//----------------------------------------------------------------------------
//
// getcaps.h
//
// Legacy caps as pulled from mustard\direct3d\d3d\ddraw\getcaps.c
//
// This file is included from swprov.cpp with BUILD_RAMP set and not set,
// to pick up exactly the caps reported by the software rasterizers in DX5.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#define	MAX_CLIPPING_PLANES	12

/* Space for vertices generated/copied while clipping one triangle */

#define MAX_CLIP_VERTICES	(( 2 * MAX_CLIPPING_PLANES ) + 3 )

#define MAX_VERTEX_COUNT 2048
#define BASE_VERTEX_COUNT (MAX_VERTEX_COUNT - MAX_CLIP_VERTICES)

#define transformCaps { sizeof(D3DTRANSFORMCAPS), D3DTRANSFORMCAPS_CLIP }

#ifdef BUILD_RAMP
#define THIS_MODEL D3DLIGHTINGMODEL_MONO
#define THIS_COLOR_MODEL D3DCOLOR_MONO
#else
#define THIS_MODEL D3DLIGHTINGMODEL_RGB
#define THIS_COLOR_MODEL D3DCOLOR_RGB
#endif

#define lightingCaps {							\
    	sizeof(D3DLIGHTINGCAPS),					\
	D3DLIGHTCAPS_POINT |						\
	    D3DLIGHTCAPS_SPOT |						\
	    D3DLIGHTCAPS_DIRECTIONAL |					\
	    D3DLIGHTCAPS_PARALLELPOINT,		 			\
	THIS_MODEL,			/* dwLightingModel */		\
	0,				/* dwNumLights (infinite) */	\
}

/*
 * Software Driver caps
 */
#ifdef BUILD_RAMP
#define TRISHADECAPS					\
    D3DPSHADECAPS_COLORFLATMONO			|	\
	D3DPSHADECAPS_COLORGOURAUDMONO		|	\
	D3DPSHADECAPS_SPECULARFLATMONO		|	\
	D3DPSHADECAPS_SPECULARGOURAUDMONO	|	\
	D3DPSHADECAPS_ALPHAFLATSTIPPLED		|	\
	D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED
#else
#define TRISHADECAPS					\
    D3DPSHADECAPS_COLORFLATRGB			|	\
	D3DPSHADECAPS_COLORGOURAUDRGB		|	\
	D3DPSHADECAPS_SPECULARFLATRGB		|	\
	D3DPSHADECAPS_SPECULARGOURAUDRGB	|	\
	D3DPSHADECAPS_ALPHAFLATSTIPPLED		|	\
	D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED	|	\
	D3DPSHADECAPS_FOGFLAT			|	\
	D3DPSHADECAPS_FOGGOURAUD
#endif

#ifdef BUILD_RAMP
#define TRIFILTERCAPS					   \
    D3DPTFILTERCAPS_NEAREST          | \
    D3DPTFILTERCAPS_MIPNEAREST
#else
#define TRIFILTERCAPS					   \
    D3DPTFILTERCAPS_NEAREST			 |	\
    D3DPTFILTERCAPS_LINEAR           | \
    D3DPTFILTERCAPS_MIPNEAREST		 |	\
    D3DPTFILTERCAPS_MIPLINEAR        | \
    D3DPTFILTERCAPS_LINEARMIPNEAREST
#endif

#ifndef BUILD_RAMP
#define TRIRASTERCAPS					\
    D3DPRASTERCAPS_DITHER			|	\
    	D3DPRASTERCAPS_SUBPIXELX		|	\
	D3DPRASTERCAPS_FOGVERTEX		|	\
	D3DPRASTERCAPS_FOGTABLE		|	\
	D3DPRASTERCAPS_ZTEST
#else
#define TRIRASTERCAPS					\
    D3DPRASTERCAPS_DITHER			|	\
    	D3DPRASTERCAPS_SUBPIXELX		|	\
	D3DPRASTERCAPS_ZTEST
#endif

#define triCaps {					\
    sizeof(D3DPRIMCAPS),				\
    D3DPMISCCAPS_CULLCCW | D3DPMISCCAPS_CULLCW | D3DPMISCCAPS_CULLNONE,	/* miscCaps */		\
    TRIRASTERCAPS,		/* rasterCaps */	\
    D3DPCMPCAPS_NEVER | D3DPCMPCAPS_LESS | D3DPCMPCAPS_EQUAL | D3DPCMPCAPS_LESSEQUAL | D3DPCMPCAPS_GREATER | D3DPCMPCAPS_NOTEQUAL | D3DPCMPCAPS_GREATEREQUAL | D3DPCMPCAPS_ALWAYS,	/* zCmpCaps */		\
    0,				/* sourceBlendCaps */	\
    0,				/* destBlendCaps */	\
    0,				/* alphaBlendCaps */	\
    TRISHADECAPS,		/* shadeCaps */		\
    D3DPTEXTURECAPS_PERSPECTIVE |/* textureCaps */	\
	D3DPTEXTURECAPS_POW2 |				\
	D3DPTEXTURECAPS_TRANSPARENCY,			\
    TRIFILTERCAPS,		/* textureFilterCaps */ \
    D3DPTBLENDCAPS_COPY |	/* textureBlendCaps */	\
	D3DPTBLENDCAPS_MODULATE,			\
    D3DPTADDRESSCAPS_WRAP,	/* textureAddressCaps */\
    4,				/* stippleWidth */	\
    4				/* stippleHeight */	\
}							\

static D3DDEVICEDESC devDesc = {
    sizeof(D3DDEVICEDESC),	/* dwSize */
    D3DDD_COLORMODEL |		/* dwFlags */
	D3DDD_DEVCAPS |
	D3DDD_TRANSFORMCAPS |
	D3DDD_LIGHTINGCAPS |
	D3DDD_BCLIPPING |
	D3DDD_TRICAPS |
	D3DDD_DEVICERENDERBITDEPTH |
	D3DDD_DEVICEZBUFFERBITDEPTH |
	D3DDD_MAXBUFFERSIZE |
	D3DDD_MAXVERTEXCOUNT,
    THIS_COLOR_MODEL,		/* dcmColorModel */
    D3DDEVCAPS_FLOATTLVERTEX |
	D3DDEVCAPS_SORTINCREASINGZ |
	D3DDEVCAPS_SORTEXACT |
	D3DDEVCAPS_EXECUTESYSTEMMEMORY |
	D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY |
        D3DDEVCAPS_DRAWPRIMTLVERTEX,
    transformCaps,		/* transformCaps */
    TRUE,			/* bClipping */
    lightingCaps,		/* lightingCaps */
    triCaps,			/* lineCaps */
    triCaps,			/* triCaps */
    DDBD_8 | DDBD_16 | DDBD_24 | DDBD_32, /* dwDeviceRenderBitDepth */
    DDBD_16,			/* dwDeviceZBufferBitDepth */
    0,				/* dwMaxBufferSize */
    BASE_VERTEX_COUNT		/* dwMaxVertexCount */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\d3dif.cpp ===
//----------------------------------------------------------------------------
//
// d3dif.cpp
//
// shared interface functions
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// FindOutSurfFormat
//
// Converts a DDPIXELFORMAT to D3DI_SPANTEX_FORMAT.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT pDdPixFmt,
                  D3DI_SPANTEX_FORMAT *pFmt)
{
    if (pDdPixFmt->dwFlags & DDPF_ZBUFFER)
    {
        switch(pDdPixFmt->dwZBitMask)
        {
        default:
        case 0x0000FFFF: *pFmt = D3DI_SPTFMT_Z16S0; break;
        case 0xFFFFFF00: *pFmt = D3DI_SPTFMT_Z24S8; break;
        case 0x0000FFFE: *pFmt = D3DI_SPTFMT_Z15S1; break;
        case 0xFFFFFFFF: *pFmt = D3DI_SPTFMT_Z32S0; break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_BUMPDUDV)
    {
        UINT uFmt = pDdPixFmt->dwBumpDvBitMask;
        switch (uFmt)
        {
        case 0x0000ff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 24:
                *pFmt = D3DI_SPTFMT_U8V8L8;
                break;
            case 16:
                *pFmt = D3DI_SPTFMT_U8V8;
                break;
            }
            break;

        case 0x000003e0:
            *pFmt = D3DI_SPTFMT_U5V5L6;
            break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED8)
    {
        *pFmt = D3DI_SPTFMT_PALETTE8;
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED4)
    {
        *pFmt = D3DI_SPTFMT_PALETTE4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y'))
    {
        *pFmt = D3DI_SPTFMT_UYVY;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2'))
    {
        *pFmt = D3DI_SPTFMT_YUY2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '1'))
    {
        *pFmt = D3DI_SPTFMT_DXT1;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '2'))
    {
        *pFmt = D3DI_SPTFMT_DXT2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '3'))
    {
        *pFmt = D3DI_SPTFMT_DXT3;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '4'))
    {
        *pFmt = D3DI_SPTFMT_DXT4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '5'))
    {
        *pFmt = D3DI_SPTFMT_DXT5;
    }
    else
    {
        UINT uFmt = pDdPixFmt->dwGBitMask | pDdPixFmt->dwRBitMask;

        if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
        {
            uFmt |= pDdPixFmt->dwRGBAlphaBitMask;
        }

        switch (uFmt)
        {
        case 0x00ffff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 32:
                *pFmt = D3DI_SPTFMT_B8G8R8X8;
                break;
            case 24:
                *pFmt = D3DI_SPTFMT_B8G8R8;
                break;
            }
            break;
        case 0xffffff00:
            *pFmt = D3DI_SPTFMT_B8G8R8A8;
            break;
        case 0xffe0:
            if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
            {
                *pFmt = D3DI_SPTFMT_B5G5R5A1;
            }
            else
            {
                *pFmt = D3DI_SPTFMT_B5G6R5;
            }
            break;
        case 0x07fe0:
            *pFmt = D3DI_SPTFMT_B5G5R5;
            break;
        case 0xff0:
            *pFmt = D3DI_SPTFMT_B4G4R4;
            break;
        case 0xfff0:
            *pFmt = D3DI_SPTFMT_B4G4R4A4;
            break;
        case 0xff:
            *pFmt = D3DI_SPTFMT_L8;
            break;
        case 0xffff:
            *pFmt = D3DI_SPTFMT_L8A8;
            break;
        case 0xfc:
            *pFmt = D3DI_SPTFMT_B2G3R3;
            break;
        default:
            *pFmt = D3DI_SPTFMT_NULL;
            break;
        }
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// ValidTextureSize
//
// checks for power of two texture size
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidTextureSize(INT16 iuSize, INT16 iuShift,
                 INT16 ivSize, INT16 ivShift)
{
    if (iuSize == 1)
    {
        if (ivSize == 1)
        {
            return TRUE;
        }
        else
        {
            return !(ivSize & (~(1 << ivShift)));
        }
    }
    else
    {
        if (ivSize == 1)
        {
            return !(iuSize & (~(1 << iuShift)));
        }
        else
        {
            return (!(iuSize & (~(1 << iuShift)))
                    && !(iuSize & (~(1 << iuShift))));
        }
    }
}

//----------------------------------------------------------------------------
//
// ValidMipmapSize
//
// Computes size of next smallest mipmap level, clamping at 1
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize)
{
    if (iPreSize == 1)
    {
        if (iSize == 1)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return ((iPreSize >> 1) == iSize);
    }
}


//----------------------------------------------------------------------------
//
// TextureFormats
//
// Returns all the texture formats supported by our rasterizer.
// Right now, it's called at device creation time to fill the driver gloabl
// data.
//
//----------------------------------------------------------------------------

#define NUM_SUPPORTED_TEXTURE_FORMATS   22

int
TextureFormats(LPDDSURFACEDESC* lplpddsd, DWORD dwVersion, SW_RAST_TYPE RastType)
{
    int i = 0;

    if (RastType == SW_RAST_MMX && dwVersion < 3)
    {
        static DDSURFACEDESC mmx_ddsd[1];

        /* pal8 */
        mmx_ddsd[i].dwSize = sizeof(mmx_ddsd[0]);
        mmx_ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        mmx_ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        mmx_ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        mmx_ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
        mmx_ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;

        i++;

        *lplpddsd = mmx_ddsd;

        return i;
    }

    static DDSURFACEDESC ddsd_RefNull_Dev3[NUM_SUPPORTED_TEXTURE_FORMATS];
    static DDSURFACEDESC ddsd_RefNull_Dev2[NUM_SUPPORTED_TEXTURE_FORMATS];
    static DDSURFACEDESC ddsd_RGBMMX_Dev3[NUM_SUPPORTED_TEXTURE_FORMATS];
    static DDSURFACEDESC ddsd_RGBMMX_Dev2[NUM_SUPPORTED_TEXTURE_FORMATS];
    DDSURFACEDESC *ddsd;

    if (RastType == SW_RAST_REFNULL)
    {
        if (dwVersion >= 3)
        {
            ddsd = ddsd_RefNull_Dev3;
        }
        else
        {
            ddsd = ddsd_RefNull_Dev2;
        }
    }
    else
    {
        if (dwVersion >= 3)
        {
            ddsd = ddsd_RGBMMX_Dev3;
        }
        else
        {
            ddsd = ddsd_RGBMMX_Dev2;
        }
    }

    /* 888 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;

    i++;

    /* 8888 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;

    i++;

    /* 565 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xf800;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x07e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    /* 555 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0x7c00;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x03e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    /* pal4 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED4 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 4;

    i++;

    /* pal8 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;

    i++;

    if ((dwVersion >= 3) || (RastType == SW_RAST_REFNULL))
    {
        /* 1555 */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0x8000;
        ddsd[i].ddpfPixelFormat.dwRBitMask = 0x7c00;
        ddsd[i].ddpfPixelFormat.dwGBitMask = 0x03e0;
        ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

        i++;

        // A formats for PC98 consistency
        // 4444 ARGB (it is already supported by S3 Virge)
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xf000;
        ddsd[i].ddpfPixelFormat.dwRBitMask        = 0x0f00;
        ddsd[i].ddpfPixelFormat.dwGBitMask        = 0x00f0;
        ddsd[i].ddpfPixelFormat.dwBBitMask        = 0x000f;

        i++;
    }

    if ((dwVersion >= 2) && (RastType == SW_RAST_REFNULL))
    {
        // 332 8-bit RGB
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwRBitMask = 0xe0;
        ddsd[i].ddpfPixelFormat.dwGBitMask = 0x1c;
        ddsd[i].ddpfPixelFormat.dwBBitMask = 0x03;

        i++;
    }

    if (dwVersion >= 3)
    {
        /* 8 bit luminance-only */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0xff;

        i++;

        /* 16 bit alpha-luminance */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff00;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0xff;

        i++;

        if (RastType == SW_RAST_REFNULL)
        {
            // A couple of formats for PC98 consistency
            // UYVY
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('U', 'Y', 'V', 'Y');

            i++;

            // YVY2
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('Y', 'U', 'Y', '2');

            i++;

            // S3 compressed texture format 1
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '1');

            i++;

            // S3 compressed texture format 2
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '2');

            i++;

            // S3 compressed texture format 3
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '3');

            i++;

            // S3 compressed texture format 4
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '4');

            i++;

            // S3 compressed texture format 5
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '5');

            i++;

            // Add a few bump map formats
            // U8V8
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_BUMPDUDV;
            ddsd[i].ddpfPixelFormat.dwBumpBitCount = 16;
            ddsd[i].ddpfPixelFormat.dwBumpDuBitMask = 0x00ff;
            ddsd[i].ddpfPixelFormat.dwBumpDvBitMask = 0xff00;
            ddsd[i].ddpfPixelFormat.dwBumpLuminanceBitMask = 0x0;

            i++;

            // U5V5L6
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_BUMPDUDV |
                                              DDPF_BUMPLUMINANCE;
            ddsd[i].ddpfPixelFormat.dwBumpBitCount = 16;
            ddsd[i].ddpfPixelFormat.dwBumpDuBitMask = 0x001f;
            ddsd[i].ddpfPixelFormat.dwBumpDvBitMask = 0x03e0;
            ddsd[i].ddpfPixelFormat.dwBumpLuminanceBitMask = 0xfc00;

            i++;

            // U8V8L8
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_BUMPDUDV |
                                              DDPF_BUMPLUMINANCE;
            ddsd[i].ddpfPixelFormat.dwBumpBitCount = 24;
            ddsd[i].ddpfPixelFormat.dwBumpDuBitMask = 0x0000ff;
            ddsd[i].ddpfPixelFormat.dwBumpDvBitMask = 0x00ff00;
            ddsd[i].ddpfPixelFormat.dwBumpLuminanceBitMask = 0xff0000;

            i++;
        }
    }

    *lplpddsd = ddsd;

    return i;
}

//----------------------------------------------------------------------------
//
// ZBufferFormats
//
// Must return union of all the Z buffer formats supported by all rasterizers.
// CreateDevice will screen out device-specific ones (i.e. ones ramp doesnt handle) later.
// Called at device creation time and by DDHEL to validate software ZBuffer
// creation.
//
//----------------------------------------------------------------------------

#define NUM_SUPPORTED_ZBUFFER_FORMATS   4

int
ZBufferFormats(DDPIXELFORMAT** ppDDPF, BOOL bIsRefOrNull)
{
    static DDPIXELFORMAT DDPF[NUM_SUPPORTED_ZBUFFER_FORMATS];

    int i = 0;

    memset(&DDPF[0],0,sizeof(DDPF));

    /* 16 bit Z; no stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER;
    DDPF[i].dwZBufferBitDepth = 16;
    DDPF[i].dwStencilBitDepth = 0;
    DDPF[i].dwZBitMask = 0xffff;
    DDPF[i].dwStencilBitMask = 0x0000;

    i++;

    /* 24 bit Z; 8 bit stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 8;
    DDPF[i].dwZBitMask = 0xffffff00;
    DDPF[i].dwStencilBitMask = 0x000000ff;

    i++;

    if (bIsRefOrNull)
    {
        /* 15 bit Z; 1 bit stencil */
        DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
        DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
        DDPF[i].dwZBufferBitDepth = 16;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
        DDPF[i].dwStencilBitDepth = 1;
        DDPF[i].dwZBitMask = 0xfffe;
        DDPF[i].dwStencilBitMask = 0x0001;

        i++;

        /* 32bit Z; no stencil */
        DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
        DDPF[i].dwFlags = DDPF_ZBUFFER;
        DDPF[i].dwZBufferBitDepth = 32;
        DDPF[i].dwStencilBitDepth = 0;
        DDPF[i].dwZBitMask = 0xffffffff;
        DDPF[i].dwStencilBitMask = 0x00000000;

        i++;
    }

    *ppDDPF = DDPF;

    return i;
}

// this fn is exported externally to be called by the directdraw HEL
DWORD WINAPI Direct3DGetSWRastZPixFmts(DDPIXELFORMAT** ppDDPF)
{
    // try to get texture formats from external DLL ref device
    PFNGETREFZBUFFERFORMATS pfnGetRefZBufferFormats;
    if (NULL != (pfnGetRefZBufferFormats =
        (PFNGETREFZBUFFERFORMATS)LoadReferenceDeviceProc("GetRefZBufferFormats")))
    {
        D3D_INFO(0,"Direct3DGetSWRastZPixFmts: getting Z buffer formats from d3dref");
        return pfnGetRefZBufferFormats(IID_IDirect3DRefDevice, ppDDPF);
    }

    // always return all formats so DDraw creates
    // all surfaces which it should
    return (DWORD) ZBufferFormats(ppDDPF, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\sources.inc ===
TARGETNAME = rcspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        $O\catest.cpp\
        $O\cbeadtbl.cpp\
        ..\cbldfncs.cpp\
        ..\cbufread.cpp\
        ..\cbufwrt.cpp\
        $O\cclrbld.cpp\
        $O\cclrgen.cpp\
        $O\cloop.cpp\
        ..\cspnpars.cpp\
        ..\cspnutil.cpp\
        $O\ctest.cpp\
        $O\ctx1addr.cpp\
        $O\ctx2addr.cpp\
        $O\ctxblend.cpp\
        ..\ctexfilt.cpp\
        $O\ctexread.cpp\
        $O\ctstfail.cpp

NTTARGETFILE0 = \
        $O\catest_mh.h\
        $O\ccrbd_mh.h\
        $O\ccrgn_mh.h\
        $O\ctest_mh.h\
        $O\ctx1a_mh.h\
        $O\ctx2a_mh.h\
        $O\ctxbd_mh.h\
        $O\ctxrd_mh.h\
        $O\ctstf_mh.h\
        $O\cbeadtbl.cpp\
        $O\cclrbld.cpp\
        $O\cclrgen.cpp\
        $O\cloop.cpp\
        $O\ctest.cpp\
        $O\ctx1addr.cpp\
        $O\ctx2addr.cpp\
        $O\ctxblend.cpp\
        $O\ctexread.cpp\
        $O\catest.cpp\
        $O\ctstfail.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3di.hpp>
#include <haldrv.hpp>

#include <dpf.h>

#include <rast.h>
#include "d3dif.hpp"
#include "swprov.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\d3dif.hpp ===
//----------------------------------------------------------------------------
//
// d3dif.hpp
//
// D3D front-end/rasterizer interface header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DIF_HPP_
#define _D3DIF_HPP_

#include <setup.hpp>

// For Primitive function prototypes.
#include <pmfns_mh.h>

// Vertex data is aligned on 32-byte boundaries.
#define DP_VTX_ALIGN 32

// Flags for uflags of D3DContex
#define D3DCONTEXT_IN_BEGIN             0x0001
#define D3DCONTEXT_TEXTURE_LOCKED       0x0002

// Flags for D3DDEVICEDESC dwDeviceZBufferBitDepth
// Note: This must be replicated in ddraw\ddd3dapi.h so DDHEL can pick them up
//       It only affect what legacy apps see when using GetCaps or EnumDevices,
//       internally ZBufferFormats() is checked when on ZBuffer creation.
//       Note stencil formats should have no representation in this flag word
//       becase legacy apps will be fooled into trying to create a Z-only surface
//       at the DDBD bitdepth and fail.   New apps should ignore dwDeviceZBufferBitDepth
//       and use EnumZBufferFormats

#define D3DSWRASTERIZER_ZBUFFERBITDEPTHFLAGS (DDBD_16)

// Macros used to access DDRAW surface info.
#define DDSurf_Width(lpLcl) ( (lpLcl)->lpGbl->wWidth )
#define DDSurf_Pitch(lpLcl) ( (lpLcl)->lpGbl->lPitch )
#define DDSurf_Height(lpLcl) ( (lpLcl)->lpGbl->wHeight )
#define DDSurf_BitDepth(lpLcl) \
    ( (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      (lpLcl->lpGbl->ddpfSurface.dwRGBBitCount) : \
      (lpLcl->lpGbl->lpDD->vmiData.ddpfDisplay.dwRGBBitCount) \
    )
#define DDSurf_PixFmt(lpLcl) \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      ((lpLcl)->lpGbl->ddpfSurface) : \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay) \
    )
#define VIDEO_MEMORY(pDDS) \
    (!(((LPDDRAWI_DDRAWSURFACE_INT) (pDDS))->lpLcl->lpGbl->dwGlobalFlags & \
    DDRAWISURFGBL_SYSMEMREQUESTED))
#define SURFACE_LOCKED(pDDS) \
    (((LPDDRAWI_DDRAWSURFACE_INT)(pDDS))->lpLcl->lpGbl->dwUsageCount > 0)

// Macro to retrieve SPANTEX pointer
#define HANDLE_TO_SPANTEX(hTex) \
    (*(PD3DI_SPANTEX *)ULongToPtr(hTex))

// Check the return value and return if something wrong.
// Assume hr has been declared
#define HR_RET(exp)                                                           \
{                                                                             \
    hr = (exp);                                                               \
    if (hr != D3D_OK)                                                           \
    {                                                                         \
        return hr;                                                            \
    }                                                                         \
}

// Triangle/Line/Point function
#define PFN_TRIANGLE_5ARG_DEFAULT (D3DTRIFLAG_EDGEENABLE1 | \
                                   D3DTRIFLAG_EDGEENABLE2 | \
                                   D3DTRIFLAG_EDGEENABLE3)

typedef HRESULT (*PFN_TRIANGLE)(LPVOID pCtx, PUINT8 pV0, PUINT8 pV1,
                                PUINT8 pV2,
                                WORD wFlags /*= PFN_TRIANGLE_5ARG_DEFAULT*/);
typedef HRESULT (*PFN_POINT)(LPVOID pCtx, PUINT8 pV0);
typedef HRESULT (*PFN_LINE)(LPVOID pCtx, PUINT8 pV0, PUINT8 pV1);
typedef void (*PFN_STORELASTPIXELSTATE)(LPVOID pCtx, BOOL bStore);
typedef HRESULT (*PFN_DP2SETRENDERSTATES)(LPVOID pCtx,
                                        DWORD dwFvf,
                                        LPD3DHAL_DP2COMMAND pCmd,
                                        LPDWORD lpdwRuntimeRStates);
typedef HRESULT (*PFN_DP2TEXTURESTAGESTATE)(LPVOID pCtx,
                                            DWORD dwFvf,
                                            LPD3DHAL_DP2COMMAND pCmd);

typedef HRESULT (*PFN_DP2SETVIEWPORT)(LPVOID pCtx, LPD3DHAL_DP2COMMAND pCmd);
typedef HRESULT (*PFN_DP2SETWRANGE)(LPVOID pCtx, LPD3DHAL_DP2COMMAND pCmd);

typedef struct _PRIMITIVE_FUNTIONS
{
    PFN_TRIANGLE pfnTri;
    PFN_POINT pfnPoint;
    PFN_LINE pfnLine;
    PFN_STORELASTPIXELSTATE pfnStoreLastPixelState;
    PFN_DP2SETRENDERSTATES pfnDp2SetRenderStates;
    PFN_DP2TEXTURESTAGESTATE pfnDp2TextureStageState;
    PFN_DP2SETVIEWPORT pfnDp2SetViewport;
    PFN_DP2SETWRANGE pfnDp2SetWRange;
}PRIMITIVE_FUNTIONS;

typedef enum _SW_RAST_TYPE
{
    SW_RAST_REFNULL = 1,
    SW_RAST_RGB = 2,
    SW_RAST_MMX = 3,
    SW_RAST_MMXASRGB = 4,
}SW_RAST_TYPE;

// Records the stride and the member offsets of the current FVF vertex type
// Used to pack a FVF vertex into one known by the rasterizer, such as
// RAST_GENERIC_VERTEX
typedef struct _FVFDATA
{
    // 0 means no according field
    INT16 offsetRHW;
    INT16 offsetDiff;
    INT16 offsetSpec;
    INT16 offsetTex0;
    INT16 offsetTex1;

    UINT16 stride;

    RAST_VERTEX_TYPE vtxType;

    DWORD preFVF;
    INT TexIdx[2];
    UINT cActTex;
}FVFDATA;

// Class used for the context returned to D3DIM.
class D3DContext
{
public:
    D3DI_RASTCTX m_RastCtx;

    // InBegin and TextureLockd flags
    // TextureLockd bit is set/cleared by texture Lock/Unlock functions.
    // It is used by texture Lock/Unlock and Begin functions.
    // InBegin bit is set by Begin and cleared by End
    unsigned short m_uFlags;

    // This is init'ed according to the fill mode.
    // It is init'ed after state change and before rendering
    PRIMITIVE_FUNTIONS m_fnPrims;

    // This is used to save the current ramp tex map in Begin and then used to
    // restore it in End. It's needed primarily because for ExecBuf apps the
    // the current mat may not be the one used for a primitive. For DrawPrim
    // apps, the prims are flushed whenever a material change occurs. As a
    // result this is not necessary but will not hurt anything. Also, if
    // everything works out fine, the Flush may be removed.
    PUINT32 pTexRampmapSave;

    // Used to store the old last pixel setting when drawing line strips.
    UINT uOldFlags;

    inline BOOL IsTextureOff(void);

    inline void UpdatePrimFunctionTbl(void);    // Init m_pfnTri
    inline BOOL IsAnyStatesChanged(void);
    inline BOOL IsStateChanged(UINT32 uState);
    inline void StateChanged(UINT32 uState);
    inline void SetAllStatesDirtyBits(void);
    inline void ClearAllStatesDirtyBits(void);
    inline void ClearStateDirtyBit(UINT32 uState);

    // FVF stuff
    FVFDATA m_fvfData;


#if DBG
    inline HRESULT ValidatePrimType(D3DPRIMITIVETYPE PrimitiveType);
#endif

    PrimProcessor m_PrimProc;

    // Used by RenderState for override states.
    D3DFE_STATESET m_renderstate_override;

    UINT32 dwSize;

    D3DContext(void){};
    ~D3DContext(void){};

    HRESULT Initialize(LPDIRECTDRAWSURFACE pDDS,
        LPDIRECTDRAWSURFACE pDDSZ, DWORD BeadSet, DWORD devVer);
    HRESULT FillContext(LPDIRECTDRAWSURFACE pDDS, LPDIRECTDRAWSURFACE pDDSZ);
    HRESULT SetViewport(LPD3DHAL_DP2VIEWPORTINFO pVpt);
    HRESULT TextureSetState(PD3DI_SPANTEX pSpanTex, DWORD dwState, DWORD dwValue);
    HRESULT ValidateTextureStageState(void);
    HRESULT UpdateActiveTexStageCount(void);

    inline PD3DI_RASTCTX GetRastCtx(void){return &m_RastCtx;};

    HRESULT Begin(void);
    inline HRESULT End(BOOL bNotFlush = TRUE);
    inline void BeginPrimSet(D3DPRIMITIVETYPE PrimType, RAST_VERTEX_TYPE VertType)
        {m_PrimProc.BeginPrimSet(PrimType, VertType);};
    inline void StoreLastPixelState(BOOL bStore);
    inline PRIMITIVE_FUNTIONS *GetFunsTbl(void){return &m_fnPrims;};

    void RastUnlockSpanTexture(void);
    HRESULT RastLockSpanTexture(void);
    void UpdateColorKeyAndPalette(void);
    void RemoveTexture(PD3DI_SPANTEX pSpanTex);
    HRESULT InitSpanTexture(PD3DI_SPANTEX pSpanTex, LPDIRECTDRAWSURFACE pDDS);
    HRESULT SetSizesSpanTexture(PD3DI_SPANTEX pSpanTex);

    HRESULT SetRenderState(UINT32 uState, UINT32 uStateVal);
    HRESULT UpdateRenderStates(LPDWORD puStateChange, UINT cStateChanges);
    HRESULT UpdateAllRenderStates(LPDWORD puStates);
    HRESULT Dp2SetRenderStates(LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates);
    HRESULT Dp2TextureStageState(LPD3DHAL_DP2COMMAND pCmd, DWORD dwFvf);
    void MapTextureStage0State( void );
    void MapTextureStage1State( void );
    void MapLegacyTextureBlend( void );
    void MapLegacyTextureFilter( void );

    inline HRESULT CheckDrawOnePrimitive(
        LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData);
    inline HRESULT CheckDrawOneIndexedPrimitive(
        LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pOneIdxPrimData);
    inline HRESULT DrawOnePrimitive(PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices);
    inline HRESULT DrawOneIndexedPrimitive(PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices);

    // Check if a triangle is culled or not. It's only used for wireframe and
    // point mode. It's done in PrimProc.Tri for solid mode.
    inline BOOL NotCulled(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                                             LPD3DTLVERTEX pV2);

    // FVF stuff
    HRESULT FASTCALL CheckFVF(DWORD dwFVF);
    void FASTCALL PackGenVertex(PUINT8 pFvfVtx, RAST_GENERIC_VERTEX *pGenVtx);
    inline UINT16 GetFvfStride(void){return m_fvfData.stride;};
    inline RAST_VERTEX_TYPE GetFvfVertexType(void){return m_fvfData.vtxType;};

    // Following functions are for RampRast
    // Create/Destroy a RampLightingDriver.
    inline HRESULT CreateRampLightingDriver(void);
    inline void DestroyRampLightingDriver(void);

    inline void InitRampFuncs(void){
    m_fnPrims.pfnTri = RAMP_TriSolid;
    m_fnPrims.pfnPoint = RAMP_Point;
    m_fnPrims.pfnLine = RAMP_Line;
    };
    inline HRESULT RampCreateMaterial(D3DMATERIALHANDLE hMat);
    inline HRESULT RampDestroyMaterial(D3DMATERIALHANDLE hMat);
    inline HRESULT RampSetLightstate(UINT32 uState, LPVOID pVal);
    inline HRESULT RampMaterialChanged(D3DMATERIALHANDLE hMat);
    inline void BeginSceneHook(void);
    inline void EndSceneHook(void);
    inline HRESULT RampSceneCapture(DWORD dwStart, LPDIRECT3DDEVICEI lpDevI);
    inline HRESULT RampFindLightingRange(RAMP_RANGE_INFO *pRampInfo);
    inline HRESULT RampClear(void);
    inline HRESULT RampMaterialToPixel(D3DMATERIALHANDLE hMat, DWORD* pPixel);
    inline void RampSetFogData(UINT32 uState, UINT32 uStateVal);
    inline void RampSetMaterial(D3DMATERIALHANDLE hMat);
    inline HRESULT RampCheckTexMap(LPD3DTLVERTEX pV);
    inline void RampInitTexMap(LPD3DTLVERTEX pV)
            {m_RastCtx.pTexRampMap = (PUINT32)ULongToPtr(pV->specular);};
    inline void RampUpdateRangeInfo(void);
    inline HRESULT RGB8ColorToPixel(D3DCOLOR Color, DWORD* pdwPalIdx);
    inline HRESULT RampPaletteChanged(D3DTEXTUREHANDLE hTex);
    inline HRESULT RampClearTexRect(D3DMATERIALHANDLE hMat, LPD3DRECT pRect);

};

inline void D3DContext::StoreLastPixelState(BOOL bStore)
{
    if (bStore)
    {
        uOldFlags = m_PrimProc.GetFlags();
        m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);
    }
    else
    {
        m_PrimProc.SetFlags(uOldFlags & PPF_DRAW_LAST_LINE_PIXEL);
    }
}

inline BOOL D3DContext::NotCulled(LPD3DTLVERTEX pV0,
              LPD3DTLVERTEX pV1, LPD3DTLVERTEX pV2)
{
    if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE)
    {
        return TRUE;
    }

    FLOAT x1, y1, x2x1, x3x1, y2y1, y3y1, fDet;

    x1 = pV0->sx;
    y1 = pV0->sy;
    x2x1 = pV1->sx - x1;
    y2y1 = pV1->sy - y1;
    x3x1 = pV2->sx - x1;
    y3y1 = pV2->sy - y1;

    fDet = x2x1 * y3y1 - x3x1 * y2y1;

    if (0. == fDet)
    {
        return FALSE;
    }
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_CULLMODE] )
    {
    case D3DCULL_CW:
        if ( fDet > 0.f )
        {
            return FALSE;
        }
        break;
    case D3DCULL_CCW:
        if ( fDet < 0.f )
        {
            return FALSE;
        }
        break;
    }
    return TRUE;
}
// Update m_pfnPrims according to the current fill mode, device type
// and vertextype. It's called when fill mode or FVF type chang.
inline void D3DContext::UpdatePrimFunctionTbl(void)
{
    if (m_RastCtx.BeadSet == D3DIBS_RAMP)
    {
        switch (m_RastCtx.pdwRenderState[D3DRENDERSTATE_FILLMODE])
        {
        case D3DFILL_POINT:
            m_fnPrims.pfnTri = RAMP_TriPoint;
            break;
        case D3DFILL_WIREFRAME:
            m_fnPrims.pfnTri = RAMP_TriWireframe;
            break;
        case D3DFILL_SOLID:
        default:
            m_fnPrims.pfnTri = RAMP_TriSolid;
            break;
        }
    }
    else
    {
        if (m_fvfData.vtxType == RAST_GENVERTEX)
        {
            m_fnPrims.pfnPoint = RGB_PointPack;
            m_fnPrims.pfnLine = RGB_LinePack;
        }
        else
        {
            m_fnPrims.pfnPoint = RGB_PointNoPack;
            m_fnPrims.pfnLine = RGB_LineNoPack;
        }
        switch (m_RastCtx.pdwRenderState[D3DRENDERSTATE_FILLMODE])
        {
        case D3DFILL_POINT:
            if (m_fvfData.vtxType == RAST_GENVERTEX)
            {
                m_fnPrims.pfnTri = RGB_TriPackPoint;
            }
            else
            {
                m_fnPrims.pfnTri = RGB_TriNoPackPoint;
            }
            break;
        case D3DFILL_WIREFRAME:
            if (m_fvfData.vtxType == RAST_GENVERTEX)
            {
                m_fnPrims.pfnTri = RGB_TriPackWireframe;
            }
            else
            {
                m_fnPrims.pfnTri = RGB_TriNoPackWireframe;
            }
            break;
            break;
        case D3DFILL_SOLID:
        default:
            if (m_fvfData.vtxType == RAST_GENVERTEX)
            {
                m_fnPrims.pfnTri = RGB_TriPackSolid;
            }
            else
            {
                m_fnPrims.pfnTri = RGB_TriNoPackSolid;
            }
            break;
        }
    }
}

// The following inline functions are provided to manipulate StatesDirtyBits.
// StatesDirtyBits is used to store one dirty bit for each render state. It
// contains (D3DHAL_MAX_RSTATES_AND_STAGES>>3+1) bytes.
// For a particular state, say uState,
// it is represented by i'th bit of j'th byte, where i=(uState & 7) and
// j=uState>>3. So,
// StatesDirtyBits[uState>>3]&(1<<(uState&7)) gives the bit info. for uState
// StatesDirtyBits[uState>>3] |= (1<<(uState&7)) sets the bit to 1
// StatesDirtyBits[uState>>3] &= ~(1 <<(uState&7)) clears the bit to 0

// Check if any render states have changed. The info. is stored in the bit
// corresponding to D3DHAL_MAX_RSTATES_AND_STAGES.
inline BOOL D3DContext::IsAnyStatesChanged()
{
    return (m_RastCtx.StatesDirtyBits[D3DHAL_MAX_RSTATES_AND_STAGES>>3] &
        (1<<(D3DHAL_MAX_RSTATES_AND_STAGES & 7)));
}
// Check if uState has changed.
inline BOOL D3DContext::IsStateChanged(UINT32 uState)
{
    return (m_RastCtx.StatesDirtyBits[uState>>3] & (1<<(uState & 7)));
};

// uState has changed so set the according dirty bit and the AnyStates bit.
inline void D3DContext::StateChanged(UINT32 uState)
{
    m_RastCtx.StatesDirtyBits[uState>>3] |= (1<<(uState & 7));
    m_RastCtx.StatesDirtyBits[D3DHAL_MAX_RSTATES_AND_STAGES>>3] |=
        (1<<(D3DHAL_MAX_RSTATES_AND_STAGES & 7));
};

// Called after bead chooser to clear all the dirty bits.
inline void D3DContext::ClearAllStatesDirtyBits(void)
{
    memset(m_RastCtx.StatesDirtyBits, 0, sizeof(UINT8) * RAST_DIRTYBITS_SIZE);
};

// Called at context creation time to set all the dirty bits.
inline void D3DContext::SetAllStatesDirtyBits(void)
{
    memset(m_RastCtx.StatesDirtyBits, 7, sizeof(UINT8) * RAST_DIRTYBITS_SIZE);
};

// Clear the dirty bit corresponding to uState.
inline void D3DContext::ClearStateDirtyBit(UINT32 uState)
{
    m_RastCtx.StatesDirtyBits[uState>>3] &= ~(1 << (uState & 7));
}
inline BOOL D3DContext::IsTextureOff(void)
{
    return
        (m_RastCtx.cActTex == 0 ||
        (m_RastCtx.cActTex == 1 && m_RastCtx.pTexture[0] == NULL) ||
        (m_RastCtx.cActTex == 2 &&
         (m_RastCtx.pTexture[0] == NULL ||
          m_RastCtx.pTexture[1] == NULL)));
}
extern "C" HRESULT WINAPI
DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern "C" HRESULT WINAPI
DDInternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl );

// Lock surfaces before rendering
inline HRESULT LockSurface(LPDIRECTDRAWSURFACE pDDS, LPVOID *ppData)
{
    if (pDDS)
    {
        if (!VIDEO_MEMORY(pDDS))
        {
            if (SURFACE_LOCKED(pDDS))
            return DDERR_SURFACEBUSY;
            *ppData = (LPVOID)SURFACE_MEMORY(pDDS);
            return DD_OK;
        }
        else
        {
            HRESULT ddrval;
            do
            {
                LPDDRAWI_DDRAWSURFACE_INT lpInt;

                lpInt = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
                ddrval = DDInternalLock(lpInt->lpLcl, ppData);
            } while (ddrval == DDERR_WASSTILLDRAWING);
            return ddrval;
        }
    }
    return DD_OK;
}
// Unlock surfaces after rendering
inline void UnlockSurface(LPDIRECTDRAWSURFACE pDDS)
{
    if (pDDS && VIDEO_MEMORY(pDDS))
    {
        LPDDRAWI_DDRAWSURFACE_INT lpInt;

        lpInt = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
        DDInternalUnlock(lpInt->lpLcl);
    }
}
// After rendering cleanup: flush primitive processor, unlock textures
inline HRESULT
D3DContext::End(BOOL bNotFlush)
{
    if (m_uFlags & D3DCONTEXT_IN_BEGIN)
    {
        HRESULT hr = m_PrimProc.End();

        // Unlock texture if this is not called in the middle of drawPrims to
        // flush for possible state changes. In the 2nd case, let
        // SetRenderState to handle it.
        if (bNotFlush)
        {
            RastUnlockSpanTexture();
        }

        // Unlock surfaces
        UnlockSurface(m_RastCtx.pDDS);
        if (m_RastCtx.pDDSZ != NULL)
        {
            UnlockSurface(m_RastCtx.pDDSZ);
        }

        m_uFlags &= ~D3DCONTEXT_IN_BEGIN;
        if (m_RastCtx.pRampDrv)
        {
            m_RastCtx.pTexRampMap = pTexRampmapSave;
        }
        return (hr);
    }
    else
    {
        // In the case of DrawPrims being called just to set render states,
        // Begin is actually not called.
        return D3D_OK;
    }
}

inline HRESULT
D3DContext::RampCheckTexMap(LPD3DTLVERTEX pV)
{
    if (m_RastCtx.pTexRampMap != (PUINT32)ULongToPtr(pV->specular))
    {
        HRESULT hr;
        // Flush Prims
        HR_RET(End());
        HR_RET(Begin());
        m_RastCtx.pTexRampMap = (PUINT32)ULongToPtr(pV->specular);
    }
    return D3D_OK;
}

// Following primitive functions are shared by RGB/RAMP/REF rasterizers
HRESULT FASTCALL
DoDrawOneIndexedPrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices);
HRESULT FASTCALL
DoDrawOnePrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices);
HRESULT FASTCALL
DoDrawOneEdgeFlagTriangleFan(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 UINT cVertices,
                 UINT32 dwEdgeFlags);
HRESULT FASTCALL
DoRendPoints(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DPOINT pPt);
HRESULT FASTCALL
DoRendLines(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DLINE pLine);
HRESULT FASTCALL
DoRendTriangles(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DTRIANGLE pTri);
HRESULT FASTCALL
DoDrawPrimitives2(LPVOID pCtx,
                  PRIMITIVE_FUNTIONS *pfnPrims,
                  UINT16 dwStride,
                  DWORD dwFvf,
                  PUINT8 pVtx,
                  LPD3DHAL_DP2COMMAND *ppCmd,
                  LPDWORD lpdwRStates,
                  BOOL bWireframe = FALSE
                  );


inline HRESULT
D3DContext::DrawOnePrimitive(PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices)
{
    m_PrimProc.BeginPrimSet(PrimType, m_fvfData.vtxType);
    return DoDrawOnePrimitive((LPVOID)this,
                                    &m_fnPrims,
                                    m_fvfData.stride,
                                    (PUINT8)pVtx,
                                    PrimType,
                                    cVertices);

}

inline HRESULT
D3DContext::DrawOneIndexedPrimitive(PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices)
{
    m_PrimProc.BeginPrimSet(PrimType, m_fvfData.vtxType);
    return DoDrawOneIndexedPrimitive((LPVOID)this,
                                    &m_fnPrims,
                                    m_fvfData.stride,
                                    (PUINT8)pVtx,
                                    puIndices,
                                    PrimType,
                                    cIndices);
}

// Macros to check if a pointer is valid
#if DBG
#define VALID_D3DCONTEX_PTR(pDCtx)  ((pDCtx)->dwSize == sizeof(D3DContext))
#define VALID_D3DI_RASTCTX_PTR(pRastCtx) \
            ((pRastCtx)->dwSize == sizeof(D3DI_RASTCTX))
#define VALID_D3DI_SPANTEX_PTR(pSpanTex) \
            ((pSpanTex)->dwSize == sizeof(D3DI_SPANTEX))
#define VALID_D3DI_SPANTEX_PTR_PTR(ppSpanTex) \
            ((ppSpanTex) && VALID_D3DI_SPANTEX_PTR(*(ppSpanTex)))
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    if ((data_ptr) == NULL)   \
    {   \
        D3D_INFO(1, "in %s, data pointer = NULL", (caller_name));  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
    pCtx = (type)((data_ptr)->dwhContext); \
    if (!pCtx) \
    {   \
        D3D_INFO(1, "in %s, dwhContext = NULL", (caller_name));    \
        (data_ptr)->ddrval = D3DHAL_CONTEXT_BAD;  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}
#else // !DBG
#define VALID_D3DCONTEX_PTR(pDCtx)              1
#define VALID_D3DI_RASTCTX_PTR(pRastCtx)        1
#define VALID_D3DI_SPANTEX_PTR(pSpanTex)        1
#define VALID_D3DI_SPANTEX_PTR_PTR(ppSpanTex)   1
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    pCtx = (type)((data_ptr)->dwhContext); \
}
#endif // !DBG

// Validate D3DCxt. pDCtx should be declared before this macro
#define VALIDATE_D3DCONTEXT(caller_name, data_ptr)  \
{   \
    VALIDATE_CONTEXT(caller_name, data_ptr, pDCtx, D3DContext*); \
    if (!VALID_D3DCONTEX_PTR(pDCtx) ||  \
        !VALID_D3DI_RASTCTX_PTR((pDCtx)->GetRastCtx()))    \
    {   \
        D3D_INFO(1, "in %s, invalid dwhContext", (caller_name));    \
        (data_ptr)->ddrval = D3DHAL_CONTEXT_BAD;  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}

// Validate ReferenceRasterizer. pRefRast should be declared before this macro
#define VALIDATE_REFRAST_CONTEXT(caller_name, data_ptr)  \
{   \
    VALIDATE_CONTEXT(caller_name, data_ptr, pRefRast, ReferenceRasterizer*);\
}

#define CHECK_FVF(ret, pDCtx, dwFlags)  \
{   \
    if ((ret = pDCtx->CheckFVF(dwFlags)) != DD_OK)  \
    {   \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}

HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT pDdPixFmt,
                  D3DI_SPANTEX_FORMAT *pFmt);

extern int
TextureFormats(LPDDSURFACEDESC* lplpddsd, DWORD dwVersion, SW_RAST_TYPE RastType);

extern int
RampTextureFormats(LPDDSURFACEDESC* lplpddsd);

extern int
ZBufferFormats(DDPIXELFORMAT** ppDDPF, BOOL bIsRefRast);

extern int
RampZBufferFormats(DDPIXELFORMAT** ppDDPF);

BOOL FASTCALL
ValidTextureSize(INT16 iuSize, INT16 iuShift,
                             INT16 ivSize, INT16 ivShift);
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize);

DWORD __stdcall
RastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData, DWORD BeadSet);

DWORD __stdcall
RastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData, DWORD BeadSet);

DWORD __stdcall
RastContextCreateC(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextCreateCMMX(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextCreateMMX(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextCreateMMXAsRGB(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextCreateRamp(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData);

DWORD __stdcall
RastContextDestroyRamp(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData);

DWORD __stdcall
RastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData);

DWORD __stdcall
RastTextureCreate(LPD3DHAL_TEXTURECREATEDATA pTexData);

DWORD __stdcall
RastTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pTexDestroyData);

DWORD __stdcall
RastTextureSwap(LPD3DHAL_TEXTURESWAPDATA pTexSwapData);

DWORD __stdcall
RastTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pTexGetSurf);

DWORD __stdcall
RastRenderState(LPD3DHAL_RENDERSTATEDATA pStateData);

DWORD __stdcall
RastRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA pRenderData);

DWORD __stdcall
RastDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData);

DWORD __stdcall
RastDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
                            pOneIdxPrimData);

DWORD __stdcall
RastDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA pDrawPrimData);

DWORD __stdcall
RastClearRamp(LPD3DHAL_CLEARDATA pClrData);

DWORD __stdcall
RastSceneCaptureRamp(LPD3DHAL_SCENECAPTUREDATA pSceneData);

DWORD __stdcall
RastValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData);

DWORD __stdcall
RastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data);

DWORD __stdcall
RefRastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data);


//---------------------------------------------------------------------------
//
//  Interface for Reference Device External DLL
//

//  prototypes for functions exported by d3dref.dll
STDAPI GetRefHalProvider(REFCLSID riid, IHalProvider **ppHalProvider, HINSTANCE *phDll);
STDAPI GetRefZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF);
STDAPI GetRefTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd, DWORD dwD3DDeviceVersion);

typedef HRESULT (STDAPICALLTYPE* PFNGETREFHALPROVIDER)(REFCLSID,IHalProvider**,HINSTANCE*);
typedef HRESULT (STDAPICALLTYPE* PFNGETREFZBUFFERFORMATS)(REFCLSID, DDPIXELFORMAT**);
typedef HRESULT (STDAPICALLTYPE* PFNGETREFTEXTUREFORMATS)(REFCLSID, LPDDSURFACEDESC*, DWORD);

inline FARPROC LoadReferenceDeviceProc( char* szProc )
{
    HINSTANCE hRefDLL;
    if (NULL == (hRefDLL = LoadLibrary("d3dref.dll")) )
    {
        return NULL;
    }
    return GetProcAddress(hRefDLL, szProc);
}

//---------------------------------------------------------------------------
#endif // #ifndef _D3DIF_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\drawprim.cpp ===
//----------------------------------------------------------------------------
//
// drawprim.cpp
//
// Implements DrawOnePrimitive, DrawOneIndexedPrimitive and
// DrawPrimitives.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// CheckFVF
//
// Check a FVF control word and then init m_fvfData accordingly
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
D3DContext::CheckFVF(DWORD dwFVF)
{
    // check if FVF controls have changed
    if ( (m_fvfData.preFVF == dwFVF) &&
         (m_fvfData.TexIdx[0] == (INT)m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_TEXCOORDINDEX)]) &&
         (m_fvfData.TexIdx[1] == (INT)m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_TEXCOORDINDEX)]) &&
         (m_fvfData.cActTex == m_RastCtx.cActTex) )
    {
        return D3D_OK;
    }
#if DBG
    // This is added here per Iouri's request. It will make it easier for him
    // to test his code for legacy drivers.
    if (dwFVF == 0)
    {
        dwFVF = D3DFVF_TLVERTEX;
    }
#endif

    memset(&m_fvfData, 0, sizeof(FVFDATA));
    m_fvfData.preFVF = dwFVF;
    m_fvfData.TexIdx[0] = m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_TEXCOORDINDEX)];
    m_fvfData.TexIdx[1] = m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_TEXCOORDINDEX)];
    m_fvfData.cActTex = m_RastCtx.cActTex;

#if DBG
    // We only support max 8 texture coords
    if (m_fvfData.TexIdx[0] > 7 || m_fvfData.TexIdx[1] > 7)
    {
        D3D_WARN(0, "(Rast) Texture coord index bigger than max supported.");
        return DDERR_INVALIDPARAMS;
    }
#endif

    // Update the copy of wrap states in RastCtx
    m_RastCtx.pdwWrap[0] = m_RastCtx.pdwRenderState[
                (D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0+m_fvfData.TexIdx[0])];
    m_RastCtx.pdwWrap[1] = m_RastCtx.pdwRenderState[
                (D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0+m_fvfData.TexIdx[1])];

    // do either true FVF parsing or legacy TLVERTEX handling
    if ( (m_RastCtx.BeadSet != D3DIBS_RAMP) &&
         ( (dwFVF != D3DFVF_TLVERTEX) ||
           (0 != m_fvfData.TexIdx[0]) ||
           (m_RastCtx.cActTex > 1) ) )
    {   // New (non TL)FVF vertex
        // XYZ
        if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED1 | D3DFVF_RESERVED2 |
             D3DFVF_NORMAL)) ||
             ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
        {
            // can't set reserved bits, shouldn't have normals in
            // output to rasterizers, and must have coordinates
            return DDERR_INVALIDPARAMS;
        }
        m_fvfData.stride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            m_fvfData.offsetRHW = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            m_fvfData.offsetDiff = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            m_fvfData.offsetSpec = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
#if DBG
        INT iTexIdx0 = m_fvfData.TexIdx[0], iTexIdx1 = m_fvfData.TexIdx[1];
        if (iTexCount > 0)
        {
            if ( iTexIdx0 >= iTexCount)
            {
                D3D_WARN(1, "(Rast)Texture coord index bigger than texture coord count.");
                iTexIdx0 = 0;
            }
            if ( iTexIdx1 >= iTexCount)
            {
                D3D_WARN(1, "(Rast)Texture coord index bigger than texture coord count.");
                iTexIdx1 = 0;
            }
            // set offset for Textures 0 and 1
            m_fvfData.offsetTex0 = (INT16)(m_fvfData.stride +
                                    2*sizeof(D3DVALUE)*iTexIdx0);
            m_fvfData.offsetTex1 = (INT16)(m_fvfData.stride +
                                    2*sizeof(D3DVALUE)*iTexIdx1);
            // update stride
            m_fvfData.stride += (INT16)(iTexCount * (sizeof(D3DVALUE) * 2));
        }
#else
        if (iTexCount > 0)
        {
            // set offset for Textures 0 and 1
            m_fvfData.offsetTex0 = (INT16)(m_fvfData.stride +
                                    2*sizeof(D3DVALUE)*m_fvfData.TexIdx[0]);
            m_fvfData.offsetTex1 = (INT16)(m_fvfData.stride +
                                    2*sizeof(D3DVALUE)*m_fvfData.TexIdx[1]);
            // update stride
            m_fvfData.stride += (INT16)(iTexCount * (sizeof(D3DVALUE) * 2));
        }
#endif

        m_fvfData.vtxType = RAST_GENVERTEX;
    }
    else
    {
        // (Legacy) TL vertex
        if (0 < m_fvfData.TexIdx[0])
        {
            D3D_ERR("(Rast) Texture coord index bigger than 0 for legacy TL vertex.");
            return DDERR_INVALIDPARAMS;
        }
        m_fvfData.stride = sizeof(D3DTLVERTEX);
        m_fvfData.vtxType = RAST_TLVERTEX;
    }

    UpdatePrimFunctionTbl();

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PackGenVertex
//
// Pack a FvFVertex into RAST_GENERIC_VERTEX. This is called for every non TL
// FVF vertex. It can be optimized for speed later.
//
//----------------------------------------------------------------------------
void FASTCALL
D3DContext::PackGenVertex(PUINT8 pFvfVtx, RAST_GENERIC_VERTEX *pGenVtx)
{
    pGenVtx->sx = *((D3DVALUE *)pFvfVtx);
    pGenVtx->sy = *((D3DVALUE *)pFvfVtx + 1);
    pGenVtx->sz = *((D3DVALUE *)pFvfVtx + 2);
    if (m_fvfData.offsetRHW)
    {
        pGenVtx->rhw = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetRHW));
    }
    else
    {
        pGenVtx->rhw = 1.0f;
    }
    if (m_fvfData.offsetDiff)
    {
        pGenVtx->color = *((D3DCOLOR *)(pFvfVtx + m_fvfData.offsetDiff));
    }
    else
    {
        pGenVtx->color = __DEFAULT_DIFFUSE;
    }
    if (m_fvfData.offsetSpec)
    {
        pGenVtx->specular = *((D3DCOLOR *)(pFvfVtx + m_fvfData.offsetSpec));
    }
    else
    {
        pGenVtx->specular = __DEFAULT_SPECULAR;
    }
    if (m_fvfData.offsetTex0)
    {
        pGenVtx->tu = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex0));
        pGenVtx->tv = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex0) + 1);
    }
    else
    {
        pGenVtx->tu = 0.0f;
        pGenVtx->tv = 0.0f;
    }
    if (m_fvfData.offsetTex1)
    {
        pGenVtx->tu2 = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex1));
        pGenVtx->tv2 = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex1) + 1);
    }
    else
    {
        pGenVtx->tu2 = 0.0f;
        pGenVtx->tv2 = 0.0f;
    }
}

//----------------------------------------------------------------------------
//
// DoDrawOnePrimitive
//
// Draw one list of primitives. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOnePrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    switch (PrimType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cVertices; i > 0; i--)
        {
            HR_RET(pfnPrims->pfnPoint(pCtx, pVtx));
            pVtx += FvfStride;
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cVertices / 2; i > 0; i--)
        {
            pV0 = pVtx;
            pVtx += FvfStride;
            pV1 = pVtx;
            pVtx += FvfStride;
            HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
        }
        break;
    case D3DPT_LINESTRIP:
        {
            pV1 = pVtx;

            // Disable last-pixel setting for shared verties and store prestate.
            pfnPrims->pfnStoreLastPixelState(pCtx, 1);

            // Initial pV0.
            for (i = (INT)cVertices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pVtx += FvfStride;
                pV1 = pVtx;
                HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
            }

            // Restore last-pixel setting.
            pfnPrims->pfnStoreLastPixelState(pCtx, 0);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + FvfStride;
                HR_RET(pfnPrims->pfnLine(pCtx, pV1, pV0));
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cVertices; i > 0; i -= 3)
        {
            pV0 = pVtx;
            pVtx += FvfStride;
            pV1 = pVtx;
            pVtx += FvfStride;
            pV2 = pVtx;
            pVtx += FvfStride;
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx;
            pVtx += FvfStride;
            pV2 = pVtx;
            pVtx += FvfStride;

            for (i = (INT)cVertices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pVtx += FvfStride;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pVtx += FvfStride;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV2, pV1, PFN_TRIANGLE_5ARG_DEFAULT));
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = pVtx;
            pVtx += FvfStride;
            // Preload initial pV0.
            pV1 = pVtx;
            pVtx += FvfStride;
            for (i = (INT)cVertices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pVtx;
                pVtx += FvfStride;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));
            }
        }
        break;

    default:
        D3D_ERR("(Rast) Unknown or unsupported primitive type "
            "requested of DrawOnePrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawOneIndexedPrimitive
//
// Draw one list of indexed primitives. It's called by
// RastDrawOneIndexedPrimitive.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOneIndexedPrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    switch(PrimType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            HR_RET(pfnPrims->pfnPoint(pCtx, pV0));
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pV1 = pVtx + FvfStride * (*puIndices++);
            HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            pfnPrims->pfnStoreLastPixelState(pCtx, 1);
            // Initial pV1.
            pV1 = pVtx + FvfStride * (*puIndices++);
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
            }
            // Restore last-pixel setting.
            pfnPrims->pfnStoreLastPixelState(pCtx, 0);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + FvfStride * (*puIndices);
                HR_RET(pfnPrims->pfnLine(pCtx, pV1, pV0));
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pV1 = pVtx + FvfStride * (*puIndices++);
            pV2 = pVtx + FvfStride * (*puIndices++);
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx + FvfStride * (*puIndices++);
            pV2 = pVtx + FvfStride * (*puIndices++);

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV2, pV1, PFN_TRIANGLE_5ARG_DEFAULT));
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = pVtx + FvfStride * (*puIndices++);
            // Preload initial pV0.
            pV1 = pVtx + FvfStride * (*puIndices++);
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));
            }
        }
        break;

    default:
        D3D_ERR("(Rast) Unknown or unsupported primitive type "
            "requested of DrawOneIndexedPrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawOneEdgeFlagTriangleFan
//
// Draw one list of triangle fans. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOneEdgeFlagTriangleFan(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 UINT cVertices,
                 UINT32 dwEdgeFlags)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    pV2 = pVtx;
    pVtx += FvfStride;
    pV0 = pVtx;
    pVtx += FvfStride;
    pV1 = pVtx;
    pVtx += FvfStride;
    WORD wFlags = 0;
    if(dwEdgeFlags & 0x2)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    if(dwEdgeFlags & 0x1)
        wFlags |= D3DTRIFLAG_EDGEENABLE3;
    if(cVertices == 3) {
        if(dwEdgeFlags & 0x4)
            wFlags |= D3DTRIFLAG_EDGEENABLE2;
        HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, wFlags));
        return D3D_OK;
    }
    HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, wFlags));
    UINT32 dwMask = 0x4;
    for (i = (INT)cVertices - 4; i > 0; i--)
    {
        pV0 = pV1;
        pV1 = pVtx;
        pVtx += FvfStride;
        if(dwEdgeFlags & dwMask)
        {
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, D3DTRIFLAG_EDGEENABLE1));
        }
        else
        {
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, 0));
        }
        dwMask <<= 1;
    }
    pV0 = pV1;
    pV1 = pVtx;
    wFlags = 0;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    dwMask <<= 1;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE2;
    HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, wFlags));

    return D3D_OK;
}

#if DBG
//----------------------------------------------------------------------------
//
// ValidatePrimType
//
// Check if the primitive type is supported. We could remove this function
// after we have implemented all primitive types and then depend on D3DIM
// to check if the primitive type is valid.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::ValidatePrimType(D3DPRIMITIVETYPE PrimitiveType)
{
    switch(PrimitiveType)
    {
    case D3DPT_POINTLIST:
    case D3DPT_LINELIST:
    case D3DPT_LINESTRIP:
    case D3DPT_TRIANGLELIST:
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        break;
    default:
        D3D_ERR("(Rast) PrimitiveType not supported by the new rasterizer.");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}
#endif
//----------------------------------------------------------------------------
//
// CheckDrawOnePrimitive
//
// Check if the DRAWONEPRIMITIVEDATA is valid.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::CheckDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData)
{
#if DBG
    HRESULT hr;

    if (pOnePrimData == NULL ||
        pOnePrimData->dwhContext == 0 ||
        pOnePrimData->lpvVertices == NULL)
    {
        D3D_ERR("(Rast) Invalid data passed to the new rasterizer.");
        return DDERR_INVALIDPARAMS;
    }

    HR_RET(ValidatePrimType(pOnePrimData->PrimitiveType));
#endif
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// CheckDrawOneIndexedPrimitive
//
// Check if the DRAWONEINDEXEDPRIMITIVEDATA is valid.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::CheckDrawOneIndexedPrimitive(
                         LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pOneIdxPrimData)
{
#if DBG
    HRESULT hr;

    if (pOneIdxPrimData == NULL ||
        pOneIdxPrimData->dwhContext == 0 ||
        pOneIdxPrimData->lpvVertices == NULL ||
        pOneIdxPrimData->lpwIndices == NULL)
    {
        D3D_ERR("(Rast) Invalid data passed to the new rasterizer.");
        return DDERR_INVALIDPARAMS;
    }

    HR_RET(ValidatePrimType(pOneIdxPrimData->PrimitiveType));
#endif
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastDrawOnePrimitive
//
// Draw one list of primitives. This is called by D3DIM for API DrawPrimitive.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData)
{
    HRESULT hr;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastDrawOnePrimitive", pOnePrimData);

    if ((pOnePrimData->ddrval =
        pDCtx->CheckDrawOnePrimitive(pOnePrimData)) != DD_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Check for FVF vertex, and init FVF related fileds if necessary
    // Assume the control word is passed in through dwFlags
    CHECK_FVF(pOnePrimData->ddrval, pDCtx, (DWORD)pOnePrimData->dwFVFControl);

    pOnePrimData->ddrval = pDCtx->Begin();
    if (pOnePrimData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    pOnePrimData->ddrval =
        pDCtx->DrawOnePrimitive((PUINT8)pOnePrimData->lpvVertices,
                         pOnePrimData->PrimitiveType,
                         pOnePrimData->dwNumVertices);

    hr = pDCtx->End();
    if (pOnePrimData->ddrval == D3D_OK)
    {
        pOnePrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastDrawOneIndexedPrimitive
//
// Draw one list of primitives. This is called by D3DIM for API
// DrawIndexedPrimitive.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
                            pOneIdxPrimData)
{
    HRESULT hr;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastDrawOneIndexedPrimitive", pOneIdxPrimData);

    if ((pOneIdxPrimData->ddrval =
         pDCtx->CheckDrawOneIndexedPrimitive(pOneIdxPrimData)) != DD_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Check for FVF vertex, and init FVF related fileds if necessary
    // Assume the control word is passed in through dwFlags
    CHECK_FVF(pOneIdxPrimData->ddrval, pDCtx, (DWORD)pOneIdxPrimData->dwFVFControl);

    pOneIdxPrimData->ddrval = pDCtx->Begin();
    if (pOneIdxPrimData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    pOneIdxPrimData->ddrval =
        pDCtx->DrawOneIndexedPrimitive((PUINT8)pOneIdxPrimData->lpvVertices,
                                pOneIdxPrimData->lpwIndices,
                                pOneIdxPrimData->PrimitiveType,
                                pOneIdxPrimData->dwNumIndices);

    hr = pDCtx->End();
    if (pOneIdxPrimData->ddrval == D3D_OK)
    {
        pOneIdxPrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastDrawPrimitives
//
// This is called by D3DIM for a list of batched API DrawPrimitive calls.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA pDrawPrimData)
{
    PUINT8  pData = (PUINT8)pDrawPrimData->lpvData;
    LPD3DHAL_DRAWPRIMCOUNTS pDrawPrimitiveCounts;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastDrawPrimitives", pDrawPrimData);

    pDrawPrimitiveCounts = (LPD3DHAL_DRAWPRIMCOUNTS)pData;

    // Check for FVF vertex when there are actually something to be drawn, and
    // init FVF related fileds if necessary Assume the control word is passed
    // in through dwReserved
    if (pDrawPrimitiveCounts->wNumVertices > 0)
    {
        CHECK_FVF(pDrawPrimData->ddrval, pDCtx, pDrawPrimData->dwFVFControl);
    }

    // Skip state check and texture lock if the first thing is state change
    if (pDrawPrimitiveCounts->wNumStateChanges == 0)
    {
        pDrawPrimData->ddrval =pDCtx->Begin();
        if (pDrawPrimData->ddrval != D3D_OK)
        {
            goto EH_Exit;
        }
    }

    // Loop through the data, update render states
    // and then draw the primitive
    for (;;)
    {
        pDrawPrimitiveCounts = (LPD3DHAL_DRAWPRIMCOUNTS)pData;
        pData += sizeof(D3DHAL_DRAWPRIMCOUNTS);

        //
        // Update render states
        //

        if (pDrawPrimitiveCounts->wNumStateChanges > 0)
        {
            // Flush the prim proc before any state changs
            pDrawPrimData->ddrval = pDCtx->End(FALSE);
            if (pDrawPrimData->ddrval != D3D_OK)
            {
                return DDHAL_DRIVER_HANDLED;
            }

            pDrawPrimData->ddrval =
                pDCtx->UpdateRenderStates((LPDWORD)pData,
                                   pDrawPrimitiveCounts->wNumStateChanges);
            if (pDrawPrimData->ddrval != D3D_OK)
            {
                goto EH_Exit;
            }

            pData += pDrawPrimitiveCounts->wNumStateChanges *
                sizeof(DWORD) * 2;
        }

        // Check for exit
        if (pDrawPrimitiveCounts->wNumVertices == 0)
        {
            break;
        }

        // Align pointer to vertex data
        pData = (PUINT8)
            ((UINT_PTR)(pData + (DP_VTX_ALIGN - 1)) & ~(DP_VTX_ALIGN - 1));

        // Delayed change until we really need to render something
        if (pDrawPrimitiveCounts->wNumStateChanges > 0)
        {
            // We might have a new texture so lock.
            pDrawPrimData->ddrval = pDCtx->Begin();
            if (pDrawPrimData->ddrval != D3D_OK)
            {
                goto EH_Exit;
            }
        }

        //
        // Primitives
        //
        pDrawPrimData->ddrval =
            pDCtx->DrawOnePrimitive((PUINT8)pData,
                        (D3DPRIMITIVETYPE)pDrawPrimitiveCounts->wPrimitiveType,
                        pDrawPrimitiveCounts->wNumVertices);
        if (pDrawPrimData->ddrval != DD_OK)
        {
            goto EH_Exit;
        }

        pData += pDrawPrimitiveCounts->wNumVertices * pDCtx->GetFvfStride();
    }

 EH_Exit:
    HRESULT hr;

    hr = pDCtx->End();

    if (pDrawPrimData->ddrval == D3D_OK)
    {
        pDrawPrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\rampif.cpp ===
//----------------------------------------------------------------------------
//
// rampif.cpp
//
// Implements RampService.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "rampif.h"
#include "rampmat.hpp"

//----------------------------------------------------------------------------
//
// RastRampService
//
// Called by d3dim to update RampRast about material cchanges and so on.
//
//----------------------------------------------------------------------------

HRESULT
RastRampService(ULONG_PTR dwCtx,
                RastRampServiceType srvType, ULONG_PTR arg1, LPVOID arg2)
{
    D3DContext *pD3DCtx = (D3DContext *)dwCtx;

    switch (srvType)
    {
    case RAMP_SERVICE_CREATEMAT    :
        return pD3DCtx->RampCreateMaterial((D3DMATERIALHANDLE) arg1);
    case RAMP_SERVICE_DESTORYMAT   :
        return pD3DCtx->RampDestroyMaterial((D3DMATERIALHANDLE) arg1);
    case RAMP_SERVICE_SETMATDATA   :
        return pD3DCtx->RampMaterialChanged((D3DMATERIALHANDLE) arg1);
    case RAMP_SERVICE_SETLIGHTSTATE:
        return pD3DCtx->RampSetLightstate((UINT32)arg1, arg2);
    case RAMP_SERVICE_FIND_LIGHTINGRANGE:
        return pD3DCtx->RampFindLightingRange((RAMP_RANGE_INFO *)arg1);
    case RAMP_SERVICE_CLEAR:
        return pD3DCtx->RampClear();
    case RAMP_SERVICE_MATERIAL_TO_PIXEL:
        return pD3DCtx->RampMaterialToPixel((D3DMATERIALHANDLE) arg1, (DWORD*) arg2);
    case RAMP_SERVICE_SCENE_CAPTURE:
        return pD3DCtx->RampSceneCapture((DWORD)arg1, (LPDIRECT3DDEVICEI)arg2);
    case RAMP_SERVICE_PALETTE_CHANGED:
        return pD3DCtx->RampPaletteChanged((D3DTEXTUREHANDLE)arg1);
    case RAMP_SERVICE_CLEAR_TEX_RECT:
        return pD3DCtx->RampClearTexRect((D3DMATERIALHANDLE)arg1, (LPD3DRECT)arg2);
    default:
        D3D_ERR("(Rast) Invalid Service type passed to RastRampService");
        return DDERR_GENERIC;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastService
//
// Generic Rasterizer service call.
//
// Only use currently is to compute the RGB8 clear color, which requires
// accessing an internal ramp map.
//
//----------------------------------------------------------------------------

HRESULT
RastService(ULONG_PTR dwCtx,
                RastServiceType srvType, DWORD arg1, LPVOID arg2)
{
    D3DContext *pD3DCtx = (D3DContext *)dwCtx;

    switch (srvType)
    {
    case RAST_SERVICE_RGB8COLORTOPIXEL    :
        return pD3DCtx->RGB8ColorToPixel((D3DCOLOR) arg1, (DWORD*)arg2);
    default:
        D3D_ERR("(Rast) Invalid Service type passed to RastService");
        return DDERR_GENERIC;
    }
}

inline HRESULT
D3DContext::RampCreateMaterial(D3DMATERIALHANDLE hMat)
{
    return RLDDIRampCreateMaterial(
                        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv,
                        hMat,
                        &(m_RastCtx));
}

inline HRESULT
D3DContext::RampDestroyMaterial(D3DMATERIALHANDLE hMat)
{
    return RLDDIRampDestroyMaterial(
                        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv,
                        hMat);
}

inline HRESULT
D3DContext::RampMaterialChanged(D3DMATERIALHANDLE hMat)
{
    RLDDIRampLightingDriver *pLtDriver =
        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;
    if (pLtDriver)
    {
        // Update the material
        HRESULT hr = RLDDIRampMaterialChanged(pLtDriver, hMat);

        RampUpdateRangeInfo();

        return hr;
    }
    else
    {
        return DDERR_GENERIC;
    }
}

inline HRESULT
D3DContext::RampSetLightstate(UINT32 uState, LPVOID pVal)
{
    RLDDIRampLightingDriver *pRampdrv =
        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;
    // d3dim has alreay filtered out invlaid light states
    switch (uState)
    {
    case D3DLIGHTSTATE_MATERIAL:
        RampSetMaterial(*((LPD3DMATERIALHANDLE)pVal));
        break;
    case D3DLIGHTSTATE_AMBIENT:
        {
            D3DCOLOR Color = *((D3DCOLOR*)pVal);
            pRampdrv->driver.ambient = (FLOAT)(RGBA_GETRED(Color) * 0x4c + RGBA_GETGREEN(Color) * 0x96 +
                RGBA_GETBLUE(Color) * 0x1d) * (1.0F/(256.0F*255.0F));
        }
        break;
    case D3DLIGHTSTATE_FOGMODE:
        pRampdrv->driver.fog_mode = *((D3DFOGMODE*)pVal);
        break;
    case D3DLIGHTSTATE_FOGSTART:
        pRampdrv->driver.fog_start = *((FLOAT*)pVal);
        break;
    case D3DLIGHTSTATE_FOGEND:
        pRampdrv->driver.fog_end = *((FLOAT*)pVal);
        break;
    case D3DLIGHTSTATE_FOGDENSITY:
        pRampdrv->driver.fog_density = *((FLOAT*)pVal);
        break;
    case D3DLIGHTSTATE_COLORMODEL:
        pRampdrv->driver.color_model = *((D3DCOLORMODEL*)pVal);
        break;
    }
    return D3D_OK;
}

inline void
D3DContext::BeginSceneHook(void)
{
    RLDDIRampBeginSceneHook((RLDDIRampLightingDriver*)m_RastCtx.pRampDrv);
    RampUpdateRangeInfo();
}

inline void
D3DContext::EndSceneHook(void)
{
    RLDDIRampEndSceneHook((RLDDIRampLightingDriver*)m_RastCtx.pRampDrv);
}

inline HRESULT
D3DContext::RampMaterialToPixel(D3DMATERIALHANDLE hMat, DWORD* pPixel)
{
    *pPixel = RLDDIRampMaterialToPixel(
                        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv,
                        hMat);
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastClearRamp
//
// This is for RampRast only.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::RampClear(void)
{
    // We only need to call BeginSceneHook here
    BeginSceneHook();

    return D3D_OK;
}

inline void
D3DContext::RampUpdateRangeInfo(void)
{
    RLDDIRampLightingDriver *pLtDriver =
        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;

    if (pLtDriver && pLtDriver->current_material)
    {
        // Update the ramp info. in RastCtx
        pLtDriver->current_material->FindLightingRange(
                             &(m_RastCtx.RampBase),
                             &(m_RastCtx.RampSize),
                             &(m_RastCtx.bRampSpecular),
                             (unsigned long**)&(m_RastCtx.pTexRampMap));

        // Make sure DD Palette is updated after it gets set by FindLightingRange
        RLDDIRampUpdateDDPalette(&m_RastCtx);
    }
}
inline void
D3DContext::RampSetMaterial(D3DMATERIALHANDLE hMat)
{
    RLDDIRampLightingDriver *pLtDriver =
        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;
    RLDDIRampSetMaterial(pLtDriver, hMat);
    // Update the ramp info. in RastCtx
    RampUpdateRangeInfo();
}

inline HRESULT
D3DContext::RampFindLightingRange(RAMP_RANGE_INFO *pRampInfo)
{
    RLDDIRampLightingDriver *pLtDriver =
        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;

    if (pLtDriver && pLtDriver->current_material)
    {
        RampUpdateRangeInfo();

        pRampInfo->base = m_RastCtx.RampBase;
        pRampInfo->size = m_RastCtx.RampSize;
        pRampInfo->specular = m_RastCtx.bRampSpecular;
        pRampInfo->pTexRampMap = m_RastCtx.pTexRampMap;

        return D3D_OK;
    }
    else
    {
        return DDERR_GENERIC;
    }
}

//-----------------------------------------------------------------------------
//
// RampSceneCapture
//
// Called on either begin or end scene to perform needed deferred operations on
// ramp materials and palettes.
//
//-----------------------------------------------------------------------------
inline HRESULT
D3DContext::RampSceneCapture(DWORD dwStart, LPDIRECT3DDEVICEI lpDevI)
{
    // always do begin, so that even materials used on internal begin/end's
    // (like textured fills) get properly aged so they don't go away.
    if (dwStart)
    {
        BeginSceneHook();
    }
    else
    {
        if (!(lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INTERNAL_BEGIN_END))
        {
            EndSceneHook();
        }
    }
    return DD_OK;
}

//---------------------------------------------------------------------
// Builds color index that moste closely matches the D3DCOLOR source color.
// For use in 8 bit RGB mode which requires a palette.
//
// Returns:
//      color index in range 0 to 0xff
//
//---------------------------------------------------------------------
inline HRESULT
D3DContext::RGB8ColorToPixel(D3DCOLOR Color, DWORD* pdwPalIdx)
{
    if ((m_RastCtx.pRampMap == NULL) || (pdwPalIdx == NULL))
    {
        return DDERR_GENERIC;
    }
    INT32 iMapIdx = MAKE_RGB8(RGBA_GETRED(Color), RGBA_GETGREEN(Color), RGBA_GETBLUE(Color));
    iMapIdx &= 0xff;    // RGB8 ramp map always first and only rampmap
    // 8 bit result
    *pdwPalIdx = m_RastCtx.pRampMap[iMapIdx] & 0xff;
    return DD_OK;
}

//---------------------------------------------------------------------
// Causes the texture handle passed to have its colors rebuild, based
// on the new palette.
//
// Returns:
//      color index in range 0 to 0xff
//
//---------------------------------------------------------------------
inline HRESULT
D3DContext::RampPaletteChanged(D3DTEXTUREHANDLE hTex)
{
    RLDDIRampLightingDriver *pLtDriver =
        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;

    return RLDDIRampPaletteChanged(pLtDriver, hTex);
}

//---------------------------------------------------------------------
// Handles legacy non-power of 2 texture fill for clear.
//
// Returns:
//      D3D_OK
//
//---------------------------------------------------------------------
inline HRESULT D3DContext::RampClearTexRect(D3DMATERIALHANDLE hMat, LPD3DRECT pRect)
{
    switch (m_RastCtx.iSurfaceBitCount)
    {
    case 8:
        Ramp_Mono_ScaleImage_8(&m_RastCtx, hMat, pRect);
        break;
    case 16:
        Ramp_Mono_ScaleImage_16(&m_RastCtx, hMat, pRect);
        break;
    case 24:
        Ramp_Mono_ScaleImage_24(&m_RastCtx, hMat, pRect);
        break;
    case 32:
        Ramp_Mono_ScaleImage_32(&m_RastCtx, hMat, pRect);
        break;
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\ramprov.cpp ===
//----------------------------------------------------------------------------
//
// ramprov.cpp
//
// Implements software rasterizer HAL provider.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

extern HRESULT
RastService(ULONG_PTR dwCtx,
                RastServiceType srvType, DWORD arg1, LPVOID arg2);

extern HRESULT
RastRampService(ULONG_PTR dwCtx,
                RastRampServiceType srvType, ULONG_PTR arg1, LPVOID arg2);

extern D3DDEVICEDESC g_nullDevDesc;

#define BUILD_RAMP 1
#define devDesc rampDevDescDX5
#include "getcaps.h"

STDMETHODIMP
RampRastHalProvider::GetCaps(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion)
{
    *pHwDesc = g_nullDevDesc;
    *pHelDesc = rampDevDescDX5;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RampRastHalProvider::GetInterface
//
// Returns driver interface data for opt rast.
//
//----------------------------------------------------------------------------

static D3DHAL_GLOBALDRIVERDATA SwDriverData =
{
    sizeof(D3DHAL_GLOBALDRIVERDATA),
    // The rest is filled in at runtime.
};

static D3DHAL_CALLBACKS RampRastCallbacks =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateRamp,
    RastContextDestroyRamp,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    RastTextureSwap,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS2 RampRastCallbacks2 =
{
    sizeof(D3DHAL_CALLBACKS2),
    D3DHAL2_CB32_SETRENDERTARGET |
        D3DHAL2_CB32_DRAWONEPRIMITIVE |
        D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE |
        D3DHAL2_CB32_DRAWPRIMITIVES,
    RastSetRenderTarget,
    NULL,
    RastDrawOnePrimitive,
    RastDrawOneIndexedPrimitive,
    RastDrawPrimitives
};

static D3DHAL_CALLBACKS3 RampRastCallbacks3 =
{
    sizeof(D3DHAL_CALLBACKS3),
    D3DHAL3_CB32_DRAWPRIMITIVES2,
    NULL, // Clear2
    NULL, // lpvReserved
    NULL, // ValidateTextureStageState
    RastDrawPrimitives2,  // DrawVB
};

//----------------------------------------------------------------------------
//
// TextureFormats
//
// Returns all the texture formats supported by our rasterizer.
// Right now, it's called at device creation time to fill the driver gloabl
// data.
//
//----------------------------------------------------------------------------

#define NUM_RAMP_SUPPORTED_TEXTURE_FORMATS   2

int
RampTextureFormats(LPDDSURFACEDESC* lplpddsd)
{
    static DDSURFACEDESC ddsd[NUM_RAMP_SUPPORTED_TEXTURE_FORMATS];

    int i = 0;

    /* pal8 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;

    i++;

    /* pal4 */
//  although ramp supports the pal4 (and 16 bit texture formats, for copy)
//  texture format, it must not be enumerated for backwards compatibility
//
//    ddsd[i].dwSize = sizeof(ddsd[0]);
//    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
//    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
//    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
//    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED4 | DDPF_RGB;
//    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 4;
//
//    i++;

    *lplpddsd = ddsd;

    return i;
}

// Note: because ramp ZBuffer Formats are different than the standard ones
// used by the other rasterizers, it is impossible for DDHEL to properly validate
// zbuffer creation for the case of ramp (because the ramp device may have not
// been created at zbuffer creation time), so Direct3DCreateDevice has a special check
// to invalidate the zformats (i.e. stencil) not accepted by ramp

#define NUM_SUPPORTED_ZBUFFER_FORMATS  1

int
RampZBufferFormats(DDPIXELFORMAT** ppDDPF)
{
    static DDPIXELFORMAT DDPF[NUM_SUPPORTED_ZBUFFER_FORMATS];

    int i = 0;

    /* 16 bit Z; no stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER;
    DDPF[i].dwZBufferBitDepth = 16;
    DDPF[i].dwStencilBitDepth = 0;
    DDPF[i].dwZBitMask = 0xffff;
    DDPF[i].dwStencilBitMask = 0x0000;

    i++;
    *ppDDPF = DDPF;

    return i;
}

STDMETHODIMP
RampRastHalProvider::GetInterface(THIS_
                                 LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                                 LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                                 DWORD dwVersion)
{

    memcpy(&SwDriverData.hwCaps, &rampDevDescDX5, sizeof(SwDriverData.hwCaps));
    SwDriverData.dwNumVertices = BASE_VERTEX_COUNT;
    SwDriverData.dwNumClipVertices = MAX_CLIP_VERTICES;
    SwDriverData.dwNumTextureFormats =
        RampTextureFormats(&SwDriverData.lpTextureFormats);
    pInterfaceData->pGlobalData = &SwDriverData;

    pInterfaceData->pExtCaps = NULL;

    pInterfaceData->pCallbacks = &RampRastCallbacks;
    pInterfaceData->pCallbacks2 = &RampRastCallbacks2;
    pInterfaceData->pCallbacks3 = &RampRastCallbacks3;
    pInterfaceData->pfnRampService = RastRampService;
    pInterfaceData->pfnRastService = RastService;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\sources.inc ===
TARGETNAME = rd3dif
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;..\..\refrast;..\..\rampmat;$(D3DROOT)\pipeln\inc;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        ..\d3dif.cpp\
        ..\swprov.cpp\
        ..\drawprim.cpp\
        $O\dprim2.cpp\
        ..\rendprim.cpp\
        ..\rastctx.cpp\
        ..\rasttex.cpp\
        ..\ramprov.cpp\
        ..\rampif.cpp\
        $O\pmfns.cpp\
        $O\nullif.cpp

NTTARGETFILE0 = \
        $O\pmfns_mh.h\
        $O\pmfns.cpp\
        $O\dprim2.cpp\
        $O\nullif.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\rasttex.cpp ===
//----------------------------------------------------------------------------
//
// rasttex.cpp
//
// Texture functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// SetSizesSpanTexture
//
// Initialize pSpanTex data using current iMaxMipLevel info, Getting the
// surfaces from pSurf.  Assumes InitSpanTexture has been called first.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::SetSizesSpanTexture(PD3DI_SPANTEX pSpanTex)
{
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);
    LPDIRECTDRAWSURFACE pDDS = pSpanTex->pSurf[iFirstSurf];
    INT i;

    // Init
    pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;

    pSpanTex->iSizeU = (INT16)DDSurf_Width(pLcl);
    pSpanTex->iSizeV = (INT16)DDSurf_Height(pLcl);
    pSpanTex->uMaskU = (INT16)(pSpanTex->iSizeU - 1);
    pSpanTex->uMaskV = (INT16)(pSpanTex->iSizeV - 1);
    pSpanTex->iShiftU = (INT16)IntLog2(pSpanTex->iSizeU);
    if (0 != DDSurf_BitDepth(pLcl))
    {
        pSpanTex->iShiftPitch[0] =
                (INT16)IntLog2((UINT32)(DDSurf_Pitch(pLcl) * 8)/DDSurf_BitDepth(pLcl));
    }
    else
    {
        pSpanTex->iShiftPitch[0] =
                (INT16)IntLog2(((UINT32)DDSurf_Width(pLcl) * 8));
    }
    pSpanTex->iShiftV = (INT16)IntLog2(pSpanTex->iSizeV);
    pSpanTex->uMaskV = pSpanTex->uMaskV;

    // Check if the texture size is power of 2
    if (!ValidTextureSize(pSpanTex->iSizeU, pSpanTex->iShiftU,
                          pSpanTex->iSizeV, pSpanTex->iShiftV))
    {
        // this texture can only be used for a ramp fill
        pSpanTex->uFlags |= D3DI_SPANTEX_NON_POWER_OF_2;
        pSpanTex->cLODTex = 0;
    }

    // Check for mipmap if any.
    // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
    // mipmap. They are init'ed with the first texture size.
    INT16 iPreSizeU = pSpanTex->iSizeU, iPreSizeV = pSpanTex->iSizeV;
    for ( i = iFirstSurf + 1; i <= pSpanTex->cLODTex; i++)
    {
        pDDS = pSpanTex->pSurf[i];
        // Check for invalid mipmap texture size
        pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;
        if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width(pLcl)) ||
            !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height(pLcl)))
        {
            return DDERR_INVALIDPARAMS;
        }
        if (0 != DDSurf_BitDepth(pLcl))
        {
            pSpanTex->iShiftPitch[i - iFirstSurf] =
                (INT16)IntLog2(((UINT32)DDSurf_Pitch(pLcl)*8)/DDSurf_BitDepth(pLcl));
        }
        else
        {
            pSpanTex->iShiftPitch[0] =
                (INT16)IntLog2(((UINT32)DDSurf_Width(pLcl)*8));
        }
        iPreSizeU = (INT16)DDSurf_Width(pLcl);
        iPreSizeV = (INT16)DDSurf_Height(pLcl);
    }
    pSpanTex->iMaxScaledLOD = ((pSpanTex->cLODTex + 1) << LOD_SHIFT) - 1;
    pSpanTex->uFlags &= ~D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// InitSpanTexture
//
// Initializes the entire array of pSurf's (regardless of iMaxMipLevel) pointed
// to by the root surface of pDDS.  Sets all pSpanTex state that will not ever
// change in SetSizesSpanTexture.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::InitSpanTexture(PD3DI_SPANTEX pSpanTex, LPDIRECTDRAWSURFACE pDDS)
{
    HRESULT hr;
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    DDSCAPS ddscaps;
    static INT32 iGeneration = 0;

    // Init
    pSpanTex->iGeneration = iGeneration++;

    // Note that all pSpanTex elements are initialized to 0
    pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;

    // Set the transparent bit and the transparent color with pSurf[0]
    // initially
    if ((pLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) != 0)
    {
        pSpanTex->uFlags |= D3DI_SPANTEX_HAS_TRANSPARENT;
        pSpanTex->TransparentColor =
            pLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
    }
    else
    {
        pSpanTex->uFlags &= ~D3DI_SPANTEX_HAS_TRANSPARENT;
    }

    HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLcl)), &(pSpanTex->Format)));

    if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8 ||
        pSpanTex->Format == D3DI_SPTFMT_PALETTE4)
    {
        if (pLcl->lpDDPalette)
        {
            LPDDRAWI_DDRAWPALETTE_GBL   pPal = pLcl->lpDDPalette->lpLcl->lpGbl;
            if (pPal->dwFlags & DDRAWIPAL_ALPHA)
            {
                pSpanTex->uFlags |= D3DI_SPANTEX_ALPHAPALETTE;
            }
            pSpanTex->pPalette = (PUINT32)pPal->lpColorTable;
        }
        if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8)
        {
            pSpanTex->iPaletteSize = 256;
        }
        else
        {
            // PALETTE4
            pSpanTex->iPaletteSize = 16;
        }
    }
    pSpanTex->TexAddrU = D3DTADDRESS_WRAP;
    pSpanTex->TexAddrV = D3DTADDRESS_WRAP;
    pSpanTex->BorderColor = RGBA_MAKE(0xff, 0x00, 0xff, 0xff);

    // assign first pSurf here (mipmap chain gets assigned below)
    pSpanTex->pSurf[0] = pDDS;

    // Check for mipmap if any.
    LPDIRECTDRAWSURFACE pTmpS;
    // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
    // mipmap. They are init'ed with the first texture size.
    INT16 iPreSizeU = pSpanTex->iSizeU, iPreSizeV = pSpanTex->iSizeV;
    for (;;)
    {
        memset(&ddscaps, 0, sizeof(DDSCAPS));
        ddscaps.dwCaps = DDSCAPS_TEXTURE;
        hr = pDDS->GetAttachedSurface(&ddscaps, &pTmpS);    //implicit AddRef
        if (hr == DDERR_NOTFOUND)
        {
            break;
        }
        else if (hr != D3D_OK)
        {
            return hr;
        }
        pDDS = pTmpS;

        pSpanTex->cLODTex ++;
        pSpanTex->pSurf[pSpanTex->cLODTex] = pTmpS;
    }

    pSpanTex->dwSize = sizeof(D3DI_SPANTEX);

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RemoveTexture
//
// Check to see if the to-be-destroyed pSpanTex is currently used by the
// context. If yes, set the according entry to be NULL to disable texture.
//
//----------------------------------------------------------------------------
void D3DContext::RemoveTexture(PD3DI_SPANTEX pSpanTex)
{
    INT i;
    INT cActTex = (INT)m_RastCtx.cActTex;

    for (i = 0; i < cActTex; i++)
    {
        if (m_RastCtx.pTexture[i] == pSpanTex)
        {
            // NULL out the according texture and set dirty bits
            m_RastCtx.cActTex --;
            StateChanged(D3DRENDERSTATE_TEXTUREHANDLE);
            m_RastCtx.pTexture[i] = NULL;
            for (int j=pSpanTex->cLODTex;j>0;j--)   //release attached surfs
            {
                pSpanTex->pSurf[j]->Release();
            }
        }
    }
}
//----------------------------------------------------------------------------
//
// RastTextureCreate
//
// Creates a RAST texture and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureCreate(LPD3DHAL_TEXTURECREATEDATA pTexData)
{
    PD3DI_SPANTEX *ppSpanTex;
    PD3DI_SPANTEX pSpanTex;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureCreate", pTexData);

    // Create the span texture
    ppSpanTex = new PD3DI_SPANTEX;
    pSpanTex = new D3DI_SPANTEX;
    if (ppSpanTex == NULL || pSpanTex == NULL)
    {
        delete ppSpanTex;
        delete pSpanTex;
        D3D_ERR("(Rast) Out of memory in RastTextureCreate");
        pTexData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }
    memset(pSpanTex, 0, sizeof(D3DI_SPANTEX));

    // Point indirector to this texture initially.
    *ppSpanTex = pSpanTex;

    // Init the span texture
    if ((pTexData->ddrval = pDCtx->InitSpanTexture(pSpanTex, pTexData->lpDDS))
        != D3D_OK)
    {
        delete ppSpanTex;
        delete pSpanTex;
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pTexData->ddrval = pDCtx->SetSizesSpanTexture(pSpanTex))
        != D3D_OK)
    {
        delete ppSpanTex;
        delete pSpanTex;
        return DDHAL_DRIVER_HANDLED;
    }

    // ppSpanTex is used as the texture handle returned to d3dim.
    pTexData->dwHandle = (UINT32)(ULONG_PTR)ppSpanTex;

    pTexData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastTextureDestroy
//
// Destroy a RAST texture.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pTexDestroyData)
{
    PD3DI_SPANTEX *ppSpanTex;
    PD3DI_SPANTEX pSpanTex;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureDestroy", pTexDestroyData);
    if (!VALID_D3DI_SPANTEX_PTR_PTR(
        (PD3DI_SPANTEX*)ULongToPtr(pTexDestroyData->dwHandle)))
    {
        D3D_ERR("(Rast) in RastTextureDestroy, invalid texture handle");
        pTexDestroyData->ddrval = DDERR_INVALIDPARAMS;
        return DDHAL_DRIVER_HANDLED;
    }

    // Find the texture
    ppSpanTex = (PD3DI_SPANTEX *)ULongToPtr(pTexDestroyData->dwHandle);
    pSpanTex = *ppSpanTex;

    pDCtx->RemoveTexture(pSpanTex);

    // Delete it
    if (pSpanTex)
    {
        delete ppSpanTex;
        delete pSpanTex;
    }
    else
    {
        pTexDestroyData->ddrval = DDERR_INVALIDPARAMS;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastTextureSwap
//
// Swaps over the ownership of two texture handles.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureSwap(LPD3DHAL_TEXTURESWAPDATA pTexSwapData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureSwap", pTexSwapData);

    // Check out the span textures
    PD3DI_SPANTEX pSpanTex1, pSpanTex2;
    pSpanTex1 = HANDLE_TO_SPANTEX(pTexSwapData->dwHandle1);
    pSpanTex2 = HANDLE_TO_SPANTEX(pTexSwapData->dwHandle2);

    // Swap
    if (pSpanTex1 != NULL && pSpanTex2 != NULL)
    {
        HANDLE_TO_SPANTEX(pTexSwapData->dwHandle1) = pSpanTex2;
        HANDLE_TO_SPANTEX(pTexSwapData->dwHandle2) = pSpanTex1;
        pTexSwapData->ddrval = D3D_OK;
    }
    else
    {
        pTexSwapData->ddrval = DDERR_INVALIDPARAMS;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastTextureGetSurf
//
// Returns the surface pointer associate with a texture handle.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pTexGetSurf)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureGetSurf", pTexGetSurf);

    // Check out the span texture
    PD3DI_SPANTEX pSpanTex;
    pSpanTex = HANDLE_TO_SPANTEX(pTexGetSurf->dwHandle);

    if (pSpanTex)
    {
        pTexGetSurf->lpDDS = (UINT_PTR)pSpanTex->pSurf[0];
        pTexGetSurf->ddrval = D3D_OK;
    }
    else
    {
        pTexGetSurf->ddrval = DDERR_INVALIDPARAMS;
    }
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastLockSpanTexture
//
// Lock current texture surface before the texture bits are accessed.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::RastLockSpanTexture(void)
{
    INT i, j;
    PD3DI_SPANTEX pSpanTex;
    HRESULT hr;

    if (IsTextureOff())
    {
        return D3D_OK;
    }

    DDASSERT((m_uFlags & D3DCONTEXT_TEXTURE_LOCKED) == 0);

    for (j = 0;
        j < (INT)m_RastCtx.cActTex;
        j++)
    {
        pSpanTex = m_RastCtx.pTexture[j];
        if (pSpanTex->uFlags & D3DI_SPANTEX_MAXMIPLEVELS_DIRTY)
        {
            hr = SetSizesSpanTexture(pSpanTex);
            if (hr != D3D_OK)
            {
                goto EH_Unlock;
            }
        }
        INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);

        // Currently recursive locks are not allowed.
        DDASSERT((pSpanTex->uFlags & D3DI_SPANTEX_SURFACES_LOCKED) == 0);

        for (i = iFirstSurf; i <= pSpanTex->cLODTex; i++)
        {
            hr = LockSurface(pSpanTex->pSurf[i],
                            (LPVOID*)&(pSpanTex->pBits[i-iFirstSurf]));
            if (hr != D3D_OK)
            {
                // Unlock any partial mipmap locks we've taken, as
                // RastUnlock can only handle entire textures being
                // locked or unlocked.
                while (--i >= 0)
                {
                    UnlockSurface(pSpanTex->pSurf[i]);
                }

                // Make sure that i is signed and that the above
                // loop exited properly.
                DDASSERT(i < 0);

                goto EH_Unlock;
            }
        }

        pSpanTex->uFlags |= D3DI_SPANTEX_SURFACES_LOCKED;
    }

    m_uFlags |= D3DCONTEXT_TEXTURE_LOCKED;

    return D3D_OK;

 EH_Unlock:
    if (j > 0)
    {
        // Unlock complete textures we've already locked.
        // RastUnlock will check the flags to figure
        // out which ones to unlock.
        RastUnlockSpanTexture();
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// RastUnlockTexture
//
// Unlock texture surface after the texture bits are accessed.
// The input is a D3DI_SPANTEX. NULL texture needs to be checked before this
// function gets called.
//
//----------------------------------------------------------------------------
void
D3DContext::RastUnlockSpanTexture(void)
{
    INT i, j;
    PD3DI_SPANTEX pSpanTex;;

    if (IsTextureOff())
    {
        return;
    }

    DDASSERT((m_uFlags & D3DCONTEXT_TEXTURE_LOCKED) != 0);

    for (j = 0;
        j < (INT)m_RastCtx.cActTex;
        j++)
    {
        pSpanTex = m_RastCtx.pTexture[j];

        INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);
        // RastUnlock is used for cleanup in RastLock so it needs to
        // be able to handle partially locked mipmap chains.
        if (pSpanTex->uFlags & D3DI_SPANTEX_SURFACES_LOCKED)
        {
            for (i = iFirstSurf; i <= pSpanTex->cLODTex; i++)
            {
                UnlockSurface(pSpanTex->pSurf[i]);
            }

            pSpanTex->uFlags &= ~D3DI_SPANTEX_SURFACES_LOCKED;
        }
    }
    m_uFlags &= ~D3DCONTEXT_TEXTURE_LOCKED;
}

//----------------------------------------------------------------------------
//
// UpdateColorKeyAndPalette
//
// Updates the color key value and palette.
//
// Also, if the ColorKey enable for the texture has changed, set the texture handle
// dirty bit so the new mode is recognized in span init.
//
//----------------------------------------------------------------------------
void
D3DContext::UpdateColorKeyAndPalette(void)
{
    INT j;
    PD3DI_SPANTEX pSpanTex;

    // Set the transparent bit and the transparent color with pSurf[0]
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    for (j = 0;
        j < (INT)m_RastCtx.cActTex;
        j++)
    {
        pSpanTex = m_RastCtx.pTexture[j];
        if ((pSpanTex != NULL) && (pSpanTex->pSurf[0] != NULL))
        {
            pLcl = ((LPDDRAWI_DDRAWSURFACE_INT) pSpanTex->pSurf[0])->lpLcl;

            // Palette might be changed
            if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8 ||
                    pSpanTex->Format == D3DI_SPTFMT_PALETTE4)
            {
                    if (pLcl->lpDDPalette)
                    {
                            LPDDRAWI_DDRAWPALETTE_GBL   pPal = pLcl->lpDDPalette->lpLcl->lpGbl;
                            if (pPal->dwFlags & DDRAWIPAL_ALPHA)
                            {
                                    pSpanTex->uFlags |= D3DI_SPANTEX_ALPHAPALETTE;
                            }
                            pSpanTex->pPalette = (PUINT32)pPal->lpColorTable;
                    }
            }

            if ((pLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) != 0)
            {
                // texture has a ColorKey value
                pSpanTex->TransparentColor =
                    pLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                if (!(pSpanTex->uFlags & D3DI_SPANTEX_HAS_TRANSPARENT))
                {
                    pSpanTex->uFlags |= D3DI_SPANTEX_HAS_TRANSPARENT;

                    // make sure this state change is recognized, and a new
                    // texture read function is used
                    StateChanged(D3DHAL_TSS_OFFSET(j, D3DTSS_TEXTUREMAP));
                }
            }
            else
            {
                // texture does not have a ColorKey value
                if (pSpanTex->uFlags & D3DI_SPANTEX_HAS_TRANSPARENT)
                {
                    pSpanTex->uFlags &= ~D3DI_SPANTEX_HAS_TRANSPARENT;

                    // make sure this state change is recognized, and a new
                    // texture read function is used
                    StateChanged(D3DHAL_TSS_OFFSET(j, D3DTSS_TEXTUREMAP));
                }
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// Dp2TextureStageState
//
// Called by Drawprim2 to set texture stage states..
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::Dp2TextureStageState(LPD3DHAL_DP2COMMAND pCmd, DWORD dwFvf)
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr;
    LPD3DHAL_DP2TEXTURESTAGESTATE pTexStageState =
                                    (D3DHAL_DP2TEXTURESTAGESTATE  *)(pCmd + 1);
    // Flush the prim proc before any state changs
    HR_RET(End(FALSE));

    for (i = 0; i < (INT)wStateCount; i++, pTexStageState++)
    {
        HR_RET(SetRenderState(D3DHAL_TSS_OFFSET((DWORD)pTexStageState->wStage,
                                              (DWORD)pTexStageState->TSState),
                            pTexStageState->dwValue));
    }

    HR_RET(CheckFVF(dwFvf));

    hr = Begin();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\rastctx.cpp ===
//----------------------------------------------------------------------------
//
// rastctx.cpp
//
// Context functions + state functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "rampif.h"
#include "rampmat.hpp"

// Unlock previous texture if necessary. It's called before the texture handle
// is going to be changed.
#define CHECK_AND_UNLOCK_TEXTURE    \
{   \
    if (m_uFlags & D3DCONTEXT_TEXTURE_LOCKED)   \
    {   \
        RastUnlockSpanTexture();    \
    }   \
}

inline void
D3DContext::RampSetFogData(UINT32 uState, UINT32 uStateVal)
{
    RLDDIRampLightingDriver *pRampdrv =
                        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;
    if (pRampdrv != NULL)
    {
        switch(uState)
        {
        case D3DRENDERSTATE_FOGENABLE      :
            pRampdrv->fog_enable = uStateVal;
            break;
        case D3DRENDERSTATE_FOGCOLOR       :
            pRampdrv->fog_color = uStateVal;
            break;
        case D3DRENDERSTATE_FOGTABLEMODE   :
            pRampdrv->driver.fog_mode = (D3DFOGMODE)uStateVal;
            break;
        case D3DRENDERSTATE_FOGTABLESTART  :
            pRampdrv->driver.fog_start = (FLOAT)uStateVal;
            break;
        case D3DRENDERSTATE_FOGTABLEEND    :
            pRampdrv->driver.fog_end = (FLOAT)uStateVal;
            break;
        case D3DRENDERSTATE_FOGTABLEDENSITY:
            pRampdrv->driver.fog_density = (FLOAT)uStateVal;
            break;
        }
    }
}

//----------------------------------------------------------------------------
//
// FillContext
//
// Fill the context with the info. from the surfaces.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::FillContext(LPDIRECTDRAWSURFACE pDDS,
                               LPDIRECTDRAWSURFACE pDDSZ)
{
    HRESULT hr;

    LPDDRAWI_DDRAWSURFACE_LCL pLcl =
        ((LPDDRAWI_DDRAWSURFACE_INT)(pDDS))->lpLcl;
    m_RastCtx.iSurfaceStride = DDSurf_Pitch(pLcl);
    m_RastCtx.iSurfaceBitCount = DDSurf_BitDepth(pLcl);
    m_RastCtx.iSurfaceStep = m_RastCtx.iSurfaceBitCount/8;
    HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLcl)),
        (D3DI_SPANTEX_FORMAT *)&(m_RastCtx.iSurfaceType)));
    m_RastCtx.Clip.left = m_RastCtx.Clip.top = 0;
    m_RastCtx.Clip.bottom = DDSurf_Height(pLcl);
    m_RastCtx.Clip.right = DDSurf_Width(pLcl);

    if (pDDSZ != NULL)
    {
        pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pDDSZ))->lpLcl;
        m_RastCtx.pZBits = (PUINT8)SURFACE_MEMORY(pDDSZ);
        m_RastCtx.iZStride = DDSurf_Pitch(pLcl);
        m_RastCtx.iZBitCount = DDSurf_BitDepth(pLcl);
        m_RastCtx.iZStep = m_RastCtx.iZBitCount/8;
    }
    else
    {
        m_RastCtx.pZBits = NULL;
        m_RastCtx.iZStride = 0;
        m_RastCtx.iZBitCount = 0;
        m_RastCtx.iZStep = 0;
    }

    m_RastCtx.pDDS = pDDS;
    m_RastCtx.pDDSZ = pDDSZ;

    m_RastCtx.dwSize = sizeof(D3DI_RASTCTX);

    // Make sure SpanInit is called at least once
    SetAllStatesDirtyBits();

    // Check for MsGolf AppHack
    if (pLcl->lpSurfMore->lpDD_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_FORCEMODULATED)
    {
        m_RastCtx.uFlags |= RASTCTXFLAGS_APPHACK_MSGOLF;
    }

    return D3D_OK;
}

HRESULT
D3DContext::Initialize(LPDIRECTDRAWSURFACE pDDS,
                       LPDIRECTDRAWSURFACE pDDSZ,
                       DWORD BeadSet,
                       DWORD devVer)
{
    HRESULT hr;

    // Initialize the primitive processor.
    HR_RET(m_PrimProc.Initialize());

    memset(&m_RastCtx, 0, sizeof(m_RastCtx));

    m_uFlags = 0;
    HR_RET(FillContext(pDDS, pDDSZ));

    m_PrimProc.SetCtx(&m_RastCtx);

    dwSize = sizeof(D3DContext);

    // Initialize bead table enum
    m_RastCtx.BeadSet = (D3DI_BEADSET)BeadSet;

    STATESET_INIT(m_renderstate_override);

    // Init FVF data as legacy TL vertex
    m_fvfData.preFVF = -1;
    CheckFVF(D3DFVF_TLVERTEX);

    m_RastCtx.uDevVer = devVer;

    // All render and texture stage state is initialized by
    // DIRECT3DDEVICEI::stateInitialize

    // Init prim function table. It will be updated for RAMP, or when FVF
    // control word changes or when fill mode changes.
    m_fnPrims.pfnTri = RGB_TriNoPackSolid;
    m_fnPrims.pfnPoint = RGB_PointNoPack;
    m_fnPrims.pfnLine = RGB_LineNoPack;
    // This one should be always the same.
    m_fnPrims.pfnStoreLastPixelState = RGBRAMP_StoreLastPixelState;
    m_fnPrims.pfnDp2SetRenderStates = RGBRAMP_Dp2SetRenderStates;
    m_fnPrims.pfnDp2TextureStageState = RGBRAMP_Dp2TextureStageState;
    m_fnPrims.pfnDp2SetViewport = RGBRAMP_Dp2SetViewport;
    m_fnPrims.pfnDp2SetWRange = RGBRAMP_Dp2SetWRange;

    // Enable MMX Fast Paths (Monolithics) if a registry key for it is not 0
    m_RastCtx.dwMMXFPDisableMask[0] = 0x0;       // enable MMX FP's by default
    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey) )
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwDisableMask[MMX_FP_DISABLE_MASK_NUM] = {0x0};
        DWORD dwSize = 4;

        // only code up looking at one mask, for now
        DDASSERT(MMX_FP_DISABLE_MASK_NUM == 1);

        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "MMXFPDisableMask0", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD )
        {
           dwDisableMask[0] = dwValue;
        }
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "MMX Fast Path", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD)
        {
            if (dwValue == 0)
            {
                // Override MMXFPDisableMask0 and disable all MMX Fast Paths
                m_RastCtx.dwMMXFPDisableMask[0] = 0xffffffff;
            }
            else
            {
                // Take all MMX paths not disabled by MMXFPDisableMask0
                m_RastCtx.dwMMXFPDisableMask[0] = dwDisableMask[0];
            }
        }

        RegCloseKey( hKey );
    }

    return D3D_OK;
}

HRESULT
D3DContext::SetViewport(LPD3DHAL_DP2VIEWPORTINFO pVpt)
{
    m_RastCtx.Clip.left = pVpt->dwX;
    m_RastCtx.Clip.top = pVpt->dwY;
    m_RastCtx.Clip.bottom = pVpt->dwY + pVpt->dwHeight;
    m_RastCtx.Clip.right = pVpt->dwX + pVpt->dwWidth;
    return D3D_OK;
}

inline HRESULT
D3DContext::CreateRampLightingDriver(void)
{
    m_RastCtx.pRampDrv = RLDDIRampCreate(&m_RastCtx);

    if (m_RastCtx.pRampDrv == NULL)
    {
        return DDERR_OUTOFMEMORY;
    }
    else
    {
        return D3D_OK;
    }
}

inline void
D3DContext::DestroyRampLightingDriver(void)
{
    RLDDIRampDestroy((RLDDIRampLightingDriver*)m_RastCtx.pRampDrv);
    m_RastCtx.pRampDrv = NULL;
}

//----------------------------------------------------------------------------
//
// RastContextCreateC
//
// Calls RastContextCreate with the C bead set.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateC(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_C);
}

//----------------------------------------------------------------------------
//
// RastContextCreateCMMX
//
// Calls RastContextCreate with the CMMX bead set.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateCMMX(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_CMMX);
}

//----------------------------------------------------------------------------
//
// RastContextCreateMMX
//
// Calls RastContextCreate with the MMX bead set.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateMMX(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_MMX);
}

//----------------------------------------------------------------------------
//
// RastContextCreateMMXAsRGB
//
// Calls RastContextCreate with the MMX bead set, but remember that we
// came from RGB.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateMMXAsRGB(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_MMXASRGB);
}

//----------------------------------------------------------------------------
//
// RastContextCreateRamp
//
// Calls RastContextCreate with the ramp bead set.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateRamp(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    HRESULT hr;

    hr = RastContextCreate(pCtxData, (DWORD)D3DIBS_RAMP);

    if (pCtxData->ddrval != D3D_OK)
    {
        return hr;
    }

    // Create a RampLightingDriver
    D3DContext *pDCtx = (D3DContext *)pCtxData->dwhContext;
    pCtxData->ddrval = pDCtx->CreateRampLightingDriver();

    // Init prim function table for RAMP
    pDCtx->InitRampFuncs();

    return hr;
}

//----------------------------------------------------------------------------
//
// RastContextCreate
//
// Creates a RASTCTX and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData, DWORD BeadSet)
{
    DDASSERT(pCtxData != NULL);

    D3DContext *pDCtx = new D3DContext;

    if (pDCtx == NULL)
    {
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    pCtxData->ddrval =
        pDCtx->Initialize(pCtxData->lpDDS,
                          pCtxData->lpDDSZ,
                          BeadSet,
                          (DWORD)pCtxData->dwhContext);

    pCtxData->dwhContext = (ULONG_PTR)pDCtx;

    PD3DI_RASTCTX pCtx = pDCtx->GetRastCtx();
    if ((D3DI_SPTFMT_PALETTE8 == pCtx->iSurfaceType) &&
        (D3DIBS_RAMP != BeadSet))
    {
        // need a ramp lighting driver for 8 bit palettized RGB output
        pCtxData->ddrval = pDCtx->CreateRampLightingDriver();

        if (pCtxData->ddrval == D3D_OK)
        {
            // initialize the RGB8 palette
            RLDDIRampMakePaletteRGB8((RLDDIRampLightingDriver*)pCtx->pRampDrv);

            // Make sure DD Palette is updated after it gets set by FindLightingRange
            RLDDIRampUpdateDDPalette(pCtx);
        }
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastContextDestroy
//
// Destroy a rast context.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastContextDestroy", pCtxDestroyData);

    PD3DI_RASTCTX pCtx = pDCtx->GetRastCtx();
    if (pCtx->pRampDrv)
    {
        // destroy the ramp lighting driver, if one was created
        pDCtx->DestroyRampLightingDriver();
    }

    delete pDCtx;

    pCtxDestroyData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}


//----------------------------------------------------------------------------
//
// ValidateTextureStageState
//
// Utility function that returns an appropriate D3DERR_ if the current
// multi-texture setup can not be rendered, D3D_OK otherwise.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::ValidateTextureStageState(void)
{
#if DBG
    if ((m_RastCtx.pTexture[0] == m_RastCtx.pTexture[1]) &&
        (m_RastCtx.pTexture[0] != NULL) )
    {
        // except under very special circumstances, this will not work in RGB/MMX
        // since we keep a lot of stage state in the D3DI_SPANTEX structure
        D3D_ERR("(Rast) ValidateTextureStageState Warning, pTexture[0] == pTexture[1]");
    }
#endif
    for (INT i = 0; i < 2; i++)
    {
        switch(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(i,D3DTSS_COLOROP)])
        {
        default:
            return D3DERR_UNSUPPORTEDCOLOROPERATION;
        case D3DTOP_DISABLE:
            return D3D_OK;  // don't have to validate further if the stage is disabled
        case D3DTOP_SELECTARG1:
        case D3DTOP_SELECTARG2:
        case D3DTOP_MODULATE:
        case D3DTOP_MODULATE2X:
        case D3DTOP_MODULATE4X:
        case D3DTOP_ADD:
        case D3DTOP_ADDSIGNED:
        case D3DTOP_BLENDDIFFUSEALPHA:
        case D3DTOP_BLENDTEXTUREALPHA:
        case D3DTOP_BLENDFACTORALPHA:
        case D3DTOP_BLENDTEXTUREALPHAPM:
            break;
        }

        switch(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(i,D3DTSS_COLORARG1)] &
                ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
        {
        default:
            return D3DERR_UNSUPPORTEDCOLORARG;
        case (D3DTA_TEXTURE):
            break;
        }

        switch(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(i,D3DTSS_COLORARG2)] &
                ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
        {
        default:
            return D3DERR_UNSUPPORTEDCOLORARG;
        case (D3DTA_TFACTOR):
        case (D3DTA_CURRENT):
        case (D3DTA_DIFFUSE):
            break;
        }

        switch(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(i,D3DTSS_ALPHAOP)])
        {
        default:
            return D3DERR_UNSUPPORTEDALPHAOPERATION;
        case D3DTOP_DISABLE:
            break;
        case D3DTOP_SELECTARG1:
        case D3DTOP_SELECTARG2:
        case D3DTOP_MODULATE:
        case D3DTOP_MODULATE2X:
        case D3DTOP_MODULATE4X:
        case D3DTOP_ADD:
        case D3DTOP_ADDSIGNED:
        case D3DTOP_BLENDDIFFUSEALPHA:
        case D3DTOP_BLENDTEXTUREALPHA:
        case D3DTOP_BLENDFACTORALPHA:
        case D3DTOP_BLENDTEXTUREALPHAPM:
            // only validate alpha args if alpha op is not disable
            switch(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(i,D3DTSS_ALPHAARG1)] &
                    ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
            {
            default:
                return D3DERR_UNSUPPORTEDALPHAARG;
            case (D3DTA_TEXTURE):
                break;
            }

            switch(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(i,D3DTSS_ALPHAARG2)] &
                    ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
            {
            default:
                return D3DERR_UNSUPPORTEDALPHAARG;
            case (D3DTA_TFACTOR):
            case (D3DTA_CURRENT):
            case (D3DTA_DIFFUSE):
                break;
            }
            break;
        }

    }
    // allow unused state to be zero'ed since this is so common
    if ( !((m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(2,D3DTSS_COLOROP)] == D3DTOP_DISABLE) ||
         (m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(2,D3DTSS_COLOROP)] == 0)) )
    {
        return D3DERR_TOOMANYOPERATIONS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastValidateTextureStageState
//
// Returns whether the current multitexture setup can be rendered and, if
// so, the number of passes required to render it.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastValidateTextureStageState", pData);

    pData->dwNumPasses = 1;

    pData->ddrval = pDCtx->ValidateTextureStageState();

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastContextDestroyRamp
//
// Destroy a rast context.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextDestroyRamp(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastContextDestroy", pCtxDestroyData);

    pDCtx->DestroyRampLightingDriver();

    delete pDCtx;

    pCtxDestroyData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastSetRenderTarget
//
// Update a rast context with the info from a new render target.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastSetRenderTarget", pTgtData);

    pTgtData->ddrval = pDCtx->FillContext(pTgtData->lpDDS, pTgtData->lpDDSZ);

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// SetRenderState
//
// Check to see if a state change requires an update to the D3DCTX.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::SetRenderState(UINT32 uState, UINT32 uStateVal)
{
    // Assume d3dim has filtered out unchanged states
    StateChanged(uState);

    m_RastCtx.pdwRenderState[uState] = uStateVal;

    switch(uState)
    {
    case D3DRENDERSTATE_FOGENABLE      :
    case D3DRENDERSTATE_FOGCOLOR       :
    case D3DRENDERSTATE_FOGTABLEMODE   :
    case D3DRENDERSTATE_FOGTABLESTART  :
    case D3DRENDERSTATE_FOGTABLEEND    :
    case D3DRENDERSTATE_FOGTABLEDENSITY:
        RampSetFogData(uState, uStateVal);
        break;
    case D3DRENDERSTATE_CULLMODE:
        // Set face culling sign from state.
        switch(uStateVal)
        {
        case D3DCULL_CCW:
            m_RastCtx.uCullFaceSign = 1;
            break;
        case D3DCULL_CW:
            m_RastCtx.uCullFaceSign = 0;
            break;
        case D3DCULL_NONE:
            m_RastCtx.uCullFaceSign = 2;
            break;
        }
        break;
    case D3DRENDERSTATE_ZENABLE:
        if ( (D3DZB_FALSE != uStateVal) && (NULL == m_RastCtx.pDDSZ) )
        {
            DPF(0, "(ERROR) (Rast) SetRenderState: Can't set D3DRENDERSTATE_ZENABLE to %d if there is no Z Buffer", uStateVal);
            m_RastCtx.pdwRenderState[uState] = D3DZB_FALSE;
        }
        break;
    case D3DRENDERSTATE_LASTPIXEL:
        // Set last-pixel flag from state.
        if (uStateVal)
        {
            m_PrimProc.SetFlags(PPF_DRAW_LAST_LINE_PIXEL);
        }
        else
        {
            m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);
        }
        break;


        // map legacy modes with one-to-one mappings to texture stage 0
    case D3DRENDERSTATE_TEXTUREADDRESS:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESS)] =
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSU)] =
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSV)] = uStateVal;
        MapTextureStage0State();
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSU:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSU)] = uStateVal;
        MapTextureStage0State();
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSV:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSV)] = uStateVal;
        MapTextureStage0State();
        break;
    case D3DRENDERSTATE_MIPMAPLODBIAS:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPMAPLODBIAS)] = uStateVal;
        MapTextureStage0State();
        break;
    case D3DRENDERSTATE_BORDERCOLOR:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_BORDERCOLOR)] = uStateVal;
        MapTextureStage0State();
        break;

    case D3DRENDERSTATE_TEXTUREMAG:
    case D3DRENDERSTATE_TEXTUREMIN:
        // map legacy filtering/sampling state to texture stage 0
        MapLegacyTextureFilter();
        // assign to current texture
        MapTextureStage0State();
        break;

    case D3DRENDERSTATE_TEXTUREMAPBLEND:
        // map legacy blending state to texture stage 0
        MapLegacyTextureBlend();
        break;

        // map legacy WRAPU/V to per-index controls
    case D3DRENDERSTATE_WRAPU:
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_U;
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] |= ((uStateVal) ? D3DWRAP_U : 0);
        StateChanged(D3DRENDERSTATE_WRAP0);
        break;
    case D3DRENDERSTATE_WRAPV:
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_V;
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] |= ((uStateVal) ? D3DWRAP_V : 0);
        StateChanged(D3DRENDERSTATE_WRAP0);
        break;

//
// NOTE - this compututation of cActTex does not account for blend-only stages
//
    case D3DRENDERSTATE_TEXTUREHANDLE:

        CHECK_AND_UNLOCK_TEXTURE;

        // map handle thru to stage 0
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_TEXTUREMAP)] = uStateVal;
        m_RastCtx.pTexture[1] = NULL;
        // set up for single stage
        if (uStateVal == 0)
        {
            m_RastCtx.pTexture[0] = NULL;
        }
        else
        {
            m_RastCtx.pTexture[0] = HANDLE_TO_SPANTEX(uStateVal);
        }
        // map stage 0 state to first texture
        MapTextureStage0State();
        UpdateActiveTexStageCount();
        break;

    case D3DHAL_TSS_TEXTUREMAP0:
        // Silently zero out legacy handle.  They didn't mean it.
        if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] != 0 &&
            uStateVal != 0)
        {
            m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
        }

        CHECK_AND_UNLOCK_TEXTURE;

        if (uStateVal == 0)
        {
            if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] == 0)
            {
                m_RastCtx.pTexture[0] = NULL;
            }
            // don't set m_RastCtx.pTexture[1] = NULL (in case the handle is never
            // sent again).  cActTex will keep it from being used until pTexture[0] is
            // set to something
        }
        else
        {
#if DBG
            if (HANDLE_TO_SPANTEX(uStateVal) == m_RastCtx.pTexture[1])
            {
                D3D_ERR( "Stage1 and 2 have same texture handle." );
                return DDERR_INVALIDPARAMS;
            }
#endif
            m_RastCtx.pTexture[0] = HANDLE_TO_SPANTEX(uStateVal);
        }

        // map stage 0 state to first texture
        MapTextureStage0State();
        UpdateActiveTexStageCount();
        break;

    case D3DHAL_TSS_TEXTUREMAP1:
        // Silently zero out legacy handle.  They didn't mean it.
        if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] != 0 &&
            uStateVal != 0)
        {
            m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
        }

        CHECK_AND_UNLOCK_TEXTURE;

        if (uStateVal == 0)
        {
            m_RastCtx.pTexture[1] = NULL;
        }
        else
        {
            // 2nd texture can only be enabled if there's an active
            // 1st texture, but computation of cActTex will prevent this
            // from happening
#if DBG
            if (HANDLE_TO_SPANTEX(uStateVal) == m_RastCtx.pTexture[0])
            {
                D3D_ERR( "Stage1 and 2 have same texture handle." );
                return DDERR_INVALIDPARAMS;
            }
#endif
            m_RastCtx.pTexture[1] = HANDLE_TO_SPANTEX(uStateVal);
        }

        // map stage 1 state to second texture
        MapTextureStage1State();
        UpdateActiveTexStageCount();
        break;


    // map single set ADDRESS to both U and V controls for stages 0 & 1
    case D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESS):
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSU)] = uStateVal;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSV)] = uStateVal;
        MapTextureStage0State();
        break;
    case D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESS):
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESSU)] = uStateVal;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESSV)] = uStateVal;
        MapTextureStage1State();
        break;

    case D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSU):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSV):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_MIPMAPLODBIAS):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_MAXMIPLEVEL):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_BORDERCOLOR):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_MAGFILTER):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER):
        MapTextureStage0State();
        break;

    case D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESSU):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESSV):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_MIPMAPLODBIAS):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_MAXMIPLEVEL):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_BORDERCOLOR):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_MAGFILTER):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_MINFILTER):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_MIPFILTER):
        MapTextureStage1State();
        break;

    case D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG1):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG2):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAOP):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG1):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG2):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_COLOROP):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_COLORARG1):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_COLORARG2):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_ALPHAOP):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_ALPHAARG1):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_ALPHAARG2):
        // anything that effects the validity of the texture blending
        // could change the number of active texture stages
        UpdateActiveTexStageCount();
        break;
    }

    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// UpdateActiveTexStageCount - Steps through per-stage renderstate and computes
// a count of currently active texture stages.  For legacy texture, the count
// is at most one.
//
//-----------------------------------------------------------------------------
HRESULT D3DContext::UpdateActiveTexStageCount( void )
{
    HRESULT hr;
    UINT cNewActTex = 0;

    // conservative but correct
    if ((hr = ValidateTextureStageState()) == D3D_OK)
    {
        // always one active texture stage for legacy texture mode
        if ( NULL != m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] )
        {
            cNewActTex = 1;
        }
        else
        {
            // count number of contiguous-from-zero active texture blend stages
            for ( INT iStage=0; iStage<2; iStage++ )
            {
                // check for disabled stage (subsequent are thus inactive)
                // also conservatively checks for incorrectly enabled stage (might be legacy)
                if ( ( m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(iStage,D3DTSS_COLOROP)] == D3DTOP_DISABLE ) ||
                     ( m_RastCtx.pTexture[iStage] == NULL ) )
                {
                    break;
                }

                // stage is active
                cNewActTex ++;
            }
        }
    }
    if (m_RastCtx.cActTex != cNewActTex)
    {
        CHECK_AND_UNLOCK_TEXTURE;
        StateChanged(D3DRENDERSTATE_TEXTUREHANDLE);
        m_RastCtx.cActTex = cNewActTex;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// UpdateRenderStates
//
// Update a list of render states and notify components of state change.
//
//----------------------------------------------------------------------------
HRESULT D3DContext::
UpdateRenderStates(LPDWORD puStateChange, UINT cStateChanges)
{
    HRESULT hr;
    INT i;
    UINT32 State, StateVal;

    if (cStateChanges == 0)
    {
        return D3D_OK;
    }

    // Update the D3DCTX
    for (i = 0; i < (INT)cStateChanges; i++)
    {
        State = *puStateChange ++;
        StateVal = * puStateChange++;
        HR_RET(SetRenderState(State, StateVal));
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// UpdateAllRenderStates
//
// Update all render states.
// It is still kept here because we probably need it in the case of fail-over.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::UpdateAllRenderStates(LPDWORD puStates)
{
    HRESULT hr, hrSet;
    INT i;

    DDASSERT(puStates != NULL);

    // Update D3DCTX.
    // Attempt to set as many states as possible, even if there are
    // errors on some.  This allows context initialization to work
    // even though some of the states fail due to dependencies on
    // other state, such as active texture handles.
    // SetRenderState failures are noted and returned eventually,
    // even if everything else succeeds.
    hrSet = D3D_OK;
    for (i = 0; i < D3DHAL_MAX_RSTATES_AND_STAGES; i++)
    {
        if ((hr = SetRenderState(i, puStates[i])) != D3D_OK)
        {
            hrSet = hr;
        }
    }

    return hrSet;
}

//----------------------------------------------------------------------------
//
// Dp2SetRenderStates
//
// Called by Drawprim2 to set render states..
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::Dp2SetRenderStates(LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates)
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr;
    D3DHAL_DP2RENDERSTATE *pRenderState =
                                    (D3DHAL_DP2RENDERSTATE *)(pCmd + 1);
    // Flush the prim proc before any state changs
    HR_RET(End(FALSE));

    for (i = 0; i < (INT)wStateCount; i++, pRenderState++)
    {
        UINT32 type = (UINT32) pRenderState->RenderState;

        // Check for overrides
        if (IS_OVERRIDE(type)) {
            UINT32 override = GET_OVERRIDE(type);
            if (pRenderState->dwState)
            STATESET_SET(m_renderstate_override, override);
            else
            STATESET_CLEAR(m_renderstate_override, override);
            continue;
        }

        if (STATESET_ISSET(m_renderstate_override, type))
            continue;

        // Set the runtime copy (if necessary)
        if (NULL != lpdwRuntimeRStates)
        {
            lpdwRuntimeRStates[pRenderState->RenderState] = pRenderState->dwState;
        }

            // Set the state
        HR_RET(SetRenderState(pRenderState->RenderState,
                            pRenderState->dwState));
    }

    hr = Begin();
    return hr;
}
//----------------------------------------------------------------------------
//
// Begin - Before rendering preparation
//
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::Begin(void)
{
    HRESULT hr;

    DDASSERT((m_uFlags & D3DCONTEXT_IN_BEGIN) == 0);

    // ATTENTION call this less often?
    UpdateColorKeyAndPalette();

    // Check for state changes
    if (IsAnyStatesChanged())
    {
        // Check for fillmode change
        if (IsStateChanged(D3DRENDERSTATE_FILLMODE))
        {
            UpdatePrimFunctionTbl();
        }

        BOOL bMaxMipLevelsDirty = FALSE;
        for (INT j = 0; j < (INT)m_RastCtx.cActTex; j++)
        {
            PD3DI_SPANTEX pSpanTex = m_RastCtx.pTexture[j];
            if (pSpanTex)
            {
                bMaxMipLevelsDirty = bMaxMipLevelsDirty || (pSpanTex->uFlags & D3DI_SPANTEX_MAXMIPLEVELS_DIRTY);
            }
        }

        if (IsStateChanged(D3DRENDERSTATE_TEXTUREHANDLE) ||
            IsStateChanged(D3DHAL_TSS_TEXTUREMAP0) ||
            IsStateChanged(D3DHAL_TSS_TEXTUREMAP1) ||
            bMaxMipLevelsDirty)
        {
            // Relock texture if texture handles have changed.
            // SetRenderState should have already unlocked the texture.
            if (m_uFlags & D3DCONTEXT_TEXTURE_LOCKED)
            {
                RastUnlockSpanTexture();
            }
            HR_RET(RastLockSpanTexture());
        }

        // Check for WRAP state change
        for (int iWrap=0; iWrap<8; iWrap++)
        {
            D3DRENDERSTATETYPE iWrapState = (D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0+iWrap);
            if (IsStateChanged(iWrapState))
            {
                int i;
                for (i=0; i < 2; i++)
                {
                    if (m_fvfData.TexIdx[i] == iWrap)
                    {
                        m_RastCtx.pdwWrap[i] = m_RastCtx.pdwRenderState[iWrapState];
                    }
                }
            }
        }

        // Notify primitive Processor of state change.
        m_PrimProc.StateChanged();

        // Clear state dirtybits
        ClearAllStatesDirtyBits();

        // Must call SpanInit AFTER texture is locked, since this
        // sets various flags and fields that are needed for bead choosing
        // Call SpanInit to setup the beads
        HR_RET(SpanInit(&m_RastCtx));
    }

    // If texture is not locked yet, lock it
    if (!(m_uFlags & D3DCONTEXT_TEXTURE_LOCKED))
    {
        HR_RET(RastLockSpanTexture());
    }

    // Lock rendering target.
    if ((hr=LockSurface(m_RastCtx.pDDS, (LPVOID *)&(m_RastCtx.pSurfaceBits))) != D3D_OK)
    {
        RastUnlockSpanTexture();
        return hr;
    }
    if (m_RastCtx.pDDSZ != NULL)
    {
        if ((hr=LockSurface(m_RastCtx.pDDSZ, (LPVOID *)&(m_RastCtx.pZBits))) != D3D_OK)
        {
            RastUnlockSpanTexture();
            UnlockSurface(m_RastCtx.pDDS);
            return hr;
        }
    }
    else
    {
        m_RastCtx.pZBits = NULL;
    }

    // Prepare the primitive processor
    m_PrimProc.Begin();
    m_uFlags |= D3DCONTEXT_IN_BEGIN;

    if (m_RastCtx.pRampDrv)
    {
        pTexRampmapSave = m_RastCtx.pTexRampMap;
    }

    return D3D_OK;

}


//-----------------------------------------------------------------------------
//
// MapTextureStage0/1State - Maps state0/stage1 texture state to spantex object
//
//-----------------------------------------------------------------------------
void
D3DContext::MapTextureStage0State( void )
{
    if (m_RastCtx.pTexture[0] == NULL) return;
    //
    // assign texture state from stage 0
    //
    m_RastCtx.pTexture[0]->TexAddrU = (D3DTEXTUREADDRESS)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSU)]);
    m_RastCtx.pTexture[0]->TexAddrV = (D3DTEXTUREADDRESS)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSV)]);
    m_RastCtx.pTexture[0]->BorderColor = (D3DCOLOR)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_BORDERCOLOR)]);
    m_RastCtx.pTexture[0]->uMagFilter = (D3DTEXTUREMAGFILTER)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MAGFILTER)]);
    m_RastCtx.pTexture[0]->uMinFilter = (D3DTEXTUREMINFILTER)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)]);
    m_RastCtx.pTexture[0]->uMipFilter = (D3DTEXTUREMIPFILTER)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)]);
    m_RastCtx.pTexture[0]->cLOD =
        (D3DTFP_NONE == m_RastCtx.pTexture[0]->uMipFilter)
        ? 0 : m_RastCtx.pTexture[0]->cLODTex;
    {
        m_RastCtx.pTexture[0]->fLODBias = m_RastCtx.pfRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPMAPLODBIAS)];
    }
    if (m_RastCtx.pTexture[0]->iMaxMipLevel != (INT32)m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MAXMIPLEVEL)])
    {
        m_RastCtx.pTexture[0]->iMaxMipLevel = (INT32)m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MAXMIPLEVEL)];
        m_RastCtx.pTexture[0]->uFlags |= D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;
    }
}
void
D3DContext::MapTextureStage1State( void )
{
    if (m_RastCtx.pTexture[1] == NULL) return;
    //
    // assign texture state from stage 0
    //
    m_RastCtx.pTexture[1]->TexAddrU = (D3DTEXTUREADDRESS)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESSU)]);
    m_RastCtx.pTexture[1]->TexAddrV = (D3DTEXTUREADDRESS)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESSV)]);
    m_RastCtx.pTexture[1]->BorderColor = (D3DCOLOR)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_BORDERCOLOR)]);
    m_RastCtx.pTexture[1]->uMagFilter = (D3DTEXTUREMAGFILTER)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_MAGFILTER)]);
    m_RastCtx.pTexture[1]->uMinFilter = (D3DTEXTUREMINFILTER)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_MINFILTER)]);
    m_RastCtx.pTexture[1]->uMipFilter = (D3DTEXTUREMIPFILTER)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_MIPFILTER)]);
    m_RastCtx.pTexture[1]->cLOD =
        (D3DTFP_NONE == m_RastCtx.pTexture[1]->uMipFilter)
        ? 0 : m_RastCtx.pTexture[1]->cLODTex;
    {
        m_RastCtx.pTexture[1]->fLODBias = m_RastCtx.pfRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_MIPMAPLODBIAS)];
    }
    if (m_RastCtx.pTexture[1]->iMaxMipLevel != (INT32)m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_MAXMIPLEVEL)])
    {
        m_RastCtx.pTexture[1]->iMaxMipLevel = (INT32)m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_MAXMIPLEVEL)];
        m_RastCtx.pTexture[1]->uFlags |= D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;
    }
}

//-----------------------------------------------------------------------------
//
// MapLegacyTextureFilter -
//
//-----------------------------------------------------------------------------
void
D3DContext::MapLegacyTextureFilter( void )
{
    // D3D legacy filter specifications are (XXXMIP)YYY where XXX is the
    // mip filter and YYY is the filter used within an LOD

    // map MAG filter - legacy support is point or linear (and maybe aniso)
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREMAG] )
    {
    default:
    case D3DFILTER_NEAREST:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MAGFILTER)] = D3DTFG_POINT;
        break;
    case D3DFILTER_LINEAR:
        // select based on aniso enable
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MAGFILTER)] = D3DTFG_LINEAR;
        break;
    }
    // map MIN and MIP filter at the same time - legacy support
    // has them intermingled...
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREMIN] )
    {
    case D3DFILTER_NEAREST:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)] = D3DTFN_POINT;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)] = D3DTFP_NONE;
        break;
    case D3DFILTER_MIPNEAREST:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)] = D3DTFN_POINT;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)] = D3DTFP_POINT;
        break;
    case D3DFILTER_LINEARMIPNEAREST:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)] = D3DTFN_POINT;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)] = D3DTFP_LINEAR;
        break;
    case D3DFILTER_LINEAR:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)] = D3DTFN_LINEAR;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)] = D3DTFP_NONE;
        break;
    case D3DFILTER_MIPLINEAR:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)] = D3DTFN_LINEAR;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)] = D3DTFP_POINT;
        break;
    case D3DFILTER_LINEARMIPLINEAR:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)] = D3DTFN_LINEAR;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)] = D3DTFP_LINEAR;
        break;
    }
}

//-----------------------------------------------------------------------------
//
// MapLegacyTextureBlend - Maps legacy (pre-DX6) texture blend modes to DX6
// texture blending controls.  Uses per-stage program mode (first stage only).
// This mapping is done whenever the legacy TBLEND renderstate is set, and
// does overwrite any previously set DX6 texture blending controls.
//
//-----------------------------------------------------------------------------
void
D3DContext::MapLegacyTextureBlend( void )
{
    // disable texture blend processing stage 1 (this also disables subsequent stages)
    m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_COLOROP)] = D3DTOP_DISABLE;

    // set texture blend processing stage 0 to match legacy mode
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND] )
    {
    default:
    case D3DTBLEND_DECALMASK: // unsupported - do decal
    case D3DTBLEND_DECAL:
    case D3DTBLEND_COPY:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP)]   = D3DTOP_SELECTARG1;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAOP)]   = D3DTOP_SELECTARG1;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG1)] = D3DTA_TEXTURE;
        break;

    case D3DTBLEND_MODULATEMASK: // unsupported - do modulate
    case D3DTBLEND_MODULATE:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP)]   = D3DTOP_MODULATE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG2)] = D3DTA_DIFFUSE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAOP)]   = D3DTOP_SELECTARG1;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG2)] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_MODULATEALPHA:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP)]   = D3DTOP_MODULATE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG2)] = D3DTA_DIFFUSE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAOP)]   = D3DTOP_MODULATE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG2)] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_DECALALPHA:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP)]   = D3DTOP_BLENDTEXTUREALPHA;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG2)] = D3DTA_DIFFUSE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAOP)]   = D3DTOP_SELECTARG2;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG2)] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_ADD:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP)]   = D3DTOP_ADD;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG2)] = D3DTA_DIFFUSE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAOP)]   = D3DTOP_SELECTARG2;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG2)] = D3DTA_DIFFUSE;
        break;
    }

    // since we change [D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP), we can go from DISABLE to
    // something else, and we can need to update the TexStageCount
    UpdateActiveTexStageCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\rendprim.cpp ===
//----------------------------------------------------------------------------
//
// rendprim.cpp
//
// RastRenderState and RastRenderPrimitive.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#define DDS_LCL(x) ((LPDDRAWI_DDRAWSURFACE_INT)(x))->lpLcl

//----------------------------------------------------------------------------
//
// RendPoint
//
// Draw lists of points. Called by RastRenderPrimitive() for drawing points.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendPoints(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DPOINT pPt)
{
    INT i;
    LPD3DTLVERTEX pV;

    for (i = pIns->wCount; i > 0; i--)
    {
        INT iPts;
        for (iPts = pPt->wCount, pV = pVtx + pPt->wFirst;
             iPts > 0;
             iPts --, pV ++)
        {
            HRESULT hr;
            HR_RET(pfnPrims->pfnPoint(pCtx, (PUINT8)pV));
        }
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RendLine
//
// Draw a list of lines. Called by RastRenderPrimitive() for drawing lines.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendLines(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DLINE pLine)
{
    INT i;
    LPD3DTLVERTEX pV0, pV1;

    for (i = pIns->wCount; i > 0; i --)
    {
        HRESULT hr;
        pV0 = pVtx + pLine->v1;
        pV1 = pVtx + pLine->v2;
        pLine = (LPD3DLINE)((PINT8)pLine + pIns->bSize);
        HR_RET(pfnPrims->pfnLine(pCtx, (PUINT8)pV0, (PUINT8)pV1));
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RendTriangle
//
// Draw a list of triangles. Called by RastRenderPrimitive() for drawing
// triangles.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendTriangles(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DTRIANGLE pTri)
{
    LPD3DTLVERTEX pV0, pV1, pV2;
    INT i;
    for (i = pIns->wCount; i > 0; i --)
    {
        HRESULT hr;
        pV0 = pVtx + pTri->v1;
        pV1 = pVtx + pTri->v2;
        pV2 = pVtx + pTri->v3;
        HR_RET(pfnPrims->pfnTri(pCtx, (PUINT8)pV0, (PUINT8)pV1, 
                                (PUINT8)pV2, pTri->wFlags));
        pTri = (LPD3DTRIANGLE)((PINT8)pTri + pIns->bSize);
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastRenderPrimitive
//
// Called by Execute() for drawing primitives.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA pRenderData)
{
    LPD3DINSTRUCTION pIns;
    LPD3DTLVERTEX pVtx;
    PUINT8 pData, pPrim;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastRenderPrimitive", pRenderData);

    if (pDCtx->GetRastCtx()->pdwRenderState[D3DRENDERSTATE_ZVISIBLE])
    {
        pRenderData->dwStatus &= ~D3DSTATUS_ZNOTVISIBLE;
        pRenderData->ddrval = D3D_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    // Find out necessary data
    pData = (PUINT8)(DDS_LCL(pRenderData->lpExeBuf)->lpGbl->fpVidMem);
    pIns = &pRenderData->diInstruction;
    pPrim = pData + pRenderData->dwOffset;
    pVtx = (LPD3DTLVERTEX)
                ((PUINT8)DDS_LCL(pRenderData->lpTLBuf)->lpGbl->fpVidMem
                + pRenderData->dwTLOffset);

    pRenderData->ddrval = pDCtx->Begin();
    if (pRenderData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Render
    switch (pIns->bOpcode) {
    case D3DOP_POINT:
        pDCtx->BeginPrimSet(D3DPT_POINTLIST, RAST_TLVERTEX);
        pRenderData->ddrval = DoRendPoints((LPVOID)pDCtx, pDCtx->GetFunsTbl(),
                                        pIns, pVtx, (LPD3DPOINT)pPrim);
        break;
    case D3DOP_LINE:
        pDCtx->BeginPrimSet(D3DPT_LINELIST, RAST_TLVERTEX);
        pRenderData->ddrval = DoRendLines((LPVOID)pDCtx, pDCtx->GetFunsTbl(),
                                        pIns, pVtx, (LPD3DLINE)pPrim);
        break;
    case D3DOP_TRIANGLE:
        pDCtx->BeginPrimSet(D3DPT_TRIANGLELIST, RAST_TLVERTEX);
        pRenderData->ddrval = DoRendTriangles((LPVOID)pDCtx, pDCtx->GetFunsTbl(),
                                        pIns, pVtx, (LPD3DTRIANGLE)pPrim);
        break;
    default:
        D3D_ERR("(Rast) Wrong Opcode passed to the new rasterizer.");
        pRenderData->ddrval =  DDERR_INVALIDPARAMS;
        break;
    }

    HRESULT hr;

    hr = pDCtx->End();
    if (pRenderData->ddrval == D3D_OK)
    {
        pRenderData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastRenderPrimitive
//
// Called by Execute() for setting render states.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastRenderState(LPD3DHAL_RENDERSTATEDATA pStateData)
{
    PUINT8 pData;
    LPD3DSTATE pState;
    INT i;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastRenderState", pStateData);

    // Updates D3DCTX
    pData = (PUINT8) (((LPDDRAWI_DDRAWSURFACE_INT)
        (pStateData->lpExeBuf))->lpLcl->lpGbl->fpVidMem);
    for (i = 0, pState = (LPD3DSTATE) (pData + pStateData->dwOffset);
         i < (INT)pStateData->dwCount;
         i ++, pState ++)
    {
        UINT32 type = (UINT32) pState->drstRenderStateType;

        // Check for overrides
    if (IS_OVERRIDE(type)) {
        UINT32 override = GET_OVERRIDE(type);
        if (pState->dwArg[0])
        STATESET_SET(pDCtx->m_renderstate_override, override);
        else
        STATESET_CLEAR(pDCtx->m_renderstate_override, override);
        continue;
    }

    if (STATESET_ISSET(pDCtx->m_renderstate_override, type))
        continue;

        // Set the state
        pStateData->ddrval = pDCtx->SetRenderState(type, pState->dwArg[0]);
        if (pStateData->ddrval != D3D_OK)
        {
            return DDHAL_DRIVER_HANDLED;
        }
    }

    return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\swprov.hpp ===
//----------------------------------------------------------------------------
//
// swprov.hpp
//
// Base software HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SWPROV_HPP_
#define _SWPROV_HPP_

//----------------------------------------------------------------------------
//
// SwHalProvider
//
// Implements the base HAL provider for the software rasterizers.
//
//----------------------------------------------------------------------------

class SwHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
};

//----------------------------------------------------------------------------
//
// RefRastHalProvider
//
// Specific provider for the reference rasterizer.
//
//----------------------------------------------------------------------------

class RefRastHalProvider : public SwHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion);
};

//----------------------------------------------------------------------------
//
// OptRastHalProvider
//
// Specific provider for the optimized software rasterizer.
//
//----------------------------------------------------------------------------

class OptRastHalProvider : public SwHalProvider
{
private:
    DWORD m_BeadSet;
public:
    OptRastHalProvider(THIS_
                       DWORD);
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion);
};

//----------------------------------------------------------------------------
//
// RampRastHalProvider
//
// Specific provider for the ramp software rasterizer.
//
//----------------------------------------------------------------------------

class RampRastHalProvider : public SwHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion);
};

//----------------------------------------------------------------------------
//
// NullDeviceHalProvider
//
// Specific provider for the null device.
//
//----------------------------------------------------------------------------

class NullDeviceHalProvider : public SwHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion);
};

#endif // #ifndef _SWPROV_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\swprov.cpp ===
//----------------------------------------------------------------------------
//
// swprov.cpp
//
// Implements software rasterizer HAL provider.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

extern HRESULT
RastService(ULONG_PTR dwCtx,
                RastServiceType srvType, DWORD arg1, LPVOID arg2);

#define nullPrimCaps \
{                                                                             \
    sizeof(D3DPRIMCAPS), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                \
}

#define nullTransCaps \
{                                                                             \
    sizeof(D3DTRANSFORMCAPS), 0                                               \
}

#define nullLightCaps \
{                                                                             \
    sizeof(D3DLIGHTINGCAPS), 0, 0, 0                                          \
}

D3DDEVICEDESC g_nullDevDesc =
{
    sizeof(D3DDEVICEDESC),      /* dwSize */
    0,                          /* dwFlags */
    0,                          /* dcmColorModel */
    0,                          /* dwDevCaps */
    nullTransCaps,              /* transformCaps */
    FALSE,
    nullLightCaps,              /* lightingCaps */
    nullPrimCaps,               /* lineCaps */
    nullPrimCaps,               /* triCaps */
    0,                          /* dwMaxBufferSize */
    0,                          /* dwMaxVertexCount */
    0, 0,
    0, 0,
    0, 0,
    0, 0
};

/**********************************************************
 *
 * Legacy caps, as pulled from mustard\direct3d\d3d\ddraw\getcaps.c
 *
 **********************************************************/

#undef BUILD_RAMP
#define devDesc rgbDevDescDX5
#include "getcaps.h"
#undef devDesc

/**********************************************************
 *
 * End legacy caps
 *
 **********************************************************/

static D3DDEVICEDESC rgbDevDesc = {0};
static D3DHAL_D3DEXTENDEDCAPS OptSwExtCaps;

static void
FillOutDeviceCaps( void )
{
    //
    //  set device description
    //
    rgbDevDesc.dwSize = sizeof(rgbDevDesc);

    rgbDevDesc.dwFlags =
        D3DDD_COLORMODEL            |
        D3DDD_DEVCAPS               |
        D3DDD_TRANSFORMCAPS         |
        D3DDD_LIGHTINGCAPS          |
        D3DDD_BCLIPPING             |
        D3DDD_LINECAPS              |
        D3DDD_TRICAPS               |
        D3DDD_DEVICERENDERBITDEPTH  |
        D3DDD_DEVICEZBUFFERBITDEPTH |
        D3DDD_MAXBUFFERSIZE         |
        D3DDD_MAXVERTEXCOUNT        ;
    rgbDevDesc.dcmColorModel = D3DCOLOR_RGB;
    rgbDevDesc.dwDevCaps =
        D3DDEVCAPS_FLOATTLVERTEX        |
        D3DDEVCAPS_EXECUTESYSTEMMEMORY  |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY  |
        D3DDEVCAPS_DRAWPRIMTLVERTEX     ;

    rgbDevDesc.dtcTransformCaps.dwSize = sizeof(D3DTRANSFORMCAPS);
    rgbDevDesc.dtcTransformCaps.dwCaps = D3DTRANSFORMCAPS_CLIP;
    rgbDevDesc.bClipping = TRUE;
    rgbDevDesc.dlcLightingCaps.dwSize = sizeof(D3DLIGHTINGCAPS);
    rgbDevDesc.dlcLightingCaps.dwCaps =
        D3DLIGHTCAPS_POINT         |
        D3DLIGHTCAPS_SPOT          |
        D3DLIGHTCAPS_DIRECTIONAL   |
        D3DLIGHTCAPS_PARALLELPOINT ;
    rgbDevDesc.dlcLightingCaps.dwLightingModel = D3DLIGHTINGMODEL_RGB;
    rgbDevDesc.dlcLightingCaps.dwNumLights = 0;

    rgbDevDesc.dpcTriCaps.dwSize = sizeof(D3DPRIMCAPS);
    rgbDevDesc.dpcTriCaps.dwMiscCaps =
        D3DPMISCCAPS_CULLNONE |
        D3DPMISCCAPS_CULLCW   |
        D3DPMISCCAPS_CULLCCW  ;
    rgbDevDesc.dpcTriCaps.dwRasterCaps =
        D3DPRASTERCAPS_DITHER                   |
        D3DPRASTERCAPS_ROP2                     |
        D3DPRASTERCAPS_XOR                      |
    //    D3DPRASTERCAPS_PAT                      |
        D3DPRASTERCAPS_ZTEST                    |
        D3DPRASTERCAPS_SUBPIXEL                 |
        D3DPRASTERCAPS_SUBPIXELX                |
        D3DPRASTERCAPS_FOGVERTEX                |
        D3DPRASTERCAPS_FOGTABLE                 |
    //    D3DPRASTERCAPS_STIPPLE                  |
    //    D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   |
    //    D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
    //    D3DPRASTERCAPS_ANTIALIASEDGES           |
        D3DPRASTERCAPS_MIPMAPLODBIAS            |
    //    D3DPRASTERCAPS_ZBIAS                    |
    //    D3DPRASTERCAPS_ZBUFFERLESSHSR           |
        D3DPRASTERCAPS_FOGRANGE;
    //    D3DPRASTERCAPS_ANISOTROPY               ;
        rgbDevDesc.dpcTriCaps.dwZCmpCaps =
        D3DPCMPCAPS_NEVER        |
        D3DPCMPCAPS_LESS         |
        D3DPCMPCAPS_EQUAL        |
        D3DPCMPCAPS_LESSEQUAL    |
        D3DPCMPCAPS_GREATER      |
        D3DPCMPCAPS_NOTEQUAL     |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS       ;
    rgbDevDesc.dpcTriCaps.dwSrcBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      |
        D3DPBLENDCAPS_BOTHSRCALPHA     |
        D3DPBLENDCAPS_BOTHINVSRCALPHA  ;
    rgbDevDesc.dpcTriCaps.dwDestBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      ;
    rgbDevDesc.dpcTriCaps.dwAlphaCmpCaps =
    rgbDevDesc.dpcTriCaps.dwZCmpCaps;
    rgbDevDesc.dpcTriCaps.dwShadeCaps =
        D3DPSHADECAPS_COLORFLATRGB       |
        D3DPSHADECAPS_COLORGOURAUDRGB    |
        D3DPSHADECAPS_SPECULARFLATRGB    |
        D3DPSHADECAPS_SPECULARGOURAUDRGB |
        D3DPSHADECAPS_ALPHAFLATBLEND     |
        D3DPSHADECAPS_ALPHAGOURAUDBLEND  |
        D3DPSHADECAPS_FOGFLAT            |
        D3DPSHADECAPS_FOGGOURAUD         ;
    rgbDevDesc.dpcTriCaps.dwTextureCaps =
        D3DPTEXTURECAPS_PERSPECTIVE  |
        D3DPTEXTURECAPS_POW2         |
        D3DPTEXTURECAPS_ALPHA        |
        D3DPTEXTURECAPS_TRANSPARENCY |
        D3DPTEXTURECAPS_ALPHAPALETTE |
        D3DPTEXTURECAPS_BORDER       |
        D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
        D3DPTEXTURECAPS_ALPHAPALETTE             ;
    rgbDevDesc.dpcTriCaps.dwTextureFilterCaps =
        D3DPTFILTERCAPS_NEAREST          |
        D3DPTFILTERCAPS_LINEAR           |
        D3DPTFILTERCAPS_MIPNEAREST       |
        D3DPTFILTERCAPS_MIPLINEAR        |
        D3DPTFILTERCAPS_LINEARMIPNEAREST |
        D3DPTFILTERCAPS_LINEARMIPLINEAR  |
        D3DPTFILTERCAPS_MINFPOINT        |
        D3DPTFILTERCAPS_MINFLINEAR       |
        D3DPTFILTERCAPS_MIPFPOINT        |
        D3DPTFILTERCAPS_MIPFLINEAR       |
        D3DPTFILTERCAPS_MAGFPOINT        |
        D3DPTFILTERCAPS_MAGFLINEAR       ;
    rgbDevDesc.dpcTriCaps.dwTextureBlendCaps =
        D3DPTBLENDCAPS_DECAL         |
        D3DPTBLENDCAPS_MODULATE      |
        D3DPTBLENDCAPS_DECALALPHA    |
        D3DPTBLENDCAPS_MODULATEALPHA |
        // D3DPTBLENDCAPS_DECALMASK     |
        // D3DPTBLENDCAPS_MODULATEMASK  |
        D3DPTBLENDCAPS_COPY          |
        D3DPTBLENDCAPS_ADD           ;
    rgbDevDesc.dpcTriCaps.dwTextureAddressCaps =
        D3DPTADDRESSCAPS_WRAP          |
        D3DPTADDRESSCAPS_MIRROR        |
        D3DPTADDRESSCAPS_CLAMP         |
        D3DPTADDRESSCAPS_BORDER        |
        D3DPTADDRESSCAPS_INDEPENDENTUV ;
    rgbDevDesc.dpcTriCaps.dwStippleWidth = 4;
    rgbDevDesc.dpcTriCaps.dwStippleHeight = 4;

    //  line caps - copy tricaps and modify
    memcpy( &rgbDevDesc.dpcLineCaps, &rgbDevDesc.dpcTriCaps, sizeof(D3DPRIMCAPS) );

    rgbDevDesc.dwDeviceRenderBitDepth = DDBD_8 | DDBD_16 | DDBD_24 | DDBD_32;
    rgbDevDesc.dwDeviceZBufferBitDepth = D3DSWRASTERIZER_ZBUFFERBITDEPTHFLAGS;
    rgbDevDesc.dwMaxBufferSize = 0;
    rgbDevDesc.dwMaxVertexCount = BASE_VERTEX_COUNT;

    // DX5 stuff (should be in sync with the extended caps reported below)
    rgbDevDesc.dwMinTextureWidth = 1;
    rgbDevDesc.dwMaxTextureWidth = 1024;
    rgbDevDesc.dwMinTextureHeight = 1;
    rgbDevDesc.dwMaxTextureHeight = 1024;
    rgbDevDesc.dwMinStippleWidth = 0;   //  stipple unsupported
    rgbDevDesc.dwMaxStippleWidth = 0;
    rgbDevDesc.dwMinStippleHeight = 0;
    rgbDevDesc.dwMaxStippleHeight = 0;


    //
    //  set extended caps
    //
    OptSwExtCaps.dwSize = sizeof(OptSwExtCaps);

    OptSwExtCaps.dwMinTextureWidth = 1;
    OptSwExtCaps.dwMaxTextureWidth = 1024;
    OptSwExtCaps.dwMinTextureHeight = 1;
    OptSwExtCaps.dwMaxTextureHeight = 1024;
    OptSwExtCaps.dwMinStippleWidth = 0;   //  stipple unsupported
    OptSwExtCaps.dwMaxStippleWidth = 0;
    OptSwExtCaps.dwMinStippleHeight = 0;
    OptSwExtCaps.dwMaxStippleHeight = 0;

    OptSwExtCaps.dwMaxTextureRepeat = 256;
    OptSwExtCaps.dwMaxTextureAspectRatio = 0; // no limit
    OptSwExtCaps.dwMaxAnisotropy = 1;
    OptSwExtCaps.dvGuardBandLeft  = -32768.f;
    OptSwExtCaps.dvGuardBandTop   = -32768.f;
    OptSwExtCaps.dvGuardBandRight  = 32767.f;
    OptSwExtCaps.dvGuardBandBottom = 32767.f;
    OptSwExtCaps.dvExtentsAdjust = 0.;    //  AA kernel is 1.0 x 1.0
    OptSwExtCaps.dwStencilCaps =
        D3DSTENCILCAPS_KEEP   |
        D3DSTENCILCAPS_ZERO   |
        D3DSTENCILCAPS_REPLACE|
        D3DSTENCILCAPS_INCRSAT|
        D3DSTENCILCAPS_DECRSAT|
        D3DSTENCILCAPS_INVERT |
        D3DSTENCILCAPS_INCR   |
        D3DSTENCILCAPS_DECR;
    OptSwExtCaps.dwFVFCaps = 2;
    OptSwExtCaps.dwTextureOpCaps =
        D3DTEXOPCAPS_DISABLE                   |
        D3DTEXOPCAPS_SELECTARG1                |
        D3DTEXOPCAPS_SELECTARG2                |
        D3DTEXOPCAPS_MODULATE                  |
        D3DTEXOPCAPS_MODULATE2X                |
        D3DTEXOPCAPS_MODULATE4X                |
        D3DTEXOPCAPS_ADD                       |
        D3DTEXOPCAPS_ADDSIGNED                 |
//        D3DTEXOPCAPS_ADDSIGNED2X               |
//        D3DTEXOPCAPS_SUBTRACT                  |
//        D3DTEXOPCAPS_ADDSMOOTH                 |
        D3DTEXOPCAPS_BLENDDIFFUSEALPHA         |
        D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
        D3DTEXOPCAPS_BLENDFACTORALPHA          |
        D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       ;
//        D3DTEXOPCAPS_BLENDCURRENTALPHA         |
//        D3DTEXOPCAPS_PREMODULATE               |
//        D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    |
//        D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    |
//        D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
//        D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
    OptSwExtCaps.wMaxTextureBlendStages = 2;
    OptSwExtCaps.wMaxSimultaneousTextures = 2;
}
//----------------------------------------------------------------------------
//
// SwHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP SwHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// SwHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) SwHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// SwHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) SwHalProvider::Release(THIS)
{
    return 0;
}

//----------------------------------------------------------------------------
//
// SwHalProvider::GetCaps
//
// Returns software rasterizer caps.
//
//----------------------------------------------------------------------------

STDMETHODIMP
OptRastHalProvider::GetCaps(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion)
{
    *pHwDesc = g_nullDevDesc;

    if (rgbDevDesc.dwSize == 0)
    {
        FillOutDeviceCaps();
        D3DDeviceDescConvert(&rgbDevDesc,NULL,&OptSwExtCaps);  // add extended caps to rgbDevDesc
    }
    if (dwVersion >= 3)
        *pHelDesc = rgbDevDesc;
    else
    {
        D3D_WARN(1, "(Rast) GetCaps: returning legacy caps for RGB rasterizer");
        *pHelDesc = rgbDevDescDX5;
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// OptRastHalProvider::GetInterface
//
// Returns driver interface data for opt rast.
//
//----------------------------------------------------------------------------

static D3DHAL_GLOBALDRIVERDATA SwDriverData =
{
    sizeof(D3DHAL_GLOBALDRIVERDATA),
    // The rest is filled in at runtime.
};

static D3DHAL_CALLBACKS OptRastCallbacksCMMX =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateCMMX,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    RastTextureSwap,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS OptRastCallbacksC =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateC,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    RastTextureSwap,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS OptRastCallbacksMMX =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateMMX,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    RastTextureSwap,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS OptRastCallbacksMMXAsRGB =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateMMXAsRGB,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    RastTextureSwap,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS2 OptRastCallbacks2 =
{
    sizeof(D3DHAL_CALLBACKS2),
    D3DHAL2_CB32_SETRENDERTARGET |
        D3DHAL2_CB32_DRAWONEPRIMITIVE |
        D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE |
        D3DHAL2_CB32_DRAWPRIMITIVES,
    RastSetRenderTarget,
    NULL,
    RastDrawOnePrimitive,
    RastDrawOneIndexedPrimitive,
    RastDrawPrimitives
};

static D3DHAL_CALLBACKS3 OptRastCallbacks3 =
{
    sizeof(D3DHAL_CALLBACKS3),
    D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE |
        D3DHAL3_CB32_DRAWPRIMITIVES2,
    NULL, // Clear2
    NULL, //lpvReserved
    RastValidateTextureStageState,
    RastDrawPrimitives2,
};

STDMETHODIMP
OptRastHalProvider::GetInterface(THIS_
                                 LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                                 LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                                 DWORD dwVersion)
{
    if (rgbDevDesc.dwSize == 0)
    {
        FillOutDeviceCaps();
        D3DDeviceDescConvert(&rgbDevDesc,NULL,&OptSwExtCaps);  // add extended caps to rgbDevDesc
    }

    memcpy(&SwDriverData.hwCaps, &rgbDevDesc, sizeof(SwDriverData.hwCaps));
    SW_RAST_TYPE RastType;
    switch(m_BeadSet)
    {
    default:
    case D3DIBS_C:
        RastType = SW_RAST_RGB;
        break;
    case D3DIBS_MMX:
        RastType = SW_RAST_MMX;
        break;
    case D3DIBS_MMXASRGB:
        RastType = SW_RAST_MMXASRGB;
        break;
    }
    // Vertex counts are left zero.
    SwDriverData.dwNumTextureFormats =
        TextureFormats(&SwDriverData.lpTextureFormats, dwVersion, RastType);
    SwDriverData.dwNumVertices = BASE_VERTEX_COUNT;
    SwDriverData.dwNumClipVertices = MAX_CLIP_VERTICES;
    pInterfaceData->pGlobalData = &SwDriverData;

    pInterfaceData->pExtCaps = &OptSwExtCaps;

    switch(m_BeadSet)
    {
    case D3DIBS_CMMX:       pInterfaceData->pCallbacks = &OptRastCallbacksCMMX;     break;
    case D3DIBS_MMX:        pInterfaceData->pCallbacks = &OptRastCallbacksMMX;      break;
    case D3DIBS_MMXASRGB:   pInterfaceData->pCallbacks = &OptRastCallbacksMMXAsRGB; break;
    case D3DIBS_C:          pInterfaceData->pCallbacks = &OptRastCallbacksC;        break;
    }
    pInterfaceData->pCallbacks2 = &OptRastCallbacks2;
    pInterfaceData->pCallbacks3 = &OptRastCallbacks3;

    pInterfaceData->pfnRampService = NULL;
    pInterfaceData->pfnRastService = RastService;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// OptRastHalProvider
//
// Constructor for OptRastHalProvider to allow a bit of private state to be
// kept to indicate which optimized rasterizer is to be used.
//
//----------------------------------------------------------------------------
OptRastHalProvider::OptRastHalProvider(THIS_
                       DWORD BeadSet)
{
    m_BeadSet = BeadSet;
}

//----------------------------------------------------------------------------
//
// GetSwProvider
//
// Returns the appropriate software HAL provider based on the given GUID.
//
//----------------------------------------------------------------------------

static OptRastHalProvider g_OptRastHalProviderC(D3DIBS_C);
static OptRastHalProvider g_OptRastHalProviderMMX(D3DIBS_MMX);
static OptRastHalProvider g_OptRastHalProviderCMMX(D3DIBS_CMMX);
static OptRastHalProvider g_OptRastHalProviderMMXAsRGB(D3DIBS_MMXASRGB);
static RampRastHalProvider g_RampRastHalProvider;
static NullDeviceHalProvider g_NullDeviceHalProvider;

STDAPI GetSwHalProvider(REFIID riid, IHalProvider **ppHalProvider,
                        HINSTANCE *phDll)
{
    *phDll = NULL;
    if (IsEqualIID(riid, IID_IDirect3DRGBDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderC;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMMXDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderMMX;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMMXAsRGBDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderMMXAsRGB;
    }
    else if (IsEqualIID(riid, IID_IDirect3DNewRGBDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderCMMX;
    }
    else if (IsEqualIID(riid, IID_IDirect3DRampDevice))
    {
        *ppHalProvider = &g_RampRastHalProvider;
    }
    else if (IsEqualIID(riid, IID_IDirect3DRefDevice) ||
             IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        // try to get provider from external DLL ref device
        PFNGETREFHALPROVIDER pfnGetRefHalProvider;
        if (NULL == (pfnGetRefHalProvider =
            (PFNGETREFHALPROVIDER)LoadReferenceDeviceProc("GetRefHalProvider")))
        {
            *ppHalProvider = NULL;
            return E_NOINTERFACE;
        }
        D3D_INFO(0,"GetSwHalProvider: getting provider from d3dref");
        pfnGetRefHalProvider(riid, ppHalProvider, phDll);
    }
    else
    {
        *ppHalProvider = NULL;
        return E_NOINTERFACE;
    }

    // As a debugging aid, allow the particular rasterizer to be forced
    // via a registry setting.  This lets a developer run an app on any
    // rasterizer regardless of what it asks for.

    // Don't remap ramp.
    if (IsEqualIID(riid, IID_IDirect3DRampDevice))
    {
        return S_OK;
    }

    LONG iRet;
    HKEY hKey;

    iRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RESPATH, 0, KEY_READ, &hKey);
    if (iRet == ERROR_SUCCESS)
    {
        DWORD dwData, dwType;
        DWORD dwDataSize;

        dwDataSize = sizeof(dwData);
        iRet = RegQueryValueEx(hKey, "ForceRgbRasterizer", NULL,
                               &dwType, (BYTE *)&dwData, &dwDataSize);
        if (iRet == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            dwDataSize == sizeof(dwData))
        {
            switch(dwData)
            {
            case 1:
                *ppHalProvider = &g_OptRastHalProviderC;
                break;
            case 2:
                *ppHalProvider = &g_OptRastHalProviderCMMX;
                break;
            case 3:
                *ppHalProvider = &g_OptRastHalProviderMMX;
                break;
            case 4:
                {
                    // try to get provider from external DLL ref device
                    PFNGETREFHALPROVIDER pfnGetRefHalProvider;
                    if (NULL == (pfnGetRefHalProvider =
                                 (PFNGETREFHALPROVIDER)LoadReferenceDeviceProc("GetRefHalProvider")))
                    {
                        *ppHalProvider = NULL;
                        return E_NOINTERFACE;
                    }
                    D3D_INFO(0,"GetSwHalProvider: getting provider from d3dref");
                    pfnGetRefHalProvider(riid, ppHalProvider, phDll);
                    break;
                }
            case 5:
                *ppHalProvider = &g_NullDeviceHalProvider;
                break;
            case 6:
                *ppHalProvider = &g_OptRastHalProviderMMXAsRGB;
                break;
            case 0:
                // no override for 0
                break;
            default:
                D3D_ERR("(Rast) Unknown ForceRgbRasterizer setting - no force");
                break;
            }

            D3D_INFO(1, "(Rast) ForceRgbRasterizer to %d", dwData);
        }

        RegCloseKey(hKey);
    }

    return S_OK;
}

STDAPI GetSwTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd, DWORD dwD3DDeviceVersion) {

    // assumes it can't get an invalid RIID.
    if(IsEqualIID(riid, IID_IDirect3DHALDevice)) 
    {
        D3D_WARN(2,"(Rast) GetSWTextureFormats Internal Error: HAL GUID is not valid arg");
        *lplpddsd=NULL;
        return 0;
    }

    if(IsEqualIID(riid, IID_IDirect3DRefDevice) ||
       IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        // try to get provider from external DLL ref device
        PFNGETREFTEXTUREFORMATS pfnGetRefTextureFormats;
        if (NULL == (pfnGetRefTextureFormats =
                     (PFNGETREFTEXTUREFORMATS)LoadReferenceDeviceProc("GetRefTextureFormats")))
        {
            D3D_WARN(2,"(Rast) GetSWTextureFormats Internal Error: d3dref.dll not found");
            *lplpddsd=NULL;
            return 0;
        }
        D3D_INFO(0,"GetSWTextureFormats: getting provider from d3dref");
        return pfnGetRefTextureFormats(riid, lplpddsd, dwD3DDeviceVersion);
    }

    if (IsEqualIID(riid, IID_IDirect3DRampDevice))
    {
        return RampTextureFormats(lplpddsd);
    }

    // else using RGB or internal ref device
    SW_RAST_TYPE RastType = SW_RAST_RGB;
    if (IsEqualIID(riid, IID_IDirect3DMMXDevice))
    {
        RastType = SW_RAST_MMX;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMMXAsRGBDevice))
    {
        RastType = SW_RAST_MMXASRGB;
    }
    return TextureFormats(lplpddsd,dwD3DDeviceVersion, RastType);
}

STDAPI GetSwZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF)
{
    // assumes it can't get an invalid RIID.
    if(IsEqualIID(riid, IID_IDirect3DHALDevice)) 
    {
        D3D_WARN(2,"(Rast) GetSWZBufferFormats Internal Error: HAL GUID is not valid arg");
        *ppDDPF=NULL;
        return 0;
    }

    if (IsEqualIID(riid, IID_IDirect3DRefDevice) ||
        IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        // try to get Z buffer formats from external DLL ref device
        PFNGETREFZBUFFERFORMATS pfnGetRefZBufferFormats;
        if (NULL == (pfnGetRefZBufferFormats =
            (PFNGETREFZBUFFERFORMATS)LoadReferenceDeviceProc("GetRefZBufferFormats")))
        {
            D3D_WARN(2,"(Rast) GetSWZBufferFormats Internal Error: d3dref.dll not found");
            *ppDDPF=NULL;
            return 0;
        }
        return pfnGetRefZBufferFormats(riid, ppDDPF);
    }

    if (IsEqualIID(riid, IID_IDirect3DRampDevice))
    {
        return RampZBufferFormats(ppDDPF);
    }

    return ZBufferFormats(ppDDPF, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\dxshad.h ===
/*--

$Revision: 1 $

Copyright (c) 1995, Microsoft Corporation

--*/
#ifndef _DXSHAD_H_
#define _DXSHAD_H_

//////////////////////////////////////////////////////////////////////////
//
//  Needed extensions to D3D to support hardware, per pixel style shadows
//
//////////////////////////////////////////////////////////////////////////

typedef struct _D3DSHADOWDATA {
    DWORD               dwSize;            /* Size of structure */
    DWORD               dwFlags;           /* Flags */
    LPDIRECTDRAWSURFACE lpDDSZBuffer;      /* Shadow z-buffer surface */
    D3DMATRIX*          lpD3DMatrixEye;    /* Eye space transform matrix */
    D3DMATRIX*          lpD3DMatrixLight;  /* Light space transform matrix */
    D3DVALUE            dvAttenuation;     /* Attenuation of light in shadow */
    D3DVALUE            dvZBiasMin;        /* Minimum z bias */
    D3DVALUE            dvZBiasMax;        /* Maximum z bias */
    D3DVALUE            dvUJitter;         /* Shadow sample jitter in u */
    D3DVALUE            dvVJitter;         /* Shadow sample jitter in v */
    DWORD               dwFilterSize;      /* Size of shadow filter */
} D3DSHADOWDATA, *LPD3DSHADOWDATA;

// D3DSHADOWDATA dwFlags
#define D3DSZBUF_ZBIAS      1
#define D3DSZBUF_UVJITTER   2
#define D3DSZBUF_TRIANGLEFILTER   4         /* for experimental purposes */

// This structure is how shadow information is communicated
// to the HAL
typedef struct _D3DI_SHADOWDATA{
    DWORD               dwSize;            /* Size of structure */
    DWORD               dwFlags;           /* Flags */
    DDSURFACEDESC       ddsdShadZ;         /* Shadow z-buffer surface */
    DWORD               dwShadZMaskU;      /* ~(ddsdShadZ.dwWidth-1) */
    DWORD               dwShadZMaskV;      /* ~(ddsdShadZ.dwHeight-1) */
    D3DMATRIX           MatrixShad;        /* Embedded Concatenated screen to light space matrix */
    D3DVALUE            dvAttenuation;     /* Attenuation of light in shadow */
    D3DVALUE            dvZBiasMin;        /* Minimum z bias */
    D3DVALUE            dvZBiasRange;      /* Maximum z bias - Minimum z bias */
    D3DVALUE            dvUJitter;         /* 4.4 integer jitter in u */
    D3DVALUE            dvVJitter;         /* 4.4 integer jitter in v */
    DWORD               dwFilterSize;      /* Size of shadow filter */
    DWORD               dwFilterArea;      /* dwFilterSize*dwFilterSize */
} D3DI_SHADOWDATA, *LPD3DI_SHADOWDATA;

// Additional D3DI_SHADOWDATA dwFlags
#define D3DSHAD_ENABLE  0x80000000          // set to enable shadowing

typedef enum _D3DSHADOWFILTERSIZE {
    D3DSHADOWFILTERSIZE_1x1 = 1,
    D3DSHADOWFILTERSIZE_2x2,
    D3DSHADOWFILTERSIZE_3x3,
    D3DSHADOWFILTERSIZE_4x4,
    D3DSHADOWFILTERSIZE_5x5,
    D3DSHADOWFILTERSIZE_6x6,
    D3DSHADOWFILTERSIZE_7x7,
    D3DSHADOWFILTERSIZE_8x8,
} D3DSHADOWFILTERSIZE;

#endif  // _DXSHAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\mlspan.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Monolithic Rasterizer Functions - Public Header File
//
///////////////////////////////////////////////////////////////////////////////


#ifndef _MONOSPAN_H
#define _MONOSPAN_H

#include "span.h"

DllExport HRESULT Monolithic_RenderSpansTestSelector(PD3DI_RASTCTX pCtx);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3drast\d3drast.cpp ===
#define INITGUID
#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3di.hpp>

//
//  dummy file to get build.exe to do something
//
//  also used to get guid's into d3drast.dll
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\lists.h ===
/* Copyright (c) 1997-1998  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef	_LISTS_H
#define	_LISTS_H

#if __cplusplus
extern "C" {
#endif

#define LIST_ROOT(name, type) struct name {struct type *Root;}

#define LIST_MEMBER(type) struct { struct type **Prev; struct type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
	(root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define	LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define	TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   struct type *First;\
    struct type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   struct type *Next;\
    struct type **Prev;	/* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   struct type *Last;\
    struct type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   struct type *Prev;\
    struct type *Next;\
}

#define	CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
	(root)->Last->field.Next = (element);\
    else\
	(root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
	(root)->First->field.Prev = (element);\
    else\
	(root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
	(current_element)->field.Prev->field.Next = (element);\
    else\
	(root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define	CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
	(element)->field.Prev->field.Next = (element)->field.Next;\
    else\
	(root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.h"

void TestList(void)
{
    struct Foo
    {
	int a;
	LIST_MEMBER(Foo) ListStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
	int a;
	TAIL_QUEUE_MEMBER(Foo) TQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);

    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
	int a;
	CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
	CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
	MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
	MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
	MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

	switch(WhichInsert)
	{
	case END:
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    WhichInsert = ROOT;
	    break;
	case ROOT:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    WhichInsert = PREVIOUS;
	    break;
	case PREVIOUS:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
	    WhichInsert = DONE;
	    break;
	default:
	    assert(0);
	}

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);

        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);

        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);

        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

	pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
	pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
	assert(pFoo == &MyFoo3);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);

        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);

        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);

        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);

        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);

        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);

        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);

        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */

#if __cplusplus
}
#endif

#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\rast.h ===
//----------------------------------------------------------------------------
//
// rast.h
//
// Umbrella header file for the rasterizers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAST_H_
#define _RAST_H_

#ifndef DllExport
#define DllExport   __declspec( dllexport )
#endif

#include <d3ditype.h>
#include <d3dutil.h>
#include <span.h>

#endif // #ifndef _RAST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\mlrfns.h ===
#ifndef _CMLRFNS_H_
#define _CMLRFNS_H_

#ifdef __cplusplus
  extern "C" {
#endif

HRESULT MMXMLRast_1(PD3DI_RASTCTX);
HRESULT MMXMLRast_2(PD3DI_RASTCTX);
HRESULT MMXMLRast_3(PD3DI_RASTCTX);
HRESULT MMXMLRast_4(PD3DI_RASTCTX);
HRESULT MMXMLRast_5(PD3DI_RASTCTX);
HRESULT MMXMLRast_6(PD3DI_RASTCTX);
HRESULT MMXMLRast_7(PD3DI_RASTCTX);
HRESULT MMXMLRast_8(PD3DI_RASTCTX);
HRESULT MMXMLRast_9(PD3DI_RASTCTX);
HRESULT MMXMLRast_10(PD3DI_RASTCTX);
HRESULT MMXMLRast_11(PD3DI_RASTCTX);
HRESULT MMXMLRast_12(PD3DI_RASTCTX);
HRESULT MMXMLRast_13(PD3DI_RASTCTX);
HRESULT MMXMLRast_14(PD3DI_RASTCTX);
HRESULT MMXMLRast_15(PD3DI_RASTCTX);
HRESULT MMXMLRast_16(PD3DI_RASTCTX);
HRESULT MMXMLRast_17(PD3DI_RASTCTX);
HRESULT MMXMLRast_18(PD3DI_RASTCTX);
HRESULT MMXMLRast_19(PD3DI_RASTCTX);
HRESULT MMXMLRast_20(PD3DI_RASTCTX);
HRESULT MMXMLRast_21(PD3DI_RASTCTX);
HRESULT MMXMLRast_22(PD3DI_RASTCTX);
HRESULT MMXMLRast_23(PD3DI_RASTCTX);
HRESULT MMXMLRast_24(PD3DI_RASTCTX);
HRESULT MMXMLRast_25(PD3DI_RASTCTX);
HRESULT MMXMLRast_26(PD3DI_RASTCTX);
HRESULT MMXMLRast_27(PD3DI_RASTCTX);
HRESULT MMXMLRast_28(PD3DI_RASTCTX);

#ifdef __cplusplus
}
#endif


HRESULT CMLRast_1(PD3DI_RASTCTX);
HRESULT CMLRast_2(PD3DI_RASTCTX);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\d3drast\sources.inc ===
MAJORCOMP=d3drast
MINORCOMP=d3drast
TARGETNAME=d3drast
TARGETPATH=$(BASEDIR)\public\sdk\lib
TARGETTYPE=DYNLINK
DLLDEF=..\$(TARGETNAME).def
COFFBASE = usermode
SUBSYSTEM_VERSION=4.00

!IFDEF NTBBT
X3DLIB=x3dbbt.lib
!ELSE
X3DLIB=x3d.lib
!ENDIF

SYNCHRONIZE_DRAIN = 1

TARGETLIBS = \
        $(BASEDIR)\public\sdk\lib\*\user32.lib\
        $(BASEDIR)\public\sdk\lib\*\advapi32.lib\
        $(BASEDIR)\public\sdk\lib\*\uuid.lib

!if !("$(ALPHA)" == "1")
TARGETLIBS=$(TARGETLIBS) \
           $(D3DROOT)\lib\$(PLAT_DIR)\*\$(X3DLIB)
!endif

LINKLIBS = \
        $(D3DROOT)\d3dutil\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dutil.lib \
        $(D3DROOT)\pipeln\$(PLAT_DIR)\$(_OBJ_DIR)\*\pipeln.lib \
        $(D3DROOT)\d3dim\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dim.lib \
        $(D3DROOT)\rast\mmxemul\$(PLAT_DIR)\$(_OBJ_DIR)\*\mmxemul.lib \
        $(D3DROOT)\rast\refrast\$(PLAT_DIR)\$(_OBJ_DIR)\*\refrast.lib \
        $(D3DROOT)\rast\cspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rcspan.lib \
        $(D3DROOT)\rast\mmxspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rmmxspan.lib \
        $(D3DROOT)\rast\rampspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rrmpspan.lib \
        $(D3DROOT)\rast\rampmat\$(PLAT_DIR)\$(_OBJ_DIR)\*\rrampmat.lib \
        $(D3DROOT)\rast\mlspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rmlspan.lib \
        $(D3DROOT)\rast\spaninit\$(PLAT_DIR)\$(_OBJ_DIR)\*\rspanini.lib \
        $(D3DROOT)\rast\setup\$(PLAT_DIR)\$(_OBJ_DIR)\*\rsetup.lib \
        $(D3DROOT)\rast\d3dif\$(PLAT_DIR)\$(_OBJ_DIR)\*\rd3dif.lib

DLLENTRY = _DllMainCRTStartup

INCLUDES = ..\..\inc;$(D3DROOT)\pipeln\inc;$(INCLUDES)

SOURCES = \
        ..\d3drast.cpp \
        ..\d3drast.rc

BINPLACE_PLACEFILE = ..\d3drast.dir
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\mmxemul.h ===
//-----------------------------------------------------------------------------
//
// This file contains headers for routines that emulate MMX instructions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// union for playing with 16 bit multiplies
typedef union tagVAL32 {
    INT32 i;
    struct {
        INT16 l;
        INT16 h;
    } i16;
} VAL32;

UINT16 MMX_addsw(INT16 x, INT16 y);
INT16  MMX_addusw(UINT16 x, UINT16 y);
UINT16 MMX_cmpeqw(INT16 x, INT16 y);
UINT16 MMX_cmpgtw(INT16 x, INT16 y);
INT16  MMX_mulhw(INT16 x, INT16 y);
INT16  MMX_mullw(INT16 x, INT16 y);
INT16  MMX_subsw(INT16 x, INT16 y);
UINT16 MMX_subusw(UINT16 x, UINT16 y);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mlspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
#include "mlspan.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mlspan\cmlrast.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains C span loops.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

HRESULT
CMLRast_1(
    PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            UINT16 uPix = pS->uPix;
            INT iSurfaceStep;
            INT iZStep;

            if (pP->uFlags & D3DI_RASTPRIM_X_DEC) {
                iZStep = -pCtx->iZStep;
                iSurfaceStep = -pCtx->iSurfaceStep;
                pCtx->SI.iXStep = -1;   // for dithering
            } else {
                iZStep = pCtx->iZStep;
                iSurfaceStep = pCtx->iSurfaceStep;
                pCtx->SI.iXStep = 1;
            }

            while (1) {
                UINT16 uZ = (UINT16)(pS->uZ>>15);
                UINT16 uZB = *((UINT16*)pS->pZ);
                pS->uZ += pP->iDZDX;
                if ((pCtx->iZXorMask)^(uZ > uZB)) {
                    *((UINT16*)pS->pZ) = uZ;
                    pCtx->SI.uBB = pS->uB;
                    pCtx->SI.uBG = pS->uG;
                    pCtx->SI.uBR = pS->uR;
                    pCtx->SI.uBA = pS->uA;
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    pCtx->SI.uBB = (UINT16)min((UINT32)pCtx->SI.uBB + (UINT32)pS->uBS, 0xffff);
                    pCtx->SI.uBG = (UINT16)min((UINT32)pCtx->SI.uBG + (UINT32)pS->uGS, 0xffff);
                    pCtx->SI.uBR = (UINT16)min((UINT32)pCtx->SI.uBR + (UINT32)pS->uRS, 0xffff);
                    pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                    pS->uRS += pP->iDRSDX;
                    *(PUINT16)pS->pSurface =
                        ((pCtx->SI.uBR >>  1) & 0x7c00) |
                        ((pCtx->SI.uBG >>  6) & 0x03e0) |
                        ((pCtx->SI.uBB >> 11) & 0x001f) |
                        0x8000;
                } else {
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
                        pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                        pS->uRS += pP->iDRSDX;
                    }
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_FOGENABLE]) {
                        pS->uFog += (INT16)pS->iDFog;
                        pCtx->SI.uFogB += pCtx->SI.iFogBDX;
                        pCtx->SI.uFogG += pCtx->SI.iFogGDX;
                        pCtx->SI.uFogR += pCtx->SI.iFogRDX;
                    }
                }
                if (--uPix <= 0)
                    break;
                pS->pZ += iZStep;
                pS->pSurface += iSurfaceStep;
#ifdef DBG
                // handy for debug to see where we are
                pS->uX += (INT16)pCtx->SI.iXStep;
#endif
            }

            pS++;
        }

        pP = pP->pNext;
    }

    return D3D_OK;
}

HRESULT
CMLRast_2(
    PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            UINT16 uPix = pS->uPix;
            INT iSurfaceStep;
            INT iZStep;

            if (pP->uFlags & D3DI_RASTPRIM_X_DEC) {
                iZStep = -pCtx->iZStep;
                iSurfaceStep = -pCtx->iSurfaceStep;
                pCtx->SI.iXStep = -1;   // for dithering
            } else {
                iZStep = pCtx->iZStep;
                iSurfaceStep = pCtx->iSurfaceStep;
                pCtx->SI.iXStep = 1;
            }

            while (1) {
                UINT16 uZ = (UINT16)(pS->uZ>>15);
                UINT16 uZB = *((UINT16*)pS->pZ);
                pS->uZ += pP->iDZDX;
                if ((pCtx->iZXorMask)^(uZ > uZB)) {
                    *((UINT16*)pS->pZ) = uZ;
                    pCtx->SI.uBB = pS->uB;
                    pCtx->SI.uBG = pS->uG;
                    pCtx->SI.uBR = pS->uR;
                    pCtx->SI.uBA = pS->uA;
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    pCtx->SI.uBB = (UINT16)min((UINT32)pCtx->SI.uBB + (UINT32)pS->uBS, 0xffff);
                    pCtx->SI.uBG = (UINT16)min((UINT32)pCtx->SI.uBG + (UINT32)pS->uGS, 0xffff);
                    pCtx->SI.uBR = (UINT16)min((UINT32)pCtx->SI.uBR + (UINT32)pS->uRS, 0xffff);
                    pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                    pS->uRS += pP->iDRSDX;
                    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                                             pCtx->SI.uBB>>8, 0xff);
                    PUINT32 pSurface = (PUINT32)pS->pSurface;
                    *pSurface = uARGB;
                } else {
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
                        pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                        pS->uRS += pP->iDRSDX;
                    }
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_FOGENABLE]) {
                        pS->uFog += (INT16)pS->iDFog;
                        pCtx->SI.uFogB += pCtx->SI.iFogBDX;
                        pCtx->SI.uFogG += pCtx->SI.iFogGDX;
                        pCtx->SI.uFogR += pCtx->SI.iFogRDX;
                    }
                }
                if (--uPix <= 0)
                    break;
                pS->pZ += iZStep;
                pS->pSurface += iSurfaceStep;
#ifdef DBG
                // handy for debug to see where we are
                pS->uX += (INT16)pCtx->SI.iXStep;
#endif
            }

            pS++;
        }

        pP = pP->pNext;
    }

    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\stp_base.h ===
//----------------------------------------------------------------------------
//
// stp_base.h
//
// Basic types shared between C++ and assembly.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _STP_BASE_H_
#define _STP_BASE_H_

// Generic set of attribute values.  Used for holding current values
// and deltas.
typedef struct tagATTRSET
{
    union
    {
        struct
        {
            PUINT8 pSurface, pZ;
        };
        struct
        {
            INT32 ipSurface, ipZ;
        };
    };

    union
    {
        FLOAT fZ;
        INT32 iZ;
        UINT32 uZ;
    };
    union
    {
        FLOAT fOoW;
        INT32 iOoW;
    };

    union
    {
        struct
        {
            FLOAT fUoW1, fVoW1;
        };
        struct
        {
            INT32 iUoW1, iVoW1;
        };
    };

    union
    {
        struct
        {
            FLOAT fUoW2, fVoW2;
        };
        struct
        {
            INT32 iUoW2, iVoW2;
        };
    };

    union
    {
        struct
        {
            FLOAT fB, fG, fR, fA;
        };
        struct
        {
            INT32 iB, iG, iR, iA;
        };
        struct
        {
            UINT32 uB, uG, uR, uA;
        };
        struct
        {
            FLOAT fDIdx, fDIdxA;
        };
        struct
        {
            INT32 iDIdx, iDIdxA;
        };
        struct
        {
            UINT32 uDIdx, uDIdxA;
        };
    };

    union
    {
        struct
        {
            FLOAT fBS, fGS, fRS;
        };
        struct
        {
            INT32 iBS, iGS, iRS;
        };
        struct
        {
            UINT32 uBS, uGS, uRS;
        };
    };
    union
    {
        FLOAT fFog;
        INT32 iFog;
        UINT32 uFog;
    };
} ATTRSET, *PATTRSET;

// Parameters for doing int/carry arithmetic on a value.
typedef struct tagINTCARRYVAL
{
    INT iV;
    INT iFrac;
    INT iDFrac;
    INT iCY, iNC;
} INTCARRYVAL, *PINTCARRYVAL;

// Attribute handlers.
typedef struct tagSETUPCTX *PSETUPCTX;

typedef void (FASTCALL *PFN_ADDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta, PSETUPCTX pStpCtx);
typedef void (FASTCALL *PFN_ADDSCALEDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta,
     PSETUPCTX pStpCtx, int iScale);
typedef void (FASTCALL *PFN_FILLSPANATTRS)
    (PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
     PSETUPCTX pStpCtx, INT cPix);

extern PFN_ADDATTRS g_pfnAddFloatAttrsTable[];
extern PFN_ADDATTRS g_pfnRampAddFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnRampFillSpanFloatAttrsTable[];
#ifdef STEP_FIXED
extern PFN_ADDATTRS g_pfnAddFixedAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[];
#endif
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[];
extern PFN_ADDSCALEDATTRS g_pfnRampAddScaledFloatAttrsTable[];

// Triangle trapezoid walkers.
typedef HRESULT (FASTCALL *PFN_WALKTRAPSPANS)
    (UINT uSpans, PINTCARRYVAL pXOther,
     PSETUPCTX pStpCtx, BOOL bAdvanceLast);

extern PFN_WALKTRAPSPANS g_pfnWalkTrapFloatSpansNoClipTable[];
extern PFN_WALKTRAPSPANS g_pfnRampWalkTrapFloatSpansNoClipTable[];
#ifdef STEP_FIXED
extern PFN_WALKTRAPSPANS g_pfnWalkTrapFixedSpansNoClipTable[];
#endif

// Float-to-fixed attribute converters.
typedef void (FASTCALL *PFN_FLOATATTRSTOFIXED)
    (PATTRSET pfAttrs, PATTRSET piAttrs, PSETUPCTX pStpCtx);

#ifdef STEP_FIXED
extern PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[];
#endif

typedef void (FASTCALL *PFN_SETUPTRIATTR)
    (PSETUPCTX pStpCtx, LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
     LPD3DTLVERTEX pV2);

//
// Setup flags.
//

// Per primitive set.
#define PRIMSF_DIFF_USED                0x00000001
#define PRIMSF_SPEC_USED                0x00000002
#define PRIMSF_TEX1_USED                0x00000004
#define PRIMSF_TEX2_USED                0x00000008
#define PRIMSF_DIDX_USED                0x00000010
#define PRIMSF_LOCAL_FOG_USED           0x00000020
#define PRIMSF_GLOBAL_FOG_USED          0x00000040
#define PRIMSF_Z_USED                   0x00000080
#define PRIMSF_LOD_USED                 0x00000100
#define PRIMSF_PERSP_USED               0x00000200
#define PRIMSF_FLAT_SHADED              0x00000400

#define PRIMSF_COLORS_USED              (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED)
#define PRIMSF_TEX_USED                 (PRIMSF_TEX1_USED | PRIMSF_TEX2_USED)
#define PRIMSF_ALL_USED \
    (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED | \
     PRIMSF_TEX2_USED | PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_LOCAL_FOG_USED | PRIMSF_GLOBAL_FOG_USED | PRIMSF_PERSP_USED | \
     PRIMSF_DIDX_USED)

#define PRIMSF_SLOW_USED \
    (PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_LOCAL_FOG_USED | PRIMSF_GLOBAL_FOG_USED | PRIMSF_TEX2_USED)

#define PRIMSF_ALL \
    (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED | \
     PRIMSF_TEX2_USED | PRIMSF_DIDX_USED  | PRIMSF_LOCAL_FOG_USED |\
     PRIMSF_GLOBAL_FOG_USED | PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_PERSP_USED | PRIMSF_FLAT_SHADED)

// Per primitive.
#define PRIMF_FIXED_OVERFLOW            0x00001000
#define PRIMF_TRIVIAL_ACCEPT_Y          0x00002000
#define PRIMF_TRIVIAL_ACCEPT_X          0x00004000

#define PRIMF_ALL \
    (PRIMF_TRIVIAL_ACCEPT_Y | PRIMF_TRIVIAL_ACCEPT_X | PRIMF_FIXED_OVERFLOW)

// No point flags right now.
#define PTF_ALL 0

// Per line.
#define LNF_X_MAJOR                     0x00008000

#define LNF_ALL \
    (LNF_X_MAJOR)

// Per triangle.
#define TRIF_X_DEC                      0x00008000
#define TRIF_RASTPRIM_OVERFLOW          0x00010000

#define TRIF_ALL \
    (TRIF_X_DEC | TRIF_RASTPRIM_OVERFLOW)

// PWL support flags.
#define PWL_NEXT_LOD                    0x00000001

#ifdef PWL_FOG
#define PWL_NEXT_FOG                    0x00000002
// Suppress computation of next fog for lines.
// No equivalent flag for LOD since lines don't support LOD.
#define PWL_NO_NEXT_FOG                 0x00000004
#endif

// Setup information shared between C++ and assembly.
typedef struct tagSETUPCTX
{
    // Overall rasterization context.
    PD3DI_RASTCTX pCtx;

    // Current PrimProcessor for span allocator calls.
    PVOID PrimProcessor;

    // Current primitive.
    PD3DI_RASTPRIM pPrim;

    // Per-primitive flags.
    UINT uFlags;

    // Flat shading vertex pointer.
    LPD3DTLVERTEX pFlatVtx;

    // Maximum span length allowed.
    INT cMaxSpan;

    //
    // Piecewise-linear support for LOD and global fog.
    //
    UINT uPwlFlags;

    // LOD.
    FLOAT fNextW;
    FLOAT fNextOoW;
    FLOAT fNextUoW1, fNextVoW1;
    INT iNextLOD;

    // Local fog X delta.  Fog deltas are always sent through RASTSPAN
    // instead of RASTPRIM to make the local and global cases the same.
    // For the local fog case where the delta doesn't change convert
    // it once and keep it here.
    INT iDLocalFogDX;
#ifdef PWL_FOG
    // Global fog.
    FLOAT fNextZ;
    UINT uNextFog;
#endif

    // Attribute handling functions.
    PFN_ADDATTRS pfnAddAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrs;
    PFN_FILLSPANATTRS pfnFillSpanAttrs;

    // Edge walking function.
    PFN_WALKTRAPSPANS pfnWalkTrapSpans;

    // Triangle attribute setup beads.
    PFN_SETUPTRIATTR pfnTriSetupFirstAttr;
    PFN_SETUPTRIATTR pfnTriSetupZEnd;
    PFN_SETUPTRIATTR pfnTriSetupTex1End;
    PFN_SETUPTRIATTR pfnTriSetupTex2End;
    PFN_SETUPTRIATTR pfnTriSetupDiffEnd;
    PFN_SETUPTRIATTR pfnTriSetupSpecEnd;
    PFN_SETUPTRIATTR pfnTriSetupFogEnd;

    // Current X and Y values.
    INT iX, iY;

    union
    {
        // Edge fraction and delta for lines.
        struct
        {
            INT iLineFrac, iDLineFrac;
        };

        // Edge X walkers for triangles.
        struct
        {
            INTCARRYVAL X20, X10, X21;
        };
    };

    // Floating-point versions of X20 NC and CY values for setup.
    FLOAT fX20NC, fX20CY;

    // Long edge attribute values.
    ATTRSET Attr;

    union
    {
        // Attribute major axis deltas for lines.
        ATTRSET DAttrDMajor;

        // Attribute X deltas for triangles.
        ATTRSET DAttrDX;
    };

    // Attribute Y deltas.
    ATTRSET DAttrDY;

    // Span-to-span deltas when attribute edge carries a pixel.
    INT iDXCY, iDYCY;
    ATTRSET DAttrCY;

    // Span-to-span deltas when attribute edge doesn't carry a pixel.
    INT iDXNC, iDYNC;
    ATTRSET DAttrNC;

    union
    {
        // One over length for lines.
        FLOAT fOoLen;

        // One over determinant for triangles.
        FLOAT fOoDet;
    };

    // Edge deltas.
    FLOAT fDX10, fDY10;
    FLOAT fDX20, fDY20;

    // Normalized edge deltas.
    FLOAT fNX10, fNY10;
    FLOAT fNX20, fNY20;

    // Subpixel correction amounts.
    union
    {
        // Lines.
        FLOAT fDMajor;

        // Triangles.
        struct
        {
            FLOAT fDX, fDY;
        };
    };

    // Pixel length of line.
    INT cLinePix;
} SETUPCTX;

#endif // #ifndef _STP_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\setup.hpp ===
//----------------------------------------------------------------------------
//
// setup.hpp
//
// Setup declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SETUP_HPP_
#define _SETUP_HPP_

#pragma warning(disable:4786)

#include "stp_base.h"

// PrimProcessor flags.
#define PPF_IN_BEGIN                    0x00000001
#define PPF_STATE_CHANGED               0x00000002
#define PPF_NORMALIZE_RHW               0x00000004
#define PPF_DRAW_LAST_LINE_PIXEL        0x00000008

// Bounds for normalized RHWs.  These are not quite the ideal bounds to
// avoid over- and underflow after normalization when at least one RHW is
// guaranteed to be at the bounds.  There is no reason it
// has to be normalized to [0,1] anway, other than to try and spread
// the values across the desired range.
#define NORMALIZED_RHW_MIN g_fZero
#define NORMALIZED_RHW_MAX g_fp95

//----------------------------------------------------------------------------
//
// PrimProcessor
//
// Accepts primitives to be rasterized.  Primitive and span descriptions
// are put into a buffer for later processing by the span-level code.
//
//----------------------------------------------------------------------------

class DllExport PrimProcessor
{
public:
    PrimProcessor(void);
    HRESULT Initialize(void);
    ~PrimProcessor(void);

    inline UINT GetFlags(void);
    inline void SetFlags(UINT uFlags);
    inline void ClrFlags(UINT uFlags);

    inline void StateChanged();

    void SetCtx(PD3DI_RASTCTX pCtx);

    void BeginPrimSet(D3DPRIMITIVETYPE PrimType,
                      RAST_VERTEX_TYPE VertType);

    HRESULT Point(LPD3DTLVERTEX pV0,
                  LPD3DTLVERTEX pFlatVtx);
    HRESULT Line(LPD3DTLVERTEX pV0,
                 LPD3DTLVERTEX pV1,
                 LPD3DTLVERTEX pFlatVtx);
    HRESULT Tri(LPD3DTLVERTEX pV0,
                LPD3DTLVERTEX pV1,
                LPD3DTLVERTEX pV2);

    void Begin(void);
    HRESULT End(void);

    HRESULT AllocSpans(PUINT pcSpans, PD3DI_RASTSPAN *ppSpan);
    void FreeSpans(UINT cSpans);

private:
    // Original FP control word.
    UINT16 m_uFpCtrl;

    // Buffer space and current pointer.
    PUINT8 m_pBuffer;
    PUINT8 m_pBufferStart;
    PUINT8 m_pBufferEnd;
    PUINT8 m_pCur;

    // Flags.
    UINT m_uPpFlags;

    //
    // Intermediate results shared between methods.
    //

    SETUPCTX m_StpCtx;

    // Previous primitive, for primitive chaining.
    PD3DI_RASTPRIM m_pOldPrim;

    // Attribute function table index.
    INT m_iAttrFnIdx;

    // Old primitive and vertex types.
    D3DPRIMITIVETYPE m_PrimType;
    RAST_VERTEX_TYPE m_VertType;

    //
    // Triangle values.
    //

    // Y values and trapezoid heights.
    INT m_iY1, m_iY2;
    UINT m_uHeight10, m_uHeight21, m_uHeight20;

    // Triangle X extent.
    INT m_iXWidth;

    // Original RHW saved during RHW normalization.
    D3DVALUE m_dvV0RHW;
    D3DVALUE m_dvV1RHW;
    D3DVALUE m_dvV2RHW;

    //
    // Point methods.
    //
    void NormalizePointRHW(LPD3DTLVERTEX pV0);
    void FillPointSpan(LPD3DTLVERTEX pV0, PD3DI_RASTSPAN pSpan);

    //
    // Line methods.
    //
    void NormalizeLineRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1);
    BOOL PointDiamondCheck(INT32 iXFrac, INT32 iYFrac,
                           BOOL bSlopeIsOne, BOOL bSlopeIsPosOne);
    BOOL LineSetup(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1);

    //
    // Triangle methods.
    //
    void NormalizeTriRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                         LPD3DTLVERTEX pV2);
    BOOL TriSetup(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1, LPD3DTLVERTEX pV2);
    inline void SetTriFunctions(void);

    //
    // Buffer management methods.
    //
    inline void ResetBuffer(void);
    HRESULT Flush(void);
    HRESULT FlushPartial(void);
    HRESULT AppendPrim(void);

#if DBG
    //
    // Debug methods.  Only callable within DBG builds.
    //
    inline HRESULT ValidateVertex(LPD3DTLVERTEX pV);
#endif
};

//----------------------------------------------------------------------------
//
// PrimProcessor::GetFlags
//
// Returns the current PrimProcessor flags.
//
//----------------------------------------------------------------------------

inline UINT
PrimProcessor::GetFlags(void)
{
    return m_uPpFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::SetFlags
//
// Sets the given flags.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::SetFlags(UINT uFlags)
{
    m_uPpFlags |= uFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ClrFlags
//
// Clears the given flags.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::ClrFlags(UINT uFlags)
{
    m_uPpFlags &= ~uFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::StateChanged
//
// Notifies the PrimProcessor that state has changed.
// Could be done through SetFlags but this hides the actual implementation.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::StateChanged(void)
{
    m_uPpFlags |= PPF_STATE_CHANGED;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ComputeIntCarry
//
// Takes an FP coordinate value and span delta and computes integer form
// for int/carry arithmetic.
//
// NOTE: Assumes iV already computed.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

// Prototype is:
// inline void
// PrimProcessor::ComputeIntCarry(FLOAT fV, FLOAT fDVDS, PINTCARRYVAL pICY)
//
// Fraction is biased by one to handle exactly-integer coordinate
// values properly.

#define ComputeIntCarry(fV, fDVDS, pICY)                                      \
    ((pICY)->iFrac = (SCALED_FRACTION((fV) - FLOORF(fV)) - 1) & 0x7fffffff,   \
     (pICY)->iNC = FTOI(fDVDS),                                               \
     (pICY)->iDFrac = SCALED_FRACTION((fDVDS) - (pICY)->iNC),                 \
     (pICY)->iCY = FLOAT_LTZ(fDVDS) ? (pICY)->iNC - 1 : (pICY)->iNC + 1)

//----------------------------------------------------------------------------
//
// PrimProcessor::GetPrim
//
// Moves prim pointer to the next position in the buffer, flushing
// to make space if necessary.  Checks to see if there's space for
// at least one span also since it doesn't make much sense to not
// flush if there's exactly enough space for just the prim structure.
//
// Does not update m_pCur until CommitPrim.  m_pCur == pPrim
// indicates pPrim is not fully valid.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

#define GET_PRIM()                                                            \
{                                                                             \
    if (m_pCur + (sizeof(D3DI_RASTPRIM) + sizeof(D3DI_RASTSPAN)) >            \
        m_pBufferEnd)                                                         \
    {                                                                         \
        HRESULT hr;                                                           \
                                                                              \
        RSHRRET(Flush());                                                     \
    }                                                                         \
                                                                              \
    m_StpCtx.pPrim = (PD3DI_RASTPRIM)m_pCur;                                  \
}

//----------------------------------------------------------------------------
//
// PrimProcessor::CommitPrim
//
// Commits the current primitive space so that spans may be added.
// The primitive data can be partly or fulled cleared as part of
// the commit.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

#define COMMIT_PRIM(bClearAll)                                                \
{                                                                             \
    m_pCur = (PUINT8)(m_StpCtx.pPrim + 1);                                    \
                                                                              \
    if (m_pOldPrim != NULL)                                                   \
    {                                                                         \
        m_pOldPrim->pNext = m_StpCtx.pPrim;                                   \
    }                                                                         \
    m_pOldPrim = m_StpCtx.pPrim;                                              \
                                                                              \
    if (bClearAll)                                                            \
    {                                                                         \
        memset(m_StpCtx.pPrim, 0, sizeof(*m_StpCtx.pPrim));                   \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        m_StpCtx.pPrim->uSpans = 0;                                           \
        m_StpCtx.pPrim->pNext = NULL;                                         \
    }                                                                         \
}

#define ALLOC_SPANS(pStpCtx, pcSpans, ppSpan) \
    ((PrimProcessor *)pStpCtx->PrimProcessor)->AllocSpans(pcSpans, ppSpan)
#define FREE_SPANS(pStpCtx, cSpans) \
    ((PrimProcessor *)pStpCtx->PrimProcessor)->FreeSpans(cSpans)

// Compute texture difference times 1/W.
#define PERSP_TEXTURE_DELTA(fTb, fRb, fTa, fTRa, iWrap)                       \
    ((TextureDiff((fTb), (fTa), (iWrap)) + (fTa)) * (fRb) - (fTRa))

// Extract components from a packed color.
#define SPLIT_COLOR(uPacked, uB, uG, uR, uA)                                  \
    ((uB) = (UINT)RGBA_GETBLUE(uPacked),                                      \
     (uG) = (UINT)RGBA_GETGREEN(uPacked),                                     \
     (uR) = (UINT)RGBA_GETRED(uPacked),                                       \
     (uA) = (UINT)RGBA_GETALPHA(uPacked))

// Compute FP deltas from the difference of the given packed color
// and the given components.
#define COLOR_DELTA(uPacked, uB, uG, uR, uA, fDB, fDG, fDR, fDA)              \
    ((fDB) = (FLOAT)((INT)((UINT)RGBA_GETBLUE(uPacked)-(uB)) << COLOR_SHIFT), \
     (fDG) = (FLOAT)((INT)((UINT)RGBA_GETGREEN(uPacked)-(uG)) << COLOR_SHIFT),\
     (fDR) = (FLOAT)((INT)((UINT)RGBA_GETRED(uPacked)-(uR)) << COLOR_SHIFT),  \
     (fDA) = (FLOAT)((INT)((UINT)RGBA_GETALPHA(uPacked)-(uA)) << COLOR_SHIFT))

// Extract components from a packed index color.
// Applies a .5F offset to the color index to effect rounding
// when the color index is truncated.
#define SPLIT_IDX_COLOR(uPacked, iIdx, iA)                                    \
    ((iIdx) = (INT32)CI_MASKALPHA(uPacked) + (1<<(INDEX_COLOR_VERTEX_SHIFT-1)),                                   \
     (iA) = (INT32)CI_GETALPHA(uPacked))

#define IDX_COLOR_DELTA(uPacked, iIdx, iA, fDIdx, fDA)                        \
    ((fDIdx) = (FLOAT)((((INT32)CI_MASKALPHA(uPacked) +                       \
                    (1<<(INDEX_COLOR_VERTEX_SHIFT-1))) - (iIdx)) <<           \
                       INDEX_COLOR_FIXED_SHIFT),                              \
     (fDA) = (FLOAT)(((INT32)CI_GETALPHA(uPacked) - (iA)) <<                  \
                     INDEX_COLOR_SHIFT))

#endif // #ifndef _SETUP_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mlspan\nothing.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// Does nothing and is only used as a test to see if bead selector can get here.
//
//-----------------------------------------------------------------------------
HRESULT Monolithic_RenderSpansTestSelector(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            //pCtx->pfnBegin(pCtx, pP, pS);
            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxemul\sources.inc ===
TARGETNAME = mmxemul
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\mmxemul.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mlspan\sources.inc ===
TARGETNAME = rmlspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\cmlrast.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxemul\mmxemul.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains routines that emulate MMX instructions in ordinary C
// for algorithm development.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "d3dtypesp.h"
#include "d3ditype.h"
#include "mmxemul.h"

UINT16 MMX_addsw(INT16 x, INT16 y)
{
    INT32 z = x + y;
    if (z > 0x7fff)
        z = 0x7fff;
    if (z < -32768)
        z = -32768;
    return (INT16)z;
}

INT16  MMX_addusw(UINT16 x, UINT16 y)
{
    INT32 z = (INT32)x + (INT32)y;
    if (z > 0xffff)
        z = 0xffff;
    if (z < 0)
        z = 0;
    return (UINT16)z;
}

UINT16 MMX_cmpeqw(INT16 x, INT16 y)
{
    if (x == y) {
        return 0xffff;
    } else {
        return 0x0;
    }
}

UINT16 MMX_cmpgtw(INT16 x, INT16 y)
{
    if (x > y) {
        return 0xffff;
    } else {
        return 0x0;
    }
}

// Emulate 16 bit MMX style multiplies
// Note that MULHW only works with signed operands, but MULLW works for
// signed and unsigned operands.
INT16 MMX_mulhw(INT16 x, INT16 y)
{
    INT32 z = x*y;
    INT16 r = (INT16)(z>>16);
    return r;
}

INT16 MMX_mullw(INT16 x, INT16 y)
{
    INT32 z = x*y;
    INT16 r = z & 0xffff;
    return r;
}

INT16 MMX_subsw(INT16 x, INT16 y)
{
    INT32 z = x - y;
    if (z > 0x7fff)
        z = 0x7fff;
    if (z < -32768)
        z = -32768;
    return (INT16)z;
}

UINT16 MMX_subusw(UINT16 x, UINT16 y)
{
    INT32 z = (INT32)x - (INT32)y;
    if (z > 0xffff)
        z = 0xffff;
    if (z < 0)
        z = 0;
    return (UINT16)z;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\bufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR MMX_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR MMX_BufRead_Palette8(PUINT8 pBits);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\i386src.inc ===
i386_SOURCES = \
        $O\atest.asm\
        $O\bldfuncs.asm\
        $O\bufread.asm\
        $O\bufwrite.asm\
        $O\colorbld.asm\
        $O\colorgen.asm\
        $O\spanpars.asm\
        ..\spanutil.cpp\
        $O\test.asm\
        $O\tex1addr.asm\
        $O\tex2addr.asm\
        $O\texblend.asm\
        $O\texread.asm\
        $O\tstfail.asm\
        $O\ml1.asm\
        $O\ml2.asm\
        $O\ml3.asm\
        $O\ml4.asm\
        $O\ml5.asm\
        $O\ml6.asm\
        $O\ml7.asm\
        $O\ml8.asm\
        $O\ml9.asm\
        $O\ml10.asm\
        $O\ml11.asm\
        $O\ml12.asm\
        $O\ml13.asm\
        $O\ml14.asm\
        $O\ml15.asm\
        $O\ml16.asm\
        $O\ml17.asm\
        $O\ml18.asm\
        $O\ml19.asm\
        $O\ml20.asm\
        $O\ml21.asm\
        $O\ml22.asm\
        $O\ml23.asm\
        $O\ml24.asm\
        $O\ml25.asm\
        $O\ml26.asm\
        $O\ml27.asm\
        $O\ml28.asm

NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES) \
        $O\clrbd_mh.h\
        $O\clrgn_mh.h\
        $O\test_mh.h\
        $O\tex1a_mh.h\
        $O\tex2a_mh.h\
        $O\texbd_mh.h\
        $O\texrd_mh.h\
        $O\tstf_mh.h\
        $O\atest_mh.h\
        $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\bufwrite.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void MMX_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\loop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

void MMX_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\bldfuncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

void MMX_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void MMX_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\iammx.inc ===
;/*
;*    INTEL CORPORATION PROPRIETARY INFORMATION 
;*
;*    This software is supplied under the terms of a license
;*    agreement or nondisclosure agreement with Intel Corporation 
;*    and may not be copied or disclosed except in accordance with 
;*    the terms of that agreement.
;*    Copyright (c) 1991,1992,1993  Intel Corporation. 
;*
;*/
;NOTE:NOTE:NOTE:
; IF YOU MODIFY ANY OF THE OPCODES HERE, MAKE SURE TO REFLECT THAT
; IN THE ValidMmxOpcode[] array in mm.c. 
;
;Please use MMWORD and not DWORD (QWORD does not work) for 64 bit data 
; in MMX instructions. After getting a real assembler you will just have to
; add the line " MMWORD	TEXTEQU	<QWORD>" to your code.
MMWORD	TEXTEQU	<DWORD>
opc_Rdpmc     = 033H
opc_Emms      = 077H
opc_Movd_ld   = 06EH
opc_Movd_st   = 07EH
opc_Movq_ld   = 06FH
opc_Movq_st   = 07FH
opc_Packssdw  = 06BH
opc_Packsswb  = 063H
opc_Packuswb  = 067H
opc_Paddb     = 0FCH
opc_Paddd     = 0FEH
opc_Paddsb    = 0ECH
opc_Paddsw    = 0EDH
opc_Paddusb   = 0DCH
opc_Paddusw   = 0DDH
opc_Paddw     = 0FDH
opc_Pand      = 0DBH
opc_Pandn     = 0DFH
opc_Pcmpeqb   = 074H
opc_Pcmpeqd   = 076H
opc_Pcmpeqw   = 075H
opc_Pcmpgtb   = 064H
opc_Pcmpgtd   = 066H
opc_Pcmpgtw   = 065H
opc_Pmaddwd   = 0F5H
opc_Pmulhw    = 0E5H
opc_Pmullw    = 0D5H
opc_Por       = 0EBH
opc_PSHimd    = 072H
opc_PSHimq    = 073H
opc_PSHimw    = 071H
opc_Pslld     = 0F2H
opc_Psllq     = 0F3H
opc_Psllw     = 0F1H
opc_Psrad     = 0E2H
opc_Psraw     = 0E1H
opc_Psrld     = 0D2H
opc_Psrlq     = 0D3H
opc_Psrlw     = 0D1H
opc_Psubb     = 0F8H
opc_Psubd     = 0FAH
opc_Psubsb    = 0E8H
opc_Psubsw    = 0E9H
opc_Psubusb   = 0D8H
opc_Psubusw   = 0D9H
opc_Psubw     = 0F9H
opc_Punpcklbw = 060H
opc_Punpckldq = 062H
opc_Punpcklwd = 061H
opc_Punpckhbw = 068H
opc_Punpckhdq = 06AH
opc_Punpckhwd = 069H
opc_Pxor      = 0EFH

.486P

; ALIAS R# to MM# registers

DefineMMxRegs Macro
IFDEF APP_16BIT
	MM0	TEXTEQU	<AX>
	MM1	TEXTEQU	<CX>
	MM2	TEXTEQU	<DX>
	MM3	TEXTEQU	<BX>
	MM4	TEXTEQU	<SP>
	MM5	TEXTEQU	<BP>
	MM6	TEXTEQU	<SI>
	MM7	TEXTEQU	<DI>

	mm0	TEXTEQU	<AX>
	mm1	TEXTEQU	<CX>
	mm2	TEXTEQU	<DX>
	mm3	TEXTEQU	<BX>
	mm4	TEXTEQU	<SP>
	mm5	TEXTEQU	<BP>
	mm6	TEXTEQU	<SI>
	mm7	TEXTEQU	<DI>

	Mm0	TEXTEQU	<AX>
	Mm1	TEXTEQU	<CX>
	Mm2	TEXTEQU	<DX>
	Mm3	TEXTEQU	<BX>
	Mm4	TEXTEQU	<SP>
	Mm5	TEXTEQU	<BP>
	Mm6	TEXTEQU	<SI>
	Mm7	TEXTEQU	<DI>

	mM0	TEXTEQU	<AX>
	mM1	TEXTEQU	<CX>
	mM2	TEXTEQU	<DX>
	mM3	TEXTEQU	<BX>
	mM4	TEXTEQU	<SP>
	mM5	TEXTEQU	<BP>
	mM6	TEXTEQU	<SI>
	mM7	TEXTEQU	<DI>

ELSE
	MM0	TEXTEQU	<EAX>
	MM1	TEXTEQU	<ECX>
	MM2	TEXTEQU	<EDX>
	MM3	TEXTEQU	<EBX>
	MM4	TEXTEQU	<ESP>
	MM5	TEXTEQU	<EBP>
	MM6	TEXTEQU	<ESI>
	MM7	TEXTEQU	<EDI>

	mm0	TEXTEQU	<EAX>
	mm1	TEXTEQU	<ECX>
	mm2	TEXTEQU	<EDX>
	mm3	TEXTEQU	<EBX>
	mm4	TEXTEQU	<ESP>
	mm5	TEXTEQU	<EBP>
	mm6	TEXTEQU	<ESI>
	mm7	TEXTEQU	<EDI>

	Mm0	TEXTEQU	<EAX>
	Mm1	TEXTEQU	<ECX>
	Mm2	TEXTEQU	<EDX>
	Mm3	TEXTEQU	<EBX>
	Mm4	TEXTEQU	<ESP>
	Mm5	TEXTEQU	<EBP>
	Mm6	TEXTEQU	<ESI>
	Mm7	TEXTEQU	<EDI>

	mM0	TEXTEQU	<EAX>
	mM1	TEXTEQU	<ECX>
	mM2	TEXTEQU	<EDX>
	mM3	TEXTEQU	<EBX>
	mM4	TEXTEQU	<ESP>
	mM5	TEXTEQU	<EBP>
	mM6	TEXTEQU	<ESI>
	mM7	TEXTEQU	<EDI>
ENDIF
EndM

; ALIAS R# to MM# registers
DefineMMxNUM Macro
	MM0	TEXTEQU	<0>
	MM1	TEXTEQU	<0>
	MM2	TEXTEQU	<0>
	MM3	TEXTEQU	<0>
	MM4	TEXTEQU	<0>
	MM5	TEXTEQU	<0>
	MM6	TEXTEQU	<0>
	MM7	TEXTEQU	<0>

	mm0	TEXTEQU	<0>
	mm1	TEXTEQU	<0>
	mm2	TEXTEQU	<0>
	mm3	TEXTEQU	<0>
	mm4	TEXTEQU	<0>
	mm5	TEXTEQU	<0>
	mm6	TEXTEQU	<0>
	mm7	TEXTEQU	<0>

	Mm0	TEXTEQU	<0>
	Mm1	TEXTEQU	<0>
	Mm2	TEXTEQU	<0>
	Mm3	TEXTEQU	<0>
	Mm4	TEXTEQU	<0>
	Mm5	TEXTEQU	<0>
	Mm6	TEXTEQU	<0>
	Mm7	TEXTEQU	<0>

	mM0	TEXTEQU	<0>
	mM1	TEXTEQU	<0>
	mM2	TEXTEQU	<0>
	mM3	TEXTEQU	<0>
	mM4	TEXTEQU	<0>
	mM5	TEXTEQU	<0>
	mM6	TEXTEQU	<0>
	mM7	TEXTEQU	<0>
EndM



UnDefineMMxRegs Macro
	MM0	TEXTEQU	<MM0>
	MM1	TEXTEQU	<MM1>
	MM2	TEXTEQU	<MM2>
	MM3	TEXTEQU	<MM3>
	MM4	TEXTEQU	<MM4>
	MM5	TEXTEQU	<MM5>
	MM6	TEXTEQU	<MM6>
	MM7	TEXTEQU	<MM7>

	mm0	TEXTEQU	<mm0>
	mm1	TEXTEQU	<mm1>
	mm2	TEXTEQU	<mm2>
	mm3	TEXTEQU	<mm3>
	mm4	TEXTEQU	<mm4>
	mm5	TEXTEQU	<mm5>
	mm6	TEXTEQU	<mm6>
	mm7	TEXTEQU	<mm7>

	Mm0	TEXTEQU	<Mm0>
	Mm1	TEXTEQU	<Mm1>
	Mm2	TEXTEQU	<Mm2>
	Mm3	TEXTEQU	<Mm3>
	Mm4	TEXTEQU	<Mm4>
	Mm5	TEXTEQU	<Mm5>
	Mm6	TEXTEQU	<Mm6>
	Mm7	TEXTEQU	<Mm7>

	mM0	TEXTEQU	<mM0>
	mM1	TEXTEQU	<mM1>
	mM2	TEXTEQU	<mM2>
	mM3	TEXTEQU	<mM3>
	mM4	TEXTEQU	<mM4>
	mM5	TEXTEQU	<mM5>
	mM6	TEXTEQU	<mM6>
	mM7	TEXTEQU	<mM7>
EndM


rdpmc     macro
	db	0fh, opc_Rdpmc
endm

emms     macro
	db	0fh, opc_Emms
endm



movd   macro   dst:req, src:req
        local   x, y

		DefineMMxNUM

IF (OPATTR(dst)) AND 00010000y ; register
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
		UnDefineMMxRegs
ELSE
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
ENDIF
		UnDefineMMxRegs
ENDIF
        endm

movdt    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
		UnDefineMMxRegs
        endm

movdf   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st
        org     y
		UnDefineMMxRegs
        endm

movq   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movq_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movq_st 
        org     y
ENDIF
		UnDefineMMxRegs
        endm


packssdw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packssdw
        org     y
		UnDefineMMxRegs
        endm

packsswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packsswb
        org     y
		UnDefineMMxRegs
        endm

packuswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packuswb
        org     y
		UnDefineMMxRegs
        endm

paddd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddd   
        org     y
		UnDefineMMxRegs
        endm

paddsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsb  
        org     y
		UnDefineMMxRegs
        endm

paddsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsw  
        org     y
		UnDefineMMxRegs
        endm

paddusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusb 
        org     y
		UnDefineMMxRegs
        endm

paddusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusw 
        org     y
		UnDefineMMxRegs
        endm

paddb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddb   
        org     y
		UnDefineMMxRegs
        endm

paddw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddw   
        org     y
		UnDefineMMxRegs
        endm

pand    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pand    
        org     y
		UnDefineMMxRegs
        endm

pandn    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pandn   
        org     y
		UnDefineMMxRegs
        endm

pcmpeqb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqb 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqd 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqw 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtb 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtd 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtw 
        org     y
		UnDefineMMxRegs
        endm

pmaddwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmaddwd 
        org     y
		UnDefineMMxRegs
        endm

pmulhw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmulhw  
        org     y
		UnDefineMMxRegs
        endm

pmullw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmullw  
        org     y
		UnDefineMMxRegs
        endm

por    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Por     
        org     y
		UnDefineMMxRegs
        endm


pslld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pslld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psllw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrad    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrad   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psraw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psraw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrlq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psllq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psrlw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psubsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsb  
        org     y
		UnDefineMMxRegs
        endm

psubsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsw  
        org     y
		UnDefineMMxRegs
        endm

psubusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusb 
        org     y
		UnDefineMMxRegs
        endm

psubusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusw 
        org     y
		UnDefineMMxRegs
        endm

psubb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubb   
        org     y
		UnDefineMMxRegs
        endm

psubw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubw   
        org     y
		UnDefineMMxRegs
        endm

punpcklbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklbw
        org     y
		UnDefineMMxRegs
        endm

punpckhdq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhdq
        org     y
		UnDefineMMxRegs
        endm

punpcklwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklwd
        org     y
		UnDefineMMxRegs
        endm

punpckhbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhbw
        org     y
		UnDefineMMxRegs
        endm

punpckldq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckldq
        org     y
		UnDefineMMxRegs
        endm

punpckhwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhwd
        org     y
		UnDefineMMxRegs
        endm

pxor    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pxor    
        org     y
		UnDefineMMxRegs
        endm

psubd   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubd   
        org     y
		UnDefineMMxRegs
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\makefile.inc ===
$(GENTGT)\clrbd_mh.h: ..\clrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\clrgn_mh.h: ..\clrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\test_mh.h: ..\test_mh.mh $(RAST_STD_M4)

$(GENTGT)\tex1a_mh.h: ..\tex1a_mh.mh ..\texaddra.mh $(RAST_STD_M4)

$(GENTGT)\tex2a_mh.h: ..\tex2a_mh.mh ..\texaddra.mh $(RAST_STD_M4)

$(GENTGT)\texbd_mh.h: ..\texbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\texrd_mh.h: ..\texrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\tstf_mh.h: ..\tstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\atest_mh.h: ..\atest_mh.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): ..\offs_acp.acp \
        ..\..\..\inc\span.h ..\..\inc\stp_base.h

$(GENTGT)\beadtbl.cpp: ..\beadtbl.mcp $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\atest.asm: ..\atest.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\bldfuncs.asm: ..\bldfuncs.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\bufread.asm: ..\bufread.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\bufwrite.asm: ..\bufwrite.mas ..\bufwrite.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\colorbld.asm: ..\colorbld.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\colorgen.asm: ..\colorgen.mas ..\colorgen.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\test.asm: ..\test.mas ..\test.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\tex1addr.asm: ..\tex1addr.mas ..\cvars.mh ..\texaddra.mh $(RAST_STD_M4)

$(GENTGT)\tex2addr.asm: ..\tex2addr.mas ..\cvars.mh ..\texaddra.mh $(RAST_STD_M4)

$(GENTGT)\texblend.asm: ..\texblend.mas ..\texblend.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\texread.asm: ..\texread.mas ..\texread.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\tstfail.asm: ..\tstfail.mas ..\tstfail.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\spanpars.asm: ..\spanpars.mas ..\cvars.mh $(RAST_STD_M4)

$(GENGT)\ml1.asm: ..\ml1.mas $(RAST_STD_M4)
$(GENGT)\ml2.asm: ..\ml2.mas $(RAST_STD_M4)
$(GENGT)\ml3.asm: ..\ml3.mas $(RAST_STD_M4)
$(GENGT)\ml4.asm: ..\ml4.mas $(RAST_STD_M4)
$(GENGT)\ml5.asm: ..\ml5.mas $(RAST_STD_M4)
$(GENGT)\ml6.asm: ..\ml6.mas $(RAST_STD_M4)
$(GENGT)\ml7.asm: ..\ml7.mas $(RAST_STD_M4)
$(GENGT)\ml8.asm: ..\ml8.mas $(RAST_STD_M4)
$(GENGT)\ml9.asm: ..\ml9.mas $(RAST_STD_M4)
$(GENGT)\ml10.asm: ..\ml10.mas $(RAST_STD_M4)
$(GENGT)\ml11.asm: ..\ml11.mas $(RAST_STD_M4)
$(GENGT)\ml12.asm: ..\ml12.mas $(RAST_STD_M4)
$(GENGT)\ml13.asm: ..\ml13.mas $(RAST_STD_M4)
$(GENGT)\ml14.asm: ..\ml14.mas $(RAST_STD_M4)
$(GENGT)\ml15.asm: ..\ml15.mas $(RAST_STD_M4)
$(GENGT)\ml16.asm: ..\ml16.mas $(RAST_STD_M4)
$(GENGT)\ml17.asm: ..\ml17.mas $(RAST_STD_M4)
$(GENGT)\ml18.asm: ..\ml18.mas $(RAST_STD_M4)
$(GENGT)\ml19.asm: ..\ml19.mas $(RAST_STD_M4)
$(GENGT)\ml20.asm: ..\ml20.mas $(RAST_STD_M4)
$(GENGT)\ml21.asm: ..\ml21.mas $(RAST_STD_M4)
$(GENGT)\ml22.asm: ..\ml22.mas $(RAST_STD_M4)
$(GENGT)\ml23.asm: ..\ml23.mas $(RAST_STD_M4)
$(GENGT)\ml24.asm: ..\ml24.mas $(RAST_STD_M4)
$(GENGT)\ml25.asm: ..\ml25.mas $(RAST_STD_M4)
$(GENGT)\ml26.asm: ..\ml26.mas $(RAST_STD_M4)
$(GENGT)\ml27.asm: ..\ml27.mas $(RAST_STD_M4)
$(GENGT)\ml28.asm: ..\ml28.mas $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\nommxsrc.inc ===
NTTARGETFILE0 = $(NTTARGETFILE0) \
        $O\clrbd_mh.h\
        $O\clrgn_mh.h\
        $O\test_mh.h\
        $O\tex1a_mh.h\
        $O\tex2a_mh.h\
        $O\texbd_mh.h\
        $O\texrd_mh.h\
        $O\atest_mh.h\
        $O\tstf_mh.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\spanpars.h ===
//----------------------------------------------------------------------------
//
// spanpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

#ifdef __cplusplus
  extern "C" {
#endif


HRESULT MMX_RenderSpansAny(PD3DI_RASTCTX pCtx);

#ifdef __cplusplus
  }
#endif


#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\sources.inc ===
TARGETNAME = rmmxspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;..\..\refrast;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        $O\beadtbl.cpp

NTTARGETFILE0 = \
        $O\beadtbl.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\spanutil.cpp ===
//----------------------------------------------------------------------------
//
// spanutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\spanutil.h ===
//----------------------------------------------------------------------------
//
// spanutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\stp_base.h ===
//----------------------------------------------------------------------------
//
// stp_base.h
//
// Basic types shared between C++ and assembly.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _STP_BASE_H_
#define _STP_BASE_H_

// Generic set of attribute values.  Used for holding current values
// and deltas.
// ATTENTION - It may be better to use RASTSPAN.  RASTSPAN has some extra
// space that'd go unused but then it'd be possible to memcpy ATTRSETs
// to RASTSPANs during fixed-point edge walking.
typedef struct tagATTRSET
{
    union
    {
        FLOAT fZ;
        INT32 iZ;
        UINT32 uZ;
    };
    union
    {
        FLOAT fOoW;
        INT32 iOoW;
    };
    union
    {
        struct
        {
            FLOAT fUoW1, fVoW1;
        };
        struct
        {
            INT32 iUoW1, iVoW1;
        };
    };
    union
    {
        struct
        {
            FLOAT fB, fG, fR, fA;
        };
        struct
        {
            INT32 iB, iG, iR, iA;
        };
        struct
        {
            UINT32 uB, uG, uR, uA;
        };
    };
    union
    {
        struct
        {
            FLOAT fBS, fGS, fRS, fFog;
        };
        struct
        {
            INT32 iBS, iGS, iRS, iFog;
        };
        struct
        {
            UINT32 uBS, uGS, uRS, uFog;
        };
        struct
        {
            FLOAT fUoW2, fVoW2;
        };
        struct
        {
            INT32 iUoW2, iVoW2;
        };
    };
    union
    {
        struct
        {  
            PUINT8 pSurface, pZ;
        };
        struct
        {  
            INT32 ipSurface, ipZ;
        };
    };
} ATTRSET, *PATTRSET;

// Parameters for doing int/carry arithmetic on a value.
typedef struct tagINTCARRYVAL
{
    INT iV;
    INT iFrac;
    INT iDFrac;
    INT iCY, iNC;
} INTCARRYVAL, *PINTCARRYVAL;

// Attribute handlers.
typedef void (FASTCALL *PFN_ADDATTRS)(PATTRSET pAttrs, PATTRSET pDelta);
typedef void (FASTCALL *PFN_ADDSCALEDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta, int iScale, FLOAT fNextOoW);
typedef void (FASTCALL *PFN_FILLSPANATTRS)
    (PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
     struct tagSETUPCTX *pStpCtx, INT cPix);

extern PFN_ADDATTRS g_pfnAddFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[];
#ifdef STEP_FIXED
extern PFN_ADDATTRS g_pfnAddFixedAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[];
#endif
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[];
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsPwlTable[];

// Edge walkers.
typedef HRESULT (FASTCALL *PFN_WALKSPANS)
    (UINT uSpans, PINTCARRYVAL pXOther,
     struct tagSETUPCTX *pStpCtx, BOOL bAdvanceLast);

extern PFN_WALKSPANS g_pfnWalkFloatSpansClipTable[];
extern PFN_WALKSPANS g_pfnWalkFloatSpansNoClipTable[];
#ifdef STEP_FIXED
extern PFN_WALKSPANS g_pfnWalkFixedSpansNoClipTable[];
#endif

// Float-to-fixed attribute converters.
typedef void (FASTCALL *PFN_FLOATATTRSTOFIXED)
    (PATTRSET pfAttrs, PATTRSET piAttrs);

#ifdef STEP_FIXED
extern PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[];
#endif

// Setup flags.
#define TRIP_DIFF_USED                  0x00000001
#define TRIP_SPEC_USED                  0x00000002
#define TRIP_TEX1_USED                  0x00000004
#define TRIP_TEX2_USED                  0x00000008
#define TRIP_Z_USED                     0x00000010
#define TRIP_LOD_USED                   0x00000020
#define TRIP_FOG_USED                   0x00000040
#define TRIP_TRIVIAL_ACCEPT_Y           0x00000080
#define TRIP_TRIVIAL_ACCEPT_X           0x00000100
#define TRIP_X_DEC                      0x00000200
#define TRIP_RASTPRIM_OVERFLOW          0x00000400
#define TRIP_FIXED_OVERFLOW             0x00000800
#define TRIP_IN_BEGIN                   0x00001000

#define TRIP_COLORS_USED                (TRIP_DIFF_USED | TRIP_SPEC_USED)
#define TRIP_TEX_USED                   (TRIP_TEX1_USED | TRIP_TEX2_USED)

// These flags are set and reset per-triangle, while the other flags are
// set per triangle set.
#define TRIP_PER_TRIANGLE_FLAGS \
    (TRIP_TRIVIAL_ACCEPT_Y | TRIP_TRIVIAL_ACCEPT_X | TRIP_X_DEC | \
     TRIP_RASTPRIM_OVERFLOW | TRIP_FIXED_OVERFLOW)
#define TRIP_PER_TRIANGLE_SET_FLAGS \
    (TRIP_DIFF_USED | TRIP_SPEC_USED | TRIP_TEX1_USED | TRIP_TEX2_USED | \
     TRIP_Z_USED | TRIP_LOD_USED | TRIP_FOG_USED)
    
// Setup information shared between C++ and assembly.
typedef struct tagSETUPCTX
{
    // Overall rasterization context.
    PD3DI_RASTCTX pCtx;

    // Current TriProcessor for span allocator calls.
    PVOID TriProcessor;
    
    // Current primitive.
    PD3DI_RASTPRIM pPrim;
    
    // Per-triangle flags.
    UINT uFlags;

    // Maximum span length allowed.
    INT cMaxSpan;
    
    // Piecewise-linear support for LOD.
    BOOL bNextValid;
    FLOAT fNextW;
    FLOAT fNextOoW;
    INT iNextLOD;

    // Attribute handling functions.
    PFN_ADDATTRS pfnAddAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrsPwl;
    PFN_FILLSPANATTRS pfnFillSpanAttrs;

    // Edge walking function.
    PFN_WALKSPANS pfnWalkSpans;
    
    // Current Y value.
    INT iY;
    
    // Edge X walkers.
    INTCARRYVAL X20, X10, X21;
    
    // Floating-point versions of X20 NC and CY values for setup.
    FLOAT fX20NC, fX20CY;
    
    // Long edge attribute values.
    ATTRSET Attr;
    
    // Attribute X deltas.
    ATTRSET DAttrDX;
    
    // Attribute Y deltas.
    ATTRSET DAttrDY;
    
    // Attribute span-to-span deltas when X carries a pixel.
    ATTRSET DAttrCY;

    // Attribute span-to-span deltas when X doesn't carry a pixel.
    ATTRSET DAttrNC;

    // One over determinant.
    FLOAT fOoDet;
    
    // Edge deltas.
    FLOAT fDX10, fDY10;
    FLOAT fDX20, fDY20;
    
    // Normalized edge deltas.
    FLOAT fNX10, fNY10;
    FLOAT fNX20, fNY20;
    
    // Subpixel correction amounts.
    FLOAT fDX, fDY;
} SETUPCTX, *PSETUPCTX;

#endif // #ifndef _STP_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\makefile.inc ===
$(GENTGT)\rampmat.cpp: ..\rampmat.mcp $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\indcmap.h ===
//----------------------------------------------------------------------------
//
// indcmap.h
//
// Structures and prototypes for indirect colormap code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _INDCMAP_H_
#define _INDCMAP_H_

RLDDIColormap* RLDDICreateIndirectColormap(RLDDIColorAllocator* alloc,
                         size_t size);
unsigned long* RLDDIIndirectColormapGetMap(RLDDIColormap* cmap);

#endif // _INDCMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\colall.h ===
//----------------------------------------------------------------------------
//
// colall.h
//
// Structures and prototypes for color allocation code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPCOLALL_H_
#define _RAMPCOLALL_H_

struct _RLDDIColorAllocator;
typedef struct _RLDDIColorAllocator RLDDIColorAllocator;

typedef unsigned long (*RLDDIColorAllocatorAllocateColor)(void*,
                                int red,
                                int green,
                                int blue);

typedef void (*RLDDIColorAllocatorFreeColor)(void*,
                           unsigned long pixel);

struct _RLDDIColorAllocator {
    void* priv;         /* implementation dependant */
    RLDDIColorAllocatorAllocateColor    allocate_color;
    RLDDIColorAllocatorFreeColor    free_color;
};

#endif // _RAMPCOLALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\indcmap.cpp ===
//----------------------------------------------------------------------------
//
// indcmap.cpp
//
// Implements indirect colormap code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

typedef struct _RLDDIIndirectPrivate
{
    RLDDIColorAllocator*    alloc;
    size_t          size;
    unsigned long*      map;
} RLDDIIndirectPrivate;

static void Destroy(RLDDIColormap* cmap);
static void SetColor(RLDDIColormap* cmap,
                     int index, int red, int green, int blue);

RLDDIColormap* RLDDICreateIndirectColormap(RLDDIColorAllocator* alloc,
                                           size_t size)
{
    RLDDIColormap* cmap;
    RLDDIIndirectPrivate* priv;
    size_t i;

    if (D3DMalloc((void**) &cmap, sizeof(RLDDIColormap)))
        return NULL;

    if (D3DMalloc((void**) &priv, sizeof(RLDDIIndirectPrivate)))
    {
        D3DFree(cmap);
        return NULL;
    }

    cmap->size = size;
    cmap->destroy = Destroy;
    cmap->set_color = SetColor;
    cmap->priv = priv;
    priv->alloc = alloc;
    priv->size = size;
    if (D3DMalloc((void**) &priv->map, size * sizeof(unsigned long)))
    {
        D3DFree(priv);
        D3DFree(cmap);
        return NULL;
    }

    for (i = 0; i < size; i++)
        priv->map[i] = alloc->allocate_color(alloc->priv, 0, 0, 0);

    return cmap;
}

unsigned long* RLDDIIndirectColormapGetMap(RLDDIColormap* cmap)
{
    RLDDIIndirectPrivate* priv;

    if (cmap == NULL)
        return NULL;
    priv = (RLDDIIndirectPrivate*) cmap->priv;
    if ( priv == NULL)
        return NULL;
    else
        return priv->map;
}

static void Destroy(RLDDIColormap* cmap)
{
    if (cmap && cmap->priv && ((RLDDIIndirectPrivate*)cmap->priv)->alloc)
    {
        RLDDIIndirectPrivate* priv = (RLDDIIndirectPrivate*) cmap->priv;
        RLDDIColorAllocator* alloc = priv->alloc;
        size_t i;

        for (i = 0; i < priv->size; i++)
            alloc->free_color(alloc->priv, priv->map[i]);
        D3DFree(priv->map);
        D3DFree(priv);
        D3DFree(cmap);
    }
}

static void SetColor(RLDDIColormap* cmap,
                     int index, int red, int green, int blue)
{
    red   = min(max(red,   0x0), 0xff);
    green = min(max(green, 0x0), 0xff);
    blue  = min(max(blue,  0x0), 0xff);
    if (cmap && cmap->priv && ((RLDDIIndirectPrivate*)cmap->priv)->alloc)
    {
        RLDDIIndirectPrivate* priv = (RLDDIIndirectPrivate*) cmap->priv;
        RLDDIColorAllocator* alloc = priv->alloc;

        if (index >= 0 && ((size_t)index) < priv->size)
        {
            alloc->free_color(alloc->priv, priv->map[index]);
            priv->map[index] = alloc->allocate_color(alloc->priv, red, green, blue);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\cmap.h ===
//----------------------------------------------------------------------------
//
// cmap.h
//
// Declares RLDDIColormap structures and procedures.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPCMAP_H_
#define _RAMPCMAP_H_

struct _RLDDIColormap;
typedef struct _RLDDIColormap RLDDIColormap;

typedef void (*RLDDIColormapDestroy)(RLDDIColormap*);
typedef void (*RLDDIColormapSetColor)(RLDDIColormap*,
                    int index,
                    int red, int green, int blue);

struct _RLDDIColormap {
    int size;           /* maximum color index */
    void* priv;         /* implementation dependant */
    RLDDIColormapDestroy    destroy;
    RLDDIColormapSetColor   set_color;
};

void RLDDIDestroyColormap(RLDDIColormap* cmap);

#endif // _RAMPCMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\palette.h ===
//----------------------------------------------------------------------------
//
// palette.h
//
// Structures and prototypes ramp palette code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPPALETTE_H_
#define _RAMPPALETTE_H_

#include "colall.h"

typedef void (*RLDDIPaletteSetColorMethod)(void*, int index,
                        int red, int green, int blue);
typedef int (*RLDDIPaletteAllocateColorMethod)(void*,
                        int red, int green, int blue);
typedef void (*RLDDIPaletteFreeColorMethod)(void*, int index);

typedef struct _RLDDIPaletteEntry RLDDIPaletteEntry;

typedef enum _PaletteState
{
    PALETTE_FREE,                   /* not used, allocatable */
    PALETTE_UNUSED,                 /* not used, not allocatable */
    PALETTE_USED                    /* used, allocatable */
} PaletteState;

struct _RLDDIPaletteEntry {
    LIST_MEMBER(_RLDDIPaletteEntry) list;
    int usage;                              /* how many users (0 => free) */
    unsigned char red, green, blue, pad1;   /* intensity values */
    PaletteState state;
};

#define HASH_SIZE 257
#define RGB_HASH(red, green, blue)      (((red) << 8) ^ ((green) << 4) ^ (blue))
#define ENTRY_TO_INDEX(pal, entry)      ((int)((entry) - (pal)->entries))
#define INDEX_TO_ENTRY(pal, index)      (&(pal)->entries[index])

typedef struct _RLDDIPalette {
    RLDDIPaletteEntry*  entries;        /* palette entries */
    size_t              size;           /* number of entries in palette */
    LIST_ROOT(name3, _RLDDIPaletteEntry) free; /* free list */
    LIST_ROOT(name4, _RLDDIPaletteEntry) unused; /* colors not to use */
    LIST_ROOT(name5, _RLDDIPaletteEntry) hash[HASH_SIZE];

    void*                       priv;
    RLDDIPaletteAllocateColorMethod allocate_color;
    RLDDIPaletteFreeColorMethod free_color;
    RLDDIPaletteSetColorMethod set_color;

    /*
     * A color allocator for use with RLDDIColormap.
     */
    RLDDIColorAllocator        alloc;
} RLDDIPalette;

RLDDIPalette* RLDDICreatePalette(PD3DI_RASTCTX pCtx, size_t size);
void RLDDIPaletteSetColor(RLDDIPalette* pal,
               int index, int red, int green, int blue);
int RLDDIPaletteAllocateColor(RLDDIPalette* pal,
                   int red, int green, int blue);
void RLDDIPaletteFreeColor(RLDDIPalette* pal, int index);
void RLDDIDestroyPalette(RLDDIPalette* pal);

#endif // _RAMPPALETTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\palette.cpp ===
//----------------------------------------------------------------------------
//
// palette.cpp
//
// Implements ramp palette code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// RLDDIRampUpdateDDPalette
//
// Called before the destination DirectDraw surface is displayed, to set its palette.
//
//-----------------------------------------------------------------------------
long RLDDIRampUpdateDDPalette(PD3DI_RASTCTX pCtx)
{
    RLDDIRampLightingDriver* driver = (RLDDIRampLightingDriver*)pCtx->pRampDrv;

    if (driver->paletteChanged) {
        HRESULT ddrval;
        LPDIRECTDRAWPALETTE lpDDPal;
        ddrval = pCtx->pDDS->GetPalette(&lpDDPal);

        driver->paletteChanged = FALSE;
        if (lpDDPal) {
            PALETTEENTRY ddppe[256];
            DWORD i;

            ddrval = lpDDPal->GetEntries(0, 0, 256, ddppe);
            if (ddrval != DD_OK) {
                DPF_ERR("Failed to get palette entries from DirectDraw.");
                return ddrval;
            }

            // Update only those entries marked as free.
            for (i=0; i<256; i++) {
                if (!(ddppe[i].peFlags & (D3DPAL_READONLY | D3DPAL_RESERVED))) {
                                        ddppe[i] = driver->ddpalette[i];
                }
            }

            // Reset palette
            ddrval = lpDDPal->SetEntries(0, 0, 256, ddppe);
            if (ddrval != DD_OK)
                return ddrval;
        }
    }
    return DD_OK;
}

//
// Set color in preparation to set the real palette
//
static void SetColor(void* arg, int index, int red, int green, int blue)
{
    PD3DI_RASTCTX pCtx = (PD3DI_RASTCTX)arg;

    RLDDIRampLightingDriver* driver = (RLDDIRampLightingDriver*)pCtx->pRampDrv;

    driver->ddpalette[index].peRed = (BYTE)red;
    driver->ddpalette[index].peGreen = (BYTE)green;
    driver->ddpalette[index].peBlue = (BYTE)blue;
    //driver->ddpalette[index].peFlags = PC_RESERVED;
    driver->paletteChanged = TRUE;
}

RLDDIPalette* RLDDICreatePalette(PD3DI_RASTCTX pCtx, size_t size)
{
    RLDDIPalette* pal;
    int i;

    if (D3DMalloc((void**) &pal, sizeof(RLDDIPalette)))
        return NULL;

    if (D3DMalloc((void**) &pal->entries,
                  size * sizeof(RLDDIPaletteEntry)))
    {
        D3DFree(pal);
        return NULL;
    }

    pal->size = size;
    pal->priv = pCtx;
    pal->set_color = SetColor;
    pal->allocate_color = NULL;
    pal->free_color = NULL;

    LIST_INITIALIZE(&pal->free);
    LIST_INITIALIZE(&pal->unused);
    for (i = 0; i < HASH_SIZE; i++)
        LIST_INITIALIZE(&pal->hash[i]);

    for (i = size - 1; i >= 0; i--)
    {
        pal->entries[i].state = PALETTE_UNUSED;
        pal->entries[i].usage = 1;
        LIST_INSERT_ROOT(&pal->unused, &pal->entries[i], list);
    }

    pal->alloc.priv = pal;
    pal->alloc.allocate_color =
    (RLDDIColorAllocatorAllocateColor) RLDDIPaletteAllocateColor;
    pal->alloc.free_color =
    (RLDDIColorAllocatorFreeColor) RLDDIPaletteFreeColor;

    return pal;
}

void RLDDIPaletteSetColor(RLDDIPalette* pal,
                          int index, int red, int green, int blue)
{
    RLDDIPaletteEntry* entry;
    unsigned int hash = RGB_HASH(red, green, blue) % HASH_SIZE;

    entry = INDEX_TO_ENTRY(pal, index);

    /*
     * Snip out from its list (free, unused or some hash list).
     */
    LIST_DELETE(entry, list);
    entry->red = (BYTE)red;
    entry->green = (BYTE)green;
    entry->blue = (BYTE)blue;
    entry->state = PALETTE_USED;
    entry->usage = 1;
    LIST_INSERT_ROOT(&pal->hash[hash], entry, list);

    if (pal->set_color)
    {
        /*
         * Call lower level to set the color (hardware colormap or Windows
         * palette or whatever).
         */
        pal->set_color(pal->priv, index, red, green, blue);
    }
}

#define COLOR_MASK 0xF8

int RLDDIPaletteAllocateColor(RLDDIPalette* pal,
                              int red, int green, int blue)
{
    RLDDIPaletteEntry* entry;
    unsigned int hash = RGB_HASH(red, green, blue) % HASH_SIZE;
    RLDDIPaletteEntry* best = NULL;
    size_t i;
    int closeness;

    for (entry = LIST_FIRST(&pal->hash[hash]); entry;
        entry = LIST_NEXT(entry,list))
    {
        if ((entry->red & COLOR_MASK) == (red & COLOR_MASK)
            && (entry->green & COLOR_MASK) == (green & COLOR_MASK)
            && (entry->blue & COLOR_MASK) == (blue & COLOR_MASK)
            && entry->state != PALETTE_UNUSED)
        {
            entry->usage++;
            return ENTRY_TO_INDEX(pal, entry);
        }
    }

    /*
     * Are there any free palette entries?
     */
    if (pal->allocate_color)
    {
        int index;
        index = pal->allocate_color(pal->priv, red, green, blue);
        if (index >= 0)
        {
            RLDDIPaletteSetColor(pal, index, red, green, blue);
            return index;
        }
    }
    else if (LIST_FIRST(&pal->free))
    {
        entry = LIST_FIRST(&pal->free);
        RLDDIPaletteSetColor(pal, ENTRY_TO_INDEX(pal, entry),
                             red, green, blue);
        return ENTRY_TO_INDEX(pal, entry);
    }

    /*
     * No more colors available, return the closest.
     */
    closeness = INT_MAX;
    for (i = 0, entry = pal->entries; i < pal->size; i++, entry++)
    {
        int t;
        if (entry->state != PALETTE_USED) continue;
#if 1
        {
            int t1,t2,t3;
            t1 = red - entry->red;
            t2 = green - entry->green;
            t3 = blue - entry->blue;
            t = (t1*t1 + t2*t2 + t3*t3);
        }
#else
        t = (abs(red - entry->red)
             + abs(green - entry->green)
             + abs(blue - entry->blue));
#endif
        if (t < closeness)
        {
            closeness = t;
            best = entry;
        }
    }
    best->usage++;
    /* *error = closeness; */
    return ENTRY_TO_INDEX(pal, best);
}

void RLDDIPaletteFreeColor(RLDDIPalette* pal, int index)
{
    RLDDIPaletteEntry* entry;

    entry = INDEX_TO_ENTRY(pal, index);
    entry->usage--;
    if (entry->usage > 0) return;

    /*
     * Remove from whichever list it is on (pal->unused or pal->hash[])
     * and add to the free list.
     */
    LIST_DELETE(entry, list);

    if (pal->free_color)
    {
        pal->free_color(pal->priv, index);
        entry->state = PALETTE_UNUSED;
        LIST_INSERT_ROOT(&pal->unused, entry, list);
    }
    else
    {
        entry->state = PALETTE_FREE;
        LIST_INSERT_ROOT(&pal->free, entry, list);
    }
}

void RLDDIDestroyPalette(RLDDIPalette* pal)
{
    RLDDIPaletteEntry* entry;
    size_t i;

    for (i = 0, entry = pal->entries; i < pal->size; i++, entry++)
    {
        if (entry->state != PALETTE_USED) continue;
        RLDDIPaletteFreeColor(pal, i);
    }
    D3DFree(pal->entries);
    D3DFree(pal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3di.hpp>
#include <haldrv.hpp>

#include <dpf.h>

#include <rast.h>

#include "lists.h"

#include "cmap.h"
#include "colall.h"
#include "rgbmap.h"
#include "rampmap.h"
#include "palette.h"
#include "rampmat.hpp"
#include "indcmap.h"
#include "rampmisc.h"
#include "rampif.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rampif.h ===
//----------------------------------------------------------------------------
//
// rampif.h
//
// Declares external interface for ramp material handling.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPIF_H_
#define _RAMPIF_H_

struct RLDDIRampLightingDriver;

RLDDIRampLightingDriver* RLDDIRampCreate(PD3DI_RASTCTX pCtx);
void RLDDIRampDestroy(RLDDIRampLightingDriver* drv);
void RLDDIRampBeginSceneHook(RLDDIRampLightingDriver* driver);
void RLDDIRampEndSceneHook(RLDDIRampLightingDriver* driver);
long RLDDIRampMaterialChanged(RLDDIRampLightingDriver* driver, D3DMATERIALHANDLE hMat);
long RLDDIRampSetMaterial(RLDDIRampLightingDriver* driver, D3DMATERIALHANDLE hMat);
long RLDDIRampCreateMaterial(RLDDIRampLightingDriver* driver, D3DMATERIALHANDLE hMat, PD3DI_RASTCTX pCtx);
long RLDDIRampDestroyMaterial(RLDDIRampLightingDriver* driver, D3DMATERIALHANDLE hMat);
unsigned long RLDDIRampMaterialToPixel(RLDDIRampLightingDriver* driver, D3DMATERIALHANDLE hMat);
long RLDDIRampUpdateDDPalette(PD3DI_RASTCTX pCtx);
long RLDDIRampMakePaletteRGB8(RLDDIRampLightingDriver* driver);
long RLDDIRampPaletteChanged(RLDDIRampLightingDriver* driver, D3DTEXTUREHANDLE hTex);
void Ramp_Mono_ScaleImage_8(PD3DI_RASTCTX pCtx, D3DMATERIALHANDLE hMat, LPD3DRECT pRect);
void Ramp_Mono_ScaleImage_16(PD3DI_RASTCTX pCtx, D3DMATERIALHANDLE hMat, LPD3DRECT pRect);
void Ramp_Mono_ScaleImage_24(PD3DI_RASTCTX pCtx, D3DMATERIALHANDLE hMat, LPD3DRECT pRect);
void Ramp_Mono_ScaleImage_32(PD3DI_RASTCTX pCtx, D3DMATERIALHANDLE hMat, LPD3DRECT pRect);


#endif // _RAMPIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rampmisc.h ===
//----------------------------------------------------------------------------
//
// rampmisc.h
//
// Miscellaneous stuff needed to compile imported ramp code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPMISC_H_
#define _RAMPMISC_H_

#define VALPTOD(f,prec) ((double) (f))

#define NORMAL_PREC     16
#define VALTOD(f)       VALPTOD(f,NORMAL_PREC)

// Macro to retrieve SPANTEX pointer
#define HANDLE_TO_SPANTEX(hTex) \
    (*(PD3DI_SPANTEX *)ULongToPtr(hTex))

#endif // _RAMPMISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rampmap.cpp ===
//----------------------------------------------------------------------------
//
// rampmap.cpp
//
// Implements required RLDDI stuff for rampmaps.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

static RLDDIRamp* NewRamp(int base, int size);

RLDDIRampmap* RLDDICreateRampmap(RLDDIColormap* cmap)
{
    RLDDIRampmap* rampmap;
    RLDDIRamp* ramp;

    if (D3DMalloc((void**) &rampmap, sizeof(RLDDIRampmap)))
        return NULL;

    CIRCLE_QUEUE_INITIALIZE(&rampmap->free,RLDDIRamp);
    CIRCLE_QUEUE_INITIALIZE(&rampmap->allocated,RLDDIRamp);

    rampmap->cmap = cmap;
    ramp = NewRamp(0, cmap->size);
    if (ramp == NULL)
    {
        D3DFree(rampmap);
        return NULL;
    }
    CIRCLE_QUEUE_INSERT_ROOT(&rampmap->free, RLDDIRamp, ramp, queue);

    return rampmap;
}

void RLDDIDestroyRampmap(RLDDIRampmap* rampmap)
{
    RLDDIRamp* ramp;
    RLDDIRamp* ramp_next;

    if (!rampmap)
        return ;

    for (ramp = CIRCLE_QUEUE_FIRST(&rampmap->allocated); ramp;
        ramp = ramp_next)
    {
        ramp_next = CIRCLE_QUEUE_NEXT(&rampmap->allocated,ramp,queue);
        D3DFree(ramp);
    }
    for (ramp = CIRCLE_QUEUE_FIRST(&rampmap->free); ramp;
        ramp = ramp_next)
    {
        ramp_next = CIRCLE_QUEUE_NEXT(&rampmap->free,ramp,queue);
        D3DFree(ramp);
    }
    D3DFree(rampmap);
}

RLDDIRamp* RLDDIRampmapAllocate(RLDDIRampmap* rampmap, int size)
{
    RLDDIRamp* ramp;
    RLDDIRamp* newramp;
    RLDDIRamp* ramp_next;

    if (!rampmap)
        return NULL;

    ramp = CIRCLE_QUEUE_FIRST(&rampmap->free);
    if (!ramp) return NULL;

    /*
     * cycle thru free rampmaps
     */
    for (; ramp && ramp->size < size; ramp = ramp_next)
    {
        ramp_next = CIRCLE_QUEUE_NEXT(&rampmap->free,ramp,queue);
    }
    /*
     * if we can't find a large enough ramp give up,
     * should try coalescing but it is non functional
     */
    if (!ramp || size > ramp->size)
        return NULL;

    /*
     * Remove the ramp from the freelist and add it to the allocated list.
     */
    CIRCLE_QUEUE_DELETE(&rampmap->free, ramp, queue);
    CIRCLE_QUEUE_INSERT_ROOT(&rampmap->allocated, RLDDIRamp, ramp, queue);
    ramp->free = FALSE;

    /*
     * If the size is right, return it.
     */
    if (size == ramp->size)
        return ramp;

    /*
     * Otherwise create a new ramp from the unneeded tail of this one and
     * throw it back into the freelist.
     */
    newramp = NewRamp(ramp->base + size, ramp->size - size);
    ramp->size = size;
    RLDDIRampmapFree(rampmap, newramp);

    return ramp;
}

void RLDDIRampmapFree(RLDDIRampmap* rampmap, RLDDIRamp* ramp)
{
    RLDDIRamp* free;

    if (!rampmap || !ramp)
        return ;

    DDASSERT(!ramp->free);
    ramp->free = TRUE;
    if (CIRCLE_QUEUE_NEXT(&rampmap->free,ramp,queue))
    {
        CIRCLE_QUEUE_DELETE(&rampmap->allocated, ramp, queue);
    }
    for (free = CIRCLE_QUEUE_FIRST(&rampmap->free); free;
        free = CIRCLE_QUEUE_NEXT(&rampmap->free,free,queue))
    {
        if (free->size > ramp->size)
        {
            /*
             * Add this ramp before the current one.
             */
            CIRCLE_QUEUE_INSERT_PREVIOUS(&rampmap->free, free, ramp, queue);
            return;
        }
    }
    /*
     * Must be the smallest so far, so add it to the end.
     */
    CIRCLE_QUEUE_INSERT_END(&rampmap->free, RLDDIRamp, ramp, queue);
}

static RLDDIRamp* NewRamp(int base, int size)
{
    RLDDIRamp* ramp;

    if (D3DMalloc((void**) &ramp, sizeof(RLDDIRamp)))
        return NULL;

    CIRCLE_QUEUE_INITIALIZE_MEMBER(ramp,queue);
    ramp->base = base;
    ramp->size = size;
    ramp->free = FALSE;
    return ramp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rgbmap.cpp ===
//----------------------------------------------------------------------------
//
// rgbmap.cpp
//
// Implements rgb colormap code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

static int CalculateShift(unsigned long mask);
static unsigned long AllocateColor(void* arg, int red, int green, int blue);
static void FreeColor(void* arg, unsigned long pixel);

RLDDIRGBMap* RLDDICreateRGBMap(unsigned long red_mask,
                               unsigned long green_mask,
                               unsigned long blue_mask)
{
    RLDDIRGBMap* rgbmap;

    if (D3DMalloc((void**) &rgbmap, sizeof(RLDDIRGBMap)))
        return NULL;

    rgbmap->red_mask = red_mask;
    rgbmap->green_mask = green_mask;
    rgbmap->blue_mask = blue_mask;

    rgbmap->red_shift = CalculateShift(rgbmap->red_mask);
    rgbmap->green_shift = CalculateShift(rgbmap->green_mask);
    rgbmap->blue_shift = CalculateShift(rgbmap->blue_mask);

    rgbmap->alloc.priv = rgbmap;
    rgbmap->alloc.allocate_color = AllocateColor;
    rgbmap->alloc.free_color = FreeColor;

    return rgbmap;
}

// ATTENTION this function should perhaps be packaged up and put in d3dutil
static int RLDDILog2[] = {
    0,  0,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,
    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    8,
};

static int CalculateShift(unsigned long mask)
{
    int shift, width;

    shift = 0;
    while ((mask & 1) == 0)
    {
        shift++;
        mask >>= 1;
    }
    width = RLDDILog2[mask + 1];
    return shift - (8 - width);
}

/*
 * We can't just use left shift since some CPUs don't treat left shift by
 * a negative as right shift (and why should they after all).
 */
#define SHIFT(t, v, s)                                \
do {                                          \
    if (s < 0)                                    \
    t = v >> -s;                                  \
    else                                      \
    t = v << s;                               \
} while (0)

static unsigned long AllocateColor(void* arg, int red, int green, int blue)
{
    RLDDIRGBMap* rgbmap = (RLDDIRGBMap*) arg;
    unsigned long pixel;
    unsigned long t;
    SHIFT(t, red, rgbmap->red_shift);
    pixel = t & rgbmap->red_mask;
    SHIFT(t, green, rgbmap->green_shift);
    pixel |= t & rgbmap->green_mask;
    SHIFT(t, blue, rgbmap->blue_shift);
    pixel |= t & rgbmap->blue_mask;
    return pixel;
}

static void FreeColor(void* arg, unsigned long pixel)
{
}

void RLDDIDestroyRGBMap(RLDDIRGBMap* rgbmap)
{
    D3DFree(rgbmap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rampmat.hpp ===
//----------------------------------------------------------------------------
//
// rampmat.hpp
//
// Declares classes for ramp material handling.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPMAT_HPP_
#define _RAMPMAT_HPP_

/* -*- c++ -*- */

#include "rampmap.h"
#include "palette.h"
#include "rgbmap.h"

struct ExtMaterial;
struct IntMaterial;
struct RampMaterial;
struct RLDDIRampLightingDriver;

struct AgeList {
    CIRCLE_QUEUE_MEMBER(AgeList) list;
    LIST_ROOT(alh,IntMaterial) agelist;
};

class RampCommon {
public:

    void* operator new(size_t size)
    {
    void* p;
        if (D3DMalloc(&p, size))
        return NULL;
    return p;
    }

    void operator delete(void *p)
    {
        D3DFree(p);
    }
};

/*
 * An ExtMaterial is the underlying driver object for an LPDIRECT3DMATERIAL.
 * When used, it creates IntMaterials which are distinguished by different
 * ambient light, fog, D3DMATERIAL value etc.
 *
 * The ExtMaterials are kept on a list in the driver and if not explicitly
 * freed, they are cleaned up when the driver is destroyed.
 *
 * The IntMaterials can outlive the ExtMaterial in the case that the
 * ExtMaterial is destroyed right after use.  We add these orphans to a list
 * which is emptied at Clear time since after Clear, no pixels are visible
 * which were rendered with the IntMaterial and it can be freed.
 */
struct ExtMaterial : public RampCommon {
    friend struct IntMaterial;
private:
    /*
     * Driver object which owns us.
     */
    RLDDIRampLightingDriver*    driver;

    /*
     * Current API level material definition.
     */
    D3DMATERIAL         mat;

    /*
     * List of internal materials derived from us.
     */
    LIST_ROOT(eml,IntMaterial)  intlist;

    /*
     * Generation count.  The generation is incremented each time
     * the material is changed.  This allows us to generate a new internal
     * material as needed.
     */
    int             generation;

    /*
     * This tracks the generation of any texture used by the material.  The
     * texture generation is bumped if its palette is changed or it is
     * loaded from another texture.
     */
    int             texture_generation;

    /*
     * This tracks the underlying texture object represented by the texture
     * handle (if any).  If texture handles are swapped, we need to know
     * so that we can make a new internal material for the new texture.
     */
    PD3DI_SPANTEX       texture;

    /*
     * Increment the generation either because the material was set or
     * because a texture changed.
     */
    void            Age();

public:
    /*
     * Chain for list of external materials created by this driver.
     */
    LIST_MEMBER(ExtMaterial)    list;

public:
    /*
     * Constructor/Destructor.
     */
    ExtMaterial(RLDDIRampLightingDriver* driver, D3DMATERIALHANDLE hMat);
    ~ExtMaterial();

    /*
     * Change the API level material.
     */
    void SetMaterial(D3DMATERIAL* mat);

    /*
     * Accessor to the current API level material.
     */
    D3DMATERIAL* GetMaterial() {
    return &mat;
    }

    /*
     * Find an internal material which corresponds to the current driver
     * object state.
     */
    IntMaterial* FindIntMaterial();

    /*
     * Find what range of values lighting should take.  The base is the
     * pixel value (in fixed point) of the dark end of the material.  The
     * shift value is user to convert a 0.16 fixed point shade into the
     * range needed for the material. e.g.
     *
     *      pixel = base + (VALTOFX8(shade) << shift);
     *
     */
    HRESULT FindLightingRange(unsigned long* base,
                  unsigned long* size,
                  BOOL* specular,
                  unsigned long** texture_colors);
};

/*
 * The IntMaterial is derived from an ExtMaterial taking into account the
 * driver state when the ExtMaterial was used.  Normally IntMaterials are
 * on a list in their owning ExtMaterial.  If the external material is
 * destroyed, any active internal materials which it owned are
 * transferred to an orphans list in the driver.  This is cleared out
 * next time Clear is called.
 *
 * The internal material has a list of underlying RampMaterials.  For
 * a non-textured material, there is exactly one and for a textured
 * material, there is one per color in the texture's palette.  The
 * ramp materials track color sharing between internal materials and
 * handle the details of allocating color resources.
 *
 * Internal materials are also chained onto one of a number of lists
 * based on their age.  The age of a material is the number of frames
 * since it was last used to render something.  When a material is
 * aged, it is rejuvenated by moving it to the age=0 list.  Each
 * frame, the lists are rotated by one notch and materials on the
 * oldest list are reclaimed.
 *
 * A material is either active or inactive.  Active materials have
 * color resources and are either on the age=0 list (active this
 * frame) or the age=1 list (active last frame).  When an inactive
 * material is used, it allocates color resources by attempting to
 * activate the underlying ramp materials.
 *
 * At the end of the frame, on Update, any active materials on the
 * age=1 list must be materials which were active last frame but were
 * not used this frame.  We remove their color resources by
 * deactivating the underlying ramp materials.
 */
struct IntMaterial : public RampCommon {
private:
    /*
     * Driver object which owns us.
     */
    RLDDIRampLightingDriver*    driver;

    /*
     * External material which created us.
     */
    ExtMaterial*        extmat;

public:
    /*
     * Too annoying to have these private.
     */

    /*
     * Chain of internal materials created by our external material owner
     * which owns us.  The chain is also used to place the material on the
     * driver's orphans list if appropriate.
     */
    LIST_MEMBER(IntMaterial)    list;

    /*
     * Current ageing list which we are on.
     */
    AgeList*            age;
    LIST_MEMBER(IntMaterial)    agelist;
private:

    /*
     * D3DMATERIAL which the external material had when it created us.
     */
    D3DMATERIAL         mat;

    /*
     * TRUE if we are active.  We are active if we currently have color
     * allocation resources assigned to us.
     */
    int             active;

    /*
     * Base values of our color allocation resources.  Contents are valid
     * only when active.
     */
    unsigned long*      colors;

    /*
     * Features which distinguish us from other internal materials owned by
     * our external material.
     */
    float                  ambient;        // ambient shade
    unsigned long       viewport_id;    // viewport which owns it
    int             fog_enable; // material incorporates fog
    unsigned long       fog_color;  // the fogging color
    int             generation;

    /*
     * RampMaterials used by this internal material.
     */
    int             ramp_count;
    RampMaterial**      ramps;

public:

    /*
     * Constructor/Destructor.
     */
    IntMaterial(ExtMaterial* extmat);
    ~IntMaterial();

    /*
     * Returns TRUE if we match the current settings of our external material
     * and driver state.
     */
    int Valid();

    /*
     * See ExtMaterial
     */
    HRESULT FindLightingRange(unsigned long* base,
                  unsigned long* size,
                  BOOL* specular,
                  unsigned long** texture_colors);

    /*
     * Activate the material and allocate color resources for it.
     */
    HRESULT Activate();

    /*
     * Deactivate the material, freeing color resources.  Always works.
     */
    void Deactivate();

    /*
     * Returns TRUE if the material is currently active.
     */
    int IsActive() {
    return active;
    }

    /*
     * Add the material to the driver's orphaned material list.  Called when
     * the external material is destroyed.
     */
    void Orphan();
};

/*
 * RampMaterials are used by internal materials to represent ranges of
 * colors.  They perform low level color allocation by allocating
 * color ranges (RLDDIRamps) from a rampmap.
 *
 * A textured internal material can use many ramp materials.
 * Several internal materials can use the same ramp material if the
 * colors match.  This can happen easily if many textures use the same
 * palette.  The ramp material maintains a usage of how many internal
 * materials are using it and is freed when the last one stops.
 *
 * Ramp materials, like internal materials are either active or
 * inactive.  Active materials have color resources and inactive
 * materials do not.  A ramp material is made active when any of its
 * internal material users are active and inactive when none of then
 * are active.  To track this a count of how many active users is
 * maintained.
 *
 * When a material is made active, it attempts to allocate a color
 * range to use.  If that is successful, it sets the colors in the
 * range to an appropriate ramp of colors.  If is no more space in the
 * colormap for a new range, it finds the closes active ramp material
 * and shares its ramp.
 *
 * To track active materials and sharing materials, the driver has a
 * list of active materials and each material has a list of sharers.
 * The sharers list is only valid for materials which are both active
 * and which own their ramp.
 */
struct RampMaterial : public RampCommon {
private:
    /*
     * Driver object which owns us.
     */
    RLDDIRampLightingDriver* driver;

    /*
     * List of materials which have the same hash value.
     */
    LIST_MEMBER(RampMaterial) hash;

    /*
     * Materials sharing this ramp.  Only valid for active materials
     * with owner == TRUE.
     */
    LIST_ROOT(name6,RampMaterial) sharers;

    /*
     * If the material is active, then it is on the drivers rmactive list
     * if it owns the ramp, otherwise it is on the sharers list of the
     * material which does own the ramp.  Only valid for active materials.
     */
    LIST_MEMBER(RampMaterial) list;

    /*
     * If were sharing a ramp and inherit it from the owner, we need to
     * defer setting the colors until the next frame to avoid possible
     * palette flashing.  The driver has a list of materials for which
     * color setting is deferred, chainged through here.
     *
     * We make sure that deferredlist.le_next is NULL unless we are
     * actually on the deferred list so that we can avoid list problems
     * if we are destroyed or passed on to another inheritor before the
     * list is processed.
     */
    LIST_MEMBER(RampMaterial) deferredlist;

    /*
     * A count of the number of internal materials which use us.
     */
    int         usage;

    /*
     * A count of active internal materials which use us.
     */
    int         active;

    /*
     * If we are active (active > 0), this is the underlying color
     * range for the material.
     */
    RLDDIRamp*          ramp;

    /*
     * TRUE if we created or inherited the ramp.  FALSE if I am merely
     * sharing some other material.
     */
    int                 owner;

    /*
     * Distinguishing features.
     */
    float          ambient;        /* ambient shade */
    D3DMATERIAL         mat;            /* material we represent */
    int         fog_enable; /* material incorporates fog */
    unsigned long   fog_color;  /* the fogging color */

private:

    /*
     * Constructor/Destructor.
     * These are private.  Callers should use Find/Release.
     */
    RampMaterial(RLDDIRampLightingDriver* driver,
                 D3DMATERIAL* mat, float ambient);
    ~RampMaterial();

public:
    /*
     * Find a material which matches the api material and driver state.
     * If no such material exists, make one.
     */
    static RampMaterial* Find(RLDDIRampLightingDriver* driver,
                  D3DMATERIAL* mat);

private:
    /*
     * Next functions are implementation detail of Find.
     */

    /*
     * Compare two api materials to see if they are identical.
     */
    static int MaterialSame(D3DMATERIAL* mat1, D3DMATERIAL* mat2);

    /*
     * Return a measure of how close two rgb colors are in rgb space.
     */
    static int RGBDist(D3DCOLORVALUE* rgb1, D3DCOLORVALUE* rgb2);

    /*
     * Return a measure of how close two api materials are.
     */
    static int CompareMaterials(D3DMATERIAL* mat1, D3DMATERIAL* mat2);

public:
    /*
     * Called by a user when it is no longer needed.
     */
    void Release();

    /*
     * Called by a user when the material is about to be used.
     */
    HRESULT Activate();

    /*
     * Called by a user when the material has not been used this frame.
     */
    void Deactivate();

    /*
     * Return the base color of an active material.
     */
    unsigned long Base();

private:
    /*
     * Implementation details of Activate and Deactivate.
     */

    /*
     * Allocate a ramp of colors for us to use.
     * May only be called for an inactive material.
     */
    HRESULT AllocateColors();

    /*
     * Free our color allocation.  May only be called for an active material.
     */
    void FreeColors();

    /*
     * Set the color values of our color allocation.
     */
private:
    void SetColorsStd();
    void SetColorsFog();
public:
    void SetColors();
};

///*
// * Workspace used when evaluating complex lighting models.
// */
//struct Workspace {
//    float  diffuse;
//    float  specular;
//};
//
//struct SpecularTable {
//    LIST_MEMBER(SpecularTable) list;
//    float          power;          /* shininess power */
//    float          table[260];     /* space for overflows */
//};
//
//#define WORKSPACE_SIZE  1024

#define HASH_SIZE       257
/*
 * If the app is rendering at 30fps, this means that a material can survive
 * for about 5 seconds.  This seems like enough to cope with stuff moving
 * out of shot and back in again soon after.
 */
#define AGE_MAX         (30*5)      /* age at which unused materials die */

typedef struct _RLDDISoftLightingDriver {
    D3DMATERIAL     material;
    float          ambient;
    D3DFOGMODE      fog_mode;
    float          fog_start;
    float          fog_end;
    float          fog_density;
    D3DMATERIALHANDLE   hMat;
    D3DCOLORMODEL   color_model;
    DWORD           ambient_save;
} RLDDISoftLightingDriver;

struct RLDDIRampLightingDriver {
    RLDDISoftLightingDriver         driver; /* common fields */

    /*
     * Colormap
     */
    RLDDIPalette*   palette;
    RLDDIRGBMap*    rgbmap;
    unsigned long*  pixelmap; /* map color indices to pixels */
    PALETTEENTRY    ddpalette[256];
    int         paletteChanged;

    RLDDIRampmap*       rampmap;
    unsigned long   viewport_id;    /* current viewport */
    int         fog_enable;
    unsigned long   fog_color;

    /*
     * External materials created by this driver.
     */
    LIST_ROOT(deml,ExtMaterial) materials;

    /*
     * Active internal materials orphaned by their owning external material.
     */
    LIST_ROOT(diml,IntMaterial) orphans;

    AgeList     agelists[AGE_MAX];
    CIRCLE_QUEUE_ROOT(aqh,AgeList) agequeue;    /* age sorted queue of lists */
    AgeList*        active;     /* current active list */

    /*
     * This is set to TRUE after Clear has advanced the ages one notch and
     * cleared on update.  It is used to stop multiple calls to Clear from
     * confusing the aging system
     */
    int         already_aged;

    LIST_ROOT(name7,RampMaterial) rmactive; /* materials with ramps */
    LIST_ROOT(name8,RampMaterial) rmdeferred;
    LIST_ROOT(name9,RampMaterial) hash[HASH_SIZE]; /* materials hash table */

    /*
     * Current material.
     */
    ExtMaterial*    current_material;
};

typedef struct _RLDDILookupMaterialData {
    D3DMATERIALHANDLE   hMat;            /* material to look up */
    unsigned long       base;           /* base pixel value */
    unsigned long       size;           /* size of index range */
    unsigned long       texture_index;  /* texture table for textures */
} RLDDILookupMaterialData;


#endif // _RAMPMAT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rampmap.h ===
//----------------------------------------------------------------------------
//
// rampmap.h
//
// Declares structures and procedures for RLDDIRampmap.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPMAP_H_
#define _RAMPMAP_H_

#include "cmap.h"

struct _RLDDIRampmap;
typedef struct _RLDDIRampmap RLDDIRampmap;

typedef struct _RLDDIRamp {
    CIRCLE_QUEUE_MEMBER(_RLDDIRamp) queue;

    int         base, size;
    int         free;
} RLDDIRamp;

struct _RLDDIRampmap {
    RLDDIColormap*  cmap;

    CIRCLE_QUEUE_ROOT(RLDDIRampQueue, _RLDDIRamp) free, allocated;
};

RLDDIRampmap* RLDDICreateRampmap(RLDDIColormap* cmap);
void RLDDIDestroyRampmap(RLDDIRampmap* rmap);
RLDDIRamp* RLDDIRampmapAllocate(RLDDIRampmap* rmap, int size);
void RLDDIRampmapFree(RLDDIRampmap* rmap, RLDDIRamp* ramp);

#endif // _RAMPMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\sources.inc ===
TARGETNAME = rrampmat
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(D3DROOT)\pipeln\inc;$(INCLUDES)

SOURCES = \
        ..\indcmap.cpp\
        ..\rampmap.cpp\
        $O\rampmat.cpp\
        ..\palette.cpp\
        ..\rgbmap.cpp

NTTARGETFILE0 = \
        $O\rampmat.cpp


PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rgbmap.h ===
//----------------------------------------------------------------------------
//
// rgbmap.h
//
// Structures and prototypes for rgb colormap code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RGBMAP_H_
#define _RGBMAP_H_

#include "colall.h"

typedef struct _RLDDIRGBMap {
    unsigned long   red_mask;
    unsigned long   green_mask;
    unsigned long   blue_mask;

    int         red_shift;
    int         green_shift;
    int         blue_shift;

    /*
     * A color allocator for use with RLDDIColormap.
     */
    RLDDIColorAllocator alloc;
} RLDDIRGBMap;

RLDDIRGBMap* RLDDICreateRGBMap(unsigned long red_mask,
                   unsigned long green_mask,
                   unsigned long blue_mask);
void RLDDIDestroyRGBMap(RLDDIRGBMap* rgbmap);

#endif // _RGBMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\d3drlddi.h ===
/*
 * $Id: d3drlddi.h,v 1.8 1995/11/21 14:42:53 sjl Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */

#ifndef _D3DRLDDI_H_
#define _D3DRLDDI_H_

#include "d3di.h"

#if defined(__cplusplus)
extern "C"
{
#endif

#ifndef TRUE
#define FALSE 0
#define TRUE 1
#endif

typedef D3DRECT RLDDIRectangle;
typedef D3DTLVERTEX RLDDIVertex;
typedef D3DTRANSFORMDATA RLDDITransformData;

#define RLDDI_TRIANGLE_ENABLE_EDGE01 D3DTRIANGLE_ENABLE_EDGE01
#define RLDDI_TRIANGLE_ENABLE_EDGE12 D3DTRIANGLE_ENABLE_EDGE12
#define RLDDI_TRIANGLE_ENABLE_EDGE20 D3DTRIANGLE_ENABLE_EDGE20

#if defined(__cplusplus)
};
#endif

#endif /* _D3DRLDDI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\dlist.h ===
/*
 * $Id: dlist.h,v 1.13 1995/07/31 16:01:40 dfr Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */

#ifndef __DLIST_H__
#define __DLIST_H__




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\dmath.h ===
#ifndef __RLDMATH__
#define __RLDMATH__

extern RLDDIValue RLDDIhdivtab[];

#define HDIVIDE(a, b)	RLDDIFMul24((a), RLDDIhdivtab[b])

#ifdef USE_FLOAT
#define TWOPOW32 ((double)(65536.0 * 65536.0))

#define TWOPOW(N) (((N) < 32) ? ((double)(1UL << (N))) : \
		                ((double)(1UL << (N - 32)) * TWOPOW32))

extern double RLDDIConvertIEEE[];
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\dmath.c ===
/* $Id: dmath.c,v 1.2 1995/09/25 11:39:43 james Exp $ */

#include <math.h>
#include <limits.h>
#include "driver.h"
#include "dmath.h"

//#ifdef USE_FLOAT
#define CONST_TWOPOW20  1048576
#define CONST_TWOPOW27  134217728
#define FLOAT_TWOPOW27  ((float)(CONST_TWOPOW27))

float RLDDIFloatConstInv64K = (float)1.0 / (float)65536.0;
float RLDDIFloatConstInv256 = (float)1.0 / (float)256.0;
float RLDDIFloatConst64K = (float)65536.0;
float RLDDIFloatConst2p24 = (float)65536.0 * (float)256.0;
float RLDDIFloatConst2p36 = (float)16.0 * (float)65536.0 * (float)65536.0;
float RLDDIFloatConst5 = (float)5.0;
float RLDDIFloatConst16 = (float)16.0;
float RLDDIFloatConst1 = (float)1.0;
float RLDDIFloatConstHalf = (float)0.5;
float RLDDIFloatConstAffineThreshold = (float)2.0 * (float)64.0;
float g_fOne = (float)1.0;
float g_fOoTwoPow20 =           (float)(1.0 / (double)CONST_TWOPOW20);
float g_fTwoPow27 =             FLOAT_TWOPOW27;
//#endif

double RLDDIConvertIEEE[33] =
{
  TWOPOW32 + TWOPOW(52),
  TWOPOW32 + TWOPOW(51),
  TWOPOW32 + TWOPOW(50),
  TWOPOW32 + TWOPOW(49),
  TWOPOW32 + TWOPOW(48),
  TWOPOW32 + TWOPOW(47),
  TWOPOW32 + TWOPOW(46),
  TWOPOW32 + TWOPOW(45),
  TWOPOW32 + TWOPOW(44),
  TWOPOW32 + TWOPOW(43),
  TWOPOW32 + TWOPOW(42),
  TWOPOW32 + TWOPOW(41),
  TWOPOW32 + TWOPOW(40),
  TWOPOW32 + TWOPOW(39),
  TWOPOW32 + TWOPOW(38),
  TWOPOW32 + TWOPOW(37),
  TWOPOW32 + TWOPOW(36),
  TWOPOW32 + TWOPOW(35),
  TWOPOW32 + TWOPOW(34),
  TWOPOW32 + TWOPOW(33),
  TWOPOW32 + TWOPOW(31),
  TWOPOW(31) + TWOPOW(30),
  TWOPOW(30) + TWOPOW(29),
  TWOPOW(29) + TWOPOW(28),
  TWOPOW(28) + TWOPOW(27),
  TWOPOW(27) + TWOPOW(26),
  TWOPOW(26) + TWOPOW(25),
  TWOPOW(25) + TWOPOW(24),
  TWOPOW(24) + TWOPOW(23),
  TWOPOW(23) + TWOPOW(22),
  TWOPOW(22) + TWOPOW(21),
  TWOPOW(21) + TWOPOW(20),
  TWOPOW(20) + TWOPOW(19)
};

RLDDIValue RLDDIhdivtab[] = {
#include "hdivtab.i"
};

#ifdef CHIMERA
unsigned short RLDDI_reciprocals[] = {
#include "recips.i"
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\dditypes.h ===
/*
 * $Id: dditypes.h,v 1.28 1995/11/21 14:46:07 sjl Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */

#ifndef __DDITYPES_H__
#define __DDITYPES_H__

#include "d3di.h"

#ifdef __psx__
typedef struct _RLDDIPSXUpdateFlags {;
    int 		update_color;
    int 		update_texture;
} RLDDIPSXUpdateFlags;
#endif


typedef struct _RLDDIDriverParams {
    int			width, height;	/* dimensions */
    int			depth;		/* pixel depth */
    unsigned long	red_mask;
    unsigned long	green_mask;
    unsigned long	blue_mask;
    int			aspectx, aspecty; /* aspect ratios */

    unsigned long	caps;		/* miscellaneous capabilities */
} RLDDIDriverParams;

typedef enum _RLDDIRenderParamType {
    RLDDIRenderParamDither,		/* enable dithering */
    RLDDIRenderParamGamma,		/* change gamma correction */
    RLDDIRenderParamPerspective		/* enable perspective correction */
} RLDDIRenderParamType;

#if 0
typedef struct _RLDDIRenderParams {
    int			dither;		/* TRUE to enable dithering */
    RLDDIValue		gamma;		/* gamma correction value */
    int			perspective;	/* TRUE for perspective correction */
} RLDDIRenderParams;
#endif

typedef struct _RLDDIMatrix {
    RLDDIValue		_11, _12, _13, _14;
    RLDDIValue		_21, _22, _23, _24;
    RLDDIValue		_31, _32, _33, _34;
    RLDDIValue		_41, _42, _43, _44;
} RLDDIMatrix;

typedef struct _RLDDIVector {
    RLDDIValue		x, y, z;
} RLDDIVector;

#if 0
/*
 * Format of CI colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |         color index          |   fraction    |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define CI_GET_ALPHA(ci)	((ci) >> 24)
#define CI_GET_INDEX(ci)	(((ci) >> 8) & 0xffff)
#define CI_GET_FRACTION(ci)	((ci) & 0xff)
#define CI_ROUND_INDEX(ci)	CI_GET_INDEX((ci) + 0x80)
#define CI_MASK_ALPHA(ci)	((ci) & 0xffffff)
#define CI_MAKE(a, i, f)	(((a) << 24) | ((i) << 8) | (f))

/*
 * Format of RGBA colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGBA_GET_ALPHA(ci)	((ci) >> 24)
#define RGBA_GET_RED(ci)	(((ci) >> 16) & 0xff)
#define RGBA_GET_GREEN(ci)	(((ci) >> 8) & 0xff)
#define RGBA_GET_BLUE(ci)	((ci) & 0xff)
#define RGBA_SET_ALPHA(rgba, x)	(((x) << 24) | ((rgba) & 0x00ffffff))
#define RGBA_SET_RED(rgba, x)	(((x) << 16) | ((rgba) & 0xff00ffff))
#define RGBA_SET_GREEN(rgba, x)	(((x) << 8) | ((rgba) & 0xffff00ff))
#define RGBA_SET_BLUE(rgba, x)	(((x) << 0) | ((rgba) & 0xffffff00))
#define RGBA_MAKE(r, g, b, a)	(((a) << 24) | ((r) << 16) | ((g) << 8) | (b))

/*
 * Format of RGB colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    ignored    |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGB_GET_RED(ci)		(((ci) >> 16) & 0xff)
#define RGB_GET_GREEN(ci)	(((ci) >> 8) & 0xff)
#define RGB_GET_BLUE(ci)	((ci) & 0xff)
#define RGB_SET_RED(rgb, x)	(((x) << 16) | ((rgb) & 0xff00ffff))
#define RGB_SET_GREEN(rgb, x)	(((x) << 8) | ((rgb) & 0xffff00ff))
#define RGB_SET_BLUE(rgb, x)	(((x) << 0) | ((rgb) & 0xffffff00))
#define RGB_MAKE(r, g, b)	(((r) << 16) | ((g) << 8) | (b))
#define RGBA_TO_RGB(rgba)	((rgba) & 0xffffff)
#define RGB_TO_RGBA(rgb)	((rgb) | 0xff000000)

#endif

/* XXX move into D3D */
typedef struct _RLDDIFogData {
    int			fog_enable;
    int			fog_mode;	/* make a  D3Dfog mode */
    unsigned long	fog_color;
    RLDDIValue		fog_start;
    RLDDIValue		fog_end;
    RLDDIValue		fog_density;
} RLDDIFogData;

typedef struct _RLDDIPixmap {
    int			width;		/* width in pixels */
    int			height;		/* height in pixels */
    int			depth;		/* bits per pixel */
    int			bytes_per_line;	/* bytes per scanline */
    short		free_pixels;	/* TRUE if we allocated pixels */
    short		vidmem;		/* surface is in vidmem */
    LPPALETTEENTRY	palette;	/* if !NULL, associated palette */
    int			palette_size;	/* number of valid palette entries */
    unsigned long	red_mask;	/* if palette==NULL, rgba masks */
    unsigned long	green_mask;
    unsigned long	blue_mask;
    unsigned long	alpha_mask;
    void RLFAR*		pixels;		/* the scanlines */
    LPDIRECTDRAWSURFACE	lpDDS;		/* underlying surface if relavent */
} RLDDIPixmap;

#define PIXMAP_LINE(pm, y)	(void RLFAR*)((char RLFAR*) (pm)->pixels \
					      + y * (pm)->bytes_per_line)

#define PIXMAP_POS(pm, x, y)	(void RLFAR*)((char RLFAR*)		\
					      PIXMAP_LINE(pm, y)	\
					      + (x) * (pm)->depth / 8)

typedef struct _RLDDISetTextureOpacityParams {
    D3DTEXTUREHANDLE	texture; 	/* texture to change */
    int			has_transparent; /* texture has a transparent color */
    unsigned long	transparent;	/* transparent color */
    RLImage*		opacity;	/* opacity map */
} RLDDISetTextureOpacityParams;

typedef RLDDIDriver* (*RLDDICreateDriverFunction)(int width, int height);
typedef struct _RLDDICreateDriverFunctions {
    RLDDICreateDriverFunction	transform;
    RLDDICreateDriverFunction	render;
    RLDDICreateDriverFunction	light;
} RLDDICreateDriverFunctions;

#endif /* dditypes.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\d3di.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3di.h
 *  Content:	Direct3D internal include file
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id: d3di.h,v 1.26 1995/12/04 11:29:44 sjl Exp $
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   05/11/95   stevela	Initial rev with this header.
 *   11/11/95	stevela	Light code changed.
 *   21/11/95   colinmc Made Direct3D aggregatable
 *                      (so it can be QI'd off DirectDraw).
 *   23/11/95   colinmc Made Direct3D textures and devices aggregatable
 *                      (QI'd off DirectDrawSurfaces).
 *   07/12/95	stevela Merged in Colin's changes.
 *   10/12/95	stevela	Removed AGGREGATE_D3D.
 *			Removed Validate macros from here. Now in d3dpr.h
 *   02/03/96   colinmc Minor build fix
 *   17/04/96	stevela Use ddraw.h externally and ddrawp.h internally
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _D3DI_H
#define _D3DI_H

//@@BEGIN_MSINTERNAL
#include "ddrawp.h"
#if 0
//@@END_MSINTERNAL
#include "ddraw.h"
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
#include "d3dp.h"

// @@BEGIN_MSINTERNAL
#if !defined(BUILD_RLAPI) && !defined(BUILD_DDDDK)
#include "ddrawi.h"

#include "rlreg.h"
#include "lists.h"
#include "object.h"


/*
	INDEX_BATCH_SCALE is the constant which is used by DrawIndexedPrim
	to deterimine if the number of primitives being drawn is small 
	relative to the number of vertices being passed.  If it is then
	the prims are dereferenced in batches and sent to DrawPrim.
*/
#define INDEX_BATCH_SCALE	2

/*
typedef D3DCOLORMODEL D3DCOLORMODEL;

#define D3DCOLOR_RAMP D3DCOLOR_RAMP
#define D3DCOLOR_RGB D3DCOLOR_RGB
#define D3D_COLORMODEL D3D_COLORMODEL
*/
#endif /* !BUILD_RLAPI */
// @@END_MSINTERNAL

typedef DWORD D3DI_BUFFERHANDLE, *LPD3DI_BUFFERHANDLE;

/*
 * Internal version of executedata
 */
typedef struct _D3DI_ExecuteData {
    DWORD       dwSize;
    D3DI_BUFFERHANDLE dwHandle;		/* Handle allocated by driver */
    DWORD       dwVertexOffset;
    DWORD       dwVertexCount;
    DWORD       dwInstructionOffset;
    DWORD       dwInstructionLength;
    DWORD       dwHVertexOffset;
    D3DSTATUS   dsStatus;		/* Status after execute */
} D3DI_EXECUTEDATA, *LPD3DI_EXECUTEDATA;

/*
 * Internal version of lightdata and constants for flags
 */

#define D3DLIGHTI_ATT0_IS_NONZERO	(0x00010000)	
#define D3DLIGHTI_ATT1_IS_NONZERO	(0x00020000)
#define D3DLIGHTI_ATT2_IS_NONZERO	(0x00040000)
#define D3DLIGHTI_LINEAR_FALLOFF	(0x00080000)
#define D3DLIGHTI_UNIT_SCALE		(0x00100000)
#define D3DLIGHTI_LIGHT_AT_EYE		(0x00200000)

typedef struct _D3DI_LIGHT {
    D3DLIGHTTYPE	type;
	DWORD			version;	/* matches number on D3DLIGHT struct */
    BOOL			valid;
    D3DVALUE		red, green, blue, shade;
    D3DVECTOR		position;
    D3DVECTOR		model_position;
    D3DVECTOR		direction;
    D3DVECTOR		model_direction;
    D3DVECTOR		halfway;
	D3DVECTOR		model_eye;		/* direction from eye in model space */
	D3DVECTOR		model_scale;	/* model scale for proper range computations */
    D3DVALUE		range;
    D3DVALUE		range_squared;
    D3DVALUE		falloff;
    D3DVALUE		attenuation0;
    D3DVALUE		attenuation1;
    D3DVALUE		attenuation2;
    D3DVALUE		cos_theta_by_2;
    D3DVALUE		cos_phi_by_2;
	DWORD			flags;
} D3DI_LIGHT, *LPD3DI_LIGHT;

// @@BEGIN_MSINTERNAL
#if !defined(BUILD_RLAPI) && !defined(BUILD_DDDDK)
#ifndef BUILD_HEL
#ifdef BUILD_D3D_LAYER
#include "driver.h"
#endif

typedef struct IUnknownVtbl D3DUNKNOWNCALLBACKS, *LPD3DUNKNOWNCALLBACKS;
typedef struct ID3DObjectVtbl D3DOBJECTVTBL, *LPD3DOBJECTVTBL;
typedef struct IDirect3DVtbl DIRECT3DCALLBACKS, *LPDIRECT3DCALLBACKS;
typedef struct IDirect3D2Vtbl DIRECT3D2CALLBACKS, *LPDIRECT3D2CALLBACKS;
typedef struct IDirect3DDeviceVtbl DIRECT3DDEVICECALLBACKS, *LPDIRECT3DDEVICECALLBACKS;
typedef struct IDirect3DDevice2Vtbl DIRECT3DDEVICE2CALLBACKS, *LPDIRECT3DDEVICE2CALLBACKS;
typedef struct IDirect3DExecuteBufferVtbl DIRECT3DEXECUTEBUFFERCALLBACKS, *LPDIRECT3DEXECUTEBUFFERCALLBACKS;
typedef struct IDirect3DLightVtbl DIRECT3DLIGHTCALLBACKS, *LPDIRECT3DLIGHTCALLBACKS;
typedef struct IDirect3DMaterialVtbl DIRECT3DMATERIALCALLBACKS, *LPDIRECT3DMATERIALCALLBACKS;
typedef struct IDirect3DMaterial2Vtbl DIRECT3DMATERIAL2CALLBACKS, *LPDIRECT3DMATERIAL2CALLBACKS;
typedef struct IDirect3DTextureVtbl DIRECT3DTEXTURECALLBACKS, *LPDIRECT3DTEXTURECALLBACKS;
typedef struct IDirect3DTexture2Vtbl DIRECT3DTEXTURE2CALLBACKS, *LPDIRECT3DTEXTURE2CALLBACKS;
typedef struct IDirect3DViewport2Vtbl DIRECT3DVIEWPORT2CALLBACKS, *LPDIRECT3DVIEWPORT2CALLBACKS;

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DIRECT3DI *LPDIRECT3DI;
typedef struct _DIRECT3DDEVICEI *LPDIRECT3DDEVICEI;
typedef struct _DIRECT3DEXECUTEBUFFERI *LPDIRECT3DEXECUTEBUFFERI;
typedef struct _DIRECT3DLIGHTI *LPDIRECT3DLIGHTI;
typedef struct _DIRECT3DMATERIALI *LPDIRECT3DMATERIALI;
typedef struct _DIRECT3DTEXTUREI *LPDIRECT3DTEXTUREI;
typedef struct _DIRECT3DVIEWPORTI *LPDIRECT3DVIEWPORTI;

/*
 * If we have an aggregate Direct3D we need a structure to
 * represent an interface distinct from the underlying
 * object. This is that structure. None of this would be necessary
 * in C++
 */
typedef struct _DIRECT3DUNKNOWNI
{
    LPD3DUNKNOWNCALLBACKS       lpVtbl;
    LPDIRECT3DI                lpObj;
} DIRECT3DUNKNOWNI;
typedef struct _DIRECT3DUNKNOWNI *LPDIRECT3DUNKNOWNI;

typedef struct _DIRECT3DOLDI
{
	LPDIRECT3DCALLBACKS lpVtbl;
	LPDIRECT3DI lpObj;
} DIRECT3DOLDI;
typedef struct _DIRECT3DOLDI *LPDIRECT3DOLDI;

/*
 * Internal version of Direct3D object; it has data after the vtable
 */
typedef struct _DIRECT3DI
{
    /*** Object Interface ***/
    LPDIRECT3D2CALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count object */

    /*** Object Relations ***/
    /* Devices */
    int				numDevs;/* Number of devices */
    LIST_ROOT(_devices, _DIRECT3DDEVICEI) devices;
    					/* Associated IDirect3DDevices */

    /* Viewports */
    int				numViewports; /* Number of viewports */
    LIST_ROOT(_viewports, _DIRECT3DVIEWPORTI) viewports;
    					/* Created IDirect3DViewports */
					
    /* Lights */
    int				numLights; /* Number of lights */
    LIST_ROOT(_lights, _DIRECT3DLIGHTI) lights;
    					/* Created IDirect3DLights */

    /* Materials */
    int				numMaterials; /* Number of materials */
    LIST_ROOT(_materials, _DIRECT3DMATERIALI) materials;
    					/* Created IDirect3DMaterials */

    /*** Object Data ***/
    unsigned long		v_next;	/* id of next viewport to be created */
    RLDDIRegistry*		lpReg;	/* Registry */

    /*
     * DirectDraw Interface
     */
    LPDDRAWI_DIRECTDRAW_INT	lpDDInt;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */
    DIRECT3DUNKNOWNI            lpThisIUnknown;   /* Our IUnknown interface */
	DIRECT3DOLDI				lpThisIDirect3D;   /* Our IDirect3D interface */

    DWORD                       dwVersion;      /* 1 for legacy D3D, 2 for D3D2 */
} DIRECT3DI;

/*
 * If we have an aggreate Direct3DDevice we need a structure to
 * represent an interface distinct from the underlying
 * object. This is that structure. 
 */
typedef struct _DIRECT3DDEVICEUNKNOWNI
{
    LPDIRECT3DDEVICE2CALLBACKS   lpVtbl;
    LPDIRECT3DDEVICEI           lpObj;
} DIRECT3DDEVICEUNKNOWNI;
typedef struct _DIRECT3DDEVICEUNKNOWNI *LPDIRECT3DDEVICEUNKNOWNI;

typedef struct _DIRECT3DDEVICEOLDI
{
    LPDIRECT3DDEVICECALLBACKS   lpVtbl;
    LPDIRECT3DDEVICEI           lpObj;
} DIRECT3DDEVICEOLDI;
typedef struct _DIRECT3DDEVICEOLDI *LPDIRECT3DDEVICEOLDI;

/*
 * Internal version of Direct3DDevice object; it has data after the vtable
 */

#include "d3dhal.h"

typedef RLDDIDriver*  (*RLDDIDDrawCreateDriverFn)(
					LPDDRAWI_DIRECTDRAW_INT lpDDInt,
					LPDIRECTDRAWSURFACE lpDDS,
					LPDIRECTDRAWSURFACE lpZ,
					LPDIRECTDRAWPALETTE lpPal,
					LPDIRECT3DDEVICEI);

typedef HRESULT (*RLDDIGetCapsFn)(LPD3DDEVICEDESC*, LPD3DDEVICEDESC*);
typedef void (*RLDDIInitFn)(RLDDIMallocFn, RLDDIReallocFn, RLDDIFreeFn, RLDDIRaiseFn, RLDDIValue**, int, int);
typedef void (*RLDDIPushDriverFn)(RLDDIDriverStack*, RLDDIDriver*);
typedef void (*RLDDIPopDriverFn)(RLDDIDriverStack*);

struct _RLDDIGenRasDriver;
typedef struct _RLDDIGenRasDriver* LPRLDDIGENRASDRIVER;
struct _RLDDIDDrawDriver;
typedef struct _RLDDIDDrawDriver* LPRLDDIDDRAWDRIVER;

struct _RLDDITransformDriver;
typedef struct _RLDDITransformDriver* LPRLDDITRANSFORMDRIVER;

typedef HRESULT (*PFNLOCKTEXTURE)(LPRLDDIGENRASDRIVER driver);
typedef void (*PFNUNLOCKTEXTURE)(LPRLDDIGENRASDRIVER driver);
typedef int (*PFNSETFILLPARAMS)(LPRLDDIGENRASDRIVER driver, D3DSTATE* in_params,
			  int count);
typedef HRESULT (*PFNREALLOCALIGNED)(void** p_inout, size_t size);
typedef HRESULT (*PFNMALLOCALIGNED)(void** p_inout, size_t size);
typedef HRESULT (*PFNFREEALIGNED)(void* p_inout);
typedef HRESULT (*PFNDRVSETRENDERTARGET)(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE, 
										 LPDIRECTDRAWPALETTE, LPDIRECT3DDEVICEI);
typedef HRESULT (*PFNDOFLUSHBEGINEND)(LPDIRECT3DDEVICE2, DWORD);
typedef	HRESULT (*PFNDRAWPRIMITIVES)(LPDIRECT3DDEVICEI, LPD3DTLVERTEX, LPVOID, LPD3DINSTRUCTION, DWORD);


typedef struct _D3DI_TEXTUREBLOCK
{
    LIST_MEMBER(_D3DI_TEXTUREBLOCK)	list;
    					/* Next block in IDirect3DTexture */
    LIST_MEMBER(_D3DI_TEXTUREBLOCK)	devList;
    					/* Next block in IDirect3DDevice */
    LPDIRECT3DDEVICEI			lpD3DDeviceI;
    LPDIRECT3DTEXTUREI			lpD3DTextureI;
    D3DTEXTUREHANDLE			hTex;
    					/* texture handle */
} D3DI_TEXTUREBLOCK;
typedef struct _D3DI_TEXTUREBLOCK *LPD3DI_TEXTUREBLOCK;

typedef struct _D3DI_MATERIALBLOCK
{
    LIST_MEMBER(_D3DI_MATERIALBLOCK)	list;
    					/* Next block in IDirect3DMaterial */
    LIST_MEMBER(_D3DI_MATERIALBLOCK)	devList;
    					/* Next block in IDirect3DDevice */
    LPDIRECT3DDEVICEI			lpD3DDeviceI;
    LPDIRECT3DMATERIALI			lpD3DMaterialI;
    D3DMATERIALHANDLE			hMat;
    					/* material handle */
} D3DI_MATERIALBLOCK;
typedef struct _D3DI_MATERIALBLOCK *LPD3DI_MATERIALBLOCK;

#define D3D_RSTATEBUF_SIZE 128
#define D3D_MAX_RSTATES 96 /* Last render state ID + 1 */
#define D3D_MAX_MMX_VERTICES 1024

extern DWORD dwD3DTriBatchSize, dwTriBatchSize, dwLineBatchSize;
extern DWORD dwHWBufferSize, dwHWMaxTris;
extern DWORD dwHWFewVertices;

typedef struct _D3DHAL_DRAWPRIMCOUNTS *LPD3DHAL_DRAWPRIMCOUNTS;

// Legacy HAL batching is done with these structs.
typedef struct _D3DI_HWCOUNTS {
    WORD wNumStateChanges;      // Number of state changes batched
    WORD wNumVertices;          // Number of vertices in tri list
    WORD wNumTriangles;         // Number of triangles in tri list
} D3DI_HWCOUNTS, *LPD3DI_HWCOUNTS;

typedef struct _DIRECT3DDEVICEI
{
    /*** Object Interface ***/
    LPDIRECT3DDEVICE2CALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI                lpDirect3DI; /* parent */
    LIST_MEMBER(_DIRECT3DDEVICEI)list;	/* Next device IDirect3D */

    /* Textures */
    LIST_ROOT(_textures, _D3DI_TEXTUREBLOCK) texBlocks;
    					/* Ref to created IDirect3DTextures */

    /* Execute buffers */
    LIST_ROOT(_buffers, _DIRECT3DEXECUTEBUFFERI) buffers;
    					/* Created IDirect3DExecuteBuffers */

    /* Viewports */
    int				numViewports;
    CIRCLE_QUEUE_ROOT(_dviewports, _DIRECT3DVIEWPORTI) viewports;
    					/* Associated IDirect3DViewports */
    LPDIRECT3DVIEWPORT2 lpCurrentViewport;

    /* Materials */
    LIST_ROOT(_dmmaterials, _D3DI_MATERIALBLOCK) matBlocks;
    					/* Ref to associated IDirect3DMaterials */

    /*** Object Data ***/
    /* Private interfaces */
    LPD3DOBJECTVTBL		lpClassVtbl; /* Private Vtbl */
    LPD3DOBJECTVTBL		lpObjVtbl; /* Private Vtbl */

    LPD3DHAL_CALLBACKS		lpD3DHALCallbacks; /* HW specific */
    LPD3DHAL_GLOBALDRIVERDATA	lpD3DHALGlobalDriverData; /* HW specific */

    /* Viewports */
    unsigned long		v_id;	/* ID of last viewport rendered */

    /* Lights */
    int				numLights;
    					/* This indicates the maximum number
					   of lights that have been set in
					   the device. */

    /* Device characteristics */
    int				age;
    int				width;
    int				height;
    int				depth;
    unsigned long		red_mask, green_mask, blue_mask;

    int				dither;
    int				ramp_size; /* SW specific */
    D3DCOLORMODEL		color_model;
    int				wireframe_options;
    D3DTEXTUREFILTER		texture_quality;
    D3DVALUE			gamma;
    unsigned char		gamma_table[256];
    int				aspectx, aspecty;
    D3DVALUE			perspective_tolerance;

    /* Library information */
#ifdef WIN32
    HINSTANCE		hDrvDll;
    char		dllname[MAXPATH];
    char		base[256];
#endif
#ifdef SHLIB
    void*		so;
#endif

    /* Are we in a scene? */
    BOOL		bInScene;

    /* Our Device type */
    GUID		guid;

    /* GetCaps function from the library */
    RLDDIGetCapsFn	GetCapsFn;

    /* Functions required to build driver */
    RLDDIInitFn		RLDDIInit;
    RLDDIPushDriverFn	RLDDIPushDriver;
    RLDDIPopDriverFn	RLDDIPopDriver;
    RLDDIDDrawCreateDriverFn	RLDDIDDrawCreateDriver;

    /* Device description */
    D3DDEVICEDESC	d3dHWDevDesc;
    D3DDEVICEDESC	d3dHELDevDesc;

    /* Driver stack */
    RLDDIDriverStack*	stack;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */
    DIRECT3DDEVICEUNKNOWNI      lpThisIUnknown;   /* Our IUnknown interface */
    DIRECT3DDEVICEOLDI			lpThisID3DDev;   /* Our IDirect3DDevice interface */

    LPD3DHAL_CALLBACKS2         lpD3DHALCallbacks2; /* HW specific */

	/*
	 * Renderstate cache for DrawPrimitive
	 */
	WORD wRStateBufLevel;
        D3DSTATE renStateBuf[D3D_RSTATEBUF_SIZE];

	/* Pointers to drivers used by DrawPrimitive */
	LPRLDDIGENRASDRIVER rasDriver; /* SW specific */
	LPRLDDITRANSFORMDRIVER xfmDriver; /* Assumed to be NULL for HW */
	LPRLDDIDDRAWDRIVER drawDriver; /* Assumed to be NULL for HW */

	/*
	 * Pointers to functions used by DrawPrim&Begin/End
	 */

	PFNLOCKTEXTURE pfnLockTexture; /* SW specific */
	PFNUNLOCKTEXTURE pfnUnlockTexture; /* SW specific */
	PFNSETFILLPARAMS pfnSetFillParams; /* SW specific */
	PFNREALLOCALIGNED pfnReallocAligned; /* SW specific */
	PFNDRVSETRENDERTARGET pfnDrvSetRenderTarget; /* SW specific */
	HRESULT (*pfnFlushStates)(struct _DIRECT3DDEVICEI*);
    PFNDOFLUSHBEGINEND pfnDoFlushBeginEnd;
	PFNDRAWPRIMITIVES pfnDrawPrimitives;

    /* Are we between Begin/End? */
    BOOL				bInBegin;
    D3DVERTEXTYPE		vtVertexType;
    D3DPRIMITIVETYPE	ptPrimitiveType;
	CRITICAL_SECTION	BeginEndCSect;

	// max number of vertices
    #define BEGIN_DATA_BLOCK_SIZE   256

    LPVOID	lpvVertexBatch;
	WORD	*lpIndexBatch;

    // lpvVertexData is non-NULL if we are InBegin and indexed.
    LPVOID	lpvVertexData;
    DWORD	dwNumVertices;
	DWORD	dwMaxVertexCount;	// current number of vertices there is space for
    WORD	*lpVertexIndices;
    DWORD	dwNumIndices;
	DWORD	dwMaxIndexCount;	// current number of indices there is space for

    DWORD	dwFlags;
    WORD	wFlushed;

    /*
     * DrawPrimitives batching
     */


        // Buffer to put DrawPrimitives stuff into
        // Used for both legacy and DrawPrimitive HALs
	 WORD *lpwDPBuffer; 
	 WORD *lpwDPBufferAlloced;

    /* Legacy HALs */
        // pointer to current prim counts struct
        LPD3DHAL_DRAWPRIMCOUNTS lpDPPrimCounts;

        // Buffer of counts structures that keep track of the
        // number of render states and vertices buffered
        LPD3DI_HWCOUNTS lpHWCounts;

        // Buffer of triangle structures.
        LPD3DTRIANGLE lpHWTris;

        // Buffer of interleaved render states and primitives.
        LPD3DTLVERTEX lpHWVertices;

        // Byte offset into lpHWVertices. This gets incremented
        // by 8 when a render state is batched and by 32*dwNumVertices
        // when a primitive is batched.
        DWORD dwHWOffset;

        // Max value of dwHWOffset. Used to decide whether to flush.
        DWORD dwHWMaxOffset;

        // Index into lpHWTris.
        DWORD dwHWTriIndex;

        // Number of counts structures used so far. This actually
        // gives the number of primitives batched and the index of
        // the counts structure to batch render states into.
        DWORD dwHWNumCounts;

    /* DrawPrimitive-aware HALs */

        // Byte offset into buffer (we are currently
        // using the device's wTriIndex)
        DWORD dwDPOffset;

        // Maximum offset. If dwDPOffset exceeds this, it is
        // time to flush.
        DWORD dwDPMaxOffset;

	WORD *wTriIndex;

	// buffers for TL and H vertices
	LPD3DTLVERTEX	lpTLVbuf;
	LPD3DHVERTEX	lpHVbuf;
	DWORD			dwVbufSize;

    LPD3DHAL_D3DEXTENDEDCAPS lpD3DExtendedCaps;  /* HW specific */

} DIRECT3DDEVICEI;

/*
 * Internal version of Direct3DExecuteBuffer object;
 * it has data after the vtable
 */
typedef struct _DIRECT3DEXECUTEBUFFERI
{
    /*** Object Interface ***/
    LPDIRECT3DEXECUTEBUFFERCALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DDEVICEI		lpD3DDeviceI; /* Parent */
    LIST_MEMBER(_DIRECT3DEXECUTEBUFFERI)list;
    					/* Next buffer in IDirect3D */

    /*** Object Data ***/
    DWORD			pid;	/* Process locking execute buffer */
    D3DEXECUTEBUFFERDESC	debDesc;
    					/* Description of the buffer */
    D3DEXECUTEDATA		exData;	/* Execute Data */
    BOOL			locked;	/* Is the buffer locked */

    D3DI_BUFFERHANDLE		hBuf;
    					/* Execute buffer handle */
} DIRECT3DEXECUTEBUFFERI;

/*
 * Internal version of Direct3DLight object;
 * it has data after the vtable
 */
typedef struct _DIRECT3DLIGHTI
{
    /*** Object Interface ***/
    LPDIRECT3DLIGHTCALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI                lpDirect3DI; /* Parent */
    LIST_MEMBER(_DIRECT3DLIGHTI)list;
    					/* Next light in IDirect3D */

    LPDIRECT3DVIEWPORTI		lpD3DViewportI; /* Guardian */
    CIRCLE_QUEUE_MEMBER(_DIRECT3DLIGHTI)light_list;
    					/* Next light in IDirect3DViewport */

    /*** Object Data ***/
    D3DLIGHT2			dlLight;/* Data describing light */
    D3DI_LIGHT			diLightData;
    					/* Internal representation of light */
} DIRECT3DLIGHTI;

typedef struct _DIRECT3DMATERIALOLDI
{
	LPDIRECT3DMATERIALCALLBACKS lpVtbl;
	LPDIRECT3DMATERIALI lpObj;
} DIRECT3DMATERIALOLDI, *LPDIRECT3DMATERIALOLDI;

/*
 * Internal version of Direct3DMaterial object;
 * it has data after the vtable
 */
typedef struct _DIRECT3DMATERIALI
{
    /*** Object Interface ***/
    LPDIRECT3DMATERIAL2CALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI                lpDirect3DI; /* Parent */
	DIRECT3DMATERIALOLDI lpThisID3DMat; /* Our IDirect3DMaterial interface */
    LIST_MEMBER(_DIRECT3DMATERIALI)list;
    					/* Next MATERIAL in IDirect3D */

    LIST_ROOT(_mblocks, _D3DI_MATERIALBLOCK)blocks;
    					/* devices we're associated with */

    /*** Object Data ***/
    D3DMATERIAL			dmMaterial; /* Data describing material */
    BOOL			bRes;	/* Is this material reserved in the driver */
} DIRECT3DMATERIALI;

/*
 * If we have an aggreate Direct3DTexture we need a structure
 * to represent an unknown interface distinct from the underlying
 * object. This is that structure. 
 */
typedef struct _DIRECT3DTEXTUREUNKNOWNI
{
    LPDIRECT3DTEXTURECALLBACKS  lpVtbl;
    LPDIRECT3DTEXTUREI          lpObj;
} DIRECT3DTEXTUREUNKNOWNI;
typedef struct _DIRECT3DTEXTUREUNKNOWNI *LPDIRECT3DTEXTUREUNKNOWNI;

typedef struct _DIRECT3DTEXTUREOLDI
{
	LPDIRECT3DTEXTURECALLBACKS lpVtbl;
	LPDIRECT3DTEXTUREI lpObj;
} DIRECT3DTEXTUREOLDI, *LPDIRECT3DTEXTUREOLDI;

/*
 * Internal version of Direct3DTexture object; it has data after the vtable
 */
typedef struct _DIRECT3DTEXTUREI
{
    /*** Object Interface ***/
    LPDIRECT3DTEXTURE2CALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */


    /*** Object Relations ***/
    LIST_ROOT(_blocks, _D3DI_TEXTUREBLOCK) blocks;
    					/* Devices we're associated with */

    /*** Object Data ***/
    LPDIRECTDRAWSURFACE		lpDDS;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */
    DIRECT3DTEXTUREUNKNOWNI     lpThisIUnknown;   /* Our IUnknown interface */
    DIRECT3DTEXTUREOLDI     lpThisID3DTex;   /* Our IDirect3DTexture interface */
    BOOL			bIsPalettized;

} DIRECT3DTEXTUREI;

/*
 * Internal version of Direct3DViewport object; it has data after the vtable
 */
typedef struct _DIRECT3DVIEWPORTI
{
    /*** Object Interface ***/
    LPDIRECT3DVIEWPORT2CALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations */
    LPDIRECT3DI                 lpDirect3DI; /* Parent */
    LIST_MEMBER(_DIRECT3DVIEWPORTI)list;
    					/* Next viewport in IDirect3D */

    LPDIRECT3DDEVICEI		lpD3DDeviceI; /* Guardian */
    CIRCLE_QUEUE_MEMBER(_DIRECT3DVIEWPORTI)vw_list;
    					/* Next viewport in IDirect3DDevice */
					
    /* Lights */
    int				numLights;
    CIRCLE_QUEUE_ROOT(_dlights, _DIRECT3DLIGHTI) lights;
    					/* Associated IDirect3DLights */

    /*** Object Data ***/
    unsigned long		v_id;	/* Id for this viewport */
    D3DVIEWPORT2			v_data;
    BOOL                v_data_is_set;

    BOOL			have_background;
    D3DMATERIALHANDLE		background;
    					/* Background material */
    BOOL			have_depth;
    LPDIRECTDRAWSURFACE		depth;	/* Background depth */
    
    BOOL			bLightsChanged;
    					/* Have the lights changed since they
					   were last collected? */
    DWORD			clrCount; /* Number of rects allocated */
    LPD3DRECT			clrRects; /* Rects used for clearing */
} DIRECT3DVIEWPORTI;

/*
 * Picking stuff.
 */
typedef struct _D3DI_PICKDATA {
    D3DI_EXECUTEDATA*	exe;
    D3DPICKRECORD*	records;
    int			pick_count;
    D3DRECT		pick;
} D3DI_PICKDATA, *LPD3DI_PICKDATA;

/*
 * Direct3D memory allocation
 */

/*
 * Register a set of functions to be used in place of malloc, realloc
 * and free for memory allocation.  The functions D3DMalloc, D3DRealloc
 * and D3DFree will use these functions.  The default is to use the
 * ANSI C library routines malloc, realloc and free.
 */
typedef LPVOID (*D3DMALLOCFUNCTION)(size_t);
typedef LPVOID (*D3DREALLOCFUNCTION)(LPVOID, size_t);
typedef VOID (*D3DFREEFUNCTION)(LPVOID);

/*
 * Allocate size bytes of memory and return a pointer to it in *p_return.
 * Returns D3DERR_BADALLOC with *p_return unchanged if the allocation fails.
 */
HRESULT D3DAPI 		D3DMalloc(LPVOID* p_return, size_t size);

/*
 * Change the size of an allocated block of memory.  A pointer to the
 * block is passed in in *p_inout.  If *p_inout is NULL then a new
 * block is allocated.  If the reallocation is successful, *p_inout is
 * changed to point to the new block.  If the allocation fails,
 * *p_inout is unchanged and D3DERR_BADALLOC is returned.
 */
HRESULT D3DAPI 		D3DRealloc(LPVOID* p_inout, size_t size);

/*
 * Free a block of memory previously allocated with D3DMalloc or
 * D3DRealloc.
 */
VOID D3DAPI		D3DFree(LPVOID p);

/*
 * Used for raising errors from the driver.
 */
HRESULT D3DAPI D3DRaise(HRESULT);

/*
 * Convert RLDDI error codes to D3D error codes
 */
#define RLDDITOD3DERR(_errcode) (RLDDIToD3DErrors[_errcode])
extern HRESULT RLDDIToD3DErrors[];

/*
 * maths
 */
#if 1 /* defined(STACK_CALL) && defined(__WATCOMC__) */
D3DVALUE D3DIPow(D3DVALUE, D3DVALUE);
#else
#define D3DIPow(v,p)	DTOVAL(pow(VALTOD(v), VALTOD(p)))
#endif

/*
 * Light utils
 */
void D3DI_DeviceMarkLightEnd(LPDIRECT3DDEVICEI, int);
void D3DI_UpdateLightInternal(LPDIRECT3DLIGHTI);
void D3DI_VectorNormalise12(LPD3DVECTOR v);
D3DTEXTUREHANDLE D3DI_FindTextureHandle(LPDIRECT3DTEXTUREI, LPDIRECT3DDEVICEI);
void D3DI_SetTextureHandle(LPDIRECT3DTEXTUREI, LPDIRECT3DDEVICEI, D3DTEXTUREHANDLE);
void D3DI_RemoveTextureBlock(LPD3DI_TEXTUREBLOCK);
void D3DI_RemoveMaterialBlock(LPD3DI_MATERIALBLOCK);

extern BOOL D3DI_isHALValid(LPD3DHAL_CALLBACKS);

#ifdef BUILD_D3D_LAYER
extern RLDDIValue* RLDDIFInvSqrtTable;
#endif

#ifdef __cplusplus
};
#endif

#endif /* BUILD_HEL */
#endif /* !BUILD_RLAPI */
// @@END_MSINTERNAL

#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\i386src.inc ===
i386_SOURCES = \
$O\zramp8f.asm $O\zramp8ft.asm $O\zramp8g.asm $O\zramp8gt.asm $O\zramp8gtg.asm \
$O\zramp8ftg.asm $O\zrmfp8.asm $O\zrmfpg8.asm $O\zrmgp8.asm $O\zrmgpg8.asm \
$O\gramp8f.asm $O\gramp8ft.asm $O\gramp8g.asm $O\gramp8gt.asm $O\gramp8gtg.asm \
$O\gramp8ftg.asm $O\grmfp8.asm $O\grmfpg8.asm $O\grmgp8.asm $O\grmgpg8.asm \
$O\zramp16f.asm $O\zramp16ft.asm $O\zramp16g.asm $O\zramp16gt.asm $O\zramp16gtg.asm \
$O\zramp16ftg.asm $O\zrmfp16.asm $O\zrmfpg16.asm $O\zrmgp16.asm $O\zrmgpg16.asm \
$O\gramp16f.asm $O\gramp16ft.asm $O\gramp16g.asm $O\gramp16gt.asm $O\gramp16gtg.asm \
$O\gramp16ftg.asm $O\grmfp16.asm $O\grmfpg16.asm $O\grmgp16.asm $O\grmgpg16.asm

NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\driver.h ===
/* $Id: driver.h,v 1.71 1995/12/04 11:31:51 sjl Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */

#ifndef __DRIVER_H__
#define __DRIVER_H__

#define USE_FLOAT

#ifdef WIN32
//#define WIN32_LEAN_AND_MEAN
#endif
#include <stddef.h>
#include <wtypes.h>

typedef struct _RLDDIDriver RLDDIDriver;
typedef struct _RLDDIDriverStack RLDDIDriverStack;

#ifdef USE_FLOAT
#include "fltval.h"
#else
#include "fixval.h"
#endif
#include "osdep.h"

#ifdef D3D
typedef enum _RLRenderQuality {
    RLRenderWireframe,      /* display just the edges */
    RLRenderUnlitFlat,      /* flat shaded without lighting */
    RLRenderFlat,       /* flat shaded */
    RLRenderGouraud,        /* gouraud shaded */
    RLRenderPhong       /* phong shaded */
} RLRenderQuality;

typedef enum _RLColorModel {
    RLColorRamp, RLColorRGB
} RLColorModel;

typedef enum _RLLightType {
    RLLightAmbient,
    RLLightPoint,
    RLLightSpot,
    RLLightDirectional,
    RLLightParallelPoint
} RLLightType;

#if 0
/*
 * Error codes
 */
typedef enum _RLError {
    RLNoError = 0,      /* no error */
    RLBadObject,        /* object expected in argument */
    RLBadType,          /* bad argument type passed */
    RLBadAlloc,         /* out of memory */
    RLFaceUsed,         /* face already used in a mesh */
    RLNotFound,         /* object not found in specified place */
    RLNotDoneYet,       /* unimplemented */
    RLFileNotFound,     /* file cannot be opened */
    RLBadFile,          /* data file is corrupt */
    RLBadDevice,        /* device is not compatible with renderer */
    RLBadValue,         /* bad argument value */
    RLBadMajorVersion,      /* bad dll major version */
    RLBadMinorVersion,      /* bad dll minor version */
    RLMaxError
} RLErrorXXX;
#endif

#else
#include "rl.h"
#endif D3D

/*
 * Normal precision used to store numbers.
 */
#define NORMAL_PREC     16
#define DTOVAL(d)       DTOVALP(d,NORMAL_PREC)
#define VALTOD(f)       VALPTOD(f,NORMAL_PREC)
#define ITOVAL(i)       ITOVALP(i,NORMAL_PREC)
#define VALTOI(f)       VALPTOI(f,NORMAL_PREC)
#define VALROUND(f)     VALPROUND(f,NORMAL_PREC)
#define VALTOFX(f)      VALTOFXP(f,NORMAL_PREC)
#define FXTOVAL(f)      FXPTOVAL(f,NORMAL_PREC)
#define ITOFX(i)        ITOFXP(i,NORMAL_PREC)
#define FXTOI(f)        FXPTOI(f,NORMAL_PREC)
#define FXROUND(f)      FXPROUND(f,NORMAL_PREC)
#define FXFLOOR(f)      FXPTOI(f,NORMAL_PREC)
#define FXCEIL(f)       FXPCEIL(f,NORMAL_PREC)
#define VALTOFX24(f)    VALTOFXP(f,24)
#define FX24TOVAL(f)    FXPTOVAL(f,24)
#define VALTOFX20(f)    VALTOFXP(f,20)
#define FX20TOVAL(f)    FXPTOVAL(f,20)
#define VALTOFX12(f)    VALTOFXP(f,12)
#define FX12TOVAL(f)    FXPTOVAL(f,12)
#define VALTOFX8(f)     VALTOFXP(f,8)
#define FX8TOVAL(f)     FXPTOVAL(f,8)

/*
 * A handy macro.
 */
#define RLDDIAbs(N) (((N) < 0) ? -(N) : (N))

#if defined(__DOS__) || defined(__WINDOWS_386__)
#define RLFAR far
#else
#define RLFAR
#endif

#ifndef UNUSED
#if defined(__WATCOMC__)
#define UNUSED(v)       (v)
#else
#define UNUSED(v)
#endif
#endif

typedef enum _RLDDIServiceType {
    /*
     * Notify a module after it has been pushed into a stack.
     *
     * The module may also register fast service functions;
     * to register a fast service, set the appropriate table entry.
     * Note: the module must either register *no* services (old style),
     * or *all* the services it supports (including RLDDIPush)
     */
    /* HRESULT */ RLDDIPush,                    /* 0, RLDDIServiceProc[] */

    /*
     * Get a set of functions to create transform, render and lighting
     * drivers compatible with the given windowing system driver and color
     * model.
     */
    /* HRESULT */ RLDDIGetCreateDriverFunctions,/* RLColorModel, &result */

    /*
     * Notify a module before it is popped from a stack.
     */
    /* HRESULT */ RLDDIPop,                     /* NULL, NULL */

    /*
     * Set various rendering parameters.
     */
    /* HRESULT */ RLDDISetRenderParams,         /* 0, RLDDIRenderParams* */

    /*
     * Set the current viewport.
     */
    /* HRESULT */ RLDDISetViewport,             /* id, D3DVIEWPORT2* */

    /*
     * Deal with matrices
     */
    /* HRESULT */ RLDDICreateMatrix,        /* 0, LPD3DMATRIXHANDLE */
    /* HRESULT */ RLDDISetMatrix,       /* D3DMATRIXHANDLE, LPD3DMATRIX */
    /* HRESULT */ RLDDIGetMatrix,       /* D3DMATRIXHANDLE, LPD3DMATRIX */
    /* HRESULT */ RLDDIDeleteMatrix,        /* D3DMATRIXHANDLE, NULL */
    /*
     * Set one of the transformation matrices
     */
    /* HRESULT */ RLDDISetMatrixView,                   /* type, D3DMATRIXHANDLE */
    /* HRESULT */ RLDDISetMatrixProj,                   /* type, D3DMATRIXHANDLE */
    /* HRESULT */ RLDDISetMatrixWorld,                  /* type, D3DMATRIXHANDLE */
#if 0
    /* HRESULT */ RLDDISetMatrixTrans,                  /* type, D3DMATRIXHANDLE */
#endif

    /* HRESULT */ RLDDIMultiplyMatrices,                /* count, RLDDIMatrix** */

    /*
     * Transform some vertices.
     */
    /* ClipFlags */ RLDDITransform,                     /* count, RLDDITransformData* */
    /* ClipFlags */ RLDDITransformClipped,              /* count, RLDDITransformData* */
    /* ClipFlags */ RLDDITransformUnclipped,            /* count, RLDDITransformData* */

    /*
     * Set the current lighting configuration.  All normals are given
     * in the current model coordinate system.
     */
    /* HRESULT */ RLDDISetLight,               /* which_light, D3DI_LIGHTDATA* */

    /*
     * Set the current fog configuration.
     */
    /* HRESULT */ RLDDISetFogMode,          /* 0, D3DFOGMODE* */
    /* HRESULT */ RLDDISetFogStart,         /* 0, RLDDIValue* */
    /* HRESULT */ RLDDISetFogEnd,           /* 0, RLDDIValue* */
    /* HRESULT */ RLDDISetFogDensity,           /* 0, RLDDIValue* */

    /* HRESULT */ RLDDISetFogEnable,            /* 0, D3DFOGMODE* */
    /* HRESULT */ RLDDISetFogColor,         /* 0, D3DFOGMODE* */

    /*
     * Calculate pixel values for some primitives with lighting.
     */
    /* HRESULT */ RLDDIApplyMaterialsLit,       /* count, D3DLIGHTDATA* */

    /*
     * Calculate pixel values for some primitives without lighting.
     */
    /* HRESULT */ RLDDIApplyMaterialsUnlit,     /* count, D3DLIGHTDATA* */

    /*
     * Calculate vertex values for some primitives without lighting.
     */
    /* HRESULT */ RLDDIApplyMaterialShade,     /* count, D3DLIGHTDATA* */

    /*
     * Called to update dynamic color allocation state for materials
     * which are still being used but not lit.  Returns TRUE if the
     * results of the previous lighting calls can be reused or FALSE
     * if the object should be relit anyway due to color entries being
     * reclaimed.
     */
    /* Boolean */ RLDDIUpdateMaterial,

    /*
     * Clear a drivers pick records
     */
    /* HRESULT */ RLDDIClearPickRecords,                /* 0, NULL */

    /* HRESULT */ RLDDIGetPickRecords,                  /* 0, NULL */
    /*
     * pick a display list.
     */
    /* HRESULT */ RLDDIPickExecuteBuffer,               /* stak top, RLDDIPickData* */

    /*
     * Execute a display list.
     */
    /* HRESULT */ RLDDIExecuteUnclipped,                /* stak top, RLDDIExecuteData* */
    /* HRESULT */ RLDDIExecuteClipped,                  /* stak top, RLDDIExecuteData* */

    /*
     * Get the current pixmaps used for drawing (used by software
     * renderers to interface with low level drivers).
     */
    /* HRESULT */ RLDDIGetColorPixmap,                  /* NULL, &pixmap */
    /* HRESULT */ RLDDIGetDepthPixmap,                  /* NULL, &pixmap */

    /*
     * Release the current pixmaps used for drawing (used by software
     * renderers to interface with low level drivers).
     */
    /* HRESULT */ RLDDIReleaseColorPixmap,              /* NULL NULL */
    /* HRESULT */ RLDDIReleaseDepthPixmap,              /* NULL NULL */

    /*
     * Find a color allocator to use for mapping rgb values to pixels.
     */
    /* HRESULT */ RLDDIFindColorAllocator,              /* NULL, &alloc */

    /*
     * Find a rampmap to use for color allocation in color index
     * drivers.  This does not need to be supported if color index
     * rendering is not used.
     */
    /* HRESULT */ RLDDIFindRampmap,                     /* NULL, &rampmap */

    /*
     * Release a rampmap (from RLDDIFindRampmap), freeing all
     * resources.
     */
    /* HRESULT */ RLDDIReleaseRampmap,                  /* NULL, rampmap */

    /*
     * Get the color index -> pixel value mapping (if any).
     */
    /* HRESULT */ RLDDIGetColorMapping,                 /* NULL, &unsigned_long_ptr */

    /*
     * Convert a texture handle into a pointer (private to ramp driver)
     */
    /* HRESULT */ RLDDILookupTexture,               /* NULL, handle */

    /*
     * Update the screen with a region which has changed.  May involve
     * copying into the window, swapping double buffers, etc.
     */
    /* HRESULT */ RLDDIUpdate,                          /* count, D3DRECTANGLE* */

    /*
     * Lock against vsync, if necessary, for a given driver.
     */
    /* HRESULT */ RLDDISync,

    /*
     * Clear the viewport.
     */
    /* HRESULT */ RLDDIClear,                           /*  */

    /*
     * Clear the zbuffer.
     */
    /* HRESULT */ RLDDIClearZ,                          /*  */

    /*
     * Clear the both the z and viewport.
     */
    /* HRESULT */ RLDDIClearBoth,                       /*  */

    /*
     * Get the dimensions of the device.
     */
    /* HRESULT */ RLDDIGetDriverParams,                 /* 0, RLDDIDriverParams* */

    /*
     * Set a material to be used to clear the viewport in RLDDIClear.
     */
    /* HRESULT */ RLDDISetBackgroundMaterial,           /* 0, D3DMATERIALHANDLE */

    /*
     * Set an image to be used to clear the viewport depth planes
     * in RLDDIClear.
     */
    /* HRESULT */ RLDDISetBackgroundDepth,              /* 0, RLImage* */

    /*
     * Ask the driver whether it can support the given RLImage as a
     * texture map.  If the image can be supported directly, the
     * driver should return RLNoError.  If another image format is
     * preferred, the driver should modify the pointer to point to an
     * RLImage structure of the required format and return RLNoError.  Note
     * that this need not be a complete image.  The buffer1 and
     * palette fields are ignored.
     *
     * If the driver does not support texture mapping at all, then it
     * should return RLBadDevice.
     *
     * If arg1 is not null, the driver will point at an array of DDSURFACEDESC
     * structures and return the size of the array.
     */
    /* HRESULT  | int */ RLDDIQueryTextureFormat,               /* LPDDSURFACEDESC*, RLImage** */

    /* HRESULT */ RLDDIActivatePalette,                 /* WM_ACTIVATE */

    /*
     * Set the current material for the lighting module.
     */
    /* HRESULT */ RLDDISetMaterial,                 /* 0, D3DMATERIALHANDLE */

    /*
     * Set the color of the ambient light. The format is:
     *     (white << 24) | (red << 16) | (green << 8) | blue
     * where white is the equivalent white shade for monochrome lighting.
     */
    /* HRESULT */ RLDDISetAmbientLight,                 /* color, NULL */

    /*
     * Create a texture from the given image.  The image must be in a format
     * approved by RLDDIQueryTextureFormat.  The texture may use the memory
     * of the image for the pixel values or it may copy the image.  Returns
     * a handle for the texture.
     */
    /* HRESULT */ RLDDICreateTexture,             /* LPDIRECTDRAWSURFACE, &D3DTEXTUREHANDLE */

    /*
     * Destroy a texture previously created using RLDDICreateTexture.
     */
    /* HRESULT */ RLDDIDestroyTexture,                  /* D3DTEXTUREHANDLE, 0 */

    /*
     * Load a texture previously created using RLDDICreateTexture.
     * arg1 - src, arg2 = dst
     */
    /* HRESULT */ RLDDILoadTexture,                 /* D3DTEXTUREHANDLE, D3DTEXTUREHANDLE*/

    /*
     * Lock a texture previously created using RLDDICreateTexture.
     */
    /* HRESULT */ RLDDILockTexture,                 /* D3DTEXTUREHANDLE, 0 */

    /*
     * Unlock a texture previously created using RLDDICreateTexture.
     */
    /* HRESULT */ RLDDIUnlockTexture,                   /* D3DTEXTUREHANDLE, 0 */

    /*
     * Swap two textures.
     */
    /* HRESULT */ RLDDISwapTextureHandles,              /* D3DTEXTUREHANDLE, D3DTEXTUREHANDLE */

    /*
     * Update any private copies of the pixels in a texture when it has been
     * changed by the application.  The flags argument is a bitfield:
     *
     *          flags & 1               the image pixels have changed
     *          flags & 2               the image palette has changed
     */
    /* HRESULT */ RLDDIUpdateTexture,                   /* flags, handle */

    /*
     *
     */
    /* HRESULT */ RLDDISetTextureOpacity,       /* 0, RLDDISetTextureOpacityParams */

    /*
     * Used in ramp color module for interfacing between renderer and
     * lighting.
     */
    /* HRESULT */ RLDDILookupMaterial,

    /*
     * Create a material
     */
    /* HRESULT */ RLDDICreateMaterial,  /* D3DMATERIALHANDLE*, D3DMATERIAL* */

    /*
     * Destroy a material
     */
    /* HRESULT */ RLDDIDestroyMaterial, /* D3DMATERIALHANDLE, NULL */

    /*
     * Used by renderer to map material handles to materials.
     */
    /* HRESULT */ RLDDIFindMaterial,    /* D3DMATERIALHANDLE, LPD3DMATERIAL* */

    /*
     * Used by Direct3D to inform the driver that a material has changed.
     */
    /* HRESULT */ RLDDIMaterialChanged, /* D3DMATERIALHANDLE, LPD3DMATERIAL */

    /*
     * Used by Direct3D to reserve a material
     */
    /* HRESULT */ RLDDIMaterialReserve, /* D3DMATERIALHANDLE, NULL */

    /*
     * Used by Direct3D to unreserve a material
     */
    /* HRESULT */ RLDDIMaterialUnreserve,/* D3DMATERIALHANDLE, NULL */

    /*
     * Used with frame materials to override the settings of a
     * display list.
     */
    /* HRESULT */ RLDDISetOverrideFillParams,           /* 0, &override_params */

    /*
     * Used with frame materials to override the settings of a
     * display list.
     */
    /* HRESULT */ RLDDISetOverrideMaterial,     /* 0, override_material */

    /*
     * Create an Execute Buffer
     */
    /* HRESULT */ RLDDIAllocateBuffer,          /* LPD3DI_BUFFERHANDLE, LPD3DEXECUTEBUFFERDESC */

    /*
     * Destroy an Execute Buffer
     */
    /* HRESULT */ RLDDIDeallocateBuffer,        /* D3DI_BUFFERHANDLE, (LPVOID)0 */

    /*
     * Lock an Execute Buffer
     */
    /* HRESULT */ RLDDILockBuffer,          /* D3DI_BUFFERHANDLE, (LPVOID)0 */

    /*
     * Unlock an Execute Buffer
     */
    /* HRESULT */ RLDDIUnlockBuffer,            /* D3DI_BUFFERHANDLE, (LPVOID)0 */

    /*
     * Set all 256 palette entries in an 8 bit device.
     */
    /* HRESULT */ RLDDISetPalette,          /* 0, RLPalettEntry* */

    /*
     * Get all 256 palette entries of an 8 bit device.
     */
    /* HRESULT */ RLDDIGetPalette,          /* 0, RLPaletteEntry* */

    /*
     * Generic platform specific driver extension type thing.
     */
    /* HRESULT */ RLDDIDriverExtension,         /* code, (void *) */

#ifdef __psx__
    /*
     * Set various PSX specific flags, to increase speed
     */
    /* HRESULT */ RLDDIPSXSetUpdateFlags,

    /*
     * allow people to reserve space in VRAM for their own use
     */
    /* HRESULT */ RLDDIPSXReserveTextureSpace,
    /* HRESULT */ RLDDIPSXReserveCLUTSpace,

    /*
     * so that people can access ordering table info
     */

    /* HRESULT */ RLDDIPSXQuery,
#endif

    /*
     * Inform of beginning/end of a scene.
     */
    /* HRESULT */ RLDDISceneCapture,            /* BOOL, NULL */

    /*
     * Get an item of state from a particular module.
     */
    /* HRESULT */ RLDDIGetState,            /* long, LPD3DSTATE */

    /*
     * Get stats from a driver
     */
    /* HRESULT */ RLDDIGetStats,            /* 0, LPD3DSTATS */

    /*
     * Not a service call
     */
    RLDDIServiceCount /* assumes none of the other enums are given initializers */

} RLDDIServiceType;


#ifdef D3D
typedef enum _RLPaletteFlags {
    RLPaletteFree,      /* renderer may use this entry freely */
    RLPaletteReadOnly,      /* fixed but may be used by renderer */
    RLPaletteReserved       /* may not be used by renderer */
} RLPaletteFlags;


typedef struct _RLPaletteEntry {
    unsigned char red;      /* 0 .. 255 */
    unsigned char green;    /* 0 .. 255 */
    unsigned char blue;     /* 0 .. 255 */
    unsigned char flags;    /* one of RLPaletteFlags */
} RLPaletteEntry;

typedef struct _RLImage {
    int width, height;      /* width and height in pixels */
    int aspectx, aspecty;   /* aspect ratio for non-square pixels */
    int depth;          /* bits per pixel */
    int rgb;            /* if false, pixels are indices into a
                   palette otherwise, pixels encode
                   RGB values. */
    int bytes_per_line;     /* number of bytes of memory for a
                   scanline. This must be a multiple
                   of 4. */
    void* buffer1;      /* memory to render into (first buffer). */
    void* buffer2;      /* second rendering buffer for double
                   buffering, set to NULL for single
                   buffering. */
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    unsigned long alpha_mask;
                /* if rgb is true, these are masks for
                   the red, green and blue parts of a
                   pixel.  Otherwise, these are masks
                   for the significant bits of the
                   red, green and blue elements in the
                   palette.  For instance, most SVGA
                   displays use 64 intensities of red,
                   green and blue, so the masks should
                   all be set to 0xfc. */
    int palette_size;           /* number of entries in palette */
    RLPaletteEntry* palette;    /* description of the palette (only if
                   rgb is false).  Must be (1<<depth)
                   elements. */
} RLImage;




#endif /* D3D */


#ifdef WIN32
#define RLDDIAPI  __stdcall
#else
#define RLDDIAPI
#endif

typedef void (*RLDDIDestroyProc)(RLDDIDriver* driver);
typedef long (*RLDDIServiceProc)(RLDDIDriver* driver,
                 RLDDIServiceType type,
                 long arg1,
                 void* arg2);

typedef HRESULT (RLDDIAPI *RLDDIMallocFn)(void**, size_t);
typedef HRESULT (RLDDIAPI *RLDDIReallocFn)(void**, size_t);
typedef void (RLDDIAPI *RLDDIFreeFn)(void*);
typedef HRESULT (*RLDDIRaiseFn)(HRESULT);

#ifndef DLL_IMPORTS_GEN
__declspec( dllexport ) extern RLDDIRaiseFn RLDDIRaise;
__declspec( dllexport ) extern RLDDIMallocFn    RLDDIMalloc;
__declspec( dllexport ) extern RLDDIReallocFn   RLDDIRealloc;
__declspec( dllexport ) extern RLDDIFreeFn  RLDDIFree;
#else
__declspec( dllimport ) RLDDIRaiseFn    RLDDIRaise;
__declspec( dllimport ) RLDDIMallocFn   RLDDIMalloc;
__declspec( dllimport ) RLDDIReallocFn  RLDDIRealloc;
__declspec( dllimport ) RLDDIFreeFn RLDDIFree;
#endif

#include "d3di.h"
#include "dditypes.h"

typedef struct _RLDDIGlobalDriverData {
    /*
     * Pointers to driver modules
     */
    RLDDIDriver     *transform;
    RLDDIDriver     *lighting;
    RLDDIDriver     *raster;
} RLDDIGlobalDriverData;

struct _RLDDIDriver {
    RLDDIDriver*        prev;
    RLDDIDriver*        next;
    RLDDIDriverStack*   top;            /* top of the driver stack */

    int                 width, height;  /* dimensions */

    RLDDIDestroyProc    destroy;        /* clean up */
    RLDDIServiceProc    service;        /* do something */

    RLDDIGlobalDriverData* data;    /* pointer to global data */
    /* Driver private data may follow */
};

struct _RLDDIDriverStack {
    RLDDIDriver *top;
    struct {
    RLDDIServiceProc call;
    RLDDIDriver *driver;
    } fastService[RLDDIServiceCount];
    int polygons_drawn;
    RLDDIGlobalDriverData data;
};

#include "d3drlddi.h"
#include "dlist.h"

#define RLDDIService(stackp, type, arg1, arg2) \
    (*((stackp)->fastService[type].call)) \
    ((stackp)->fastService[type].driver, (type), (arg1), (arg2))

/* old macro
    (*((stackp)->top->service))((stackp)->top, (type), (arg1), (arg2))
*/

#ifdef DLL_IMPORTS_GEN
__declspec( dllimport ) int RLDDILog2[];
#else
extern int RLDDILog2[];
#endif

#ifdef _DLL
void RLDDIInit2(RLDDIMallocFn, RLDDIReallocFn, RLDDIFreeFn, RLDDIRaiseFn, RLDDIValue**, int, int);
#endif
void RLDDIInit(RLDDIMallocFn, RLDDIReallocFn, RLDDIFreeFn, RLDDIRaiseFn, RLDDIValue**, int, int);
void RLDDIPushDriver(RLDDIDriverStack* stack, RLDDIDriver* driver);
void RLDDIPopDriver(RLDDIDriverStack* stack);

HRESULT RLDDICreatePixmap(RLDDIPixmap** result,
              int width, int height, int depth);
HRESULT RLDDICreatePixmapFrom(RLDDIPixmap** result,
                  int width, int height, int depth,
                  void RLFAR* data, int bytes_per_line);
HRESULT RLDDICreatePixmapFromSurface(RLDDIPixmap** result,
                     LPDIRECTDRAWSURFACE lpDDS);
void RLDDIDestroyPixmap(RLDDIPixmap* pm);
void RLDDIPixmapFill(RLDDIPixmap* pm, unsigned long value,
             int x1, int y1, int x2, int y2);
void RLDDIPixmapCopy(RLDDIPixmap* dstpm, RLDDIPixmap* srcpm,
             int x1, int y1, int x2, int y2,
             int dstx, int dsty);
void RLDDIPixmapScale(RLDDIPixmap* dstpm, LPDDSURFACEDESC srcim,
              RLDDIValue scalex, RLDDIValue scaley,
              int x1, int y1, int x2, int y2,
              int dstx, int dsty);
HRESULT RLDDIPixmapLock(RLDDIPixmap* pm);
void RLDDIPixmapUnlock(RLDDIPixmap* pm);
void RLDDIPixmapUpdatePalette(RLDDIPixmap* pm);

RLDDIDriver*    RLDDICreateTransformDriver(int width, int height);
RLDDIDriver*    RLDDICreateRampLightingDriver(int width, int height);
RLDDIDriver*    RLDDICreateRampDriver(int width, int height);
RLDDIDriver*    RLDDICreateRGBLightingDriver(int width, int height);
RLDDIDriver*    RLDDICreateRGBDriver(int width, int height);

extern HRESULT WINAPI DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern HRESULT WINAPI DDInternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl );

/*
 * RLDDIDriverExtension codes
 */
#define RLDDIDDrawGetObjects    0x1234
#define RLDDIDDrawWinMove   0x1235

/*
 * Six standard clipping planes plus six user defined clipping planes.
 * See rl\d3d\d3d\d3dtypes.h.
 */

#define MAX_CLIPPING_PLANES 12

/* Space for vertices generated/copied while clipping one triangle */

#define MAX_CLIP_VERTICES   (( 2 * MAX_CLIPPING_PLANES ) + 3 )

/* 3 verts. -> 1 tri, 4 v -> 2 t, N vertices -> (N - 2) triangles */

#define MAX_CLIP_TRIANGLES  ( MAX_CLIP_VERTICES - 2 )

#endif /* driver.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\equates.asm ===
; $Id: equates.asm,v 1.5 1995/04/04 14:57:34 servan Exp $
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994
; Version 1.0beta2
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
;

ifdef STACK_CALL 
else
SUFFIX = 1
endif

ifdef MICROSOFT_NT
SUFFIX = 1
endif

	ifdef	SUFFIX


	else

_RLDDIhdivtab		equ RLDDIhdivtab
_RLDDIhdiv2tab		equ RLDDIhdiv2tab

 	endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\fltval.h ===
/*
 * $Id: fltval.h,v 1.7 1995/12/01 18:07:12 dave Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */

#ifndef __RLFLOAT__
#define __RLFLOAT__

/*
 * Floating point versions of fixed point math.
 */
typedef float RLDDIValue;
typedef int RLDDIFixed;

#define VAL_MAX		((RLDDIValue) 1e30)
#define VAL_MIN		((RLDDIValue) (-1e30))

/*
 * Convert a value to fixed point at given precision.
 */
#define VALTOFXP(d,prec) ((RLDDIFixed)SAFE_FLOAT_TO_INT((d) * (double)(1 << (prec))))
extern double RLDDIConvertIEEE[];
// The macro form can cause problems when used multiple times in
// a function invocation due to its use of a global
// Fortunately, inline functions work in our compiler
__inline RLDDIFixed QVALTOFXP(double d, int prec)
{
    double tmp = d+RLDDIConvertIEEE[prec];
    return *(RLDDIFixed *)&tmp;
}

/*
 * Convert from fixed point to value.
 */
#define FXPTOVAL(f,prec) ((RLDDIValue)(((double)(f)) / (double)(1 << (prec))))

/*
 * Convert from integer to fixed point.
 */
#define ITOFXP(i,prec)	((i) << (prec))

/*
 * Convert from fixed point to integer, truncating.
 */
#define FXPTOI(f,prec)	((int)((f) >> (prec)))

/*
 * Convert from fixed point to integer, rounding.
 */
#define FXPROUND(f,prec) ((int)(((f) + (1 << ((prec) - 1))) >> (prec)))

/*
 * Convert from fixed point to nearest integer greater or equal to f.
 */
#define FXPCEIL(f,prec) ((int)(((f) + (1 << (prec)) - 1) >> (prec)))

/*
 * Convert a double to fixed point at given precision.
 */
#define DTOVALP(d,prec)	((RLDDIValue) (d))

/*
 * Convert from fixed point to double.
 */
#define VALPTOD(f,prec)	((double) (f))

/*
 * Convert from integer to fixed point.
 */
#define ITOVALP(i,prec)	((RLDDIValue)(i))

/*
 * Convert from fixed point to integer, truncating.
 */
#define VALPTOI(f,prec)	((int)(f))

/*
 * Convert from fixed point to integer, rounding.
 */
#define VALPROUND(f,prec) ((int)((f) + 0.5))

/*
 * Convert between fixed point precisions.
 */
#define VALPTOVALP(f,from,to) (f)

/*
 * Increase the precision of a value.
 */
#define INCPREC(f,amount)	(f)

/*
 * Decrease the precision of a value.
 */
#define DECPREC(f,amount)	(f)

#define RLDDIFMul8(a, b)		((a) * (b))

#define RLDDIFMul12(a, b)		((a) * (b))

#define RLDDIFMul16(a, b)		((a) * (b))

#define RLDDIFMul24(a, b)		((a) * (b))

#define RLDDIFInvert12(a)		(1.0f / (a))

#define RLDDIFInvert16(a)		(1.0f / (a))

#define RLDDIFInvert24(a)		(1.0f / (a))

#define RLDDIFMulDiv(a, b, c)	((a) * (b) / (c))

#define RLDDIFDiv24(a, b)		((a) / (b))

#define RLDDIFDiv16(a, b)		((a) / (b))

#define RLDDIFDiv12(a, b)		((a) / (b))

#define RLDDIFDiv8(a, b)		((a) / (b))

/*
 * RLDDIFDiv8, checking for overflow.
 */
#define RLDDICheckDiv8(a, b)      ((a) / (b))

/*
 * RLDDIFDiv16, checking for overflow.
 */
#define RLDDICheckDiv16(a, b)	((a) / (b))

#define RLDDIGetZStep(zl, zr, zm, h3, h1) \
	(((zr - zm) * h3 - (zl - zm) * h1) / denom)

#if defined(i386)
#include <limits.h>
#define SAFE_FLOAT_TO_INT(f)	((f) > LONG_MAX				      \
				 ? LONG_MAX				      \
				 : (f) < LONG_MIN			      \
				 ? LONG_MIN				      \
				 : (RLDDIFixed)(f))
#else
#define SAFE_FLOAT_TO_INT(f)	((RLDDIFixed)(f))
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\macros.asm ===
; $Id: macros.asm,v 1.4 1995/09/27 09:26:54 james Exp $
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994
; Version 1.0beta2
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
;
;the 8086 macros...
;the general purpose macros just so you can write code more easily

        ifdef INTEL
func    macro   name
        public  name
name:
        endm
        else
func    macro   name
        public  _&name
name:                   ;lay down both labels so I have one I know will
_&name:                 ;always be available for asm to call.
        endm
        endif

push_all        macro
        irp     z,<edi,esi,edx,ecx,ebx,eax>
        push    z
        endm
        endm

pop_all         macro
        irp     z,<eax,ebx,ecx,edx,esi,edi>
        pop     z
        endm
        endm

push_m  macro   list
        irp     z,<list>
        push    z
        endm
        endm

pop_m   macro   list
        irp     z,<list>
        pop     z
        endm
        endm

byte_eax        equ     al
byte_ebx        equ     bl
byte_ecx        equ     cl
byte_edx        equ     dl

word_eax        equ     ax
word_ebx        equ     bx
word_ecx        equ     cx
word_edx        equ     dx
word_edi        equ     di
word_esi        equ     si
word_ebp        equ     bp

; Divide eax by divisor, an 8 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div8    macro   divisor
        local   divide, nodivide
        cdq
        xor     edx, eax
        sar     edx, 017H
        cmp     divisor, edx
        jg      divide
        sar     eax, 1fH
        xor     eax, 7fffffffH
        jmp     nodivide
divide:
        mov     edx, eax
        sar     edx, 018h
        shl     eax, 008h
        idiv    divisor
nodivide:
        endm

; Divide eax by divisor, an 16 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div16   macro   divisor
        local   divide, nodivide
        cdq
        xor     edx, eax
        sar     edx, 0fH
        cmp     divisor, edx
        jg      divide
        sar     eax, 1fH
        xor     eax, 7fffffffH
        jmp     nodivide
divide:
        mov     edx, eax
        sar     edx, 010h
        shl     eax, 010h
        idiv    divisor
nodivide:
        endm

ES_PREFIX       macro
    ifndef      NT
        db      26h
    endif
        endm

beginargs macro
        align   4
stack   =       4       ;return address
vars    =       0       ;no vars yet
args    =       0       ;no args yet
        endm

endargs macro
        sub     esp, vars
        endm

savereg macro   arg
        push    arg
stack   =       stack + 4
        endm

saveregs macro  arglist
        irp     z,<arglist>
        savereg z
        endm
        endm

defvar  macro   name
name    =       vars
vars    =       vars + 4
stack   =       stack + 4
        endm

defvars macro   arglist
        irp     z,<arglist>
        defvar  z
        endm
        endm

defarg  macro   name
name    =       stack + args
args    =       args + 4
        endm

defargs macro   arglist
        irp     z,<arglist>
        defarg  z
        endm
        endm

regarg  macro   name
        ifdef   STACK_CALL
        defarg  name
        else
        defvar  name
        endif
        endm

regargs macro   arglist
        irp     z,<arglist>
        regarg  z
        endm
        endm

return  macro
        ifdef   STACK_CALL
        ret
        else
        ret     args
        endif
        endm

    ifdef       BCC             ;{

beginproc macro prefix,GF,Te,Tr,name    ;{
        align   4
        ifndef  DEPTH
        display "DEPTH must be defined for modules using the beginproc macro"
        endif
        if DEPTH eq 0
prefix&name     equ     _&prefix&GF&Tr&Te&name
        else
          if DEPTH eq 8
prefix&name     equ     _&prefix&8&GF&Tr&Te&name
          else
prefix&name     equ     _&prefix&16&GF&Tr&Te&name
          endif
        endif
        public  prefix&name
prefix&name proc
        endm                    ;}

    else                        ;} ifndef BCC {

beginproc macro prefix,GF,Z,Te,Tr,name  ;{
        align   4
        ifndef  DEPTH
        display "DEPTH must be defined for modules using the beginproc macro"
        endif
        ifdef   STACK_CALL      ;{
        if DEPTH eq 0
prefix&name     equ     prefix&GF&Z&Tr&Te&name
        else
            if DEPTH eq 8
prefix&name     equ     prefix&8_&GF&Z&Tr&Te&name
            else
prefix&name     equ     prefix&16_&GF&Z&Tr&Te&name
            endif
        endif
        else                    ;} else {
        if DEPTH eq 0
prefix&name     equ     prefix&GF&Tr&Te&name&_
        else
            if DEPTH eq 8
prefix&name     equ     prefix&8&GF&Tr&Te&name&_
            else
prefix&name     equ     prefix&16&GF&Tr&Te&name&_
            endif
        endif
        endif                   ;}
        public  prefix&name
prefix&name proc
        endm                    ;}
    endif               ;}

    ifdef       BCC     ;{
endproc macro prefix,name       ;{
        ifndef  DEPTH
        display "DEPTH must be defined for modules using the endproc macro"
        endif
        if      DEPTH eq 8
_&prefix&name endp
        else
_&prefix&name endp
        endif
        endm                    ;}

    else                ;} ifndef BCC {

endproc macro prefix,GF,Z,Te,Tr,name    ;{
        ifndef  DEPTH
        display "DEPTH must be defined for modules using the endproc macro"
        endif
        ifdef   STACK_CALL
            if  DEPTH eq 0
prefix&GF&Tr&Te&name endp
            else
            if  DEPTH eq 8
prefix&8_&GF&Z&Tr&Te&name endp
            else
prefix&16_&GF&Z&Tr&Te&name endp
            endif
            endif
        else
            if  DEPTH eq 0
prefix&GF&Tr&Te&name&_ endp
            else
            if  DEPTH eq 8
prefix&8&GF&Tr&Te&name&_ endp
            else
prefix&16&GF&Tr&Te&name&_ endp
            endif
            endif
        endif
        endm                    ;}

    endif               ;}

; ************************************************************************
itoval  macro   reg
        shl     reg,10h
        endm

FDUP    macro
        fld     st(0)
        endm

FDROP   macro
        fstp    st(0)
        endm

FRECIPROCAL     macro
        fld1
        fdivrp  st(1),st
        endm

FCOMXX macro   v
      fcom    v
      fnstsw  ax
      sahf
      endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\makefile.inc ===
$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): ..\offs_acp.acp \
        ..\..\..\inc\span.h

##############################################################################
# 8
##############################################################################

$(GENTGT)\zramp8f.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp8ft.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp8g.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp8gt.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp8gtg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\zramp8ftg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\zrmfp8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zrmfpg8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\zrmgp8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zrmgpg8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@

##########

$(GENTGT)\gramp8f.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp8ft.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp8g.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp8gt.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp8gtg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\gramp8ftg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\grmfp8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\grmfpg8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\grmgp8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\grmgpg8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@


##############################################################################
# 16
##############################################################################

$(GENTGT)\zramp16f.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp16ft.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp16g.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp16gt.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp16gtg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\zramp16ftg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\zrmfp16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zrmfpg16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\zrmgp16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zrmgpg16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@

##########

$(GENTGT)\gramp16f.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp16ft.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp16g.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp16gt.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp16gtg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\gramp16ftg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\grmfp16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\grmfpg16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\grmgp16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\grmgpg16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@


##############################################################################
# apparently never compiled or tested 24 or 32 bit versions of fast fill
# routines under DX5, don't do it now!
##############################################################################
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3di.hpp>
#include <haldrv.hpp>

#include <dpf.h>

#include <rast.h>

#include "lists.h"
#include "rampold.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\rampold.h ===
//----------------------------------------------------------------------------
//
// rampold.h
//
// Structures which define the interface to the old ramp routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPOLD_H_
#define _RAMPOLD_H_


#define ROB_DEPTH_NUM 2
#define ROB_RENDER_Z_NUM 2
#define ROB_RENDER_GOURAUD_NUM 2
#define ROB_RENDER_TEXTURE_NUM 3
#define ROB_RENDER_TRANS_NUM 2

typedef struct tagRAMPOLDBEADS
{
    PFNRAMPOLD pfnRampOld[ROB_DEPTH_NUM][ROB_RENDER_Z_NUM][ROB_RENDER_GOURAUD_NUM][ROB_RENDER_TEXTURE_NUM][ROB_RENDER_TRANS_NUM];
} RAMPOLDBEADS, *PRAMPOLDBEADS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\osdep.h ===
/*
 * $Id: osdep.h,v 1.6 1995/07/21 12:46:14 dfr Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */


/* Check that the programmer gives at least one useable definition */
#define NO_MACHINE


#ifdef WIN32

#define MAXPATH    256
#define PATHSEP    ';'
#define FILESEP    '\\'
/*
#define RLINLINE   __inline
*/
#define RLINLINE  
#undef NO_MACHINE
#define DEFAULT_GAMMA   DTOVAL(1.4)

#endif /* WIN32 */

#ifdef __psx__

#define MAXPATH    256
#define PATHSEP    ';'
#define FILESEP    '\\'
#define RLINLINE   
#define FIXED_POINT_API
#undef NO_MACHINE

#endif /* PSX */


#if defined(DOS) || defined(__WINDOWS_386__)

#define MAXPATH    256
#define PATHSEP    ';'
#define FILESEP    '\\'
#define RLINLINE   
#define DEFAULT_GAMMA   DTOVAL(1.4)
#undef NO_MACHINE

#endif /* DOS */


#ifdef MAC

#define MAXPATH 1024
#define FILESEP ':'
#define PATHSEP '\0'
#define BIG_ENDIAN
#define DONT_UNROLL
#undef NO_MACHINE
#define RLINLINE inline

#endif /* MAC */

#ifdef POWERMAC

#define MAXPATH 1024
#define FILESEP ':'
#define PATHSEP '\0'
#define BIG_ENDIAN
#define DONT_UNROLL
#undef NO_MACHINE
#define RLINLINE inline

#endif /* POWERMAC */


#ifdef __FreeBSD__

#define MAXPATH    1024
#define PATHSEP    ':'
#define FILESEP    '/'
#define RLINLINE   
#define DEFAULT_GAMMA   DTOVAL(1.4)
#undef NO_MACHINE

#endif /* __FreeBSD__ */


#if defined(sun) || defined(sgi)

#define MAXPATH    1024
#define PATHSEP    ':'
#define FILESEP    '/'
#define RLINLINE   
#define DEFAULT_GAMMA   DTOVAL(2.2)
#define BIG_ENDIAN
#undef NO_MACHINE

#endif /* sun */


#ifdef NO_MACHINE
#error There appears to be no machine defined...
#endif

#ifdef FIXED_POINT_API

#ifdef USE_FLOAT
#define APITOVAL(x)     FXTOVAL(x)
#define VALTOAPI(x)     VALTOFX(x)
#else
#define APITOVAL(x)     (x)
#define VALTOAPI(x)     (x)
#endif

#else

#ifdef USE_FLOAT
#define APITOVAL(x)     (x)
#define VALTOAPI(x)     (x)
#else
#define APITOVAL(x)     DTOVAL(x)
#define VALTOAPI(x)     VALTOD(x)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\sources.inc ===
TARGETNAME=d3dramp
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLDEF=..\$(TARGETNAME).def

INCLUDES = ..;$(INCLUDES);$(O)

SOURCES = \
        ..\dmath.c \
        ..\rampold.cpp \
        ..\d3dramp.rc

NTTARGETFILE0 = \
        $(O)\offs_acp.$(ASM_INCLUDE_SUFFIX)


PRECOMPILED_INCLUDE = ..\pch.cpp

BINPLACE_PLACEFILE = ..\rampold.dir
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\offsets.asm ===
include offs_acp.inc

RLDDIRampDriver_map     equ     RCTX_pRampMap
RLDDIGenRasDriver_fill_params   equ     RCTX_pFillParams
RLDDIGenRasDriver_pm    equ     RCTX_pSurfaceBits
RLDDIGenRasDriver_zb    equ     RCTX_pZBits
RLDDIGenRasDriver_texture       equ     RCTX_pTexture
RLDDIGenRasFillParams_wrap_u    equ     FPMS_dwWrapU
RLDDIGenRasFillParams_wrap_v    equ     FPMS_dwWrapV
RLDDIGenRasFillParams_culling_ccw       equ     FPMS_dwCullCCW
RLDDIGenRasFillParams_culling_cw        equ     FPMS_dwCullCW

RLDDITexture_transparent      equ     STEX_TransparentColor
RLDDITexture_u_shift    equ     STEX_iShiftU
RLDDITexture_v_shift    equ     STEX_iShiftV
D3DINSTRUCTION_wCount   equ     02h
D3DINSTRUCTION_bSize    equ     01h
D3DTLVERTEX_sx  equ     00h
D3DTLVERTEX_sy  equ     04h
D3DTLVERTEX_sz  equ     08h
D3DTLVERTEX_rhw       equ     0ch
D3DTLVERTEX_color       equ     010h
D3DTLVERTEX_specular    equ     014h
D3DTLVERTEX_tu  equ     018h
D3DTLVERTEX_tv  equ     01ch
D3DTRIANGLE_v1  equ     00h
D3DTRIANGLE_v2  equ     02h
D3DTRIANGLE_v3  equ     04h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\rampold.cpp ===
//----------------------------------------------------------------------------
//
// rampold.cpp
//
// Entry points for DX3/DX5 ramp assembly routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#ifdef _X86_

#ifdef __cplusplus
  extern "C" {
#endif

void __cdecl RLDDIR8_FTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR8_GTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR8_FZTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FZTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FZGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FZPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FZGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR8_GZTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GZTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GZGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GZPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GZGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR16_FTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR16_GTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR16_FZTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FZTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FZGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FZPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FZGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR16_GZTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GZTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GZGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GZPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GZGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR16_GZTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

#ifdef __cplusplus
  }
#endif

//----------------------------------------------------------------------------
//
// RampOldTri
//
// Entry point for DX3/DX5 ramp assembly routines.
//
//----------------------------------------------------------------------------

HRESULT RampOldTri(PD3DI_RASTCTX pCtx,
                   LPD3DTLVERTEX pV0,
                   LPD3DTLVERTEX pV1,
                   LPD3DTLVERTEX pV2)
{
    HRESULT hr;

    hr = D3D_OK;

    D3DINSTRUCTION ins;
    ins.bOpcode = D3DOP_TRIANGLE;
    ins.bSize = sizeof(D3DTRIANGLE);
    ins.wCount = 1;

    D3DTRIANGLE tri;
    tri.v1 = 0;
    tri.v2 = 1;
    tri.v3 = 2;

    D3DTLVERTEX TLVert[3];
    TLVert[0] = *pV0;
    TLVert[1] = *pV1;
    TLVert[2] = *pV2;

    // Lego Island fix
    // 0x3f7ffe00 == 1 - 2/0xffff or 2 Z units from the maximum Z.  Integer math is faster
    // and doesn't cause FP lib linker issues with the assembly.
    INT32* pZ;
    pZ = (INT32*)&TLVert[0].sz;
    *pZ = (*pZ > 0x3f7ffe00) ? (0x3f7ffe00) : (*pZ);
    pZ = (INT32*)&TLVert[1].sz;
    *pZ = (*pZ > 0x3f7ffe00) ? (0x3f7ffe00) : (*pZ);
    pZ = (INT32*)&TLVert[2].sz;
    *pZ = (*pZ > 0x3f7ffe00) ? (0x3f7ffe00) : (*pZ);

    pCtx->pFillParams = &pCtx->FillParams;
    pCtx->pFillParams->dwWrapU = pCtx->pdwWrap[0] & D3DWRAP_U;
    pCtx->pFillParams->dwWrapV = pCtx->pdwWrap[0] & D3DWRAP_V;
    pCtx->pFillParams->dwCullCCW = (pCtx->pdwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW);
    pCtx->pFillParams->dwCullCW =  (pCtx->pdwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CW);

    pCtx->pfnRampOld(pCtx, &ins, TLVert, &tri);

    return hr;
}

// resurrect this if DX5 ramp assembly must be called with a triangle list for performance
// reasons.
#if 0
HRESULT RampOldTriList(PD3DI_RASTCTX pCtx, DWORD dwStride, D3DTLVERTEX* pVtx, WORD cPrims, D3DTRIANGLE* pTri)
{
    HRESULT hr;

    hr = D3D_OK;

    D3DINSTRUCTION ins;
    ins.bOpcode = D3DOP_TRIANGLE;
    ins.bSize = sizeof(D3DTRIANGLE);
    ins.wCount = cPrims;

    DDASSERT(dwStride == sizeof(D3DTLVERTEX));

    pCtx->pFillParams = &pCtx->FillParams;
    pCtx->pFillParams->dwWrapU = pCtx->pdwWrap[0] & D3DWRAP_U;
    pCtx->pFillParams->dwWrapV = pCtx->pdwWrap[0] & D3DWRAP_V;
    pCtx->pFillParams->dwCullCCW = (pCtx->pdwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW);
    pCtx->pFillParams->dwCullCW =  (pCtx->pdwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CW);

    pCtx->pfnRampOld(pCtx, &ins, pVtx, pTri);

    return hr;
}
#endif // RampOldTriList

//
//  [ROB_DEPTH_NUM]
//  [ROB_RENDER_Z_NUM]
//  [ROB_RENDER_GOURAUD_NUM]
//  [ROB_RENDER_TEXTURE_NUM][ROB_RENDER_TRANS_NUM]
RAMPOLDBEADS g_RampOld_BeadTbl =
{
    RLDDIR8_FTriangle, NULL,    RLDDIR8_FTTriangle, RLDDIR8_FGTTriangle,    RLDDIR8_FPTriangle, RLDDIR8_FGPTriangle,
    RLDDIR8_GTriangle, NULL,    RLDDIR8_GTTriangle, RLDDIR8_GGTTriangle,    RLDDIR8_GPTriangle, RLDDIR8_GGPTriangle,

    RLDDIR8_FZTriangle, NULL,   RLDDIR8_FZTTriangle, RLDDIR8_FZGTTriangle,  RLDDIR8_FZPTriangle, RLDDIR8_FZGPTriangle,
    RLDDIR8_GZTriangle, NULL,   RLDDIR8_GZTTriangle, RLDDIR8_GZGTTriangle,  RLDDIR8_GZPTriangle, RLDDIR8_GZGPTriangle,

    RLDDIR16_FTriangle, NULL,   RLDDIR16_FTTriangle, RLDDIR16_FGTTriangle,  RLDDIR16_FPTriangle, RLDDIR16_FGPTriangle,
    RLDDIR16_GTriangle, NULL,   RLDDIR16_GTTriangle, RLDDIR16_GGTTriangle,  RLDDIR16_GPTriangle, RLDDIR16_GGPTriangle,

    RLDDIR16_FZTriangle, NULL,  RLDDIR16_FZTTriangle, RLDDIR16_FZGTTriangle,RLDDIR16_FZPTriangle, RLDDIR16_FZGPTriangle,
    RLDDIR16_GZTriangle, NULL,  RLDDIR16_GZTTriangle, RLDDIR16_GZGTTriangle,RLDDIR16_GZPTriangle, RLDDIR16_GZGPTriangle,

};

#else // _X86_

HRESULT RampOldTri(PD3DI_RASTCTX pCtx,
                   LPD3DTLVERTEX pV0,
                   LPD3DTLVERTEX pV1,
                   LPD3DTLVERTEX pV2)
{
    return D3D_OK;
}

// since all ramp beads are NULL, will never call RampOldTri
RAMPOLDBEADS g_RampOld_BeadTbl = { NULL };


#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\rlreg.h ===
/*
 * $Id: rlreg.h,v 1.1 1995/10/10 11:18:16 sjl Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 2.0
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */

#ifndef _RLREG_H_
#define _RLREG_H_

#include <objbase.h>

#define RESPATH    "Software\\Microsoft\\Direct3D\\Drivers"
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

typedef struct _RLDDIRegDriver {
    char name[256];
    char base[256];
    char description[512];
    GUID guid;
} RLDDIRegDriver;

typedef struct _RLDDIRegistry {
    char defaultDriver[256];
    int numDrivers;
    int onlySoftwareDrivers;
    RLDDIRegDriver* drivers;
} RLDDIRegistry;

extern HRESULT RLDDIBuildRegistry(RLDDIRegistry** lplpReg, BOOL bEnumMMXDevice);
extern HRESULT RLDDIGetDriverName(REFIID lpGuid, char** lpBase, BOOL bEnumMMXDevice); /* get name from registry */

#endif _RLREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\makefile.inc ===
$(GENTGT)\rbeadtbl.cpp: ..\rbeadtbl.mcp $(RASTROOT)\inc\rampbead.mh $(RAST_STD_M4)

$(GENTGT)\rloop.cpp: ..\rloop.mcp $(RASTROOT)\inc\rampbead.mh ..\rtexaddr.mh ..\ramppix.mh ..\rtexread.mh $(RAST_STD_M4)

$(GENTGT)\rrampgen.cpp: ..\rrampgen.mcp $(RASTROOT)\inc\rampbead.mh ..\rtexaddr.mh ..\ramppix.mh $(RAST_STD_M4)

$(GENTGT)\rrampcpy.cpp: ..\rrampcpy.mcp $(RASTROOT)\inc\rampbead.mh ..\rtexaddr.mh ..\ramppix.mh $(RAST_STD_M4)

$(GENTGT)\rtexread.cpp: ..\rtexread.mcp $(RASTROOT)\inc\rampbead.mh ..\rtexaddr.mh ..\rtexread.mh $(RAST_STD_M4)

$(GENTGT)\rloop_mh.h: ..\rloop_mh.mh $(RASTROOT)\inc\rampbead.mh $(RAST_STD_M4)

$(GENTGT)\rtrd_mh.h: ..\rtrd_mh.mh $(RASTROOT)\inc\rampbead.mh ..\rtexread.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): ..\offs_acp.acp \
        ..\..\..\inc\span.h

$(GENTGT)\raloop.asm: ..\raloop.mas $(RASTROOT)\inc\rampbead.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\i386src.inc ===
i386_SOURCES = $O\raloop.asm
NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES)\
    $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3di.hpp>
#include <haldrv.hpp>

#include <dpf.h>

#include <rast.h>
#include "rspnutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\sources.inc ===
TARGETNAME = rrmpspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;..\..\refrast;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

#386_OPTIMIZATION = /Oxt /G5

SOURCES = \
        $O\rbeadtbl.cpp\
        $O\rloop.cpp\
        $O\rrampcpy.cpp\
        $O\rrampgen.cpp\
        ..\rspnpars.cpp\
        $O\rtexread.cpp

NTTARGETFILE0 = \
        $O\rbeadtbl.cpp\
        $O\rloop.cpp\
        $O\rloop_mh.h\
        $O\rrampcpy.cpp\
        $O\rrampgen.cpp\
        $O\rtexread.cpp\
        $O\rtrd_mh.h

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\rspnpars.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "rloop_mh.h"

// #define SPAN_HISTOGRAM

#ifdef SPAN_HISTOGRAM
UINT32 uSpanHist[16];
#endif

//-----------------------------------------------------------------------------
//
// RenderSpans_Any
//
// All mode general span routine.
//
//-----------------------------------------------------------------------------
HRESULT Ramp_RenderSpans_Any(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    if (pCtx->pTexture[0])
    {
        pCtx->pTexture[0]->pRampmap = pCtx->pTexRampMap;
    }
    
    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
#ifdef SPAN_HISTOGRAM
            INT iBucket;

            for (iBucket = 0;
                 iBucket < sizeof(uSpanHist)/sizeof(uSpanHist[0]);
                 iBucket++)
            {
                if (pS->uPix <= (1 << iBucket))
                {
                    uSpanHist[iBucket]++;
                    break;
                }
            }
#endif
            
            pCtx->pfnBegin(pCtx, pP, pS);

            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\rmono.h ===
//----------------------------------------------------------------------------
//
// rmono.h
//
// Declarations of all monolithic ramp routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RMONO_H_
#define _RMONO_H_

void Ramp_Mono_Modulate(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                        PD3DI_RASTSPAN pS);
void Ramp_Mono_Copy_8(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                    PD3DI_RASTSPAN pS);
void Ramp_Mono_Copy_16(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                    PD3DI_RASTSPAN pS);

#endif // #ifndef _RMONO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\rspnutil.h ===
//----------------------------------------------------------------------------
//
// rspnutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

extern UINT16 g_uRampDitherTable[16];

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

//-----------------------------------------------------------------------------
//
// imul32h_s20
//
// Returns (x*y)>>20
//
//-----------------------------------------------------------------------------
inline INT32 imul32h_s20(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        shrd eax, edx, 20
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 20);
#endif
}

#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\cppsrc.inc ===
O_FILES = $O\attrscpp.cpp $O\tstpcpp.cpp
$(TARGET_DIRECTORY)_SOURCES = $(O_FILES) ..\walkcpp.cpp
NTTARGETFILE0 = $(NTTARGETFILE0) $(O_FILES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\i386src.inc ===
i386_SOURCES = $O\attrsx86.asm $O\tstpx86.asm $O\walkx86.asm
NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES) \
        $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\line.cpp ===
//----------------------------------------------------------------------------
//
// line.cpp
//
// Line processing.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// LinePatternStateMachine
//
// Runs the line pattern state machine and returns TRUE if the pixel is to be
// drawn, false otherwise.
//
//----------------------------------------------------------------------------

static inline BOOL LinePatternStateMachine(WORD wRepeatFactor, WORD wLinePattern, WORD& wRepeati, WORD& wPatterni)
{
    if (wRepeatFactor == 0)
    {
        return TRUE;
    }
    WORD wBit = (wLinePattern >> wPatterni) & 1;
    if (++wRepeati >= wRepeatFactor)
    {
        wRepeati = 0;
        wPatterni = (wPatterni+1) & 0xf;
    }
    return (BOOL)wBit;
}

#define CLAMP_COLOR(fVal, uVal) \
    if (FLOAT_LTZ(fVal))        \
    {                           \
        uVal = 0;               \
    }                           \
    else                        \
    {                           \
        if (uVal > 0xffff)      \
        {                       \
            uVal = 0xffff;      \
        }                       \
    }                           \

#define CLAMP_Z(fVal, uVal)     \
    if (FLOAT_LTZ(fVal))        \
    {                           \
        uVal = 0;               \
    }                           \

//----------------------------------------------------------------------------
//
// ClampPixel
//
// Clamp color, specular and z(if any) of a pixel. Right now, it's done for 
// first and last pixel of a line only.
//
//----------------------------------------------------------------------------
inline void
ClampPixel(PATTRSET pAttrs, PD3DI_RASTSPAN pSpan)
{
    CLAMP_COLOR(pAttrs->fB, pSpan->uB);
    CLAMP_COLOR(pAttrs->fG, pSpan->uG);
    CLAMP_COLOR(pAttrs->fR, pSpan->uR);
    CLAMP_COLOR(pAttrs->fA, pSpan->uA);
    CLAMP_COLOR(pAttrs->fBS, pSpan->uBS);
    CLAMP_COLOR(pAttrs->fGS, pSpan->uGS);
    CLAMP_COLOR(pAttrs->fRS, pSpan->uRS);
    CLAMP_Z(pAttrs->fZ, pSpan->uZ);
}

//----------------------------------------------------------------------------
//
// WalkLinePattern
//
// Walks a line and generates the pixels touched according to the pattern.
// If wRepeatFactor >= 1, we are patterning, otherwise, we are not
//
//----------------------------------------------------------------------------

HRESULT
WalkLinePattern(PSETUPCTX pStpCtx, WORD wRepeatFactor, WORD wLinePattern)
{
    HRESULT hr;
    UINT uSpansAvail;
    PD3DI_RASTSPAN pSpan;
    WORD wRepeati = 0;
    WORD wPatterni = 0;
    BOOL bFirst = TRUE;

    RSASSERT(pStpCtx->cLinePix > 0);

    hr = D3D_OK;
    uSpansAvail = 0;

    RSASSERT((pStpCtx->uFlags & PRIMSF_LOD_USED) == 0);
#ifdef PWL_FOG
    pStpCtx->uPwlFlags = PWL_NO_NEXT_FOG;
#endif

    for (;;)
    {
        if (pStpCtx->iX >= pStpCtx->pCtx->Clip.left &&
            pStpCtx->iX < pStpCtx->pCtx->Clip.right &&
            pStpCtx->iY >= pStpCtx->pCtx->Clip.top &&
            pStpCtx->iY < pStpCtx->pCtx->Clip.bottom)
        {
            if (LinePatternStateMachine(wRepeatFactor, wLinePattern, wRepeati, wPatterni))
            {
                if (uSpansAvail == 0)
                {
                    uSpansAvail = pStpCtx->cLinePix;
                    hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                    if (hr != D3D_OK)
                    {
                        // uSpansAvail is set to zero on failure.
                        goto EH_Exit;
                    }
                }
                else
                {
                    pSpan++;
                }
                uSpansAvail--;
                pStpCtx->pPrim->uSpans++;

                pSpan->uPix = 1;
                pSpan->uX = (UINT16)pStpCtx->iX;
                pSpan->uY = (UINT16)pStpCtx->iY;

                pStpCtx->pfnFillSpanAttrs(&pStpCtx->Attr, pSpan, pStpCtx, 1);
                // Clamp first/last pixel
                if (bFirst || pStpCtx->cLinePix == 1)
                {
                    bFirst = FALSE;
                    ClampPixel(&pStpCtx->Attr, pSpan);
                }
            }
        }

        if (--pStpCtx->cLinePix == 0)
        {
            break;
        }

#ifdef VERBOSE_LINES
        RSDPF(("  %4d,%4d: %10d %11d => ",
               pStpCtx->iX, pStpCtx->iY,
               pStpCtx->iLineFrac, pStpCtx->iLineFrac + pStpCtx->iDLineFrac));
#endif

        pStpCtx->iLineFrac += pStpCtx->iDLineFrac;
        if (pStpCtx->iLineFrac < 0)
        {
            pStpCtx->iLineFrac &= 0x7fffffff;

            pStpCtx->iX += pStpCtx->iDXCY;
            pStpCtx->iY += pStpCtx->iDYCY;

            pStpCtx->DAttrDMajor.ipSurface = pStpCtx->DAttrCY.ipSurface;
            pStpCtx->DAttrDMajor.ipZ = pStpCtx->DAttrCY.ipZ;
        }
        else
        {
            pStpCtx->iX += pStpCtx->iDXNC;
            pStpCtx->iY += pStpCtx->iDYNC;

            pStpCtx->DAttrDMajor.ipSurface = pStpCtx->DAttrNC.ipSurface;
            pStpCtx->DAttrDMajor.ipZ = pStpCtx->DAttrNC.ipZ;
        }

#ifdef VERBOSE_LINES
        RSDPFM((DBG_MASK_FORCE | DBG_MASK_NO_PREFIX, "%4d,%4d: %10d\n",
               pStpCtx->iX, pStpCtx->iY,
               pStpCtx->iLineFrac));
#endif

        pStpCtx->pfnAddAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDMajor, pStpCtx);
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Line
//
// Provides a line for processing.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Line(LPD3DTLVERTEX pV0,
                    LPD3DTLVERTEX pV1,
                    LPD3DTLVERTEX pFlatVtx)
{
    HRESULT hr;

    hr = D3D_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != D3D_OK)
    {
        return hr;
    }
    hr = ValidateVertex(pV1);
    if (hr != D3D_OK)
    {
        return hr;
    }
#endif

    // Clear per-line flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | LNF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X\n",
            m_uPpFlags, m_StpCtx.uFlags));

    RSDPFM((RSM_LINES, "Line\n"));
    RSDPFM((RSM_LINES, "  V0 (%f,%f,%f)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ));
    RSDPFM((RSM_LINES, "  V1 (%f,%f,%f)\n",
            pV1->dvSX, pV1->dvSY, pV1->dvSZ));

    // Remember flat color controlling vertex for setup.
    m_StpCtx.pFlatVtx = pFlatVtx;

    if (LineSetup(pV0, pV1))
    {
        // Compute initial buffer pointers for the scanline.
        m_StpCtx.Attr.pSurface = m_StpCtx.pCtx->pSurfaceBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;
        if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            m_StpCtx.Attr.pZ = m_StpCtx.pCtx->pZBits +
                m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
                m_StpCtx.iY * m_StpCtx.pCtx->iZStride;
        }

        // Line walking only generates single-pixel spans so
        // the prim deltas are unused.  Therefore, line spans
        // are simply added to whatever primitive happens to
        // be sitting in the buffer.

        hr = AppendPrim();
        if (hr != D3D_OK)
        {
            return hr;
        }

        union
        {
            D3DLINEPATTERN LPat;
            DWORD dwLPat;
        } LinePat;
        LinePat.dwLPat = m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_LINEPATTERN];
        hr = WalkLinePattern(&m_StpCtx, LinePat.LPat.wRepeatFactor, LinePat.LPat.wLinePattern);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\buffer.cpp ===
//----------------------------------------------------------------------------
//
// buffer.cpp
//
// PrimProcessor buffering methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

// Define to use new/delete instead of VirtualAlloc/VirtualFree.
#if 0
#define USE_CPP_HEAP
#endif

// Define to show FP exceptions.
#if 0
#define UNMASK_EXCEPTIONS
#endif

//----------------------------------------------------------------------------
//
// PrimProcessor::PrimProcessor
//
// Initializes a triangle processor to an invalid state.
//
//----------------------------------------------------------------------------

PrimProcessor::PrimProcessor(void)
{
    // Zero everything to NULL initial pointers and eliminate FP garbage.
    memset(this, 0, sizeof(PrimProcessor));

    m_StpCtx.PrimProcessor = (PVOID)this;

    // Initialize to values that will force a validation.
    // ATTENTION - Default to normalizing RHW.  This is a performance hit
    // and should be removed if possible.
    m_uPpFlags = PPF_STATE_CHANGED | PPF_NORMALIZE_RHW;
    m_PrimType = D3DPT_FORCE_DWORD;
    m_VertType = RAST_FORCE_DWORD;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Initialize
//
// Initializes the triangle processor to an active state.
//
//----------------------------------------------------------------------------

#define CACHE_LINE 32
#define BUFFER_SIZE 4096
// Uncomment to force a flush every span for debug purposes
//#define BUFFER_SIZE ((8 * sizeof(D3DI_RASTSPAN)) + sizeof(D3DI_RASTPRIM))

HRESULT
PrimProcessor::Initialize(void)
{
    HRESULT hr;

    // Assert that both RASTPRIM and RASTSPAN are multiples of the cache
    // line size so that everything in the buffer stays cache aligned.
    RSASSERT((sizeof(D3DI_RASTPRIM) & (CACHE_LINE - 1)) == 0 &&
             (sizeof(D3DI_RASTSPAN) & (CACHE_LINE - 1)) == 0);

#ifdef USE_CPP_HEAP
    m_pBuffer = new UINT8[BUFFER_SIZE];
#else
    // Get a page-aligned buffer.
    m_pBuffer = (PUINT8)
        VirtualAlloc(NULL, BUFFER_SIZE,
                     MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
#endif
    if (m_pBuffer == NULL)
    {
        return RSHRCHK(E_OUTOFMEMORY);
    }

    m_pBufferEnd = m_pBuffer+BUFFER_SIZE;

#ifdef USE_CPP_HEAP
    // Compute cache-line aligned start in the buffer.  Formulated
    // somewhat oddly to avoid casting a complete pointer to a DWORD and
    // back.
    m_pBufferStart = m_pBuffer +
        ((CACHE_LINE - ((UINT)m_pBuffer & (CACHE_LINE - 1))) &
         (CACHE_LINE - 1));
#else
    // Page aligned memory should be cache aligned.
    RSASSERT(((UINT_PTR)m_pBuffer & (CACHE_LINE - 1)) == 0);
    m_pBufferStart = m_pBuffer;
#endif

    m_pCur = m_pBufferStart;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::~PrimProcessor
//
//----------------------------------------------------------------------------

PrimProcessor::~PrimProcessor(void)
{
#ifdef USE_CPP_HEAP
    delete m_pBuffer;
#else
    if (m_pBuffer != NULL)
    {
        VirtualFree(m_pBuffer, 0, MEM_RELEASE);
    }
#endif
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ResetBuffer
//
// Initialize buffer pointers to an empty state.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::ResetBuffer(void)
{
    m_pCur = m_pBufferStart;
    m_StpCtx.pPrim = NULL;
    m_pOldPrim = NULL;
}

//----------------------------------------------------------------------------
//
// DumpPrims
//
// Debugging function to dump primitives sent to the span renderer.
//
//----------------------------------------------------------------------------

#if DBG
void
DumpPrims(PSETUPCTX pStpCtx)
{
    PD3DI_RASTPRIM pPrim;
    UINT uOldFlags;

    uOldFlags = RSGETFLAGS(DBG_OUTPUT_FLAGS);
    RSSETFLAGS(DBG_OUTPUT_FLAGS, uOldFlags | DBG_OUTPUT_ALL_MATCH);

    for (pPrim = pStpCtx->pCtx->pPrim; pPrim != NULL; pPrim = pPrim->pNext)
    {
        RSDPFM((RSM_BUFPRIM, "Prim at %p, %d spans at %p\n",
                pPrim, pPrim->uSpans, pPrim+1));
        RSDPFM((RSM_BUFPRIM | RSM_OOW, "  DOoWDX %X (%f)\n",
                pPrim->iDOoWDX, (FLOAT)pPrim->iDOoWDX / OOW_SCALE));

        if ((RSGETFLAGS(DBG_OUTPUT_MASK) & RSM_BUFSPAN) ||
            (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                           RSU_CHECK_SPAN_EDGES)))
        {
            PD3DI_RASTSPAN pSpan;
            UINT16 i;

            pSpan = (PD3DI_RASTSPAN)(pPrim+1);
            for (i = 0; i < pPrim->uSpans; i++)
            {
                RSDPFM((RSM_BUFSPAN,
                        "  Span at (%d,%d), pix %c%d, S %p Z %p\n",
                        pSpan->uX, pSpan->uY,
                        (pPrim->uFlags & D3DI_RASTPRIM_X_DEC) ? '-' : '+',
                        pSpan->uPix, pSpan->pSurface, pSpan->pZ));

                if (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                                  RSU_CHECK_SPAN_EDGES))
                {
                    PUINT16 pPix;

                    pPix = (PUINT16)pSpan->pSurface;
                    if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_CHECK_SPAN_EDGES)
                    {
                        if (*pPix != 0)
                        {
                            RSDPF(("  Overwrite at %p: %X\n", pPix, *pPix));
                        }
                    }
                    if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_MARK_SPAN_EDGES)
                    {
                        *pPix = 0xffff;
                    }

                    if (pSpan->uPix > 1)
                    {
                        if (pPrim->uFlags & D3DI_RASTPRIM_X_DEC)
                        {
                            pPix = (PUINT16)pSpan->pSurface -
                                (pSpan->uPix - 1);
                        }
                        else
                        {
                            pPix = (PUINT16)pSpan->pSurface +
                                (pSpan->uPix - 1);
                        }

                        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_CHECK_SPAN_EDGES)
                        {
                            if (*pPix != 0)
                            {
                                RSDPF(("  Overwrite at %p: %X\n",
                                       pPix, *pPix));
                            }
                        }
                        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_MARK_SPAN_EDGES)
                        {
                            *pPix = 0xffff;
                        }
                    }
                }

                FLOAT fZScale;
                if (pStpCtx->pCtx->iZBitCount == 16)
                {
                    fZScale = Z16_SCALE;
                }
                else
                {
                    fZScale = Z32_SCALE;
                }
                RSDPFM((RSM_BUFSPAN | RSM_Z,
                        "    Z %X (%f)\n",
                        pSpan->uZ, (FLOAT)pSpan->uZ / fZScale));

                RSDPFM((RSM_BUFSPAN | RSM_DIFF,
                        "    D %X,%X,%X,%X (%f,%f,%f,%f)\n",
                        pSpan->uB, pSpan->uG, pSpan->uR, pSpan->uA,
                        (FLOAT)pSpan->uB / COLOR_SCALE,
                        (FLOAT)pSpan->uG / COLOR_SCALE,
                        (FLOAT)pSpan->uR / COLOR_SCALE,
                        (FLOAT)pSpan->uA / COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_SPEC,
                        "    S %X,%X,%X (%f,%f,%f)\n",
                        pSpan->uBS, pSpan->uGS, pSpan->uRS,
                        (FLOAT)pSpan->uBS / COLOR_SCALE,
                        (FLOAT)pSpan->uGS / COLOR_SCALE,
                        (FLOAT)pSpan->uRS / COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_DIDX,
                        "    I %X,%X (%f,%f)\n",
                        pSpan->iIdx, pSpan->iIdxA,
                        (FLOAT)pSpan->iIdx / INDEX_COLOR_SCALE,
                        (FLOAT)pSpan->iIdxA / INDEX_COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_OOW,
                        "    OoW %X (%f), W %X (%f)\n",
                        pSpan->iOoW, (FLOAT)pSpan->iOoW / OOW_SCALE,
                        pSpan->iW, (FLOAT)pSpan->iW / W_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_LOD,
                        "    LOD %X (%f), DLOD %X (%f)\n",
                        pSpan->iLOD, (FLOAT)pSpan->iLOD / LOD_SCALE,
                        pSpan->iDLOD, (FLOAT)pSpan->iDLOD / LOD_SCALE));

                if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
                {
                    RSDPFM((RSM_BUFSPAN | RSM_TEX1,
                            "    PTex1 %X,%X (%f,%f) (%f,%f)\n",
                            pSpan->iUoW1, pSpan->iVoW1,
                            (FLOAT)pSpan->iUoW1 / TEX_SCALE,
                            (FLOAT)pSpan->iVoW1 / TEX_SCALE,
                            ((FLOAT)pSpan->iUoW1 * OOW_SCALE) /
                            (TEX_SCALE * (FLOAT)pSpan->iOoW),
                            ((FLOAT)pSpan->iVoW1 * OOW_SCALE) /
                            (TEX_SCALE * (FLOAT)pSpan->iOoW)));
                }
                else
                {
                    RSDPFM((RSM_BUFSPAN | RSM_TEX1,
                            "    ATex1 %X,%X (%f,%f)\n",
                            pSpan->iUoW1, pSpan->iVoW1,
                            (FLOAT)pSpan->iUoW1 / TEX_SCALE,
                            (FLOAT)pSpan->iVoW1 / TEX_SCALE));
                }

                RSDPFM((RSM_BUFSPAN | RSM_FOG,
                        "    Fog %X (%f), DFog %X (%f)\n",
                        pSpan->uFog, (FLOAT)pSpan->uFog / FOG_SCALE,
                        pSpan->iDFog, (FLOAT)pSpan->iDFog / FOG_SCALE));

                pSpan++;
            }
        }
    }

    RSSETFLAGS(DBG_OUTPUT_FLAGS, uOldFlags);
}
#endif // DBG

//----------------------------------------------------------------------------
//
// PrimProcessor::Flush
//
// Flushes any remaining data from the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Flush(void)
{
    HRESULT hr;

    if (m_pCur - m_pBufferStart > sizeof(D3DI_RASTPRIM))
    {
        // Process data.
        m_StpCtx.pCtx->pPrim = (PD3DI_RASTPRIM)m_pBufferStart;
        m_StpCtx.pCtx->pNext = NULL;

#if DBG
        if ((RSGETFLAGS(DBG_OUTPUT_MASK) & (RSM_BUFPRIM | RSM_BUFSPAN)) ||
            (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                           RSU_CHECK_SPAN_EDGES)))
        {
            DumpPrims(&m_StpCtx);
        }

        if ((RSGETFLAGS(DBG_USER_FLAGS) & RSU_NO_RENDER_SPANS) == 0)
        {
            if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_BREAK_ON_RENDER_SPANS)
            {
                DebugBreak();
            }

            RSHRCHK(m_StpCtx.pCtx->pfnRenderSpans(m_StpCtx.pCtx));
        }
        else
        {
            hr = D3D_OK;
        }
#else
        hr = m_StpCtx.pCtx->pfnRenderSpans(m_StpCtx.pCtx);
#endif

        ResetBuffer();
    }
    else
    {
        hr = D3D_OK;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::FlushPartial
//
// Flushes the buffer in the middle of a primitive.  Preserves last
// partial primitive and replaces it in the buffer after the flush.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::FlushPartial(void)
{
    D3DI_RASTPRIM SavedPrim;
    HRESULT hr;

    RSDPFM((RSM_BUFFER, "FlushPartial, saving prim at %p, Y %d\n",
            m_StpCtx.pPrim, m_StpCtx.iY));

    // Not enough space.  Flush current buffer.  We need to
    // save the current prim and put it back in the buffer after the
    // flush since it's being extended.
    SavedPrim = *m_StpCtx.pPrim;

    RSHRRET(Flush());

    GET_PRIM();

    *m_StpCtx.pPrim = SavedPrim;
    COMMIT_PRIM(FALSE);

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::AppendPrim
//
// Ensures that some primitive is active in the buffer for spans to
// be added to.  If no valid primitive is available to append to,
// a zeroed primitive is committed into the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::AppendPrim(void)
{
    // If there's no primitive or the current primitive has not
    // been committed, commit a clean primitive into the buffer.
    if (m_StpCtx.pPrim == NULL ||
        (PUINT8)m_StpCtx.pPrim == m_pCur)
    {
        GET_PRIM();
        COMMIT_PRIM(TRUE);
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Begin
//
// Resets the buffer to an empty state in preparation for incoming
// triangles.
//
//----------------------------------------------------------------------------

void
PrimProcessor::Begin(void)
{
    UINT16 uFpCtrl;
    FPU_GET_MODE(uFpCtrl);
    m_uFpCtrl = uFpCtrl;
    uFpCtrl =
        FPU_MODE_CHOP_ROUND(
                FPU_MODE_LOW_PRECISION(
                        FPU_MODE_MASK_EXCEPTIONS(m_uFpCtrl)));
#if defined(_X86_) && defined(UNMASK_EXCEPTIONS)
    // Unmask some exceptions so that we can eliminate them.
    // This requires a safe set to clear any exceptions that
    // are currently asserted.
    //
    // Exceptions left masked:
    //   Precision, denormal.
    // Exceptions unmasked:
    //   Underflow, overflow, divzero, invalid op.
    uFpCtrl &= ~0x1d;
    FPU_SAFE_SET_MODE(uFpCtrl);
#else
    FPU_SET_MODE(uFpCtrl);
#endif

    m_uPpFlags |= PPF_IN_BEGIN;
    ResetBuffer();
}

//----------------------------------------------------------------------------
//
// PrimProcessor::End
//
// Flushes if necessary and cleans up.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::End(void)
{
    HRESULT hr;

    if (m_pCur - m_pBufferStart > sizeof(D3DI_RASTPRIM))
    {
        RSHRCHK(Flush());
    }
    else
    {
        hr = D3D_OK;
    }

    UINT16 uFpCtrl = m_uFpCtrl;
    FPU_SAFE_SET_MODE(uFpCtrl);

    m_uPpFlags &= ~PPF_IN_BEGIN;

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::SetCtx
//
// Sets the rasterization context to operate in.
//
//----------------------------------------------------------------------------

void
PrimProcessor::SetCtx(PD3DI_RASTCTX pCtx)
{
    // This function can't be called inside a Begin/End pair.  This
    // is enforced so that we don't have to worry about the span
    // rendering function changing in the middle of a batch.
    RSASSERT((m_uPpFlags & PPF_IN_BEGIN) == 0);

    m_StpCtx.pCtx = pCtx;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::AllocSpans
//
// Checks to see if there's room in the buffer for the requested number
// of spans.  If so the buffer pointer is updated and a pointer is returned.
// If the requested number is not available but some reasonable number is,
// return that many.  Otherwise the buffer is flushed and the process starts
// over.  The "reasonable" number must therefore be no more than what
// can fit in the buffer at once.
//
//----------------------------------------------------------------------------

// Space for enough spans to avoid a flush.
#define AVOID_FLUSH_SPACE (8 * sizeof(D3DI_RASTSPAN))

HRESULT
PrimProcessor::AllocSpans(PUINT pcSpans, PD3DI_RASTSPAN *ppSpan)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    UINT uSpanSize;

    RSASSERT(AVOID_FLUSH_SPACE <= (BUFFER_SIZE - sizeof(D3DI_RASTPRIM)));
    // The multiplies and divides here will be really bad unless
    // RASTPRIM is a nice power-of-two in size.
    RSASSERT((sizeof(D3DI_RASTSPAN) & (sizeof(D3DI_RASTSPAN) - 1)) == 0);

    uSpanSize = *pcSpans * sizeof(D3DI_RASTSPAN);

    for (;;)
    {
        // First check for space for all requested spans.
        if (m_pCur + uSpanSize > m_pBufferEnd)
        {
            // Not enough space for everything, so see if we have
            // enough space to avoid a flush.
            if (m_pCur + AVOID_FLUSH_SPACE > m_pBufferEnd)
            {
                // Not enough space, so flush.
                RSHRCHK(FlushPartial());
                if (hr != D3D_OK)
                {
                    *pcSpans = 0;
                    return hr;
                }

                // Loop around.  Flush is guaranteed to at least produce
                // AVOID_FLUSH_SPACE so the loop will always exit.
            }
            else
            {
                // Not enough space for everything but enough space
                // to return some.  Set new span count.
                *pcSpans = (UINT)((m_pBufferEnd - m_pCur) / sizeof(D3DI_RASTSPAN));
                uSpanSize = *pcSpans * sizeof(D3DI_RASTSPAN);
                break;
            }
        }
        else
        {
            break;
        }
    }

    pSpan = (PD3DI_RASTSPAN)m_pCur;
    m_pCur += uSpanSize;
    *ppSpan = pSpan;

    RSDPFM((RSM_BUFFER, "Alloc %d spans at %p, cur %p\n",
            *pcSpans, pSpan, m_pCur));

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::FreeSpans and FreeSpans
//
// Returns space given out by AllocSpans.
//
//----------------------------------------------------------------------------

void
PrimProcessor::FreeSpans(UINT cSpans)
{
    m_pCur -= cSpans * sizeof(D3DI_RASTSPAN);

    RSDPFM((RSM_BUFFER, "Free  %d spans at %p, cur %p\n", cSpans,
            m_pCur + cSpans * sizeof(D3DI_RASTSPAN), m_pCur));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\makefile.inc ===
$(GENTGT)\attrs_mh.h: ..\attrs_mh.mh $(RAST_STD_M4)

$(GENTGT)\tstp_mh.h: ..\tstp_mh.mh $(RAST_STD_M4)

$(GENTGT)\walk_mh.h: ..\walk_mh.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): ..\offs_acp.acp \
        ..\..\..\inc\span.h ..\..\inc\stp_base.h

$(GENTGT)\attrsx86.asm: ..\attrsx86.mas ..\attrsx86.mh $(RAST_STD_M4)

$(GENTGT)\attrscpp.cpp: ..\attrscpp.mcp $(RAST_STD_M4)

$(GENTGT)\tstpx86.asm: ..\tstpx86.mas $(RAST_STD_M4)

$(GENTGT)\tstpcpp.cpp: ..\tstpcpp.mcp $(RAST_STD_M4)

$(GENTGT)\walkx86.asm: ..\walkx86.mas ..\attrsx86.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\attrs.cpp ===
//----------------------------------------------------------------------------
//
// attrs.cpp
//
// Cross-platform attribute handling functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// AddFloatAttrs_Any
//
// Adds a set of attribute deltas to an ATTRSET.
// Handles any set of attributes via USED flags.
//
//----------------------------------------------------------------------------

void FASTCALL
AddFloatAttrs_Any(PATTRSET pAttr, PATTRSET pDelta, PSETUPCTX pStpCtx)
{
    pAttr->pSurface += pDelta->ipSurface;
    pAttr->pZ += pDelta->ipZ;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        pAttr->fZ += pDelta->fZ;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        pAttr->fOoW += pDelta->fOoW;

        pAttr->fUoW1 += pDelta->fUoW1;
        pAttr->fVoW1 += pDelta->fVoW1;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        pAttr->fUoW2 += pDelta->fUoW2;
        pAttr->fVoW2 += pDelta->fVoW2;
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pAttr->fB += pDelta->fB;
        pAttr->fG += pDelta->fG;
        pAttr->fR += pDelta->fR;
        pAttr->fA += pDelta->fA;
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pAttr->fDIdx += pDelta->fDIdx;
        pAttr->fDIdxA += pDelta->fDIdxA;
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pAttr->fBS += pDelta->fBS;
        pAttr->fGS += pDelta->fGS;
        pAttr->fRS += pDelta->fRS;
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pAttr->fFog += pDelta->fFog;
    }
}

//----------------------------------------------------------------------------
//
// AddScaledFloatAttrs_Any_Either
//
// Scales and adds a set of attribute deltas to an ATTRSET.
// Handles any set of attributes via USED flags.
// Uses PWL support.
//
//----------------------------------------------------------------------------

void FASTCALL
AddScaledFloatAttrs_Any_Either(PATTRSET pAttr, PATTRSET pDelta,
                               PSETUPCTX pStpCtx, INT iScale)
{
    FLOAT fScale = (FLOAT)iScale;

    pAttr->pSurface += pDelta->ipSurface * iScale;
    pAttr->pZ += pDelta->ipZ * iScale;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
#ifdef PWL_FOG
        if (pStpCtx->uPwlFlags & PWL_NEXT_FOG)
        {
            pAttr->fZ = pStpCtx->fNextZ;
        }
        else
#endif
        {
            pAttr->fZ += pDelta->fZ * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
        {
            pAttr->fOoW = pStpCtx->fNextOoW;
            pAttr->fUoW1 = pStpCtx->fNextUoW1;
            pAttr->fVoW1 = pStpCtx->fNextVoW1;
        }
        else
        {
            pAttr->fOoW += pDelta->fOoW * fScale;
            pAttr->fUoW1 += pDelta->fUoW1 * fScale;
            pAttr->fVoW1 += pDelta->fVoW1 * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        pAttr->fUoW2 += pDelta->fUoW2 * fScale;
        pAttr->fVoW2 += pDelta->fVoW2 * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pAttr->fB += pDelta->fB * fScale;
        pAttr->fG += pDelta->fG * fScale;
        pAttr->fR += pDelta->fR * fScale;
        pAttr->fA += pDelta->fA * fScale;
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pAttr->fDIdx += pDelta->fDIdx * fScale;
        pAttr->fDIdxA += pDelta->fDIdxA * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pAttr->fBS += pDelta->fBS * fScale;
        pAttr->fGS += pDelta->fGS * fScale;
        pAttr->fRS += pDelta->fRS * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pAttr->fFog += pDelta->fFog * fScale;
    }
}

//----------------------------------------------------------------------------
//
// FillSpanFloatAttrs_Any_Either
//
// Fills in a span structure with the given attributes.
// Handles any set of attributes via USED flags.
// Uses and updates PWL support.
//
//----------------------------------------------------------------------------

void FASTCALL
FillSpanFloatAttrs_Any_Either(PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
                              PSETUPCTX pStpCtx, INT cPix)
{
    FLOAT fPix = (FLOAT)cPix;
    pSpan->pSurface = pAttr->pSurface;
    pSpan->pZ = pAttr->pZ;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        pSpan->uZ = FTOI(pAttr->fZ);
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fW;

        if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
        {
            fW = pStpCtx->fNextW;
        }
        else if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            if (FLOAT_EQZ(pAttr->fOoW))
            {
                fW = g_fZero;
            }
            else
            {
                fW = OOW_SCALE / pAttr->fOoW;
            }
        }
        else
        {
            fW = g_fOne;
        }

        pSpan->iW = FTOI(fW * W_SCALE);

        if (pStpCtx->uFlags & PRIMSF_LOD_USED)
        {
            // Mipmapping is enabled so compute texture LOD.
            // The span code can do linear LOD interpolation
            // so that we can do piecewise-linear approximations
            // instead of true per-pixel LOD.  In order to make this
            // work we need to compute the next LOD and a delta
            // value.  All of these values can be reused if this
            // loop goes around so keep them available for the next
            // iteration and set a flag to indicate that they've
            // been computed.

            if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
            {
                pSpan->iLOD = (INT16)pStpCtx->iNextLOD;
            }
            else
            {
                pSpan->iLOD =
                    (INT16)ComputeLOD(pStpCtx->pCtx,
                               (pAttr->fUoW1 * OO_TEX_SCALE) * fW,
                               (pAttr->fVoW1 * OO_TEX_SCALE) * fW,
                               fW,
                               (pStpCtx->DAttrDX.fUoW1 * OO_TEX_SCALE),
                               (pStpCtx->DAttrDX.fVoW1 * OO_TEX_SCALE),
                               (pStpCtx->DAttrDX.fOoW * OO_OOW_SCALE),
                               (pStpCtx->DAttrDY.fUoW1 * OO_TEX_SCALE),
                               (pStpCtx->DAttrDY.fVoW1 * OO_TEX_SCALE),
                               (pStpCtx->DAttrDY.fOoW * OO_OOW_SCALE));
            }

            if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
            {
                pStpCtx->fNextOoW = pAttr->fOoW + pStpCtx->DAttrDX.fOoW * fPix;

                if (FLOAT_EQZ(pStpCtx->fNextOoW))
                {
                    fW = g_fZero;
                }
                else
                {
                    fW = OOW_SCALE / pStpCtx->fNextOoW;
                }
            }
            else
            {
                pStpCtx->fNextOoW = OOW_SCALE;
                fW = g_fOne;
            }

            pStpCtx->fNextW = fW;
            pStpCtx->fNextUoW1 = pAttr->fUoW1 + pStpCtx->DAttrDX.fUoW1 * fPix;
            pStpCtx->fNextVoW1 = pAttr->fVoW1 + pStpCtx->DAttrDX.fVoW1 * fPix;
            pStpCtx->iNextLOD =
                ComputeLOD(pStpCtx->pCtx,
                           (pStpCtx->fNextUoW1 * OO_TEX_SCALE) * fW,
                           (pStpCtx->fNextVoW1 * OO_TEX_SCALE) * fW,
                           fW,
                           (pStpCtx->DAttrDX.fUoW1 * OO_TEX_SCALE),
                           (pStpCtx->DAttrDX.fVoW1 * OO_TEX_SCALE),
                           (pStpCtx->DAttrDX.fOoW * OO_OOW_SCALE),
                           (pStpCtx->DAttrDY.fUoW1 * OO_TEX_SCALE),
                           (pStpCtx->DAttrDY.fVoW1 * OO_TEX_SCALE),
                           (pStpCtx->DAttrDY.fOoW * OO_OOW_SCALE));
            pStpCtx->uPwlFlags |= PWL_NEXT_LOD;

            pSpan->iDLOD = (INT16)
                FTOI((FLOAT)(pStpCtx->iNextLOD - pSpan->iLOD) / fPix);
        }
        else
        {
            pSpan->iLOD = 0;
            pSpan->iDLOD = 0;
        }

        pSpan->iOoW = FTOI(pAttr->fOoW);

        pSpan->iUoW1 = FTOI(pAttr->fUoW1);
        pSpan->iVoW1 = FTOI(pAttr->fVoW1);
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        pSpan->iUoW2 = FTOI(pAttr->fUoW2);
        pSpan->iVoW2 = FTOI(pAttr->fVoW2);
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pSpan->uB = (INT16)FTOI(pAttr->fB);
        pSpan->uG = (INT16)FTOI(pAttr->fG);
        pSpan->uR = (INT16)FTOI(pAttr->fR);
        pSpan->uA = (INT16)FTOI(pAttr->fA);
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pSpan->iIdx = FTOI(pAttr->fDIdx);
        pSpan->iIdxA = FTOI(pAttr->fDIdxA);
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pSpan->uBS = (INT16)FTOI(pAttr->fBS);
        pSpan->uGS = (INT16)FTOI(pAttr->fGS);
        pSpan->uRS = (INT16)FTOI(pAttr->fRS);
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pSpan->uFog = (INT16)FTOI(pAttr->fFog);
        pSpan->iDFog = (INT16)(pStpCtx->iDLocalFogDX);
    }
#ifdef PWL_FOG
    else if (pStpCtx->uFlags & PRIMSF_GLOBAL_FOG_USED)
    {
        FLOAT fOoZScale;

        // The span code doesn't have direct global fog support.
        // It's faked by setup doing PWL approximations here
        // similarly to how LOD is handled.

        if (pStpCtx->pCtx->iZBitCount == 16)
        {
            fOoZScale = OO_Z16_SCALE;
        }
        else
        {
            fOoZScale = OO_Z32_SCALE;
        }

        if (pStpCtx->uPwlFlags & PWL_NEXT_FOG)
        {
            pSpan->uFog = pStpCtx->uNextFog;
        }
        else
        {
            pSpan->uFog = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                          pAttr->fZ * fOoZScale);
        }

        if ((pStpCtx->uPwlFlags & PWL_NO_NEXT_FOG) == 0)
        {
            pStpCtx->fNextZ = pAttr->fZ + pStpCtx->DAttrDX.fZ * fPix;
            pStpCtx->uNextFog = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                                pStpCtx->fNextZ * fOoZScale);
            pStpCtx->uPwlFlags |= PWL_NEXT_FOG;

            pSpan->iDFog =
                FTOI((FLOAT)((INT)pStpCtx->uNextFog -
                             (INT)pSpan->uFog) / fPix);
        }
        else
        {
            pSpan->iDFog = 0;
        }
    }
#endif
}

//
// Tables of attribute handlers.
// Indexing is with the low four PRIMSF_*_USED bits.
//

// Attribute adders.
PFN_ADDATTRS g_pfnAddFloatAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -2 -1 -S -D */
    AddFloatAttrs_Z_Diff,                               /* 1: -2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 2: -2 -1 +S -D */
    AddFloatAttrs_Z_Diff_Spec,                          /* 3: -2 -1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 4: -2 +1 -S -D */
    AddFloatAttrs_Z_Diff_Tex1,                          /* 5: -2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 6: -2 +1 +S -D */
    AddFloatAttrs_Z_Diff_Spec_Tex1,                     /* 7: -2 +1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 8: +2 -1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 9: +2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* A: +2 -1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* B: +2 -1 +S +D */
    AddFloatAttrs_Z_Tex1_Tex2,                          /* C: +2 +1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* D: +2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* E: +2 +1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_ADDATTRS g_pfnAddFixedAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -2 -1 -S -D */
    AddFixedAttrs_Z_Diff,                               /* 1: -2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 2: -2 -1 +S -D */
    AddFixedAttrs_Z_Diff_Spec,                          /* 3: -2 -1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 4: -2 +1 -S -D */
    AddFixedAttrs_Z_Diff_Tex1,                          /* 5: -2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 6: -2 +1 +S -D */
    AddFixedAttrs_Z_Diff_Spec_Tex1,                     /* 7: -2 +1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 8: +2 -1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 9: +2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* A: +2 -1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* B: +2 -1 +S +D */
    AddFixedAttrs_Z_Tex1_Tex2,                          /* C: +2 +1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* D: +2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* E: +2 +1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* F: +2 +1 +S +D */
};
#endif

// Scaled attribute adders without PWL support.
PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[] =
{
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 0: -2 -1 -S -D */
    AddScaledFloatAttrs_Z_Diff,                         /* 1: -2 -1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 2: -2 -1 +S -D */
    AddScaledFloatAttrs_Z_Diff_Spec,                    /* 3: -2 -1 +S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 4: -2 +1 -S -D */
    AddScaledFloatAttrs_Z_Diff_Tex1,                    /* 5: -2 +1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 6: -2 +1 +S -D */
    AddScaledFloatAttrs_Z_Diff_Spec_Tex1,               /* 7: -2 +1 +S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 8: +2 -1 -S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 9: +2 -1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* A: +2 -1 +S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* B: +2 -1 +S +D */
    AddScaledFloatAttrs_Z_Tex1_Tex2,                    /* C: +2 +1 -S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* D: +2 +1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* E: +2 +1 +S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* F: +2 +1 +S +D */
};

// RASTSPAN filling functions.
PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    FillSpanFloatAttrs_Z_Diff,                          /* 1: -2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    FillSpanFloatAttrs_Z_Diff_Spec,                     /* 3: -2 -1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    FillSpanFloatAttrs_Z_Diff_Tex1,                     /* 5: -2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    FillSpanFloatAttrs_Z_Diff_Spec_Tex1,                /* 7: -2 +1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    FillSpanFloatAttrs_Z_Tex1_Tex2,                     /* C: +2 +1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    FillSpanFixedAttrs_Z_Diff,                          /* 1: -2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    FillSpanFixedAttrs_Z_Diff_Spec,                     /* 3: -2 -1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    FillSpanFixedAttrs_Z_Diff_Tex1,                     /* 5: -2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    FillSpanFixedAttrs_Z_Diff_Spec_Tex1,                /* 7: -2 +1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    FillSpanFixedAttrs_Z_Tex1_Tex2,                     /* C: +2 +1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#endif

// Float-to-fixed attribute converters.
#ifdef STEP_FIXED
PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[] =
{
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 0: -2 -1 -S -D */
    FloatAttrsToFixed_Z_Diff,                           /* 1: -2 -1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 2: -2 -1 +S -D */
    FloatAttrsToFixed_Z_Diff_Spec,                      /* 3: -2 -1 +S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 4: -2 +1 -S -D */
    FloatAttrsToFixed_Z_Diff_Tex1,                      /* 5: -2 +1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 6: -2 +1 +S -D */
    FloatAttrsToFixed_Z_Diff_Spec_Tex1,                 /* 7: -2 +1 +S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 8: +2 -1 -S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 9: +2 -1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* A: +2 -1 +S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* B: +2 -1 +S +D */
    FloatAttrsToFixed_Z_Tex1_Tex2,                      /* C: +2 +1 -S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* D: +2 +1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* E: +2 +1 +S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* F: +2 +1 +S +D */
};
#endif

//
// Tables of ramp mode attribute handlers.
// Indexing is with PRIMSF_TEX1_USED and PRIMSF_DIDX_USED.
//

// Attribute adders.
PFN_ADDATTRS g_pfnRampAddFloatAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -I -1 */
    AddFloatAttrs_Z_Tex1,                               /* 1: -I +1 */
    AddFloatAttrs_Z_DIdx,                               /* 2: +I -1 */
    AddFloatAttrs_Z_DIdx_Tex1,                          /* 3: +I +1 */
};

// Scaled attribute adders without PWL support.
PFN_ADDSCALEDATTRS g_pfnRampAddScaledFloatAttrsTable[] =
{
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 0: -I -1 */
    AddScaledFloatAttrs_Z_Tex1,                         /* 1: -I +1 */
    AddScaledFloatAttrs_Z_DIdx,                         /* 2: +I -1 */
    AddScaledFloatAttrs_Z_DIdx_Tex1,                    /* 3: +I +1 */
};

// RASTSPAN filling functions.
PFN_FILLSPANATTRS g_pfnRampFillSpanFloatAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -I -1 */
    FillSpanFloatAttrs_Z_Tex1,                          /* 1: -I +1 */
    FillSpanFloatAttrs_Z_DIdx,                          /* 2: +I -1 */
    FillSpanFloatAttrs_Z_DIdx_Tex1,                     /* 3: +I +1 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\lstp.cpp ===
//----------------------------------------------------------------------------
//
// lstp.cpp
//
// Line setup methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// LineSetup_Start
//
// Starts setup of line attributes.
//
//----------------------------------------------------------------------------

void FASTCALL
LineSetup_Start(PSETUPCTX pStpCtx,
                LPD3DTLVERTEX pV0,
                LPD3DTLVERTEX pV1)
{
    FLOAT fZ0;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        FLOAT fZScale;

        if (pStpCtx->pCtx->iZBitCount == 16)
        {
            fZScale = Z16_SCALE;
        }
        else
        {
            fZScale = Z32_SCALE;
        }

        pStpCtx->DAttrDMajor.fZ =
            (pV1->dvSZ - pV0->dvSZ) * fZScale * pStpCtx->fOoLen;

        // fZ0 may be used later so set if from the vertex Z.
        fZ0 = pV0->dvSZ;
        pStpCtx->Attr.fZ = fZ0 * fZScale +
            pStpCtx->DAttrDMajor.fZ * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fUoW1, fVoW1;

        // Mipmapping doesn't have any meaning.
        RSASSERT((pStpCtx->uFlags & PRIMSF_LOD_USED) == 0);

        if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            pStpCtx->DAttrDMajor.fOoW =
                (pV1->dvRHW - pV0->dvRHW) * OOW_SCALE * pStpCtx->fOoLen;
            pStpCtx->Attr.fOoW = pV0->dvRHW * OOW_SCALE +
                pStpCtx->DAttrDMajor.fOoW * pStpCtx->fDMajor;

            fUoW1 = pV0->dvTU * pV0->dvRHW;
            fVoW1 = pV0->dvTV * pV0->dvRHW;

            pStpCtx->DAttrDMajor.fUoW1 =
                PERSP_TEXTURE_DELTA(pV1->dvTU, pV1->dvRHW, pV0->dvTU, fUoW1,
                                    pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_U) *
                                    TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW1 =
                PERSP_TEXTURE_DELTA(pV1->dvTV, pV1->dvRHW, pV0->dvTV, fVoW1,
                                    pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_V) *
                                    TEX_SCALE * pStpCtx->fOoLen;
        }
        else
        {
            pStpCtx->DAttrDMajor.fOoW = g_fZero;
            pStpCtx->Attr.fOoW = OOW_SCALE;

            fUoW1 = pV0->dvTU;
            fVoW1 = pV0->dvTV;

            pStpCtx->DAttrDMajor.fUoW1 =
                TextureDiff(pV1->dvTU, fUoW1,
                            pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_U) *
                            TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW1 =
                TextureDiff(pV1->dvTV, fVoW1,
                            pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_V) *
                            TEX_SCALE * pStpCtx->fOoLen;
        }

        pStpCtx->Attr.fUoW1 = TEX_SCALE * fUoW1 +
            pStpCtx->DAttrDMajor.fUoW1 * pStpCtx->fDMajor;
        pStpCtx->Attr.fVoW1 = TEX_SCALE * fVoW1 +
            pStpCtx->DAttrDMajor.fVoW1 * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        PRAST_GENERIC_VERTEX pVM0 = (PRAST_GENERIC_VERTEX)pV0;
        PRAST_GENERIC_VERTEX pVM1 = (PRAST_GENERIC_VERTEX)pV1;
        FLOAT fUoW2, fVoW2;

        if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            fUoW2 = pVM0->dvTU2 * pVM0->dvRHW;
            fVoW2 = pVM0->dvTV2 * pVM0->dvRHW;

            pStpCtx->DAttrDMajor.fUoW2 =
                PERSP_TEXTURE_DELTA(pVM1->dvTU2, pVM1->dvRHW,
                                    pVM0->dvTU2, fUoW2,
                                    pStpCtx->pCtx->pdwWrap[1] & D3DWRAP_U) *
                                    TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW2 =
                PERSP_TEXTURE_DELTA(pVM1->dvTV2, pVM1->dvRHW,
                                    pVM0->dvTV2, fVoW2,
                                    pStpCtx->pCtx->pdwWrap[1] & D3DWRAP_V) *
                                    TEX_SCALE * pStpCtx->fOoLen;
        }
        else
        {
            fUoW2 = pVM0->dvTU2;
            fVoW2 = pVM0->dvTV2;

            pStpCtx->DAttrDMajor.fUoW2 =
                TextureDiff(pVM1->dvTU2, fUoW2,
                            pStpCtx->pCtx->pdwWrap[1] & D3DWRAP_U) *
                            TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW2 =
                TextureDiff(pVM1->dvTV2, fVoW2,
                            pStpCtx->pCtx->pdwWrap[1] & D3DWRAP_V) *
                            TEX_SCALE * pStpCtx->fOoLen;
        }

        pStpCtx->Attr.fUoW2 = fUoW2 +
            pStpCtx->DAttrDMajor.fUoW2 * pStpCtx->fDMajor;
        pStpCtx->Attr.fVoW2 = fVoW2 +
            pStpCtx->DAttrDMajor.fVoW2 * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_FLAT_SHADED)
    {
        if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
        {
            UINT uB, uG, uR, uA;

            SPLIT_COLOR(pStpCtx->pFlatVtx->dcColor, uB, uG, uR, uA);

            pStpCtx->DAttrDMajor.fB = g_fZero;
            pStpCtx->DAttrDMajor.fG = g_fZero;
            pStpCtx->DAttrDMajor.fR = g_fZero;
            pStpCtx->DAttrDMajor.fA = g_fZero;

            pStpCtx->Attr.fB = (FLOAT)(uB << COLOR_SHIFT);
            pStpCtx->Attr.fG = (FLOAT)(uG << COLOR_SHIFT);
            pStpCtx->Attr.fR = (FLOAT)(uR << COLOR_SHIFT);
            pStpCtx->Attr.fA = (FLOAT)(uA << COLOR_SHIFT);
        }
        else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
        {
            pStpCtx->DAttrDMajor.fDIdx = g_fZero;
            pStpCtx->DAttrDMajor.fDIdxA = g_fZero;

            pStpCtx->Attr.fDIdx =
                (FLOAT)(CI_MASKALPHA(pStpCtx->pFlatVtx->dcColor) <<
                        INDEX_COLOR_FIXED_SHIFT);
            pStpCtx->Attr.fDIdxA =
                (FLOAT)(CI_GETALPHA(pStpCtx->pFlatVtx->dcColor) <<
                        INDEX_COLOR_SHIFT);
        }

        if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
        {
            UINT uB, uG, uR, uA;

            SPLIT_COLOR(pStpCtx->pFlatVtx->dcSpecular, uB, uG, uR, uA);

            pStpCtx->DAttrDMajor.fBS = g_fZero;
            pStpCtx->DAttrDMajor.fGS = g_fZero;
            pStpCtx->DAttrDMajor.fRS = g_fZero;

            pStpCtx->Attr.fBS = (FLOAT)(uB << COLOR_SHIFT);
            pStpCtx->Attr.fGS = (FLOAT)(uG << COLOR_SHIFT);
            pStpCtx->Attr.fRS = (FLOAT)(uR << COLOR_SHIFT);
        }
    }
    else
    {
        if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
        {
            UINT uB, uG, uR, uA;
            FLOAT fDB, fDG, fDR, fDA;

            SPLIT_COLOR(pV0->dcColor, uB, uG, uR, uA);
            COLOR_DELTA(pV1->dcColor, uB, uG, uR, uA, fDB, fDG, fDR, fDA);

            pStpCtx->DAttrDMajor.fB = fDB * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fG = fDG * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fR = fDR * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fA = fDA * pStpCtx->fOoLen;

            pStpCtx->Attr.fB = (FLOAT)(uB << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fB * pStpCtx->fDMajor;
            pStpCtx->Attr.fG = (FLOAT)(uG << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fG * pStpCtx->fDMajor;
            pStpCtx->Attr.fR = (FLOAT)(uR << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fR * pStpCtx->fDMajor;
            pStpCtx->Attr.fA = (FLOAT)(uA << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fA * pStpCtx->fDMajor;
        }
        else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
        {
            INT32 iIdx, iA;
            FLOAT fDIdx, fDA;

            SPLIT_IDX_COLOR(pV0->dcColor, iIdx, iA);
            IDX_COLOR_DELTA(pV1->dcColor, iIdx, iA, fDIdx, fDA);

            pStpCtx->DAttrDMajor.fDIdx = fDIdx * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fDIdxA = fDA * pStpCtx->fOoLen;

            pStpCtx->Attr.fDIdx = (FLOAT)(iIdx << INDEX_COLOR_FIXED_SHIFT) +
                pStpCtx->DAttrDMajor.fDIdx * pStpCtx->fDMajor;
            pStpCtx->Attr.fDIdxA = (FLOAT)(iA << INDEX_COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fDIdxA * pStpCtx->fDMajor;
        }

        if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
        {
            UINT uB, uG, uR, uA;
            FLOAT fDB, fDG, fDR, fDA;

            SPLIT_COLOR(pV0->dcSpecular, uB, uG, uR, uA);
            COLOR_DELTA(pV1->dcSpecular, uB, uG, uR, uA, fDB, fDG, fDR, fDA);

            pStpCtx->DAttrDMajor.fBS = fDB * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fGS = fDG * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fRS = fDR * pStpCtx->fOoLen;

            pStpCtx->Attr.fBS = (FLOAT)(uB << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fBS * pStpCtx->fDMajor;
            pStpCtx->Attr.fGS = (FLOAT)(uG << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fGS * pStpCtx->fDMajor;
            pStpCtx->Attr.fRS = (FLOAT)(uR << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fRS * pStpCtx->fDMajor;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        UINT uFog0, uFog1;

#ifndef PWL_FOG
        // Check for global-into-local fog.  If global fog is on,
        // compute the local fog values from table fog rather than
        // from the vertex.
        if (pStpCtx->uFlags & PRIMSF_GLOBAL_FOG_USED)
        {
            // Make sure Z information is valid.
            RSASSERT(pStpCtx->uFlags & PRIMSF_Z_USED);

            uFog0 = ComputeTableFog(pStpCtx->pCtx->pdwRenderState, fZ0);
            uFog1 = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                    pV1->dvSZ);
        }
        else
#endif
        {
            uFog0 = (UINT)RGBA_GETALPHA(pV0->dcSpecular) << FOG_SHIFT;
            uFog1 = (UINT)RGBA_GETALPHA(pV1->dcSpecular) << FOG_SHIFT;
        }

        pStpCtx->DAttrDMajor.fFog =
            (FLOAT)((INT)uFog1 - (INT)uFog0) * pStpCtx->fOoLen;
        pStpCtx->Attr.fFog = (FLOAT)uFog0 +
            pStpCtx->DAttrDMajor.fFog * pStpCtx->fDMajor;
    }
}

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
#define NEEDS_NORMALIZE2(fV0, fV1) \
    ((ASUINT32(fV0) | ASUINT32(fV1)) > INT32_FLOAT_ONE)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizeLineRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function ensures that
// the RHWs are in the proper range by finding the largest one and
// scaling all of them down by it.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizeLineRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1)
{
    // Save original values.
    m_dvV0RHW = pV0->dvRHW;
    m_dvV1RHW = pV1->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW) || FLOAT_LTZ(pV1->dvRHW))
    {
        RSDPF(("Line RHW out of range %f,%f\n",
               pV0->dvRHW, pV1->dvRHW));
    }
#endif

    // Find bounds and compute scale.
    FLOAT fMax;

    if (pV0->dvRHW < pV1->dvRHW)
    {
        fMax = pV1->dvRHW;
    }
    else
    {
        fMax = pV0->dvRHW;
    }

    FLOAT fRHWScale = NORMALIZED_RHW_MAX / fMax;

    // Scale all values by scaling factor.
    pV0->dvRHW = pV0->dvRHW * fRHWScale;
    pV1->dvRHW = pV1->dvRHW * fRHWScale;
}

//-----------------------------------------------------------------------------
//
// PrimProcessor::PointDiamondCheck
//
// Tests if vertex is within diamond of nearest candidate
// position.  The +.5 (lower-right) tests are used because this is
// pixel-relative test - this corresponds to an upper-left test for
// a vertex-relative position.
//
//-----------------------------------------------------------------------------

BOOL
PrimProcessor::PointDiamondCheck(INT32 iXFrac, INT32 iYFrac,
                                 BOOL bSlopeIsOne, BOOL bSlopeIsPosOne)
{
    const INT32 iPosHalf =  0x8;
    const INT32 iNegHalf = -0x8;

    INT32 iFracAbsSum = labs( iXFrac ) + labs( iYFrac );

    // return TRUE if point is in fully-exclusive diamond
    if ( iFracAbsSum < iPosHalf )
    {
        return TRUE;
    }

    // else return TRUE if diamond is on left or top extreme of point
    if ( ( iXFrac == ( bSlopeIsPosOne ? iNegHalf : iPosHalf ) ) &&
         ( iYFrac == 0 ) )
    {
        return TRUE;
    }

    if ( ( iYFrac == iPosHalf ) &&
         ( iXFrac == 0 ) )
    {
        return TRUE;
    }

    // return true if slope is one, vertex is on edge,
    // and (other conditions...)
    if ( bSlopeIsOne && ( iFracAbsSum == iPosHalf ) )
    {
        if (  bSlopeIsPosOne && ( iXFrac < 0 ) && ( iYFrac > 0 ) )
        {
            return TRUE;
        }

        if ( !bSlopeIsPosOne && ( iXFrac > 0 ) && ( iYFrac > 0 ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::LineSetup
//
// Does attribute setup computations.
//
//----------------------------------------------------------------------------

// Line computations are done in n.4 fixed-point to reduce vertex jitter,
// move more computation to integer and to more easily match the GDI
// line computations.
#define LINE_FIX 4
#define LINE_SNAP FLOAT_TWOPOW4
#define OO_LINE_SNAP (1.0f / FLOAT_TWOPOW4)
#define LINE_FIX_HALF (1 << (LINE_FIX - 1))
#define LINE_FIX_NEAR_HALF (LINE_FIX_HALF - 1)

BOOL
PrimProcessor::LineSetup(LPD3DTLVERTEX pV0,
                         LPD3DTLVERTEX pV1)
{
    // compute fixed point vertex values, with cheap
    // rounding for better accuracy
    INT32 iX0 = FTOI(pV0->dvSX * LINE_SNAP + .5F);
    INT32 iX1 = FTOI(pV1->dvSX * LINE_SNAP + .5F);
    INT32 iY0 = FTOI(pV0->dvSY * LINE_SNAP + .5F);
    INT32 iY1 = FTOI(pV1->dvSY * LINE_SNAP + .5F);

    // compute x,y extents of the line (fixed point)
    INT32 iXSize = iX1 - iX0;
    INT32 iYSize = iY1 - iY0;

    // ignore zero length lines
    if ( iXSize == 0 && iYSize == 0 )
    {
        return FALSE;
    }

    INT32 iAbsXSize;
    INT32 iAbsYSize;

    if ( iXSize < 0 )
    {
        m_StpCtx.iDXCY = -1;
        iAbsXSize = -iXSize;
    }
    else
    {
        m_StpCtx.iDXCY = 1;
        iAbsXSize = iXSize;
    }

    if ( iYSize < 0 )
    {
        m_StpCtx.iDYCY = -1;
        iAbsYSize = -iYSize;
    }
    else
    {
        m_StpCtx.iDYCY = 1;
        iAbsYSize = iYSize;
    }

    BOOL bSlopeIsOne = iAbsXSize == iAbsYSize;
    BOOL bSlopeIsPosOne =
        bSlopeIsOne && ((iXSize ^ iYSize) & 0x80000000) == 0;

    // compute closest pixel for vertices
    //
    //       n                   n
    //   O-------*           *-------O
    //  n-.5    n+.5        n-.5    n+.5
    //
    //  Nearest Ceiling     Nearest Floor
    //
    // always nearest ceiling for Y; use nearest floor for X for
    // exception (slope == +1) case else use nearest ceiling
    //
    INT32 iXAdjust;
    if (bSlopeIsPosOne)
    {
        iXAdjust = LINE_FIX_HALF;
    }
    else
    {
        iXAdjust = LINE_FIX_NEAR_HALF;
    }
    INT32 iPixX0 = ( iX0 + iXAdjust ) >> LINE_FIX;
    INT32 iPixX1 = ( iX1 + iXAdjust ) >> LINE_FIX;
    INT32 iPixY0 = ( iY0 + LINE_FIX_NEAR_HALF ) >> LINE_FIX;
    INT32 iPixY1 = ( iY1 + LINE_FIX_NEAR_HALF ) >> LINE_FIX;

    // determine major axis and compute step values

    // sign of extent from V0 to V1 in major direction
    BOOL bLineMajorNeg;

    INT32 iLineMajor0;
    INT32 iLineMajor1;
    INT32 iLinePix0;
    INT32 iLinePix1;
    INT32 iLinePixStep;

    // use GreaterEqual compare here so X major will be used when slope is
    // exactly one - this forces the per-pixel evaluation to be done on the
    // Y axis and thus adheres to the rule of inclusive right (instead of
    // inclusive left) for slope == 1 cases
    if ( iAbsXSize >= iAbsYSize )
    {
        // here for X major
        m_StpCtx.uFlags |= LNF_X_MAJOR;
        iLineMajor0 = iX0;
        iLineMajor1 = iX1;
        iLinePix0 = iPixX0;
        iLinePix1 = iPixX1;
        iLinePixStep = m_StpCtx.iDXCY;
        bLineMajorNeg = iXSize & 0x80000000;
        m_StpCtx.iDXNC = m_StpCtx.iDXCY;
        m_StpCtx.iDYNC = 0;
    }
    else
    {
        // here for Y major
        iLineMajor0 = iY0;
        iLineMajor1 = iY1;
        iLinePix0 = iPixY0;
        iLinePix1 = iPixY1;
        iLinePixStep = m_StpCtx.iDYCY;
        bLineMajorNeg = iYSize & 0x80000000;
        m_StpCtx.iDXNC = 0;
        m_StpCtx.iDYNC = m_StpCtx.iDYCY;
    }

    // The multiplies here could be traded for sign tests but there'd
    // be four cases.  On a PII the multiplies will be faster than
    // the branches.
    m_StpCtx.DAttrCY.ipSurface =
        m_StpCtx.iDYCY * m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.iDXCY * m_StpCtx.pCtx->iSurfaceStep;
    m_StpCtx.DAttrNC.ipSurface =
        m_StpCtx.iDYNC * m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.iDXNC * m_StpCtx.pCtx->iSurfaceStep;
    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        m_StpCtx.DAttrCY.ipZ =
            m_StpCtx.iDYCY * m_StpCtx.pCtx->iZStride +
            m_StpCtx.iDXCY * m_StpCtx.pCtx->iZStep;
        m_StpCtx.DAttrNC.ipZ =
            m_StpCtx.iDYNC * m_StpCtx.pCtx->iZStride +
            m_StpCtx.iDXNC * m_StpCtx.pCtx->iZStep;
    }

    // check for vertices in/out of diamond
    BOOL bV0InDiamond = PointDiamondCheck( iX0 - (iPixX0 << LINE_FIX),
                                           iY0 - (iPixY0 << LINE_FIX),
                                           bSlopeIsOne, bSlopeIsPosOne );
    BOOL bV1InDiamond = PointDiamondCheck( iX1 - (iPixX1 << LINE_FIX),
                                           iY1 - (iPixY1 << LINE_FIX),
                                           bSlopeIsOne, bSlopeIsPosOne );

#define LINEDIR_CMP( _A, _B ) \
    ( bLineMajorNeg ? ( (_A) > (_B) ) : ( (_A) < (_B) ) )

    // do first pixel handling - not in or behind diamond
    if ( !( bV0InDiamond ||
            LINEDIR_CMP( iLineMajor0, iLinePix0 << LINE_FIX ) ) )
    {
        iLinePix0 += iLinePixStep;
    }

    // do last-pixel handling - don't pull in extent if past diamond
    // (in which case the pixel is always filled) or if in diamond
    // and rendering last pixel
    if ( !( ( !bV1InDiamond &&
              LINEDIR_CMP( iLinePix1 << LINE_FIX, iLineMajor1 ) ||
            ( bV1InDiamond &&
              m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_LASTPIXEL] ) ) ) )
    {
        iLinePix1 -= iLinePixStep;
    }

    // compute extent along major axis
    m_StpCtx.cLinePix =
        bLineMajorNeg ? iLinePix0 - iLinePix1 + 1 : iLinePix1 - iLinePix0 + 1;

    // return if no major extent
    if ( m_StpCtx.cLinePix <= 0 )
    {
        return FALSE;
    }

    FLOAT fSlope;
    FLOAT fMinor0;

    // compute final axis-specific line values
    if ( iAbsXSize >= iAbsYSize )
    {
        m_StpCtx.iX = iLinePix0;

        if (bLineMajorNeg)
        {
            m_StpCtx.fDMajor =
                (iX0 - (m_StpCtx.iX << LINE_FIX)) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iX0 - iX1);
        }
        else
        {
            m_StpCtx.fDMajor =
                ((m_StpCtx.iX << LINE_FIX) - iX0) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iX1 - iX0);
        }

        fSlope = m_StpCtx.fOoLen * (iY1 - iY0) * OO_LINE_SNAP;

        fMinor0 = (iY0 + LINE_FIX_NEAR_HALF) * OO_LINE_SNAP +
            m_StpCtx.fDMajor * fSlope;
        m_StpCtx.iY = IFLOORF(fMinor0);
        m_StpCtx.iLineFrac = SCALED_FRACTION(fMinor0 - m_StpCtx.iY);
        m_StpCtx.iDLineFrac = SCALED_FRACTION(fSlope);
    }
    else
    {
        m_StpCtx.iY = iLinePix0;

        if (bLineMajorNeg)
        {
            m_StpCtx.fDMajor =
                (iY0 - (m_StpCtx.iY << LINE_FIX)) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iY0 - iY1);
        }
        else
        {
            m_StpCtx.fDMajor =
                ((m_StpCtx.iY << LINE_FIX) - iY0) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iY1 - iY0);
        }

        fSlope = m_StpCtx.fOoLen * (iX1 - iX0) * OO_LINE_SNAP;

        fMinor0 = (iX0 + iXAdjust) * OO_LINE_SNAP + m_StpCtx.fDMajor * fSlope;
        m_StpCtx.iX = IFLOORF(fMinor0);
        m_StpCtx.iLineFrac = SCALED_FRACTION(fMinor0 - m_StpCtx.iX);
        m_StpCtx.iDLineFrac = SCALED_FRACTION(fSlope);
    }

#ifdef LINE_CORRECTION_BIAS
    // A fudge factor of one-half is thrown into the correction
    // to avoid undershoot due to negative corrections.
    // This shifts all the attributes along the line,
    // introducing error, but it's better than clamping
    // them.  This is not done to the coordinates to avoid
    // perturbing them.
    m_StpCtx.fDMajor += g_fHalf;
#else
    // The correction factor is clamped to positive numbers to
    // avoid undershooting with attribute values.  This won't
    // cause overshooting issues because it moves attributes by
    // at most one-half.
    if (FLOAT_LTZ(m_StpCtx.fDMajor))
    {
        m_StpCtx.fDMajor = 0;
    }
#endif

    RSDPFM((RSM_LINES, "Line %.2f,%.2f - %.2f,%.2f\n",
            pV0->dvSX, pV0->dvSY, pV1->dvSX, pV1->dvSY));
    RSDPFM((RSM_LINES, "  %c major, %d,%d, %d pix\n",
            (m_StpCtx.uFlags & LNF_X_MAJOR) ? 'X' : 'Y',
            m_StpCtx.iX, m_StpCtx.iY, m_StpCtx.cLinePix));
    RSDPFM((RSM_LINES, "  slope %f, dmajor %f, minor0 %f\n",
            fSlope, m_StpCtx.fDMajor, fMinor0));
    RSDPFM((RSM_LINES, "  frac %d, dfrac %d\n",
            m_StpCtx.iLineFrac, m_StpCtx.iDLineFrac));

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE2(pV0->dvRHW, pV1->dvRHW))
    {
        NormalizeLineRHW(pV0, pV1);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    LineSetup_Start(&m_StpCtx, pV0, pV1);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
        pV1->dvRHW = m_dvV1RHW;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\point.cpp ===
//----------------------------------------------------------------------------
//
// point.cpp
//
// Point processing.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

void
PrimProcessor::FillPointSpan(LPD3DTLVERTEX pV0, PD3DI_RASTSPAN pSpan)
{
    FLOAT fZ;
    FLOAT fZScale;

    pSpan->uPix = 1;
    pSpan->uX = (UINT16)m_StpCtx.iX;
    pSpan->uY = (UINT16)m_StpCtx.iY;

    pSpan->pSurface = m_StpCtx.pCtx->pSurfaceBits +
        m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
        m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;

    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        pSpan->pZ = m_StpCtx.pCtx->pZBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iZStride;

        if (m_StpCtx.pCtx->iZBitCount == 16)
        {
            fZScale = Z16_SCALE;
        }
        else
        {
            fZScale = Z32_SCALE;
        }

        // fZ may be used later so set if from the vertex Z.
        fZ = pV0->dvSZ;
        pSpan->uZ = FTOI(fZ * fZScale);
    }

    if (m_StpCtx.uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fW;
        FLOAT fUoW, fVoW;

        // Mipmapping doesn't have any meaning.
        RSASSERT((m_StpCtx.uFlags & PRIMSF_LOD_USED) == 0);

        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            if (FLOAT_EQZ(pV0->dvRHW))
            {
                fW = g_fZero;
            }
            else
            {
                fW = g_fOne / pV0->dvRHW;
            }

            pSpan->iW = FTOI(fW * W_SCALE);

            fUoW = pV0->dvTU * pV0->dvRHW;
            fVoW = pV0->dvTV * pV0->dvRHW;

            pSpan->iOoW = FTOI(pV0->dvRHW * OOW_SCALE);
        }
        else
        {
            fUoW = pV0->dvTU;
            fVoW = pV0->dvTV;
        }

        pSpan->iLOD = 0;
        pSpan->iDLOD = 0;

        pSpan->iUoW1 = FTOI(fUoW * TEX_SCALE);
        pSpan->iVoW1 = FTOI(fVoW * TEX_SCALE);
    }

    if (m_StpCtx.uFlags & PRIMSF_TEX2_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            pSpan->iUoW2 =
                FTOI(((PRAST_GENERIC_VERTEX)pV0)->dvTU2 *
                     pV0->dvRHW * TEX_SCALE);
            pSpan->iVoW2 =
                FTOI(((PRAST_GENERIC_VERTEX)pV0)->dvTV2 *
                     pV0->dvRHW * TEX_SCALE);
        }
        else
        {
            pSpan->iUoW2 =
                FTOI(((PRAST_GENERIC_VERTEX)pV0)->dvTU2 * TEX_SCALE);
            pSpan->iVoW2 =
                FTOI(((PRAST_GENERIC_VERTEX)pV0)->dvTV2 * TEX_SCALE);
        }
    }

    if (m_StpCtx.uFlags & PRIMSF_DIFF_USED)
    {
        pSpan->uB = (UINT)RGBA_GETBLUE(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uG = (UINT)RGBA_GETGREEN(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uR = (UINT)RGBA_GETRED(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uA = (UINT)RGBA_GETALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
    }
    else if (m_StpCtx.uFlags & PRIMSF_DIDX_USED)
    {
        pSpan->iIdx = (INT32)CI_MASKALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            INDEX_COLOR_FIXED_SHIFT;
        pSpan->iIdxA = (INT32)CI_GETALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            INDEX_COLOR_SHIFT;
    }

    if (m_StpCtx.uFlags & PRIMSF_SPEC_USED)
    {
        pSpan->uBS = (UINT)RGBA_GETBLUE(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
        pSpan->uGS = (UINT)RGBA_GETGREEN(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
        pSpan->uRS = (UINT)RGBA_GETRED(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
    }

    if (m_StpCtx.uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_GLOBAL_FOG_USED)
        {
            // Make sure that fZ has been set.
            RSASSERT(m_StpCtx.uFlags & PRIMSF_Z_USED);

            pSpan->uFog = (UINT16)ComputeTableFog(m_StpCtx.pCtx->pdwRenderState, fZ);
        }
        else
        {
            pSpan->uFog = (INT16)
                FTOI((FLOAT)RGBA_GETALPHA(pV0->dcSpecular) *
                     FOG_255_SCALE);
        }
    }
}

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
#define NEEDS_NORMALIZE1(fV0) \
    (ASUINT32(fV0) > INT32_FLOAT_ONE)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizePointRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function clamps
// the RHW to the proper range.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizePointRHW(LPD3DTLVERTEX pV0)
{
    // Save original value.
    m_dvV0RHW = pV0->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW))
    {
        RSDPF(("Point RHW out of range %f,%f",
               pV0->dvRHW));
    }
#endif

    if (pV0->dvRHW < NORMALIZED_RHW_MIN)
    {
        pV0->dvRHW = NORMALIZED_RHW_MIN;
    }
    else if (pV0->dvRHW > NORMALIZED_RHW_MAX)
    {
        pV0->dvRHW = NORMALIZED_RHW_MAX;
    }
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Point
//
// Provides a point for processing.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Point(LPD3DTLVERTEX pV0,
                     LPD3DTLVERTEX pFlatVtx)
{
    HRESULT hr;

    hr = D3D_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != D3D_OK)
    {
        return hr;
    }
#endif

    // Clear per-point flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | PTF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X",
            m_uPpFlags, m_StpCtx.uFlags));

    // Round coordinates to integer.
    m_StpCtx.iX = IFLOORF(pV0->dvSX + g_fHalf);
    m_StpCtx.iY = IFLOORF(pV0->dvSY + g_fHalf);

    RSDPFM((RSM_POINTS, "Point\n"));
    RSDPFM((RSM_POINTS, "    V0 (%f,%f,%f) (%d,%d)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ,
            m_StpCtx.iX, m_StpCtx.iY));

    // Clip test.
    if (m_StpCtx.iX < m_StpCtx.pCtx->Clip.left ||
        m_StpCtx.iX >= m_StpCtx.pCtx->Clip.right ||
        m_StpCtx.iY < m_StpCtx.pCtx->Clip.top ||
        m_StpCtx.iY >= m_StpCtx.pCtx->Clip.bottom)
    {
        return D3D_OK;
    }

    //
    // Fill out a one-pixel span for the point.
    // Since the prim deltas are irrelevant for the span,
    // the span is appended to whatever primitive happens
    // to be available in the buffer.
    //

    PD3DI_RASTSPAN pSpan;
    UINT cSpans = 1;

    hr = AppendPrim();
    if (hr != D3D_OK)
    {
        return hr;
    }

    hr = AllocSpans(&cSpans, &pSpan);
    if (hr != D3D_OK)
    {
        return hr;
    }

    m_StpCtx.pPrim->uSpans++;

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE1(pV0->dvRHW))
    {
        NormalizePointRHW(pV0);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    // Remember flat color controlling vertex for setup.
    m_StpCtx.pFlatVtx = pFlatVtx;

    FillPointSpan(pV0, pSpan);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
    }

    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\primproc.cpp ===
//----------------------------------------------------------------------------
//
// primproc.cpp
//
// Miscellaneous PrimProcessor methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// PrimProcessor::BeginPrimSet
//
// Marks the start of a set of primitives that have the same vertex type.
// Computes attributes used from the current state and the vertex type.
//
//----------------------------------------------------------------------------

void
PrimProcessor::BeginPrimSet(D3DPRIMITIVETYPE PrimType,
                            RAST_VERTEX_TYPE VertType)
{
    // If state hasn't changed and the primitive and vertex types match the
    // ones we're already set up for there's no work to do.
    if ((m_uPpFlags & PPF_STATE_CHANGED) == 0 &&
        VertType == m_VertType &&
        PrimType == m_PrimType)
    {
        return;
    }

    m_StpCtx.uFlags &= ~PRIMSF_ALL;

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_STENCILENABLE])
    {
        m_StpCtx.uFlags |= PRIMSF_Z_USED;
    }

    if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
    {
        // Index is unused during copy mode texturing.
        if (m_StpCtx.pCtx->pdwRenderState
            [D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_COPY ||
            m_StpCtx.pCtx->cActTex == 0)
        {
            m_StpCtx.uFlags |= PRIMSF_DIDX_USED;
        }
    }
    else
    {
        // ATTENTION - Don't set these for copy mode texture?  Is
        // copy mode texture meaningful in RGB?
        m_StpCtx.uFlags |= PRIMSF_DIFF_USED;
        if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
        {
            m_StpCtx.uFlags |= PRIMSF_SPEC_USED;
        }
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_SHADEMODE] ==
        D3DSHADE_FLAT)
    {
        m_StpCtx.uFlags |= PRIMSF_FLAT_SHADED;
    }

    if (m_StpCtx.pCtx->cActTex > 0)
    {
        m_StpCtx.uFlags |= PRIMSF_TEX1_USED;
        DDASSERT((m_StpCtx.pCtx->pTexture[0]->uFlags & D3DI_SPANTEX_NON_POWER_OF_2) == 0);

        if (m_StpCtx.pCtx->cActTex > 1)
        {
            m_StpCtx.uFlags |= PRIMSF_TEX2_USED;
            DDASSERT((m_StpCtx.pCtx->pTexture[1]->uFlags & D3DI_SPANTEX_NON_POWER_OF_2) == 0);
        }
    }

    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
    {
        m_StpCtx.uFlags |= PRIMSF_PERSP_USED;
    }

    // Currently only tex1 can be mipmapped.
    if (((m_StpCtx.uFlags & PRIMSF_TEX1_USED) &&
        (PrimType == D3DPT_TRIANGLELIST ||
         PrimType == D3DPT_TRIANGLESTRIP ||
         PrimType == D3DPT_TRIANGLEFAN) &&
        (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FILLMODE]
         == D3DFILL_SOLID)) &&

        (((m_StpCtx.pCtx->pTexture[0]->cLOD >= 1) &&
        (m_StpCtx.pCtx->pTexture[0]->uMipFilter != D3DTFP_NONE)) ||
        // need LOD if we need to dynamically switch between different min
        // and mag filters
        (m_StpCtx.pCtx->pTexture[0]->uMinFilter !=
         m_StpCtx.pCtx->pTexture[0]->uMagFilter)))
    {
        m_StpCtx.uFlags |= PRIMSF_LOD_USED;
    }

    // select between min and mag filters for TEX2
    if (((m_StpCtx.uFlags & PRIMSF_TEX2_USED) &&
        (PrimType == D3DPT_TRIANGLELIST ||
         PrimType == D3DPT_TRIANGLESTRIP ||
         PrimType == D3DPT_TRIANGLEFAN) &&
        (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FILLMODE]
         == D3DFILL_SOLID)) &&

        (((m_StpCtx.pCtx->pTexture[1]->cLOD >= 1) &&
        (m_StpCtx.pCtx->pTexture[1]->uMipFilter != D3DTFP_NONE)) ||
        // need LOD if we need to dynamically switch between different min
        // and mag filters
        (m_StpCtx.pCtx->pTexture[1]->uMinFilter !=
         m_StpCtx.pCtx->pTexture[1]->uMagFilter)))
    {
        m_StpCtx.uFlags |= PRIMSF_LOD_USED;
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FOGENABLE])
    {
        // Note, if PWL_FOG is ever brought back to life, enabling
        // PRIMSF_GLOBAL_FOG_USED with no Z buffer will not trivially work
        // if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            switch (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE])
            {
            case D3DFOG_EXP:
            case D3DFOG_EXP2:
            case D3DFOG_LINEAR:
                m_StpCtx.uFlags |= PRIMSF_GLOBAL_FOG_USED;
#ifndef PWL_FOG
                // The span routines don't support table fog directly.
                // Instead table fog is computed per vertex and used to
                // set up local fog.
                m_StpCtx.uFlags |= PRIMSF_LOCAL_FOG_USED;
#endif
                break;
            default:
                m_StpCtx.uFlags |= PRIMSF_LOCAL_FOG_USED;
                break;
            }
        }
    }

    PFN_ADDATTRS *ppfnAddAttrsTable;
    PFN_ADDSCALEDATTRS *ppfnAddScaledAttrsTable;
    PFN_FILLSPANATTRS *ppfnFillSpanAttrsTable;

    if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
    {
        // Ramp does not support multitexture.
        RSASSERT((m_StpCtx.uFlags & PRIMSF_TEX2_USED) == 0);

        RSASSERT((PRIMSF_TEX1_USED | PRIMSF_DIDX_USED) == 0x14);

        // Derive a function table index from bits 2 and 4 of usage
        // information.
        // An alternative method would be to use bits 0-4 and have the
        // ramp information in the top 16 entries, but splitting the
        // ramp and RGB tables is cleaner and decouples the table sizes.
        // Decoupling is useful since the ramp possibilities are much
        // more limited so its table can be smaller.

        m_iAttrFnIdx =
            ((m_StpCtx.uFlags & PRIMSF_TEX1_USED) >> 2) |
            ((m_StpCtx.uFlags & PRIMSF_DIDX_USED) >> 3);

        ppfnAddAttrsTable = g_pfnRampAddFloatAttrsTable;
        ppfnAddScaledAttrsTable = g_pfnRampAddScaledFloatAttrsTable;
        ppfnFillSpanAttrsTable = g_pfnRampFillSpanFloatAttrsTable;
    }
    else
    {
        RSASSERT((PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED |
                  PRIMSF_TEX2_USED) == 0xf);

        // Derive a function table index from the lower four bits of
        // usage information.  The lower bits are deliberately chosen
        // to represent the more performance-sensitive cases while
        // the upper bits generally represent cases handled by generic
        // code.
        //
        // Even restricted to only four bits the index contains unimportant
        // and unreachable cases, such as specular without diffuse or
        // tex2 without tex1.  Tables indexed must account for this.

        m_iAttrFnIdx = m_StpCtx.uFlags & (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED |
                                          PRIMSF_TEX1_USED | PRIMSF_TEX2_USED);

        ppfnAddAttrsTable = g_pfnAddFloatAttrsTable;
        ppfnAddScaledAttrsTable = g_pfnAddScaledFloatAttrsTable;
        ppfnFillSpanAttrsTable = g_pfnFillSpanFloatAttrsTable;
    }

    //
    // These functions only depend on the index and so can be set here.
    // Other functions depend on per-triangle information and are set
    // later.
    //

    if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
    {
        // If any slow attrs are on or Z is off use the general functions.
        m_StpCtx.pfnAddScaledAttrs = AddScaledFloatAttrs_Any_Either;
#ifndef STEP_FIXED
        m_StpCtx.pfnAddAttrs = AddFloatAttrs_Any;
        m_StpCtx.pfnFillSpanAttrs = FillSpanFloatAttrs_Any_Either;
#endif
    }
    else
    {
        m_StpCtx.pfnAddScaledAttrs =
            ppfnAddScaledAttrsTable[m_iAttrFnIdx];
#ifndef STEP_FIXED
        m_StpCtx.pfnAddAttrs = ppfnAddAttrsTable[m_iAttrFnIdx];
        m_StpCtx.pfnFillSpanAttrs = ppfnFillSpanAttrsTable[m_iAttrFnIdx];
#endif
    }

    // Attribute beads can be set here.
    PFN_SETUPTRIATTR *ppfnSlot;

    ppfnSlot = &m_StpCtx.pfnTriSetupFirstAttr;
    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        if (m_StpCtx.pCtx->iZBitCount == 16)
        {
            *ppfnSlot = TriSetup_Z16;
        }
        else
        {
            *ppfnSlot = TriSetup_Z32;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupZEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_TEX1_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            *ppfnSlot = TriSetup_Persp_Tex1;
        }
        else
        {
            *ppfnSlot = TriSetup_Affine_Tex1;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupTex1End;
    }
    if (m_StpCtx.uFlags & PRIMSF_TEX2_USED)
    {
        // Code assumes that tex1 is enabled if tex2 is enabled.
        RSASSERT(m_StpCtx.uFlags & PRIMSF_TEX1_USED);

        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            *ppfnSlot = TriSetup_Persp_Tex2;
        }
        else
        {
            *ppfnSlot = TriSetup_Affine_Tex2;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupTex2End;
    }
    if (m_StpCtx.uFlags & PRIMSF_DIFF_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_DiffFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_Diff;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupDiffEnd;
    }
    else if (m_StpCtx.uFlags & PRIMSF_DIDX_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_DIdxFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_DIdx;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupDiffEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_SPEC_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_SpecFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_Spec;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupSpecEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        *ppfnSlot = TriSetup_Fog;
        ppfnSlot = &m_StpCtx.pfnTriSetupFogEnd;
    }
    *ppfnSlot = TriSetup_End;

    // Remember the primitive and vertex type and clear the state change bit.
    m_PrimType = PrimType;
    m_VertType = VertType;
    m_uPpFlags &= ~PPF_STATE_CHANGED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>

#include <d3dp.h>
#include <d3dhal.h>

#include <rast.h>
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

#include <dpf.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\sources.inc ===
TARGETNAME = rsetup
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

#C_DEFINES = $(C_DEFINES) -DSTEP_FIXED

SOURCES = \
        ..\attrs.cpp\
        ..\buffer.cpp\
        ..\line.cpp\
        ..\lstp.cpp\
        ..\point.cpp\
        ..\primproc.cpp\
        ..\rsdbg.cpp\
        ..\tri.cpp\
        ..\tstp.cpp\
        ..\walk.cpp

NTTARGETFILE0 = $(NTTARGETFILE0) \
        $O\attrs_mh.h\
        $O\tstp_mh.h\
        $O\walk_mh.h

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\rsdbg.hpp ===
//----------------------------------------------------------------------------
//
// rsdbg.hpp
//
// Setup debug definitions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RSDBG_HPP_
#define _RSDBG_HPP_

#include <cppdbg.hpp>

DBG_DECLARE_HEADER(RS);

#define RSDPF(Args)             DBG_DECLARE_DPF(RS, Args)
#define RSDPFM(Args)            DBG_DECLARE_DPFM(RS, Args)
#define RSASSERT(Exp)           DBG_DECLARE_ASSERT(RS, Exp)
#define RSASSERTMSG(Exp, Args)  DBG_DECLARE_ASSERTMSG(RS, Exp, Args)
#define RSVERIFY(Exp)           DBG_DECLARE_VERIFY(RS, Exp)
#define RSVERIFYMSG(Exp)        DBG_DECLARE_VERIFYMSG(RS, Exp, Args)
#define RSPROMPT(Args)          DBG_DECLARE_PROMPT(RS, Args)
#define RSGETFLAGS(Idx)         DBG_DECLARE_GETFLAGS(RS, Idx)
#define RSSETFLAGS(Idx, Value)  DBG_DECLARE_SETFLAGS(RS, Idx, Value)
#define RSHRCHK(Exp)            DBG_DECLARE_HRCHK(RS, Exp)
#define RSHRGO(Exp, Label)      DBG_DECLARE_HRGO(RS, Exp, Label)
#define RSHRERR(Exp)            DBG_DECLARE_HRERR(RS, Exp)
#define RSHRRET(Exp)            DBG_DECLARE_HRRET(RS, Exp)

#define RSM_TRIS                0x00000001
#define RSM_LINES               0x00000002
#define RSM_POINTS              0x00000004
#define RSM_Z                   0x00000008
#define RSM_DIFF                0x00000010
#define RSM_SPEC                0x00000020
#define RSM_OOW                 0x00000040
#define RSM_LOD                 0x00000080
#define RSM_TEX1                0x00000100
#define RSM_TEX2                0x00000200
#define RSM_FOG                 0x00000400
#define RSM_XCLIP               0x00000800
#define RSM_YCLIP               0x00001000
#define RSM_BUFFER              0x00002000
#define RSM_BUFPRIM             0x00004000
#define RSM_BUFSPAN             0x00008000
#define RSM_FLAGS               0x00010000
#define RSM_WALK                0x00020000
#define RSM_DIDX                0x00040000

#define RSU_BREAK_ON_RENDER_SPANS       0x00000001
#define RSU_MARK_SPAN_EDGES             0x00000002
#define RSU_CHECK_SPAN_EDGES            0x00000004
#define RSU_NO_RENDER_SPANS             0x00000008
#define RSU_FORCE_GENERAL_WALK          0x00000010
#define RSU_FORCE_PIXEL_SPANS           0x00000020
#define RSU_FLUSH_AFTER_PRIM            0x00000040

#endif // #ifndef _RSDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\tri.cpp ===
//----------------------------------------------------------------------------
//
// tri.cpp
//
// PrimProcessor top-level triangle methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

// Disallow fixed-point edge walkers to be chosen or not.
#if 0
#define DISALLOW_FIXED
#endif

// Maximum length of a PWL span.  Short to make piecewise-linear
// approximation more accurate.
#define MAX_PWL_SPAN_LEN        16
// Maximum normal span length.
#define MAX_SPAN_LEN            256

//----------------------------------------------------------------------------
//
// PrimProcessor::SetTriFunctions
//
// Set up function pointers for triangle processing.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::SetTriFunctions(void)
{
#if DBG
    if ((RSGETFLAGS(DBG_USER_FLAGS) & RSU_FORCE_PIXEL_SPANS) == 0)
#else
    if ((m_StpCtx.uFlags & TRIF_RASTPRIM_OVERFLOW) == 0)
#endif
    {
        // Valid deltas.  If mipmapping or global fog is on then
        // only allow short subspans so that they can be done
        // reasonably accurately via piecewise linear interpolation.
#ifdef PWL_FOG
        if (m_StpCtx.uFlags & (PRIMSF_LOD_USED | PRIMSF_GLOBAL_FOG_USED))
#else
        if (m_StpCtx.uFlags & PRIMSF_LOD_USED)
#endif
        {
            m_StpCtx.cMaxSpan = MAX_PWL_SPAN_LEN;
        }
        else
        {
            // No mipmapping so we can handle much larger spans.
            // Color values only have 8 bits of fraction so
            // we still need to worry about error accumulation.
            // Cut long spans to cap accumulated error.
            m_StpCtx.cMaxSpan = MAX_SPAN_LEN;
        }
    }
    else
    {
        // Invalid deltas.  There's no way to communicate deltas to
        // the span routines so chop spans into pixels.
        // This case can only occur with very narrow triangles so
        // this isn't as expensive as it might seem at first.
        m_StpCtx.cMaxSpan = 1;
    }

    BOOL bFixed = FALSE;

#ifdef STEP_FIXED
    // No ramp support.
    RSASSERT(m_StpCtx.pCtx->BeadSet != D3DIBS_RAMP);
#endif

    if ((m_StpCtx.uFlags & PRIMF_TRIVIAL_ACCEPT_X) &&
#if DBG
        (RSGETFLAGS(DBG_USER_FLAGS) & RSU_FORCE_GENERAL_WALK) == 0 &&
#endif
        m_iXWidth <= m_StpCtx.cMaxSpan)
    {
        if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
        {
            // If any slow attrs are on or Z is off use the general
            // function.
            m_StpCtx.pfnWalkTrapSpans = WalkTrapEitherSpans_Any_NoClip;
        }
#if defined(STEP_FIXED) && !defined(DISALLOW_FIXED)
        // Attribute conversion can be a dominant cost for
        // triangles with very few spans, so avoid using fixed point
        // edge walking for them.
        else if ((m_StpCtx.uFlags & PRIMF_FIXED_OVERFLOW) == 0 &&
                 m_uHeight20 > 3)
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnWalkTrapFixedSpansNoClipTable[m_iAttrFnIdx];
            bFixed = TRUE;
        }
#endif
        else if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnRampWalkTrapFloatSpansNoClipTable[m_iAttrFnIdx];
        }
        else
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnWalkTrapFloatSpansNoClipTable[m_iAttrFnIdx];
        }
    }
    else
    {
        // No special cases, just a general function.
        m_StpCtx.pfnWalkTrapSpans = WalkTrapEitherSpans_Any_Clip;
    }

#ifdef STEP_FIXED
    if (bFixed)
    {
        RSASSERT((m_StpCtx.uFlags & PRIMSF_SLOW_USED) == PRIMSF_Z_USED);

        m_StpCtx.pfnAddAttrs = g_pfnAddFixedAttrsTable[m_iAttrFnIdx];
        m_StpCtx.pfnFillSpanAttrs =
            g_pfnFillSpanFixedAttrsTable[m_iAttrFnIdx];

        PFN_FLOATATTRSTOFIXED pfnFloatAttrsToFixed;

        pfnFloatAttrsToFixed = g_pfnFloatAttrsToFixedTable[m_iAttrFnIdx];
        pfnFloatAttrsToFixed(&m_StpCtx.Attr, &m_StpCtx.Attr);
        pfnFloatAttrsToFixed(&m_StpCtx.DAttrNC, &m_StpCtx.DAttrNC);
        pfnFloatAttrsToFixed(&m_StpCtx.DAttrCY, &m_StpCtx.DAttrCY);
    }
    else
    {
        if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
        {
            // If any slow attrs are on or Z is off use the general functions.
            m_StpCtx.pfnAddAttrs = AddFloatAttrs_Any;
            m_StpCtx.pfnFillSpanAttrs = FillSpanFloatAttrs_Any_Either;
        }
        else
        {
            m_StpCtx.pfnAddAttrs = g_pfnAddFloatAttrsTable[m_iAttrFnIdx];
            m_StpCtx.pfnFillSpanAttrs =
                g_pfnFillSpanFloatAttrsTable[m_iAttrFnIdx];
        }
    }

    // Scaled attr functions already set since they only depend on
    // m_iAttrFnIdx.
#else // STEP_FIXED
    // All attr functions already set since they only depend on
    // m_iAttrFnIdx.
#endif // STEP_FIXED
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Tri
//
// Calls triangle setup.  If a triangle is produced by setup
// this routine walks edges, generating spans into the buffer.
//
//----------------------------------------------------------------------------
HRESULT
PrimProcessor::Tri(LPD3DTLVERTEX pV0,
                   LPD3DTLVERTEX pV1,
                   LPD3DTLVERTEX pV2)
{
    HRESULT hr;


    hr = D3D_OK;

    if (m_StpCtx.pCtx->pfnRampOld)
    {
        m_StpCtx.pCtx->pfnRampOldTri(m_StpCtx.pCtx, pV0, pV1, pV2);

        return hr;
    }

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != D3D_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V0\n"));
        return hr;
    }
    hr = ValidateVertex(pV1);
    if (hr != D3D_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V1\n"));
        return hr;
    }
    hr = ValidateVertex(pV2);
    if (hr != D3D_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V2\n"));
        return hr;
    }
#endif

    // Clear per-triangle flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | TRIF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X\n",
            m_uPpFlags, m_StpCtx.uFlags));

    RSDPFM((RSM_TRIS, "Tri\n"));
    RSDPFM((RSM_TRIS, "  V0 (%f,%f,%f)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ));
    RSDPFM((RSM_TRIS, "  V1 (%f,%f,%f)\n",
            pV1->dvSX, pV1->dvSY, pV1->dvSZ));
    RSDPFM((RSM_TRIS, "  V2 (%f,%f,%f)\n",
            pV2->dvSX, pV2->dvSY, pV2->dvSZ));

    GET_PRIM();

    // Set up the triangle and see if anything was produced.
    // Triangles may not be produced due to:
    //   Face culling.
    //   Trivial rejection against the clip rect.
    //   Zero pixel coverage.
    if (TriSetup(pV0, pV1, pV2))
    {
        // Compute initial buffer pointers for the scanline.
        m_StpCtx.Attr.pSurface = m_StpCtx.pCtx->pSurfaceBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;
        if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            m_StpCtx.Attr.pZ = m_StpCtx.pCtx->pZBits +
                m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
                m_StpCtx.iY * m_StpCtx.pCtx->iZStride;
        }

        // uSpans and pNext have already been initialized.

        SetTriFunctions();
        COMMIT_PRIM(FALSE);

        if (m_uHeight10 > 0)
        {
            hr = m_StpCtx.pfnWalkTrapSpans(m_uHeight10, &m_StpCtx.X10,
                                           &m_StpCtx, m_uHeight21 > 0);
            if (hr != D3D_OK)
            {
                return hr;
            }
        }

        if (m_uHeight21 > 0)
        {
            hr = m_StpCtx.pfnWalkTrapSpans(m_uHeight21, &m_StpCtx.X21,
                                           &m_StpCtx, FALSE);
            if (hr != D3D_OK)
            {
                return hr;
            }
        }

#if DBG
        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_FLUSH_AFTER_PRIM)
        {
            Flush();
        }
#endif
    }

    return hr;
}

#if DBG
//----------------------------------------------------------------------------
//
// PrimProcessor::ValidateVertex
//
// Checks the ranges of verifiable contents of vertex, to avoid setting up
// garbage.
//
//----------------------------------------------------------------------------
inline HRESULT PrimProcessor::ValidateVertex(LPD3DTLVERTEX pV)
{
    // from the OptSwExtCaps.dvGuardBand caps.
    if ((pV->sx < -32768.f) || (pV->sx > 32767.f) ||
        (pV->sy < -32768.f) || (pV->sy > 32767.f))
    {
        RSDPF(("ValidateVertex: x,y out of guardband range (%f,%f)\n",pV->sx,pV->sy));
        return DDERR_INVALIDPARAMS;
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
    {

        // Allow a little slack for those generating triangles exactly on the
        // depth limit.  Needed for Quake.
        if ((pV->sz < -0.00015f) || (pV->sz > 1.00015f))
        {
            RSDPF(("ValidateVertex: z out of range (%f)\n",pV->sz));
            return DDERR_INVALIDPARAMS;
        }
    }

    if (m_StpCtx.pCtx->cActTex > 0)
    {
        if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
        {
            if (pV->rhw <= 0 )
            {
                RSDPF(("ValidateVertex: rhw out of range (%f)\n",pV->rhw));
                return DDERR_INVALIDPARAMS;
            }
        }

        // from OptSwExtCaps.dwMaxTextureRepeat cap.
        if ((pV->tu > 256.0F) || (pV->tu < -256.0F) ||
            (pV->tv > 256.0F) || (pV->tv < -256.0F))
        {
            RSDPF(("ValidateVertex: tu,tv out of range (%f,%f)\n",pV->tu,pV->tv));
            return DDERR_INVALIDPARAMS;
        }

        if (m_StpCtx.pCtx->cActTex > 1)
        {
            PRAST_GENERIC_VERTEX pGV = (PRAST_GENERIC_VERTEX)pV;
            if ((pGV->tu2 > 256.0F) || (pGV->tu2 < -256.0F) ||
                (pGV->tv2 > 256.0F) || (pGV->tv2 < -256.0F))
            {
                RSDPF(("ValidateVertex: tu2,tv2 out of range (%f,%f)\n",pGV->tu2,pGV->tv2));
                return DDERR_INVALIDPARAMS;
            }
        }
    }

    return D3D_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\rsdbg.cpp ===
//----------------------------------------------------------------------------
//
// rsdbg.cpp
//
// Setup debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

static DebugModuleFlags g_RastSetupOutputFlags[] =
{
    DBG_DECLARE_MODFLAG(RSM, TRIS),
    DBG_DECLARE_MODFLAG(RSM, LINES),
    DBG_DECLARE_MODFLAG(RSM, POINTS),
    DBG_DECLARE_MODFLAG(RSM, Z),
    DBG_DECLARE_MODFLAG(RSM, DIFF),
    DBG_DECLARE_MODFLAG(RSM, SPEC),
    DBG_DECLARE_MODFLAG(RSM, OOW),
    DBG_DECLARE_MODFLAG(RSM, LOD),
    DBG_DECLARE_MODFLAG(RSM, TEX1),
    DBG_DECLARE_MODFLAG(RSM, TEX2),
    DBG_DECLARE_MODFLAG(RSM, XCLIP),
    DBG_DECLARE_MODFLAG(RSM, YCLIP),
    DBG_DECLARE_MODFLAG(RSM, BUFFER),
    DBG_DECLARE_MODFLAG(RSM, BUFPRIM),
    DBG_DECLARE_MODFLAG(RSM, BUFSPAN),
    DBG_DECLARE_MODFLAG(RSM, FLAGS),
    DBG_DECLARE_MODFLAG(RSM, WALK),
    DBG_DECLARE_MODFLAG(RSM, DIDX),
    0, NULL,
};
static DebugModuleFlags g_RastSetupUserFlags[] =
{
    DBG_DECLARE_MODFLAG(RSU, BREAK_ON_RENDER_SPANS),
    DBG_DECLARE_MODFLAG(RSU, MARK_SPAN_EDGES),
    DBG_DECLARE_MODFLAG(RSU, CHECK_SPAN_EDGES),
    DBG_DECLARE_MODFLAG(RSU, NO_RENDER_SPANS),
    DBG_DECLARE_MODFLAG(RSU, FORCE_GENERAL_WALK),
    DBG_DECLARE_MODFLAG(RSU, FORCE_PIXEL_SPANS),
    0, NULL,
};
DBG_DECLARE_ONCE(RastSetup, RS,
                 g_RastSetupOutputFlags, 0,
                 g_RastSetupUserFlags, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\walk.cpp ===
//----------------------------------------------------------------------------
//
// walk.cpp
//
// TriProcessor edge walking methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// WalkTrapEitherSpans_Any_Clip
//
// Walks the given number of spans, using edge 0 - 2 as the attribute
// edge and the given X and DXDY for the other edge.
// Spans are clipped in X against the current clip rect.
//
// The spans can be split into subspans if required.  cPixSplit indicates
// the maximum length span that should be recorded.  Any longer spans will
// be cut into multiple span segments.
//
// Calls attribute handler functions so all attributes are supported.
// Attributes are never touched directly so both fixed and float are supported.
//
//----------------------------------------------------------------------------

HRESULT FASTCALL
WalkTrapEitherSpans_Any_Clip(UINT uSpans, PINTCARRYVAL pXOther,
                             PSETUPCTX pStpCtx, BOOL bAdvanceLast)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    INT cTotalPix;
    INT cPix;
    INT uX, uXO;
    BOOL b20Valid;
    UINT uSpansAvail;

    RSASSERT(uSpans > 0);
    
    hr = D3D_OK;
    uSpansAvail = 0;
    
    for (;;)
    {
        //
        // Clip span and compute length.  No attributes need to be
        // updated here because attributes have already been moved
        // inside the clip boundary.
        //

        uX = pStpCtx->X20.iV;
        uXO = pXOther->iV;
        b20Valid = TRUE;

        RSDPFM((RSM_WALK, "Full span at Y %d, %d - %d\n",
                pStpCtx->iY, uX,
                (pStpCtx->uFlags & TRIF_X_DEC) ? uXO + 1 : uXO - 1));
        
        if (pStpCtx->uFlags & TRIF_X_DEC)
        {
            if (uX >= pStpCtx->pCtx->Clip.right)
            {
                b20Valid = FALSE;
                uX = pStpCtx->pCtx->Clip.right - 1;
            }
            else if (uX < pStpCtx->pCtx->Clip.left &&
                     pStpCtx->X20.iCY <= 0)
            {
                // Right edge has crossed the left clip boundary
                // travelling left so the remainder of the triangle
                // will not be visible.
                goto EH_Exit;
            }


            // -1 because this edge is displaced by one.
            if (uXO < pStpCtx->pCtx->Clip.left - 1)
            {
                uXO = pStpCtx->pCtx->Clip.left - 1;
            }

            cTotalPix = uX - uXO;
        }
        else
        {
            if (uX < pStpCtx->pCtx->Clip.left)
            {
                b20Valid = FALSE;
                uX = pStpCtx->pCtx->Clip.left;
            }
            else if (uX >= pStpCtx->pCtx->Clip.right &&
                     pStpCtx->X20.iCY >= 0)
            {
                // Left edge has crossed the right clip boundary
                // travelling right so the remainder of the triangle
                // will not be visible.
                goto EH_Exit;
            }

            if (uXO > pStpCtx->pCtx->Clip.right)
            {
                uXO = pStpCtx->pCtx->Clip.right;
            }

            cTotalPix = uXO - uX;
        }

        if (cTotalPix > 0)
        {
            ATTRSET Attr;
            PATTRSET pAttr;

            // Start without PWL support since the first iteration doesn't
            // have precomputed values.
            pStpCtx->uPwlFlags = 0;
            
            pAttr = &pStpCtx->Attr;
        
            for (;;)
            {
                if (uSpansAvail == 0)
                {
                    // We don't really have a good number to request
                    // since uSpans could result in any number of span
                    // fragments after dicing.  Using uSpans is OK
                    // as long as uSpans is relatively large, but if
                    // uSpans gets small and there's a lot of dicing then
                    // it would result in excessive AllocSpans calls.
                    // Try to avoid this problem by lower-bounding the
                    // request.  Any excess spans will be given back
                    // at the end.
                    uSpansAvail = min(8, uSpans);
                    hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                    if (hr != D3D_OK)
                    {
                        // uSpansAvail is set to zero on failure.
                        goto EH_Exit;
                    }
                }
                else
                {
                    pSpan++;
                }
                uSpansAvail--;
                pStpCtx->pPrim->uSpans++;

                // Split up remaining pixels if necessary.
                cPix = min(cTotalPix, pStpCtx->cMaxSpan);

                pSpan->uPix = (UINT16)cPix;
                pSpan->uX = (UINT16)uX;
                pSpan->uY = (UINT16)pStpCtx->iY;

                RSDPFM((RSM_WALK, "  Seg at Y %d, X %d, %c%d pix (%d, %d)\n",
                        pStpCtx->iY, uX,
                        (pStpCtx->uFlags & TRIF_X_DEC) ? '-' : '+',
                        cPix, cTotalPix, pStpCtx->cMaxSpan));

                pStpCtx->pfnFillSpanAttrs(pAttr, pSpan, pStpCtx, cPix);

                cTotalPix -= cPix;
                if (cTotalPix <= 0)
                {
                    break;
                }

                // There are still pixels left in the span so the loop's
                // going to go around again.  Update all the attribute
                // values by cPix dX steps.
                //
                // We don't want to update the real edge attributes so we
                // need to work with a copy.  We do this lazily to
                // avoid the data movement for the normal case where
                // the span isn't split.
                if (pAttr == &pStpCtx->Attr)
                {
                    Attr = pStpCtx->Attr;
                    pAttr = &Attr;
                }

                if (pStpCtx->uFlags & TRIF_X_DEC)
                {
                    uX -= cPix;
                }
                else
                {
                    uX += cPix;
                }
                pStpCtx->pfnAddScaledAttrs(pAttr, &pStpCtx->DAttrDX,
                                           pStpCtx, cPix);
            }
        }

        uSpans--;

        // If this is truly the last span of the triangle then we can stop,
        // but if it's just the last span of the top trapezoid then we
        // still need to advance the attributes on the long edge so
        // they're correct for the next trapzoid's first span.
        if (!bAdvanceLast && uSpans == 0)
        {
            break;
        }

        //
        // Advance long edge and all attributes.
        //

        pStpCtx->iY++;
        
        PATTRSET pDelta;

        pStpCtx->X20.iFrac += pStpCtx->X20.iDFrac;
        if (pStpCtx->X20.iFrac < 0)
        {
            // Carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iCY;
            pStpCtx->X20.iFrac &= 0x7fffffff;
            pDelta = &pStpCtx->DAttrCY;
        }
        else
        {
            // No-carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iNC;
            pDelta = &pStpCtx->DAttrNC;
        }

        // See if the edge has crossed a clip boundary.
        cPix = 0;
        if (b20Valid)
        {
            // Always take a normal step.
            pStpCtx->pfnAddAttrs(&pStpCtx->Attr, pDelta, pStpCtx);

            // See if the edge crossed out of the clip rect and if so,
            // how far.
            if (pStpCtx->uFlags & TRIF_X_DEC)
            {
                if (pStpCtx->X20.iV >= pStpCtx->pCtx->Clip.right)
                {
                    cPix = pStpCtx->X20.iV - (pStpCtx->pCtx->Clip.right - 1);
                }
            }
            else
            {
                if (pStpCtx->X20.iV < pStpCtx->pCtx->Clip.left)
                {
                    cPix = pStpCtx->pCtx->Clip.left - pStpCtx->X20.iV;
                }
            }
        }
        else
        {
            // Always step in Y.
            pStpCtx->pfnAddAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDY, pStpCtx);

            // See if the edge crossed into validity and if so,
            // how far.
            if (pStpCtx->uFlags & TRIF_X_DEC)
            {
                if (pStpCtx->X20.iV < pStpCtx->pCtx->Clip.right - 1)
                {
                    cPix = (pStpCtx->pCtx->Clip.right - 1) - pStpCtx->X20.iV;
                }
            }
            else
            {
                if (pStpCtx->X20.iV > pStpCtx->pCtx->Clip.left)
                {
                    cPix = pStpCtx->X20.iV - pStpCtx->pCtx->Clip.left;
                }
            }
        }

        if (cPix > 0)
        {
            // The edge made a validity transition.  Either the
            // attributes are sitting back at the edge of validity and
            // need to move forward or they've left the clip rect and
            // need to move back.  Either way, cPix has the
            // number of pixels to move in X.
            
            // No precomputed values.
            pStpCtx->uPwlFlags = 0;
            pStpCtx->pfnAddScaledAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDX,
                                       pStpCtx, cPix);
        }

        // Long edge updating is done so we can always stop here if we're out
        // of spans.
        if (uSpans == 0)
        {
            break;
        }

        // Advance other edge.
        pXOther->iFrac += pXOther->iDFrac;
        if (pXOther->iFrac < 0)
        {
            // Carry step.
            pXOther->iV += pXOther->iCY;
            pXOther->iFrac &= 0x7fffffff;
        }
        else
        {
            // No-carry step.
            pXOther->iV += pXOther->iNC;
        }
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
// WalkTrapEitherSpans_Any_NoClip
//
// WalkTrapSpans specialized for the trivial-accept clipping case.
// Span dicing is also unsupported.
// Calls attribute handler functions so all attributes are supported.
// Attributes are never touched directly so both fixed and float are supported.
//
//----------------------------------------------------------------------------

HRESULT FASTCALL
WalkTrapEitherSpans_Any_NoClip(UINT uSpans, PINTCARRYVAL pXOther,
                               PSETUPCTX pStpCtx, BOOL bAdvanceLast)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    PINTCARRYVAL pXLeft, pXRight;
    UINT uSpansAvail;

    RSASSERT(uSpans > 0);
    
    hr = D3D_OK;

    if (pStpCtx->uFlags & TRIF_X_DEC)
    {
        pXLeft = pXOther;
        pXRight = &pStpCtx->X20;
    }
    else
    {
        pXLeft = &pStpCtx->X20;
        pXRight = pXOther;
    }

    uSpansAvail = 0;

    for (;;)
    {
        if (pXRight->iV > pXLeft->iV)
        {
            if (uSpansAvail == 0)
            {
                uSpansAvail = uSpans;
                hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                if (hr != D3D_OK)
                {
                    // uSpansAvail is set to zero on failure.
                    goto EH_Exit;
                }
            }
            else
            {
                pSpan++;
            }
            uSpansAvail--;
            pStpCtx->pPrim->uSpans++;

            pSpan->uPix = (UINT16)(pXRight->iV - pXLeft->iV);
            pSpan->uX = (UINT16)pStpCtx->X20.iV;
            pSpan->uY = (UINT16)pStpCtx->iY;

            RSDPFM((RSM_WALK, "Span at Y %d, X %d, %c%d pix\n",
                    pStpCtx->iY, pSpan->uX,
                    (pStpCtx->uFlags & TRIF_X_DEC) ? '-' : '+',
                    pSpan->uPix));

            pStpCtx->uPwlFlags = 0;
            pStpCtx->pfnFillSpanAttrs(&pStpCtx->Attr, pSpan, pStpCtx, 1);
        }

        uSpans--;

        // If this is truly the last span of the triangle then we can stop,
        // but if it's just the last span of the top trapezoid then we
        // still need to advance the attributes on the long edge so
        // they're correct for the next trapzoid's first span.
        if (!bAdvanceLast && uSpans == 0)
        {
            break;
        }

        //
        // Advance long edge and all attributes.
        //

        pStpCtx->iY++;
        
        PATTRSET pDelta;

        pStpCtx->X20.iFrac += pStpCtx->X20.iDFrac;
        if (pStpCtx->X20.iFrac < 0)
        {
            // Carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iCY;
            pStpCtx->X20.iFrac &= 0x7fffffff;
            pDelta = &pStpCtx->DAttrCY;
        }
        else
        {
            // No-carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iNC;
            pDelta = &pStpCtx->DAttrNC;
        }

        pStpCtx->pfnAddAttrs(&pStpCtx->Attr, pDelta, pStpCtx);

        // Long edge updating is done so we can always stop here if we're out
        // of spans.
        if (uSpans == 0)
        {
            break;
        }

        // Advance other edge.
        pXOther->iFrac += pXOther->iDFrac;
        if (pXOther->iFrac < 0)
        {
            // Carry step.
            pXOther->iV += pXOther->iCY;
            pXOther->iFrac &= 0x7fffffff;
        }
        else
        {
            // No-carry step.
            pXOther->iV += pXOther->iNC;
        }
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }
    
    return hr;
}

//
// Tables of edge walkers.
// Indexing is with the low four TRISF_*_USED bits.
//

#if !defined(_X86_) || defined(X86_CPP_WALKTRAPSPANS)
#define WalkTrapFloatSpans_Z_Diff_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Spec_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Tex1_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Spec_Tex1_NoClip \
    WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Tex1_Tex2_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_DIdx_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_DIdx_Tex1_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Tex1_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Spec_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Tex1_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Spec_Tex1_NoClip \
    WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Tex1_Tex2_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_DIdx_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_DIdx_Tex1_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Tex1_NoClip WalkTrapEitherSpans_Any_NoClip
#endif

// Trivial accept walkers.
PFN_WALKTRAPSPANS g_pfnWalkTrapFloatSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    WalkTrapFloatSpans_Z_Diff_NoClip,                   /* 1: -2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    WalkTrapFloatSpans_Z_Diff_Spec_NoClip,              /* 3: -2 -1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    WalkTrapFloatSpans_Z_Diff_Tex1_NoClip,              /* 5: -2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    WalkTrapFloatSpans_Z_Diff_Spec_Tex1_NoClip,         /* 7: -2 +1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    WalkTrapFloatSpans_Z_Tex1_Tex2_NoClip,              /* C: +2 +1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_WALKTRAPSPANS g_pfnWalkTrapFixedSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    WalkTrapFixedSpans_Z_Diff_NoClip,                   /* 1: -2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    WalkTrapFixedSpans_Z_Diff_Spec_NoClip,              /* 3: -2 -1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    WalkTrapFixedSpans_Z_Diff_Tex1_NoClip,              /* 5: -2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    WalkTrapFixedSpans_Z_Diff_Spec_Tex1_NoClip,         /* 7: -2 +1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    WalkTrapFixedSpans_Z_Tex1_Tex2_NoClip,              /* C: +2 +1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#endif

// Ramp mode trivial accept walkers.
PFN_WALKTRAPSPANS g_pfnRampWalkTrapFloatSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -I -1 */
    WalkTrapFloatSpans_Z_Tex1_NoClip,                   /* 1: -I +1 */
    WalkTrapFloatSpans_Z_DIdx_NoClip,                   /* 2: +I -1 */
    WalkTrapFloatSpans_Z_DIdx_Tex1_NoClip,              /* 3: +I +1 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\tstp.cpp ===
//----------------------------------------------------------------------------
//
// setup.cpp
//
// PrimProcessor setup methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// MINMAX3
//
// Computes the min and max of three integer values.
//
//----------------------------------------------------------------------------

#define MINMAX3(iV0, iV1, iV2, iMin, iMax)                                    \
    if ((iV0) <= (iV1))                                                       \
    {                                                                         \
        if ((iV1) <= (iV2))                                                   \
        {                                                                     \
            (iMin) = (iV0);                                                   \
            (iMax) = (iV2);                                                   \
        }                                                                     \
        else if ((iV0) <= (iV2))                                              \
        {                                                                     \
            (iMin) = (iV0);                                                   \
            (iMax) = (iV1);                                                   \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            (iMin) = (iV2);                                                   \
            (iMax) = (iV1);                                                   \
        }                                                                     \
    }                                                                         \
    else if ((iV1) <= (iV2))                                                  \
    {                                                                         \
        (iMin) = (iV1);                                                       \
        if ((iV0) <= (iV2))                                                   \
        {                                                                     \
            (iMax) = (iV2);                                                   \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            (iMax) = (iV0);                                                   \
        }                                                                     \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        (iMin) = (iV2);                                                       \
        (iMax) = (iV0);                                                       \
    }

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
//
// ATTENTION Just wipe this out for now.  Need a test for W too close to
// zero to avoid numerical problems.
//#define NEEDS_NORMALIZE3(fV0, fV1, fV2) \
//    ((ASUINT32(fV0) | ASUINT32(fV1) | ASUINT32(fV2)) > INT32_FLOAT_ONE)

#define NEEDS_NORMALIZE3(fV0, fV1, fV2) \
    (1)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizeTriRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function ensures that
// the RHWs are in the proper range by finding the largest one and
// scaling all of them down by it.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizeTriRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                               LPD3DTLVERTEX pV2)
{
    // Save original values.
    m_dvV0RHW = pV0->dvRHW;
    m_dvV1RHW = pV1->dvRHW;
    m_dvV2RHW = pV2->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW) || 
        FLOAT_LTZ(pV1->dvRHW) || 
        FLOAT_LTZ(pV2->dvRHW))
    {
        RSDPF(("Triangle RHW out of range %f,%f,%f\n",
               pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
    }
#endif

    // Find bounds and compute scale.
    FLOAT fMax;

    if (pV0->dvRHW < pV1->dvRHW)
    {
        if (pV1->dvRHW < pV2->dvRHW)
        {
            fMax = pV2->dvRHW;
        }
        else if (pV0->dvRHW < pV2->dvRHW)
        {
            fMax = pV1->dvRHW;
        }
        else
        {
            fMax = pV1->dvRHW;
        }
    }
    else if (pV1->dvRHW < pV2->dvRHW)
    {
        if (pV0->dvRHW < pV2->dvRHW)
        {
            fMax = pV2->dvRHW;
        }
        else
        {
            fMax = pV0->dvRHW;
        }
    }
    else
    {
        fMax = pV0->dvRHW;
    }

    FLOAT fRHWScale;

    fRHWScale = NORMALIZED_RHW_MAX / fMax;

    // Scale all values by scaling factor.
    pV0->dvRHW = pV0->dvRHW * fRHWScale;
    pV1->dvRHW = pV1->dvRHW * fRHWScale;
    pV2->dvRHW = pV2->dvRHW * fRHWScale;

#ifdef DBG_RHW_NORM
    RSDPF(("%f,%f,%f - %f,%f,%f\n",
           m_dvV0RHW, m_dvV1RHW, m_dvV2RHW,
           pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
#endif
}

//----------------------------------------------------------------------------
//
// PrimProcessor::TriSetup
//
// Takes three vertices and does triangle setup, filling in both a
// primitive structure for the triangle and a span structure for the first
// span.  All internal intermediates and DY values are computed.
//
// Uses the current D3DI_RASTPRIM and D3DI_RASTSPAN so these pointers must
// be valid before calling this routine.
//
// Returns whether the triangle was kept or not.  Culled triangles return
// FALSE.
//
//----------------------------------------------------------------------------

BOOL
PrimProcessor::TriSetup(LPD3DTLVERTEX pV0,
                        LPD3DTLVERTEX pV1,
                        LPD3DTLVERTEX pV2)
{
    // Preserve original first vertex for flat shading reference.
    m_StpCtx.pFlatVtx = pV0;

    //
    // Sort vertices in Y.
    // This can cause ordering changes from the original vertex set
    // so track reversals.
    //
    // Determinant computation and culling could be done before this.
    // Doing so causes headaches with computing deltas up front, though,
    // because the edges may change during sorting.
    //

    LPD3DTLVERTEX pVTmp;
    UINT uReversed;

    uReversed = 0;
    if (pV0->dvSY <= pV1->dvSY)
    {
        if (pV1->dvSY <= pV2->dvSY)
        {
            // Sorted.
        }
        else if (pV0->dvSY <= pV2->dvSY)
        {
            // Sorted order is 0 2 1.
            pVTmp = pV1;
            pV1 = pV2;
            pV2 = pVTmp;
            uReversed = 1;
        }
        else
        {
            // Sorted order is 2 0 1.
            pVTmp = pV0;
            pV0 = pV2;
            pV2 = pV1;
            pV1 = pVTmp;
        }
    }
    else if (pV1->dvSY < pV2->dvSY)
    {
        if (pV0->dvSY <= pV2->dvSY)
        {
            // Sorted order is 1 0 2.
            pVTmp = pV0;
            pV0 = pV1;
            pV1 = pVTmp;
            uReversed = 1;
        }
        else
        {
            // Sorted order is 1 2 0.
            pVTmp = pV0;
            pV0 = pV1;
            pV1 = pV2;
            pV2 = pVTmp;
        }
    }
    else
    {
        // Sorted order is 2 1 0.
        pVTmp = pV0;
        pV0 = pV2;
        pV2 = pVTmp;
        uReversed = 1;
    }

    FLOAT fX0 = pV0->dvSX;
    FLOAT fX1 = pV1->dvSX;
    FLOAT fX2 = pV2->dvSX;
    FLOAT fY0 = pV0->dvSY;
    FLOAT fY1 = pV1->dvSY;
    FLOAT fY2 = pV2->dvSY;

    //
    // Compute x,y deltas.
    //
    m_StpCtx.fDX10 = fX1 - fX0;
    m_StpCtx.fDX20 = fX2 - fX0;
    m_StpCtx.fDY10 = fY1 - fY0;
    m_StpCtx.fDY20 = fY2 - fY0;

    //
    // Compute determinant and do culling.
    //
    FLOAT fDet;

    fDet = m_StpCtx.fDX20 * m_StpCtx.fDY10 - m_StpCtx.fDX10 * m_StpCtx.fDY20;
    if (FLOAT_EQZ(fDet))
    {
        // No area, so bail out
        return FALSE;
    }

    // Get sign of determinant.
    UINT uDetCcw = FLOAT_GTZ(fDet) ? 1 : 0;

    // If culling is off the cull sign to check against is set to a
    // value that can't be matched so this single check is sufficient
    // for all three culling cases.
    //
    // Fold in sign reversal here rather than in uDetCcw because
    // we need the true sign later to determine whether the long edge is
    // to the left or the right.
    if ((uDetCcw ^ uReversed) == m_StpCtx.pCtx->uCullFaceSign)
    {
        return FALSE;
    }

    // Snap bounding vertex Y's to pixel centers and check for trivial reject.

    m_StpCtx.iY = ICEILF(fY0);
    m_iY2 = ICEILF(fY2);

    if (m_StpCtx.iY >= m_StpCtx.pCtx->Clip.bottom ||
        m_iY2 <= m_StpCtx.pCtx->Clip.top)
    {
        return FALSE;
    }

    INT iX0 = ICEILF(fX0);
    INT iX1 = ICEILF(fX1);
    INT iX2 = ICEILF(fX2);

    // Start 2 - 0 edge DXDY divide so that it's overlapped with the
    // integer processing done during X clip checking.  The assumption
    // is that it's nearly zero cost when overlapped so it's worth
    // it to start it even when the clip check rejects the triangle.
    FLOAT fDX20, fDY20, fDXDY20;

    // Need to use stack variables so the assembly can understand the
    // address.
    fDX20 = m_StpCtx.fDX20;
    fDY20 = m_StpCtx.fDY20;
    FLD_BEGIN_DIVIDE(fDX20, fDY20, fDXDY20);

    // Computing the X triangle bounds involves quite a few operations,
    // but it allows for both trivial rejection and trivial acceptance.
    // Given that guard band clipping can lead to a lot of trivial rejections
    // and that there will usually be a lot of trivial acceptance cases,
    // the work is worth it.

    INT iMinX, iMaxX;
    BOOL bXAccept;

    MINMAX3(iX0, iX1, iX2, iMinX, iMaxX);

    m_iXWidth = iMaxX - iMinX;

    // Use X bounds for trivial reject and accept.
    if (iMinX >= m_StpCtx.pCtx->Clip.right ||
        iMaxX <= m_StpCtx.pCtx->Clip.left ||
        m_iXWidth <= 0)
    {
        bXAccept = FALSE;
    }
    else
    {
        if (iMinX >= m_StpCtx.pCtx->Clip.left &&
            iMaxX <= m_StpCtx.pCtx->Clip.right)
        {
            m_StpCtx.uFlags |= PRIMF_TRIVIAL_ACCEPT_X;
        }
        else
        {
            RSDPFM((RSM_XCLIP, "XClip bounds %5d - %5d, %5d\n",
                    iMinX, iMaxX, m_iXWidth));
        }

        bXAccept = TRUE;
    }

    // Complete divide.
    FSTP_END_DIVIDE(fDXDY20);

    if (!bXAccept)
    {
        return FALSE;
    }

    // Clamp triangle Y's to clip rect.

    m_iY1 = ICEILF(fY1);

    if (m_StpCtx.iY < m_StpCtx.pCtx->Clip.top)
    {
        RSDPFM((RSM_YCLIP, "YClip iY %d to %d\n",
                m_StpCtx.iY, m_StpCtx.pCtx->Clip.top));

        m_StpCtx.iY = m_StpCtx.pCtx->Clip.top;

        if (m_iY1 < m_StpCtx.pCtx->Clip.top)
        {
            RSDPFM((RSM_YCLIP, "YClip iY1 %d to %d\n",
                    m_iY1, m_StpCtx.pCtx->Clip.top));

            m_iY1 = m_StpCtx.pCtx->Clip.top;
        }
    }

    if (m_iY1 > m_StpCtx.pCtx->Clip.bottom)
    {
        RSDPFM((RSM_YCLIP, "YClip iY1 %d, iY2 %d to %d\n",
                m_iY1, m_iY2, m_StpCtx.pCtx->Clip.bottom));

        m_iY1 = m_StpCtx.pCtx->Clip.bottom;
        m_iY2 = m_StpCtx.pCtx->Clip.bottom;
    }
    else if (m_iY2 > m_StpCtx.pCtx->Clip.bottom)
    {
        RSDPFM((RSM_YCLIP, "YClip iY2 %d to %d\n",
                m_iY2, m_StpCtx.pCtx->Clip.bottom));

        m_iY2 = m_StpCtx.pCtx->Clip.bottom;
    }

    // Compute Y subpixel correction.  This will include any Y
    // offset due to clamping.
    m_StpCtx.fDY = m_StpCtx.iY - fY0;

    // Compute trapzeoid heights.  These will be restricted to
    // lie in the clip rect.

    RSASSERT(m_iY1 >= m_StpCtx.iY && m_iY2 >= m_iY1);

    m_uHeight10 = m_iY1 - m_StpCtx.iY;
    m_uHeight21 = m_iY2 - m_iY1;

    m_uHeight20 = m_uHeight10 + m_uHeight21;
    if (m_uHeight20 == 0)
    {
        // Triangle doesn't cover any pixels.
        return FALSE;
    }

    RSDPFM((RSM_TRIS, "Tstp (%.4f,%.4f) (%.4f,%.4f) (%.4f,%.4f)\n",
            fX0, fY0, fX1, fY1, fX2, fY2));
    RSDPFM((RSM_TRIS, "    (%.4f,%.4f : %.4f,%.4f) %d:%d det %.4f\n",
            m_StpCtx.fDX10, m_StpCtx.fDY10,
            m_StpCtx.fDX20, m_StpCtx.fDY20,
            m_uHeight10, m_uHeight21, fDet));
    RSDPFM((RSM_Z, "    Z (%f) (%f) (%f)\n",
        pV0->dvSZ, pV1->dvSZ, pV2->dvSZ));
    RSDPFM((RSM_DIFF, "    diff (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcColor, pV1->dcColor, pV2->dcColor));
    RSDPFM((RSM_DIDX, "    didx (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcColor, pV1->dcColor, pV2->dcColor));
    RSDPFM((RSM_SPEC, "    spec (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcSpecular & 0xffffff, pV1->dcSpecular & 0xffffff,
            pV2->dcSpecular & 0xffffff));
    RSDPFM((RSM_OOW, "    OoW (%f) (%f) (%f)\n",
            pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
    RSDPFM((RSM_TEX1, "    Tex1 (%f,%f) (%f,%f) (%f,%f)\n",
            pV0->dvTU, pV0->dvTV, pV1->dvTU, pV1->dvTV,
            pV2->dvTU, pV2->dvTV));
    RSDPFM((RSM_FOG, "    Fog (0x%02X) (0x%02X) (0x%02X)\n",
            RGBA_GETALPHA(pV0->dcSpecular),
            RGBA_GETALPHA(pV1->dcSpecular),
            RGBA_GETALPHA(pV2->dcSpecular)));

    // Compute dx/dy for edges and initial X's.

    m_StpCtx.fDX = m_StpCtx.fDY * fDXDY20;
    FLOAT fX20 = fX0 + m_StpCtx.fDX;

    ComputeIntCarry(fX20, fDXDY20, &m_StpCtx.X20);
    m_StpCtx.fX20NC = (FLOAT)m_StpCtx.X20.iNC;
    m_StpCtx.fX20CY = (FLOAT)m_StpCtx.X20.iCY;

    RSDPFM((RSM_TRIS, "    edge20  %f dxdy %f\n", fX20, fDXDY20));
    RSDPFM((RSM_TRIS, "            (?.%d d %d nc %d cy %d)\n",
            m_StpCtx.X20.iFrac,
            m_StpCtx.X20.iDFrac, m_StpCtx.X20.iNC, m_StpCtx.X20.iCY));

    if (m_uHeight10 > 0)
    {
        FLOAT fDXDY10;
        FLOAT fX10;

#ifdef CHECK_VERTICAL
        // This case probably doesn't occur enough to justify the code.
        if (FLOAT_EQZ(m_StpCtx.fDX10))
        {
            fDXDY10 = g_fZero;
            fX10 = fX0;
        }
        else
#endif
        {
            fDXDY10 = m_StpCtx.fDX10 / m_StpCtx.fDY10;
            fX10 = fX0 + m_StpCtx.fDY * fDXDY10;
        }

        m_StpCtx.X10.iV = ICEILF(fX10);
        ComputeIntCarry(fX10, fDXDY10, &m_StpCtx.X10);

        RSDPFM((RSM_TRIS, "    edge10  %f dxdy %f\n", fX10, fDXDY10));
        RSDPFM((RSM_TRIS, "            (%d.%d d %d nc %d cy %d)\n",
                m_StpCtx.X10.iV, m_StpCtx.X10.iFrac,
                m_StpCtx.X10.iDFrac, m_StpCtx.X10.iNC, m_StpCtx.X10.iCY));
    }
#if DBG
    else
    {
        // Make it easier to detect when an invalid edge is used.
        memset(&m_StpCtx.X10, 0, sizeof(m_StpCtx.X10));
    }
#endif

    if (m_uHeight21 > 0)
    {
        FLOAT fDXDY21;
        FLOAT fX21;

#ifdef CHECK_VERTICAL
        // This case probably doesn't occur enough to justify the code.
        if (FLOAT_COMPARE(fX1, ==, fX2))
        {
            fDXDY21 = g_fZero;
            fX21 = fX1;
        }
        else
#endif
        {
            fDXDY21 = (fX2 - fX1) / (fY2 - fY1);
            fX21 = fX1 + (m_iY1 - fY1) * fDXDY21;
        }

        m_StpCtx.X21.iV = ICEILF(fX21);
        ComputeIntCarry(fX21, fDXDY21, &m_StpCtx.X21);

        RSDPFM((RSM_TRIS, "    edge21  %f dxdy %f\n", fX21, fDXDY21));
        RSDPFM((RSM_TRIS, "            (%d.%d d %d nc %d cy %d)\n",
                m_StpCtx.X21.iV, m_StpCtx.X21.iFrac,
                m_StpCtx.X21.iDFrac, m_StpCtx.X21.iNC, m_StpCtx.X21.iCY));
    }
#if DBG
    else
    {
        // Make it easier to detect when an invalid edge is used.
        memset(&m_StpCtx.X21, 0, sizeof(m_StpCtx.X21));
    }
#endif

    // The edge walker always walks the long edge so it may either
    // be a left or a right edge.  Determine what side the long edge
    // is and perform appropriate snapping and subpixel adjustment
    // computations.
    //
    // The clip-clamped initial X pixel position is also computed and
    // any necessary offset added into the subpixel correction delta.

    if (uDetCcw)
    {
        // Long edge (0-2) is to the right.

        m_StpCtx.uFlags |= TRIF_X_DEC;
        m_StpCtx.pPrim->uFlags = D3DI_RASTPRIM_X_DEC;

        m_StpCtx.X20.iV = ICEILF(fX20) - 1;

        // Other edges are left edges.  Bias them back by one
        // so that the span width computation can do R - L
        // rather than R - L + 1.
        m_StpCtx.X10.iV--;
        m_StpCtx.X21.iV--;

        // Clamp the initial X position.
        if (m_StpCtx.X20.iV >= m_StpCtx.pCtx->Clip.right)
        {
            m_StpCtx.iX = m_StpCtx.pCtx->Clip.right - 1;
        }
        else
        {
            m_StpCtx.iX = m_StpCtx.X20.iV;
        }
    }
    else
    {
        // Long edge (0-2) is to the left.

        m_StpCtx.pPrim->uFlags = 0;

        m_StpCtx.X20.iV = ICEILF(fX20);

        // Other edges are right edges.  The ICEILF snapping done
        // already leaves them off by one so that R - L works.

        // Clamp the initial X position.
        if (m_StpCtx.X20.iV < m_StpCtx.pCtx->Clip.left)
        {
            m_StpCtx.iX = m_StpCtx.pCtx->Clip.left;
        }
        else
        {
            m_StpCtx.iX = m_StpCtx.X20.iV;
        }
    }

    // Update X subpixel correction.  This delta includes any
    // offseting due to clamping of the initial pixel position.
    m_StpCtx.fDX += m_StpCtx.iX - fX20;

    RSDPFM((RSM_TRIS, "    subp    %f,%f\n", m_StpCtx.fDX, m_StpCtx.fDY));

    // Compute span-to-span steps for buffer pointers.
    m_StpCtx.DAttrNC.ipSurface = m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.X20.iNC * m_StpCtx.pCtx->iSurfaceStep;
    m_StpCtx.DAttrNC.ipZ = m_StpCtx.pCtx->iZStride +
        m_StpCtx.X20.iNC * m_StpCtx.pCtx->iZStep;

    // Start one over determinant divide.  Done after the multiplies
    // since integer multiplies require some of the FP unit.

    FLOAT fOoDet;

    FLD_BEGIN_DIVIDE(g_fOne, fDet, fOoDet);

    if (m_StpCtx.X20.iCY > m_StpCtx.X20.iNC)
    {
        m_StpCtx.DAttrCY.ipSurface = m_StpCtx.DAttrNC.ipSurface +
            m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrCY.ipZ = m_StpCtx.DAttrNC.ipZ + m_StpCtx.pCtx->iZStep;
    }
    else
    {
        m_StpCtx.DAttrCY.ipSurface = m_StpCtx.DAttrNC.ipSurface -
            m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrCY.ipZ = m_StpCtx.DAttrNC.ipZ - m_StpCtx.pCtx->iZStep;
    }

    //
    // Compute attribute functions.
    //

    // Set pure X/Y step deltas for surface and Z so that DX, DY, CY and NC all
    // have complete information and can be used interchangeably.
    if (m_StpCtx.uFlags & TRIF_X_DEC)
    {
        m_StpCtx.DAttrDX.ipSurface = -m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrDX.ipZ = -m_StpCtx.pCtx->iZStep;
    }
    else
    {
        m_StpCtx.DAttrDX.ipSurface = m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrDX.ipZ = m_StpCtx.pCtx->iZStep;
    }
    m_StpCtx.DAttrDY.ipSurface = m_StpCtx.pCtx->iSurfaceStride;
    m_StpCtx.DAttrDY.ipZ = m_StpCtx.pCtx->iZStride;

    // Finish overlapped divide.
    FSTP_END_DIVIDE(fOoDet);

    m_StpCtx.fOoDet = fOoDet;

    // The PrimProcessor is created zeroed out so the initial
    // state is FP clean.  Later uses may put FP values in slots but
    // they should still be valid, so the optional computations here
    // should never result in FP garbage.  It should therefore be
    // OK to use any mixture of attribute handlers since there should
    // never be any case where FP garbage will creep in.

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE3(pV0->dvRHW, pV1->dvRHW, pV2->dvRHW))
    {
        NormalizeTriRHW(pV0, pV1, pV2);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    TriSetup_Start(&m_StpCtx, pV0, pV1, pV2);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
        pV1->dvRHW = m_dvV1RHW;
        pV2->dvRHW = m_dvV2RHW;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\makefile.inc ===
$(GENTGT)\bdstr_mh.h: ..\bdstr_mh.mh $(RAST_STD_M4)

$(GENTGT)\beadstr.cpp: ..\beadstr.mcp ..\bdstr_mh.mh $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\spaninit.cpp: ..\spaninit.mcp ..\bdstr_mh.mh $(RASTROOT)\inc\bead.mh $(RASTROOT)\inc\rampbead.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\walkcpp.cpp ===
//----------------------------------------------------------------------------
//
// walkcpp.cpp
//
// C++ trapezoid edge walking functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// Currently empty.
//
// Could use m4 to generate specialized versions of everything,
// but the only overhead is two function calls per span.  I don't
// think it's important enough to justify the extra code.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3dhal.h>

#include "rast.h"
#include "spindbg.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\rastcoll.h ===
// RastColl.h - declaration of the CRastCollection class
//
// Copyright Microsoft Corporation, 1997.
//

#ifndef _RASTCOLL_H_
#define _RASTCOLL_H_

typedef struct _RASTFNREC {
    DWORD           rgdwRastCap[RASTCAPRECORD_SIZE];
    PFNRENDERSPANS  pfnRastFunc;
    int             iIndex;             // index for disable mask
    char            pszRastDesc[128];   // brief human description of monolith
} RASTFNREC;

class CRastCollection {

private:

    RASTFNREC* RastFnLookup(CRastCapRecord*,RASTFNREC*,int);

public:

    RASTFNREC*  Search(PD3DI_RASTCTX,CRastCapRecord*);

};

#endif  // _RASTCOLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\rastcoll.cpp ===
// rastcoll.cpp - implementation of the CRastCollection class
//
// Copyright Microsoft Corporation, 1997.
//

#include "pch.cpp"
#pragma hdrstop

#include "RastCap.h"
#include "rastcoll.h"
#include "mlrfns.h"

// MMX monolithic rasterizers are for X86 only
#ifdef _X86_
// table containing rasterzer capability bit vectors and
// pointers to functions implementing MMX monolithic
// rasterizers with those capabilities.
//
// note that table is sorted numerically by
// capability bit vector, this is essential for the
// search through the table.
//

static RASTFNREC s_RastListMMX[] = {
    {{ 0x00000000, 0x00000000, 0x00000100 }, MMXMLRast_22, 21, "MMX ml22" },
    {{ 0x00000000, 0x00000000, 0x00000102 }, MMXMLRast_8,   7, "MMX ml8 " },
    {{ 0x00000000, 0x00001100, 0x00000100 }, MMXMLRast_23, 22, "MMX ml23" },
    {{ 0x00000000, 0x00001102, 0x00000102 }, MMXMLRast_9,   8, "MMX ml9 " },
    {{ 0x00000000, 0x00003100, 0x00000100 }, MMXMLRast_26, 25, "MMX ml26" },
    {{ 0x00000000, 0x00003102, 0x00000102 }, MMXMLRast_12, 11, "MMX ml12" },
    {{ 0x00000000, 0x00101200, 0x00000100 }, MMXMLRast_24, 23, "MMX ml24" },
    {{ 0x00000000, 0x00101202, 0x00000102 }, MMXMLRast_10,  9, "MMX ml10" },
    {{ 0x00000000, 0x00103200, 0x00000100 }, MMXMLRast_27, 26, "MMX ml27" },
    {{ 0x00000000, 0x00103202, 0x00000102 }, MMXMLRast_13, 12, "MMX ml13" },
    {{ 0x00000000, 0x00111200, 0x00000100 }, MMXMLRast_25, 24, "MMX ml25" },
    {{ 0x00000000, 0x00111202, 0x00000102 }, MMXMLRast_11, 10, "MMX ml11" },
    {{ 0x00000000, 0x00113200, 0x00000100 }, MMXMLRast_28, 27, "MMX ml28" },
    {{ 0x00000000, 0x00113202, 0x00000102 }, MMXMLRast_14, 13, "MMX ml14" },
    {{ 0x00003003, 0x00000000, 0x00000100 }, MMXMLRast_15, 14, "MMX ml15" },
    {{ 0x00003003, 0x00000000, 0x00000102 }, MMXMLRast_1,   0, "MMX ml1 " },
    {{ 0x00003003, 0x00001100, 0x00000100 }, MMXMLRast_16, 15, "MMX ml16" },
    {{ 0x00003003, 0x00001102, 0x00000102 }, MMXMLRast_2,   1, "MMX ml2 " },
    {{ 0x00003003, 0x00003100, 0x00000100 }, MMXMLRast_19, 18, "MMX ml19" },
    {{ 0x00003003, 0x00003102, 0x00000102 }, MMXMLRast_5,   4, "MMX ml5 " },
    {{ 0x00003003, 0x00101200, 0x00000100 }, MMXMLRast_17, 16, "MMX ml17" },
    {{ 0x00003003, 0x00101202, 0x00000102 }, MMXMLRast_3,   2, "MMX ml3 " },
    {{ 0x00003003, 0x00103200, 0x00000100 }, MMXMLRast_20, 19, "MMX ml20" },
    {{ 0x00003003, 0x00103202, 0x00000102 }, MMXMLRast_6,   5, "MMX ml6 " },
    {{ 0x00003003, 0x00111200, 0x00000100 }, MMXMLRast_18, 17, "MMX ml18" },
    {{ 0x00003003, 0x00111202, 0x00000102 }, MMXMLRast_4,   3, "MMX ml4 " },
    {{ 0x00003003, 0x00113200, 0x00000100 }, MMXMLRast_21, 20, "MMX ml21" },
    {{ 0x00003003, 0x00113202, 0x00000102 }, MMXMLRast_7,   6, "MMX ml7 " },


};
#endif // _X86_

// table containing rasterizer capability bit vectors and
// pointers to functions implementing monolithic
// rasterizers with those capabilities.
//
// note that table is sorted numerically by
// capability bit vector, this is essential for the
// search through the table.
//
static RASTFNREC s_RastListNormal[] = {
    // Don't select these until we are sure they work
//    {{ 0x00113003, 0x00000000, 0x00000100 }, CMLRast_1, 0, "CML 1" },
//    {{ 0x00113003, 0x00000000, 0x00000103 }, CMLRast_2, 1, "CML 2" }
    {{ 0xffffffff, 0xffffffff, 0xffffffff }, CMLRast_1, 0, "CML 1" },
    {{ 0xffffffff, 0xffffffff, 0xffffffff }, CMLRast_2, 1, "CML 2" }
};


int RastCapCompare(DWORD* pdwCap1, DWORD* pdwCap2)
{
    for (int i = 0; i < RASTCAPRECORD_SIZE; i++) {
        if (pdwCap1[i] < pdwCap2[i]) {
            return -1;
        } else if (pdwCap1[i] > pdwCap2[i]) {
            return 1;
        }
    }

    return 0;
}


RASTFNREC*
CRastCollection::RastFnLookup(
    CRastCapRecord* pRastCapRec,
    RASTFNREC* pRastFnTbl,
    int iSize)
{
    int iLow = 0,
        iHigh = iSize - 1,
    iMid;
    RASTFNREC* pfnRastFnRec = NULL;

    // all MMX monolithics can handle either shade mode
    pRastCapRec->m_rgdwData[SHADEMODE_POS/32] &= ~(((1<<SHADEMODE_LEN)-1)<<SHADEMODE_POS);

    do
    {
        iMid = (iLow + iHigh) / 2;
        switch (RastCapCompare(pRastCapRec->
                m_rgdwData,pRastFnTbl[iMid].rgdwRastCap))
        {
        case -1 :
            iHigh = iMid - 1;
            break;
        case 0 :
            // found match
            pfnRastFnRec = &pRastFnTbl[iMid];
            iLow = iHigh + 1;       // exits while loop
            break;
        case 1 :
            iLow = iMid + 1;
            break;
        }
    } while (iLow <= iHigh);

    return pfnRastFnRec;
}


RASTFNREC*
CRastCollection::Search(PD3DI_RASTCTX pCtx,
    CRastCapRecord* pRastCapRec)
{
    RASTFNREC* pfnRastFnRec = NULL;

#ifdef _X86_
    // if we're on an MMX machine, is there an MMX rasterizer to use?
    if ((pCtx->BeadSet == D3DIBS_MMX)||(pCtx->BeadSet == D3DIBS_MMXASRGB)) {
        pfnRastFnRec = RastFnLookup(pRastCapRec,s_RastListMMX,
                             sizeof(s_RastListMMX) /
                             sizeof(s_RastListMMX[0]));
        if (pfnRastFnRec)
        {
            // only code up looking at one mask, for now
            DDASSERT(MMX_FP_DISABLE_MASK_NUM == 1);
            int iIndex = pfnRastFnRec->iIndex;
            DDASSERT((iIndex < 32) && (iIndex >= 0));
            if ((pCtx->dwMMXFPDisableMask[0]>>iIndex) & 1)
            {
                // oops, don't choose this one, it is on the disable list
                pfnRastFnRec = NULL;
            }
        }
    } else {
#endif //_X86_
        // no MMX or on ALPHA, so look in the normal list
        pfnRastFnRec = RastFnLookup(pRastCapRec,s_RastListNormal,
                                 sizeof(s_RastListNormal) /
                                 sizeof(s_RastListNormal[0]));
#ifdef _X86_
    }
#endif //_X86_

    return pfnRastFnRec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\d3dcom.h ===
/*
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       objbase.h
//
//  Contents:   Component object model defintions.
//
//  History:    02-7-94   terryru           Created.
//
//----------------------------------------------------------------------------
*/
/*
 * Taken from objbase.h
 */
#ifndef _D3DCOM_H
#define _D3DCOM_H

#include "subwtype.h"

#ifndef WIN32
#define __export
#define __stdcall
#endif /* WIN32 */

typedef void    IUnknown;
#ifndef WINAPI
#define WINAPI
#endif
#define FAR
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | \
            ((unsigned long)(fac)<<16) | \
             ((unsigned long)(code))))

/* Component Object Model defines, and macros */

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef WIN32

/* Win32 doesn't support __export */

#define STDMETHODCALLTYPE       __stdcall
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

/* The 'V' versions allow Variable Argument lists. */

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
/*#define interface               struct FAR */
#define interface struct
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface



#else

#define interface               struct


#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)




#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define CONST_VTBL const
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define CONST_VTBL
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif

#endif /* _D3DCOM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\spindbg.cpp ===
//----------------------------------------------------------------------------
//
// rsdbg.cpp
//
// Setup debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

static DebugModuleFlags g_RastSpanInitOutputFlags[] =
{
    DBG_DECLARE_MODFLAG(SPIM, INVALID),
    DBG_DECLARE_MODFLAG(SPIM, REPORT),
    0, NULL,
};
static DebugModuleFlags g_RastSpanInitUserFlags[] =
{
    DBG_DECLARE_MODFLAG(SPIU, BREAK_ON_SPANINIT),
    0, NULL,
};
DBG_DECLARE_ONCE(RastSpanInit, SPI,
                 g_RastSpanInitOutputFlags, 0,
                 g_RastSpanInitUserFlags, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\rastcap.h ===
// rastcap.h - declaration of the CRastCapRecord class
//
// Copyright Microsoft Corporation, 1997.
//

#ifndef _RASTCAP_H_
#define _RASTCAP_H_

// the current size of the rasterizer capability bit vector, in DWORDs.
#define RASTCAPRECORD_SIZE  3

// sets bits in the rasterizer capability bit vector
#define SET_VAL(pos, len, val)  ((m_rgdwData[(pos) / 32]) |= \
                                 (((val) & ~(0xFFFFFFFF << (len))) << \
                                  ((pos) % 32)))

// the positions and lengths of fields in the rasterizer capability bit vector
// note: make sure fields do not straddle DWORD boundaries!  SET_VAL cannot
//       currently handle that
#define ZFUNC_POS               0
#define ZFUNC_LEN               8
#define ZFORMAT_POS             8
#define ZFORMAT_LEN             4
#define ZTEST_POS               12
#define ZTEST_LEN               1
#define ZWRITE_POS              13
#define ZWRITE_LEN              1

#define SHADEMODE_POS           16
#define SHADEMODE_LEN           4
#define SPECULAR_POS            20
#define SPECULAR_LEN            1
#define VERTEXFOG_POS           21
#define VERTEXFOG_LEN           1
#define MONO_POS                22
#define MONO_LEN                1

#define TEXTUREFORMAT_POS       32
#define TEXTUREFORMAT_LEN       8
#define TEXTURE_POS             40
#define TEXTURE_LEN             4
#define TEXTUREBLEND_POS        44
#define TEXTUREBLEND_LEN        4
#define TEXTUREFILTER_POS       48
#define TEXTUREFILTER_LEN       4
#define TEXTUREPERSP_POS        52
#define TEXTUREPERSP_LEN        1
#define TEXTUERBORDER_POS       53
#define TEXTUREBORDER_LEN       1
#define TEXTUREADDR_POS         54
#define TEXTUREADDR_LEN         1
#define TEXTUREMIP_POS          55
#define TEXTUREMIP_LEN          1
#define TEXTURELOD_POS          56
#define TEXTURELOD_LEN          1
#define TEXTURECOLORKEY_POS     57
#define TEXTURECOLORKEY_LEN     1
#define TEXTUREALPHAOVERRIDE_POS 58
#define TEXTUREALPHAOVERRIDE_LEN 1

#define TARGETPIXELFORMAT_POS   64
#define TARGETPIXELFORMAT_LEN   8
#define SRCBLEND_POS            72
#define SRCBLEND_LEN            4
#define DESTBLEND_POS           76
#define DESTBLEND_LEN           4
#define STIPPLE_POS             80
#define STIPPLE_LEN             1
#define DITHER_POS              81
#define DITHER_LEN              1
#define ROP_POS                 82
#define ROP_LEN                 1
#define BLEND_POS               83
#define BLEND_LEN               1
#define ALPHATEST_POS           84
#define ALPHATEST_LEN           1
#define ALPHABLEND_POS          85
#define ALPHABLEND_LEN          1
#define STENCIL_POS             86
#define STENCIL_LEN             1

class CRastCapRecord {

    friend class CRastCollection;

private:

    DWORD   m_rgdwData[RASTCAPRECORD_SIZE];

public:

    CRastCapRecord(void)
    {
        memset(m_rgdwData,0,RASTCAPRECORD_SIZE * sizeof(DWORD));
        return;
    }

    void Set_ZTest(int iZTest)
    {
        SET_VAL(ZTEST_POS,ZTEST_LEN,iZTest);
        return;
    }

    void Set_ZFormat(int iZFormat)
    {
        SET_VAL(ZFORMAT_POS,ZFORMAT_LEN,iZFormat);
        return;
    }

    void Set_ZWrite(int iZWrite)
    {
        SET_VAL(ZWRITE_POS,ZWRITE_LEN,iZWrite);
        return;
    }

    void Set_ZFunc(int iZFunc)
    {
        SET_VAL(ZFUNC_POS,ZFUNC_LEN,iZFunc);
        return;
    }

    void Set_Stipple(int iStipple)
    {
        SET_VAL(STIPPLE_POS,STIPPLE_LEN,iStipple);
        return;
    }

    void Set_AlphaTest(int iAlphaTest)
    {
        SET_VAL(ALPHATEST_POS,ALPHATEST_LEN,iAlphaTest);
        return;
    }

    void Set_ShadeMode(int iShadeMode)
    {
        SET_VAL(SHADEMODE_POS,SHADEMODE_LEN,iShadeMode);
        return;
    }

    void Set_Specular(int iSpecular)
    {
        SET_VAL(SPECULAR_POS,SPECULAR_LEN,iSpecular);
        return;
    }

    void Set_VertexFog(int iVertexFog)
    {
        SET_VAL(VERTEXFOG_POS,VERTEXFOG_LEN,iVertexFog);
        return;
    }

    void Set_Texture(int iTexture)
    {
        SET_VAL(TEXTURE_POS,TEXTURE_LEN,iTexture);
        return;
    }

    void Set_TexturePersp(int iTexturePersp)
    {
        SET_VAL(TEXTUREPERSP_POS,TEXTUREPERSP_LEN,iTexturePersp);
        return;
    }

    void Set_TextureBlend(int iTextureBlend)
    {
        SET_VAL(TEXTUREBLEND_POS,TEXTUREBLEND_LEN,iTextureBlend);
        return;
    }

    // for now, just capture texture state for the first texture
    // and assume monolithics are single textured.
    void Set_TextureBorder(int i, int iTextureBorder)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUERBORDER_POS,TEXTUREBORDER_LEN,iTextureBorder);
        }
        return;
    }

    void Set_TextureAddr(int i, int iTextureAddr)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREADDR_POS,TEXTUREADDR_LEN,iTextureAddr);
        }
        return;
    }

    void Set_TextureFilter(int i, int iTextureFilter)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREFILTER_POS,TEXTUREFILTER_LEN,iTextureFilter);
        }
        return;
    }

    void Set_TextureMip(int i, int iTextureMip)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREMIP_POS,TEXTUREMIP_LEN,iTextureMip);
        }
        return;
    }

    void Set_TextureLOD(int i, int iTextureLOD)
    {
        if (i == 0)
        {
            SET_VAL(TEXTURELOD_POS,TEXTURELOD_LEN,iTextureLOD);
        }
        return;
    }

    void Set_TextureFormat(int i, int iTextureFormat)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREFORMAT_POS,TEXTUREFORMAT_LEN,iTextureFormat);
        }
        return;
    }

    void Set_TextureColorKey(int i, int iTextureColorKey)
    {
        if (i == 0)
        {
            SET_VAL(TEXTURECOLORKEY_POS,TEXTURECOLORKEY_LEN,iTextureColorKey);
        }
        return;
    }

    void Set_TextureAlphaOverride(int i, int iTextureAlphaOverride)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREALPHAOVERRIDE_POS,TEXTUREALPHAOVERRIDE_LEN,iTextureAlphaOverride);
        }
        return;
    }

    void Set_Mono(int iMono)
    {
        SET_VAL(MONO_POS,MONO_LEN,iMono);
        return;
    }

    void Set_AlphaBlend(int iAlphaBlend)
    {
        SET_VAL(ALPHABLEND_POS,ALPHABLEND_LEN,iAlphaBlend);
        return;
    }

    void Set_Blend(int iBlend)
    {
        SET_VAL(BLEND_POS,BLEND_LEN,iBlend);
        return;
    }

    void Set_ROP(int iROP)
    {
        SET_VAL(ROP_POS,ROP_LEN,iROP);
        return;
    }

    void Set_SrcBlend(int iSrcBlend)
    {
        SET_VAL(SRCBLEND_POS,SRCBLEND_LEN,iSrcBlend);
        return;
    }

    void Set_DestBlend(int iDestBlend)
    {
        SET_VAL(DESTBLEND_POS,DESTBLEND_LEN,iDestBlend);
        return;
    }

    void Set_TargetPixelFormat(int iTargetPixelFormat)
    {
        SET_VAL(TARGETPIXELFORMAT_POS,TARGETPIXELFORMAT_LEN,iTargetPixelFormat);
        return;
    }

    void Set_Dither(int iDither)
    {
        SET_VAL(DITHER_POS,DITHER_LEN,iDither);
        return;
    }

    void Set_Stencil(int iStencil)
    {
        SET_VAL(STENCIL_POS,STENCIL_LEN,iStencil);
        return;
    }

#if DBG
    DWORD GetCapDWord(int iNum)
    {
        return m_rgdwData[iNum];
    }
#endif
};

#endif  // _RASTCAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\spindbg.hpp ===
//----------------------------------------------------------------------------
//
// spindbg.hpp
//
// Span Init debug definitions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPINDBG_HPP_
#define _SPINDBG_HPP_

#include <cppdbg.hpp>

DBG_DECLARE_HEADER(SPI);

#define SPIDPF(Args)             DBG_DECLARE_DPF(SPI, Args)
#define SPIDPFM(Args)            DBG_DECLARE_DPFM(SPI, Args)
#define SPIASSERT(Exp)           DBG_DECLARE_ASSERT(SPI, Exp)
#define SPIASSERTMSG(Exp, Args)  DBG_DECLARE_ASSERTMSG(SPI, Exp, Args)
#define SPIVERIFY(Exp)           DBG_DECLARE_VERIFY(SPI, Exp)
#define SPIVERIFYMSG(Exp)        DBG_DECLARE_VERIFYMSG(SPI, Exp, Args)
#define SPIPROMPT(Args)          DBG_DECLARE_PROMPT(SPI, Args)
#define SPIGETFLAGS(Idx)         DBG_DECLARE_GETFLAGS(SPI, Idx)
#define SPISETFLAGS(Idx, Value)  DBG_DECLARE_SETFLAGS(SPI, Idx, Value)
#define SPIHRCHK(Exp)            DBG_DECLARE_HRCHK(SPI, Exp)
#define SPIHRGO(Exp, Label)      DBG_DECLARE_HRGO(SPI, Exp, Label)
#define SPIHRERR(Exp)            DBG_DECLARE_HRERR(SPI, Exp)
#define SPIHRRET(Exp)            DBG_DECLARE_HRRET(SPI, Exp)

#define SPIM_INVALID             0x00000001
#define SPIM_REPORT              0x00000002

#define SPIU_BREAK_ON_SPANINIT   0x00000001

#endif // #ifndef _SPINDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\sources.inc ===
TARGETNAME = rspanini
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;..\..\refrast;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY);..\..\rampold

SOURCES = \
        $O\beadstr.cpp\
        $O\spaninit.cpp\
        ..\spindbg.cpp\
        ..\rastcoll.cpp

NTTARGETFILE0 = \
        $O\bdstr_mh.h\
        $O\beadstr.cpp\
        $O\spaninit.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\d3diunk.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    d3diunk.c
*  Content: Direct3D IUnknown
*@@BEGIN_MSINTERNAL
* 
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95    stevela Merged Colin's changes.
*   27/08/96   stevela Ifdefed out the Close of gHEvent.  We're using
*                      DirectDraw's critical section.
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * If we are built with aggregation enabled then we actually need two
 * different Direct3D QueryInterface, AddRef and Releases. One which
 * does the right thing on the Direct3D object and one which simply
 * punts to the owning interface.
 */

/*
 * CDirect3DUnk::QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::QueryInterface"

HRESULT D3DAPI CDirect3DUnk::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    if( !VALID_OUTPTR( ppvObj ) )
    {
        D3D_ERR( "Invalid obj ptr" );
        return DDERR_INVALIDPARAMS;
    }
    
    *ppvObj = NULL;

    D3D_INFO(3, "Direct3D IUnknown QueryInterface");
    
    if(IsEqualIID(riid, IID_IUnknown))
    {
        /*
         * Asking for IUnknown and we are IUnknown so just bump the
         * reference count and return this interface.
         * NOTE: Must AddRef through the interface being returned.
         */
        pD3DI->AddRef();
        // explicit ::CDirect3D disambiguation required since there are multiple IUnknown DIRECT3DI inherits from
        *ppvObj = static_cast<LPVOID>(static_cast<LPUNKNOWN>(static_cast<DIRECT3DI*>(pD3DI)));
    }
    else if (IsEqualIID(riid, IID_IDirect3D7))
    {
        pD3DI->AddRef();
        // No disambiguation required. Only one IDirect3D3 base for DIRECT3DI
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3D7>(pD3DI));
    }
    else
    {
        /*
         * Don't understand this interface. Fail.
         * NOTE: Used to return DDERR_GENERIC. Now return
         * E_NOINTERFACE.
         */
        return (E_NOINTERFACE);
    }
    
    return (D3D_OK);
    
} /* CDirect3DUnk::QueryInterface */

/*
 * CDirect3DUnk::AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DUnk::AddRef"

ULONG D3DAPI CDirect3DUnk::AddRef()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    refCnt++;
    D3D_INFO(3, "Direct3D IUnknown AddRef: Reference count = %d", refCnt);
    return (refCnt);
    
} /* CDirect3DUnk::AddRef */

/*
 * CDirect3DUnk::Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DUnk::Release"

ULONG D3DAPI CDirect3DUnk::Release()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    refCnt--;
    D3D_INFO(3, "Direct3D IUnknown Release: Reference count = %d", refCnt);
    
    if( refCnt == 0 )
    {
        delete pD3DI; // Delete Parent object
        return 0;
    }
    return refCnt;
    
} /* D3DIUnknown_Release */

DIRECT3DI::~DIRECT3DI()
{
    D3D_INFO(3, "Release Direct3D Object");

#if COLLECTSTATS
    if(m_hFont)
    {
        DeleteObject(m_hFont);
    }
#endif

    delete lpTextureManager;
    /*
     * free up all allocated Buckets
     */
#if DBG
    /* this->lpFreeList must have all the buckets that are allocated */
    if (this->lpFreeList || this->lpBufferList)
    {
        int i,j;
        LPD3DBUCKET   temp;
        for (i=0,temp=this->lpFreeList;temp;i++) temp=temp->next;
        for (j=0,temp=this->lpBufferList;temp;j++) temp=temp->next;
        D3D_INFO(4,"D3D Release: recovered %d buckets in lpFreeList in %d buffers",i,j);
        DDASSERT(j*(D3DBUCKETBUFFERSIZE-1)==i);
    }
#endif  //DBG
    while (this->lpBufferList)
    {
        LPD3DBUCKET   temp=this->lpBufferList;
        this->lpBufferList=temp->next;
        D3DFree(temp->lpBuffer);
        D3D_INFO(4,"D3D Release:lpBufferList %d bytes freed",D3DBUCKETBUFFERSIZE*sizeof(D3DBUCKET));
    }
    this->lpFreeList=NULL;
}
    
/*
  * DIRECT3DI::QueryInterface
  */
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::QueryInterface"
  
HRESULT D3DAPI DIRECT3DI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    if( !VALID_OUTPTR( ppvObj ) )
    {
        D3D_ERR( "Invalid obj ptr" );
        return DDERR_INVALIDPARAMS;
    }
    
    *ppvObj = NULL;

    ret = this->lpOwningIUnknown->QueryInterface(riid, ppvObj);
    return ret;
}

/*
 * DIRECT3DI::AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::AddRef"

ULONG D3DAPI DIRECT3DI::AddRef()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * Punt to the owning interface.
     */
    return  this->lpOwningIUnknown->AddRef();
}

/*
 * DIRECT3DI::Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::Release"

ULONG D3DAPI DIRECT3DI::Release()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * Punt to the owning interface.
     */
    return  this->lpOwningIUnknown->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\d3dcreat.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3di.h
 *  Content:    Direct3D HAL include file
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   09/11/95   stevela Initial rev with this header.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *                      Validate args.
 *   17/04/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *   29/04/96   colinmc Bug 19954: Must query for Direct3D before texture
 *                      or device
 *   27/08/96   stevela Ifdefed out definition of ghEvent as we're using
 *                      DirectDraw's critical section.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3D object
 */

// Remove DDraw's type unsafe definition and replace with our C++ friendly def
#ifdef VALIDEX_CODE_PTR
#undef VALIDEX_CODE_PTR
#endif
#define VALIDEX_CODE_PTR( ptr ) \
(!IsBadCodePtr( (FARPROC) ptr ) )

LPCRITICAL_SECTION      lpD3DCSect;

#if DBG
    int     iD3DCSCnt;
#endif

#if COLLECTSTATS
void DIRECT3DI::ResetTexStats()
{
    ((LPDDRAWI_DIRECTDRAW_INT)lpDD7)->lpLcl->dwNumTexLocks = ((LPDDRAWI_DIRECTDRAW_INT)lpDD7)->lpLcl->dwNumTexGetDCs = 0;
    m_setpris = m_setLODs = m_texCreates = m_texDestroys = 0;
}

void DIRECT3DI::GetTexStats(LPD3DDEVINFO_TEXTURING pStats)
{
    pStats->dwNumSetPriorities = GetNumSetPris();
    pStats->dwNumSetLODs = GetNumSetLODs();
    pStats->dwNumCreates = GetNumTexCreates();
    pStats->dwNumDestroys = GetNumTexDestroys();
    pStats->dwNumLocks = GetNumTexLocks();
    pStats->dwNumGetDCs = GetNumTexGetDCs();
}
#endif

//---------------------------------------------------------------------
// for use by fns that take a GUID param before device is created
BOOL IsValidD3DDeviceGuid(REFCLSID riid) {

    if (IsBadReadPtr(&riid, sizeof(CLSID))) {
        return FALSE;
    }
    if( IsEqualIID(riid, IID_IDirect3DRampDevice) ||
        IsEqualIID(riid, IID_IDirect3DRGBDevice)  ||
        IsEqualIID(riid, IID_IDirect3DMMXDevice)  ||
        IsEqualIID(riid, IID_IDirect3DHALDevice)  ||
        IsEqualIID(riid, IID_IDirect3DRefDevice)  ||
        IsEqualIID(riid, IID_IDirect3DNullDevice) ||
        IsEqualIID(riid, IID_IDirect3DTnLHalDevice)) {
       return TRUE;
    } else {
        return FALSE;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DCreate"

DIRECT3DI::DIRECT3DI()
{
    lpDD           = NULL;
    lpDD7          = NULL;
    numDevs        = 0;
    mD3DUnk.pD3DI  = this;
    mD3DUnk.refCnt = 1;

    LIST_INITIALIZE(&devices);
    LIST_INITIALIZE(&textures);

    lpFreeList       = NULL;    /* nothing is allocated initially */
    lpBufferList     = NULL;
    lpTextureManager = NULL;

#ifdef __DISABLE_VIDMEM_VBS__
    bDisableVidMemVBs = FALSE;
#endif
}

HRESULT DIRECT3DI::Initialize(IUnknown* pUnkOuter, LPDDRAWI_DIRECTDRAW_INT pDDrawInt)
{
    // HACK.  D3D needs a DD1 DDRAWI interface because it uses CreateSurface1 internally
    // for exebufs, among other things.  Because pDDrawInt could be any DDRAWI type,
    // we need to QI to find a DD1 interface.  But the D3DI object cannot keep a reference
    // to its parent DD object because it is aggegrated with the DD obj, so that would constitute
    // a circular reference that would prevent deletion. So we QI for DD1 interface, copy it into D3DI
    // and release it, then point lpDD at the copy. (disgusting)

    // another HACK alert: dont know which DDRAWI type pDDrawInt is, but a cast to LPDIRECTDRAW should
    // work because QI is in the same place in all the DDRAWI vtables and is the same fn for all
    HRESULT ret;
    ret = ((LPDIRECTDRAW)pDDrawInt)->QueryInterface(IID_IDirectDraw, (LPVOID*)&lpDD);
    if(FAILED(ret))
    {
        D3D_ERR( "QueryInterface for IDDraw failed" );
        return ret;
    }
    memcpy(&DDInt_DD1,lpDD,sizeof(DDInt_DD1));
    lpDD->Release();
    lpDD=(LPDIRECTDRAW)&DDInt_DD1;

    // We know that the pointer that is handed in is a DD7 interface, hence just typecast and assign
    lpDD7 = reinterpret_cast<LPDIRECTDRAW7>(pDDrawInt);

    lpTextureManager = new TextureCacheManager(this);
    if(lpTextureManager == 0)
    {
        D3D_ERR("Out of memory allocating texture manager");
        return E_OUTOFMEMORY;
    }
    ret = lpTextureManager->Initialize();
    if(ret != D3D_OK)
    {
        D3D_ERR("Failed to initialize texture manager");
        return ret;
    }

#if COLLECTSTATS
    DWORD value = 0;
    GetD3DRegValue(REG_DWORD, "DisplayStats", &value, sizeof(DWORD));
    if(value != 0)
    {
        LOGFONT font;
        strcpy(font.lfFaceName, STATS_FONT_FACE);
        font.lfCharSet        = DEFAULT_CHARSET;
        font.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
        font.lfEscapement     = 0;
        font.lfHeight         = STATS_FONT_SIZE;
        font.lfItalic         = FALSE;
        font.lfOrientation    = 0;
        font.lfOutPrecision   = OUT_DEFAULT_PRECIS;
        font.lfPitchAndFamily = DEFAULT_PITCH;
        font.lfQuality        = DEFAULT_QUALITY;
        font.lfStrikeOut      = FALSE;
        font.lfUnderline      = FALSE;
        font.lfWeight         = FW_DONTCARE;
        font.lfWidth          = 0;
        m_hFont = CreateFontIndirect(&font);
    }
    else
    {
        m_hFont = 0;
    }
#endif

#ifdef __DISABLE_VIDMEM_VBS__
    {
        bDisableVidMemVBs = FALSE;
        DWORD value = 0;
        GetD3DRegValue(REG_DWORD, "DisableVidMemVBs", &value, sizeof(DWORD));
        if(value != 0)
        {
            // Disable VidMemVBs 
            bDisableVidMemVBs = TRUE;
        }

        // We also disable vidmem VBs unless the driver explicitly asks us to turn them on...
        if (((LPDDRAWI_DIRECTDRAW_INT)lpDD7)->lpLcl->lpGbl->lpD3DGlobalDriverData)
        {
            if (0 == (((LPDDRAWI_DIRECTDRAW_INT)lpDD7)->lpLcl->lpGbl->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_HWVERTEXBUFFER) )
            {
                bDisableVidMemVBs = TRUE;
            }
        }
    }
#endif //__DISABLE_VIDMEM_VBS__

    /*
     * Are we really being aggregated?
     */
    if (pUnkOuter != NULL)
    {
        /*
         * Yup - we are being aggregated. Store the supplied
         * IUnknown so we can punt to that.
         * NOTE: We explicitly DO NOT AddRef here.
         */
        this->lpOwningIUnknown = pUnkOuter;
        /*
         * Store away the interface pointer
         */
    }
    else
    {
        /*
         * Nope - but we pretend we are anyway by storing our
         * own IUnknown as the parent IUnknown. This makes the
         * code much neater.
         */
        this->lpOwningIUnknown = static_cast<LPUNKNOWN>(&this->mD3DUnk);
    }
    return D3D_OK;
}


extern "C" HRESULT WINAPI Direct3DCreate(LPCRITICAL_SECTION lpDDCSect,
                                         LPUNKNOWN*         lplpDirect3D,
                                         IUnknown*          pUnkOuter)
{
    LPDIRECT3DI pd3d;

    try
    {
        DPFINIT();

        /*
         * No need to validate params as DirectDraw is giving them to us.
         */

        /*
         * Is another thread coming in and is this the first time?
         */

        /*
         * We can let every invocation of this function assign
         * the critical section as we know its always going to
         * be the same value (for a D3D session).
         */
        lpD3DCSect = lpDDCSect;
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                        // Release in the destructor

        *lplpDirect3D = NULL;

        // We do not support non aggregated Direct3D object yet
        if (!pUnkOuter)
            return DDERR_INVALIDPARAMS;

        if (!(pd3d = static_cast<LPDIRECT3DI>(new DIRECT3DI)))
        {
            D3D_ERR("Out of memory allocating DIRECT3DI");
            return E_OUTOFMEMORY;
        }

        HRESULT hr = pd3d->Initialize(pUnkOuter, (LPDDRAWI_DIRECTDRAW_INT)pUnkOuter);
        if(hr != D3D_OK)
        {
            D3D_ERR("Failed to initialize Direct3D.");
            delete pd3d;
            return hr;
        }

        /*
         * NOTE: The special IUnknown is returned and not the actual
         * Direct3D interface so you can't use this to drive Direct3D.
         * You must query off this interface for the Direct3D interface.
         */
        *lplpDirect3D = static_cast<LPUNKNOWN>(&(pd3d->mD3DUnk));

        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::EnumDevices"

extern BOOL isMMXprocessor(void);

typedef struct _D3DI_DeviceType {
    CONST GUID *pGuid;
    char name[256];
    char description[512];
} D3DI_DeviceType;

// Static definitions for various enumerable devices
static D3DI_DeviceType RGBDevice =
{
    &IID_IDirect3DRGBDevice, "RGB Emulation",
    "Microsoft Direct3D RGB Software Emulation"
};
static D3DI_DeviceType HALDevice =
{
    &IID_IDirect3DHALDevice, "Direct3D HAL",
    "Microsoft Direct3D Hardware acceleration through Direct3D HAL"
};
static D3DI_DeviceType RefDevice =
{
    &IID_IDirect3DRefDevice, "Reference Rasterizer",
    "Microsoft Reference Rasterizer"
};
static D3DI_DeviceType NullDevice =
{
    &IID_IDirect3DNullDevice, "Null device",
    "Microsoft Null Device"
};
static D3DI_DeviceType TnLHALDevice =
{
    &IID_IDirect3DTnLHalDevice, "Direct3D T&L HAL",
    "Microsoft Direct3D Hardware Transform and Lighting acceleration capable device"
};

static D3DI_DeviceType *AllDevices[] =
{
    &RGBDevice, &HALDevice, &RefDevice, &NullDevice,
    &TnLHALDevice, NULL
};

HRESULT
DIRECT3DI::EnumDevices(LPD3DENUMDEVICESCALLBACK7 lpEnumCallback,
                       LPVOID lpContext, DWORD dwSize, DWORD dwVer)
{
    HRESULT err, userRet;
    HKEY hKey;
    LONG result;
    int i;

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                        // Release in the destructor

        if (!VALIDEX_CODE_PTR((FARPROC)lpEnumCallback))
        {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }

        BOOL bSoftwareOnly = FALSE;
        BOOL bEnumReference = FALSE;
        BOOL bEnumNullDevice = FALSE;
        BOOL bEnumSeparateMMX = FALSE;

        result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RESPATH, 0, KEY_READ, &hKey);
        if (result == ERROR_SUCCESS)
        {
            DWORD dwData, dwType;
            DWORD dwDataSize;

            // Enumerate software rasterizers only ?
            dwDataSize = sizeof(dwData);
            result = RegQueryValueEx(hKey, "SoftwareOnly", NULL,
                                     &dwType, (BYTE *) &dwData, &dwDataSize);
            if ( result == ERROR_SUCCESS && dwType == REG_DWORD )
            {
                bSoftwareOnly = ( dwData != 0 );
            }

            // Enumerate Reference Rasterizer ?
            dwDataSize = sizeof(dwData);
            result = RegQueryValueEx(hKey, "EnumReference", NULL,
                                     &dwType, (BYTE *)&dwData, &dwDataSize);
            if (result == ERROR_SUCCESS &&
                dwType == REG_DWORD &&
                dwDataSize == sizeof(dwData))
            {
                bEnumReference = (BOOL)dwData;
            }

            // Enumerate Null Device ?
            dwDataSize = sizeof(dwData);
            result = RegQueryValueEx(hKey, "EnumNullDevice", NULL,
                                     &dwType, (BYTE *)&dwData, &dwDataSize);
            if (result == ERROR_SUCCESS &&
                dwType == REG_DWORD &&
                dwDataSize == sizeof(dwData))
            {
                bEnumNullDevice = (BOOL)dwData;
            }


            RegCloseKey( hKey );
        }

        D3DI_DeviceType **lpDevices = AllDevices;

        userRet = D3DENUMRET_OK;
        for (i = 0; lpDevices[i] && userRet == D3DENUMRET_OK; i++)
        {
            LPSTR drvName = lpDevices[i]->name;
            LPSTR drvDesc = lpDevices[i]->description;
            REFCLSID riid = *lpDevices[i]->pGuid;
            D3DDEVICEDESC7 HWDesc;
            D3DDEVICEDESC7 HELDesc;
            LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;
            IHalProvider *pHalProv;
            HINSTANCE hDll;

            if ( !bEnumReference &&
                 IsEqualIID(riid, IID_IDirect3DRefDevice))
            {
                // Not enumerating the reference.
                continue;
            }

            if (!bEnumNullDevice &&
                IsEqualIID(riid, IID_IDirect3DNullDevice))
            {
                // Not enumerating the Null device.
                continue;
            }

            // By COM definition, our owning IUnknown is a pointer to the
            // DirectDraw object that was used to create us.
            // Check this for the existence of a Direct3D HAL.
            lpDDGbl = ((LPDDRAWI_DIRECTDRAW_INT)this->lpDD)->lpLcl->lpGbl;


            if (IsEqualIID(riid, IID_IDirect3DTnLHalDevice) && (lpDDGbl->lpD3DGlobalDriverData))
            {
                if (!(lpDDGbl->lpD3DGlobalDriverData->hwCaps.dwDevCaps &
                  D3DDEVCAPS_HWTRANSFORMANDLIGHT))
            {
                // Not enumerating the T&L device if the hardware doesnt support
                // T&L
                continue;
                }
            }

            // See if this is a software driver.
            err = GetSwHalProvider(riid, &pHalProv, &hDll);
            if (err == S_OK)
            {
                // Successfully got a software driver.
            }
            else if (err == E_NOINTERFACE &&
                     ! bSoftwareOnly &&
                     GetHwHalProvider(riid, &pHalProv, &hDll, lpDDGbl) == S_OK)
            {
                // Successfully got a hardware driver.
            }
            else
            {
                // Unrecognized driver.
                continue;
            }

            err = pHalProv->GetCaps(lpDDGbl, &HWDesc, &HELDesc, dwVer);

            pHalProv->Release();
            if (hDll != NULL)
            {
                FreeLibrary(hDll);
            }

            if (err != S_OK)
            {
                continue;
            }

            if( HWDesc.wMaxVertexBlendMatrices == 1 )
                HWDesc.wMaxVertexBlendMatrices = 0;
    
            if( HELDesc.wMaxVertexBlendMatrices == 1 )
                HELDesc.wMaxVertexBlendMatrices = 0;
    
            // If Hal device is being enumerated, strip out the
            // HWTRANSFORM... flag
            if (IsEqualIID(riid, IID_IDirect3DHALDevice))
            {
                HWDesc.dwMaxActiveLights = 0xffffffff;
                HWDesc.wMaxVertexBlendMatrices = 4;
                HWDesc.wMaxUserClipPlanes = __MAXUSERCLIPPLANES;
                HWDesc.dwVertexProcessingCaps = D3DVTXPCAPS_ALL;
                HWDesc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT);
            }

            if (IsEqualIID(riid, IID_IDirect3DRGBDevice))
            {
                HELDesc.dwMaxActiveLights = 0xffffffff;
                HELDesc.wMaxVertexBlendMatrices = 4;
                HELDesc.wMaxUserClipPlanes = __MAXUSERCLIPPLANES;
                HELDesc.dwVertexProcessingCaps = D3DVTXPCAPS_ALL;
            }

            if (IsEqualIID(riid, IID_IDirect3DHALDevice) || IsEqualIID(riid, IID_IDirect3DTnLHalDevice))
            {
                memcpy(&HWDesc.deviceGUID, lpDevices[i]->pGuid, sizeof(GUID));
                userRet = (*lpEnumCallback)(drvDesc, drvName,
                                        &HWDesc, lpContext);
            }
            else
            {
                memcpy(&HELDesc.deviceGUID, lpDevices[i]->pGuid, sizeof(GUID));
                userRet = (*lpEnumCallback)(drvDesc, drvName,
                                        &HELDesc, lpContext);
            }
        }

        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

HRESULT D3DAPI DIRECT3DI::EnumDevices(LPD3DENUMDEVICESCALLBACK7 lpEnumCallback,
                                      LPVOID lpContext)
{
    return EnumDevices(lpEnumCallback, lpContext, D3DDEVICEDESC7SIZE, 4);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DI::EnumZBufferFormats"

HRESULT D3DAPI DIRECT3DI::EnumZBufferFormats(REFCLSID riid,
                                             LPD3DENUMPIXELFORMATSCALLBACK lpEnumCallback,
                                             LPVOID lpContext)
{
    HRESULT ret, userRet;
    LPDDPIXELFORMAT lpTmpPixFmts;
    DWORD i,cPixFmts;

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        ret = D3D_OK;

        if (!VALID_DIRECT3D_PTR(this))
        {
            D3D_ERR( "Invalid Direct3D3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALIDEX_CODE_PTR(lpEnumCallback))
        {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }

        if(!IsValidD3DDeviceGuid(riid))
        {
            D3D_ERR( "Invalid D3D Device GUID" );
            return DDERR_INVALIDPARAMS;
        }

        if( IsEqualIID(riid, IID_IDirect3DHALDevice) || 
            IsEqualIID(riid, IID_IDirect3DTnLHalDevice) ) 
        {
            LPDDRAWI_DIRECTDRAW_GBL pDdGbl=((LPDDRAWI_DIRECTDRAW_INT)this->lpDD)->lpLcl->lpGbl;
            LPD3DHAL_GLOBALDRIVERDATA lpD3DHALGlobalDriverData=pDdGbl->lpD3DGlobalDriverData;
            DWORD dwHW_ZBitDepthFlags;
            if (NULL == lpD3DHALGlobalDriverData)
            {
                D3D_ERR("No HAL Support ZBufferBitDepths!");
                return (DDERR_NOZBUFFERHW);
            }
            cPixFmts=pDdGbl->dwNumZPixelFormats;
            if (cPixFmts==0) {
                // driver is pre-dx6, so it doesn't support stencil buffer pix fmts or this callback.
                // we can fake support using DD_BD bits in dwZBufferBitDepth in D3DDEVICEDESC
                D3D_WARN(6,"EnumZBufferFormats not supported directly by driver, faking it using dwDeviceZBufferBitDepth DD_BD bits");

                dwHW_ZBitDepthFlags=lpD3DHALGlobalDriverData->hwCaps.dwDeviceZBufferBitDepth;

                if(!(dwHW_ZBitDepthFlags & (DDBD_8|DDBD_16|DDBD_24|DDBD_32))) {
                        D3D_ERR("No Supported ZBufferBitDepths!");
                        return (DDERR_NOZBUFFERHW);
                }

                // malloc space for 4 DDPIXELFORMATs, since that the most there could be (DDBD_8,16,24,32)
                if (D3DMalloc((void**)&lpTmpPixFmts, 4*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                        D3D_ERR("failed to alloc space for return descriptions");
                        return (DDERR_OUTOFMEMORY);
                }

                DWORD zdepthflags[4]= {DDBD_8,DDBD_16,DDBD_24,DDBD_32};
                DWORD zbitdepths[4]= {8,16,24,32};
                DWORD zbitmasks[4]= {0xff,0xffff,0xffffff,0xffffffff};

                memset(lpTmpPixFmts,0,sizeof(4*sizeof(DDPIXELFORMAT)));

                // create some DDPIXELFORMATs the app can look at
                for(i=0;i<4;i++) {
                    if(dwHW_ZBitDepthFlags & zdepthflags[i]) {
                        lpTmpPixFmts[cPixFmts].dwSize=sizeof(DDPIXELFORMAT);
                        lpTmpPixFmts[cPixFmts].dwFlags=DDPF_ZBUFFER;
                        lpTmpPixFmts[cPixFmts].dwZBufferBitDepth=zbitdepths[i];
                        lpTmpPixFmts[cPixFmts].dwZBitMask= zbitmasks[i];
                        cPixFmts++;
                    }
                }
            } else {
                // only show the app a temp copy of DDraw's real records

                if (D3DMalloc((void**)&lpTmpPixFmts, cPixFmts*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                    D3D_ERR("Out of memory allocating space for return descriptions");
                    return (DDERR_OUTOFMEMORY);
                }
                memcpy(lpTmpPixFmts, pDdGbl->lpZPixelFormats, cPixFmts*sizeof(DDPIXELFORMAT));
            }
        } else {
            // Handle SW rasterizers
            DDPIXELFORMAT  *pDDPF;

            // malloc space for 10 DDPIXELFORMAT's, which is currently more than enough for the SW rasterizers
            if (D3DMalloc((void**)&lpTmpPixFmts, 10*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                    D3D_ERR("Out of memory allocating space for return descriptions");
                    return (DDERR_OUTOFMEMORY);
            }

            cPixFmts=GetSwZBufferFormats(riid,&pDDPF);
            memcpy(lpTmpPixFmts, pDDPF, cPixFmts*sizeof(DDPIXELFORMAT));
        }

        userRet = D3DENUMRET_OK;
        for (i = 0; (i < cPixFmts) && (userRet == D3DENUMRET_OK); i++) {
            userRet = (*lpEnumCallback)(&lpTmpPixFmts[i], lpContext);
        }

        D3DFree(lpTmpPixFmts);

        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3D::EvictManagedTextures"
HRESULT D3DAPI
DIRECT3DI::EvictManagedTextures()
{
    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
        if (!VALID_DIRECT3D_PTR(this))
        {
            D3D_ERR( "Invalid Direct3D3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&this->devices);
        while (lpDevI)
        {
            if (lpDevI->dwFEFlags & D3DFE_REALHAL)
            {
                if (DDCAPS2_CANMANAGETEXTURE &
                    ((LPDDRAWI_DIRECTDRAW_INT)this->lpDD)->lpLcl->lpGbl->ddCaps.dwCaps2)
                {
                    lpDevI->SetRenderStateI((D3DRENDERSTATETYPE)D3DRENDERSTATE_EVICTMANAGEDTEXTURES,1);
                    lpDevI->FlushStates();
                }
                lpTextureManager->EvictTextures();
                break;
            }
            lpDevI = LIST_NEXT(lpDevI,list);
        }
        return  D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3D::FlushDevicesExcept"

HRESULT DIRECT3DI::FlushDevicesExcept(LPDIRECT3DDEVICEI pDev)
{
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&this->devices);
    while (lpDevI)
    {
        if(lpDevI != pDev)
        {
            HRESULT hr = lpDevI->FlushStates();
            if(hr != D3D_OK)
            {
                DPF_ERR("Error flushing device in FlushDevicesExcept");
                return hr;
            }
        }
        lpDevI = LIST_NEXT(lpDevI,list);
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FlushD3DDevices"

extern "C" HRESULT WINAPI FlushD3DDevices(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    try
    {
        ULONGLONG qwBatch = (surf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) 
                                && (surf_lcl->lpAttachListFrom != NULL) ?
                                    surf_lcl->lpAttachListFrom->lpAttached->lpSurfMore->qwBatch.QuadPart : 
                                    surf_lcl->lpSurfMore->qwBatch.QuadPart;
        LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(surf_lcl->lpSurfMore->lpDD_lcl->pD3DIUnknown)->pD3DI;
        DDASSERT(lpD3D);
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
        while (lpDevI)
        {
            if(lpDevI->m_qwBatch <= qwBatch)
            {
                HRESULT hr = lpDevI->FlushStates();
                if(hr != D3D_OK)
                {
                    DPF_ERR("Error flushing device in FlushD3DDevices");
                    return hr;
                }
            }
            lpDevI = LIST_NEXT(lpDevI,list);
        }
        return DD_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

extern "C" void WINAPI PaletteUpdateNotify(
    LPVOID pD3DIUnknown,
    DWORD dwPaletteHandle,
    DWORD dwStartIndex,
    DWORD dwNumberOfIndices,
    LPPALETTEENTRY pFirstIndex)
{
    try
    {
        LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
        DDASSERT(lpD3D);
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
        while (lpDevI)
        {
            D3D_INFO(4,"PaletteUpdateNotify lpDevI(%x) %08lx %08lx %08lx %08lx",
                lpDevI,dwPaletteHandle,dwStartIndex,dwNumberOfIndices,*(DWORD*)&pFirstIndex[10]);
            if (IS_DX7HAL_DEVICE(lpDevI) &&
                (lpDevI->dwFEFlags & D3DFE_REALHAL)
               )
            {
                if(lpD3D->numDevs > 1)
                    lpD3D->FlushDevicesExcept(lpDevI);
                static_cast<CDirect3DDevice7*>(lpDevI)->UpdatePalette(dwPaletteHandle,dwStartIndex,dwNumberOfIndices,pFirstIndex);
                if(lpD3D->numDevs > 1)
                    lpDevI->FlushStates();
                break;
            }
            lpDevI = LIST_NEXT(lpDevI,list);
        }
    }
    catch (HRESULT ret)
    {
        D3D_ERR("PaletteUpdateNotify: FlushStates failed");
    }
}

extern "C" void WINAPI PaletteAssociateNotify(
    LPVOID pD3DIUnknown,
    DWORD dwPaletteHandle,
    DWORD dwPaletteFlags,
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl )
{
    try
    {
        LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
        DDASSERT(lpD3D);
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
        while (lpDevI)
        {
            D3D_INFO(4,"PaletteAssociateNotify lpDevI(%x) %08lx %08lx",
                lpDevI,dwPaletteHandle,surf_lcl->lpSurfMore->dwSurfaceHandle);
            if (IS_DX7HAL_DEVICE(lpDevI) &&
                (lpDevI->dwFEFlags & D3DFE_REALHAL)
               )
            {
                if(lpD3D->numDevs > 1)
                    lpD3D->FlushDevicesExcept(lpDevI);
                static_cast<CDirect3DDevice7*>(lpDevI)->SetPalette(dwPaletteHandle,dwPaletteFlags,surf_lcl->lpSurfMore->dwSurfaceHandle);
                lpDevI->BatchTexture(surf_lcl);
                if(lpD3D->numDevs > 1)
                    lpDevI->FlushStates();
                break;
            }
            lpDevI = LIST_NEXT(lpDevI,list);
        }
    }
    catch (HRESULT ret)
    {
        D3D_ERR("PaletteAssociateNotify: FlushStates failed");
    }
}

extern "C" void WINAPI SurfaceFlipNotify(LPVOID pD3DIUnknown)
{
    LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
    DDASSERT(lpD3D);
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
    D3D_INFO(4,"SurfaceFlipNotify");
    while (lpDevI)
    {
        if (IS_DX7HAL_DEVICE(lpDevI))
        {
            try
            {
                CDirect3DDevice7* lpDevI7 = static_cast<CDirect3DDevice7*>(lpDevI);
#ifndef WIN95
                if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface)
                {
                    lpDevI7->SetRenderTargetINoFlush(lpDevI->lpDDSTarget,lpDevI->lpDDSZBuffer);
                    lpDevI->hSurfaceTarget=((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface;
                }
#else
                if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->lpSurfMore->dwSurfaceHandle)
                {
                    lpDevI7->SetRenderTargetINoFlush(lpDevI->lpDDSTarget,lpDevI->lpDDSZBuffer);
                    lpDevI->hSurfaceTarget=((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;
                }
#endif
            }
            catch (HRESULT ret)
            {
                D3D_ERR("SetRenderTarget Failed on SurfaceFlipNotify!");
            }
        }
        lpDevI = LIST_NEXT(lpDevI,list);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DTextureUpdate"

extern "C" void WINAPI D3DTextureUpdate(IUnknown FAR * pD3DIUnknown)
{
    LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
    DDASSERT(lpD3D);
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
    while (lpDevI)
    {
        lpDevI->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE;
        lpDevI = LIST_NEXT(lpDevI,list);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DTextureUpdate"

extern "C" void WINAPI D3DBreakVBLock(LPVOID lpVB)
{
    DDASSERT(lpVB);
    CDirect3DVertexBuffer* lpVBI = static_cast<CDirect3DVertexBuffer*>(lpVB);
    lpVBI->BreakLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\d3dpr.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dpr.h
 *  Content:    Direct3D private include file
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *   23/11/95   colinmc Made various Direct3D interfaces queryable off
 *                      DirectDraw.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *   17/04/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef _D3DPR_H_
#define _D3DPR_H_
#include "d3di.hpp"
#include "texman.hpp"
#include "dpf.h"

/*
 * Texture Manipulation Utils
 */
extern void D3DI_RemoveTextureHandle(LPD3DI_TEXTUREBLOCK);
extern "C" void WINAPI D3DTextureUpdate(IUnknown FAR * pD3DIUnknown);

extern DWORD BitDepthToDDBD(int bpp);
extern BOOL D3DI_isHALValid(LPD3DHAL_CALLBACKS pCallbacks);
extern void FreeDeviceI(LPDIRECT3DDEVICEI pDevI);

#define D3DBUCKETBUFFERSIZE 32  //make buffer byte size 2*D3DBUCKETBUFFERSIZE*4
extern HRESULT D3DMallocBucket(LPDIRECT3DI, LPD3DBUCKET *);
extern void D3DFreeBucket(LPDIRECT3DI, LPD3DBUCKET);
extern LPD3DI_TEXTUREBLOCK D3DI_FindTextureBlock(LPDIRECT3DTEXTUREI,LPDIRECT3DDEVICEI);

inline bool MatchDDPIXELFORMAT( DDPIXELFORMAT* pddpfA, DDPIXELFORMAT* pddpfB )
{
    return ( pddpfA->dwFlags == pddpfB->dwFlags ) &&
           ( pddpfA->dwRGBBitCount == pddpfB->dwRGBBitCount ) &&
           ( pddpfA->dwRBitMask == pddpfB->dwRBitMask ) &&
           ( pddpfA->dwGBitMask == pddpfB->dwGBitMask ) &&
           ( pddpfA->dwBBitMask == pddpfB->dwBBitMask ) &&
           ( pddpfA->dwRGBAlphaBitMask == pddpfB->dwRGBAlphaBitMask ) &&
           ( pddpfA->dwFourCC == pddpfB->dwFourCC );
}

inline DDPIXELFORMAT& PixelFormat(LPDDRAWI_DDRAWSURFACE_LCL lpLcl)
{
    return (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? lpLcl->lpGbl->ddpfSurface : lpLcl->lpGbl->lpDD->vmiData.ddpfDisplay;
}

#if _D3D_FORCEDOUBLE
class CD3DForceFPUDouble
{
private:
    WORD    wFPUCW;
    WORD    wSaved;
public:
    __inline
    CD3DForceFPUDouble(CDirect3DDeviceIHW * lpDevI)
    {
        wSaved=FALSE;
        if (lpDevI->dwDebugFlags & D3DDEBUG_FORCEDOUBLE)
        {
            WORD    wTemp;
            __asm   fstcw   wTemp
            if (!(wTemp & 0x0200))
            {
                wSaved=TRUE;
                wFPUCW=wTemp;
                wTemp=wFPUCW | 0x0200;  //Enforce Double Precision bit
                __asm   fldcw  wTemp
            }
        }
    }
    __inline
    ~CD3DForceFPUDouble()
    {
        if (wSaved)
        {
            WORD    wTemp = wFPUCW;
            __asm   fldcw  wTemp
        }
    }
};
#endif  //_D3D_FORCEDOUBLE

/*
 * Critical section code.
 * Coarse locking.  All actions require this section.
 * Defined in d3dcreat.c
 */
/*
 * On WINNT critical sections can't be used because synchronization must
 * occur cross process.   DDraw and D3D must share this synchronization so
 * DDraw exports private functions for synchronization that NT D3D must use.
 */
#ifdef WIN95
extern LPCRITICAL_SECTION       lpD3DCSect;
#endif

extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
};
#if DBG
    extern int iD3DCSCnt;
    #define INCD3DCSCNT() iD3DCSCnt++;
    #define INITD3DCSCNT() iD3DCSCnt = 0;
    #define DECD3DCSCNT() iD3DCSCnt--;
#else
    #define INCD3DCSCNT()
    #define INITD3DCSCNT()
    #define DECD3DCSCNT()
#endif

#ifdef WIN95
#define ENTER_D3D() \
    EnterCriticalSection( lpD3DCSect ); \
    INCD3DCSCNT(); \

#define LEAVE_D3D() \
    DECD3DCSCNT() \
    LeaveCriticalSection( lpD3DCSect );
#else
#define ENTER_D3D() \
        AcquireDDThreadLock(); \
        INCD3DCSCNT(); \

#define LEAVE_D3D() \
        DECD3DCSCNT() \
        ReleaseDDThreadLock();
#endif

// This class is designed to simplify ENTER_D3D() LEAVE_D3D() logic
// If object of this class is instantiated, then internal lock will be taken.
// As soon as object is destroyed lock will be released
//
class CLockD3D
{
public:
    CLockD3D(char *moduleName, char *fileName)
    {
        ENTER_D3D();
#if DBG // Required to eliminate use of moduleName and fileName in retail builds
        D3D_INFO( 6, "*** LOCK_D3D: CNT = %ld %s %s", iD3DCSCnt, moduleName, fileName );
#endif
    }
    ~CLockD3D()
    {
        LEAVE_D3D();
        D3D_INFO( 6, "*** UNLOCK_D3D: CNT = %ld", iD3DCSCnt);
    }
};

class CLockD3DST
{
private:
    bool bEnter;
public:
    CLockD3DST(LPDIRECT3DDEVICEI lpDevI, char *moduleName, char *fileName)
    {
        if (! IS_MT_DEVICE(lpDevI) )
        {
            ENTER_D3D();
#if DBG // Required to eliminate use of moduleName and fileName in retail builds
            D3D_INFO( 6, "*** LOCK_D3D: CNT = %ld %s %s", iD3DCSCnt, moduleName, fileName );
#endif
            bEnter = true;
        }
        else
            bEnter = false;
    }
    ~CLockD3DST()
    {
        if (bEnter)
        {
            LEAVE_D3D();
            D3D_INFO( 6, "*** UNLOCK_D3D: CNT = %ld", iD3DCSCnt);
        }
    }
};

class CLockD3DMT
{
private:
    bool bEnter;
public:
    CLockD3DMT(LPDIRECT3DDEVICEI lpDevI, char *moduleName, char *fileName)
    {
        if ( IS_MT_DEVICE(lpDevI) )
        {
            ENTER_D3D();
#if DBG // Required to eliminate use of moduleName and fileName in retail builds
            D3D_INFO( 6, "*** LOCK_D3D: CNT = %ld %s %s", iD3DCSCnt, moduleName, fileName );
#endif
            bEnter = true;
        }
        else
            bEnter = false;
    }
    ~CLockD3DMT()
    {
        if (bEnter)
        {
            LEAVE_D3D();
            D3D_INFO( 6, "*** UNLOCK_D3D: CNT = %ld", iD3DCSCnt);
        }
    }
};

#define ENTER_CBCSECT(device) EnterCriticalSection(&(device)->CommandBufferCSect)
#define LEAVE_CBCSECT(device) LeaveCriticalSection(&(device)->CommandBufferCSect)

// Macro used to access DDRAW GBL from a given LPDIRECT3DI
#define DDGBL(lpD3DI) ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl
// Macro used to access DDRAW SURF LCL from a given surface
#define DDSLCL(lpDDS) (((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl)
// Macro used to access DDRAW SURF GBL from a given surface
#define DDSGBL(lpDDS) (((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->lpGbl)
/*
 * Macros for validating parameters.
 * Only implement those not available in ddrawpr.h.
 */

#define VALID_OUTPTR(x) ((x) && VALID_PTR_PTR(x))

// FAST_CHECKING macro is defined in ddrawpr.h
// so in make sure that ddrawpr.h is always included
// before this header.

#ifndef FAST_CHECKING

#define VALID_DIRECT3D_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DI )))
#define VALID_DIRECT3DTEXTUREM_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DTEXTUREM )))
#define VALID_DIRECT3DTEXTURED3DM_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DTEXTURED3DM )))
#define VALID_DIRECT3DDEVICE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DDEVICEI )))
#define VALID_DDSURF_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWSURFACE_INT )))
#define VALID_DIRECT3DVERTEXBUFFER_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( CDirect3DVertexBuffer )))

#define VALID_D3DVERTEXBUFFERDESC_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DVERTEXBUFFERDESC ) ) && \
    (ptr->dwSize == sizeof( D3DVERTEXBUFFERDESC )) )
#define VALID_D3DDEVICEDESC7_PTR( ptr ) \
    (! IsBadWritePtr(ptr, sizeof( D3DDEVICEDESC7 )) )
#define VALID_D3DRECT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DRECT ) ))
#define VALID_GDIRECT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( RECT ) ))
#define VALID_GDIPOINT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( POINT ) ))
#define VALID_D3DVIEWPORT_PTR( ptr ) (!IsBadWritePtr(ptr, sizeof(D3DVIEWPORT7)))
#define VALID_D3DMATRIX_PTR( ptr ) (!IsBadWritePtr(ptr, sizeof(D3DMATRIX)))
#define VALID_D3DLIGHT_PTR( ptr ) (!IsBadWritePtr(ptr, sizeof(D3DLIGHT7)))
#define VALID_D3DMATERIAL_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof(D3DMATERIAL7)))
#define VALID_D3DTEXTUREHANDLE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DTEXTUREHANDLE ) ) )
#define VALID_D3DLIGHTDATA_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DLIGHTDATA ) ) && \
    (ptr->dwSize == sizeof( D3DLIGHTDATA )) )
#define VALID_D3DFINDDEVICESEARCH_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DFINDDEVICESEARCH ) ) && \
    (ptr->dwSize == sizeof( D3DFINDDEVICESEARCH ) ) )
#define VALID_D3DFINDDEVICERESULT7_PTR( ptr ) \
        ( (! IsBadWritePtr( ptr, 4)) &&                  \
          (ptr->dwSize == sizeof(D3DFINDDEVICERESULT7)) && \
          (! IsBadWritePtr( ptr, ptr->dwSize) ) )
#define VALID_D3DDEVINFOSTRUCT_PTR( ptr, size ) \
    (!IsBadWritePtr( ptr, size ) )

// Note: these macros are replacements for the VALID_DIRECTDRAWSURFACE_PTR ddraw macros
// because those macros need access to the ddCallbacks ddraw globals.
// At some point these could be replaced with a ddraw exported fn that actually
// verifies the callback table type

#define VALID_D3D_DIRECTDRAWSURFACE_PTR(ptr) (!IsBadWritePtr(ptr, sizeof(DDRAWI_DDRAWSURFACE_INT)))
#define VALID_D3D_DIRECTDRAWSURFACE7_PTR(ptr) (!IsBadWritePtr(ptr, sizeof(DDRAWI_DDRAWSURFACE_INT)))

#else /* !FAST_CHECKING */

#define VALID_DIRECT3D_PTR( ptr ) (ptr)
#define VALID_DIRECT3DTEXTUREM_PTR( ptr ) (ptr)
#define VALID_DIRECT3DTEXTURED3DM_PTR( ptr ) (ptr)
#define VALID_DIRECT3DDEVICE_PTR( ptr ) (ptr)
#define VALID_DDSURF_PTR( ptr ) (ptr)
#define VALID_DIRECT3DVERTEXBUFFER_PTR( ptr ) (ptr)

#define VALID_D3DVERTEXBUFFERDESC_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DVERTEXBUFFERDESC ))
#define VALID_D3DDEVICEDESC7_PTR( ptr ) (ptr)
#define VALID_D3DVIEWPORT_PTR( ptr ) (ptr)
#define VALID_D3DRECT_PTR( ptr ) (ptr)
#define VALID_GDIRECT_PTR( ptr ) (ptr)
#define VALID_GDIPOINT_PTR( ptr ) (ptr)
#define VALID_D3DMATRIX_PTR( ptr ) (ptr)
#define VALID_D3DLIGHT_PTR( ptr ) (ptr)
#define VALID_D3DMATERIAL_PTR( ptr ) (ptr)
#define VALID_D3DTEXTUREHANDLE_PTR( ptr ) (ptr)
#define VALID_D3DLIGHTDATA_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DLIGHTDATA ))
#define VALID_D3DFINDDEVICESEARCH_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DFINDDEVICESEARCH ))
#define VALID_D3DFINDDEVICERESULT7_PTR( ptr ) \
        ((ptr) && (ptr->dwSize == sizeof( D3DFINDDEVICERESULT7 )) )

#define VALID_D3D_DIRECTDRAWSURFACE_PTR(ptr) (ptr)    // see comment above
#define VALID_D3D_DIRECTDRAWSURFACE7_PTR(ptr) (ptr)
#define VALID_D3DDEVINFOSTRUCT_PTR( ptr, size ) (ptr)

#endif /* !FAST_CHECKING */


#endif /* _D3DPR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\d3ddev.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3ddev.cpp
 *  Content:    Direct3D device implementation
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: device.c,v 1.26 1995/12/04 11:29:47 sjl Exp $
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
/*
 * Create an api for the Direct3DDevice object
 */
extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
}
#include "commdrv.hpp"
#include "drawprim.hpp"

//#ifdef DEBUG_PIPELINE
#include "testprov.h"
//#endif //DEBUG_PIPELINE
#ifdef PROFILE4
#include <icecap.h>
#endif
#ifdef PROFILE
#include <icapexp.h>
#endif

// Remove DDraw's type unsafe definition and replace with our C++ friendly def
#ifdef VALIDEX_CODE_PTR
#undef VALIDEX_CODE_PTR
#endif
#define VALIDEX_CODE_PTR( ptr ) \
(!IsBadCodePtr( (FARPROC) ptr ) )

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice"

// DX3, DX5, DX6, DX7, TL
#define MAX_DRIVERMODELS_SUPPORTED 5
#define D3DDRVMODEL_DX3  0x00000001
#define D3DDRVMODEL_DX5  0x00000002
#define D3DDRVMODEL_DX6  0x00000003
#define D3DDRVMODEL_DX7  0x00000004
#define D3DDRVMODEL_TL   0x00000005

extern BOOL isMMXprocessor(void);
extern BOOL IsValidD3DDeviceGuid(REFCLSID riid);
extern void setIdentity(D3DMATRIXI * m);
extern DWORD dwCPUFeatures;
#ifdef _X86_
extern HRESULT D3DAPI katmai_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
extern HRESULT D3DAPI wlmt_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
extern LPD3DFE_CONTEXTCREATE px3DContextCreate;
#endif


BOOL D3DI_isHALValid(LPD3DHAL_CALLBACKS halTable)
{
    if(halTable==NULL) {
        D3D_WARN(0, "HAL callbacks is NULL. HAL will not be enumerated.");
        return FALSE;
    }

    if (halTable->dwSize != D3DHAL_SIZE_V1) {
        D3D_WARN(0, "HAL callbacks invalid - size = %d, wanted %d. HAL will not be enumerated.",
            halTable->dwSize, D3DHAL_SIZE_V1);
        return FALSE;
    }
    if (halTable->dwReserved  ||
        halTable->dwReserved0 ||
        halTable->dwReserved1 ||
        halTable->dwReserved2 ||
        halTable->dwReserved3 ||
        halTable->dwReserved4 ||
        halTable->dwReserved5 ||
        halTable->dwReserved6 ||
        halTable->dwReserved7 ||
        halTable->dwReserved8 ||
        halTable->dwReserved9 ||
        halTable->lpReserved10 ||
        halTable->lpReserved11 ||
        halTable->lpReserved12 ||
        halTable->lpReserved13 ||
        halTable->lpReserved14 ||
        halTable->lpReserved15 ||
        halTable->lpReserved16 ||
        halTable->lpReserved17 ||
        halTable->lpReserved18 ||
        halTable->lpReserved19 ||
        halTable->lpReserved20 ||
        halTable->lpReserved21) {
        D3D_WARN(0, "HAL callbacks invalid - has non-zero reserved fields, HAL will not be enumerated.");
        return FALSE;
    }

    return TRUE;
}

// This is a list of all rstates that UpdateInternalState does some
// work other than updating this->rstates[] array. This is used to
// do a quick bitwise check to see if this rstate is trivial or not.

const D3DRENDERSTATETYPE rsList[] = {
    D3DRENDERSTATE_FOGENABLE,
    D3DRENDERSTATE_SPECULARENABLE,
    D3DRENDERSTATE_RANGEFOGENABLE,
    D3DRENDERSTATE_FOGDENSITY,
    D3DRENDERSTATE_FOGSTART,
    D3DRENDERSTATE_FOGEND,
    D3DRENDERSTATE_WRAP0,
    D3DRENDERSTATE_WRAP1,
    D3DRENDERSTATE_WRAP2,
    D3DRENDERSTATE_WRAP3,
    D3DRENDERSTATE_WRAP4,
    D3DRENDERSTATE_WRAP5,
    D3DRENDERSTATE_WRAP6,
    D3DRENDERSTATE_WRAP7,
    D3DRENDERSTATE_CLIPPING,
    D3DRENDERSTATE_LIGHTING,
    D3DRENDERSTATE_EXTENTS,
    D3DRENDERSTATE_AMBIENT,
    D3DRENDERSTATE_FOGVERTEXMODE,
    D3DRENDERSTATE_COLORVERTEX,
    D3DRENDERSTATE_LOCALVIEWER,
    D3DRENDERSTATE_NORMALIZENORMALS,
    D3DRENDERSTATE_COLORKEYBLENDENABLE,
    D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
    D3DRENDERSTATE_SPECULARMATERIALSOURCE,
    D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
    D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
    D3DRENDERSTATE_VERTEXBLEND,
    D3DRENDERSTATE_CLIPPLANEENABLE,
    D3DRENDERSTATE_SHADEMODE,

    // Retired renderstates to be filtered with DPF error and INVALID return
    // NOTE: everything listed here is also assumed to appear in rsListRetired
    D3DRENDERSTATE_TEXTUREHANDLE,
    D3DRENDERSTATE_TEXTUREADDRESS,
    D3DRENDERSTATE_WRAPU,
    D3DRENDERSTATE_WRAPV,
    D3DRENDERSTATE_MONOENABLE,
    D3DRENDERSTATE_ROP2,
    D3DRENDERSTATE_PLANEMASK,
    D3DRENDERSTATE_TEXTUREMAG,
    D3DRENDERSTATE_TEXTUREMIN,
    D3DRENDERSTATE_TEXTUREMAPBLEND,
    D3DRENDERSTATE_SUBPIXEL,
    D3DRENDERSTATE_SUBPIXELX,
    D3DRENDERSTATE_STIPPLEENABLE,
    D3DRENDERSTATE_BORDERCOLOR,
    D3DRENDERSTATE_TEXTUREADDRESSU,
    D3DRENDERSTATE_TEXTUREADDRESSV,
    D3DRENDERSTATE_MIPMAPLODBIAS,
    D3DRENDERSTATE_ANISOTROPY,
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT,
    D3DRENDERSTATE_STIPPLEPATTERN00,
    D3DRENDERSTATE_STIPPLEPATTERN01,
    D3DRENDERSTATE_STIPPLEPATTERN02,
    D3DRENDERSTATE_STIPPLEPATTERN03,
    D3DRENDERSTATE_STIPPLEPATTERN04,
    D3DRENDERSTATE_STIPPLEPATTERN05,
    D3DRENDERSTATE_STIPPLEPATTERN06,
    D3DRENDERSTATE_STIPPLEPATTERN07,
    D3DRENDERSTATE_STIPPLEPATTERN08,
    D3DRENDERSTATE_STIPPLEPATTERN09,
    D3DRENDERSTATE_STIPPLEPATTERN10,
    D3DRENDERSTATE_STIPPLEPATTERN11,
    D3DRENDERSTATE_STIPPLEPATTERN12,
    D3DRENDERSTATE_STIPPLEPATTERN13,
    D3DRENDERSTATE_STIPPLEPATTERN14,
    D3DRENDERSTATE_STIPPLEPATTERN15,
    D3DRENDERSTATE_STIPPLEPATTERN16,
    D3DRENDERSTATE_STIPPLEPATTERN17,
    D3DRENDERSTATE_STIPPLEPATTERN18,
    D3DRENDERSTATE_STIPPLEPATTERN19,
    D3DRENDERSTATE_STIPPLEPATTERN20,
    D3DRENDERSTATE_STIPPLEPATTERN21,
    D3DRENDERSTATE_STIPPLEPATTERN22,
    D3DRENDERSTATE_STIPPLEPATTERN23,
    D3DRENDERSTATE_STIPPLEPATTERN24,
    D3DRENDERSTATE_STIPPLEPATTERN25,
    D3DRENDERSTATE_STIPPLEPATTERN26,
    D3DRENDERSTATE_STIPPLEPATTERN27,
    D3DRENDERSTATE_STIPPLEPATTERN28,
    D3DRENDERSTATE_STIPPLEPATTERN29,
    D3DRENDERSTATE_STIPPLEPATTERN30,
    D3DRENDERSTATE_STIPPLEPATTERN31,
};

// list of retired renderstates - need to make sure these are
// filtered and never get from app directly to driver
const D3DRENDERSTATETYPE rsListRetired[] = {
    D3DRENDERSTATE_TEXTUREHANDLE,
    D3DRENDERSTATE_TEXTUREADDRESS,
    D3DRENDERSTATE_WRAPU,
    D3DRENDERSTATE_WRAPV,
    D3DRENDERSTATE_MONOENABLE,
    D3DRENDERSTATE_ROP2,
    D3DRENDERSTATE_PLANEMASK,
    D3DRENDERSTATE_TEXTUREMAG,
    D3DRENDERSTATE_TEXTUREMIN,
    D3DRENDERSTATE_TEXTUREMAPBLEND,
    D3DRENDERSTATE_SUBPIXEL,
    D3DRENDERSTATE_SUBPIXELX,
    D3DRENDERSTATE_STIPPLEENABLE,
    D3DRENDERSTATE_BORDERCOLOR,
    D3DRENDERSTATE_TEXTUREADDRESSU,
    D3DRENDERSTATE_TEXTUREADDRESSV,
    D3DRENDERSTATE_MIPMAPLODBIAS,
    D3DRENDERSTATE_ANISOTROPY,
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT,
    D3DRENDERSTATE_STIPPLEPATTERN00,
    D3DRENDERSTATE_STIPPLEPATTERN01,
    D3DRENDERSTATE_STIPPLEPATTERN02,
    D3DRENDERSTATE_STIPPLEPATTERN03,
    D3DRENDERSTATE_STIPPLEPATTERN04,
    D3DRENDERSTATE_STIPPLEPATTERN05,
    D3DRENDERSTATE_STIPPLEPATTERN06,
    D3DRENDERSTATE_STIPPLEPATTERN07,
    D3DRENDERSTATE_STIPPLEPATTERN08,
    D3DRENDERSTATE_STIPPLEPATTERN09,
    D3DRENDERSTATE_STIPPLEPATTERN10,
    D3DRENDERSTATE_STIPPLEPATTERN11,
    D3DRENDERSTATE_STIPPLEPATTERN12,
    D3DRENDERSTATE_STIPPLEPATTERN13,
    D3DRENDERSTATE_STIPPLEPATTERN14,
    D3DRENDERSTATE_STIPPLEPATTERN15,
    D3DRENDERSTATE_STIPPLEPATTERN16,
    D3DRENDERSTATE_STIPPLEPATTERN17,
    D3DRENDERSTATE_STIPPLEPATTERN18,
    D3DRENDERSTATE_STIPPLEPATTERN19,
    D3DRENDERSTATE_STIPPLEPATTERN20,
    D3DRENDERSTATE_STIPPLEPATTERN21,
    D3DRENDERSTATE_STIPPLEPATTERN22,
    D3DRENDERSTATE_STIPPLEPATTERN23,
    D3DRENDERSTATE_STIPPLEPATTERN24,
    D3DRENDERSTATE_STIPPLEPATTERN25,
    D3DRENDERSTATE_STIPPLEPATTERN26,
    D3DRENDERSTATE_STIPPLEPATTERN27,
    D3DRENDERSTATE_STIPPLEPATTERN28,
    D3DRENDERSTATE_STIPPLEPATTERN29,
    D3DRENDERSTATE_STIPPLEPATTERN30,
    D3DRENDERSTATE_STIPPLEPATTERN31,
};
//---------------------------------------------------------------------
DIRECT3DDEVICEI::DIRECT3DDEVICEI()
{
    m_rsMax  = D3DRENDERSTATE_CLIPPING;
    m_tssMax = D3DTSS_TEXTURETRANSFORMFLAGS;
}
//---------------------------------------------------------------------
HRESULT DIRECT3DDEVICEI::stateInitialize(BOOL bZEnable)
{
    D3DLINEPATTERN defLPat;
    HRESULT ret;
    float tmpval;
    DWORD i;

    // Initialize the bit array indicating the rstates needing non-trivial
    // work.
    for (i=0; i < sizeof(rsList) / sizeof(D3DRENDERSTATETYPE); ++i)
        rsVec[rsList[i] >> D3D_RSVEC_SHIFT] |= 1 << (rsList[i] & D3D_RSVEC_MASK);
    // Initialize the bit array indicating the retired rstates
    for (i=0; i < sizeof(rsListRetired) / sizeof(D3DRENDERSTATETYPE); ++i)
        rsVecRetired[rsListRetired[i] >> D3D_RSVEC_SHIFT] |= 1 << (rsListRetired[i] & D3D_RSVEC_MASK);
    // Obviate SetRenderState filtering 'redundant' render state settings
    // since this is the init step.
    memset( this->rstates, 0xff, sizeof(DWORD)*D3D_MAXRENDERSTATES);
    this->rstates[D3DRENDERSTATE_PLANEMASK] = 0;
    this->rstates[D3DRENDERSTATE_STENCILMASK] = 0;
    this->rstates[D3DRENDERSTATE_STENCILWRITEMASK] = 0;
    this->rstates[D3DRENDERSTATE_TEXTUREFACTOR] = 0;

    SetRenderStateInternal( D3DRENDERSTATE_TEXTUREPERSPECTIVE, TRUE);
    SetRenderStateInternal( D3DRENDERSTATE_SPECULARENABLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_ZENABLE, bZEnable);
    SetRenderStateInternal( D3DRENDERSTATE_FILLMODE, D3DFILL_SOLID);
    SetRenderStateInternal( D3DRENDERSTATE_SHADEMODE, D3DSHADE_GOURAUD);

    defLPat.wRepeatFactor = 0;
    defLPat.wLinePattern = 0;

    SetRenderStateInternal( D3DRENDERSTATE_LINEPATTERN, *((LPDWORD)&defLPat)); /* 10 */
    /*
      ((LPD3DSTATE)lpPointer)->drstRenderStateType =
      (D3DRENDERSTATETYPE)D3DRENDERSTATE_LINEPATTERN;
      memcpy(&(((LPD3DSTATE)lpPointer)->dwArg[0]), &defLPat, sizeof(DWORD));
      lpPointer = (void *)(((LPD3DSTATE)lpPointer) + 1);*/

    SetRenderStateInternal( D3DRENDERSTATE_ZWRITEENABLE, TRUE);
    SetRenderStateInternal( D3DRENDERSTATE_ALPHATESTENABLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_LASTPIXEL, TRUE);
    SetRenderStateInternal( D3DRENDERSTATE_SRCBLEND, D3DBLEND_ONE);
    SetRenderStateInternal( D3DRENDERSTATE_DESTBLEND, D3DBLEND_ZERO);
    SetRenderStateInternal( D3DRENDERSTATE_CULLMODE, D3DCULL_CCW); /* 21 */
    SetRenderStateInternal( D3DRENDERSTATE_ZFUNC, D3DCMP_LESSEQUAL);
    SetRenderStateInternal( D3DRENDERSTATE_ALPHAREF, 0);
    SetRenderStateInternal( D3DRENDERSTATE_ALPHAFUNC, D3DCMP_ALWAYS);
    SetRenderStateInternal( D3DRENDERSTATE_DITHERENABLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_FOGENABLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_ZVISIBLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_STIPPLEDALPHA, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_FOGCOLOR, 0);
    SetRenderStateInternal( D3DRENDERSTATE_FOGTABLEMODE, D3DFOG_NONE);
    tmpval = 0.0f;
    SetRenderStateInternal( D3DRENDERSTATE_FOGSTART, *((DWORD *)&tmpval));
    tmpval = 1.0f;
    SetRenderStateInternal( D3DRENDERSTATE_FOGEND, *((DWORD *)&tmpval));
    tmpval = 1.0f;
    SetRenderStateInternal( D3DRENDERSTATE_FOGDENSITY, *((DWORD *)&tmpval));
    SetRenderStateInternal( D3DRENDERSTATE_COLORKEYENABLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_ALPHABLENDENABLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_ZBIAS, 0);
    SetRenderStateInternal( D3DRENDERSTATE_RANGEFOGENABLE, FALSE);

    if (deviceType < D3DDEVTYPE_DX7HAL)
    {
        // send retired renderstate init's to pre-DX7 HALs only
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEENABLE, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_MONOENABLE, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_ROP2, R2_COPYPEN);
        SetRenderStateInternal( D3DRENDERSTATE_PLANEMASK, (DWORD)~0);
        SetRenderStateInternal( D3DRENDERSTATE_WRAPU, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_WRAPV, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_ANTIALIAS, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_SUBPIXEL, FALSE); /* 30 */
        SetRenderStateInternal( D3DRENDERSTATE_SUBPIXELX, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_EDGEANTIALIAS, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN00, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN01, 0); /* 40 */
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN02, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN03, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN04, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN05, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN06, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN07, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN08, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN09, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN10, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN11, 0); /* 50 */
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN12, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN13, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN14, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN15, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN16, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN17, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN18, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN19, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN20, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN21, 0); /* 60 */
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN22, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN23, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN24, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN25, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN26, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN27, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN28, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN29, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN30, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN31, 0); /* 70 */
    }

    // init stencil states to something reasonable
    // stencil enable is OFF by default since stenciling rasterizers will be
    // faster with it disabled, even if stencil states are benign
    SetRenderStateInternal( D3DRENDERSTATE_STENCILENABLE,   FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILFAIL,     D3DSTENCILOP_KEEP);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILZFAIL,    D3DSTENCILOP_KEEP);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILPASS,     D3DSTENCILOP_KEEP);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILFUNC,     D3DCMP_ALWAYS);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILREF,      0);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILMASK,     0xFFFFFFFF);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILWRITEMASK,0xFFFFFFFF);

    // don't forget about texturefactor (like we did in DX6.0...)
    SetRenderStateInternal( D3DRENDERSTATE_TEXTUREFACTOR,   0xFFFFFFFF);

    for (i = 0; i < 8; i++)
    {
        SetRenderStateInternal( (D3DRENDERSTATETYPE)
                        (D3DRENDERSTATE_WRAPBIAS + i), FALSE );
    }
    for (i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        lpD3DMappedTexI[i] = NULL;
        lpD3DMappedBlock[i] = NULL;
    }
    m_dwStageDirty = 0;

    // Obviate SetTextureStageState/Settexture filtering 'redundant' render state
    // settings since this is the init step.
    memset( this->tsstates, 0xff, sizeof(DWORD)*D3DHAL_TSS_MAXSTAGES*D3DHAL_TSS_STATESPERSTAGE );
    for (i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        SetTexture(i, NULL);
        if(i == 0)
            SetTextureStageState(i, D3DTSS_COLOROP, D3DTOP_MODULATE);
        else
            SetTextureStageState(i, D3DTSS_COLOROP, D3DTOP_DISABLE);
        SetTextureStageState(i, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        SetTextureStageState(i, D3DTSS_COLORARG2, D3DTA_CURRENT);
        if(i == 0)
            SetTextureStageState(i, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        else
            SetTextureStageState(i, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
        SetTextureStageState(i, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        SetTextureStageState(i, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT00, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT01, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT10, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT11, 0);
        SetTextureStageState(i, D3DTSS_TEXCOORDINDEX, 0);
        SetTextureStageState(i, D3DTSS_ADDRESS, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_BORDERCOLOR, 0x00000000);
        SetTextureStageState(i, D3DTSS_MAGFILTER, D3DTFG_POINT);
        SetTextureStageState(i, D3DTSS_MINFILTER, D3DTFN_POINT);
        SetTextureStageState(i, D3DTSS_MIPFILTER, D3DTFP_NONE);
        SetTextureStageState(i, D3DTSS_MIPMAPLODBIAS, 0);
        SetTextureStageState(i, D3DTSS_MAXMIPLEVEL, 0);
        SetTextureStageState(i, D3DTSS_MAXANISOTROPY, 1);
        SetTextureStageState(i, D3DTSS_BUMPENVLSCALE, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVLOFFSET, 0);
        SetTextureStageState(i, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
    }

#ifdef WIN95
    // Force a mapping if old HAL
    if(deviceType < D3DDEVTYPE_DP2HAL)
    {
        SetRenderStateInternal( D3DRENDERSTATE_TEXTUREHANDLE, (DWORD)NULL);
        static_cast<CDirect3DDeviceIHW*>(this)->MapTSSToRS();
    }
#endif

    SetRenderStateInternal(D3DRENDERSTATE_AMBIENT, 0);
    SetRenderStateInternal(D3DRENDERSTATE_COLORVERTEX, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_FOGVERTEXMODE, D3DFOG_NONE);
    SetRenderStateInternal(D3DRENDERSTATE_CLIPPING, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_LIGHTING, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_EXTENTS, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_NORMALIZENORMALS, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_LOCALVIEWER, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_COLORKEYBLENDENABLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
    SetRenderStateInternal(D3DRENDERSTATE_AMBIENTMATERIALSOURCE,  D3DMCS_MATERIAL);
    SetRenderStateInternal(D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,  D3DMCS_COLOR1);
    SetRenderStateInternal(D3DRENDERSTATE_SPECULARMATERIALSOURCE, D3DMCS_COLOR2);
    SetRenderStateInternal(D3DRENDERSTATE_VERTEXBLEND, D3DVBLEND_DISABLE);
    SetRenderStateInternal(D3DRENDERSTATE_CLIPPLANEENABLE, 0);

    // If we have created any textures prior to creating this device, then
    // let the driver know their priorities.
    if(DDCAPS2_CANMANAGETEXTURE & ((LPDDRAWI_DIRECTDRAW_INT)lpDirect3DI->lpDD)->lpLcl->lpGbl->ddCaps.dwCaps2)
    {
        LPDIRECT3DTEXTUREI lpTexI = LIST_FIRST(&lpDirect3DI->textures);
        while(lpTexI)
        {
            // If the texture is managed (by the driver)
            if(DDSCAPS2_TEXTUREMANAGE & ((LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS))->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2)
            {
                ret = lpTexI->SetPriority(lpTexI->m_dwPriority);
                if(ret != D3D_OK)
                {
                    D3D_ERR("SetPriority failed in device initialize.");
                    return ret;
                }
                ret = lpTexI->SetLOD(lpTexI->m_dwLOD);
                if(ret != D3D_OK)
                {
                    D3D_ERR("SetLOD failed in device initialize.");
                    return ret;
                }
            }
            lpTexI = LIST_NEXT(lpTexI, m_List);
        }
    }

    return(D3D_OK);
}

DWORD BitDepthToDDBD(int bpp)
{
    switch(bpp)
    {
    case 1:
        return DDBD_1;
    case 2:
        return DDBD_2;
    case 4:
        return DDBD_4;
    case 8:
        return DDBD_8;
    case 16:
        return DDBD_16;
    case 24:
        return DDBD_24;
    case 32:
        return DDBD_32;
    default:
        D3D_ERR("Invalid bit depth");
        return 0;
    }
}

HRESULT DIRECT3DDEVICEI::checkDeviceSurface(LPDIRECTDRAWSURFACE lpDDS, LPDIRECTDRAWSURFACE lpZbuffer, LPGUID pGuid)
{
    D3DDEVICEDESC7 Desc;
    DDPIXELFORMAT surfPF;
    DDSCAPS surfCaps;
    HRESULT ret;
    DWORD bpp;

    /* Get caps bits - check whether device and surface are:
       - video/system memory and depth compatible */

    if (FAILED(ret = lpDDS->GetCaps(&surfCaps))) {
        D3D_ERR("Failed to get render-target surface caps");
        return(ret);
    }

    memset(&surfPF, 0, sizeof(DDPIXELFORMAT));
    surfPF.dwSize = sizeof(DDPIXELFORMAT);

    if (FAILED(ret = lpDDS->GetPixelFormat(&surfPF))) {
        D3D_ERR("Failed to get render-target surface pixel format");
        return(ret);
    }

    if (IS_HW_DEVICE(this)) {
        /* I'm taking this as evidence that its running on hardware - therefore
           the surface should be in video memory */
        D3D_INFO(3, "Hardware device being used");

        if (!(surfCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
            D3D_ERR("Render-target surface not in video memory for hw device");
            return(D3DERR_SURFACENOTINVIDMEM);
        }
    }

    /* A surface can only have one bit depth - whereas a device can support
       multiple bit depths */
    if (surfPF.dwFlags & DDPF_RGB) {
        D3D_INFO(3, "Render-target surface is RGB");

        bpp = BitDepthToDDBD(surfPF.dwRGBBitCount);
        if (!bpp) {
            D3D_ERR("Bogus render-target surface pixel depth");
            return(DDERR_INVALIDPIXELFORMAT);
       }

       if((surfPF.dwRGBBitCount<16) && (IsEqualIID(*pGuid, IID_IDirect3DRefDevice) || IsEqualIID(*pGuid, IID_IDirect3DNullDevice))) {
           // this is actually subsumed by the following test, but whatever
            D3D_ERR("Reference rasterizer and null device dont support render targets with bitdepth < 16");
            return(DDERR_INVALIDPIXELFORMAT);
       }

        if (!(bpp & this->d3dDevDesc.dwDeviceRenderBitDepth)) {
            D3D_ERR("Render-target surface bitdepth is not supported by this device");
            return(DDERR_INVALIDPIXELFORMAT);
        }
    }

    if(lpZbuffer==NULL)
      return D3D_OK;

    memset(&surfPF, 0, sizeof(DDPIXELFORMAT));
    surfPF.dwSize = sizeof(DDPIXELFORMAT);

    if (FAILED(ret = lpZbuffer->GetPixelFormat(&surfPF))) {
        D3D_ERR("Failed to get zbuffer pixel format");
        return(ret);
    }

    if (FAILED(ret = lpZbuffer->GetCaps(&surfCaps))) {
        D3D_ERR("Failed to get Zbuffer caps");
        return(ret);
    }

    if (IS_HW_DEVICE(this)) {
        if (!(surfCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
            D3D_ERR("Zbuffer not in video memory for hw device");
            return(D3DERR_ZBUFF_NEEDS_VIDEOMEMORY);
        }
        D3D_INFO(3, "Hw device, zbuffer in video memory");
    } else {
        if (!(surfCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)) {
            D3D_ERR("Zbuffer not in system memory for HEL device");
            return(D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY);
        }
        D3D_INFO(3, "Hel device, zbuffer in system memory");

         // have to hack in a check to make sure ramp isn't used with stencil zbuffer
         // cant do this validation until device creation time (instead of at zbuffer creation in
         // ddhel.c) because rgb vs. ramp isn't known until now
         if(IsEqualIID(*pGuid, IID_IDirect3DRampDevice)) {
            if(surfPF.dwFlags & DDPF_STENCILBUFFER) {
                D3D_ERR("Z-Buffer with stencil is invalid with RAMP software rasterizer");
                return DDERR_INVALIDPARAMS;
            }
         }
    }

    if (surfPF.dwFlags & DDPF_ZBUFFER) {
        bpp = BitDepthToDDBD(surfPF.dwZBufferBitDepth);
        if (!bpp) {
            D3D_ERR("Bogus Zbuffer surface pixel depth");
            return(DDERR_INVALIDPIXELFORMAT);
        }
    }

    return(D3D_OK);
}


/*
 * Initialisation - class part and device part
 */

/*
 * Generic class part initialisation
 */
HRESULT InitDeviceI(LPDIRECT3DDEVICEI lpDevI, LPDIRECT3DI lpD3DI)
{
    LPDDRAWI_DIRECTDRAW_GBL lpDDI;
    HRESULT error;
    D3DDEVICEDESC7 dummyDesc;

    lpDDI = ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl;

    //
    // Retrieve HAL information from provider.
    //

    if (IS_HW_DEVICE(lpDevI))
        error = lpDevI->pHalProv->GetCaps(lpDDI,
                                      &lpDevI->d3dDevDesc,
                                      &dummyDesc,
                                      4);
    else
        error = lpDevI->pHalProv->GetCaps(lpDDI,
                                      &dummyDesc,
                                      &lpDevI->d3dDevDesc,
                                      4);
    if (error != S_OK)
    {
        return (error);
    }
    // Insert the GUID
    memcpy(&lpDevI->d3dDevDesc.deviceGUID, &lpDevI->guid, sizeof(GUID));

    if( lpDevI->d3dDevDesc.wMaxVertexBlendMatrices == 1 )
        lpDevI->d3dDevDesc.wMaxVertexBlendMatrices = 0;

    //
    // Fix up the caps for non-T&L devices
    // That use out front-end
    //
    if( IsEqualIID(lpDevI->guid, IID_IDirect3DHALDevice) ||
        IsEqualIID(lpDevI->guid, IID_IDirect3DRGBDevice) )
    {
        lpDevI->d3dDevDesc.dwMaxActiveLights = 0xffffffff;
        lpDevI->d3dDevDesc.wMaxVertexBlendMatrices = 4;
        lpDevI->d3dDevDesc.wMaxUserClipPlanes = __MAXUSERCLIPPLANES;
        lpDevI->d3dDevDesc.dwVertexProcessingCaps = D3DVTXPCAPS_ALL;
    }


    D3DHALPROVIDER_INTERFACEDATA HalProviderIData;
    memset(&HalProviderIData,0,sizeof(HalProviderIData));
    HalProviderIData.dwSize = sizeof(HalProviderIData);
    if ((error = lpDevI->pHalProv->GetInterface(lpDDI,
                                                &HalProviderIData,
                                                4)) != S_OK)
    {
        return error;
    }
    //  interface data for <=DX5 HAL
    lpDevI->lpD3DHALGlobalDriverData = HalProviderIData.pGlobalData;
    lpDevI->lpD3DExtendedCaps        = HalProviderIData.pExtCaps;
    lpDevI->lpD3DHALCallbacks        = HalProviderIData.pCallbacks;
    lpDevI->lpD3DHALCallbacks2       = HalProviderIData.pCallbacks2;
    //  interface data for DX6 HAL
    lpDevI->lpD3DHALCallbacks3       = HalProviderIData.pCallbacks3;

    lpDevI->pfnRastService = HalProviderIData.pfnRastService;
    lpDevI->dwHintFlags = 0;

    // This is available in all DX7+ drivers and is used by GetInfo API
    // call.
    lpDevI->pfnGetDriverState = HalProviderIData.pfnGetDriverState;

    // Zero out 8 bpp render target caps for real hardware.
    if (IS_HW_DEVICE(lpDevI))
    {
        lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwDeviceRenderBitDepth &=
            (~DDBD_8);
    }

    if (!D3DI_isHALValid(lpDevI->lpD3DHALCallbacks))
    {
        return D3DERR_INITFAILED;
    }

    if (lpDevI->lpD3DExtendedCaps && lpDevI->lpD3DExtendedCaps->dwFVFCaps)
    {
        lpDevI->dwMaxTextureIndices =
            lpDevI->lpD3DExtendedCaps->dwFVFCaps & D3DFVFCAPS_TEXCOORDCOUNTMASK;
        lpDevI->dwMaxTextureBlendStages =
            lpDevI->lpD3DExtendedCaps->wMaxTextureBlendStages;
        lpDevI->dwDeviceFlags |= D3DDEV_FVF;
        if (lpDevI->lpD3DExtendedCaps->dwFVFCaps & D3DFVFCAPS_DONOTSTRIPELEMENTS)
            lpDevI->dwDeviceFlags |= D3DDEV_DONOTSTRIPELEMENTS;

        DWORD value;
        if ((
#ifdef WIN95
            lpDevI->dwDebugFlags & D3DDEBUG_DISABLEDP ||
            lpDevI->dwDebugFlags & D3DDEBUG_DISABLEDP2 ||
#endif // WIN95
            (GetD3DRegValue(REG_DWORD, "DisableFVF", &value, 4) &&
            value != 0)) &&
            FVF_DRIVERSUPPORTED(lpDevI))
        {
            lpDevI->dwMaxTextureIndices = 1;
            lpDevI->dwDeviceFlags &= ~D3DDEV_FVF;
            lpDevI->dwDebugFlags |= D3DDEBUG_DISABLEFVF;
        }
        if ((GetD3DRegValue(REG_DWORD, "DisableStripFVF", &value, 4) &&
            value != 0))
        {
            lpDevI->dwDeviceFlags |= D3DDEV_DONOTSTRIPELEMENTS;
        }
    }
    else
    {
        lpDevI->dwMaxTextureIndices = 1;
        lpDevI->dwMaxTextureBlendStages = 1;
    }

    lpDevI->transform.dwMaxUserClipPlanes =
        lpDevI->d3dDevDesc.wMaxUserClipPlanes;

    lpDevI->dwFEFlags |= D3DFE_FRONTEND_DIRTY;

#if DBG
    lpDevI->dwCaller=0;
    memset(lpDevI->dwPrimitiveType,0,sizeof(lpDevI->dwPrimitiveType));
    memset(lpDevI->dwVertexType1,0,sizeof(lpDevI->dwVertexType1));
    memset(lpDevI->dwVertexType2,0,sizeof(lpDevI->dwVertexType2));
#endif
    return D3D_OK;
}

HRESULT D3DMallocBucket(LPDIRECT3DI lpD3DI, LPD3DBUCKET *lplpBucket)
{
    if (lpD3DI->lpFreeList == NULL ){
      if (lpD3DI->lpFreeList == NULL )
      {
        LPD3DBUCKET   lpBufferList;
        LPVOID  lpBuffer;
        int i;
        *lplpBucket=NULL;
        if (D3DMalloc(&lpBuffer, D3DBUCKETBUFFERSIZE*sizeof(D3DBUCKET)) != D3D_OK)
            return  DDERR_OUTOFMEMORY;
        D3D_INFO(9, "D3DMallocBucket %d Bytes allocated for %d free Buckets",
            D3DBUCKETBUFFERSIZE*sizeof(D3DBUCKET),D3DBUCKETBUFFERSIZE-1);
        lpBufferList=(LPD3DBUCKET)lpBuffer;
        for (i=0;i<D3DBUCKETBUFFERSIZE-2;i++)
            lpBufferList[i].next=&lpBufferList[i+1];
        lpBufferList[D3DBUCKETBUFFERSIZE-2].next=NULL;
        lpD3DI->lpFreeList=(LPD3DBUCKET)lpBuffer; //new free list
        lpBufferList[D3DBUCKETBUFFERSIZE-1].next=lpD3DI->lpBufferList;//add to lpBufferList
        lpBufferList[D3DBUCKETBUFFERSIZE-1].lpBuffer=lpBuffer;
        lpD3DI->lpBufferList=&lpBufferList[D3DBUCKETBUFFERSIZE-1];
      }
    }
    *lplpBucket=lpD3DI->lpFreeList;
    lpD3DI->lpFreeList=lpD3DI->lpFreeList->next;
    return  D3D_OK;
}

void    D3DFreeBucket(LPDIRECT3DI lpD3DI, LPD3DBUCKET lpBucket)
{
    lpBucket->next=lpD3DI->lpFreeList;
    lpD3DI->lpFreeList=lpBucket;
}

void DIRECT3DDEVICEI::CleanupTextures()
{
    /*
     * free up all textures created by this object - this also frees up Textures
     * We need to do this backwards because we cannot have a texture bound to
     * stage i + 1 when there is a texture bound to stage i.
     */
    for (int i = D3DHAL_TSS_MAXSTAGES - 1; i >= 0; --i)
    {
        if (lpD3DMappedTexI[i])
        {
            lpD3DMappedTexI[i]->Release();
            lpD3DMappedTexI[i] = NULL;
            lpD3DMappedBlock[i] = NULL;
        }
    }
    // The following code can result in D3DHAL_TextureDestroy() being called.
    // This BATCHES NEW INSTRUCTIONS in the instruction stream. So we must
    // make sure that at this point, the device is still able to accept
    // instructions.
    while (LIST_FIRST(&this->texBlocks)) {
        LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&this->texBlocks);
        D3DI_RemoveTextureHandle(tBlock);
        // Remove from device
        LIST_DELETE(tBlock, devList);
        // Remove from texture
        LIST_DELETE(tBlock, list);
        D3DFree(tBlock);
    }
    FlushStates();
}

/*
 * Generic device part destroy
 */
DIRECT3DDEVICEI::~DIRECT3DDEVICEI()
{
    LPDIRECTDRAWSURFACE lpDDS=NULL, lpDDSZ=NULL;
    LPDIRECTDRAWSURFACE7 lpDDS_DDS7=NULL;
    LPDIRECTDRAWPALETTE lpDDPal=NULL;

    /* Clear flags that could prohibit cleanup */
    this->dwHintFlags &=  ~(D3DDEVBOOL_HINTFLAGS_INSCENE);

    // Hold pointers into ddraw object for release after driver is destroyed
    lpDDSZ = this->lpDDSZBuffer;
    lpDDPal = this->lpDDPalTarget;
    lpDDS_DDS7 = this->lpDDSTarget_DDS7;

    // this indicates that the device need no longer be flushed when Locking, Blting
    // or GetDC'ing from the previous rendertarget
    if (this->lpDDSTarget)
        ((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSTarget)->lpLcl->lpSurfMore->qwBatch.QuadPart = 0;
    // this indicates that the device need no longer be flushed when Locking, Blting
    // or GetDC'ing from the previous zbuffer
    if (this->lpDDSZBuffer)
        ((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSZBuffer)->lpLcl->lpSurfMore->qwBatch.QuadPart = 0;

    if (pGeometryFuncs != &GeometryFuncsGuaranteed)
        delete pGeometryFuncs;

    D3DFE_Destroy(this);

    if (this->lpDirect3DI)
        UnhookFromD3D();

    if (this->lpwDPBufferAlloced)
        D3DFree(this->lpwDPBufferAlloced);

    if (this->pHalProv != NULL)
    {
        this->pHalProv->Release();
    }
    if (this->hDllProv != NULL)
    {
        FreeLibrary(this->hDllProv);
    }

    // Free the rstates that was allocated
    if(!(IS_HW_DEVICE(this) && IS_DP2HAL_DEVICE(this)))
    {
        delete rstates;
    }

    if (m_pStateSets)
        delete m_pStateSets;

    if (lpDDS)
        lpDDS->Release();
    if (lpDDSZ)
        lpDDSZ->Release();
    if (lpDDPal)
        lpDDPal->Release();
    if (lpDDS_DDS7)
        lpDDS_DDS7->Release();
    D3DFree(clrRects);
}

HRESULT DIRECT3DDEVICEI::HookToD3D(LPDIRECT3DI lpD3DI)
{

    LIST_INSERT_ROOT(&lpD3DI->devices, this, list);
    this->lpDirect3DI = lpD3DI;
    this->lpDirect3DI->AddRef(); // Since we hold a pointer to Direct3D
    lpD3DI->numDevs++;

    return (D3D_OK);
}

HRESULT DIRECT3DDEVICEI::UnhookFromD3D()
{
    LIST_DELETE(this, list);
    this->lpDirect3DI->numDevs--;
    this->lpDirect3DI->Release(); // Release our AddRef
    this->lpDirect3DI = NULL;

    return (D3D_OK);
}

/*
 * Create a device.
 *
 * NOTE: Radical modifications to support the aggregatable device
 * interface (so devices can be queried off DirectDraw surfaces):
 *
 * 1) This call is no longer a member of the Direct3D device interface.
 *    It is now an API function exported from the Direct3D DLL. Its
 *    a hidden API function - only DirectDraw will ever invoke it.
 *
 * 2) This call is, in effect, the class factory for Direct3DDevice
 *    objects. This function will be invoked to create the aggregated
 *    device object hanging off the DirectDraw surface.
 *
 * NOTE: So the Direct3DDevice knows which DirectDraw surface is
 * its rendering target this function is passed an interface pointer
 * for that DirectDraw surface. I suspect this blows a nice big
 * hole in the COM model as the DirectDraw surface is also the
 * owning interface of the device and I don't think aggregated
 * objects should know about thier owning interfaces. However, to
 * make this thing work this is what we have to do.
 *
 * EXTRA BIG NOTE: Because of the above don't take a reference to
 * the DirectDraw surface passed in. If you do you will get a circular
 * reference and the bloody thing will never die. When aggregated
 * the device interface's lifetime is entirely defined by the
 * lifetime of its owning interface (the DirectDraw surface) so the
 * DirectDraw surface can never go away before the texture.
 *
 * EXTRA EXTRA BIG NOTE: No device description is passed in any more.
 * The only things that can get passed in are things that DirectDraw
 * knows about (which does not include stuff like dither and color
 * model). Therefore, any input parameters must come in via a
 * different IID for the device. The data returned by the device
 * description must now be retrieved by another call.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DCreateDevice"

HRESULT WINAPI Direct3DCreateDevice(REFCLSID            riid,
                                    LPUNKNOWN           lpDirect3D,
                                    LPDIRECTDRAWSURFACE lpDDSTarget,
                                    LPUNKNOWN*          lplpD3DDevice,
                                    IUnknown*           pUnkOuter)
{
    LPDIRECT3DI           lpD3DI;
    LPDIRECT3DDEVICEI     pd3ddev;
    D3DCOLORMODEL         cm = D3DCOLOR_MONO;
    HRESULT               ret = D3D_OK;
    HKEY                  hKey = (HKEY) NULL;
    bool                  bDisableST = false;
    WORD                  wDriverStyle = MAX_DRIVERMODELS_SUPPORTED;
#if _D3D_FORCEDOUBLE
    bool    bForceDouble = true;
#endif  //_D3D_FORCEDOUBLE
    /* No need to validate params as they are passed to us by DirectDraw */

    /* CreateDevice member of IDirect3D2 will cause this function to be called
     * from within Direct3D. The parameters from the application level must be
     * validated. Need a way to validate the surface pointer from outside DDraw.
     */

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    if( ! VALID_PTR_PTR( lplpD3DDevice) )
    {
        D3D_ERR( "Invalid ptr to device pointer in Direct3DCreateDevice" );
        return DDERR_INVALIDPARAMS;
    }

    if(!IsValidD3DDeviceGuid(riid))
    {
        D3D_ERR( "Unrecognized Device GUID!");
        return DDERR_INVALIDPARAMS;
    }

    *lplpD3DDevice = NULL;

    // Might be safer to use dynamic_cast<> if RTTI is enabled
    lpD3DI = reinterpret_cast<CDirect3DUnk*>(lpDirect3D)->pD3DI;

    if (IsEqualIID(riid, IID_IDirect3DMMXDevice) && !isMMXprocessor()) {
      D3D_ERR("Can't create MMX Device on non-MMX machine");
      return DDERR_INVALIDPARAMS;
    }

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey) )
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;

        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "DriverStyle", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            // Win64 compiler will scream here!!
            wDriverStyle = (WORD)dwValue;
            if (wDriverStyle > MAX_DRIVERMODELS_SUPPORTED)
                wDriverStyle = MAX_DRIVERMODELS_SUPPORTED;
        }
        D3D_INFO(2,"DriverStyle: %d",wDriverStyle);

        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "DisableST", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            bDisableST = true;
        }
#if _D3D_FORCEDOUBLE
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "ForceDouble", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue == 0)
        {
            bForceDouble = false;
        }
        D3D_INFO(2,"ForceDouble: %d",bForceDouble);
#endif  //_D3D_FORCEDOUBLE
        RegCloseKey( hKey );
    }

    // Now create the appropriate device based on the wDriverStyle settings

    //---------------------------------------------------------------------
    // HKEY_LOCAL_MACHINE\Software\Microsoft\Direct3D\DriverStyle
    // In DX7 this registry key replaces the host of keys we had before like
    // DisableDP, DisableDP2 etc. This stuff is for testing purpose only.
    // It is more like a hint, in that, if the requested driver type is
    // available, it is used otherwise the latest available driver is used
    // The following is the meanings for this dword:
    //
    // Value:                    Driver-type:
    //       0x0                           Latest available
    //       0x1                           DeviceHW  (DX3)
    //       0x2                           DeviceDP  (DX5)
    //       0x3                           DeviceDP2 (DX6)
    //       0x4                           DeviceDX7 (DX7)
    //       0x5                           DeviceTL  (DX7+T&L)
    //
    // The following are the various cases we need to consider:
    // 1) NT Hardware: 3 and above are considered legal
    // 2) W9x Hardware: All of the above are legal
    // 3) Reference: 2 and above
    // 4) Software:  3 till 4 (no TL)
    //---------------------------------------------------------------------

    if (IsEqualIID(riid, IID_IDirect3DTnLHalDevice))
    {
        // For T&L hal guid, we ignore the wDriverStyle hint
        // set in the registry
        if (DDGBL(lpD3DI)->lpD3DGlobalDriverData &&
            (DDGBL(lpD3DI)->lpD3DGlobalDriverData->hwCaps.dwDevCaps &
             D3DDEVCAPS_HWTRANSFORMANDLIGHT))
        {
            wDriverStyle = D3DDRVMODEL_TL;
        }
        else // fail device creation
        {
            wDriverStyle = 0;
        }
        D3D_INFO(1,"TnLHalDevice Driver Style %x",wDriverStyle);
    }
    else if (IsEqualIID(riid, IID_IDirect3DHALDevice))
    {
        WORD wDriverCaps = 0;
        WORD wLatestDDI=0;
        //
        // 1) Determine what styles of DDIs the driver is capable of
        //

        // DX7 ?
        if (DDGBL(lpD3DI)->lpDDCBtmp &&
            DDGBL(lpD3DI)->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState)
        {
            wDriverCaps |= (1 << D3DDRVMODEL_DX7);
            if (wLatestDDI==0)
                wLatestDDI = D3DDRVMODEL_DX7;
        }

        // DX6 ?
        if (DDGBL(lpD3DI)->lpD3DHALCallbacks3 &&
            DDGBL(lpD3DI)->lpD3DHALCallbacks3->DrawPrimitives2)
        {
            wDriverCaps |= (1 << D3DDRVMODEL_DX6);
            if (wLatestDDI==0)
                wLatestDDI = D3DDRVMODEL_DX6;
        }

#ifdef WIN95
        // DX5 ?
        if (DDGBL(lpD3DI)->lpD3DHALCallbacks2 &&
            DDGBL(lpD3DI)->lpD3DHALCallbacks2->DrawOnePrimitive)
        {
            wDriverCaps |= (1 << D3DDRVMODEL_DX5);
            if (wLatestDDI==0)
                wLatestDDI = D3DDRVMODEL_DX5;
        }

        // DX3 ?
        if (DDGBL(lpD3DI)->lpD3DHALCallbacks &&
            DDGBL(lpD3DI)->lpD3DHALCallbacks->RenderPrimitive)
        {
            wDriverCaps |= (1 << D3DDRVMODEL_DX3);
            if (wLatestDDI==0)
                wLatestDDI = D3DDRVMODEL_DX3;
        }
#endif //WIN95

        //
        // 2) Verify if the requested driver is supported
        //
        if (wDriverCaps == 0)
        {
            wDriverStyle = 0;   // nothing supported so fail
        }
        else if (!(wDriverCaps & (1 << wDriverStyle)))
        {
            // use the latest available if not specified or
            // incorrectly specified or specified but not available
            wDriverStyle = wLatestDDI;
        }
        D3D_INFO(1,"HalDevice Driver Style %x",wDriverStyle);
    }
    // Reference Device
    else if (IsEqualIID(riid, IID_IDirect3DRefDevice))
    {
        // By default choose TL device for RefRast in DX7
        if (wDriverStyle < D3DDRVMODEL_DX5 || wDriverStyle > D3DDRVMODEL_TL)
        {
            // Refrast is capable of DX7+T&L
            wDriverStyle = D3DDRVMODEL_TL;
        }
    }
    // Software Rasterizers
    else
    {
        // Ignore driver style for everything except the reference rasterizer
        wDriverStyle = D3DDRVMODEL_DX6;
    }

    // Note: If wDriverStyle == 0x0 here, driver creation will fail
    // Something must have been chosen by now
    switch (wDriverStyle)
    {
#ifdef WIN95
    case D3DDRVMODEL_DX3:
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIHW());
        break;
    case D3DDRVMODEL_DX5:
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP());
        break;
#endif //WIN95
    case D3DDRVMODEL_DX6:
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP2());
        break;
    case D3DDRVMODEL_DX7:
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDevice7());
        break;
    case D3DDRVMODEL_TL:
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceTL());
        break;
    default:
        D3D_ERR("Runtime doesnt support requested/installed driver");
        // Change this return value ?
        return (DDERR_OUTOFMEMORY);
    }

    if (!pd3ddev) {
        D3D_ERR("Failed to allocate space for D3DDevice. Quitting.");
        return (DDERR_OUTOFMEMORY);
    }

    // If we have lost managed textures, we need to cleanup
    // since CheckSurfaces() would fail which would cause
    // FlushStates() to fail, which would result in the
    // current batch being abandoned (along with any device initialization)
    if(lpD3DI->lpTextureManager->CheckIfLost())
    {
        D3D_INFO(2, "Found lost managed textures. Evicting...");
        lpD3DI->lpTextureManager->EvictTextures();
    }

    ret = pd3ddev->Init(riid, lpD3DI, lpDDSTarget, pUnkOuter, lplpD3DDevice);
    if (ret!=D3D_OK)
    {
        delete pd3ddev;
        D3D_ERR("Failed to intilialize D3DDevice");
        return ret;
    }
    if (bDisableST)
        pd3ddev->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_MULTITHREADED;

#ifdef _X86_
    if (!(((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->dwLocalFlags & DDRAWILCL_FPUPRESERVE) &&
        IS_DP2HAL_DEVICE(pd3ddev))
    {
        pd3ddev->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_FPUSETUP;
        WORD wSave, wTemp;
        __asm {
            fstcw wSave
            mov ax, wSave
            and ax, not 300h    ;; single mode
            or  ax, 3fh         ;; disable all exceptions
            and ax, not 0C00h   ;; round to nearest mode
            mov wTemp, ax
            fldcw   wTemp
        }
    }
#if _D3D_FORCEDOUBLE
    if (bForceDouble && (pd3ddev->deviceType <= D3DDEVTYPE_DPHAL))
    {
        pd3ddev->dwDebugFlags |= D3DDEBUG_FORCEDOUBLE;
    }
    else
    {
        pd3ddev->dwDebugFlags &= ~D3DDEBUG_FORCEDOUBLE;
    }
#endif  //_D3D_FORCEDOUBLE
#endif

    return (ret);
}

HRESULT DIRECT3DDEVICEI::Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                              IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice)
{
    DDSCAPS               ddscaps;
    DDSURFACEDESC     ddsd;
    HRESULT       ret, ddrval;
    LPDIRECTDRAWSURFACE lpDDSZ=NULL;
    LPDIRECTDRAWPALETTE lpDDPal=NULL;
    LPGUID              pGuid;
    DDSCAPS surfCaps;

    m_qwBatch = 1;
    this->dwVIDIn = 0;
    this->refCnt = 1;

    pD3DMappedTexI = (LPVOID*)(this->lpD3DMappedTexI);

    /* Single threaded or Multi threaded app ? */
    if (((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->dwLocalFlags & DDRAWILCL_MULTITHREADED)
        this->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_MULTITHREADED;

    /*
     * Initialise textures
     */
    LIST_INITIALIZE(&this->texBlocks);

    this->dwVertexBase = 0;
    pGeometryFuncs = &GeometryFuncsGuaranteed;

    /*-----------------------------------------------------------------------------------------
     * Up till now we have done the easy part of the initialization. This is the stuff that
     * cannot fail. It initializes the object so that the destructor can be safely called if
     * any of the further initialization does not succeed.
     *---------------------------------------------------------------------------------------*/

    /*
     * Ensure the riid is one we understand.
     *
     * Query the registry.
     */
    pGuid = (GUID *)&riid;

#if DBG
    if (IsEqualIID(*pGuid, IID_IDirect3DTnLHalDevice))
    {
        D3D_INFO(0, "======================= TL-Hal device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DRGBDevice))
    {
        D3D_INFO(0, "======================= RGB device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DHALDevice))
    {
        D3D_INFO(0, "======================= HAL device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DRefDevice))
    {
        D3D_INFO(0, "======================= Reference Rasterizer device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DNullDevice))
    {
        D3D_INFO(0, "======================= Null device selected");
    }
#endif

    // set up flag to use MMX when requested RGB
    BOOL bUseMMXAsRGBDevice = FALSE;
    if (IsEqualIID(*pGuid, IID_IDirect3DRGBDevice) && isMMXprocessor())
    {
        bUseMMXAsRGBDevice = TRUE;
        // read reg key to override use of MMX for RGB
        HKEY    hKey = (HKEY) NULL;
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH, &hKey) )
        {
            DWORD dwType;
            DWORD dwValue;
            DWORD dwSize = 4;

            if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "UseMMXForRGB", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
                 dwType == REG_DWORD &&
                 dwValue == 0)
            {
                bUseMMXAsRGBDevice = FALSE;
            }
            RegCloseKey( hKey );
        }
        if (bUseMMXAsRGBDevice)
        {
            D3D_INFO(0, "  using MMX in RGB device");
        }
    }


    if (IsEqualIID(*pGuid, IID_IDirect3DRGBDevice) &&
        isMMXprocessor())
    {
        // Check for whether this app is one of the Intel ones
        // that want the MMX rasterizer
        LPDDRAWI_DIRECTDRAW_LCL lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl;

        // 0x4 corresponds to the "Intel app that wants MMX"
        // flag defined in ddrawpr.h
        if ( lpDDLcl->dwAppHackFlags & 0x4 )
        {
            pGuid = (GUID *)&IID_IDirect3DMMXDevice;
        }
    }

    /*
     * Check if the 3D cap is set on the surface.
     */
    memset(&ddsd, 0, sizeof ddsd);
    ddsd.dwSize = sizeof ddsd;
    ddrval = lpDDS->GetSurfaceDesc(&ddsd);
    if (ddrval != DD_OK) {
        D3D_ERR("Failed to get surface description of device's surface.");
        return (ddrval);
    }

    if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_3DDEVICE)) {
        D3D_ERR("**** The DDSCAPS_3DDEVICE is not set on this surface.");
        D3D_ERR("**** You need to add DDSCAPS_3DDEVICE to ddsCaps.dwCaps");
        D3D_ERR("**** when creating the surface.");
        return (DDERR_INVALIDCAPS);
    }

    if (ddsd.ddsCaps.dwCaps & DDSCAPS_ZBUFFER) {
        D3D_ERR("**** DDSCAPS_ZBUFFER is set on this surface.");
        D3D_ERR("**** Rendering into Z buffer surfaces is not");
        D3D_ERR("**** currently supported by Direct3D.");
        return (DDERR_INVALIDCAPS);
    }

    if (ddsd.dwWidth > 2048 || ddsd.dwHeight > 2048)
    {
        D3D_ERR("**** Surface too large - must be <= 2048 in width & height.");
        return (DDERR_INVALIDOBJECT);
    }

    /* Check for palette... */
    ret = lpDDS->GetPalette(&lpDDPal);
    if ((ret != DD_OK) && (ret != DDERR_NOPALETTEATTACHED))
    {
        /*
         * NOTE: Again, not an error (yet) if there is no palette attached.
         * But if there is palette and we can't get at it for some reason
         * - fail.
         */
        D3D_ERR("Supplied DirectDraw Palette is invalid - can't create device");
        return (DDERR_INVALIDPARAMS);
    }

    /*
     * We're going to check now whether we should have got a palette.
     */
    if (ret == DDERR_NOPALETTEATTACHED) {
        if (ddsd.ddpfPixelFormat.dwRGBBitCount < 16) {
            D3D_ERR("No palette supplied for palettized surface - can't create device");
            return (DDERR_NOPALETTEATTACHED);
        }
    }

    this->lpDDPalTarget = lpDDPal;

    // Check for ZBuffer

    memset(&surfCaps, 0, sizeof(DDSCAPS));
    surfCaps.dwCaps = DDSCAPS_ZBUFFER;

    if (FAILED(ret = lpDDS->GetAttachedSurface(&surfCaps, &lpDDSZ))) {
        if (ret != DDERR_NOTFOUND) {
           D3D_ERR("Failed GetAttachedSurface for ZBuffer");
           goto handle_err;
        }
        D3D_INFO(2, "No zbuffer is attached to rendertarget surface (which is OK)");
    }

    this->lpDDSZBuffer = lpDDSZ;

    this->guid = *pGuid;

    // Try to get a HAL provider for this driver (may need to use MMX guid if
    // using MMX for RGB requested device)
    ret = GetSwHalProvider(
        bUseMMXAsRGBDevice ? IID_IDirect3DMMXAsRGBDevice : riid,
        &this->pHalProv, &this->hDllProv);

    if (ret == S_OK)
    {
        // Got a software provider.
    }
    else if (ret == E_NOINTERFACE &&
             ((ret = GetHwHalProvider(riid, &this->pHalProv,
                                     &this->hDllProv,
                                     ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl)) == S_OK))
    {
        // Got a hardware provider.
    }
    else
    {
        if( IsEqualIID(riid, IID_IDirect3DHALDevice) ||
            IsEqualIID(riid, IID_IDirect3DTnLHalDevice)) {
            D3D_ERR("Requested HAL Device non-existent or invalid");
        } else {
            D3D_ERR("Unable to get D3D Device provider for requested GUID");
        }
        goto handle_err;
    }

    {
        // Initialize test HAL provider to drop HAL calls (sort of a Null device)
        //
        DWORD value = 0;
        if (GetD3DRegValue(REG_DWORD, "DisableRendering", &value, sizeof(DWORD)) &&
            value != 0)
        {
            ret = GetTestHalProvider(
                    riid, ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl,
                    &this->pHalProv, this->pHalProv, 0);
            if (ret != D3D_OK)
            {
                D3D_ERR("Unable to set up 'DisableRendering' mode");
                goto handle_err;
            }
        }
    }

    // Initialise general DEVICEI information.
    if ((ret = InitDeviceI(this, lpD3DI)) != D3D_OK)
    {
        D3D_ERR("Failed to initialise device");
        goto handle_err;
    }

    // Check the surface and device to see if they're compatible
    if (FAILED(ret = checkDeviceSurface(lpDDS,lpDDSZ,pGuid))) {
        D3D_ERR("Device and surface aren't compatible");
        goto handle_err;
    }

    // Create front-end support structures.
    // ATTENTION - We probably want to avoid doing this if the driver
    // does its own front end.  Software fallbacks complicate the issue,
    // though.
    ret = D3DFE_Create(this, lpD3DI->lpDD, lpD3DI->lpDD7, lpDDS, lpDDSZ, lpDDPal);
    if (ret != D3D_OK)
    {
        D3D_ERR("Failed to create front-end data-structures.");
        goto handle_err;
    }

    // Figure out place for rstates
    if (IS_HW_DEVICE(this) && IS_DP2HAL_DEVICE(this))
    {
        // In case of HW DP2 HAL we reuse the kernel allocated
        // memory for RStates since we need the driver to update
        // it
        rstates = (LPDWORD)lpwDPBuffer;
    }
    else
    {
        // In all other cases we simply allocate memory for rstates
        rstates = new DWORD[D3D_MAXRENDERSTATES];
    }
    D3DFE_PROCESSVERTICES::lpdwRStates = this->rstates;

    // Check if we have a processor specific implementation available
    //  only use if DisablePSGP is not in registry or set to zero
    DWORD value;
    if (!GetD3DRegValue(REG_DWORD, "DisablePSGP", &value, sizeof(DWORD)))
    {
        value = 0;
    }
#ifdef _X86_
    if (value != 1)
    {
        if ( dwCPUFeatures & D3DCPU_X3D && value != 2)
           pfnFEContextCreate = px3DContextCreate;
        else if ( dwCPUFeatures & D3DCPU_WLMT )
           pfnFEContextCreate = wlmt_FEContextCreate;
        else if ( dwCPUFeatures & D3DCPU_SSE )
           pfnFEContextCreate = katmai_FEContextCreate;

        if (pfnFEContextCreate)
        {
            D3D_INFO(0, "PSGP enabled for device");
            // Ask the PV implementation to create a device specific "context"
            LPD3DFE_PVFUNCS pOptGeoFuncs = pGeometryFuncs;
            ret = pfnFEContextCreate(dwDeviceFlags, &pOptGeoFuncs);
            if ((ret == D3D_OK) && pOptGeoFuncs)
            {
                D3D_INFO(2, "using PSGP");
                pGeometryFuncs = pOptGeoFuncs;
            }
        }
    }
#endif // _X86_

    /*
     * put this device in the list of those owned by the Direct3D object
     */
    ret = HookToD3D(lpD3DI);
    if (ret != D3D_OK)
    {
        D3D_ERR("Failed to associate device with Direct3D");
        goto handle_err;
    }
    {
        if (HVbuf.Grow((__INIT_VERTEX_NUMBER*2)*sizeof(D3DFE_CLIPCODE)) != DD_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (HVBuf)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }
        ret = this->ClipperState.clipBuf.Grow
                (this, MAX_CLIP_VERTICES*__MAX_VERTEX_SIZE);
        if (ret != D3D_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (ClipBuf)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }
        ret = this->ClipperState.clipBufPrim.Grow
                (this, MAX_CLIP_TRIANGLES*sizeof(D3DTRIANGLE));
        if (ret != D3D_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (ClipBufPrim)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }

    }

    // this indicates that the device should always be flushed when Locking, Blting
    // or GetDC'ing a rendertarget
    ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->lpSurfMore->qwBatch.QuadPart = _UI64_MAX;
    // this indicates that the device should always be flushed when Locking, Blting
    // or GetDC'ing a zbuffer
    if (lpDDSZ)
    {
        ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSZ)->lpLcl->lpSurfMore->qwBatch.QuadPart = _UI64_MAX;
    }

    /* Set the initial render state of the device */
    if (FAILED(ret = stateInitialize(lpDDSZ!=NULL)))
    {
        D3D_ERR("Failed to set initial state for device");
        goto handle_err;
    }

    // Setup the viewport
    m_Viewport.dwX = 0;
    m_Viewport.dwY = 0;
    m_Viewport.dwWidth  = ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wWidth;
    m_Viewport.dwHeight = ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wHeight;
    m_Viewport.dvMinZ = (D3DVALUE)0;
    m_Viewport.dvMaxZ = (D3DVALUE)1;
    if (FAILED(this->SetViewport(&m_Viewport)))
        goto handle_err;

    // Setup lights
    m_dwNumLights = 8;
    m_pLights = new DIRECT3DLIGHTI[8];
    LIST_INITIALIZE(&m_ActiveLights);

    // Setup material
    memset(&this->lighting.material, 0, sizeof(this->lighting.material));

    // Setup set states
    m_pStateSets = new CStateSets;
    if (m_pStateSets == NULL)
        return DDERR_OUTOFMEMORY;
    m_pStateSets->Init(this->dwFEFlags);

#ifdef PROFILE4
    m_dwProfStart = m_dwProfStop = 0;
    GetD3DRegValue(REG_DWORD, "ProfileStartFrame", &m_dwProfStart, 4);
    GetD3DRegValue(REG_DWORD, "ProfileStopFrame", &m_dwProfStop, 4);
#endif
#ifdef PROFILE
    m_dwProfStart = m_dwProfStop = 0;
    GetD3DRegValue(REG_DWORD, "ProfileStartFrame", &m_dwProfStart, 4);
    GetD3DRegValue(REG_DWORD, "ProfileStopFrame", &m_dwProfStop, 4);
#endif

#ifdef VTABLE_HACK
    // Copy with vtable
    lpVtbl = *((LPVOID**)this);
    memcpy(newVtbl, lpVtbl, sizeof(PVOID)*D3D_NUM_VIRTUAL_FUNCTIONS);
    // Point to the new one
    *((LPVOID*)this) = (LPVOID)newVtbl;

    // Set vtable hack for PreLoad() if single threaded and not software
    if (!IS_MT_DEVICE(this) && (this->dwFEFlags & D3DFE_REALHAL))
    {
        VtblPreLoadFast();
    }
#endif // VTABLE_HACK

    /*
     * NOTE: We don't return the actual device interface. We
     * return the device's special IUnknown interface which
     * will be used in a QueryInterface to get the actual
     * Direct3D device interface.
     */
    *lplpD3DDevice = static_cast<LPUNKNOWN>(this);
    return (D3D_OK);

handle_err:
    // might be able to simplify if this fn and not D3DFE_Create sets this->lpDDSZBuffer/this->lpDDPalette
    if(lpDDSZ!=NULL) {
       lpDDSZ->Release();    // release the reference GetAttachedSurface created
       this->lpDDSZBuffer=NULL;  // make sure the device destructor doesn't try to re-release this
                                 // I'd let device destructor handle this, but errors can occur before D3DFE_Create is called
    }

    if(lpDDPal!=NULL) {
      lpDDPal->Release();      // release the reference GetPalette created
      this->lpDDPalTarget=NULL;  // make sure the device destructor doesn't try to re-release this
    }

    D3D_ERR("Device creation failed!!");
    return(ret);
}

HRESULT D3DAPI DIRECT3DDEVICEI::GetCaps(LPD3DDEVICEDESC7 lpD3DDevDesc)
{
    HRESULT ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_D3DDEVICEDESC7_PTR(lpD3DDevDesc))
    {
        D3D_ERR( "Invalid D3DDEVICEDESC7 pointer" );
        return DDERR_INVALIDPARAMS;
    }
    memcpy(lpD3DDevDesc, &this->d3dDevDesc, sizeof( D3DDEVICEDESC7 ));
    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::EnumTextureFormats"

HRESULT D3DAPI DIRECT3DDEVICEI::EnumTextureFormats(
    LPD3DENUMPIXELFORMATSCALLBACK lpEnumCallback,
    LPVOID lpContext)
{
    HRESULT ret, userRet;
    LPDDSURFACEDESC lpDescs, lpRetDescs;
    DWORD num_descs;
    DWORD i;

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        ret = D3D_OK;

        if (!VALID_DIRECT3DDEVICE_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALIDEX_CODE_PTR(lpEnumCallback))
        {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }

        LPDDRAWI_DIRECTDRAW_LCL lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(this->lpDD))->lpLcl;
        BOOL bFourCCAppHack =
            (lpDDLcl->dwAppHackFlags & DDRAW_APPCOMPAT_TEXENUMDX7FOURCC)?1:0;
        D3D_INFO(3, "APPCOMPAT_TEXENUMDX7FOURCC: %d",bFourCCAppHack);

        num_descs = this->lpD3DHALGlobalDriverData->dwNumTextureFormats;
        lpDescs = this->lpD3DHALGlobalDriverData->lpTextureFormats;
        if (!num_descs)
        {
            D3D_ERR("no texture formats supported");
            return (D3DERR_TEXTURE_NO_SUPPORT);
        }

        if (D3DMalloc((void**)&lpRetDescs, sizeof(DDSURFACEDESC) * num_descs) != D3D_OK)
        {
            D3D_ERR("failed to alloc space for return descriptions");
            return (DDERR_OUTOFMEMORY);
        }
        memcpy(lpRetDescs, lpDescs, sizeof(DDSURFACEDESC) * num_descs);

        userRet = D3DENUMRET_OK;
        for (i = 0; i < num_descs && userRet == D3DENUMRET_OK; i++) {

            // Filter out any DX8 formats
            if (lpRetDescs[i].ddpfPixelFormat.dwFlags & DDPF_D3DFORMAT)
            {
                continue;
            }

            // Filter out non-DXTn FourCCs if apphack set
            if ( bFourCCAppHack && (lpRetDescs[i].ddpfPixelFormat.dwFlags == DDPF_FOURCC) )
            {
                if ( (lpRetDescs[i].ddpfPixelFormat.dwFourCC != MAKEFOURCC('D', 'X', 'T', '1')) &&
                     (lpRetDescs[i].ddpfPixelFormat.dwFourCC != MAKEFOURCC('D', 'X', 'T', '2')) &&
                     (lpRetDescs[i].ddpfPixelFormat.dwFourCC != MAKEFOURCC('D', 'X', 'T', '3')) &&
                     (lpRetDescs[i].ddpfPixelFormat.dwFourCC != MAKEFOURCC('D', 'X', 'T', '4')) &&
                     (lpRetDescs[i].ddpfPixelFormat.dwFourCC != MAKEFOURCC('D', 'X', 'T', '5')) )
                {
                    D3D_INFO(3, "EnumTextureFormats: filtering non-DXT FourCC format <%08x>",
                        lpRetDescs[i].ddpfPixelFormat.dwFourCC);
                    continue;
                }
            }

            userRet = (*lpEnumCallback)(&(lpRetDescs[i].ddpfPixelFormat), lpContext);
        }

        D3DFree(lpRetDescs);

        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#if COLLECTSTATS
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::ResetStats"
void DIRECT3DDEVICEI::ResetTexStats()
{
    this->lpDirect3DI->ResetTexStats();
    memset(&m_texstats, 0, sizeof(D3DDEVINFO_TEXTURING));
}
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::BeginScene"

HRESULT D3DAPI DIRECT3DDEVICEI::BeginScene()
{
#ifdef PROFILE4
    static DWORD dwFrameCount = 0;
#endif
#ifdef PROFILE
    static DWORD dwFrameCount = 0;
#endif
    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        if (!VALID_DIRECT3DDEVICE_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)
        {
            D3D_ERR("BeginScene, already in scene.");
            return (D3DERR_SCENE_IN_SCENE);
        }

        // Check if we lost surfaces or rtarget / zbuffer was locked
        HRESULT servRet = this->CheckSurfaces();
        if (servRet != D3D_OK)
        {
            // If we lost surfaces
            if (servRet == DDERR_SURFACELOST)
            {
                // Even if the app restores the rendertargets and z buffer, it
                // doesn't know anything about vidmem execute buffers or
                // managed texture surfaces in vidmem. So, we need to do
                // this on our own. We first check if it is safe to restore
                // surfaces. If not, we fail in the usual way. Else, we
                // do the restore. Note that we will fail *only* if the
                // app calls BeginScene at the wrong time.
                servRet = this->lpDirect3DI->lpDD7->TestCooperativeLevel();
                if (servRet == DD_OK)
                {
                    // Everything must be evicted otherwise Restore might not work
                    // as there might be new surface allocated, in fact, we should
                    // post a flag in Device so that Texture manage stop calling
                    // CreateSurface() if this flag is indicating TestCooperativeLevel()
                    // failed, however, even we added those, the EvictTextures below
                    // is still needed but not this critical--kanqiu
                    this->lpDirect3DI->lpTextureManager->EvictTextures();
                    if(IS_DP2HAL_DEVICE(this))
                    {
                        // We just bother restoring our internal vertex and command buffers
                        // It is upto the app to restore all surfaces that IT allocated.
                        // (managed textures are taken care of by the preceding evict)
                        CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2*>(this);
                        servRet = dp2dev->TLVbuf_GetDDS()->Restore();
                        if (servRet != DD_OK)
                            return D3DERR_SCENE_BEGIN_FAILED;
                        servRet = dp2dev->lpDDSCB1->Restore();
                        if (servRet != DD_OK)
                            return D3DERR_SCENE_BEGIN_FAILED;
                        // If TLVbuf was really lost
                        if (dp2dev->TLVbuf_GetVBI()->position.lpvData == 0)
                        {
                            DPF(10, "Need to reallocate TLVbuf");
                            // Reallocate TLVbuf of the orig size in the same memory location as before
                            dp2dev->TLVbuf_base = 0;
                            DWORD origSize = dp2dev->TLVbuf_size;
                            dp2dev->TLVbuf_size = 0;
                            if (dp2dev->TLVbuf_Grow(origSize, (this->dwDeviceFlags & D3DDEV_TLVBUFWRITEONLY) != 0) != DD_OK)
                            {
                                D3D_ERR( "Out of memory in BeginScene (TLVbuf)" );
                                return DDERR_OUTOFMEMORY;
                            }
                        }
                        // Release current VB since it could be app created and app might want
                        // to get rid of it due to the mode change.
                        if (dp2dev->lpDP2CurrBatchVBI)
                        {
                            dp2dev->lpDP2CurrBatchVBI->lpDevIBatched = NULL;
                            dp2dev->lpDP2CurrBatchVBI->Release();
                        }
                        dp2dev->lpDP2CurrBatchVBI = dp2dev->TLVbuf_GetVBI();
                        dp2dev->lpDP2CurrBatchVBI->AddRef();
                        dp2dev->dp2data.lpDDVertex = DDSLCL(dp2dev->TLVbuf_GetDDS());
                        dp2dev->dp2data.dwVertexLength = 0;
#ifdef VTABLE_HACK
                        dp2dev->VtblDrawPrimitiveDefault();
                        dp2dev->VtblDrawPrimitiveVBDefault();
                        dp2dev->VtblDrawIndexedPrimitiveDefault();
                        dp2dev->VtblDrawIndexedPrimitiveVBDefault();
#endif
                    }
                    servRet = this->CheckSurfaces();
                    if(servRet != D3D_OK)
                        return servRet;
                    this->dwFEFlags &= ~D3DFE_LOSTSURFACES;
                }
                else
                    return DDERR_SURFACELOST;
            }
            else
            {
                // Render target and / or the z buffer was locked
                return servRet;
            }
        }
        else
        {
            // We need to check if TLVbuf was lost. The app could have restored
            // all surfaces and thus we might not know by check TCL. However the
            // BreakLock function would have been called on the VB and the position.lpvData
            // would be set to NULL. We check this to detect that the TLVbuf was lost.
            if (IS_DP2HAL_DEVICE(this))
            {
                CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2*>(this);
                // If the lock was broken
                if (dp2dev->TLVbuf_GetVBI()->position.lpvData == 0)
                {
                    DPF(10, "Broken lock on TLVbuf. Need to reallocate");
                    // Reallocate TLVbuf of the orig size in the same memory location as before
                    dp2dev->TLVbuf_base = 0;
                    DWORD origSize = dp2dev->TLVbuf_size;
                    dp2dev->TLVbuf_size = 0;
                    if (dp2dev->TLVbuf_Grow(origSize, (this->dwDeviceFlags & D3DDEV_TLVBUFWRITEONLY) != 0) != DD_OK)
                    {
                        D3D_ERR( "Out of memory in BeginScene (TLVbuf)" );
                        return DDERR_OUTOFMEMORY;
                    }
                }
            }
        }
        if (IS_DX7HAL_DEVICE(this))
        {
            if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            {
                D3D_ERR("Cannot be recording state macros when calling BeginScene");
                return (D3DERR_SCENE_END_FAILED);
            }
            servRet = SetRenderStateI((D3DRENDERSTATETYPE)D3DRENDERSTATE_SCENECAPTURE, TRUE);
        }
        else
            servRet = D3DHAL_SceneCapture(this, TRUE);

        if (servRet != D3D_OK && servRet != DDERR_NOTFOUND)
        {
            D3D_ERR("Could not BeginScene.");
            return D3DERR_SCENE_BEGIN_FAILED;
        }

#ifdef PROFILE4
        if (++dwFrameCount == m_dwProfStart)
        {
            OutputDebugString("Direct3D IM 7.0: Started Profiling...\n");
            StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
        }
        else if (dwFrameCount == m_dwProfStop)
        {
            StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
            OutputDebugString("Direct3D IM 7.0: Stopped Profiling.\n");
        }
#endif
#ifdef PROFILE
        if (++dwFrameCount == m_dwProfStart)
        {
            OutputDebugString("Direct3D IM 7.0: Started Profiling...\n");
            StartCAP();
        }
        else if (dwFrameCount == m_dwProfStop)
        {
            StopCAP();
            OutputDebugString("Direct3D IM 7.0: Stopped Profiling.\n");
        }
#endif

        // So that currently bound textures get scene stamped
        m_dwStageDirty = (1ul << this->dwMaxTextureBlendStages) - 1ul;
        this->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE;

#if COLLECTSTATS
        this->lpDirect3DI->lpTextureManager->ResetStatCounters();
        this->ResetTexStats();
#endif

        this->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INSCENE;
        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#if COLLECTSTATS
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::DisplayStats"

void DIRECT3DDEVICEI::DisplayStats()
{
    HDC hDC;
    if(SUCCEEDED(this->lpDDSTarget_DDS7->GetDC(&hDC)))
    {
        HFONT hOldFont = (HFONT)SelectObject(hDC, this->lpDirect3DI->m_hFont);
        SetTextColor(hDC, RGB(255,255,0));
        SetBkMode(hDC, TRANSPARENT);
        D3DDEVINFO_TEXTUREMANAGER stats;
        GetInfo(D3DDEVINFOID_TEXTUREMANAGER, &stats, sizeof(D3DDEVINFO_TEXTUREMANAGER));
        char str[256];
        int x = STATS_FONT_SIZE, y = STATS_FONT_SIZE, len;
        len = sprintf(str, "Texture Cache Management Statistics");
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "-----------------------------------");
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Thrashing     : %s", stats.bThrashing ? "Yes" : "No");
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Downloaded    : %d bytes", stats.dwApproxBytesDownloaded);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Evicts        : %d", stats.dwNumEvicts);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Creates       : %d", stats.dwNumVidCreates);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Textures used : %d", stats.dwNumTexturesUsed);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Hit rate      : %d%%", stats.dwNumTexturesUsed != 0 ? ((stats.dwNumUsedTexInVid * 100) / stats.dwNumTexturesUsed) : 0);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Working set   : %d (%d bytes)", stats.dwWorkingSet, stats.dwWorkingSetBytes);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Total managed : %d (%d bytes)", stats.dwTotalManaged, stats.dwTotalBytes);
        TextOut( hDC, x, y, str, len );
        D3DDEVINFO_TEXTURING texstats;
        GetInfo(D3DDEVINFOID_TEXTURING, &texstats, sizeof(D3DDEVINFO_TEXTURING));
        y += STATS_FONT_SIZE * 2;
        len = sprintf(str, "Texturing Statistics");
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "--------------------");
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Loads         : %d (%d bytes)", texstats.dwNumLoads, texstats.dwApproxBytesLoaded);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "PreLoads      : %d", texstats.dwNumPreLoads);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "SetTextures   : %d", texstats.dwNumSet);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Creates       : %d", texstats.dwNumCreates);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Destroys      : %d", texstats.dwNumDestroys);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "SetPriorities : %d", texstats.dwNumSetPriorities);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "SetLODs       : %d", texstats.dwNumSetLODs);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Locks         : %d", texstats.dwNumLocks);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "GetDCs        : %d", texstats.dwNumGetDCs);
        TextOut( hDC, x, y, str, len );
        SelectObject(hDC, hOldFont);
        this->lpDDSTarget_DDS7->ReleaseDC(hDC);
    }
}
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::EndScene"

HRESULT D3DAPI DIRECT3DDEVICEI::EndScene()
{
    HRESULT servRet;

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        if (!VALID_DIRECT3DDEVICE_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!(this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)) {
            D3D_ERR("EndScene, not in scene.");
            return (D3DERR_SCENE_NOT_IN_SCENE);
        }

        this->dwHintFlags &= ~D3DDEVBOOL_HINTFLAGS_INSCENE;
        if (IS_DX7HAL_DEVICE(this))
        {
            if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            {
                D3D_ERR("Cannot be recording state macros when calling EndScene");
                return (D3DERR_SCENE_END_FAILED);
            }
            servRet = SetRenderStateI((D3DRENDERSTATETYPE)D3DRENDERSTATE_SCENECAPTURE, FALSE);
            if (servRet != D3D_OK)
            {
                D3D_ERR("Could not send EndScene to Driver!");
                return (D3DERR_SCENE_END_FAILED);
            }
            servRet = FlushStates();    //time to flush DrawPrimitives
        }
        else
        {
            servRet = FlushStates();    //time to flush DrawPrimitives
            if (servRet != D3D_OK)
            {
                D3D_ERR("Could not Flush commands in EndScene!");
                return (D3DERR_SCENE_END_FAILED);
            }
            servRet = D3DHAL_SceneCapture(this, FALSE);
        }
        if (servRet != D3D_OK && servRet != DDERR_NOTFOUND)
        {
            DPF(0, "(ERROR) Direct3DDevice::EndScene: Could not EndScene. Returning %08lx", servRet);
            return (D3DERR_SCENE_END_FAILED);
        }

        // Did we lose any surfaces during this scene ?
        if (this->dwFEFlags & D3DFE_LOSTSURFACES)
        {
            D3D_INFO(3, "reporting DDERR_SURFACELOST in EndScene");
            this->dwFEFlags &= ~D3DFE_LOSTSURFACES;
            return DDERR_SURFACELOST;
        }

        // Update the scene count in texman
        lpDirect3DI->lpTextureManager->SceneStamp();

        // Clear num TLVbuf changes per frame
        if (IS_DP2HAL_DEVICE(this))
        {
            CDirect3DDeviceIDP2* dev = static_cast<CDirect3DDeviceIDP2*>(this);
            dev->dwTLVbufChanges = 0;
        }

#if COLLECTSTATS
        // Display stats if they have been enabled via regkey
        if(this->lpDirect3DI->m_hFont != 0)
        {
            DisplayStats();
        }
#endif

        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

void
D3DDeviceDescConvert(LPD3DDEVICEDESC7 lpOut,
                     LPD3DDEVICEDESC_V1 lpV1,
                     LPD3DHAL_D3DEXTENDEDCAPS lpExt)
{
    if( lpV1 )
    {
        lpOut->dwDevCaps = lpV1->dwDevCaps;
        lpOut->dpcLineCaps = lpV1->dpcLineCaps;
        lpOut->dpcTriCaps = lpV1->dpcTriCaps;
        lpOut->dwDeviceRenderBitDepth = lpV1->dwDeviceRenderBitDepth;
        lpOut->dwDeviceZBufferBitDepth = lpV1->dwDeviceZBufferBitDepth;
    }

    if (lpExt)
    {
        // DX5
        lpOut->dwMinTextureWidth = lpExt->dwMinTextureWidth;
        lpOut->dwMaxTextureWidth = lpExt->dwMaxTextureWidth;
        lpOut->dwMinTextureHeight = lpExt->dwMinTextureHeight;
        lpOut->dwMaxTextureHeight = lpExt->dwMaxTextureHeight;

        // DX6
        lpOut->dwMaxTextureRepeat = lpExt->dwMaxTextureRepeat;
        lpOut->dwMaxTextureAspectRatio = lpExt->dwMaxTextureAspectRatio;
        lpOut->dwMaxAnisotropy = lpExt->dwMaxAnisotropy;
        lpOut->dvGuardBandLeft = lpExt->dvGuardBandLeft;
        lpOut->dvGuardBandTop = lpExt->dvGuardBandTop;
        lpOut->dvGuardBandRight = lpExt->dvGuardBandRight;
        lpOut->dvGuardBandBottom = lpExt->dvGuardBandBottom;
        lpOut->dvExtentsAdjust = lpExt->dvExtentsAdjust;
        lpOut->dwStencilCaps = lpExt->dwStencilCaps;
        lpOut->dwFVFCaps = lpExt->dwFVFCaps;
        lpOut->dwTextureOpCaps = lpExt->dwTextureOpCaps;
        lpOut->wMaxTextureBlendStages = lpExt->wMaxTextureBlendStages;
        lpOut->wMaxSimultaneousTextures = lpExt->wMaxSimultaneousTextures;

        // DX7
        lpOut->dwMaxActiveLights = lpExt->dwMaxActiveLights;
        lpOut->dvMaxVertexW = lpExt->dvMaxVertexW;
        lpOut->wMaxUserClipPlanes = lpExt->wMaxUserClipPlanes;
        lpOut->wMaxVertexBlendMatrices = lpExt->wMaxVertexBlendMatrices;
        lpOut->dwVertexProcessingCaps = lpExt->dwVertexProcessingCaps;
        lpOut->dwReserved1 = lpExt->dwReserved1;
        lpOut->dwReserved2 = lpExt->dwReserved2;
        lpOut->dwReserved3 = lpExt->dwReserved3;
        lpOut->dwReserved4 = lpExt->dwReserved4;
    }
}

//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::CheckSurfaces"

HRESULT DIRECT3DDEVICEI::CheckSurfaces()
{
    if(this->lpDirect3DI->lpTextureManager->CheckIfLost())
    {
        D3D_ERR("Managed Textures lost");
        return DDERR_SURFACELOST;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->lpGbl->dwUsageCount ||
         (this->lpDDSZBuffer && ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->lpGbl->dwUsageCount) )
    {
        D3D_ERR("Render target or Z buffer locked");
        return DDERR_SURFACEBUSY;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->dwFlags & DDRAWISURF_INVALID )\
        {
            D3D_ERR("Render target buffer lost");
            return DDERR_SURFACELOST;
        }
    if ( this->lpDDSZBuffer && ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->dwFlags & DDRAWISURF_INVALID ) )
    {
        D3D_ERR("Z buffer lost");
        return DDERR_SURFACELOST;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetDirect3D"

HRESULT D3DAPI DIRECT3DDEVICEI::GetDirect3D(LPDIRECT3D7 *lplpD3D)
{

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(lplpD3D))
    {
        D3D_ERR( "Invalid Direct3D pointer pointer" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpD3D = (LPDIRECT3D7) this->lpDirect3DI;
    (*lplpD3D)->AddRef();

    return (D3D_OK);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::HookTexture"

LPD3DI_TEXTUREBLOCK DIRECT3DDEVICEI::HookTexture(LPDIRECT3DTEXTUREI lpD3DText)
{
    LPD3DI_TEXTUREBLOCK nBlock;

    if (D3DMalloc((void**)&nBlock, sizeof(D3DI_TEXTUREBLOCK)) != D3D_OK)
    {
        D3D_ERR("failed to allocate space for texture block");
        return NULL;
    }
    nBlock->lpDevI = this;
    nBlock->lpD3DTextureI = lpD3DText;
    nBlock->hTex = 0;              // initialized to be zero

    LIST_INSERT_ROOT(&lpD3DText->blocks, nBlock, list);
    LIST_INSERT_ROOT(&texBlocks, nBlock, devList);

    return nBlock;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::D3DI_FindTextureBlock"

LPD3DI_TEXTUREBLOCK DIRECT3DDEVICEI::D3DI_FindTextureBlock(LPDIRECT3DTEXTUREI lpTex)
{
    LPD3DI_TEXTUREBLOCK tBlock;

    tBlock = LIST_FIRST(&lpTex->blocks);
    while (tBlock) {
        //  return match for Texture(2) only (not Texture3)
        if (tBlock->lpDevI == this) {
            return tBlock;
        }
        tBlock = LIST_NEXT(tBlock,list);
    }
    return NULL;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetTextureDDIHandle"

HRESULT DIRECT3DDEVICEI::GetTextureDDIHandle(LPDIRECT3DTEXTUREI lpTexI,
                                             LPD3DI_TEXTUREBLOCK* lplpBlock)
{
    HRESULT ret;
    LPD3DI_TEXTUREBLOCK lpBlock=*lplpBlock; //in case has the pointer

    DDASSERT(lpTexI);
    /*
     * Find out if we've used this device before.
     */
    if (!lpBlock)
    {
        lpBlock = D3DI_FindTextureBlock(lpTexI);
        if (!lpBlock)
        {
            /*
             * Put this device in the list of those owned by the
             * Direct3DDevice object
             */
            lpBlock=HookTexture(lpTexI);
            if (!lpBlock)
            {
                D3D_ERR("failed to associate texture with device");
                return DDERR_OUTOFMEMORY;
            }
        }
        *lplpBlock = lpBlock;
    }
    if (!lpBlock->hTex)
    {
        if (lpTexI->D3DManaged())
        {
            if(!lpTexI->InVidmem()) // This check covers the case when hTex is zero,
                                    // but there ALREADY IS a vidmem copy don't
                                    // create another one. This case arises when
                                    // InvalidateHandles() is called by SetRenderTarget.
            {
                ret = lpDirect3DI->lpTextureManager->allocNode(lpTexI, this);
                if (D3D_OK != ret)
                {
                    D3D_ERR("Failed to create video memory surface");
                    return ret;
                }
            }
            lpDirect3DI->lpTextureManager->TimeStamp(lpTexI);
        }
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));
        if (D3D_OK != (ret=D3DHAL_TextureCreate(this, &lpBlock->hTex, (LPDIRECTDRAWSURFACE)&(lpTexI->DDS1Tex))))
            return ret;
    }
    else
    {
        if(lpTexI->D3DManaged())
            lpDirect3DI->lpTextureManager->TimeStamp(lpTexI);
    }

    DDASSERT(lpBlock->hTex);
    return D3D_OK;
}

#if COLLECTSTATS
#undef DPF_MODNAME
#define DPF_MODNAME "BytesDownloaded"

DWORD BytesDownloaded(LPDDRAWI_DDRAWSURFACE_LCL lpLcl, LPRECT lpRect)
{
    DWORD bytes;
    if( (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
        (lpLcl->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC) )
    {
        switch (lpLcl->lpGbl->ddpfSurface.dwFourCC)
        {
        case FOURCC_DXT1:
        case FOURCC_DXT2:
        case FOURCC_DXT3:
        case FOURCC_DXT4:
        case FOURCC_DXT5:
            if(lpRect == NULL)
            {
                bytes = lpLcl->lpGbl->dwLinearSize;
            }
            else
            {
                bytes = (DWORD)(lpLcl->lpGbl->dwLinearSize * (double((lpRect->right - lpRect->left) * (lpRect->bottom - lpRect->top)) /
                                                              double(lpLcl->lpGbl->wWidth * lpLcl->lpGbl->wHeight)));
            }
            return lpLcl->lpSurfMore->dwMipMapCount == 0 ? bytes : (DWORD)(bytes * ((1. - pow(.25, lpLcl->lpSurfMore->dwMipMapCount)) / .75));
        }
    }
    if(lpRect == NULL)
    {
        bytes = lpLcl->lpGbl->lPitch * lpLcl->lpGbl->wHeight;
    }
    else
    {
        bytes = (DWORD)(lpLcl->lpGbl->lPitch * lpLcl->lpGbl->wHeight *
                            (double((lpRect->right - lpRect->left) * (lpRect->bottom - lpRect->top)) /
                             double(lpLcl->lpGbl->wWidth * lpLcl->lpGbl->wHeight)));
    }
    return lpLcl->lpSurfMore->dwMipMapCount == 0 ? bytes : (DWORD)(bytes * ((1. - pow(.25, lpLcl->lpSurfMore->dwMipMapCount)) / .75));
}
#endif

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::PreLoad"

HRESULT D3DAPI DIRECT3DDEVICEI::PreLoad(LPDIRECTDRAWSURFACE7 lpSrc)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    if(!(this->dwFEFlags & D3DFE_REALHAL))
    {
        D3D_WARN(2, "PreLoad called on a software device");
        return D3D_OK;
    }

    return PreLoadFast(lpSrc);
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::PreLoadFast"

HRESULT D3DAPI DIRECT3DDEVICEI::PreLoadFast(LPDIRECTDRAWSURFACE7 lpSrc)
{
#if DBG
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid DIRECT3DDEVICE7 pointer" );
        return DDERR_INVALIDOBJECT;
    }

    if (!VALID_DDSURF_PTR(lpSrc))
    {
        D3D_ERR( "Invalid DIRECTDRAWSURFACE7 source pointer" );
        return DDERR_INVALIDOBJECT;
    }

    if(!IsToplevel(((LPDDRAWI_DDRAWSURFACE_INT)lpSrc)->lpLcl))
    {
        D3D_ERR( "Cannot PreLoad a mipmap sublevel or a cubemap subface" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    LPDIRECT3DTEXTUREI this_src = reinterpret_cast<LPDIRECT3DTEXTUREI>(((LPDDRAWI_DDRAWSURFACE_INT)lpSrc)->lpLcl->lpSurfMore->lpTex);
#if DBG
    if (this_src == NULL)
    {
        D3D_ERR( "Not a texture" );
        return DDERR_INVALIDPARAMS;
    }
#endif
#if COLLECTSTATS
    this->IncNumPreLoads();
#endif
    try
    {
        HRESULT ddrval = D3D_OK;
        if (!this_src->D3DManaged())
        {
#if DBG
            // Make sure that texture is driver managed
            if(!(DDSCAPS2_TEXTUREMANAGE & ((LPDDRAWI_DDRAWSURFACE_INT)(this_src->lpDDS))->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2))
            {
                D3D_ERR( "Cannot PreLoad unmanaged textures" );
                return DDERR_INVALIDPARAMS;
            }
#endif
            if(this->lpDirect3DI->numDevs > 1)
            {
                D3D_WARN(2, "Multiple devices used. Calling Flush");
                ddrval = this->lpDirect3DI->FlushDevicesExcept(this); // to avoid sync problems
                if(ddrval != D3D_OK)
                {
                    D3D_ERR("Error flushing devices");
                    return ddrval;
                }
            }
            POINT p = {0, 0};
            RECTL r = {0, 0, 0, 0};
            DDASSERT(IS_DX7HAL_DEVICE(this));
            ddrval = static_cast<CDirect3DDevice7*>(this)->TexBltI(NULL, ((LPDDRAWI_DDRAWSURFACE_INT)(this_src->lpDDS))->lpLcl, &p, &r, 0);
            if(ddrval != D3D_OK)
            {
                DPF_ERR("Error inserting TexBlt instruction in batch");
                return ddrval;
            }
            if(this->lpDirect3DI->numDevs > 1)
            {
                ddrval = FlushStates(); // to avoid sync problems
                if(ddrval != D3D_OK)
                {
                    D3D_ERR("Error flushing device");
                    return ddrval;
                }
            }
            else
            {
                BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)(this_src->lpDDS))->lpLcl);
            }
        }
        else if (this_src->InVidmem())
        {
            if (this_src->bDirty)
            {
                // 0xFFFFFFFF is equivalent to ALL_FACES, but in addition indicates to CopySurface
                // that this is a sysmem -> vidmem transfer.
                ddrval = CopySurface(this_src->lpDDS,NULL,this_src->lpDDSSys,NULL,0xFFFFFFFF);
                if (DD_OK == ddrval)
                {
                    this_src->bDirty=FALSE;
                    D3D_INFO(4,"Load: Dirty texture updated");
                }
            }
#if COLLECTSTATS
            this->lpDirect3DI->lpTextureManager->IncNumTexturesSet();
            this->lpDirect3DI->lpTextureManager->IncNumSetTexInVid();
#endif
        }
        else
        {
            if(IS_DX7HAL_DEVICE(this))
            {
                D3DTEXTUREHANDLE hTex;
                ddrval = static_cast<CDirect3DDevice7*>(this)->GetTextureDDIHandle(this_src, &hTex);
            }
            else
            {
                LPD3DI_TEXTUREBLOCK lpBlock = NULL;
                ddrval = GetTextureDDIHandle(this_src, &lpBlock);
            }
#if COLLECTSTATS
            this->lpDirect3DI->lpTextureManager->IncNumTexturesSet();
#endif
        }
        return ddrval;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::Load"

HRESULT D3DAPI DIRECT3DDEVICEI::Load(LPDIRECTDRAWSURFACE7 lpDest, LPPOINT lpDestPoint,
                                     LPDIRECTDRAWSURFACE7 lpSrc, LPRECT lpSrcRect, DWORD dwFlags)
{
    LPDIRECT3DTEXTUREI  this_src, this_dst;
    HRESULT     ddrval = D3D_OK;
    LPDIRECTDRAWSURFACE7 lpDDSSrc, lpDDSDst;

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock (can't take MT since code accesses DDraw surf global)
                                                        // Release in the destructor
#if DBG
        // validate args
        if(lpDestPoint != NULL && lpSrcRect == NULL)
        {
            D3D_ERR( "Cannot have NULL src rect and non-NULL dest" );
            return DDERR_INVALIDPARAMS;
        }
        if(lpDestPoint != NULL)
        {
            if(!VALID_GDIPOINT_PTR(lpDestPoint))
            {
                D3D_ERR( "Invalid POINT pointer" );
                return DDERR_INVALIDOBJECT;
            }
        }
        if(lpSrcRect != NULL)
        {
            if(!VALID_GDIRECT_PTR(lpSrcRect))
            {
                D3D_ERR( "Invalid RECT pointer" );
                return DDERR_INVALIDOBJECT;
            }
        }
        if(dwFlags & (~DDSCAPS2_CUBEMAP_ALLFACES))
        {
            D3D_ERR( "Invalid flags" );
            return DDERR_INVALIDPARAMS;
        }

        if (!VALID_DIRECT3DDEVICE_PTR(this))
        {
            D3D_ERR( "Invalid DIRECT3DDEVICE7 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DDSURF_PTR(lpDest))
        {
            D3D_ERR( "Invalid DIRECTDRAWSURFACE7 dest pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if(!IsToplevel(((LPDDRAWI_DDRAWSURFACE_INT)lpDest)->lpLcl))
        {
            D3D_ERR( "Cannot Load to a mipmap sublevel or a cubemap subface" );
            return DDERR_INVALIDPARAMS;
        }
#endif
        this_dst = reinterpret_cast<LPDIRECT3DTEXTUREI>(((LPDDRAWI_DDRAWSURFACE_INT)lpDest)->lpLcl->lpSurfMore->lpTex);
#if DBG
        if(this_dst == NULL)
        {
            D3D_ERR( "Destination surface not a texture" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_DDSURF_PTR(lpSrc))
        {
            D3D_ERR( "Invalid DIRECTDRAWSURFACE7 source pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if(!IsToplevel(((LPDDRAWI_DDRAWSURFACE_INT)lpSrc)->lpLcl))
        {
            D3D_ERR( "Cannot Load from a mipmap sublevel or a cubemap subface" );
            return DDERR_INVALIDPARAMS;
        }
#endif
        this_src = reinterpret_cast<LPDIRECT3DTEXTUREI>(((LPDDRAWI_DDRAWSURFACE_INT)lpSrc)->lpLcl->lpSurfMore->lpTex);
#if DBG
        if(this_src == NULL)
        {
            D3D_ERR( "Source surface not a texture" );
            return DDERR_INVALIDPARAMS;
        }
#endif
#if COLLECTSTATS
        this->IncNumLoads();
#endif

        if(this_src->D3DManaged())
            lpDDSSrc = this_src->lpDDSSys;
        else
            lpDDSSrc = this_src->lpDDS;

        RECT destRect, *lpDestRect;
        if(lpDestPoint)
        {
            if(IsRectEmpty(lpSrcRect))
            {
                D3D_ERR( "Source rectangle is empty" );
                return DDERR_INVALIDPARAMS;
            }
            WORD &width  = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpLcl->lpGbl->wWidth;
            WORD &height = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpLcl->lpGbl->wHeight;
            if(lpSrcRect->left < 0 ||
                lpSrcRect->left >= width ||
                lpSrcRect->top < 0 ||
                lpSrcRect->top >= height ||
                lpSrcRect->right <= 0 ||
                lpSrcRect->right > width ||
                lpSrcRect->bottom <= 0 ||
                lpSrcRect->bottom > height)
            {
                D3D_ERR( "Rectangle outside source texture" );
                return DDERR_INVALIDPARAMS;
            }
            destRect.left   = lpDestPoint->x;
            destRect.top    = lpDestPoint->y;
            destRect.right  = lpDestPoint->x + (lpSrcRect->right - lpSrcRect->left);
            destRect.bottom = lpDestPoint->y + (lpSrcRect->bottom - lpSrcRect->top);
            lpDestRect = &destRect;
            if(lpDestRect->left < 0 ||
                lpDestRect->left >= width ||
                lpDestRect->top < 0 ||
                lpDestRect->top >= height ||
                lpDestRect->right <= 0 ||
                lpDestRect->right > width ||
                lpDestRect->bottom <= 0 ||
                lpDestRect->bottom > height)
            {
                D3D_ERR( "Rectangle outside destination texture" );
                return DDERR_INVALIDPARAMS;
            }
        }
        else
        {
            if(lpSrcRect)
            {
                if(IsRectEmpty(lpSrcRect))
                {
                    D3D_ERR( "Source rectangle is empty" );
                    return DDERR_INVALIDPARAMS;
                }
                WORD &width  = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpLcl->lpGbl->wWidth;
                WORD &height = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpLcl->lpGbl->wHeight;
                if(lpSrcRect->left < 0 ||
                    lpSrcRect->left >= width ||
                    lpSrcRect->top < 0 ||
                    lpSrcRect->top >= height ||
                    lpSrcRect->right <= 0 ||
                    lpSrcRect->right > width ||
                    lpSrcRect->bottom <= 0 ||
                    lpSrcRect->bottom > height)
                {
                    D3D_ERR( "Source rectangle outside texture" );
                    return DDERR_INVALIDPARAMS;
                }
                destRect = *lpSrcRect;
                lpDestRect = &destRect;
            }
            else
            {
                lpDestRect = NULL;
            }
        }
        if(this_dst->D3DManaged())
            lpDDSDst = this_dst->lpDDSSys;
        else
            lpDDSDst = this_dst->lpDDS;
        ddrval = CopySurface(lpDDSDst, lpDestRect, lpDDSSrc, lpSrcRect, dwFlags);
        return ddrval;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::CanDoTexBlt"

bool DIRECT3DDEVICEI::CanDoTexBlt(LPDDRAWI_DDRAWSURFACE_LCL lpDDSSrcSubFace_lcl,
                                  LPDDRAWI_DDRAWSURFACE_LCL lpDDSDstSubFace_lcl)
{
    return false;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::CopySurface"

HRESULT DIRECT3DDEVICEI::CopySurface(LPDIRECTDRAWSURFACE7 lpDDSDst,
                                     LPRECT lpDestRect,
                                     LPDIRECTDRAWSURFACE7 lpDDSSrc,
                                     LPRECT lpSrcRect,
                                     DWORD dwFlags)
{

    DDRAWI_DDRAWSURFACE_INT DDSSrcSubFace, DDSDstSubFace;
    DDSSrcSubFace.lpVtbl = DDSDstSubFace.lpVtbl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpVtbl;
    DDSDstSubFace.lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSDst)->lpLcl;
    DDSSrcSubFace.lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpLcl;
    LPDIRECTDRAWSURFACE7 lpDDSSrcSubFace = reinterpret_cast<LPDIRECTDRAWSURFACE7>(&DDSSrcSubFace);
    LPDIRECTDRAWSURFACE7 lpDDSDstSubFace = reinterpret_cast<LPDIRECTDRAWSURFACE7>(&DDSDstSubFace);
    CCubemapIter cmsrc(DDSSrcSubFace.lpLcl), cmdst(DDSDstSubFace.lpLcl);
    while(true)
    {
        DDSSrcSubFace.lpLcl = cmsrc();
        DDSDstSubFace.lpLcl = cmdst();
        DWORD face = DDSSrcSubFace.lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES;
        if(face != (DDSDstSubFace.lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES))
        {
            D3D_ERR("Destination texture has different cubemap faces than source");
            return DDERR_INVALIDPARAMS;
        }
        if(face == 0 || (DDSSrcSubFace.lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & dwFlags))
        {
            HRESULT ddrval = D3D_OK;
            DWORD psize = 0;
            if (DDSDstSubFace.lpLcl->lpDDPalette)
            {
                if(DDSSrcSubFace.lpLcl->lpDDPalette)
                {
                    const DWORD paltype = DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED1;
                    if((PixelFormat(DDSDstSubFace.lpLcl).dwFlags & paltype) != (PixelFormat(DDSSrcSubFace.lpLcl).dwFlags & paltype))
                    {
                        D3D_ERR("Src texture is has a different type of palette than dest");
                        return DDERR_INVALIDPARAMS;
                    }
                    switch(PixelFormat(DDSDstSubFace.lpLcl).dwFlags & paltype)
                    {
                    case DDPF_PALETTEINDEXED1:
                        psize = 2;
                        break;
                    case DDPF_PALETTEINDEXED2:
                        psize = 4;
                        break;
                    case DDPF_PALETTEINDEXED4:
                        psize = 16;
                        break;
                    case DDPF_PALETTEINDEXED8:
                        psize = 256;
                        break;
                    default:
                        D3D_ERR("Paletted texture format not supported");
                        return E_NOTIMPL;
                    }
                    ddrval = (reinterpret_cast<LPDIRECTDRAWPALETTE>(DDSDstSubFace.lpLcl->lpDDPalette))->SetEntries(0, 0, psize, DDSSrcSubFace.lpLcl->lpDDPalette->lpLcl->lpGbl->lpColorTable);
                    if (ddrval != DD_OK)
                    {
                        D3D_ERR("Failed to set palette entries in dest texture");
                        return ddrval;
                    }
                }
                else
                {
                    D3D_WARN(2, "Destination texture has palette, but source has none");
                }
            }

            /* Copy color keys */
            if(DDSSrcSubFace.lpLcl->dwFlags & DDRAWISURF_HASCKEYDESTBLT)
                lpDDSDstSubFace->SetColorKey(DDCKEY_DESTBLT, &DDSSrcSubFace.lpLcl->ddckCKDestBlt);
            else if(DDSDstSubFace.lpLcl->dwFlags & DDRAWISURF_HASCKEYDESTBLT)
                lpDDSDstSubFace->SetColorKey(DDCKEY_DESTBLT, NULL);
            if(DDSSrcSubFace.lpLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT)
                lpDDSDstSubFace->SetColorKey(DDCKEY_SRCBLT, &DDSSrcSubFace.lpLcl->ddckCKSrcBlt);
            else if(DDSDstSubFace.lpLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT)
                lpDDSDstSubFace->SetColorKey(DDCKEY_SRCBLT, NULL);

            DDRAWI_DDRAWSURFACE_INT DDSSrcSubMip, DDSDstSubMip;
            DDSSrcSubMip.lpVtbl = DDSDstSubMip.lpVtbl = DDSSrcSubFace.lpVtbl;
            DDSDstSubMip.lpLcl = DDSDstSubFace.lpLcl;
            DDSSrcSubMip.lpLcl = DDSSrcSubFace.lpLcl;
            LPDIRECTDRAWSURFACE7 lpDDSSrcSubMip = reinterpret_cast<LPDIRECTDRAWSURFACE7>(&DDSSrcSubMip);
            LPDIRECTDRAWSURFACE7 lpDDSDstSubMip = reinterpret_cast<LPDIRECTDRAWSURFACE7>(&DDSDstSubMip);
            RECT SrcRct, DstRct, *lpSrcRct, *lpDstRct;
            if(lpSrcRect)
            {
                SrcRct = *lpSrcRect;
                lpSrcRct = &SrcRct;
            }
            else
                lpSrcRct = NULL;
            if(lpDestRect)
            {
                DstRct = *lpDestRect;
                lpDstRct = &DstRct;
            }
            else
                lpDstRct = NULL;
            CMipmapIter mmsrc(DDSSrcSubMip.lpLcl), mmdst(DDSDstSubMip.lpLcl);
            unsigned srcmipoff = 0;
            while(mmsrc()->lpGbl->wHeight != mmdst()->lpGbl->wHeight || mmsrc()->lpGbl->wWidth != mmdst()->lpGbl->wWidth)
            {

//
//  _COMPUTE_NEXT_LOD_RECT - Computes rectangle (in place) for next smaller LOD in mip
//  chain.  Top & left are divided by two, which effectively rounds down (via truncation).
//  Bottom & right are incremented prior to truncated-division, which will round up.
//  Result is guaranteed to be at least 1x1 in size.
//
#define _COMPUTE_NEXT_LOD_RECT( m_pRct )                                                \
{                                                                                       \
    (m_pRct)->left >>= 1;                                                               \
    (m_pRct)->top  >>= 1;                                                               \
    DWORD right  = ((m_pRct)->right +1) >> 1;                                           \
    DWORD bottom = ((m_pRct)->bottom+1) >> 1;                                           \
    (m_pRct)->right  = ((right  - (m_pRct)->left) < 1) ? ((m_pRct)->left+1) : (right);  \
    (m_pRct)->bottom = ((bottom - (m_pRct)->top ) < 1) ? ((m_pRct)->top +1) : (bottom); \
}

                if(lpSrcRct)
                {
                    _COMPUTE_NEXT_LOD_RECT(lpSrcRct)
                }
                if(lpDstRct)
                {
                    _COMPUTE_NEXT_LOD_RECT(lpDstRct)
                }
                ++srcmipoff;
                ++mmsrc;
                if(mmsrc == 0)
                {
                    D3D_ERR("Size mismatch between source and destination textures");
                    return DDERR_INVALIDPARAMS;
                }
            }
            DWORD dstmipcnt = DDSDstSubMip.lpLcl->lpSurfMore->dwMipMapCount == 0 ? 1 : DDSDstSubMip.lpLcl->lpSurfMore->dwMipMapCount;
            DWORD srcmipcnt = DDSSrcSubMip.lpLcl->lpSurfMore->dwMipMapCount == 0 ? 1 : DDSSrcSubMip.lpLcl->lpSurfMore->dwMipMapCount;
            if(dstmipcnt != (srcmipcnt - srcmipoff))
            {
                if(dstmipcnt > (srcmipcnt - srcmipoff))
                {
                    D3D_ERR("Destination texture has more mipmap levels than source");
                    return DDERR_INVALIDPARAMS;
                }
                else
                    D3D_INFO(3, "Destination texture has fewer mipmap levels than source");
            }

#if COLLECTSTATS
            if(dwFlags == 0xFFFFFFFF) // texman CopySurface
                this->lpDirect3DI->lpTextureManager->IncBytesDownloaded(DDSDstSubMip.lpLcl, lpDstRct);
            else
                this->IncBytesDownloaded(DDSDstSubMip.lpLcl, lpDstRct);
#endif

            if(this->lpDirect3DI->numDevs == 1 && CanDoTexBlt(DDSSrcSubFace.lpLcl, DDSDstSubFace.lpLcl))
            {
                bool doblt = true;
                LPREGIONLIST lpRegionList = DDSSrcSubFace.lpLcl->lpSurfMore->lpRegionList;
                if(dwFlags == 0xFFFFFFFF) // 0xFFFFFFFF indicates that we
                                          // are loading from sysmem to vidmem
                                          // and the regionlist should be used
                {
                    if(lpRegionList->rdh.nCount == 0)
                    {
                        doblt = false;
                    }
                    else
                    {
                        if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                        {
                            if(DDSSrcSubFace.lpLcl->lpGbl->dwUsageCount > 0
                                || DDSDstSubFace.lpLcl->lpGbl->dwUsageCount > 0)
                            {
                                D3D_ERR("Surfaces locked");
                                return DDERR_SURFACEBUSY;
                            }
                            for(unsigned i = 0; i < lpRegionList->rdh.nCount; ++i)
                            {
                                POINT p;
                                p.x = lpRegionList->rect[i].left;
                                p.y = lpRegionList->rect[i].top;
                                ddrval = static_cast<CDirect3DDevice7*>(this)->TexBltI(DDSDstSubFace.lpLcl,
                                                                                       DDSSrcSubFace.lpLcl,
                                                                                       &p, &lpRegionList->rect[i], 0);
                                if(ddrval != D3D_OK)
                                {
                                    DPF_ERR("Error inserting TexBlt instruction in batch");
                                    return ddrval;
                                }
                            }
                            BatchTexture(DDSDstSubFace.lpLcl);
                            BatchTexture(DDSSrcSubFace.lpLcl);
                            doblt = false;
                        }
                        lpRegionList->rdh.nCount = 0;
                        lpRegionList->rdh.nRgnSize = 0;
                        lpRegionList->rdh.rcBound.left = LONG_MAX;
                        lpRegionList->rdh.rcBound.right = 0;
                        lpRegionList->rdh.rcBound.top = LONG_MAX;
                        lpRegionList->rdh.rcBound.bottom = 0;
                    }
                }
                if(doblt)
                {
                    if(DDSSrcSubFace.lpLcl->lpGbl->dwUsageCount > 0
                        || DDSDstSubFace.lpLcl->lpGbl->dwUsageCount > 0)
                    {
                        D3D_ERR("Surfaces locked");
                        return DDERR_SURFACEBUSY;
                    }
                    POINT p;
                    if(lpDstRct)
                    {
                        p.x = lpDstRct->left;
                        p.y = lpDstRct->top;
                    }
                    else
                    {
                        p.x = 0;
                        p.y = 0;
                    }
                    RECTL r;
                    if(lpSrcRct)
                    {
                        r = *((LPRECTL)lpSrcRct);
                    }
                    else
                    {
                        r.bottom = DDSSrcSubFace.lpLcl->lpGbl->wHeight;
                        r.left = 0;
                        r.right = DDSSrcSubFace.lpLcl->lpGbl->wWidth;
                        r.top = 0;
                    }
                    ddrval = static_cast<CDirect3DDevice7*>(this)->TexBltI(DDSDstSubFace.lpLcl,
                                                                           DDSSrcSubFace.lpLcl,
                                                                           &p, &r, 0);
                    if(ddrval != D3D_OK)
                    {
                        DPF_ERR("Error inserting TexBlt instruction in batch");
                        return ddrval;
                    }
                    BatchTexture(DDSDstSubFace.lpLcl);
                    BatchTexture(DDSSrcSubFace.lpLcl);
                    if(IsD3DManaged(DDSDstSubFace.lpLcl))
                    {
                        MarkDirty(DDSDstSubFace.lpLcl);
                        LPREGIONLIST lpRegionList = DDSDstSubFace.lpLcl->lpSurfMore->lpRegionList;
                        if(lpDstRct)
                        {
                            if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                            {
                                lpRegionList->rect[(lpRegionList->rdh.nCount)++] = *((LPRECTL)lpDstRct);
                                lpRegionList->rdh.nRgnSize += sizeof(RECT);
                                if(lpDstRct->left < lpRegionList->rdh.rcBound.left)
                                    lpRegionList->rdh.rcBound.left = lpDstRct->left;
                                if(lpDstRct->right > lpRegionList->rdh.rcBound.right)
                                    lpRegionList->rdh.rcBound.right = lpDstRct->right;
                                if(lpDstRct->top < lpRegionList->rdh.rcBound.top)
                                    lpRegionList->rdh.rcBound.top = lpDstRct->top;
                                if(lpDstRct->bottom > lpRegionList->rdh.rcBound.bottom)
                                    lpRegionList->rdh.rcBound.bottom = lpDstRct->bottom;
                            }
                        }
                        else
                        {
                            /* Mark everything dirty */
                            lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
                        }
                    }
                }
            }
            else
            {
                do
                {
                    DDSSrcSubMip.lpLcl = mmsrc();
                    DDSDstSubMip.lpLcl = mmdst();
                    bool doblt = true;
                    LPREGIONLIST lpRegionList = DDSSrcSubMip.lpLcl->lpSurfMore->lpRegionList;
                    if(dwFlags == 0xFFFFFFFF) // 0xFFFFFFFF indicates that we
                                              // are loading from sysmem to vidmem
                                              // and the regionlist should be used.
                    {
                        if(lpRegionList->rdh.nCount == 0)
                        {
                            doblt = false;
                        }
                        else if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                        {
                            if(lpClipper->SetClipList((LPRGNDATA)lpRegionList, 0) != DD_OK)
                            {
                                D3D_ERR("Failed to set clip list");
                            }
                            if(lpDDSDstSubMip->SetClipper(lpClipper) != DD_OK)
                            {
                                D3D_ERR("Failed to detach the clipper");
                            }
                        }
                    }
                    if(doblt)
                    {
                        ddrval = lpDDSDstSubMip->Blt(lpDstRct, lpDDSSrcSubMip, lpSrcRct, DDBLT_WAIT, NULL);
                    }
                    if(dwFlags == 0xFFFFFFFF)
                    {
                        if(lpRegionList->rdh.nCount)
                        {
                            if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                            {
                                if(lpDDSDstSubMip->SetClipper(NULL) != DD_OK)
                                {
                                    D3D_ERR("Failed to detach the clipper");
                                }
                            }
                            lpRegionList->rdh.nCount = 0;
                            lpRegionList->rdh.nRgnSize = 0;
                            lpRegionList->rdh.rcBound.left = LONG_MAX;
                            lpRegionList->rdh.rcBound.right = 0;
                            lpRegionList->rdh.rcBound.top = LONG_MAX;
                            lpRegionList->rdh.rcBound.bottom = 0;
                        }
                    }

                    if (ddrval == E_NOTIMPL && (psize == 16 || psize == 4 || psize == 2))
                    {
                        DDSURFACEDESC2 ddsd_s, ddsd_d;
                        LPBYTE psrc, pdst;
                        DWORD i;
                        DWORD dwBytesPerLine;

                        memset(&ddsd_s, 0, sizeof ddsd_s);
                        memset(&ddsd_d, 0, sizeof ddsd_d);
                        ddsd_s.dwSize = ddsd_d.dwSize = sizeof(ddsd_s);

                        // ATTENTION: implement subrect locks and copy correctly.

                        if ((ddrval = lpDDSSrcSubMip->Lock(NULL, &ddsd_s, DDLOCK_WAIT, NULL)) != DD_OK)
                        {
                            if((ddrval == DDERR_SURFACELOST) && (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE))
                            {
                                this->dwFEFlags |= D3DFE_LOSTSURFACES;
                                ddrval = DD_OK;
                            }
                            else
                            {
                                D3D_ERR("Failed to lock src texture");
                            }
                            return ddrval;
                        }
                        if ((ddrval = lpDDSDstSubMip->Lock(NULL, &ddsd_d, DDLOCK_WAIT, NULL)) != DD_OK)
                        {
                            lpDDSSrcSubMip->Unlock(NULL);
                            if((ddrval == DDERR_SURFACELOST) && (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE))
                            {
                                this->dwFEFlags |= D3DFE_LOSTSURFACES;
                                ddrval = DD_OK;
                            }
                            else
                            {
                                D3D_ERR("Failed to lock dst texture");
                            }
                            return ddrval;
                        }

                        switch (psize)
                        {
                        case 16: dwBytesPerLine = (ddsd_s.dwWidth + 1) / 2; break;
                        case 4: dwBytesPerLine = (ddsd_s.dwWidth + 3) / 4; break;
                        case 2: dwBytesPerLine = (ddsd_s.dwWidth + 7) / 8; break;
                        }

                        psrc = (LPBYTE)ddsd_s.lpSurface;
                        pdst = (LPBYTE)ddsd_d.lpSurface;
                        for (i = 0; i < ddsd_s.dwHeight; i++) {
                            memcpy( pdst, psrc, dwBytesPerLine );
                            psrc += ddsd_s.lPitch;
                            pdst += ddsd_d.lPitch;
                        }

                        lpDDSSrcSubMip->Unlock(NULL);
                        lpDDSDstSubMip->Unlock(NULL);
                    }
                    else if (ddrval != DD_OK)
                    {
                        if((ddrval == DDERR_SURFACELOST) && (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE))
                        {
                            this->dwFEFlags |= D3DFE_LOSTSURFACES;
                            ddrval = DD_OK;
                        }
                        else
                        {
                            D3D_ERR("Blt failure");
                        }
                        return ddrval;
                    }

                    if(lpSrcRct)
                    {
                        _COMPUTE_NEXT_LOD_RECT(lpSrcRct)
                    }
                    if(lpDstRct)
                    {
                        _COMPUTE_NEXT_LOD_RECT(lpDstRct)
                    }

                    ++mmsrc;
                    ++mmdst;
                }
                while(mmsrc != 0 && mmdst != 0);
            }
        }
        ++cmsrc;
        if(cmsrc == 0)
        {
            break; // out of outer loop
        }
        ++cmdst;
        if(cmdst == 0)
        {
            D3D_ERR("Destination texture has different cubemap faces than source");
            return DDERR_INVALIDPARAMS;
        }
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::VerifyTextureCaps"
HRESULT DIRECT3DDEVICEI::VerifyTextureCaps(LPDIRECT3DTEXTUREI lpTexI)
{
    DWORD texcap;
    WORD width, height;
    LPDDRAWI_DDRAWSURFACE_INT lpDDS;
    if(lpTexI->D3DManaged())
        lpDDS = (LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDSSys);
    else
        lpDDS = (LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS);
    /*
     * Are we palettized?
     */
    LPDDPIXELFORMAT pPF = &PixelFormat(lpDDS->lpLcl);
    if ( (pPF->dwFlags & DDPF_PALETTEINDEXED1) ||
         (pPF->dwFlags & DDPF_PALETTEINDEXED2) ||
         (pPF->dwFlags & DDPF_PALETTEINDEXED4) ||
         (pPF->dwFlags & DDPF_PALETTEINDEXED8) )
    {
        if(lpDDS->lpLcl->lpDDPalette == NULL)
        {
            D3D_ERR("No palette attached to a palettized texture");
            return DDERR_NOPALETTEATTACHED;
        }
    }
    /* first verify the dimensions */
    texcap = this->d3dDevDesc.dpcTriCaps.dwTextureCaps;
    width = lpDDS->lpLcl->lpGbl->wWidth;
    height = lpDDS->lpLcl->lpGbl->wHeight;
    if (texcap & D3DPTEXTURECAPS_POW2)
    {
        if (width & (width - 1)) // Clear the right most set bit
        {
            if (texcap & D3DPTEXTURECAPS_NONPOW2CONDITIONAL)
            {
                D3D_INFO( 3, "Texture width not a power of two");
                D3D_INFO( 3, "  with D3DPTEXTURECAPS_NONPOW2CONDITIONAL");
            }
            else
            {
                D3D_ERR("Texture width not a power of two");
                return D3DERR_TEXTURE_BADSIZE;
            }
        }
        if (height & (height - 1)) // Clear the right most set bit
        {
            if (texcap & D3DPTEXTURECAPS_NONPOW2CONDITIONAL)
            {
                D3D_INFO( 3, "Texture height not a power of two");
                D3D_INFO( 3, "  with D3DPTEXTURECAPS_NONPOW2CONDITIONAL");
            }
            else
            {
                D3D_ERR("Texture height not a power of two");
                return D3DERR_TEXTURE_BADSIZE;
            }
        }
    }
    if (texcap & D3DPTEXTURECAPS_SQUAREONLY)
    {
        if (width != height)
        {
            D3D_ERR("Texture not square");
            return D3DERR_TEXTURE_BADSIZE;
        }
    }
    return  D3D_OK;
}

#if COLLECTSTATS
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTexStats"
void DIRECT3DDEVICEI::GetTexStats(LPD3DDEVINFO_TEXTURING pStats)
{
    lpDirect3DI->GetTexStats(&m_texstats);
    *pStats = m_texstats;
}
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetInfoInternal"
BOOL DIRECT3DDEVICEI::GetInfoInternal(DWORD dwDevInfoID, LPVOID pDevInfoStruct, DWORD dwSize)
{
    switch(dwDevInfoID)
    {
#if COLLECTSTATS
    case D3DDEVINFOID_D3DTEXTUREMANAGER:
        if(dwSize < sizeof(D3DDEVINFO_TEXTUREMANAGER))
        {
            D3D_ERR( "Invalid size" );
            throw DDERR_INVALIDPARAMS;
        }
        lpDirect3DI->lpTextureManager->GetStats((LPD3DDEVINFO_TEXTUREMANAGER)pDevInfoStruct);
        break;
    case D3DDEVINFOID_TEXTURING:
        if(dwSize < sizeof(D3DDEVINFO_TEXTURING))
        {
            D3D_ERR( "Invalid size" );
            throw DDERR_INVALIDPARAMS;
        }
        this->GetTexStats((LPD3DDEVINFO_TEXTURING)pDevInfoStruct);
        break;
#else
    case D3DDEVINFOID_D3DTEXTUREMANAGER:
    case D3DDEVINFOID_TEXTURING:
        D3D_WARN( 0, "Stats not collected in this build" );
        memset(pDevInfoStruct, 0, dwSize);
        throw S_FALSE;
#endif
    default:
        return FALSE;
    }
    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetInfo"

HRESULT D3DAPI DIRECT3DDEVICEI::GetInfo(DWORD dwDevInfoID, LPVOID pDevInfoStruct, DWORD dwSize)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid DIRECT3DDEVICE7 pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (dwSize == 0 || !VALID_D3DDEVINFOSTRUCT_PTR(pDevInfoStruct, dwSize))
    {
        D3D_ERR( "Invalid structure pointer or size" );
        return DDERR_INVALIDOBJECT;
    }
    memset(pDevInfoStruct, 0, dwSize);
#if DBG
    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)
    {
        D3D_WARN( 2, "GetInfo called within a scene" );
    }
#endif
    try
    {
        switch(dwDevInfoID)
        {
#if COLLECTSTATS
        case D3DDEVINFOID_TEXTUREMANAGER:
            lpDirect3DI->lpTextureManager->GetStats((LPD3DDEVINFO_TEXTUREMANAGER)pDevInfoStruct);
            return D3D_OK;
#else
        case D3DDEVINFOID_TEXTUREMANAGER:
            D3D_WARN( 0, "Stats not collected in this build" );
            return S_FALSE;
#endif
        default:
            if(GetInfoInternal(dwDevInfoID, pDevInfoStruct, dwSize))
                return D3D_OK;
        }
        D3D_WARN( 1, "Device information query unsupported" );        
        return E_FAIL;
    }
    catch(HRESULT hr)
    {
        memset(pDevInfoStruct, 0, dwSize);
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\deviunk.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    deviunk.c
*  Content: Direct3DDevice IUnknown
*@@BEGIN_MSINTERNAL
* 
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95    stevela Merged Colin's changes.
*   10/12/95    stevela Removed AGGREGATE_D3D.
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * D3DDev_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::QueryInterface"
  
HRESULT D3DAPI DIRECT3DDEVICEI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
    
    if (!VALID_OUTPTR(ppvObj)) {
        D3D_ERR( "Invalid pointer to object pointer" );
        return DDERR_INVALIDPARAMS;
    }
    
    D3D_INFO(3, "Direct3DDevice IUnknown QueryInterface");
    
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDirect3DDevice7))
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(this);
    }
    else
    {
        D3D_ERR("unknown interface");
        return (E_NOINTERFACE);
    }
    
    return (D3D_OK);
    
} /* D3DDev_QueryInterface */

/*
 * D3DDev_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::AddRef"
  
ULONG D3DAPI DIRECT3DDEVICEI::AddRef()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    this->refCnt++;
    D3D_INFO(3, "Direct3DDevice IUnknown AddRef: Reference count = %d", this->refCnt);
    
    return (this->refCnt);
    
} /* D3DDev_AddRef */

/*
 * D3DDev_Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::Release"
  
ULONG D3DAPI DIRECT3DDEVICEI::Release()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    
    D3D_INFO(3, "Direct3DDevice IUnknown Release: Reference count = %d", this->refCnt);
    
    if( this->refCnt == 0 )
    {
        delete this; // suicide
        return 0;
    }
    return this->refCnt;
    
} /* D3DDev_Release */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\d3dmem.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dmem.c
 *  Content:    Direct3D mem allocation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

static D3DMALLOCFUNCTION malloc_function = (D3DMALLOCFUNCTION) MemAlloc;
static D3DREALLOCFUNCTION realloc_function = (D3DREALLOCFUNCTION) MemReAlloc;
static D3DFREEFUNCTION free_function = MemFree;

#undef DPF_MODNAME
#define DPF_MODNAME "D3DMalloc"

HRESULT D3DAPI D3DMalloc(LPVOID* p_return, size_t size)
{
    void* p;

    if (!VALID_OUTPTR(p_return)) {
        D3D_ERR("Bad pointer given");
        return DDERR_OUTOFMEMORY;
    }
    if (size > 0) {
        p = malloc_function(size);
        if (p == NULL)
            return (DDERR_OUTOFMEMORY);
    } else {
        p = NULL;
    }
    *p_return = p;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DRealloc"

HRESULT D3DAPI D3DRealloc(LPVOID* p_inout, size_t size)
{
    void* p = *p_inout;
    HRESULT err = D3D_OK;

    if (!VALID_OUTPTR(p_inout)) {
        D3D_ERR("Bad pointer given");
        return DDERR_OUTOFMEMORY;
    }
    if (size > 0) {
        if (p) {
            p = realloc_function(p, size);
            if (p == NULL)
                return (DDERR_OUTOFMEMORY);
        } else
            return D3DMalloc(p_inout, size);
    } else if (size == 0) {
        D3DFree(p);
        p = NULL;
    } else
        return (DDERR_INVALIDPARAMS);
    *p_inout = p;
    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DFree"

VOID D3DAPI D3DFree(LPVOID p)
{
    if (p == NULL) return;

    if (!VALID_DWORD_PTR(p)) {
        D3D_ERR("invalid pointer");
        return;
    }
    if (p) {
        free_function(p);
    }
}

#define CACHE_LINE 32
HRESULT MallocAligned(void** p_return, size_t size)
{
    char* p;
    size_t offset;
    HRESULT error;

    if (!p_return)
        return DDERR_INVALIDPARAMS;

    if (size > 0) {
        if ((error = D3DMalloc((void**) &p, size + CACHE_LINE)) != DD_OK)
        {
            *p_return = NULL;
            return error;
        }
        offset = (size_t)(CACHE_LINE - ((ULONG_PTR)p & (CACHE_LINE - 1)));
        p += offset;
        ((size_t*)p)[-1] = offset;
    } else
        p = NULL;
    *p_return = p;
    return DD_OK;
}

void FreeAligned(void* p)
{
    if (p) {
        size_t offset = ((size_t*)p)[-1];
        p = (void*) ((unsigned char*)p - offset);
        D3DFree(p);
    }
}

HRESULT ReallocAligned(void** p_inout, size_t size)
{
    char* p = (char*)*p_inout;
    HRESULT error;

    if (!p_inout)
        return DDERR_INVALIDPARAMS;

    if (size > 0) {
        if (p) {
            size_t old_offset = ((size_t*)p)[-1];
            size_t new_offset;

            p -= old_offset;
            if ((error = D3DRealloc((void**) &p, size + CACHE_LINE)) != DD_OK)
                return error;

            new_offset = (size_t)(CACHE_LINE - ((ULONG_PTR)p & (CACHE_LINE - 1)));
            if (old_offset != new_offset)
                memmove(p + new_offset, p + old_offset, size);
            p += new_offset;
            ((size_t*)p)[-1] = new_offset;
        } else
            return MallocAligned(p_inout, size);
    } else if (size == 0) {
        FreeAligned(p);
        p = NULL;
    } else
        return DDERR_INVALIDPARAMS;
    *p_inout = p;
    return DD_OK;
}

//----------------------------------------------------------------------------
// Growing aligned buffer implementation.
//
HRESULT CAlignedBuffer32::Grow(DWORD growSize)
{
    if (allocatedBuf)
        D3DFree(allocatedBuf);
    size = growSize;
    if (D3DMalloc(&allocatedBuf, size + 31) != DD_OK)
    {
        allocatedBuf = 0;
        alignedBuf = 0;
        size = 0;
        return DDERR_OUTOFMEMORY;
    }
    alignedBuf = (LPVOID)(((ULONG_PTR)allocatedBuf + 31 ) & ~31);
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CBufferDDS::Grow"
//----------------------------------------------------------------------
// Growing buffer using DDS implementation.
//
HRESULT CBufferDDS::Grow(LPDIRECT3DDEVICEI lpDevI, DWORD growSize)
{
    DWORD dwRefCnt = 1;
    if (growSize <= size)
        return D3D_OK;
    if (allocatedBuf)
    {
        // Save reference count before deleting
        dwRefCnt = allocatedBuf->AddRef() - 1;
        // Release till gone!
        while (allocatedBuf->Release());
        allocatedBuf = NULL;
    }
    size = growSize;
    DDSURFACEDESC2 ddsd;
    memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS;
    ddsd.dwWidth = size + 31;
    ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER | DDSCAPS_SYSTEMMEMORY;
    LPDIRECTDRAWSURFACE7 lpDDS7;
    HRESULT ret = lpDevI->lpDirect3DI->lpDD7->CreateSurface(&ddsd, &lpDDS7, NULL);
    if (ret != DD_OK)
    {
        D3D_ERR("Failed to allocate Vertex Buffer");
        size = 0;
        return ret;
    }
    ret = lpDDS7->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&allocatedBuf);
    if (ret != DD_OK)
    {
        D3D_ERR("failed to QI for DDS1");
        lpDDS7->Release();
        size = 0;
        return ret;
    }
    ret = lpDDS7->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
    if (ret != DD_OK)
    {
        D3D_ERR("Could not lock system memory Vertex Buffer.");
        lpDDS7->Release();
        allocatedBuf->Release();
        allocatedBuf = NULL;
        size = 0;
        return ret;
    }
    lpDDS7->Release();
    alignedBuf = ddsd.lpSurface;
    // Restore reference count
    while (--dwRefCnt)
        allocatedBuf->AddRef();
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\d3dtex.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    texture.c
*  Content: Direct3DTexture interface
*@@BEGIN_MSINTERNAL
*
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95   stevela  Merged Colin's changes.
*   10/12/95    stevela Removed AGGREGATE_D3D
*   17/04/96   colinmc Bug 12185: Debug output too aggresive
*   30/04/96   stevela Bug 18898: Wrong error returned on invalid GetHandle
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
* Create an api for the Direct3DTexture object
*/

#undef  DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture"

void D3DI_RemoveTextureHandle(LPD3DI_TEXTUREBLOCK lpBlock)
{
    /*  check if this block refers to a Texture/Texture2 - this
     *   needs to handle both texture types for device cleanup
     */
    if (lpBlock->hTex)
    {
        D3DHAL_TextureDestroy(lpBlock);
    }
}

DIRECT3DTEXTUREI::DIRECT3DTEXTUREI()
{
    m_dwHeapIndex = 0;
    m_bInUse = FALSE;
    m_dwPriority = 0;
    m_dwLOD = 0;
    bDirty = FALSE;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREI::Initialize"

HRESULT DIRECT3DTEXTUREI::Initialize(LPDIRECT3DI lpDirect3DI, LPDIRECTDRAWSURFACE7 pDDS)
{
    LIST_INITIALIZE(&blocks);
    this->DDS1Tex.lpVtbl = ((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->pddSurfaceCallbacks;
    this->DDS1Tex.lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;
    this->DDS1Tex.lpLink = NULL;
    this->DDS1Tex.dwIntRefCnt = 1;
    this->lpDDS        = pDDS;
    this->lpDDSSys     = NULL;
    this->m_hTex       = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl->lpSurfMore->dwSurfaceHandle;
    this->lpDirect3DI  = lpDirect3DI;
    this->lpDirect3DI->AddRef(); // Since we hold a pointer to D3DI
    // Hook texture into the list
    LIST_INSERT_ROOT(&this->lpDirect3DI->textures, this, m_List);
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREI::Destroy"

void DIRECT3DTEXTUREI::Destroy()
{
    // lpDDS or lpDDSSys need to remain alive during the while loop
    while (LIST_FIRST(&this->blocks)) 
    {
        LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&this->blocks);
        D3DI_RemoveTextureHandle(tBlock);
        // Remove from device
        LIST_DELETE(tBlock, devList);
        // Remove from texture
        LIST_DELETE(tBlock, list);
        D3DFree(tBlock);
    }
    LIST_DELETE(this, m_List); // Remove ourself from the texture chain
    lpDirect3DI->Release(); // Remove the Addref from Create
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTURED3DM::Initialize"

HRESULT DIRECT3DTEXTURED3DM::Initialize(LPDIRECT3DI lpDirect3DI, LPDIRECTDRAWSURFACE7 pDDS)
{
    HRESULT ddrval = DIRECT3DTEXTUREI::Initialize(lpDirect3DI, pDDS);
    if(ddrval != D3D_OK)
        return ddrval;
    memset(&this->ddsd, 0, sizeof(DDSURFACEDESC2));
    this->ddsd.dwSize = sizeof(DDSURFACEDESC2);
    ddrval = pDDS->GetSurfaceDesc(&this->ddsd);
    if(ddrval != DD_OK)
    {
        D3D_ERR("Failed to get surface descriptor for texture");
        return ddrval;
    }
    this->ddsd.dwFlags &= ~DDSD_PITCH;    // DDRAW always give that, but we don't want
    if(this->ddsd.ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        this->ddsd.ddsCaps.dwCaps &= ~DDSCAPS_NONLOCALVIDMEM;
        this->ddsd.ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
    }
    else
    {
        this->ddsd.ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
        this->ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
    }
    this->ddsd.ddsCaps.dwCaps2 &= ~(DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE);
    this->ddsd.ddsCaps.dwCaps2 |= DDSCAPS2_DONOTCREATED3DTEXOBJECT;
    
    if(((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->lpD3DGlobalDriverData)
    {
        if(!(((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_SEPARATETEXTUREMEMORIES) ||
            !(this->ddsd.dwFlags & DDSD_TEXTURESTAGE) ||
            (((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->lpD3DExtendedCaps->wMaxSimultaneousTextures < 2))
            this->ddsd.dwTextureStage = 0;
    }
    else
    {
        this->ddsd.dwTextureStage = 0;
    }
    this->lpDDSSys = pDDS;
    this->lpDDS = NULL;
    this->m_hTex = 0;
    this->m_dwBytes = 0;
    this->m_dwVidBytes = 0;
    // Next, we need to loop thru and set pointers to the dirty
    // bit in the DDraw surfaces
    for(CCubemapIter cmit(((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSSys)->lpLcl); cmit != 0; ++cmit)
    {
        // Set the faces bit so that when the cubemap is eventually created in vidmem, it will get all faces
        this->ddsd.ddsCaps.dwCaps2 |= (cmit()->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES);
        for(CMipmapIter mmit(cmit()); mmit != 0; ++mmit)
        {
            mmit()->lpSurfMore->lpbDirty = &(this->bDirty);
            if(this->ddsd.dwFlags & DDSD_LINEARSIZE)
                m_dwBytes += mmit()->lpGbl->dwLinearSize;
            else
                m_dwBytes += mmit()->lpGbl->lPitch * mmit()->lpGbl->wHeight;
        }
    }
#if COLLECTSTATS
    this->lpDirect3DI->lpTextureManager->IncTotSz(m_dwBytes);
#endif
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTURED3DM::Destroy"

void DIRECT3DTEXTURED3DM::Destroy()
{
    DIRECT3DTEXTUREI::Destroy();
    if(InVidmem())
    {
        this->lpDirect3DI->lpTextureManager->RemoveFromHeap(this);
        this->lpDirect3DI->lpTextureManager->remove(this);
    }
#if COLLECTSTATS
    this->lpDirect3DI->lpTextureManager->DecTotSz(m_dwBytes);
#endif
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREI::SetPriority"

HRESULT DIRECT3DTEXTUREI::SetPriority(DWORD dwPriority)
{
    D3D_ERR( "SetPriority called on unmanaged texture." );
    return DDERR_INVALIDPARAMS;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREI::GetPriority"

HRESULT DIRECT3DTEXTUREI::GetPriority(LPDWORD lpdwPriority)
{
    D3D_ERR( "GetPriority called on unmanaged texture." );
    return DDERR_INVALIDPARAMS;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREI::SetLOD"

HRESULT DIRECT3DTEXTUREI::SetLOD(DWORD dwLOD)
{
    D3D_ERR( "SetLOD called on unmanaged texture." );
    return DDERR_INVALIDPARAMS;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREI::GetLOD"

HRESULT DIRECT3DTEXTUREI::GetLOD(LPDWORD lpdwLOD)
{
    D3D_ERR( "GetLOD called on unmanaged texture." );
    return DDERR_INVALIDPARAMS;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREM::SetPriority"

HRESULT DIRECT3DTEXTUREM::SetPriority(DWORD dwPriority)
{
    try
    {
        m_dwPriority = dwPriority;
        // Look for a hardware device
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&this->lpDirect3DI->devices);
        if(lpDevI == NULL)
        {
            D3D_WARN(0, "SetPriority called before D3D device was created.");
        }
        while (lpDevI)
        {
            if (lpDevI->dwFEFlags & D3DFE_REALHAL)
            {
                if(this->lpDirect3DI->numDevs > 1)
                {
                    D3D_WARN(2, "Multiple devices used. Calling Flush");
                    HRESULT hr = this->lpDirect3DI->FlushDevicesExcept(lpDevI);  // to avoid sync problems
                    if(hr != D3D_OK)
                    {
                        DPF_ERR("Error flushing devices in SetPriority");
                        return hr;
                    }
                }
                DDASSERT(IS_DX7HAL_DEVICE(lpDevI));
                HRESULT hr = static_cast<CDirect3DDevice7*>(lpDevI)->SetPriorityI(((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDS))->lpLcl, m_dwPriority);
                if(hr != D3D_OK)
                {
                    DPF_ERR("Error inserting SetPriority instruction in batch");
                    return hr;
                }
                if(this->lpDirect3DI->numDevs > 1)
                {
                    hr = lpDevI->FlushStates();  // to avoid sync problems
                    if(hr != D3D_OK)
                    {
                        DPF_ERR("Error flushing device in SetPriority");
                    }
                }
                else
                {
                    // This will ensure that the SetPriority gets to the driver before
                    // Blting or Locking the (texture) surface. Not sure that this is
                    // necessary.
                    lpDevI->BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDS))->lpLcl);
                }
                return hr;
            }
            lpDevI = LIST_NEXT(lpDevI,list);
        }
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREM::GetPriority"

HRESULT DIRECT3DTEXTUREM::GetPriority(LPDWORD lpdwPriority)
{
    *lpdwPriority = m_dwPriority;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTURED3DM::SetPriority"

HRESULT DIRECT3DTEXTURED3DM::SetPriority(DWORD dwPriority)
{
    m_dwPriority = dwPriority;
    lpDirect3DI->lpTextureManager->UpdatePriority(this);
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREM::GetLOD"

HRESULT DIRECT3DTEXTUREM::GetLOD(LPDWORD lpdwLOD)
{
    *lpdwLOD = m_dwLOD;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREM::SetLOD"

HRESULT DIRECT3DTEXTUREM::SetLOD(DWORD dwLOD)
{
    try
    {
        if(dwLOD >= ((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDS))->lpLcl->lpSurfMore->dwMipMapCount)
        {
            D3D_ERR( "Texture has insufficient mipmap levels for this LOD" );
            return DDERR_INVALIDPARAMS;
        }
        m_dwLOD = dwLOD;
        // Look for a hardware device
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&this->lpDirect3DI->devices);
        if(lpDevI == NULL)
        {
            D3D_WARN(0, "SetLOD called before D3D device was created.");
        }
        while (lpDevI)
        {
            if (lpDevI->dwFEFlags & D3DFE_REALHAL)
            {
                if(this->lpDirect3DI->numDevs > 1)
                {
                    D3D_WARN(2, "Multiple devices used. Calling Flush");
                    HRESULT hr = this->lpDirect3DI->FlushDevicesExcept(lpDevI);  // to avoid sync problems
                    if(hr != D3D_OK)
                    {
                        DPF_ERR("Error flushing devices in SetLOD");
                        return hr;
                    }
                }
                DDASSERT(IS_DX7HAL_DEVICE(lpDevI));
                HRESULT hr = static_cast<CDirect3DDevice7*>(lpDevI)->SetTexLODI(((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDS))->lpLcl, m_dwLOD);
                if(hr != D3D_OK)
                {
                    DPF_ERR("Error inserting SetTexLODI instruction in batch");
                    return hr;
                }
                if(this->lpDirect3DI->numDevs > 1)
                {
                    hr = lpDevI->FlushStates();  // to avoid sync problems
                    if(hr != D3D_OK)
                    {
                        DPF_ERR("Error flushing device in SetLODI");
                    }
                }
                else
                {
                    // This will ensure that the SetTexLODI gets to the driver before
                    // Blting or Locking the (texture) surface. Not sure that this is
                    // necessary.
                    lpDevI->BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDS))->lpLcl);
                }
                return hr;
            }
            lpDevI = LIST_NEXT(lpDevI,list);
        }
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTURED3DM::SetLOD"

HRESULT DIRECT3DTEXTURED3DM::SetLOD(DWORD dwLOD)
{
    if(dwLOD >= ((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDSSys))->lpLcl->lpSurfMore->dwMipMapCount)
    {
        D3D_ERR( "Texture has insufficient mipmap levels for this LOD" );
        return DDERR_INVALIDPARAMS;
    }
    if(m_dwLOD != dwLOD)
    {
        m_dwLOD = dwLOD;
        this->ddsd.dwWidth = ((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDSSys))->lpLcl->lpGbl->wWidth >> m_dwLOD;
        if(this->ddsd.dwWidth == 0)
            this->ddsd.dwWidth = 1;
        this->ddsd.dwHeight = ((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDSSys))->lpLcl->lpGbl->wHeight >> m_dwLOD;
        if(this->ddsd.dwHeight == 0)
            this->ddsd.dwHeight = 1;
        this->ddsd.dwMipMapCount = ((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDSSys))->lpLcl->lpSurfMore->dwMipMapCount - m_dwLOD;
        if(InVidmem())
        {
            this->lpDirect3DI->lpTextureManager->RemoveFromHeap(this);
            this->lpDirect3DI->lpTextureManager->remove(this);
        }
        D3DTextureUpdate(static_cast<LPUNKNOWN>(&(this->lpDirect3DI->mD3DUnk)));
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTURED3DM::MarkDirtyPointers"

void DIRECT3DTEXTURED3DM::MarkDirtyPointers()
{
    // We need to loop thru and set pointers to the dirty
    // bit in the DDraw surfaces. The dirty bit will be
    // used to properly update vidmem copies after they
    // have been lost and restored.
    CCubemapIter cmsysmem(((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSSys)->lpLcl);
    CCubemapIter cmvidmem(((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDS)->lpLcl);
    m_dwVidBytes = 0;
    do
    {
        CMipmapIter mmsysmem(cmsysmem()), mmvidmem(cmvidmem());
        do
        {
            mmvidmem()->lpSurfMore->lpbDirty = &(this->bDirty);
            mmvidmem()->lpSurfMore->lpRegionList = mmsysmem()->lpSurfMore->lpRegionList;
            // Mark everything dirty since we are going to copy into this surface
            // from sysmem
            mmvidmem()->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
            if(this->ddsd.dwFlags & DDSD_LINEARSIZE)
                m_dwVidBytes += mmvidmem()->lpGbl->dwLinearSize;
            else
                m_dwVidBytes += mmvidmem()->lpGbl->lPitch * mmvidmem()->lpGbl->wHeight;
            ++mmvidmem;
            ++mmsysmem;
        }
        while(mmsysmem != 0 && mmvidmem != 0);
        ++cmvidmem;
        ++cmsysmem;
    }
    while(cmsysmem != 0);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateTexture"

extern "C" HRESULT WINAPI CreateTexture(LPDIRECTDRAWSURFACE7 pDDS)
{
    LPDIRECT3DTEXTUREI pTex;
    LPDDRAWI_DDRAWSURFACE_LCL pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;

    // Should this texture be managed by D3D?
    if(((DDSCAPS2_TEXTUREMANAGE & pLcl->lpSurfMore->ddsCapsEx.dwCaps2) && !(DDCAPS2_CANMANAGETEXTURE & pLcl->lpSurfMore->lpDD_lcl->lpGbl->ddCaps.dwCaps2))
        || (DDSCAPS2_D3DTEXTUREMANAGE & pLcl->lpSurfMore->ddsCapsEx.dwCaps2))
    {
        pTex =  static_cast<LPDIRECT3DTEXTUREI>(new DIRECT3DTEXTURED3DM);
    }
    // Should this texture be managed by the driver?
    else if((DDSCAPS2_TEXTUREMANAGE & pLcl->lpSurfMore->ddsCapsEx.dwCaps2) && (DDCAPS2_CANMANAGETEXTURE & pLcl->lpSurfMore->lpDD_lcl->lpGbl->ddCaps.dwCaps2))
    {
        pTex =  static_cast<LPDIRECT3DTEXTUREI>(new DIRECT3DTEXTUREM);
    }
    // This texture is unmanaged
    else
    {
        pTex =  static_cast<LPDIRECT3DTEXTUREI>(new DIRECT3DTEXTUREI);
    }

    if (!pTex) 
    {
        D3D_ERR("failed to allocate space for texture object");
        return (DDERR_OUTOFMEMORY);
    }

    LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pLcl->lpSurfMore->lpDD_lcl->pD3DIUnknown)->pD3DI;
    DDASSERT(lpD3D);
    HRESULT ddrval = pTex->Initialize(lpD3D, pDDS);
    if(ddrval != D3D_OK)
    {
        D3D_ERR("Failed to initialize texture.");
        delete pTex;
        return ddrval;
    }

    pLcl->lpSurfMore->lpTex = reinterpret_cast<LPVOID>(pTex);

#if COLLECTSTATS
    pTex->lpDirect3DI->IncNumTexCreates();
#endif

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DestroyTexture"

extern "C" void WINAPI DestroyTexture(LPVOID pTex)
{    
    D3D_INFO(3, "Destroying D3D texture");    
    LPDIRECT3DTEXTUREI lpTexI = reinterpret_cast<LPDIRECT3DTEXTUREI>(pTex);
#if COLLECTSTATS
    lpTexI->lpDirect3DI->IncNumTexDestroys();
#endif
    lpTexI->Destroy();
    delete lpTexI; 
} 

#undef DPF_MODNAME
#define DPF_MODNAME "SetPriority"

extern "C" HRESULT WINAPI SetPriority(LPVOID lpTexI, DWORD dwPriority)
{
#if COLLECTSTATS
    reinterpret_cast<LPDIRECT3DTEXTUREI>(lpTexI)->lpDirect3DI->IncNumSetPris();
#endif
    return reinterpret_cast<LPDIRECT3DTEXTUREI>(lpTexI)->SetPriority(dwPriority);
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetPriority"

extern "C" HRESULT WINAPI GetPriority(LPVOID lpTexI, LPDWORD lpdwPriority)
{
    return reinterpret_cast<LPDIRECT3DTEXTUREI>(lpTexI)->GetPriority(lpdwPriority);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SetLOD"

extern "C" HRESULT WINAPI SetLOD(LPVOID lpTexI, DWORD dwLOD)
{
#if COLLECTSTATS
    reinterpret_cast<LPDIRECT3DTEXTUREI>(lpTexI)->lpDirect3DI->IncNumSetLODs();
#endif
    return reinterpret_cast<LPDIRECT3DTEXTUREI>(lpTexI)->SetLOD(dwLOD);
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetLOD"

extern "C" HRESULT WINAPI GetLOD(LPVOID lpTexI, LPDWORD lpdwLOD)
{
    return reinterpret_cast<LPDIRECT3DTEXTUREI>(lpTexI)->GetLOD(lpdwLOD);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\devstate.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       devstate.c
 *  Content:    device state management
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "drawprim.hpp"
#include "pvvid.h"
#include "d3dfei.h"

extern HRESULT checkDeviceSurface(LPDIRECT3DDEVICEI lpD3DDev,
                                  LPDIRECTDRAWSURFACE lpDDS);
extern HRESULT CalcDDSurfInfo(LPDIRECT3DDEVICEI lpDevI, BOOL bUpdateZBufferFields);
//---------------------------------------------------------------------
inline void UpdateFogFactor(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->lighting.fog_end == lpDevI->lighting.fog_start)
        lpDevI->lighting.fog_factor = D3DVAL(0.0);
    else
        lpDevI->lighting.fog_factor = D3DVAL(255) /
                                     (lpDevI->lighting.fog_end - lpDevI->lighting.fog_start);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetRenderState"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetRenderState(D3DRENDERSTATETYPE dwState, DWORD value)
{
#if DBG
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0 )
    {
        D3D_ERR( "Invalid render state type" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    // Takes D3D lock (MT only).
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

    try
    {
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            if(this->CheckForRetiredRenderState(dwState))
            {
                m_pStateSets->InsertRenderState(dwState, value, CanHandleRenderState(dwState));
            }
            else
            {
                D3D_ERR("invalid renderstate %d", dwState);
                return DDERR_INVALIDPARAMS;
            }
        }
        else
            this->SetRenderStateFast(dwState, value);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetRenderStateFast"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetRenderStateFast(D3DRENDERSTATETYPE dwState, DWORD value)
{
#if DBG
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0 )
    {
        D3D_ERR( "Invalid render state type" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    if (!(rsVec[dwState >> D3D_RSVEC_SHIFT] & (1ul << (dwState & D3D_RSVEC_MASK))))
    { // Fast path. We do not need any processing done in UpdateInternalState other than updating rstates array
        if (this->rstates[dwState] == value)
        {
            D3D_WARN(4,"Ignoring redundant SetRenderState");
            return D3D_OK;
        }
        this->rstates[dwState] = value;
        // Output state to the device driver
        return SetRenderStateI(dwState, value);
    }
    else
    {
        try
        {
            // Wrap modes could be re-programmed. We need to restore them before
            // filtering redundant values
            if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
            {
                RestoreTextureStages(this);
                ForceFVFRecompute();
            }
            if (this->rstates[dwState] == value)
            {
                D3D_WARN(4,"Ignoring redundant SetRenderState");
                return D3D_OK;
            }
            this->UpdateInternalState(dwState, value);
            if (CanHandleRenderState(dwState))
            {
                if(CheckForRetiredRenderState(dwState))
                    return SetRenderStateI(dwState, value);
                D3D_ERR("invalid renderstate %d", dwState);
                return DDERR_INVALIDPARAMS;
            }
        }
        catch(HRESULT ret)
        {
            return ret;
        }
    }
    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetRenderStateInternal"

HRESULT
DIRECT3DDEVICEI::SetRenderStateInternal(D3DRENDERSTATETYPE dwState, DWORD dwValue)
{
    if (this->rstates[dwState] == dwValue)
    {
        D3D_WARN(4,"Ignoring redundant SetRenderState");
        return D3D_OK;
    }
    try
    {
        this->UpdateInternalState(dwState, dwValue);
        if (CanHandleRenderState(dwState))
            return SetRenderStateI(dwState, dwValue);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetRenderState"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetRenderState(D3DRENDERSTATETYPE dwState, LPDWORD lpdwValue)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).

#if DBG
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0)
    {
        D3D_ERR( "Invalid render state value" );
        return DDERR_INVALIDPARAMS;
    }
#endif

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_PTR(lpdwValue, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer" );
        return DDERR_INVALIDPARAMS;
    }

    if(!CheckForRetiredRenderState(dwState))
    {
        D3D_ERR("invalid renderstate %d", dwState);
        return DDERR_INVALIDPARAMS;
    }

    // WRAP render states could be re-mapped so we have to return the original
    // value
    if (dwState >= D3DRENDERSTATE_WRAP0 && dwState <= D3DRENDERSTATE_WRAP7)
    {
        if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            DWORD dwTexCoordIndex = dwState - D3DRENDERSTATE_WRAP0;
            for (DWORD i=0; i < this->dwNumTextureStages; i++)
            {
                LPD3DFE_TEXTURESTAGE pStage = &this->textureStage[i];
                if (pStage->dwInpCoordIndex == dwTexCoordIndex)
                {
                    if (pStage->dwInpCoordIndex != pStage->dwOutCoordIndex)
                    {
                        *lpdwValue = pStage->dwOrgWrapMode;
                        return D3D_OK;
                    }
                }
            }
        }
    }
    *lpdwValue = this->rstates[dwState];
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTexture"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetTexture(DWORD dwStage, LPDIRECTDRAWSURFACE7 *lplpTex)
{
    // Takes D3D lock (MT only).
    // Lock released in the destructor.
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_PTR(lplpTex, sizeof(LPVOID)))
    {
        D3D_ERR( "Invalid pointer to LPDIRECTDRAWSURFACE7" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->lpD3DMappedTexI[dwStage])
    {
        if(this->lpD3DMappedTexI[dwStage]->D3DManaged())
            *lplpTex = this->lpD3DMappedTexI[dwStage]->lpDDSSys;
        else
            *lplpTex = this->lpD3DMappedTexI[dwStage]->lpDDS;
        (*lplpTex)->AddRef();
    }
    else
    {
        *lplpTex = NULL;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::VerifyTexture"
HRESULT DIRECT3DDEVICEI::VerifyTexture(DWORD dwStage, LPDIRECTDRAWSURFACE7 lpTex)
{
    if (dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }

    if (lpTex)
    {
        if (!VALID_DDSURF_PTR(lpTex))
        {
            D3D_ERR( "Invalid surface pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if((((LPDDRAWI_DDRAWSURFACE_INT)lpTex)->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE)) &&
            !(this->dwFEFlags & D3DFE_REALHAL))
        {
            D3D_ERR( "Managed textures cannot be used with a software device" );
            return DDERR_INVALIDPARAMS;
        }

        if(!IsToplevel(((LPDDRAWI_DDRAWSURFACE_INT)lpTex)->lpLcl))
        {
            D3D_ERR( "Cannot set a mipmap sublevel or a cubemap subface" );
            return DDERR_INVALIDPARAMS;
        }

        LPDIRECT3DTEXTUREI lpTexI = reinterpret_cast<LPDIRECT3DTEXTUREI>(((LPDDRAWI_DDRAWSURFACE_INT)lpTex)->lpLcl->lpSurfMore->lpTex);
        if(lpTexI == NULL)
        {
            D3D_ERR( "Surface must have DDSCAPS_TEXTURE set to use in SetTexture" );
            return DDERR_INVALIDPARAMS;
        }

        if (!lpTexI->D3DManaged())
        {
            if((((LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS))->lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                (!(lpD3DHALGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURESYSTEMMEMORY)))
            {
                D3D_ERR( "Device cannot render using texture surface from system memory" );
                return DDERR_INVALIDPARAMS;
            }
        }

        CLockD3DST lockObject(this, DPF_MODNAME, REMIND("")); // we access DDraw gbl in VerifyTextureCaps
        return VerifyTextureCaps(lpTexI);
    }

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetTexture"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTexture(DWORD dwStage, LPDIRECTDRAWSURFACE7 lpTex)
{
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

#if DBG
        HRESULT ret = VerifyTexture(dwStage, lpTex);
        if(ret != D3D_OK)
            return ret;
#endif

        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            m_pStateSets->InsertTexture(dwStage, lpTex);
            return D3D_OK;
        }

        return SetTextureInternal(dwStage, lpTex);
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetTextureInternal"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTextureInternal(DWORD dwStage, LPDIRECTDRAWSURFACE7 lpTex)
{

#if DBG
    HRESULT ret = VerifyTexture(dwStage, lpTex);
    if(ret != D3D_OK)
        return ret;
#endif

#if COLLECTSTATS
    this->IncNumTexturesSet();
#endif

    LPDIRECT3DTEXTUREI lpTexI = lpTex ? reinterpret_cast<LPDIRECT3DTEXTUREI>(((LPDDRAWI_DDRAWSURFACE_INT)lpTex)->lpLcl->lpSurfMore->lpTex) : NULL;

    if (lpD3DMappedTexI[dwStage] == lpTexI)
    {
        return  D3D_OK;
    }

    if (lpD3DMappedTexI[dwStage])
    {
        lpD3DMappedTexI[dwStage]->Release();
    }

    lpD3DMappedTexI[dwStage] = lpTexI;

    if (lpTexI)
    {
        lpTexI->AddRef();
#if COLLECTSTATS
        if(lpTexI->D3DManaged())
        {
            this->lpDirect3DI->lpTextureManager->IncNumTexturesSet();
            if(lpTexI->InVidmem())
                this->lpDirect3DI->lpTextureManager->IncNumSetTexInVid();
        }
#endif
    }

    m_dwStageDirty |= (1 << dwStage);

    // Need to call UpdateTextures()
    this->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE;

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetTextureStageState"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTextureStageState(DWORD dwStage,
                                      D3DTEXTURESTAGESTATETYPE dwState,
                                      DWORD dwValue)
{
#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES ||
        dwState == 0 || dwState >= D3DTSS_MAX)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif //DBG
    try
    {
        // Holds D3D lock until exit.
        CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));

        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            m_pStateSets->InsertTextureStageState(dwStage, dwState, dwValue);
            return D3D_OK;
        }
        return this->SetTextureStageStateFast(dwStage, dwState, dwValue);
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetTextureStageStateFast"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTextureStageStateFast(DWORD dwStage,
                                          D3DTEXTURESTAGESTATETYPE dwState,
                                          DWORD dwValue)
{
#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES ||
        dwState == 0 || dwState >= D3DTSS_MAX)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif //DBG

    // Fast path. We do not need any processing done in UpdateInternalTSS other than updating tsstates array
    if (NeedInternalTSSUpdate(dwState))
    {
        // Texture stages could be re-programmed. We need to restore them before
        // filtering  redundant values
        if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            RestoreTextureStages(this);
            ForceFVFRecompute();
        }
        if (this->tsstates[dwStage][dwState] == dwValue)
        {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        if(this->UpdateInternalTextureStageState(dwStage, dwState, dwValue))
            return D3D_OK;
    }
    else
    {
        if (this->tsstates[dwStage][dwState] == dwValue)
        {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        tsstates[dwStage][dwState] = dwValue;
    }

    if (dwStage >= this->dwMaxTextureBlendStages)
        return D3D_OK;

    return SetTSSI(dwStage, dwState, dwValue);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTextureStageState"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetTextureStageState(DWORD dwStage,
                                      D3DTEXTURESTAGESTATETYPE dwState,
                                      LPDWORD pdwValue)
{
    // Takes D3D lock (MT only).
    // Lock released in the destructor.
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES ||
        dwState == 0 || dwState >= D3DTSS_MAX)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif  //DBG

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_PTR(pdwValue, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer" );
        return DDERR_INVALIDPARAMS;
    }

    // If texture indices were re-mapped we have to find and return the original value
    if (dwState == D3DTSS_TEXCOORDINDEX &&  this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(this);
        ForceFVFRecompute();
    }
    // Don't bother to check for DX6 support, just return the
    // cached value.
    *pdwValue = tsstates[dwStage][dwState];
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::CreateDevice"

extern HRESULT WINAPI Direct3DCreateDevice(REFCLSID            riid,
                                           LPUNKNOWN           lpDirect3D,
                                           LPDIRECTDRAWSURFACE lpDDSTarget,
                                           LPUNKNOWN*          lplpD3DDevice,
                                           IUnknown*           pUnkOuter);

HRESULT D3DAPI DIRECT3DI::CreateDevice(REFCLSID devType,
                                       LPDIRECTDRAWSURFACE7 lpDDS7,
                                       LPDIRECT3DDEVICE7 *lplpDirect3DDevice)
{
    HRESULT ret;
    LPUNKNOWN lpUnkDevice;
    LPDIRECTDRAWSURFACE lpDDS;

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                        // Release in the destructor

        if (!VALID_DIRECT3D_PTR(this)) {
            D3D_ERR( "Invalid Direct3D pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(lplpDirect3DDevice))
        {
            D3D_ERR( "Invalid pointer to Device object pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_D3D_DIRECTDRAWSURFACE7_PTR(((LPDDRAWI_DDRAWSURFACE_INT)lpDDS7)))
        {
            D3D_ERR( "Invalid DirectDrawSurface7 pointer" );
            return DDERR_INVALIDOBJECT;
        }

        *lplpDirect3DDevice = NULL;

        // QI lpDDS7 for lpDDS interface
        ret = lpDDS7->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpDDS);
        if (FAILED(ret))
            return ret;

        lpDDS->Release();

        ret = Direct3DCreateDevice(devType, &this->mD3DUnk, lpDDS, (LPUNKNOWN *) &lpUnkDevice, NULL);

        if(FAILED(ret) || (lpUnkDevice==NULL))
          return ret;

        // QI device1 for a device7 interface
        ret = lpUnkDevice->QueryInterface(IID_IDirect3DDevice7, (LPVOID*)lplpDirect3DDevice);

        lpUnkDevice->Release();  // release unneeded interface

        return ret;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//----------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetTransformI"

void DIRECT3DDEVICEI::SetTransformI(D3DTRANSFORMSTATETYPE state, LPD3DMATRIX lpMat)
{
    switch (state)
    {
    case D3DTRANSFORMSTATE_WORLD      :
        *(D3DMATRIX*)&this->transform.world[0] = *lpMat;
        this->dwFEFlags |= D3DFE_WORLDMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTRANSFORMSTATE_WORLD1     :
        *(D3DMATRIX*)&this->transform.world[1] = *lpMat;
        this->dwFEFlags |= D3DFE_WORLDMATRIX1_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTRANSFORMSTATE_WORLD2     :
        *(D3DMATRIX*)&this->transform.world[2] = *lpMat;
        this->dwFEFlags |= D3DFE_WORLDMATRIX2_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTRANSFORMSTATE_WORLD3     :
        *(D3DMATRIX*)&this->transform.world[3] = *lpMat;
        this->dwFEFlags |= D3DFE_WORLDMATRIX3_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTRANSFORMSTATE_VIEW       :
        *(D3DMATRIX*)&this->transform.view = *lpMat;
        this->dwFEFlags |= D3DFE_VIEWMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTRANSFORMSTATE_PROJECTION :
        *(D3DMATRIX*)&this->transform.proj = *lpMat;
        this->dwFEFlags |= D3DFE_PROJMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        if (!(this->dwFEFlags & D3DFE_EXECUTESTATEMODE))
        {
            this->UpdateDrvWInfo();
        }
        break;
    case D3DTRANSFORMSTATE_TEXTURE0:
    case D3DTRANSFORMSTATE_TEXTURE1:
    case D3DTRANSFORMSTATE_TEXTURE2:
    case D3DTRANSFORMSTATE_TEXTURE3:
    case D3DTRANSFORMSTATE_TEXTURE4:
    case D3DTRANSFORMSTATE_TEXTURE5:
    case D3DTRANSFORMSTATE_TEXTURE6:
    case D3DTRANSFORMSTATE_TEXTURE7:
        {
            this->dwDeviceFlags |= D3DDEV_TEXTRANSFORMDIRTY;
            DWORD dwIndex = state - D3DTRANSFORMSTATE_TEXTURE0;
            *(D3DMATRIX*)&this->mTexture[dwIndex] = *lpMat;
            break;
        }
    }
}
//----------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetTransform"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTransform(D3DTRANSFORMSTATETYPE state, LPD3DMATRIX lpMat)
{
#if DBG
    if (!VALID_PTR(lpMat, sizeof(D3DMATRIX)))
    {
        D3D_ERR( "Invalid matrix pointer" );
        return DDERR_INVALIDPARAMS;
    }
    switch (state)
    {
    case D3DTRANSFORMSTATE_WORLD:
    case D3DTRANSFORMSTATE_WORLD1:
    case D3DTRANSFORMSTATE_WORLD2:
    case D3DTRANSFORMSTATE_WORLD3:
    case D3DTRANSFORMSTATE_VIEW :
    case D3DTRANSFORMSTATE_PROJECTION :
    case D3DTRANSFORMSTATE_TEXTURE0:
    case D3DTRANSFORMSTATE_TEXTURE1:
    case D3DTRANSFORMSTATE_TEXTURE2:
    case D3DTRANSFORMSTATE_TEXTURE3:
    case D3DTRANSFORMSTATE_TEXTURE4:
    case D3DTRANSFORMSTATE_TEXTURE5:
    case D3DTRANSFORMSTATE_TEXTURE6:
    case D3DTRANSFORMSTATE_TEXTURE7:
        break;
    default :
        D3D_ERR( "Invalid state value passed to SetTransform" );
        return DDERR_INVALIDPARAMS; /* Work Item: Generate new meaningful return code */
    }
#endif
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            m_pStateSets->InsertTransform(state, lpMat);
        else
            this->SetTransformI(state, lpMat);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetTransform"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetTransform(D3DTRANSFORMSTATETYPE dtsTransformState, LPD3DMATRIX lpMat)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
    HRESULT ret = D3D_OK;
#if DBG
    if (!lpMat) {
        D3D_ERR( "NULL matrix pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    switch (dtsTransformState) {
    case D3DTRANSFORMSTATE_WORLD :
        *lpMat = *(LPD3DMATRIX)&this->transform.world[0]._11;
        break;
    case D3DTRANSFORMSTATE_WORLD1 :
        *lpMat = *(LPD3DMATRIX)&this->transform.world[1]._11;
        break;
    case D3DTRANSFORMSTATE_WORLD2 :
        *lpMat = *(LPD3DMATRIX)&this->transform.world[2]._11;
        break;
    case D3DTRANSFORMSTATE_WORLD3 :
        *lpMat = *(LPD3DMATRIX)&this->transform.world[3]._11;
        break;
    case D3DTRANSFORMSTATE_VIEW :
        *lpMat = *(LPD3DMATRIX)&this->transform.view._11;
        break;
    case D3DTRANSFORMSTATE_PROJECTION :
        *lpMat = *(LPD3DMATRIX)&this->transform.proj._11;
        break;
    case D3DTRANSFORMSTATE_TEXTURE0:
    case D3DTRANSFORMSTATE_TEXTURE1:
    case D3DTRANSFORMSTATE_TEXTURE2:
    case D3DTRANSFORMSTATE_TEXTURE3:
    case D3DTRANSFORMSTATE_TEXTURE4:
    case D3DTRANSFORMSTATE_TEXTURE5:
    case D3DTRANSFORMSTATE_TEXTURE6:
    case D3DTRANSFORMSTATE_TEXTURE7:
        *lpMat = *(LPD3DMATRIX)&this->mTexture[dtsTransformState-D3DTRANSFORMSTATE_TEXTURE0]._11;
        break;
    default :
        D3D_ERR( "Invalid state value passed to GetTransform" );
        ret = DDERR_INVALIDPARAMS; /* Work Item: Generate new meaningful return code */
        break;
    }

    return ret;
}       // end of D3DDev2_GetTransform()

void InvalidateHandles(LPDIRECT3DDEVICEI lpDevI)
{
    /* free up all textures created by this object */
    LPD3DI_TEXTUREBLOCK tBlock=LIST_FIRST(&lpDevI->texBlocks);
    while (tBlock)
    {
        D3DI_RemoveTextureHandle(tBlock);
        tBlock=LIST_NEXT(tBlock,devList);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::UpdateDriverStates"

HRESULT
DIRECT3DDEVICEI::UpdateDriverStates()
{
    // note we can't do a loop from 1 to D3DHAL_MAX_RSTATES(256) as some of rstates are not
    // valid states, passin them down to drivers(like voodoo2 DX6 driver) will crash.
    for (DWORD i = D3DRENDERSTATE_ANTIALIAS ; i < D3DRENDERSTATE_WRAPBIAS+8; ++i)
    {
        HRESULT ret = this->SetRenderStateI((D3DRENDERSTATETYPE)i, this->rstates[i]);
        if (ret != D3D_OK)
            return ret;
    }
    return D3D_OK;
}

void DIRECT3DDEVICEI::SetRenderTargetI(LPDIRECTDRAWSURFACE lpDDS, LPDIRECTDRAWSURFACE lpZ)
{
    HRESULT ret;

    // Flush before switching RenderTarget..
    ret = FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to FlushStates in SetRenderTarget");
        throw ret;
    }

    if (this->lpD3DHALCallbacks2->SetRenderTarget)
    {
        D3DHAL_SETRENDERTARGETDATA rtData;

        rtData.dwhContext = this->dwhContext;
#ifndef WIN95
        if (dwFEFlags & D3DFE_REALHAL)
        {
            if (lpDDS)
                rtData.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl;
            else
                rtData.lpDDSLcl = NULL;

            if (lpZ)
                rtData.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpZ)->lpLcl;
            else
                rtData.lpDDSZLcl = NULL;

        }
        else
#endif //WIN95
        {
            rtData.lpDDS = lpDDS;
            rtData.lpDDSZ = lpZ;
        }

        rtData.ddrval = 0;
        CALL_HAL2ONLY(ret, this, SetRenderTarget, &rtData);
        if ((ret != DDHAL_DRIVER_HANDLED) || (rtData.ddrval != DD_OK))
        {
            D3D_ERR( "Driver call failed in SetRenderTarget" );
            // Need sensible return value in this case,
            // currently we return whatever the driver stuck in here.
            ret = rtData.ddrval;
            throw ret;
        }
    }
    else
    {
        D3DHAL_CONTEXTCREATEDATA cdata;
        D3DHAL_CONTEXTDESTROYDATA ddata;

        /* Destroy old context */
        memset(&ddata, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA));
        ddata.dwhContext = this->dwhContext;

        CALL_HALONLY(ret, this, ContextDestroy, &ddata);
        if (ret != DDHAL_DRIVER_HANDLED || ddata.ddrval != DD_OK)
        {
            DPF(0, "(ERROR) ContextDestroy. Failed. dwhContext = %d", ddata.dwhContext);
            // Need sensible return value in this case,
            // currently we return whatever the driver stuck in here.
            ret = ddata.ddrval;
            throw ret;
        }

        /* Create new context */
        memset(&cdata, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));

        cdata.lpDDGbl = this->lpDDGbl;
        cdata.lpDDS = lpDDS;
        cdata.lpDDSZ = lpZ;

        // Hack Alert!! dwhContext is used to inform the driver which version
        // of the D3D interface is calling it.
        cdata.dwhContext = 3;
        cdata.dwPID  = GetCurrentProcessId();
        // Hack Alert!! ddrval is used to inform the driver which driver type
        // the runtime thinks it is (DriverStyle registry setting)
        cdata.ddrval = this->deviceType;

        CALL_HALONLY(ret, this, ContextCreate, &cdata);
        if (ret != DDHAL_DRIVER_HANDLED || cdata.ddrval != DD_OK)
        {
            D3D_ERR("HAL call to ContextCreate failed in SetRenderTarget");
            // Need sensible return value in this case,
            // currently we return whatever the driver stuck in here.
            throw cdata.ddrval;
        }
        this->dwhContext = (DWORD)cdata.dwhContext;
        D3D_INFO(9, "in halCreateContext. Succeeded. dwhContext = %d", cdata.dwhContext);

        ret = this->UpdateDriverStates();
        if (ret != D3D_OK)
            throw ret;
    }
    InvalidateHandles(this);
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetRenderTarget"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetRenderTarget(LPDIRECTDRAWSURFACE7 lpDDS7, DWORD dwFlags)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    LPDIRECTDRAWSURFACE lpZ=NULL,lpDDS=NULL;
    LPDIRECTDRAWSURFACE7 lpZ_DDS7=NULL;
    LPDIRECTDRAWPALETTE lpPal=NULL;
    try
    {
        DDSCAPS2 ddscaps;
        memset(&ddscaps, 0, sizeof(ddscaps));
        DDSURFACEDESC2 ddsd;
        HRESULT     ret, ddrval;
        DWORD i, j;


        if (!VALID_DIRECT3DDEVICE_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice7 pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALID_D3D_DIRECTDRAWSURFACE7_PTR(((LPDDRAWI_DDRAWSURFACE_INT)lpDDS7)))
        {
            D3D_ERR( "Invalid DirectDrawSurface7 pointer" );
            return DDERR_INVALIDOBJECT;
        }

        /*
         * Check if the 3D cap is set on the surface.
         */
        memset(&ddsd, 0, sizeof ddsd);
        ddsd.dwSize = sizeof ddsd;
        ddrval = lpDDS7->GetSurfaceDesc(&ddsd);
        if (ddrval != DD_OK)
        {
            D3D_ERR("Failed to get surface description of device's surface.");
            return (ddrval);
        }

        if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_3DDEVICE))
        {
            D3D_ERR("**** The DDSCAPS_3DDEVICE is not set on this surface.");
            D3D_ERR("**** You need to add DDSCAPS_3DDEVICE to ddsCaps.dwCaps");
            D3D_ERR("**** when creating the surface.");
            return (DDERR_INVALIDCAPS);
        }
        if (!(this->lpD3DHALGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & BitDepthToDDBD(ddsd.ddpfPixelFormat.dwRGBBitCount))) {
            D3D_ERR("Rendering surface's RGB bit count not supported by hardware device");
            return (DDERR_INVALIDCAPS);
        }
        if (ddsd.dwWidth > 2048 || ddsd.dwHeight > 2048)
        {
            D3D_ERR("Surface dimension > 2048");
            return DDERR_INVALIDPARAMS;
        }

        /* The z-buffer... */
        ddscaps.dwCaps = DDSCAPS_ZBUFFER;
        ret = lpDDS7->GetAttachedSurface(&ddscaps, &lpZ_DDS7);
        if ((ret != DD_OK) && (ret != DDERR_NOTFOUND))
        {
            /*
             * NOTE: Not an error if the z-buffer is not found. We will let the
             * dirver handle that (it might fail or create its own z-buffer).
             */
            D3D_ERR("Supplied DirectDraw Z-Buffer is invalid - can't set render target");
            throw DDERR_INVALIDPARAMS;
        }
        if (lpZ_DDS7)
            lpZ_DDS7->Release(); // We do not need to addref this one;

        // QI lpDDS7 for lpDDS interface, which will be used internally by D3D
        ret = lpDDS7->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpDDS);

        if(FAILED(ret))
          throw ret;

        /* The palette... */
        ret = lpDDS->GetPalette(&lpPal);
        if ((ret != DD_OK) && (ret != DDERR_NOPALETTEATTACHED))
        {
            /*
             * NOTE: Again, not an error (yet) if there is no palette attached.
             * But if there is palette and we can't get at it for some reason
             * - fail.
             */
            D3D_ERR("Supplied DirectDraw Palette is invalid - can't create device");
            throw DDERR_INVALIDPARAMS;
        }

        /*
         * We're going to check now whether we should have got a palette.
         */
        if (ret == DDERR_NOPALETTEATTACHED)
        {
            if (ddsd.ddpfPixelFormat.dwRGBBitCount < 16)
            {
                D3D_ERR("No palette supplied for palettized surface");
                throw DDERR_NOPALETTEATTACHED;
            }
        }

        /* Verify Z buffer */

        if (lpZ_DDS7!=NULL)
        {
            memset(&ddsd, 0, sizeof(ddsd));
            ddsd.dwSize = sizeof(ddsd);
            if ((ret=lpZ_DDS7->GetSurfaceDesc(&ddsd)) != DD_OK)
            {
                D3D_ERR("Failed to getsurfacedesc on Z");
                throw ret;
            }

            // QI lpDDS7 for lpDDS interface, which will be used internally by D3D
            ret = lpZ_DDS7->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpZ);

            if(FAILED(ret))
              throw ret;
        }

        SetRenderTargetI(lpDDS, lpZ);
        // this indicates that the device need no longer be flushed when Locking, Blting
        // or GetDC'ing from the previous rendertarget
        if (this->lpDDSTarget)
            ((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSTarget)->lpLcl->lpSurfMore->qwBatch.QuadPart = 0;
        // this indicates that the device need no longer be flushed when Locking, Blting
        // or GetDC'ing from the previous zbuffer
        if (this->lpDDSZBuffer)
            ((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSZBuffer)->lpLcl->lpSurfMore->qwBatch.QuadPart = 0;

        // this indicates that the device should always be flushed when Locking, Blting
        // or GetDC'ing a rendertarget
        ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS7)->lpLcl->lpSurfMore->qwBatch.QuadPart = _UI64_MAX;
        // this indicates that the device should always be flushed when Locking, Blting
        // or GetDC'ing a zbuffer
        if(lpZ_DDS7)
            ((LPDDRAWI_DDRAWSURFACE_INT)lpZ_DDS7)->lpLcl->lpSurfMore->qwBatch.QuadPart = _UI64_MAX;

        // release old device DDS/DDS7 interfaces and replace with the new ones,
        // which are mostly already AddRef'd (except for lpDDS7)

        /// DDSZBuffer ///
        if(this->lpDDSZBuffer)
          this->lpDDSZBuffer->Release();

        // lpZ AddRef'd by QI
        this->lpDDSZBuffer = lpZ;

        /// DDSZBuffer DDS7 ///
        this->lpDDSZBuffer_DDS7=lpZ_DDS7; // This needs no AddRef or Release

        ///  DDSTarget  ///
        this->lpDDSTarget = lpDDS;
#ifndef WIN95
        hSurfaceTarget = (unsigned long)((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->hDDSurface;
#else
        hSurfaceTarget = (unsigned long)((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->lpSurfMore->dwSurfaceHandle;
#endif
        // lpDDS AddRef'd by QI so release it
        this->lpDDSTarget->Release();

        ///  DDSTarget DDS7  ///
        this->lpDDSTarget_DDS7->Release();
        lpDDS7->AddRef();  // ensure lpDDS7 (which was an argument) doesnt disappear

        this->lpDDSTarget_DDS7=lpDDS7;

        if (this->lpDDPalTarget)
          this->lpDDPalTarget->Release();

        // already AddRef'd by GetPalette()
        this->lpDDPalTarget = lpPal;

        ret=CalcDDSurfInfo(this,TRUE);  // this call will never fail due to external error
        DDASSERT(ret==D3D_OK);

        return ret;
    }
    catch (HRESULT ret)
    {
        if(lpPal)
          lpPal->Release();
        if(lpZ)
          lpZ->Release();
        if(lpZ_DDS7)
          lpZ_DDS7->Release();
        if(lpDDS)
          lpDDS->Release();

        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetRenderTarget"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetRenderTarget(LPDIRECTDRAWSURFACE7* lplpDDS)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if ( !VALID_OUTPTR( lplpDDS ) )
    {
        D3D_ERR( "Invalid ptr to DDS ptr" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpDDS = this->lpDDSTarget_DDS7;

    this->lpDDSTarget_DDS7->AddRef();
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetClipStatus"

#define D3DSTATUS_VALID 0x80000000L /* Reserved Status flag to indicate SetClipStatus is called */

HRESULT D3DAPI DIRECT3DDEVICEI::SetClipStatus(LPD3DCLIPSTATUS status)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
#if DBG
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (! VALID_PTR(status, sizeof(D3DCLIPSTATUS)) )
    {
        D3D_ERR( "Invalid status pointer" );
        return DDERR_INVALIDPARAMS;
    }

#endif
    // D3DCLIPSTATUS_EXTENTS3 not supported in Device7
    if (status->dwFlags & D3DCLIPSTATUS_EXTENTS3)
    {
        D3D_ERR( "D3DCLIPSTATUS_EXTENTS3 not supported for Device7" );
        return DDERR_INVALIDPARAMS;
    }
    if (status->dwFlags & D3DCLIPSTATUS_STATUS)
        this->iClipStatus = status->dwStatus;

    if (status->dwFlags & (D3DCLIPSTATUS_EXTENTS2 | D3DCLIPSTATUS_EXTENTS3))
    {
        this->rExtents.x1 = status->minx;
        this->rExtents.y1 = status->miny;
        this->rExtents.x2 = status->maxx;
        this->rExtents.y2 = status->maxy;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetClipStatus"

HRESULT D3DAPI DIRECT3DDEVICEI::GetClipStatus(LPD3DCLIPSTATUS status)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
#if DBG
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (! VALID_PTR(status, sizeof(D3DCLIPSTATUS)) )
    {
        D3D_ERR( "Invalid status pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    status->dwStatus = iClipStatus;
    status->dwFlags = D3DCLIPSTATUS_EXTENTS2;
    status->minx = this->rExtents.x1;
    status->miny = this->rExtents.y1;
    status->maxx = this->rExtents.x2;
    status->maxy = this->rExtents.y2;
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::UpdateTextures"

HRESULT DIRECT3DDEVICEI::UpdateTextures()
{
    HRESULT result = D3D_OK;
    DWORD dwSavedFlags = this->dwFlags;
    this->dwFlags |= D3DPV_WITHINPRIMITIVE;
    for (DWORD dwStage = 0; dwStage < this->dwMaxTextureBlendStages; dwStage++)
    {
        D3DTEXTUREHANDLE dwDDIHandle;
        LPDIRECT3DTEXTUREI lpTexI = this->lpD3DMappedTexI[dwStage];
        if(lpTexI)
        {
            if (lpTexI->bDirty)
            {
                if (lpTexI->InVidmem())
                {
                    CLockD3DST lockObject(this, DPF_MODNAME, REMIND("")); // we access DDraw gbl in CopySurface
                    // 0xFFFFFFFF is equivalent to ALL_FACES, but in addition indicates to CopySurface
                    // that this is a sysmem -> vidmem transfer.
                    result = CopySurface(lpTexI->lpDDS,NULL,lpTexI->lpDDSSys,NULL,0xFFFFFFFF);
                    if (DD_OK != result)
                    {
                        D3D_ERR("Error copying surface while updating textures");
                        goto l_exit;
                    }
                    else
                    {
                        lpTexI->bDirty=FALSE;
                        D3D_INFO(4,"UpdateTextures: Dirty texture updated");
                    }
                }
            }
            LPD3DI_TEXTUREBLOCK lpBlock;
            if (m_dwStageDirty & (1 << dwStage))
            {
                lpBlock = NULL; // indicates to GetTextureDDIHandle to find the block for this (tex,dev)
            }
            else
            {
                lpBlock = this->lpD3DMappedBlock[dwStage]; // use the cached block
                DDASSERT(lpBlock);
                if (lpBlock->hTex) // have we created a handle for this (tex,dev)?
                {
                    continue;   //nothing need to be done further
                }
            }

            result = GetTextureDDIHandle(lpTexI, &lpBlock);
            if (result != D3D_OK)
            {
                D3D_ERR("Failed to get texture handle");
                goto l_exit;
            }
            else
            {
                dwDDIHandle = lpBlock->hTex;
                this->lpD3DMappedBlock[dwStage] = lpBlock;
                BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)lpTexI->lpDDS)->lpLcl);
                m_dwStageDirty &= ~(1 << dwStage); // reset stage dirty
            }
        }
        else if (m_dwStageDirty & (1 << dwStage))
        {
            this->lpD3DMappedBlock[dwStage]=NULL; //a SetTexture(Stage,NULL) issued
            dwDDIHandle = 0;    //tell driver to disable this texture
            m_dwStageDirty &= ~(1 << dwStage); // reset stage dirty
        }
        else
        {
            continue;   //both zero, no action needed
        }
#ifdef WIN95
        if (IS_DP2HAL_DEVICE(this))
        {
#endif
            CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2 *>(this);
            result = dp2dev->SetTSSI(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, dwDDIHandle);
            if(result != D3D_OK)
            {
                D3D_ERR("Failed to batch set texture instruction");
                goto l_exit;
            }
            // Update runtime copy of state.
            dp2dev->tsstates[dwStage][D3DTSS_TEXTUREMAP] = dwDDIHandle;
#ifdef WIN95
        }
        else
        {
            if(this->dwFEFlags & D3DFE_DISABLE_TEXTURES)
                break;
            CDirect3DDeviceIHW *dev = static_cast<CDirect3DDeviceIHW *>(this);
            result = dev->SetRenderStateI(D3DRENDERSTATE_TEXTUREHANDLE, dwDDIHandle);
            if(result != D3D_OK)
            {
                D3D_ERR("Failed to batch setrenderstate instruction");
                goto l_exit;
            }
            // Update runtime copy of state.
            dev->rstates[D3DRENDERSTATE_TEXTUREHANDLE] = dwDDIHandle;
        }
#endif
    }
l_exit:
    this->dwFlags = dwSavedFlags;
    return result;
}

//---------------------------------------------------------------------
// This function is called from HALEXE.CPP, from device::SetRenderState and
// from device::SetTexture.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::UpdateInternalState"

void DIRECT3DDEVICEI::UpdateInternalState(D3DRENDERSTATETYPE type, DWORD value)
{
    switch (type)
    {
    case D3DRENDERSTATE_LIGHTING:
        if (value)
            this->dwDeviceFlags |= D3DDEV_LIGHTING;
        else
            this->dwDeviceFlags &= ~D3DDEV_LIGHTING;
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_FOGENABLE:
        rstates[type] = value;      // set rstates BEFORE calling SetFogFlags
        SetFogFlags();
        break;
    case D3DRENDERSTATE_SPECULARENABLE:
        this->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY | D3DFE_FRONTEND_DIRTY;
        if (value)
            this->dwDeviceFlags |= D3DDEV_SPECULARENABLE;
        else
            this->dwDeviceFlags &= ~D3DDEV_SPECULARENABLE;
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_AMBIENT:
        {
            const D3DVALUE SCALE = 1.0f/255.0f;
            this->lighting.ambientSceneScaled.r = D3DVAL(RGBA_GETRED(value));
            this->lighting.ambientSceneScaled.g = D3DVAL(RGBA_GETGREEN(value));
            this->lighting.ambientSceneScaled.b = D3DVAL(RGBA_GETBLUE(value));
            this->lighting.ambientScene.r = this->lighting.ambientSceneScaled.r * SCALE;
            this->lighting.ambientScene.g = this->lighting.ambientSceneScaled.g * SCALE;
            this->lighting.ambientScene.b = this->lighting.ambientSceneScaled.b * SCALE;
            this->lighting.ambient_save  = value;
            this->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_FRONTEND_DIRTY;
            break;
        }
    case D3DRENDERSTATE_RANGEFOGENABLE:
        if (value)
            this->dwDeviceFlags |= D3DDEV_RANGEBASEDFOG;
        else
            this->dwDeviceFlags &= ~D3DDEV_RANGEBASEDFOG;
        break;
    case D3DRENDERSTATE_FOGVERTEXMODE:
        this->lighting.fog_mode = (D3DFOGMODE)value;
        SetFogFlags();
        break;
    case D3DRENDERSTATE_COLORVERTEX:
        if (value)
            this->dwDeviceFlags |= D3DDEV_COLORVERTEX;
        else
            this->dwDeviceFlags &= ~D3DDEV_COLORVERTEX;
        // Just to make it not take the FE fast path and call DoUpdateState()
        // This is necessary since we update lighting.alpha and
        // lighting.alphaSpecular in DoUpdateState.
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_CLIPPING:
        if (!value)
        {
            this->dwDeviceFlags |= D3DDEV_DONOTCLIP;
            // Clear clip union and intersection flags
            this->dwClipIntersection = 0;
            this->dwClipUnion = 0;
        }
        else
            this->dwDeviceFlags &= ~D3DDEV_DONOTCLIP;
        // This does not really require a "FVF" recompute,
        // but is a convenient way of switching back from
        // the fast path for DrawPrimitiveTL.
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_EXTENTS:
        if (!value)
            this->dwDeviceFlags |= D3DDEV_DONOTUPDATEEXTENTS;
        else
            this->dwDeviceFlags &= ~D3DDEV_DONOTUPDATEEXTENTS;
        // This does not really require a "FVF" recompute,
        // but is a convenient way of switching back from
        // the fast path for DrawPrimitiveTL.
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_FOGDENSITY:
        this->lighting.fog_density = *(D3DVALUE*)&value;
        break;
    case D3DRENDERSTATE_FOGSTART:
        this->lighting.fog_start = *(D3DVALUE*)&value;
        UpdateFogFactor(this);
        break;
    case D3DRENDERSTATE_FOGEND:
        this->lighting.fog_end = *(D3DVALUE*)&value;
        UpdateFogFactor(this);
        break;
    case D3DRENDERSTATE_LOCALVIEWER:
        if (value)
            this->dwDeviceFlags |= D3DDEV_LOCALVIEWER;
        else
            this->dwDeviceFlags &= ~D3DDEV_LOCALVIEWER;
        this->dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DRENDERSTATE_NORMALIZENORMALS:
        if (value)
        {
            if (this->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)
            {
                this->dwDeviceFlags &= ~D3DDEV_MODELSPACELIGHTING;
                this->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
            }
            this->dwDeviceFlags |= D3DDEV_NORMALIZENORMALS;
        }
        else
        {
            this->dwDeviceFlags &= ~D3DDEV_NORMALIZENORMALS;
            if (!(this->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                this->dwFEFlags |= D3DFE_NEEDCHECKWORLDVIEWVMATRIX | D3DFE_FRONTEND_DIRTY;
        }
        break;
    case D3DRENDERSTATE_EMISSIVEMATERIALSOURCE:
        this->lighting.dwEmissiveSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            this->lighting.dwEmissiveSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            this->lighting.dwEmissiveSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for DIFFUSEMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_DIFFUSEMATERIALSOURCE:
        this->lighting.dwDiffuseSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            this->lighting.dwDiffuseSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            this->lighting.dwDiffuseSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for DIFFUSEMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_AMBIENTMATERIALSOURCE:
        this->lighting.dwAmbientSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            this->lighting.dwAmbientSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            this->lighting.dwAmbientSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for AMBIENTMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_SPECULARMATERIALSOURCE:
        this->lighting.dwSpecularSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            this->lighting.dwSpecularSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            this->lighting.dwSpecularSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for SPECULARMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_VERTEXBLEND:
    {
        DWORD numBlendMatrices;

        switch (value)
        {
        case D3DVBLEND_DISABLE:
            numBlendMatrices = 0;
            break;
        case D3DVBLEND_1WEIGHT:
            numBlendMatrices = 2;
            break;
        case D3DVBLEND_2WEIGHTS:
            numBlendMatrices = 3;
            break;
        case D3DVBLEND_3WEIGHTS:
            numBlendMatrices = 4;
            break;
#if DBG
        default:
            D3D_ERR("Illegal value for D3DRENDERSTATE_VERTEXBLEND");
            goto error_exit;
#endif
        }
        this->dwFEFlags |= D3DFE_VERTEXBLEND_DIRTY | D3DFE_FRONTEND_DIRTY;
    }
    break;
    case D3DRENDERSTATE_CLIPPLANEENABLE:
        {
            this->dwFEFlags |= D3DFE_CLIPPLANES_DIRTY | D3DFE_FRONTEND_DIRTY;
            this->dwMaxUserClipPlanes = 0;
            break;
        }
    case D3DRENDERSTATE_SHADEMODE:
        rstates[type] = value;  // SetInterpolationFlags depends on the rstates
        SetInterpolationFlags(this);
        break;

    default:
        // WRAP render states could be re-mapped so we have to restore them before
        // setting a new value
        if (type >= D3DRENDERSTATE_WRAP0 &&  type <= D3DRENDERSTATE_WRAP7)
        {
            if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
            {
                RestoreTextureStages(this);
                ForceFVFRecompute();
            }
        }
        break;
    }
    rstates[type] = value;      // set rstates for all other cases
    return;

#if DBG
error_exit:
    throw DDERR_INVALIDPARAMS;
#endif
}
//---------------------------------------------------------------------
#if DBG
static  char ProfileStr[PROF_DRAWINDEXEDPRIMITIVEVB+1][32]=
{
    "Execute",
    "Begin",
    "BeginIndexed",
    "DrawPrimitive(Device2)",
    "DrawIndexedPrimitive(Device2)",
    "DrawPrimitiveStrided",
    "DrawIndexedPrimitiveStrided",
    "DrawPrimitive(Device7)",
    "DrawIndexedPrimitive(Device7)",
    "DrawPrimitiveVB",
    "DrawIndexedPrimitiveVB",
};
static  char PrimitiveStr[D3DPT_TRIANGLEFAN][16]=
{
    "POINTLIST",
    "LINELIST",
    "LINESTRIP",
    "TRIANGLELIST",
    "TRIANGLESTRIP",
    "TRIANGLEFAN",
};
static  char VertexStr[D3DVT_TLVERTEX][16]=
{
    "D3DVERTEX",
    "D3DLVERTEX",
    "D3DTLVERTEX",
};
#define PROFILE_LEVEL 0

void    DIRECT3DDEVICEI::Profile(DWORD caller, D3DPRIMITIVETYPE dwPrimitive, DWORD dwVertex)
{
    DWORD   bitwisecaller= 1 << caller;
    DWORD   bitwisePrimitive = 1 << (DWORD)dwPrimitive;
    DWORD   bitwiseVertex1 = 1 << (dwVertex & 0x001F);
    DWORD   bitwiseVertex2 = 1 << ((dwVertex & 0x03E0) >> 5);
    char    str[256];
    DDASSERT(PROF_DRAWINDEXEDPRIMITIVEVB >= caller);
    DDASSERT(D3DPT_TRIANGLEFAN >= dwPrimitive && D3DPT_POINTLIST<= dwPrimitive);
    if (dwCaller & bitwisecaller)
    {
        if (dwPrimitiveType[caller] & bitwisePrimitive)
        {
            if ((dwVertexType1[caller] & bitwiseVertex1) &&
                (dwVertexType2[caller] & bitwiseVertex2))
            {
                return; //matching a previous api call, no spew, could count stat though
            }
            else
            {
                dwVertexType1[caller] |= bitwiseVertex1;
                dwVertexType2[caller] |= bitwiseVertex2;
            }
        }
        else
        {
            dwPrimitiveType[caller] |= bitwisePrimitive;
            dwVertexType1[caller] |= bitwiseVertex1;
            dwVertexType2[caller] |= bitwiseVertex2;
        }
    }
    else
    {
        this->dwCaller |= bitwisecaller;
        dwPrimitiveType[caller] |= bitwisePrimitive;
        dwVertexType1[caller] |= bitwiseVertex1;
        dwVertexType2[caller] |= bitwiseVertex2;
    }
    wsprintf( (LPSTR) str, ProfileStr[caller]);
    strcat(str,":");
    strcat(str,PrimitiveStr[dwPrimitive-1]);
    if (dwVertex > D3DVT_TLVERTEX)
    {
        if (dwVertex == D3DFVF_VERTEX)
        {
            dwVertex = D3DVT_VERTEX;
        }
        else
        if (dwVertex == D3DFVF_LVERTEX)
        {
            dwVertex = D3DVT_LVERTEX;
        }
        else
        if (dwVertex == D3DFVF_TLVERTEX)
        {
            dwVertex = D3DVT_TLVERTEX;
        }
        else
        {
            D3D_INFO(PROFILE_LEVEL,"Profile:%s FVFType=%08lx",str,dwVertex);
            return;
        }
    }
    else
    {
        DDASSERT(dwVertex >= D3DVT_VERTEX);
    }
    strcat(str,":");
    strcat(str,VertexStr[dwVertex-1]);
    D3D_INFO(PROFILE_LEVEL,"Profile:%s",str);
}

#endif // DBG
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::MultiplyTransform"

//    MultiplyTransform -- this preconcatenates the new matrix to the specified
//    transform matrix
//
//        this really screams for overloaded matrix ops...
//
HRESULT D3DAPI
DIRECT3DDEVICEI::MultiplyTransform(D3DTRANSFORMSTATETYPE dtsTransformState, LPD3DMATRIX lpMat)
{
#if DBG
    if (!VALID_D3DMATRIX_PTR(lpMat))
    {
        D3D_ERR( "Invalid matrix pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
        D3DMATRIXI mResult;
        switch (dtsTransformState)
        {
        case D3DTRANSFORMSTATE_WORLD      :
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.world[0]);
            break;
        case D3DTRANSFORMSTATE_WORLD1     :
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.world[1]);
            break;
        case D3DTRANSFORMSTATE_WORLD2     :
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.world[2]);
            break;
        case D3DTRANSFORMSTATE_WORLD3     :
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.world[3]);
            break;
        case D3DTRANSFORMSTATE_VIEW       :
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.view);
            break;
        case D3DTRANSFORMSTATE_PROJECTION :
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.proj);
            break;
        case D3DTRANSFORMSTATE_TEXTURE0:
        case D3DTRANSFORMSTATE_TEXTURE1:
        case D3DTRANSFORMSTATE_TEXTURE2:
        case D3DTRANSFORMSTATE_TEXTURE3:
        case D3DTRANSFORMSTATE_TEXTURE4:
        case D3DTRANSFORMSTATE_TEXTURE5:
        case D3DTRANSFORMSTATE_TEXTURE6:
        case D3DTRANSFORMSTATE_TEXTURE7:
            {
                DWORD dwIndex = dtsTransformState - D3DTRANSFORMSTATE_TEXTURE0;
                MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->mTexture[dwIndex]);
                break;
            }
        default :
            D3D_ERR( "Invalid state value passed to MultiplyTransform" );
            return DDERR_INVALIDPARAMS; /* Work Item: Generate new meaningful return code */
        }
        SetTransformI(dtsTransformState, (D3DMATRIX*)&mResult);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::BeginStateBlock"

HRESULT D3DAPI DIRECT3DDEVICEI::BeginStateBlock()
{
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            D3D_ERR("Already in the state record mode");
            return D3DERR_INBEGINSTATEBLOCK;
        }
        if (m_pStateSets->StartNewSet() != D3D_OK)
            return DDERR_OUTOFMEMORY;

        this->dwFEFlags |= D3DFE_RECORDSTATEMODE;
#ifdef VTABLE_HACK
        VtblSetRenderStateRecord();
        VtblSetTextureStageStateRecord();
        VtblSetTextureRecord();
        VtblApplyStateBlockRecord();
#endif VTABLE_HACK
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::EndStateBlock"

HRESULT D3DAPI DIRECT3DDEVICEI::EndStateBlock(LPDWORD pdwHandle)
{
    if (!VALID_PTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer" );
        return DDERR_INVALIDPARAMS;
    }
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

        if (!(this->dwFEFlags & D3DFE_RECORDSTATEMODE))
        {
            D3D_ERR("Not in state record mode");
            return D3DERR_NOTINBEGINSTATEBLOCK;
        }
        this->dwFEFlags &= ~D3DFE_RECORDSTATEMODE;
        m_pStateSets->EndSet();
#ifdef VTABLE_HACK
        if (IS_DP2HAL_DEVICE(this) && (!IS_MT_DEVICE(this)))
        {
            VtblSetRenderStateExecute();
            VtblSetTextureStageStateExecute();
            VtblSetTextureExecute();
            VtblApplyStateBlockExecute();
        }
#endif VTABLE_HACK
        this->WriteStateSetToDevice((D3DSTATEBLOCKTYPE)0);
        *pdwHandle = m_pStateSets->GetCurrentHandle();
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        m_pStateSets->Cleanup(m_pStateSets->GetCurrentHandle());
        *pdwHandle = 0xFFFFFFFF;
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DeleteStateBlock"

HRESULT D3DAPI DIRECT3DDEVICEI::DeleteStateBlock(DWORD dwHandle)
{
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            D3D_ERR("We are in state record mode");
            return D3DERR_INBEGINSTATEBLOCK;
        }
        m_pStateSets->DeleteStateSet(this, dwHandle);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::ApplyStateBlock"

HRESULT D3DAPI DIRECT3DDEVICEI::ApplyStateBlock(DWORD dwHandle)
{
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            D3D_ERR("We are in state record mode");
            return D3DERR_INBEGINSTATEBLOCK;
        }
        return ApplyStateBlockInternal(dwHandle);
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::ApplyStateBlockInternal"

HRESULT D3DAPI DIRECT3DDEVICEI::ApplyStateBlockInternal(DWORD dwHandle)
{
    try
    {
        m_pStateSets->Execute(this, dwHandle);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::CaptureStateBlock"

HRESULT D3DAPI DIRECT3DDEVICEI::CaptureStateBlock(DWORD dwHandle)
{
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            D3D_ERR("Cannot capture when in the state record mode");
            return D3DERR_INBEGINSTATEBLOCK;
        }
        m_pStateSets->Capture(this, dwHandle);
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::CreateStateBlock"

HRESULT D3DAPI DIRECT3DDEVICEI::CreateStateBlock(D3DSTATEBLOCKTYPE sbt, LPDWORD pdwHandle)
{
    if (!VALID_PTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer" );
        return DDERR_INVALIDPARAMS;
    }
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            D3D_ERR("Cannot create state block when in the state record mode");
            return D3DERR_INBEGINSTATEBLOCK;
        }
        if (m_pStateSets->StartNewSet() != D3D_OK)
            return DDERR_OUTOFMEMORY;
        m_pStateSets->CreatePredefined(this, sbt);
        m_pStateSets->EndSet();
        this->WriteStateSetToDevice(sbt);
        *pdwHandle = m_pStateSets->GetCurrentHandle();
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        m_pStateSets->Cleanup(m_pStateSets->GetCurrentHandle());
        *pdwHandle = 0xFFFFFFFF;
        return ret;
    }
}
//---------------------------------------------------------------------
// Input:
//    type      - FVF control dword
//
// Returns D3D_OK, if the control dword is valid.
// DDERR_INVALIDPARAMS otherwise
//
#undef  DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::ValidateFVF"

HRESULT DIRECT3DDEVICEI::ValidateFVF(DWORD type)
{
    DWORD dwTexCoord = FVF_TEXCOORD_NUMBER(type);
    DWORD vertexType = type & D3DFVF_POSITION_MASK;
    // Texture format bits above texture count should be zero
    // Reserved field 0 and 2 should be 0
    // Reserved 1 should be set only for LVERTEX
    // Only two vertex position types allowed
    if (type & g_TextureFormatMask[dwTexCoord])
    {
        D3D_ERR("FVF has incorrect texture format");
        goto error;
    }
    if (type & 0xFFFF0000 && vertexType == D3DFVF_XYZRHW &&
        this->deviceType < D3DDEVTYPE_DX7HAL)
    {
        D3D_ERR("The D3D device supports only two floats per texture coordinate set");
        goto error;
    }
    if (type & (D3DFVF_RESERVED2 | D3DFVF_RESERVED0) ||
        (type & D3DFVF_RESERVED1 && !(type & D3DFVF_LVERTEX)))
    {
        D3D_ERR("FVF has reserved bit(s) set");
        goto error;
    }
    if (!(vertexType == D3DFVF_XYZRHW ||
          vertexType == D3DFVF_XYZ ||
          vertexType == D3DFVF_XYZB1 ||
          vertexType == D3DFVF_XYZB2 ||
          vertexType == D3DFVF_XYZB3 ||
          vertexType == D3DFVF_XYZB4 ||
          vertexType == D3DFVF_XYZB5))
    {
        D3D_ERR("FVF has incorrect position type");
        goto error;
    }

    if (vertexType == D3DFVF_XYZRHW && type & D3DFVF_NORMAL)
    {
        D3D_ERR("Normal should not be used with XYZRHW position type");
        goto error;
    }
    return D3D_OK;
error:
    D3D_ERR("ValidateFVF() returns DDERR_INVALIDPARAMS");
    return DDERR_INVALIDPARAMS;
}
//---------------------------------------------------------------------
// The function should bot be called by ProcessVertices.
// Computes nOutTexCoord and dwTextureIndexToCopy in case when a pre-DX6
// driver is used.
//
void ComputeTCI2CopyLegacy(LPDIRECT3DDEVICEI lpDevI,
                           DWORD  dwNumInpTexCoord,
                           DWORD* pdwInpTexCoordSize,
                           BOOL bVertexTransformed)
{
    lpDevI->dwTextureIndexToCopy = 0;
    lpDevI->nOutTexCoord = 0;
    lpDevI->dwTextureCoordSizeTotal = 0;
    lpDevI->dwTextureCoordSize[0] = 0;

    // If texture is enabled we care about texture gen mode and the texture
    // index to copy
    if (lpDevI->tsstates[0][D3DTSS_COLOROP] != D3DTOP_DISABLE)
    {
        DWORD dwTexIndex = lpDevI->tsstates[0][D3DTSS_TEXCOORDINDEX];
        DWORD dwTexGenMode = dwTexIndex & ~0xFFFF;
        dwTexIndex &= 0xFFFF;
        if (bVertexTransformed)
        {
            lpDevI->dwTextureIndexToCopy = dwTexIndex;
            // In case of clipping we need to clip as many texture
            // coordinates as set in the texture stage state.
            lpDevI->nOutTexCoord = min(dwNumInpTexCoord, lpDevI->dwTextureIndexToCopy+1);
            for (DWORD i=0; i < lpDevI->nOutTexCoord; i++)
            {
                lpDevI->dwTextureCoordSizeTotal += pdwInpTexCoordSize[i];
                lpDevI->dwTextureCoordSize[i] = pdwInpTexCoordSize[i];
            }
        }
        else
        if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
        {
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
                lpDevI->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE | D3DDEV_POSITIONINCAMERASPACE;
            else
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL)
                lpDevI->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE;
            else
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION)
                lpDevI->dwDeviceFlags |= D3DDEV_POSITIONINCAMERASPACE;
            lpDevI->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            LPD3DFE_TEXTURESTAGE pStage = &lpDevI->textureStage[0];
            pStage->dwInpCoordIndex = 0;
            pStage->dwTexGenMode = dwTexGenMode;
            pStage->dwOrgStage = 0;
            pStage->dwInpOffset = 0;
            pStage->dwOutCoordIndex = 0;
            if (lpDevI->dwFlags2 & __FLAGS2_TEXTRANSFORM0)
            {
                pStage->pmTextureTransform = &lpDevI->mTexture[0];
                pStage->dwTexTransformFuncIndex = MakeTexTransformFuncIndex(3, 2);
            }
            else
            {
                pStage->pmTextureTransform = NULL;
            }
            pStage->dwOrgWrapMode = lpDevI->rstates[D3DRENDERSTATE_WRAP0];
            // Texture index is used as an index to the new WRAP mode
            DWORD dwNewWrapMode = lpDevI->rstates[D3DRENDERSTATE_WRAP0 + dwTexIndex];
            if (dwNewWrapMode != pStage->dwOrgWrapMode)
            {
                lpDevI->rstates[D3DRENDERSTATE_WRAP0] = dwNewWrapMode;
                lpDevI->SetRenderStateI(D3DRENDERSTATE_WRAP0, dwNewWrapMode);
            }
            lpDevI->nOutTexCoord = 1;
            lpDevI->dwNumTextureStages = 1;
            lpDevI->dwTextureCoordSizeTotal = 8;
            lpDevI->dwTextureCoordSize[0] = 8;
        }
        else
        if (dwNumInpTexCoord != 0)
        {
            lpDevI->nOutTexCoord = 1;
            lpDevI->dwTextureIndexToCopy = dwTexIndex;
            lpDevI->dwTextureCoordSizeTotal = 8;
            lpDevI->dwTextureCoordSize[0] = 8;
        }
    }
}
//---------------------------------------------------------------------
// Computes output FVF id, based on input FVF id and device settingd
// Also computes nTexCoord field
// Number of texture coordinates is set based on dwVIDIn. ValidateFVF sould
// make sure that it is not greater than supported by the driver
// Last settings for dwVIDOut and dwVIDIn are saved to speed up processing
//
#undef  DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetupFVFData"

HRESULT DIRECT3DDEVICEI::SetupFVFData(DWORD *pdwInpVertexSize)
{
    // We have to restore texture stage indices if previous primitive
    // re-mapped them
    if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(this);
    }

    this->dwFEFlags &= ~D3DFE_FVF_DIRTY;
    this->nTexCoord = FVF_TEXCOORD_NUMBER(this->dwVIDIn);

    DWORD dwInpTexSizeTotal = ComputeTextureCoordSize(this->dwVIDIn, this->dwInpTextureCoordSize);
    // Compute size of dwVIDIn
    DWORD dwInpVertexSize = GetVertexSizeFVF(this->dwVIDIn) + dwInpTexSizeTotal;
    if (pdwInpVertexSize)
    {
        *pdwInpVertexSize = dwInpVertexSize;
    }

    // Compute how many texture coordinates to copy
    ComputeTCI2CopyLegacy(this, this->nTexCoord, this->dwInpTextureCoordSize,
                          FVF_TRANSFORMED(this->dwVIDIn));

    if (FVF_TRANSFORMED(this->dwVIDIn))
    {
        this->dwVIDOut = this->dwVIDIn;
        ComputeOutputVertexOffsets(this);
        this->dwOutputSize = dwInpVertexSize;
        return D3D_OK;
    }
    else
    {
        this->dwVIDOut = D3DFVF_TLVERTEX;
        this->dwOutputSize = sizeof(D3DTLVERTEX);
    }

    if (!(this->dwFlags & D3DPV_VBCALL))
        UpdateGeometryLoopData(this);

    this->dwDeviceFlags &= ~D3DDEV_TEXTURETRANSFORM;
    // Stage 0 bit is used for the texture transform
    if (this->dwFlags2 & __FLAGS2_TEXTRANSFORM0)
    {
        this->pmTexture[0] = &this->mTexture[0];
        this->dwDeviceFlags |= D3DDEV_TEXTURETRANSFORM;
        if ((this->tsstates[0][D3DTSS_TEXTURETRANSFORMFLAGS] & 0xFF) != 2)
        {
            D3D_ERR("The texture transform for the device should use 2 floats");
            return DDERR_INVALIDPARAMS;
        }
    }
    else
    if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        D3D_ERR("Cannot use texture generation without texture transform for pre-DX6 device");
        return DDERR_INVALIDPARAMS;
    }


    // In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden
    // by vertex alpha
    this->lighting.alpha = (DWORD)this->lighting.materialAlpha;
    this->lighting.alphaSpecular = (DWORD)this->lighting.materialAlphaS;

    return D3D_OK;
}
//---------------------------------------------------------------------
// Returns TRUE, if driver state should not be updated
//
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::UpdateInternalTextureStageState"

BOOL DIRECT3DDEVICEI::UpdateInternalTextureStageState
        (DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue)
{
    BOOL ret = FALSE; // return TRUE if TSS should NOT be batched
    if(dwState == D3DTSS_COLOROP)
    {
        if(dwValue == D3DTOP_DISABLE || tsstates[dwStage][D3DTSS_COLOROP] == D3DTOP_DISABLE)
            ForceFVFRecompute();
    }
    else
    if (dwState == D3DTSS_TEXCOORDINDEX)
    {
        if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            RestoreTextureStages(this);
            ForceFVFRecompute();
        }
        else
        if (TextureTransformEnabled(this))
        {
            // Force re-compute if a texture transfrom is enabled
            ForceFVFRecompute();
        }
        DWORD dwTexGenMode = 0;
        if (dwValue >= D3DDP_MAXTEXCOORD)
        {
            dwTexGenMode = dwValue & ~0xFFFF;
            if(!IS_TLHAL_DEVICE(this))
                ret = TRUE;
#if DBG
            DWORD dwTexIndex   = dwValue & 0xFFFF;
            if (!(dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
                  dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
                  dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR) ||
                  dwTexIndex > D3DDP_MAXTEXCOORD)
            {
                D3D_ERR("Incorrect texture coordinate set index");
                throw DDERR_INVALIDPARAMS;
            }
#endif
        }
        DWORD dwTexGenBit = 0;
        if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
        {
            dwTexGenBit = __FLAGS2_TEXGEN0 << dwStage;   // To set internal "enable" dword
        }
        // Force to re-compute FVF only if enable state is changed
        if ((this->dwFlags2 & dwTexGenBit) != dwTexGenBit)
        {
            ForceFVFRecompute();
            this->dwFlags2 = (this->dwFlags2 & ~dwTexGenBit) | dwTexGenBit;
            this->dwDeviceFlags &= ~(D3DDEV_POSITIONINCAMERASPACE | D3DDEV_NORMALINCAMERASPACE);
        }
        if (!(this->dwDeviceFlags & D3DDEV_FVF))
        {
            ForceFVFRecompute();
            if (dwValue != 0)
                ret = TRUE;
        }
    }
    else
    if (dwState == D3DTSS_TEXTURETRANSFORMFLAGS)
    {
        DWORD dwEnableBit = 1 << dwStage;   // To check internal "enable" dword
        // Force to re-compute FVF only if enable state is changed
        if (dwValue == D3DTTFF_DISABLE)
        {
            if (this->dwFlags2 & dwEnableBit)
            {
                ForceFVFRecompute();
                this->dwFlags2 &= ~dwEnableBit;
            }
        }
        else
        {
            if (!(this->dwFlags2 & dwEnableBit))
            {
                ForceFVFRecompute();
                this->dwFlags2 |= dwEnableBit;
            }
        }
        if(this->deviceType == D3DDEVTYPE_DP2HAL)
            ret = TRUE;
    }
    else if(dwState > D3DTSS_TEXTURETRANSFORMFLAGS)
    {
        if(this->deviceType == D3DDEVTYPE_DP2HAL)
            ret = TRUE;
    }
    // Update runtime copy of state.
    tsstates[dwStage][dwState] = dwValue;
    return ret;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetClipPlaneI"

void DIRECT3DDEVICEI::SetClipPlaneI(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
    D3DVALUE *p = &this->transform.userClipPlane[dwPlaneIndex].x;
    p[0] = pPlaneEquation[0];
    p[1] = pPlaneEquation[1];
    p[2] = pPlaneEquation[2];
    p[3] = pPlaneEquation[3];
    this->dwFEFlags |= D3DFE_CLIPPLANES_DIRTY | D3DFE_FRONTEND_DIRTY;
    this->dwMaxUserClipPlanes = 0;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetClipPlane"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
#if DBG
    if (dwPlaneIndex >= max(this->transform.dwMaxUserClipPlanes, __MAXUSERCLIPPLANES))
    {
        D3D_ERR("Plane index is too big");
        return DDERR_INVALIDPARAMS;
    }
    if (!VALID_PTR(pPlaneEquation, sizeof(D3DVALUE)*4))
    {
        D3D_ERR( "Invalid plane pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            m_pStateSets->InsertClipPlane(dwPlaneIndex, pPlaneEquation);
        else
            SetClipPlaneI(dwPlaneIndex, pPlaneEquation);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetClipPlane"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
#if DBG
    if (dwPlaneIndex >= max(this->transform.dwMaxUserClipPlanes, __MAXUSERCLIPPLANES))
    {
        D3D_ERR("Plane index is too big");
        return DDERR_INVALIDPARAMS;
    }
    if (!VALID_PTR(pPlaneEquation, sizeof(D3DVALUE)*4))
    {
        D3D_ERR( "Invalid plane pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        D3DVALUE *p = &this->transform.userClipPlane[dwPlaneIndex].x;
        pPlaneEquation[0] = p[0];
        pPlaneEquation[1] = p[1];
        pPlaneEquation[2] = p[2];
        pPlaneEquation[3] = p[3];
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\dlld3d.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   dlld3d.cpp
 *  Content:    Direct3D startup
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *   21/11/95   colinmc Added Direct3D interface ID.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *   02/03/96   colinmc Minor build fix.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Define the Direct3D IIDs.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D Startup"

DPF_DECLARE(Direct3D);

#ifdef WIN95
LPVOID lpWin16Lock;
#endif

DWORD dwD3DTriBatchSize, dwTriBatchSize, dwLineBatchSize;
DWORD dwHWBufferSize, dwHWMaxTris, dwHWFewVertices;
HINSTANCE hGeometryDLL;
LPD3DFE_CONTEXTCREATE pfnFEContextCreate;
char szCPUString[13];

DWORD dwCPUFamily, dwCPUFeatures;

#ifdef _X86_
extern BOOL isX3Dprocessor(void);
#endif

void SetMostRecentApp(void);

#ifndef WIN95 // and Win98, WinME
//---------------------------------------------------------------------

BOOL bVBSwapEnabled = TRUE, bVBSwapWorkaround = FALSE;

void SetVBSwapStatus(void)
{
    OSVERSIONINFOEX osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx((LPOSVERSIONINFO)&osvi))
    {
        D3D_INFO(1,"GetVersionEx failed - turning off VB swapping");
        bVBSwapEnabled = FALSE;
        return;
    }

    if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) // Check if Win2K Gold (2195)
        {
            if (osvi.wServicePackMajor == 0) // No service pack
            {
                D3D_INFO(1, "Win2K Gold detected - turning off VB swapping");
                bVBSwapEnabled = FALSE;
            }
            else
            {
                D3D_INFO(1, "Win2K SP1 or above detected - enabling VB swap workaround");
                bVBSwapEnabled = FALSE;
                bVBSwapWorkaround = TRUE;
            }
        }
        else // Whistler and above
        {
            /* ASSUMPTION: NO WORKAROUND NEEDED */
        }
    }
    else
    {
        // Should never get here
        DPF_ERR("OS Detection failed - turning off VB swapping");
        bVBSwapEnabled = FALSE;
        return;
    }
}
#endif // WIN95


#ifdef _X86_
// --------------------------------------------------------------------------
// Here's a routine helps us determine if we should try MMX or not
// --------------------------------------------------------------------------
BOOL _asm_isMMX()
{
    DWORD retval;
    _asm
        {
            xor         eax,eax         ; Clear out eax for return value
            pushad              ; CPUID trashes lots - save everything
            mov     eax,1           ; Check for MMX support

            ;;; We need to upgrade our compiler
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            test    edx,00800000h   ; Set flags before restoring registers

            popad               ; Restore everything

            setnz    al             ; Set return value
            mov     retval, eax
        };
    return retval;
}
#endif

static int isMMX = -1;

BOOL
isMMXprocessor(void)
{
    HKEY hKey;
    if ( RegOpenKey( HKEY_LOCAL_MACHINE,
                     RESPATH_D3D,
                     &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
        if ( RegQueryValueEx( hKey, "DisableMMX", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) == ERROR_SUCCESS &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            RegCloseKey( hKey );
            isMMX = 0;
            return FALSE;
        }
        RegCloseKey( hKey );
    }

    if (isMMX < 0)
    {
        isMMX = FALSE;
#ifdef _X86_
        D3D_WARN(0, "Executing processor detection code (benign first-chance exception possible)" );
#ifndef WIN95
        {
            // GetSystemInfo is not broken on WinNT.
            SYSTEM_INFO si;

            GetSystemInfo(&si);
            if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
                si.wProcessorLevel >= 5)
            {
#endif
                __try
                    {
                        if( _asm_isMMX() )
                        {

                            // Emit an emms instruction.
                            // This file needs to compile for non-Pentium
                            // processors
                            // so we can't use use inline asm since we're in the
                            // wrong
                            // processor mode.
                            __asm __emit 0xf;
                            __asm __emit 0x77;
                            isMMX = TRUE;
                            D3D_INFO(0, "MMX detected");
                        }
                    }
                __except(GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION ?
                         EXCEPTION_EXECUTE_HANDLER :
                         EXCEPTION_CONTINUE_SEARCH)
                    {
                    }
#ifndef WIN95
            }

        }
#endif
#endif
    }
    return isMMX;
}

#ifdef _X86_

//---------------------------------------------------------------------
// Detects Intel SSE processor
//
#pragma optimize("", off)
#define CPUID _asm _emit 0x0f _asm _emit 0xa2

#define SSE_PRESENT 0x02000000                  // bit number 25
#define WNI_PRESENT 0x04000000                  // bit number 26

DWORD IsIntelSSEProcessor(void)
{
        DWORD retval = 0;
        DWORD RegisterEAX;
        DWORD RegisterEDX;
        char VendorId[12];

        __try
        {
                _asm {
            xor         eax,eax
            CPUID
                mov             RegisterEAX, eax
                mov             dword ptr VendorId, ebx
                mov             dword ptr VendorId+4, edx
                mov             dword ptr VendorId+8, ecx
                }
        } __except (1)
        {
                return retval;
        }

        // make sure EAX is > 0 which means the chip
        // supports a value >=1. 1 = chip info
        if (RegisterEAX == 0)
                return retval;

        // this CPUID can't fail if the above test passed
        __asm {
                mov eax,1
                CPUID
                mov RegisterEAX,eax
                mov RegisterEDX,edx
        }

        if (RegisterEDX  & SSE_PRESENT) {
                retval |= D3DCPU_SSE;
        }

        if (RegisterEDX  & WNI_PRESENT) {
                retval |= D3DCPU_WLMT;
        }

        return retval;
}

#pragma optimize("", on)

#ifdef WIN95 // and Win98...
//---------------------------------------------------------------------
BOOL
IsWin95(void)
{
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        D3D_INFO(1,"GetVersionEx failed - assuming Win95");
        return TRUE;
    }

    if ( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {

        if( ( osvi.dwMajorVersion > 4UL ) ||
            ( ( osvi.dwMajorVersion == 4UL ) &&
              ( osvi.dwMinorVersion >= 10UL ) &&
              ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
        {
            // is Win98
            D3D_INFO(2,"Detected Win98");
            return FALSE;
        }
        else
        {
            // is Win95
            D3D_INFO(2,"Detected Win95");
            return TRUE;
        }
    }
    else if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        D3D_INFO(2,"Detected WinNT");
        return FALSE;
    }
    D3D_INFO(2,"OS Detection failed");
    return TRUE;
}
#endif  // WIN95

//---------------------------------------------------------------------
//
//  void GetProcessorFamily(LPDWORD lpdwFamily);
//
//      Passes back 3, 4, 5, 6 for 386, 486, Pentium, PPro class machines
//
#pragma optimize("", off)
void
GetProcessorFamily(LPDWORD lpdwFamily, LPDWORD lpdwCPUFeatures)
{
    SYSTEM_INFO si;
    __int64     start, end, freq;
    int         flags,family;
    int         time;
    int         clocks;
    DWORD       oldclass;
    HANDLE      hprocess;

    // guilty until proven otherwise
    *lpdwCPUFeatures = D3DCPU_BLOCKINGREAD;

    if ( isMMXprocessor() )
    {
        *lpdwCPUFeatures |= D3DCPU_MMX;
    }

    ZeroMemory(&si, sizeof(si));
    GetSystemInfo(&si);

    //Set the family. If wProcessorLevel is not specified, dig it out of dwProcessorType
    //Because wProcessor level is not implemented on Win95
    if (si.wProcessorLevel)
    {
        *lpdwFamily=si.wProcessorLevel;
    }
    else
    {
        //Ok, we're on Win95
        switch (si.dwProcessorType)
        {
            case PROCESSOR_INTEL_386:
                *lpdwFamily=3;
                break;

            case PROCESSOR_INTEL_486:
                *lpdwFamily=4;
                break;
            default:
                *lpdwFamily=0;
                break;
        }
    }

    //
    // make sure this is a INTEL Pentium (or clone) or higher.
    //
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
        return;

    if (si.dwProcessorType < PROCESSOR_INTEL_PENTIUM)
        return;

    //
    // see if this chip supports rdtsc before using it.
    //
    __try
    {
        _asm
        {
            xor     eax,eax
            _emit   00fh    ;; CPUID
            _emit   0a2h
            mov     dword ptr szCPUString,ebx
            mov     dword ptr szCPUString+8,ecx
            mov     dword ptr szCPUString+4,edx
            mov     byte ptr szCPUString+12,0
            mov     eax,1
            _emit   00Fh     ;; CPUID
            _emit   0A2h
            mov     flags,edx
            mov     family,eax
        }
    }
    __except(1)
    {
        flags = 0;
    }

    //check for support of CPUID and fail
    if (!(flags & 0x10))
        return;

    // fcomi and FPU features both set
    if ( (flags&(1<<15)) && (flags & (1<<0)) )
    {
        D3D_INFO(2, "Pentium Pro CPU features (fcomi, cmov) detected");
        *lpdwCPUFeatures |= D3DCPU_FCOMICMOV;
    }

    //If we don't have a family, set it now
    //Family is bits 11:8 of eax from CPU, with eax=1
    if (!(*lpdwFamily))
    {
       *lpdwFamily=(family& 0x0F00) >> 8;
    }
    // not aware of any non-Intel processors w/non blocking reads
    if ( (! strcmp(szCPUString, "GenuineIntel")) &&
         *lpdwFamily > 5)
    {
        *lpdwCPUFeatures &= ~D3DCPU_BLOCKINGREAD;
    }

    if ( isX3Dprocessor() )
    {
        D3D_INFO(2, "X3D Processor detected for PSGP");
        *lpdwCPUFeatures |= D3DCPU_X3D;
    }

    DWORD retval = IsIntelSSEProcessor();
    if (retval & D3DCPU_SSE)
    {
        D3D_INFO(2, "Streaming SIMD Extensions detected for PSGP");
        *lpdwCPUFeatures |= D3DCPU_SSE;
    }
    if (retval & D3DCPU_WLMT)
    {
        D3D_INFO(2, "Streaming SIMD Extensions 2 detected for PSGP");
        *lpdwCPUFeatures |= D3DCPU_WLMT;
    }

    return;
}
#pragma optimize("", on)

#endif // _X86_

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwType, dwSize = sizeof(dwHWFewVertices);
    char filename[_MAX_PATH];

    switch( ul_reason_for_call ) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls( hModule );
        DPFINIT();
        MemInit();
#ifdef WIN95
        GetpWin16Lock(&lpWin16Lock);
#endif

#ifdef _X86_
        GetProcessorFamily(&dwCPUFamily, &dwCPUFeatures);
        D3D_INFO(3, "dwCPUFamily = %d, dwCPUFeatures = %d", dwCPUFamily, dwCPUFeatures);
        D3D_INFO(3, "szCPUString = %s", szCPUString);
#endif

#ifdef WIN95 // and Win98...
    // SSE (aka Katmai) does not work on Win95, so see if we are on Win95 and disable
    //
    {
        BOOL bIsWin95 = IsWin95();
        if (bIsWin95)
        {
            dwCPUFeatures &= ~(D3DCPU_SSE | D3DCPU_WLMT);
        }
    }
        // We need to workaround VB problems on Win2K
#else
        SetVBSwapStatus();
#endif
        // Unfounded default value. 128*40 (vertex+D3DTRIANGLE struct)=5K
        // The assumption is that the primary cache hasn't got much better
        // to do than contain the vertex and index data.
        dwD3DTriBatchSize = 80;
        // Work item: do something more intelligent here than assume that
        // MMX-enabled processors have twice as much primary cache.
        if ( isMMXprocessor() )
            dwD3DTriBatchSize *= 2;
        dwTriBatchSize = (dwD3DTriBatchSize * 4) / 3;
        dwLineBatchSize = dwD3DTriBatchSize * 2;
        dwHWBufferSize = dwD3DTriBatchSize * (sizeof(D3DTLVERTEX) + sizeof(D3DTRIANGLE));
        dwHWMaxTris = dwD3DTriBatchSize;
        lRet = RegOpenKey( HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey );
        if ( lRet == ERROR_SUCCESS )
        {
            lRet = RegQueryValueEx(hKey,
                                   "FewVertices",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwHWFewVertices,
                                   &dwSize);
            if (lRet != ERROR_SUCCESS ||
                dwType != REG_DWORD ||
                dwHWFewVertices < 4 ||
                dwHWFewVertices > 128)

                dwHWFewVertices = 24;

#ifdef __D3D_PSGP_DLL__
            dwSize = sizeof(filename);
            lRet = RegQueryValueEx(hKey,
                                   "GeometryDriver",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) filename,
                                   &dwSize);
            if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
            {
                hGeometryDLL = LoadLibrary(filename);
                if (hGeometryDLL)
                {
                    pfnFEContextCreate = (LPD3DFE_CONTEXTCREATE) GetProcAddress(hGeometryDLL, "FEContextCreate");
                }
            }
#endif //__D3D_PSGP_DLL__

            RegCloseKey( hKey );
        }
        else
        {
            dwHWFewVertices = 24;
        }
        // Set the app name to reg.
        SetMostRecentApp();
        break;
    case DLL_PROCESS_DETACH:
        MemFini();
        if (NULL != hGeometryDLL)
            FreeLibrary(hGeometryDLL);
        break;
    default:
        ;
    }
    return TRUE;
}

// --------------------------------------------------------------------------
// This function is called at process attach time to put the name of current
// app to registry.
// --------------------------------------------------------------------------
void SetMostRecentApp(void)
{
    char    fname[_MAX_PATH];
    char    name[_MAX_PATH];
    int     i;
    HKEY    hKey;
    HANDLE  hFile;

    // Find out what process we are dealing with
    hFile =  GetModuleHandle( NULL );
    GetModuleFileName( (HINSTANCE)hFile, fname, sizeof( fname ) );
    DPF( 3, "full name  = %s", fname );
    i = strlen( fname )-1;
    while( i >=0 && fname[i] != '\\' )
    {
        i--;
    }
    i++;
    strcpy( name, &fname[i] );
    DPF( 3, "name       = %s", name );

    // Now write the name into some known place
        if( !RegCreateKey( HKEY_LOCAL_MACHINE,
             RESPATH_D3D "\\" REGSTR_KEY_LASTAPP, &hKey ) )
    {
        RegSetValueEx(hKey, REGSTR_VAL_DDRAW_NAME, 0, REG_SZ, (LPBYTE)name, strlen(name)+1);
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\dp2hal.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cbhal.cpp
 *  Content:    DrawPrimitive implementation for command buffer HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "clipfunc.h"
#include "d3dfei.h"
#include "pvvid.h"
#if DBG
// #define VALIDATE_DP2CMD
#endif

extern "C" HRESULT WINAPI
DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern "C" FLATPTR GetAliasedVidMem( LPDDRAWI_DIRECTDRAW_LCL   pdrv_lcl,
                          LPDDRAWI_DDRAWSURFACE_LCL surf_lcl,
                          FLATPTR                   fpVidMem );

#ifndef WIN95
extern BOOL bVBSwapEnabled, bVBSwapWorkaround;
#endif // WIN95

// Command buffer size tuned to 16K to minimize flushes in Unreal
const DWORD CDirect3DDeviceIDP2::dwD3DDefaultCommandBatchSize = 16384; // * 1 = 16K bytes

inline void CDirect3DDeviceIDP2::ClearBatch(bool bWithinPrimitive)
{
    // Reset command buffer
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)lpvDP2Commands;
    dwDP2CommandLength = 0;
    dp2data.dwCommandOffset = 0;
    dp2data.dwCommandLength = 0;
    bDP2CurrCmdOP = 0;
    // Reset vertex buffer
    if (!bWithinPrimitive)
    {
        dp2data.dwVertexOffset = 0;
        this->dwDP2VertexCount = 0;
        dwVertexBase = 0;
        TLVbuf_Base() = 0;
        if (dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES)
        {
            // We are flushing a user mem primitive.
            // We need to clear dp2data.lpUMVertices
            // since we are done with it. We replace
            // it with TLVbuf.
            DDASSERT(lpDP2CurrBatchVBI == NULL);
            dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)TLVbuf_GetDDS())->lpLcl;
            lpDP2CurrBatchVBI = TLVbuf_GetVBI();
            lpDP2CurrBatchVBI->AddRef();
            dp2data.dwFlags &= ~D3DHALDP2_USERMEMVERTICES;
        }
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::CheckSurfaces()"
HRESULT CDirect3DDeviceIDP2::CheckSurfaces()
{
    HRESULT hr;
    if(this->lpDirect3DI->lpTextureManager->CheckIfLost())
    {
        D3D_ERR("Managed Textures lost");
        return DDERR_SURFACELOST;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->lpGbl->dwUsageCount ||
         (this->lpDDSZBuffer && ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->lpGbl->dwUsageCount) )
    {
        D3D_ERR("Render target or Z buffer locked");
        return DDERR_SURFACEBUSY;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->dwFlags & DDRAWISURF_INVALID )\
        {
            D3D_ERR("Render target buffer lost");
            return DDERR_SURFACELOST;
        }
    if ( this->lpDDSZBuffer && ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->dwFlags & DDRAWISURF_INVALID ) )
    {
        D3D_ERR("Z buffer lost");
        return DDERR_SURFACELOST;
    }
    if (!(this->dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES) && (this->dp2data.lpDDVertex) && (this->dp2data.lpDDVertex->dwFlags & DDRAWISURF_INVALID))
    {
        D3D_ERR("Vertex buffer lost");
        return DDERR_SURFACELOST;
    }
    if (this->TLVbuf_GetDDS())
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(this->TLVbuf_GetDDS()))->lpLcl;
        if (lpLcl->dwFlags & DDRAWISURF_INVALID)
        {
            D3D_ERR("Internal vertex buffer lost");
            return DDERR_SURFACELOST;
        }
    }
    if (this->dp2data.lpDDCommands->dwFlags & DDRAWISURF_INVALID)
    {
        D3D_ERR("Command buffer lost");
        return DDERR_SURFACELOST;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::FlushStates(void)"

HRESULT CDirect3DDeviceIDP2::FlushStates(bool bWithinPrimitive)
{
    HRESULT dwRet=D3D_OK;
    if (dwFlags & D3DPV_WITHINPRIMITIVE)
        bWithinPrimitive = true;
    if (dwDP2CommandLength) // Do we have some instructions to flush ?
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        ++m_qwBatch;
        // So that currently bound textures get rebatched
        for (DWORD dwStage = 0; dwStage < this->dwMaxTextureBlendStages; dwStage++)
        {
            LPDIRECT3DTEXTUREI lpTexI = this->lpD3DMappedTexI[dwStage];
            if (NULL != lpTexI)
            {
                if(lpTexI->lpDDS != NULL)
                {
                    BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS))->lpLcl);
                }
            }
        }
        // Check if render target and / or z buffer is lost
        if ((dwRet = CheckSurfaces()) != D3D_OK)
        { // If lost, we'll just chuck all this work into the bit bucket
            ClearBatch(bWithinPrimitive);
            if (dwRet == DDERR_SURFACELOST)
            {
                this->dwFEFlags |= D3DFE_LOSTSURFACES;
                dwRet = D3D_OK;
            }
        }
        else
        {
            // Save since it will get overwritten by ddrval after DDI call
            DWORD dwVertexSize = dp2data.dwVertexSize;
            dp2data.dwVertexLength = this->dwDP2VertexCount;
            dp2data.dwCommandLength = dwDP2CommandLength;
            //we clear this to break re-entering as SW rasterizer needs to lock DDRAWSURFACE
            dwDP2CommandLength = 0;
            // Try and set these 2 values only once during initialization
            dp2data.dwhContext = this->dwhContext;
            dp2data.lpdwRStates = this->rstates;
            DDASSERT(dp2data.dwVertexSize != 0);
            D3D_INFO(6, "dwVertexType passed to the driver = 0x%08x", dp2data.dwVertexType);

            // If we need the same TLVbuf next time do not swap buffers.
            // Save and restore this bit
            bool bSwapVB = (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) != 0;
            if (bWithinPrimitive)
            {
                dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
            }
            // At the end of the DP2 call we expect the VB to be unlocked if
            // 1. We cannot allow the driver to swap the VB
            // 2. We are using a VB (not USERMEMVERTICES)
            // 3. It is not TLVbuf
            // In this case we might as well tell the driver that it is unlocked.
            // More importantly, we need to let DDraw know that the VB is unlocked.
            if (!(dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER))
            {
                if ((lpDP2CurrBatchVBI) && (lpDP2CurrBatchVBI != TLVbuf_GetVBI()))
                {
                    lpDP2CurrBatchVBI->UnlockI();
                }
            }
#ifndef WIN95
            else if (bVBSwapWorkaround && lpDP2CurrBatchVBI != 0 && lpDP2CurrBatchVBI == TLVbuf_GetVBI())
            {
                lpDP2CurrBatchVBI->UnlockWorkAround();
            }
            if (!bVBSwapEnabled)  // Note: bVBSwapEnabled not the same as bSwapVB above.
                                  // bVBSwapEnabled is a global to indicate whether VB
                                  // VB swapping should be turned off due to broken
                                  // Win2K kernel implementation
            {
                dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
            }
            if (!dp2data.lpDDCommands->hDDSurface)
                CompleteCreateSysmemSurface(dp2data.lpDDCommands);
            if (!(dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES )
                && !dp2data.lpDDVertex->hDDSurface)
                CompleteCreateSysmemSurface(dp2data.lpDDVertex);
#else
            // Take Win 16 Lock here
            LOCK_HAL( dwRet, this );
#endif //WIN95

            // Spin waiting on the driver if wait requested
            do {
                // Need to set this since the driver may have overwrote it by
                // setting ddrval = DDERR_WASSTILLDRAWING
                dp2data.dwVertexSize = dwVertexSize;
                CALL_HAL3ONLY_NOLOCK(dwRet, this, DrawPrimitives2, &dp2data);
                if (dwRet != DDHAL_DRIVER_HANDLED)
                {
                    D3D_ERR ( "Driver not handled in DrawPrimitives2" );
                    // Need sensible return value in this case,
                    // currently we return whatever the driver stuck in here.
                }
            } while (dp2data.ddrval == DDERR_WASSTILLDRAWING);
            if (dp2data.ddrval == D3DERR_COMMAND_UNPARSED)
            { // This should never occur since the driver must understand
              // all the instruction we batch.
                D3D_ERR("Driver could not parse this batch!");
                dwRet = DDERR_GENERIC; // Some thing better here ?
            }
            else
            {
                dwRet= dp2data.ddrval;
                // update command buffer pointer
                if ((dwRet == D3D_OK) && (dp2data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER))
                {
#ifdef WIN95
                    // Get Aliased vid mem pointer if it is a vid mem surf.
                    if (dp2data.dwFlags & D3DHALDP2_VIDMEMCOMMANDBUF)
                    {
                        D3D_INFO(7, "Got back new vid mem command buffer");
                        FLATPTR paliasbits = GetAliasedVidMem( dp2data.lpDDCommands->lpSurfMore->lpDD_lcl,
                            dp2data.lpDDCommands, (FLATPTR) dp2data.lpDDCommands->lpGbl->fpVidMem );
                        if (paliasbits == NULL)
                        {
                            DPF_ERR("Could not get Aliased pointer for vid mem command buffer");
                            // Since we can't use this pointer, set it's size to 0
                            // That way next time around we will try and allocate a new one
                            dp2data.lpDDCommands->lpGbl->dwLinearSize = 0;
                        }
                        lpvDP2Commands = (LPVOID)paliasbits;
                    }
                    else
#endif
                    {
                        D3D_INFO(7, "Got back new sys mem command buffer");
                        lpvDP2Commands = (LPVOID)dp2data.lpDDCommands->lpGbl->fpVidMem;
                    }
                    dwDP2CommandBufSize = dp2data.lpDDCommands->lpGbl->dwLinearSize;
                }
                // update vertex buffer pointer
                if ((dwRet == D3D_OK) && (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) && dp2data.lpDDVertex)
                {
                    FLATPTR paliasbits;
#ifdef WIN95
                    if (dp2data.dwFlags & D3DHALDP2_VIDMEMVERTEXBUF)
                    {
                        paliasbits = GetAliasedVidMem( dp2data.lpDDVertex->lpSurfMore->lpDD_lcl,
                            dp2data.lpDDVertex, (FLATPTR) dp2data.lpDDVertex->lpGbl->fpVidMem );
                        if (paliasbits == NULL)
                        {
                            DPF_ERR("Could not get Aliased pointer for vid mem vertex buffer");
                            // Since we can't use this pointer, set it's size to 0
                            // That way next time around we will try and allocate a new one
                            dp2data.lpDDVertex->lpGbl->dwLinearSize = 0;
                        }
                    }
                    else
#endif
                    {
                        paliasbits = dp2data.lpDDVertex->lpGbl->fpVidMem;
                    }
                    if (lpDP2CurrBatchVBI == TLVbuf_GetVBI())
                    {
#if DBG
                        if(this->alignedBuf != (VOID*)paliasbits)
                        {
                            D3D_INFO(2, "Driver swapped TLVBuf pointer in FlushStates");
                        }
#endif //DBG
                        this->alignedBuf = (LPVOID)paliasbits;
                        this->TLVbuf_size = dp2data.lpDDVertex->lpGbl->dwLinearSize;
                    }
                    else
                    {
#if DBG
                        if(this->lpDP2CurrBatchVBI->position.lpvData != (VOID*)paliasbits)
                        {
                            D3D_INFO(2, "Driver swapped VB pointer in FlushStates");
                        }
#endif //DBG
                        this->lpDP2CurrBatchVBI->position.lpvData = (LPVOID)paliasbits;
                    }
                }
            }
#ifdef WIN95
            // Release Win16 Lock here
            UNLOCK_HAL( this );
#else
            if (!bWithinPrimitive && bSwapVB && bVBSwapWorkaround && lpDP2CurrBatchVBI != 0 && lpDP2CurrBatchVBI == TLVbuf_GetVBI())
            {
                HRESULT hr = lpDP2CurrBatchVBI->LockWorkAround(this);
                if (FAILED(hr))
                {
                    TLVbuf_base = 0;
                    TLVbuf_size = 0;
                    D3D_ERR("Driver failed Lock in FlushStates");
                    if (SUCCEEDED(dwRet))
                    {
                        dwRet = hr;
                    }
                }
            }
#endif
            // Restore flag if necessary
            if (bSwapVB)
                dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
            // Restore to value before the DDI call
            dp2data.dwVertexSize = dwVertexSize;
            ClearBatch(bWithinPrimitive);
        }
    }
    // There are situations when the command stream has no data, but there is data in
    // the vertex pool. This could happen, for instance if every triangle got rejected
    // while clipping. In this case we still need to "Flush out" the vertex data.
    else if (dp2data.dwCommandLength == 0)
    {
        ClearBatch(bWithinPrimitive);
    }
    return dwRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::FlushStates(DWORD)"

HRESULT CDirect3DDeviceIDP2::FlushStatesReq(DWORD dwReqSize)
{
    DWORD sav = (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER);
    dp2data.dwReqVertexBufSize = dwReqSize;
    dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER | D3DHALDP2_REQVERTEXBUFSIZE;
    HRESULT ret = FlushStates();
    dp2data.dwFlags &= ~(D3DHALDP2_SWAPVERTEXBUFFER | D3DHALDP2_REQVERTEXBUFSIZE);
    dp2data.dwFlags |= sav;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::GrowCommandBuffer"
// Check and grow command buffer
HRESULT CDirect3DDeviceIDP2::GrowCommandBuffer(LPDIRECT3DI lpD3DI, DWORD dwSize)
{
    HRESULT ret;
    if (dwSize > dwDP2CommandBufSize)
    {
        if (lpDDSCB1)
        {
            lpDDSCB1->Release();
            lpDDSCB1 = NULL;
        }
        // Create command buffer through DirectDraw
        DDSURFACEDESC2 ddsd;
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS;
        ddsd.dwWidth = dwSize;
        ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER;
        if (IS_HW_DEVICE(this))
            ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        else
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        ddsd.ddsCaps.dwCaps2 = DDSCAPS2_COMMANDBUFFER;
        // Try explicit video memory first
        D3D_INFO(7, "Trying to create a vid mem command buffer");
        ret = lpD3DI->lpDD7->CreateSurface(&ddsd, &lpDDSCB1, NULL);
        if (ret != DD_OK)
        {
            // If that failed, try explicit system memory
            ddsd.ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
            D3D_INFO(7, "Trying to create a sys mem command buffer");
            ret = lpD3DI->lpDD7->CreateSurface(&ddsd, &lpDDSCB1, NULL);
            if (ret != DD_OK)
            {
                D3D_ERR("failed to allocate Command Buffer 1");
                dwDP2CommandBufSize = 0;
                return ret;
            }
        }
        // Lock command buffer
        ret = lpDDSCB1->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Could not lock command buffer.");
            lpDDSCB1->Release();
            lpDDSCB1 = NULL;
            dwDP2CommandBufSize = 0;
            return ret;
        }
        // update command buffer pointer
        lpvDP2Commands = ddsd.lpSurface;
        dp2data.lpDDCommands = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSCB1)->lpLcl;
        dwDP2CommandBufSize = dwSize;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::Init"

HRESULT CDirect3DDeviceIDP2::Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice)
{
    dwDP2CommandBufSize = 0;
    dwDP2Flags =0;
    lpDDSCB1 = NULL;
    lpvDP2Commands = NULL;
    TLVbuf_size = 0;
    allocatedBuf = 0;
    alignedBuf = 0;
    TLVbuf_base = 0;
    dwTLVbufChanges = 0;
    pNullVB = NULL;
    // We do this early in case of DP2 since GrowCommandBuffer depends on this check
    if (IsEqualIID(riid, IID_IDirect3DHALDevice) || IsEqualIID(riid, IID_IDirect3DTnLHalDevice))
    {
        this->dwFEFlags |=  D3DFE_REALHAL;
    }
    HRESULT ret = GrowCommandBuffer(lpD3DI, dwD3DDefaultCommandBatchSize);
    if (ret != D3D_OK)
        return ret;
    // Fill the dp2data structure with initial values
    dp2data.dwFlags = D3DHALDP2_SWAPCOMMANDBUFFER;
    dp2data.dwVertexType = D3DFVF_TLVERTEX; // Initial assumption
    dp2data.dwVertexSize = sizeof(D3DTLVERTEX); // Initial assumption
    ClearBatch(false);

    // Initialize the DDI independent part of the device
    ret = DIRECT3DDEVICEI::Init(riid, lpD3DI, lpDDS, pUnkOuter, lplpD3DDevice);
    if (ret != D3D_OK)
    {
        return ret;
    }

    // Since we plan to call TLV_Grow for the first time with "true"
    this->dwDeviceFlags |= D3DDEV_TLVBUFWRITEONLY;
    if (TLVbuf_Grow((__INIT_VERTEX_NUMBER*2)*sizeof(D3DTLVERTEX), true) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (TLVbuf)" );
        return DDERR_OUTOFMEMORY;
    }
    D3DVERTEXBUFFERDESC vbdesc;
    vbdesc.dwSize = sizeof(D3DVERTEXBUFFERDESC);
    vbdesc.dwCaps = D3DVBCAPS_SYSTEMMEMORY;
    vbdesc.dwFVF = D3DFVF_TLVERTEX;
    vbdesc.dwNumVertices = 1;
    ret = this->lpDirect3DI->CreateVertexBufferI(&vbdesc, &this->pNullVB, 0);
    if (ret != DD_OK)
    {
        return ret;
    }
#ifdef VTABLE_HACK
    if (!IS_MT_DEVICE(this))
    {
        // Make SetRS point to execute mode
        VtblSetRenderStateExecute();
        VtblSetTextureStageStateExecute();
        VtblSetTextureExecute();
        VtblApplyStateBlockExecute();
    }
#endif
    return ret;
}
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::~CDirect3DDeviceIDP2"

CDirect3DDeviceIDP2::~CDirect3DDeviceIDP2()
{
    CleanupTextures();
    if (pNullVB)
        pNullVB->Release();
    if (allocatedBuf)
        allocatedBuf->Release();
    if (lpDDSCB1)
        lpDDSCB1->Release();
    if (lpDP2CurrBatchVBI)
    {
        lpDP2CurrBatchVBI->lpDevIBatched = NULL;
        lpDP2CurrBatchVBI->Release();
    }
}
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetRenderStateI"

HRESULT CDirect3DDeviceIDP2::SetRenderStateI(D3DRENDERSTATETYPE dwStateType,
                                             DWORD value)
{
    HRESULT ret = D3D_OK;
    if (bDP2CurrCmdOP == D3DDP2OP_RENDERSTATE)
    { // Last instruction is a renderstate, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2RENDERSTATE) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2RENDERSTATE lpRState = (LPD3DHAL_DP2RENDERSTATE)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->RenderState = dwStateType;
            lpRState->dwState = value;
            dwDP2CommandLength += sizeof(D3DHAL_DP2RENDERSTATE);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2RENDERSTATE) > dwDP2CommandBufSize)
    {
            ret = FlushStates();

            // Since we ran out of space, we were not able to put (dwStateType, value)
            // into the batch so rstates will reflect only the last batched
            // renderstate (since the driver updates rstates from the batch).
            // To fix this, we simply put the current (dwStateType, value) into rstates.
            this->rstates[dwStateType]=value;

            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in SetRenderStateI");
                return ret;
            }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_RENDERSTATE;
    bDP2CurrCmdOP = D3DDP2OP_RENDERSTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add renderstate data
    LPD3DHAL_DP2RENDERSTATE lpRState = (LPD3DHAL_DP2RENDERSTATE)(lpDP2CurrCommand + 1);
    lpRState->RenderState = dwStateType;
    lpRState->dwState = value;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2RENDERSTATE);
    return ret;
}

// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION
const iprim2cmdop[] = {
    0, // Invalid
    0, // Points are invalid too
    D3DDP2OP_INDEXEDLINELIST2,
    D3DDP2OP_INDEXEDLINESTRIP,
    D3DDP2OP_INDEXEDTRIANGLELIST2,
    D3DDP2OP_INDEXEDTRIANGLESTRIP,
    D3DDP2OP_INDEXEDTRIANGLEFAN
};

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::DrawIndexPrim"

//---------------------------------------------------------------------
//
// The vertices are already in the vertex buffer.
//
HRESULT CDirect3DDeviceIDP2::DrawIndexPrim()
{
    HRESULT ret = D3D_OK;
    DWORD dwByteCount;          // Command length plus indices
    DWORD dwIndicesByteCount;   // Indices only
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        ret = UpdateTextures();
        if(ret != D3D_OK)
        {
            D3D_ERR("UpdateTextures failed. Device probably doesn't support current texture (check return code).");
            return ret;
        }
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    dwIndicesByteCount = sizeof(WORD) * this->dwNumIndices;
    dwByteCount = dwIndicesByteCount + sizeof(D3DHAL_DP2COMMAND) +
                  sizeof(D3DHAL_DP2STARTVERTEX);

    if (dwDP2CommandLength + dwByteCount > dwDP2CommandBufSize)
    {
        // Request the driver to grow the command buffer upon flush
        dp2data.dwReqCommandBufSize = dwByteCount;
        dp2data.dwFlags |= D3DHALDP2_REQCOMMANDBUFSIZE;
        ret = FlushStates(true);
        dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
        if (ret != D3D_OK)
            return ret;
        // Check if the driver did give us what we need or do it ourselves
        ret = GrowCommandBuffer(this->lpDirect3DI, dwByteCount);
        if (ret != D3D_OK)
        {
            D3D_ERR("Could not grow Command Buffer");
            return ret;
        }
    }
    // Insert indexed primitive instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                       dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wPrimitiveCount = (WORD)this->dwNumPrimitives;

    LPBYTE pIndices = (BYTE*)(lpDP2CurrCommand + 1);     // Place for indices
    lpDP2CurrCommand->bCommand = (BYTE)iprim2cmdop[this->primType];
    ((LPD3DHAL_DP2STARTVERTEX)(lpDP2CurrCommand+1))->wVStart =
        (WORD)this->dwVertexBase;
    pIndices += sizeof(D3DHAL_DP2STARTVERTEX);

#if DBG
    if (lpDP2CurrCommand->bCommand == 0)
    {
        D3D_ERR("Illegal primitive type");
        return DDERR_GENERIC;
    }
#endif
    bDP2CurrCmdOP = lpDP2CurrCommand->bCommand;

    memcpy(pIndices, this->lpwIndices, dwIndicesByteCount);

    wDP2CurrCmdCnt = lpDP2CurrCommand->wPrimitiveCount;
    dwDP2CommandLength += dwByteCount;
    return ret;
}

// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION
const prim2cmdop[] = {
    0, // Invalid
    D3DDP2OP_POINTS,
    D3DDP2OP_LINELIST,
    D3DDP2OP_LINESTRIP,
    D3DDP2OP_TRIANGLELIST,
    D3DDP2OP_TRIANGLESTRIP,
    D3DDP2OP_TRIANGLEFAN
};
// Map D3DPRIMITIVETYPE to bytes needed in command stream
const prim2cmdsz[] = {
    0, // Invalid
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2POINTS),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2LINELIST),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2LINESTRIP),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLELIST),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLESTRIP),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLEFAN)
};

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::DrawClippedPrim"

//---------------------------------------------------------------------
// This primitive is generated by the clipper.
// The vertices of this primitive are pointed to by the
// lpvOut member, which need to be copied into the
// command stream immediately after the command itself.
HRESULT CDirect3DDeviceIDP2::DrawClippedPrim()
{
    HRESULT ret = D3D_OK;
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        ret = UpdateTextures();
        if(ret != D3D_OK)
        {
            D3D_ERR("UpdateTextures failed. Device probably doesn't support current texture (check return code).");
            return ret;
        }
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    DWORD dwExtra = 0;
    LPVOID lpvVerticesImm;  // Place for vertices
    DWORD dwVertexPoolSize = this->dwNumVertices * this->dwOutputSize;
    if (this->primType == D3DPT_TRIANGLEFAN)
    {
        if (rstates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME &&
            this->dwFlags & D3DPV_NONCLIPPED)
        {
            // For unclipped (but pretended to be clipped) tri fans in
            // wireframe mode we generate 3-vertex tri fans to enable drawing of
            // interior edges
            BYTE vertices[__MAX_VERTEX_SIZE*3];
            BYTE *pV1 = vertices + this->dwOutputSize;
            BYTE *pV2 = pV1 + this->dwOutputSize;
            BYTE *pInput = (BYTE*)this->lpvOut;
            memcpy(vertices, pInput, this->dwOutputSize);
            pInput += this->dwOutputSize;
            const DWORD nTriangles = this->dwNumVertices - 2;
            this->dwNumVertices = 3;
            this->dwNumPrimitives = 1;
            this->lpvOut = vertices;
            this->dwFlags &= ~D3DPV_NONCLIPPED;  // Remove this flag for recursive call
            for (DWORD i = nTriangles; i; i--)
            {
                memcpy(pV1, pInput, this->dwOutputSize);
                memcpy(pV2, pInput+this->dwOutputSize, this->dwOutputSize);
                pInput += this->dwOutputSize;
                // To enable all edge flag we set the fill mode to SOLID.
                // This will prevent checking the clip flags in the clipper state.
                rstates[D3DRENDERSTATE_FILLMODE] = D3DFILL_SOLID;
                ret = DrawClippedPrim();
                rstates[D3DRENDERSTATE_FILLMODE] = D3DFILL_WIREFRAME;
                if (ret != D3D_OK)
                        return ret;
            }
            return D3D_OK;
        }
        dwExtra = sizeof(D3DHAL_DP2TRIANGLEFAN_IMM);
    }
    DWORD dwPad = (sizeof(D3DHAL_DP2COMMAND) + dwDP2CommandLength + dwExtra) & 3;
    DWORD dwByteCount = sizeof(D3DHAL_DP2COMMAND) + dwPad + dwExtra + dwVertexPoolSize;

    // Check for space in the command buffer for commands & vertices
    if (dwDP2CommandLength + dwByteCount > dwDP2CommandBufSize)
    {
        // Flush the current batch but hold on to the vertices
        ret = FlushStates(true);
        if (ret != D3D_OK)
            return ret;
        if (dwByteCount > dwDP2CommandBufSize)
        {
            ret = GrowCommandBuffer(this->lpDirect3DI, dwByteCount);
            if (ret != D3D_OK)
            {
                D3D_ERR("Could not grow Command Buffer");
                return ret;
            }
        }

        dwPad = (sizeof(D3DHAL_DP2COMMAND) + dwExtra) & 3;
        dwByteCount = sizeof(D3DHAL_DP2COMMAND) + dwExtra + dwPad + dwVertexPoolSize;
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->wPrimitiveCount = (WORD)this->dwNumPrimitives;
    lpDP2CurrCommand->bReserved = 0;
    if (this->primType == D3DPT_TRIANGLEFAN)
    {
        // Insert inline instruction and vertices
        bDP2CurrCmdOP = D3DDP2OP_TRIANGLEFAN_IMM;
        lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
        LPD3DHAL_DP2TRIANGLEFAN_IMM lpTriFanImm = (LPD3DHAL_DP2TRIANGLEFAN_IMM)(lpDP2CurrCommand + 1);
        if (rstates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME)
        {
            lpTriFanImm->dwEdgeFlags = 0;
            ClipVertex **clip = this->ClipperState.current_vbuf;
            // Look at the exterior edges and mark the visible ones
            for(DWORD i = 0; i < this->dwNumVertices; ++i)
            {
                if (clip[i]->clip & CLIPPED_ENABLE)
                    lpTriFanImm->dwEdgeFlags |= (1 << i);
            }
        }
        else
        {
            // Mark all exterior edges visible
            lpTriFanImm->dwEdgeFlags = 0xFFFFFFFF;
        }
        lpvVerticesImm = (LPBYTE)(lpTriFanImm + 1) + dwPad;
    }
    else
    {
        // Insert inline instruction and vertices
        bDP2CurrCmdOP = D3DDP2OP_LINELIST_IMM;
        lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
        lpvVerticesImm = (LPBYTE)(lpDP2CurrCommand + 1) + dwPad;
    }
    memcpy(lpvVerticesImm, this->lpvOut, dwVertexPoolSize);
    dwDP2CommandLength += dwByteCount;
    return ret;
}
//---------------------------------------------------------------------
HRESULT CDirect3DDeviceIDP2::DrawPrim()
{
    HRESULT ret = D3D_OK;
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        ret = UpdateTextures();
        if(ret != D3D_OK)
        {
            D3D_ERR("UpdateTextures failed. Device probably doesn't support current texture (check return code).");
            return ret;
        }
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    // Check for space in the command buffer for new command.
    // The vertices are already in the vertex buffer.
    if (dwDP2CommandLength + prim2cmdsz[this->primType] > dwDP2CommandBufSize)
    {
        ret = FlushStates(true);
        if (ret != D3D_OK)
            return ret;
    }
    // Insert non indexed primitive instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    bDP2CurrCmdOP = (BYTE)prim2cmdop[this->primType];
    lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
    lpDP2CurrCommand->bReserved = 0;
    if (bDP2CurrCmdOP == D3DDP2OP_POINTS)
    {
        wDP2CurrCmdCnt = 1;
        LPD3DHAL_DP2POINTS lpPoints = (LPD3DHAL_DP2POINTS)(lpDP2CurrCommand + 1);
        lpPoints->wCount = (WORD)this->dwNumVertices;
        lpPoints->wVStart = (WORD)this->dwVertexBase;
    }
    else
    {
        // Linestrip, trianglestrip, trianglefan, linelist and trianglelist are identical
        wDP2CurrCmdCnt = (WORD)this->dwNumPrimitives;
        LPD3DHAL_DP2LINESTRIP lpStrip = (LPD3DHAL_DP2LINESTRIP)(lpDP2CurrCommand + 1);
        lpStrip->wVStart = (WORD)this->dwVertexBase;
    }
    lpDP2CurrCommand->wPrimitiveCount = wDP2CurrCmdCnt;
    dwDP2CommandLength += prim2cmdsz[this->primType];
#ifdef VALIDATE_DP2CMD
    ValidateCommand(lpDP2CurrCommand);
#endif
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetTSSI"

HRESULT CDirect3DDeviceIDP2::SetTSSI(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue)
{
    HRESULT ret = D3D_OK;

    // Filter unsupported states
    if (dwState >= m_tssMax)
        return D3D_OK;

    if (bDP2CurrCmdOP == D3DDP2OP_TEXTURESTAGESTATE)
    { // Last instruction is a texture stage state, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2TEXTURESTAGESTATE) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2TEXTURESTAGESTATE lpRState = (LPD3DHAL_DP2TEXTURESTAGESTATE)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->wStage = (WORD)dwStage;
            lpRState->TSState = (WORD)dwState;
            lpRState->dwValue = dwValue;
            dwDP2CommandLength += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXTURESTAGESTATE) > dwDP2CommandBufSize)
    {
            ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in SetTSSI");
                return ret;
            }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_TEXTURESTAGESTATE;
    bDP2CurrCmdOP = D3DDP2OP_TEXTURESTAGESTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add renderstate data
    LPD3DHAL_DP2TEXTURESTAGESTATE lpRState = (LPD3DHAL_DP2TEXTURESTAGESTATE)(lpDP2CurrCommand + 1);
    lpRState->wStage = (WORD)dwStage;
    lpRState->TSState = (WORD)dwState;
    lpRState->dwValue = dwValue;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::ValidateDevice"

HRESULT D3DAPI
CDirect3DDeviceIDP2::ValidateDevice(LPDWORD lpdwNumPasses)
{
    try
    {
        // Holds D3D lock until exit.
        CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));
        HRESULT ret;
        D3DHAL_VALIDATETEXTURESTAGESTATEDATA vbod;

        if (!VALID_DIRECT3DDEVICE_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice7 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(lpdwNumPasses, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid lpdwNumPasses pointer" );
            return DDERR_INVALIDPARAMS;
        }

        // First, Update textures since drivers pass /fail this call based
        // on the current texture handles
        ret = UpdateTextures();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to update managed textures in ValidateDevice");
            return ret;
        }
        // First, flush states, so we can validate the current state
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to FlushStates in ValidateDevice");
            return ret;
        }

        // Now ask the driver!

        *lpdwNumPasses = 0;
        memset(&vbod, 0, sizeof(D3DHAL_VALIDATETEXTURESTAGESTATEDATA));
        vbod.dwhContext = this->dwhContext;
        if (this->lpD3DHALCallbacks3->ValidateTextureStageState)
        {
             CALL_HAL3ONLY(ret, this, ValidateTextureStageState, &vbod);
             if (ret != DDHAL_DRIVER_HANDLED)
                 return DDERR_UNSUPPORTED;

             *lpdwNumPasses = vbod.dwNumPasses;
             return vbod.ddrval;
        }
        else
        {
            D3D_ERR("Error: ValidateTextureStageState not supported by the driver.");
        }

        return DDERR_UNSUPPORTED;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::StartPrimVB"
//---------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called only if vertices from user memory are NOT used for rendering
//
HRESULT CDirect3DDeviceIDP2::StartPrimVB(LPDIRECT3DVERTEXBUFFERI lpVBI,
                                         DWORD dwStartVertex)
{
    HRESULT ret = D3D_OK;

    // If VID has been changed or new vertex buffer is used we flush the batch
    if (this->dwVIDOut != dp2data.dwVertexType ||
        lpDP2CurrBatchVBI != lpVBI ||
        dp2data.lpDDVertex != ((LPDDRAWI_DDRAWSURFACE_INT)(lpVBI->GetDDS()))->lpLcl)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
            return ret;
        dp2data.dwVertexType = this->dwVIDOut;
        dp2data.dwVertexSize = this->dwOutputSize;
        dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)(lpVBI->GetDDS()))->lpLcl;
        // Release previously used vertex buffer (if any), because we do not
        // need it any more. We did AddRef() to TL buffer, so it is safe.
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->lpDevIBatched = NULL;
            lpDP2CurrBatchVBI->Release();
        }
        // If a vertex buffer is used for rendering, make sure that it is not
        // released by user. So do AddRef().
        lpDP2CurrBatchVBI = lpVBI;
        lpDP2CurrBatchVBI->AddRef();
    }
    if (this->TLVbuf_GetVBI() == lpVBI)
    {
        this->dwVertexBase = this->dwDP2VertexCount;
        DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
        dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = this->dwVertexBase + this->dwNumVertices;
#ifdef VTABLE_HACK
        VtblDrawPrimitiveVBDefault();
        VtblDrawIndexedPrimitiveVBDefault();
#endif VTABLE_HACK
    }
    else
    {
        this->dwVertexBase = dwStartVertex;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = max(this->dwDP2VertexCount, this->dwVertexBase + this->dwNumVertices);
#ifdef VTABLE_HACK
        VtblDrawPrimitiveDefault();
        VtblDrawIndexedPrimitiveDefault();
#endif VTABLE_HACK
    }
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::StartPrimUserMem"
//---------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called if vertices from user memory is used for rendering
//
HRESULT CDirect3DDeviceIDP2::StartPrimUserMem(LPVOID lpMem)
{
    HRESULT ret = D3D_OK;
    // We fail vid mem VB for clipping
    bool bWriteOnly = ((this->dwDeviceFlags & D3DDEV_DONOTCLIP) || IS_TLHAL_DEVICE(this))!=0;

    // If the primitive is small, we copy vertices into the TL buffer
        // ATTENTION: Dont do this if the device is a TL device ?
    if (this->dwNumVertices < LOWVERTICESNUMBER)
    {
        if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
        {
            if (this->TLVbuf_Grow(this->dwVertexPoolSize, bWriteOnly) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
        }
        // So now user memory is not used any more.
        ret = StartPrimVB(this->TLVbuf_GetVBI(), 0);
        if (ret != D3D_OK)
            return ret;
        LPVOID tmp = this->TLVbuf_GetAddress();
        memcpy(tmp, this->lpvOut, this->dwVertexPoolSize);
        // We have to update lpvOut, because it was set to user memory
        this->lpvOut = tmp;
    }
    else
    {
        // We can not mix user memory primitive with other primitives, so
        // flush the batch.
        // Do not forget to flush the batch after rendering this primitive
        ret = this->FlushStates();
        if (ret != D3D_OK)
            return ret;
        // Release previously used vertex buffer (if any), because we do not
        // it any more
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->lpDevIBatched = NULL;
            lpDP2CurrBatchVBI->Release();
            lpDP2CurrBatchVBI = NULL;
#ifdef VTABLE_HACK
            VtblDrawPrimitiveVBDefault();
            VtblDrawIndexedPrimitiveVBDefault();
            VtblDrawPrimitiveDefault();
            VtblDrawIndexedPrimitiveDefault();
#endif VTABLE_HACK
        }
        dp2data.dwVertexType = this->dwVIDOut;
        dp2data.dwVertexSize = this->dwOutputSize;
        dp2data.lpVertices = lpMem;
        dp2data.dwFlags |= D3DHALDP2_USERMEMVERTICES;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = this->dwNumVertices;
        this->dwFlags |= D3DPV_USERMEMVERTICES;
    }
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::EndPrim"
//---------------------------------------------------------------------
// This function should not be called from DrawVertexBufferVB
//
HRESULT CDirect3DDeviceIDP2::EndPrim()
{
    HRESULT ret = D3D_OK;
    if (this->dwFlags & D3DPV_USERMEMVERTICES)
        // We can not mix user memory primitive, so flush it.
        ret = this->FlushStates();
    else
    {
        // If TL buffer was used, we have to move its internal base pointer
        this->TLVbuf_Base() += this->dwVertexPoolSize;
        DDASSERT(TLVbuf_base <= TLVbuf_size);
        DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
    }

    this->dwFlags &= ~D3DPV_USERMEMVERTICES;
    return ret;
}
//---------------------------------------------------------------------
//
//
void CDirect3DDeviceIDP2::UpdateDrvViewInfo(LPD3DVIEWPORT7 lpVwpData)
{
    LPD3DHAL_DP2VIEWPORTINFO pData;
    pData = (LPD3DHAL_DP2VIEWPORTINFO)GetHalBufferPointer(D3DDP2OP_VIEWPORTINFO, sizeof(*pData));
    pData->dwX = lpVwpData->dwX;
    pData->dwY = lpVwpData->dwY;
    pData->dwWidth = lpVwpData->dwWidth;
    pData->dwHeight = lpVwpData->dwHeight;
}
//---------------------------------------------------------------------
//
//
void CDirect3DDeviceIDP2::UpdateDrvWInfo()
{
    LPD3DHAL_DP2WINFO pData;
    pData = (LPD3DHAL_DP2WINFO)GetHalBufferPointer(D3DDP2OP_WINFO, sizeof(*pData));
    D3DMATRIXI &m = transform.proj;
    if( (m._33 == m._34) || (m._33 == 0.0f) )
    {
        D3D_WARN(1, "Cannot compute WNear and WFar from the supplied projection matrix.\n Setting wNear to 0.0 and wFar to 1.0" );
        pData->dvWNear = 0.0f;
        pData->dvWFar  = 1.0f;
        return;
    }

    pData->dvWNear = m._44 - m._43/m._33*m._34;
    pData->dvWFar  = (m._44 - m._43)/(m._33 - m._34)*m._34 + m._44;
}
//---------------------------------------------------------------------
// Initializes command header in the DP2 command buffer,
// reserves space for the command data and returns pointer to the command
// data
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::GetHalBufferPointer"

LPVOID CDirect3DDeviceIDP2::GetHalBufferPointer(D3DHAL_DP2OPERATION op, DWORD dwDataSize)
{
    DWORD dwCommandSize = sizeof(D3DHAL_DP2COMMAND) + dwDataSize;

    // Check to see if there is space to add a new command for space
    if (dwCommandSize + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        HRESULT ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in GetHalBufferPointer");
            throw ret;
        }
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = op;
    bDP2CurrCmdOP = op;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;

    dwDP2CommandLength += dwCommandSize;
    return (LPVOID)(lpDP2CurrCommand + 1);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::UpdateDriverStates"

HRESULT
CDirect3DDeviceIDP2::UpdateDriverStates()
{
    static D3DRENDERSTATETYPE dp2states[] =
    {
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_ZVISIBLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_COLORKEYENABLE,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_STIPPLEENABLE,
        D3DRENDERSTATE_MONOENABLE,
        D3DRENDERSTATE_ROP2,
        D3DRENDERSTATE_PLANEMASK,
        D3DRENDERSTATE_WRAPU,
        D3DRENDERSTATE_WRAPV,
        D3DRENDERSTATE_ANTIALIAS,
        D3DRENDERSTATE_SUBPIXEL,
        D3DRENDERSTATE_SUBPIXELX,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_STIPPLEPATTERN00,
        D3DRENDERSTATE_STIPPLEPATTERN01,
        D3DRENDERSTATE_STIPPLEPATTERN02,
        D3DRENDERSTATE_STIPPLEPATTERN03,
        D3DRENDERSTATE_STIPPLEPATTERN04,
        D3DRENDERSTATE_STIPPLEPATTERN05,
        D3DRENDERSTATE_STIPPLEPATTERN06,
        D3DRENDERSTATE_STIPPLEPATTERN07,
        D3DRENDERSTATE_STIPPLEPATTERN08,
        D3DRENDERSTATE_STIPPLEPATTERN09,
        D3DRENDERSTATE_STIPPLEPATTERN10,
        D3DRENDERSTATE_STIPPLEPATTERN11,
        D3DRENDERSTATE_STIPPLEPATTERN12,
        D3DRENDERSTATE_STIPPLEPATTERN13,
        D3DRENDERSTATE_STIPPLEPATTERN14,
        D3DRENDERSTATE_STIPPLEPATTERN15,
        D3DRENDERSTATE_STIPPLEPATTERN16,
        D3DRENDERSTATE_STIPPLEPATTERN17,
        D3DRENDERSTATE_STIPPLEPATTERN18,
        D3DRENDERSTATE_STIPPLEPATTERN19,
        D3DRENDERSTATE_STIPPLEPATTERN20,
        D3DRENDERSTATE_STIPPLEPATTERN21,
        D3DRENDERSTATE_STIPPLEPATTERN22,
        D3DRENDERSTATE_STIPPLEPATTERN23,
        D3DRENDERSTATE_STIPPLEPATTERN24,
        D3DRENDERSTATE_STIPPLEPATTERN25,
        D3DRENDERSTATE_STIPPLEPATTERN26,
        D3DRENDERSTATE_STIPPLEPATTERN27,
        D3DRENDERSTATE_STIPPLEPATTERN28,
        D3DRENDERSTATE_STIPPLEPATTERN29,
        D3DRENDERSTATE_STIPPLEPATTERN30,
        D3DRENDERSTATE_STIPPLEPATTERN31,
        D3DRENDERSTATE_TEXTUREPERSPECTIVE,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7
    };
    HRESULT ret;
    for (DWORD i=0;i<sizeof(dp2states)/sizeof(D3DRENDERSTATETYPE); ++i)
    {
        ret = this->SetRenderStateI(dp2states[i], this->rstates[dp2states[i]]);
        if (ret != D3D_OK)
            return ret;
    }
    // Update new states
    for (i=0; i<dwMaxTextureBlendStages; ++i)
        for (DWORD j=D3DTSS_COLOROP; j<=D3DTSS_BUMPENVLOFFSET; ++j) // D3DTSS_BUMPENVLOFFSET is the max. TSS understood by a DP2HAL (DX6) driver
        {
            D3D_INFO(6,"Calling SetTSSI(%d,%d,%08lx)",i,j, this->tsstates[i][j]);
            ret = this->SetTSSI(i, (D3DTEXTURESTAGESTATETYPE)j, this->tsstates[i][j]);
            if (ret != D3D_OK)
                return ret;
        }
    return D3D_OK;
}

//---------------------------------------------------------------------
// ProcessPrimitive processes indexed, non-indexed primitives or
// vertices only as defined by "op"
//
// op = __PROCPRIMOP_NONINDEXEDPRIM by default
//
HRESULT CDirect3DDeviceIDP2::ProcessPrimitive(__PROCPRIMOP op)
{
    HRESULT ret=D3D_OK;

// Grow clip flags buffer if we need clipping
//
    if (!(this->dwDeviceFlags & D3DDEV_DONOTCLIP))
    {
        DWORD size = this->dwNumVertices * sizeof(D3DFE_CLIPCODE);
        if (size > this->HVbuf.GetSize())
        {
            if (this->HVbuf.Grow(size) != D3D_OK)
            {
                D3D_ERR( "Could not grow clip buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
        }
        this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
    }

    if (FVF_TRANSFORMED(this->dwVIDIn))
    {
        // Pass vertices directly from the user memory
        this->dwVIDOut = this->dwVIDIn;
        this->dwOutputSize = this->position.dwStride;
        this->lpvOut = this->position.lpvData;
        this->dwVertexPoolSize = this->dwNumVertices * this->dwOutputSize;

        StartPrimUserMem(this->position.lpvData);
        if (ret != D3D_OK)
            return ret;
        if (this->dwDeviceFlags & D3DDEV_DONOTCLIP)
        {
            if (!(this->dwDeviceFlags & D3DDEV_DONOTUPDATEEXTENTS))
                D3DFE_updateExtents(this);
#ifdef VTABLE_HACK
            else
                if (!IS_MT_DEVICE(this) && this->dwNumVertices < LOWVERTICESNUMBER)
                    if (op == __PROCPRIMOP_INDEXEDPRIM)
                        VtblDrawIndexedPrimitiveTL();
                    else
                        VtblDrawPrimitiveTL();
#endif // VTABLE_HACK
            if (op == __PROCPRIMOP_INDEXEDPRIM)
            {
                ret = this->DrawIndexPrim();
            }
            else
            {
                ret = this->DrawPrim();
            }
        }
        else
        {
            DWORD clip_intersect = D3DFE_GenClipFlags(this);
            D3DFE_UpdateClipStatus(this);
            if (!clip_intersect)
            {
                this->dwFlags |= D3DPV_TLVCLIP;
                if (op == __PROCPRIMOP_INDEXEDPRIM)
                {
                    ret = DoDrawIndexedPrimitive(this);
                }
                else
                {
                    ret = DoDrawPrimitive(this);
                }
            }
        }
    }
    else
    {
        this->dwVertexPoolSize = this->dwNumVertices * this->dwOutputSize;
        if (op == __PROCPRIMOP_INDEXEDPRIM)
        {
            if ((this->dwDeviceFlags & (D3DDEV_DONOTCLIP | D3DDEV_TLVBUFWRITEONLY))==D3DDEV_TLVBUFWRITEONLY)
            {
                if( FAILED(this->TLVbuf_Grow(this->dwVertexPoolSize, false)) )
                {
                    D3D_ERR( "Could not grow TL vertex buffer" );
                    return DDERR_OUTOFMEMORY;
                }
            }
            else if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
            {
                if (this->TLVbuf_Grow(this->dwVertexPoolSize,
                    (this->dwDeviceFlags & D3DDEV_DONOTCLIP)!=0) != D3D_OK)
                {
                    D3D_ERR( "Could not grow TL vertex buffer" );
                    ret = DDERR_OUTOFMEMORY;
                    return ret;
                }
            }
#ifdef VTABLE_HACK
            // Use fast path if single threaded device and not using strided API
            if (!(IS_MT_DEVICE(this) || (this->dwDeviceFlags & D3DDEV_STRIDE))
                && IS_FPU_SETUP(this))
                VtblDrawIndexedPrimitiveFE();
#endif // VTABLE_HACK
        }
        else
        {
            if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
            {
                if (this->TLVbuf_Grow(this->dwVertexPoolSize, true) != D3D_OK)
                {
                    D3D_ERR( "Could not grow TL vertex buffer" );
                    ret = DDERR_OUTOFMEMORY;
                    return ret;
                }
            }
#ifdef VTABLE_HACK
            // Use fast path if single threaded device and not using strided API
            if (!(IS_MT_DEVICE(this) || (this->dwDeviceFlags & D3DDEV_STRIDE))
                && IS_FPU_SETUP(this))
                VtblDrawPrimitiveFE();
#endif // VTABLE_HACK
        }

        ret = StartPrimVB(this->TLVbuf_GetVBI(), 0);
        if (ret != D3D_OK)
            return ret;
        this->lpvOut = this->TLVbuf_GetAddress();

        // Update Lighting and related flags
        DoUpdateState(this);

#ifdef VTABLE_HACK
        // Save the flags that can be persisted if state does not change
        this->dwLastFlags = this->dwFlags & D3DPV_PERSIST;
#endif // VTABLE_HACK

        // Call PSGP or our implementation
        if (op == __PROCPRIMOP_INDEXEDPRIM)
        {
            ret = this->pGeometryFuncs->ProcessIndexedPrimitive(this);
        }
        else
        {
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
        }
        D3DFE_UpdateClipStatus(this);
    }
    if (ret != D3D_OK)
    {
        D3D_ERR("ProcessPrimitive failed");
        return ret;
    }
    return EndPrim();
}
//----------------------------------------------------------------------
// Growing aligned vertex buffer implementation.
//
HRESULT CDirect3DDeviceIDP2::TLVbuf_Grow(DWORD growSize, bool bWriteOnly)
{
    D3DVERTEXBUFFERDESC vbdesc = {sizeof(D3DVERTEXBUFFERDESC), 0, D3DFVF_TLVERTEX, 0};
    DWORD dwRefCnt = 1;
    DWORD bTLVbufIsCurr = static_cast<CDirect3DVertexBuffer*>(allocatedBuf) == lpDP2CurrBatchVBI; // Is ref cnt of TLVbuf 1 or 2 ?

    bool bDP2WriteOnly = (this->dwDeviceFlags & D3DDEV_TLVBUFWRITEONLY) != 0;
    // Avoid to many changes. Restrict TLVbuf to sys mem if too many changes
    if (this->dwTLVbufChanges >= D3D_MAX_TLVBUF_CHANGES)
    {
#if DBG
        if (this->dwTLVbufChanges == D3D_MAX_TLVBUF_CHANGES)
            DPF(1, "Too many changes: Limiting internal VB to sys mem.");
#endif
        bWriteOnly = false;
    }
    if (TLVbuf_base || (bWriteOnly != bDP2WriteOnly))
    {
        HRESULT ret;
        ret = FlushStatesReq(growSize);
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in CDirect3DDeviceIDP2::TLVbuf_Grow");
            return ret;
        }
        TLVbuf_base = 0;
    }
    if (growSize <= TLVbuf_size)
    {
        if (bWriteOnly == bDP2WriteOnly)
            return D3D_OK;
        else
            this->dwTLVbufChanges++;
    }
    if (allocatedBuf)
    {
        allocatedBuf->Release();
        allocatedBuf = NULL;
    }
    if (bTLVbufIsCurr)
    {
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->lpDevIBatched = NULL;
            lpDP2CurrBatchVBI->Release();
        }
        lpDP2CurrBatchVBI = NULL;
        dp2data.lpDDVertex = NULL;
    }
    // Make sure we do not shrink the VB since it will
    // grow it only as large to fit the largest primitive and might not
    // be enough to get good batching perf.
    DWORD size = max(growSize, TLVbuf_size);
    size = (DWORD)max(size, (__INIT_VERTEX_NUMBER*2)*sizeof(D3DTLVERTEX));
    vbdesc.dwNumVertices = (size + 31) / sizeof(D3DTLVERTEX);
    TLVbuf_size = vbdesc.dwNumVertices * sizeof(D3DTLVERTEX);
    if (!IS_HW_DEVICE(this))
    {
        vbdesc.dwCaps = D3DVBCAPS_SYSTEMMEMORY;
    }
    if (bWriteOnly)
    {
        vbdesc.dwCaps |= D3DVBCAPS_WRITEONLY;
        this->dwDeviceFlags |= D3DDEV_TLVBUFWRITEONLY;
    }
    else
    {
        this->dwDeviceFlags &= ~D3DDEV_TLVBUFWRITEONLY;
    }
    vbdesc.dwCaps |= D3DVBCAPS_DONOTCLIP;
    if (this->lpDirect3DI->CreateVertexBufferI(&vbdesc, &allocatedBuf, D3DVBFLAGS_CREATEMULTIBUFFER) != DD_OK)
    {
        // This should fail duirng mode switches or ulta-low memory situations. In either case,
        // we set allocatedBuf to a valid VB object since it gets dereferenced many places without
        // checking for it being NULL. WE use the special "NULL" VB created at init time for just 
        // this purpose
        allocatedBuf = pNullVB;
        if (pNullVB)
        {
            allocatedBuf->AddRef();
            if (bTLVbufIsCurr)
            {
                lpDP2CurrBatchVBI = static_cast<CDirect3DVertexBuffer*>(allocatedBuf);
                lpDP2CurrBatchVBI->AddRef();
                dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)(lpDP2CurrBatchVBI->GetDDS()))->lpLcl;
            }
        }
        TLVbuf_size = 0;
        alignedBuf = NULL; // Lets see if some one tries to use this...
        D3D_ERR("Could not allocate internal vertex buffer");
        return DDERR_OUTOFMEMORY;
    }
    // Update lpDP2CurrentBatchVBI if necessary
    if (bTLVbufIsCurr)
    {
        lpDP2CurrBatchVBI = static_cast<CDirect3DVertexBuffer*>(allocatedBuf);
        lpDP2CurrBatchVBI->AddRef();
        dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)(lpDP2CurrBatchVBI->GetDDS()))->lpLcl;
    }
    if (allocatedBuf->Lock(DDLOCK_WAIT, &alignedBuf, NULL) != DD_OK)
    {
        D3D_ERR("Could not lock internal vertex buffer");
        TLVbuf_size = 0;
        alignedBuf = NULL; // Lets see if some one tries to use this...
        return DDERR_OUTOFMEMORY;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// Computes the following data
//  - dwTextureCoordOffset[] offset of every input texture coordinates

static __inline void ComputeInpTexCoordOffsets(DWORD dwNumTexCoord,
                                               DWORD dwFVF,
                                               DWORD *pdwTextureCoordOffset)
{
    // Compute texture coordinate size
    DWORD dwTextureFormats = dwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            pdwTextureCoordOffset[i] = i << 3;
        }
    }
    else
    {
        DWORD dwOffset = 0;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            pdwTextureCoordOffset[i] = dwOffset;
            dwOffset += g_TextureSize[dwTextureFormats & 3];
            dwTextureFormats >>= 2;
        }
    }
    return;
}
//---------------------------------------------------------------------
// Returns 2 bits of FVF texture format for the texture index
//
static inline DWORD FVFGetTextureFormat(DWORD dwFVF, DWORD dwTextureIndex)
{
    return (dwFVF >> (dwTextureIndex*2 + 16)) & 3;
}
//---------------------------------------------------------------------
// Returns texture format bits shifted to the right place
//
static inline DWORD FVFMakeTextureFormat(DWORD dwNumberOfCoordinates, DWORD dwTextureIndex)
{
    return g_dwTextureFormat[dwNumberOfCoordinates] << ((dwTextureIndex << 1) + 16);
}
//---------------------------------------------------------------------
inline DWORD GetOutTexCoordSize(DWORD *pdwStage, DWORD dwInpTexCoordSize)
{
    // Low byte has texture coordinate count
    const DWORD dwTextureTransformFlags = pdwStage[D3DTSS_TEXTURETRANSFORMFLAGS] & 0xFF;
    if (dwTextureTransformFlags == 0)
        return dwInpTexCoordSize;
    else
        return (dwTextureTransformFlags << 2);
}
//----------------------------------------------------------------------
// pDevI->nOutTexCoord should be initialized to the number of input texture coord sets
//
HRESULT EvalTextureTransforms(LPDIRECT3DDEVICEI pDevI, DWORD dwTexTransform,
                              DWORD *pdwOutTextureSize, DWORD *pdwOutTextureFormat)
{
    DWORD dwOutTextureSize = 0;         // Used to compute output vertex size
    DWORD dwOutTextureFormat = 0;       // Used to compute output texture FVF
    // The bits are used to find out how the texture coordinates are used.
    const DWORD __USED_BY_TRANSFORM  = 1;
    const DWORD __USED               = 2;
    // The low 16 bits are for _USED bits. The high 16 bits will hold
    // re-mapped texture index for a stage
    DWORD dwTexCoordUsage[D3DDP_MAXTEXCOORD];
    memset(dwTexCoordUsage, 0, sizeof(dwTexCoordUsage));

    // Re-mapping buffer will contain only stages that use texture
    // This variable is used to count them
    pDevI->dwNumTextureStages = 0;
    DWORD dwNewIndex = 0;           // Used to generate output index
    // We need offsets for every input texture coordinate, because
    // we could access them in random order.
    // Offsets are not needed for strided input
    DWORD   dwTextureCoordOffset[D3DDP_MAXTEXCOORD];
    if (!(pDevI->dwDeviceFlags & D3DDEV_STRIDE))
    {
        ComputeInpTexCoordOffsets(pDevI->nTexCoord, pDevI->dwVIDIn, dwTextureCoordOffset);
    }
    DWORD dwOutTextureCoordSize[D3DDP_MAXTEXCOORD];
    // Go through all texture stages and find those which use texture coordinates
    for (DWORD i=0; i < D3DDP_MAXTEXCOORD; i++)
    {
        if (pDevI->tsstates[i][D3DTSS_COLOROP] == D3DTOP_DISABLE)
            break;

        DWORD dwIndex = pDevI->tsstates[i][D3DTSS_TEXCOORDINDEX];
        DWORD dwInpTextureFormat;
        DWORD dwInpTexSize;
        DWORD dwMapArrayIndex = pDevI->dwNumTextureStages;
        LPD3DFE_TEXTURESTAGE pStage = &pDevI->textureStage[dwMapArrayIndex];
        DWORD dwTexGenMode = dwIndex & ~0xFFFF;
        dwIndex = dwIndex & 0xFFFF; // Remove texture generation mode
        if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
        {
            dwInpTextureFormat = D3DFVF_TEXCOORDSIZE3(dwIndex);
            dwInpTexSize = 3*sizeof(D3DVALUE);
            pDevI->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
                pDevI->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE | D3DDEV_POSITIONINCAMERASPACE;
            else
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL)
                pDevI->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE;
            else
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION)
                pDevI->dwDeviceFlags |= D3DDEV_POSITIONINCAMERASPACE;
        }
        else
        {
            if (dwIndex >= pDevI->nTexCoord)
            {
                D3D_ERR("Texture index in a stage is greater than number of input texture coordinates");
                return DDERR_GENERIC;
            }
            dwInpTextureFormat = FVFGetTextureFormat(pDevI->dwVIDIn, dwIndex);
            dwInpTexSize = pDevI->dwTextureCoordSize[dwIndex];
            pStage->dwInpOffset = dwTextureCoordOffset[dwIndex];
        }
        pStage->dwInpCoordIndex = dwIndex;
        pStage->dwTexGenMode = dwTexGenMode;
        pStage->dwOrgStage = i;
        DWORD dwOutTexCoordSize;    // Size of the texture coord set in bytes for this stage
        if (dwTexTransform & 1)
        {
            pDevI->dwDeviceFlags |= D3DDEV_TEXTURETRANSFORM;
            pStage->pmTextureTransform = &pDevI->mTexture[i];
            dwOutTexCoordSize = GetOutTexCoordSize((DWORD*)&pDevI->tsstates[i], dwInpTexSize);
            // If we have to add or remove some coordinates we go through
            // the re-mapping path
            if (dwOutTexCoordSize != dwInpTexSize)
                pDevI->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
        }
        else
        {
            pStage->pmTextureTransform = NULL;
            dwOutTexCoordSize = dwInpTexSize;
        }
        pStage->dwTexTransformFuncIndex = MakeTexTransformFuncIndex
                                         (dwInpTexSize >> 2, dwOutTexCoordSize >> 2);
        if ((dwTexCoordUsage[dwIndex] & 0xFFFF) == 0)
        {
            // Texture coordinate set is used first time
            if (dwTexTransform & 1)
                dwTexCoordUsage[dwIndex] |= __USED_BY_TRANSFORM;
            dwTexCoordUsage[dwIndex] |= __USED;
        }
        else
        {
            // Texture coordinate set is used second or more time
            if (dwTexTransform & 1)
            {
                // This set is used by two texture transforms or a
                // texture transform and without it, so we have to
                // generate an additional output texture coordinate
                dwTexCoordUsage[dwIndex] |= __USED_BY_TRANSFORM;
                pDevI->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            }
            else
            {
                if (dwTexCoordUsage[dwIndex] & __USED_BY_TRANSFORM)
                {
                    // This set is used by two texture transforms or a
                    // texture transform and without it, so we have to
                    // generate an additional output texture coordinate
                    pDevI->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
                }
                else
                if (dwTexGenMode == 0)
                {
                    // We do not have to generate new texture coord for this,
                    // we can re-use the same input texture coordinate
                    DWORD dwOutIndex = dwTexCoordUsage[dwIndex] >> 16;
                    pStage->dwOutCoordIndex = dwOutIndex;
                    goto l_NoNewOutTexCoord;
                }
            }
        }
        // If we are here, we have to generate new output texture coordinate set
        pStage->dwOutCoordIndex = dwNewIndex;
        dwTexCoordUsage[dwIndex] |= dwNewIndex << 16;
        dwOutTextureSize += dwOutTexCoordSize;
        dwOutTextureCoordSize[dwNewIndex] = dwOutTexCoordSize;
        dwOutTextureFormat |= FVFMakeTextureFormat(dwOutTexCoordSize >> 2, dwNewIndex);
        dwNewIndex++;
l_NoNewOutTexCoord:
        pDevI->dwNumTextureStages++;
        dwTexTransform >>= 1;
    }
    if (pDevI->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        // Now, when we have to do re-mapping, we have to set new output texture
        // coordinate set sizes
        for (DWORD i=0; i < pDevI->dwNumTextureStages; i++)
        {
            pDevI->dwTextureCoordSize[i] = dwOutTextureCoordSize[i];
        }
        pDevI->nOutTexCoord = dwNewIndex;
    }
    *pdwOutTextureSize = dwOutTextureSize;
    *pdwOutTextureFormat = dwOutTextureFormat;
    return D3D_OK;
}
//----------------------------------------------------------------------
// Sets texture transform pointer for every input texture coordinate set
//
void SetupTextureTransforms(LPDIRECT3DDEVICEI pDevI)
{
    // Set texture transforms to NULL in case when some texture coordinates
    // are not used by texture stages
    memset(pDevI->pmTexture, 0, sizeof(pDevI->pmTexture));

    for (DWORD i=0; i < pDevI->dwNumTextureStages; i++)
    {
        LPD3DFE_TEXTURESTAGE pStage = &pDevI->textureStage[i];
        pDevI->pmTexture[pStage->dwInpCoordIndex] = pStage->pmTextureTransform;
    }
}
//----------------------------------------------------------------------
HRESULT CDirect3DDeviceIDP2::SetupFVFData(DWORD *pdwInpVertexSize)
{
    if (this->dwDeviceFlags & D3DDEV_FVF)
        return DIRECT3DDEVICEI::SetupFVFDataCommon(pdwInpVertexSize);
    else
        return DIRECT3DDEVICEI::SetupFVFData(pdwInpVertexSize);
}
//----------------------------------------------------------------------
// Computes the following device data
//  - dwVIDOut, based on input FVF id and device settings
//  - nTexCoord
//  - dwTextureCoordSizeTotal
//  - dwTextureCoordSize[] array, based on the input FVF id
//  - dwOutputSize, based on the output FVF id
//
// The function is called from ProcessVertices and DrawPrimitives code paths
//
// The following variables should be set in the pDevI:
//  - dwVIDIn
//
// Number of texture coordinates is set based on dwVIDIn. ValidateFVF should
// make sure that it is not greater than supported by the driver
// Last settings for dwVIDOut and dwVIDIn are saved to speed up processing
//
#undef  DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetupFVFData"

HRESULT DIRECT3DDEVICEI::SetupFVFDataCommon(DWORD *pdwInpVertexSize)
{
    HRESULT ret;
    this->dwFEFlags &= ~D3DFE_FVF_DIRTY;
    // We have to restore texture stage indices if previous primitive
    // re-mapped them
    if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(this);
    }

// Compute number of the input texture coordinates

    this->nTexCoord = FVF_TEXCOORD_NUMBER(this->dwVIDIn);

// Compute size of input texture coordinates

    this->dwTextureCoordSizeTotal = ComputeTextureCoordSize(this->dwVIDIn, this->dwInpTextureCoordSize);

// This size is the same for input and output FVFs in case when we do not have to
// expand number of texture coordinates
    for (DWORD i=0; i < this->nTexCoord; i++)
        this->dwTextureCoordSize[i] = this->dwInpTextureCoordSize[i];

    if (pdwInpVertexSize)
    {
        *pdwInpVertexSize = GetVertexSizeFVF(this->dwVIDIn) + this->dwTextureCoordSizeTotal;
    }

    this->nOutTexCoord = this->nTexCoord;

    if (FVF_TRANSFORMED(this->dwVIDIn))
    {
        // Set up vertex pointers
        this->dwVIDOut = this->dwVIDIn;
        ComputeOutputVertexOffsets(this);
        return D3D_OK;
    }

// Compute output FVF

    this->dwVIDOut = D3DFVF_XYZRHW;
    if (this->dwDeviceFlags & D3DDEV_DONOTSTRIPELEMENTS)
    {
        this->dwVIDOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
    }
    else
    {
        // If normal present we have to compute specular and duffuse
        // Otherwise set these bits the same as input.
        // Not that normal should not be present for XYZRHW position type
        if (this->dwDeviceFlags & D3DDEV_LIGHTING)
            this->dwVIDOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
        else
            this->dwVIDOut |= this->dwVIDIn & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR);
        // Always set specular flag if fog is enabled
        if (this->rstates[D3DRENDERSTATE_FOGENABLE])
            this->dwVIDOut |= D3DFVF_SPECULAR;
        else
        // Clear specular flag if specular disabled and we do not have specular in the input
        if (!this->rstates[D3DRENDERSTATE_SPECULARENABLE] && !(this->dwVIDIn & D3DFVF_SPECULAR))
            this->dwVIDOut &= ~D3DFVF_SPECULAR;
    }

    // Compute output vertex size without texture
    this->dwOutputSize = GetVertexSizeFVF(this->dwVIDOut);

// Compute number of the output texture coordinates

    // Transform enable bits
    DWORD dwTexTransform = this->dwFlags2 & __FLAGS2_TEXTRANSFORM;

    this->dwDeviceFlags &= ~D3DDEV_TEXTURETRANSFORM;
    // When texture transform is enabled or texture coordinates are taken from
    // the vertex data, output texture coordinates could be generated. so we go
    // and evaluate texture stages
    if ((dwTexTransform && this->nTexCoord > 0) ||
        this->dwFlags2 & __FLAGS2_TEXGEN)
    {
        DWORD dwOutTextureSize;         // Used to compute output vertex size
        DWORD dwOutTextureFormat;       // Used to compute output texture FVF
        // There are texture transforms.
        // Now we find out if some of the texture coordinates are used two or more
        // times and used by a texture transform. In this case we have expand number
        // of output texture coordinates.
        ret = EvalTextureTransforms(this, dwTexTransform, &dwOutTextureSize, &dwOutTextureFormat);
        if (ret != D3D_OK)
            return ret;
        if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            // For ProcessVertices calls user should set texture stages and
            // wrap modes himself
            if (!(this->dwFlags & D3DPV_VBCALL))
            {
                // dwVIDIn is used to force re-compute FVF in the
                // SetTextureStageState. so we save and restore it.
                DWORD dwVIDInSaved = this->dwVIDIn;
                // Re-map indices in the texture stages and wrap modes
                DWORD dwOrgWrapModes[D3DDP_MAXTEXCOORD];
                memcpy(dwOrgWrapModes, &this->rstates[D3DRENDERSTATE_WRAP0], sizeof(dwOrgWrapModes));
                for (DWORD i=0; i < this->dwNumTextureStages; i++)
                {
                    LPD3DFE_TEXTURESTAGE pStage = &this->textureStage[i];
                    DWORD dwOutIndex = pStage->dwOutCoordIndex;
                    DWORD dwInpIndex = pStage->dwInpCoordIndex;
                    if (dwOutIndex != dwInpIndex || pStage->dwTexGenMode)
                    {
                        DWORD dwState = D3DRENDERSTATE_WRAP0 + dwOutIndex;
                        pStage->dwOrgWrapMode = dwOrgWrapModes[dwOutIndex];
                        DWORD dwValue = dwOrgWrapModes[dwInpIndex];
                        // We do not call UpdateInternaState because it
                        // will call ForceRecomputeFVF and we do not want this.
                        this->rstates[dwState] = dwValue;
                        this->SetRenderStateI((D3DRENDERSTATETYPE)dwState, dwValue);
                        // We do not call UpdateInternalTextureStageState because it
                        // will call ForceRecomputeFVF and we do not want this.
                        this->SetTSSI(pStage->dwOrgStage, D3DTSS_TEXCOORDINDEX, dwOutIndex);
                        // We do not call UpdateInternalTextureStageState because it
                        // will call ForceRecomputeFVF and we do not want this.
                        // We set some invalid value to the internal array, because otherwise
                        // a new SetTextureStageState could be filtered as redundant
                        tsstates[pStage->dwOrgStage][D3DTSS_TEXCOORDINDEX] = 0xFFFFFFFF;
                    }
                }
                this->dwVIDIn = dwVIDInSaved;
            }
            this->dwVIDOut |= dwOutTextureFormat;
            this->dwOutputSize += dwOutTextureSize;
            this->dwTextureCoordSizeTotal = dwOutTextureSize;
        }
        else
        {   // We do not do re-mapping but we have to make correspondence between
            // texture sets and texture transforms
            SetupTextureTransforms(this);

            //  Copy input texture formats
            this->dwVIDOut |= this->dwVIDIn & 0xFFFF0000;
            this->dwOutputSize += this->dwTextureCoordSizeTotal;
        }
    }
    else
    {
        //  Copy input texture formats
        this->dwVIDOut |= this->dwVIDIn & 0xFFFF0000;
        this->dwOutputSize += this->dwTextureCoordSizeTotal;
    }

    if (this->dwDeviceFlags & D3DDEV_DONOTSTRIPELEMENTS)
    {
        if (this->nOutTexCoord == 0 && !(this->dwFlags & D3DPV_VBCALL))
        {
            this->dwOutputSize += 2*sizeof(D3DVALUE);
            this->dwTextureCoordSize[0] = 0;
            this->dwVIDOut |= (1 << D3DFVF_TEXCOUNT_SHIFT);
        }
    }
    // Set up number of output texture coordinates
    this->dwVIDOut |= (this->nOutTexCoord << D3DFVF_TEXCOUNT_SHIFT);
    if (this->dwVIDOut & 0xFFFF0000 && this->deviceType < D3DDEVTYPE_DX7HAL)
    {
        D3D_ERR("Texture format bits in the output FVF for this device should be 0");
        return DDERR_INVALIDPARAMS;
    }

    // Set up vertex pointers
    if (!(this->dwFlags & D3DPV_VBCALL))
        UpdateGeometryLoopData(this);

    // In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden
    // by vertex alpha
    this->lighting.alpha = (DWORD)this->lighting.materialAlpha;
    this->lighting.alphaSpecular = (DWORD)this->lighting.materialAlphaS;

    this->dwFEFlags |= D3DFE_VERTEXBLEND_DIRTY;

    return D3D_OK;
}

#if DBG
void CDirect3DDeviceIDP2::ValidateVertex(LPDWORD lpdwVertex)
{
    if (FVF_TRANSFORMED(dp2data.dwVertexType))
    {
        float left, right, top, bottom;
        if (dwDeviceFlags & D3DDEV_GUARDBAND)
        {
            left   = lpD3DExtendedCaps->dvGuardBandLeft;
            right  = lpD3DExtendedCaps->dvGuardBandRight;
            top    = lpD3DExtendedCaps->dvGuardBandTop;
            bottom = lpD3DExtendedCaps->dvGuardBandBottom;
        }
        else
        {
            left   = (float)m_Viewport.dwX;
            top    = (float)m_Viewport.dwY;
            right  = (float)m_Viewport.dwX + m_Viewport.dwWidth;
            bottom = (float)m_Viewport.dwY + m_Viewport.dwHeight;
        }
        if (*(float*)lpdwVertex < left || *(float*)lpdwVertex++ > right)
            DPF_ERR("X coordinate out of range!");
        if (*(float*)lpdwVertex < top || *(float*)lpdwVertex++ > bottom)
            DPF_ERR("Y coordinate out of range!");
        if (rstates[D3DRENDERSTATE_ZENABLE] ||
            rstates[D3DRENDERSTATE_ZWRITEENABLE])
        {
            // Allow a little slack for those generating triangles exactly on the
            // depth limit.  Needed for Quake.
            if (*(float*)lpdwVertex < -0.00015f || *(float*)lpdwVertex++ > 1.00015f)
                DPF_ERR("Z coordinate out of range!");
        }
        if (FVF_TEXCOORD_NUMBER(dp2data.dwVertexType) > 0)
        {
            if (*(float*)lpdwVertex <= 0 )
            {
                DPF_ERR("RHW out of range!");
            }
        }
    }
}

void CDirect3DDeviceIDP2::ValidateCommand(LPD3DHAL_DP2COMMAND lpCmd)
{
    DWORD dwTexCoordSizeDummy[8];
    DWORD dwVertexSize = GetVertexSizeFVF(dp2data.dwVertexType) + ComputeTextureCoordSize(dp2data.dwVertexType, dwTexCoordSizeDummy);
    WORD wStart, wCount;
    switch (lpCmd->bCommand)
    {
    case D3DDP2OP_TRIANGLELIST:
        {
            LPD3DHAL_DP2TRIANGLELIST pTri = (LPD3DHAL_DP2TRIANGLELIST)(lpCmd + 1);
            wStart = pTri->wVStart;
            wCount =lpCmd->wPrimitiveCount * 3;
        }
        break;
    case D3DDP2OP_TRIANGLESTRIP:
    case D3DDP2OP_TRIANGLEFAN:
        {
            LPD3DHAL_DP2TRIANGLEFAN pFan = (LPD3DHAL_DP2TRIANGLEFAN)(lpCmd + 1);
            wStart = pFan->wVStart;
            wCount = lpCmd->wPrimitiveCount + 2;
        }
        break;
    case D3DDP2OP_TRIANGLEFAN_IMM:
        {
            wCount = lpCmd->wPrimitiveCount + 2;
            for (WORD i=0; i < wCount; ++i)
            {
                ValidateVertex((LPDWORD)((LPBYTE)(lpCmd + 1) + i * dwVertexSize));
            }
        }
        // Fall through
    default:
        return;
    }
    for (WORD i = wStart; i < wStart + wCount; ++i)
    {
        if( dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES )
            ValidateVertex((LPDWORD)((LPBYTE)(dp2data.lpVertices) + i * dwVertexSize));
        else
            ValidateVertex((LPDWORD)((LPBYTE)(dp2data.lpDDVertex->lpGbl->fpVidMem) + i * dwVertexSize));
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\dpgen.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpgen.h
 *  Content:    Generate some functions for Draw Primitive 
 *
 ***************************************************************************/

#ifdef __DRAWPRIMFUNC

//---------------------------------------------------------------------
// Draws indexed and non-indexed primitives which do not require clipping
//
#ifdef  __DRAWPRIMINDEX
HRESULT CDirect3DDeviceIDP::DrawIndexPrim()
{
    D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA dpData;
    DWORD &dwNumElements = this->dwNumIndices;
#else
HRESULT CDirect3DDeviceIDP::DrawPrim()
{
    D3DHAL_DRAWONEPRIMITIVEDATA dpData;
    DWORD &dwNumElements = this->dwNumVertices;
#endif
    const WORD vertexType = D3DVT_TLVERTEX;    // XXX While we do not have DDI
    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        HRESULT ret = UpdateTextures();
        if(ret != D3D_OK)
        {
            D3D_ERR("UpdateTextures failed. Device probably doesn't support current texture (check return code).");
            return ret;
        }
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    
    if (dwNumElements < LOWVERTICESNUMBERDP && 
        this->dwCurrentBatchVID == this->dwVIDOut)
    {
        LPD3DHAL_DRAWPRIMCOUNTS lpPC;
        lpPC = this->lpDPPrimCounts;
        if (lpPC->wNumVertices)
        {
            if ((lpPC->wPrimitiveType!=(WORD) this->primType) ||
                (lpPC->wVertexType != vertexType) ||
                (this->primType==D3DPT_TRIANGLESTRIP) ||
                (this->primType==D3DPT_TRIANGLEFAN) ||
                (this->primType==D3DPT_LINESTRIP))
            {
                lpPC = this->lpDPPrimCounts=(LPD3DHAL_DRAWPRIMCOUNTS)
                       ((LPBYTE)this->lpwDPBuffer + this->dwDPOffset);
                memset( (char *)lpPC, 0, sizeof(D3DHAL_DRAWPRIMCOUNTS));
                // preserve 32 bytes alignment for vertices
                this->dwDPOffset += sizeof(D3DHAL_DRAWPRIMCOUNTS);
                ALIGN32(this->dwDPOffset);
            }
        }
        else
        {
            // 32-byte align offset pointer, just in case states have been
            // recorded.
            ALIGN32(this->dwDPOffset);
        }
        ULONG ByteCount;
        if (FVF_DRIVERSUPPORTED(this))
            ByteCount = dwNumElements * this->dwOutputSize;
        else
            ByteCount = dwNumElements << 5;   // D3DTLVERTEX
        if (this->dwDPOffset + ByteCount  > this->dwDPMaxOffset)
        {
            CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));  // Takes D3D lock (ST only).
            //DPF(0,"overflowed ByteCount=%08lx",ByteCount);
            HRESULT ret;
            ret = this->FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in Draw*Prim");
                return ret;
            }
            lpPC = this->lpDPPrimCounts;
            ALIGN32(this->dwDPOffset);
        }
        lpPC->wPrimitiveType = (WORD)this->primType;
        lpPC->wVertexType = (WORD)vertexType;
        lpPC->wNumVertices += (WORD)dwNumElements;
        BYTE *lpVertex = (BYTE*)((char *)this->lpwDPBuffer + this->dwDPOffset);
#ifdef __DRAWPRIMINDEX
        DWORD  i;
        BYTE *pV = (BYTE*)this->lpvOut;
        if (FVF_DRIVERSUPPORTED(this) || this->dwVIDOut == D3DFVF_TLVERTEX)
            for (i=0; i < this->dwNumIndices; i++)
            {
                memcpy(lpVertex, pV + this->lpwIndices[i] * this->dwOutputSize,
                       this->dwOutputSize);
                lpVertex += this->dwOutputSize;
            }
        else
            for (i=0; i < this->dwNumIndices; i++)
            {
                MapFVFtoTLVertex1(this, (D3DTLVERTEX*)lpVertex, 
                                  (DWORD*)(pV + this->lpwIndices[i] * 
                                           this->dwOutputSize));
                lpVertex += sizeof(D3DTLVERTEX);
            }
#else // !__DRAWPRIMINDEX
        if (FVF_DRIVERSUPPORTED(this) || this->dwVIDOut == D3DFVF_TLVERTEX)
            memcpy(lpVertex, this->lpvOut, ByteCount);
        else
            MapFVFtoTLVertex(lpVertex);
#endif //__DRAWPRIMINDEX
        this->dwDPOffset += ByteCount;
        return D3D_OK;
    }
    else
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        HRESULT ret;
        ret = this->FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in Draw*Prim");
            return ret;
        }
        dpData.dwhContext = this->dwhContext;
        dpData.dwFlags =  this->dwFlags;
        dpData.PrimitiveType = this->primType;
        if (FVF_DRIVERSUPPORTED(this))
        {
            dpData.dwFVFControl = this->dwVIDOut;
            dpData.lpvVertices = this->lpvOut;
        }
        else
        {
            if (this->dwVIDOut == D3DFVF_TLVERTEX)
                dpData.lpvVertices = this->lpvOut;
            else
            {
                HRESULT ret;
#ifdef __DRAWPRIMINDEX
                if (this->dwNumIndices * INDEX_BATCH_SCALE < this->dwNumVertices)
                    ret = this->MapFVFtoTLVertexIndexed();
                else
#endif
                ret = MapFVFtoTLVertex(NULL);
                if (ret != D3D_OK)
                    return ret;
                dpData.lpvVertices = this->TLVbuf.GetAddress();
            }
            dpData.VertexType = (D3DVERTEXTYPE)vertexType;
            if (this->dwDebugFlags & D3DDEBUG_DISABLEFVF)
                dpData.dwFVFControl = D3DFVF_TLVERTEX;
        }
        dpData.dwNumVertices = this->dwNumVertices;
        dpData.ddrval = D3D_OK;
#ifdef __DRAWPRIMINDEX
        dpData.lpwIndices = this->lpwIndices;
        dpData.dwNumIndices = this->dwNumIndices;
#endif
        // Spin waiting on the driver if wait requested
#if _D3D_FORCEDOUBLE
        CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE
        do {
            DWORD dwRet;
        #ifndef WIN95
            if((dwRet = CheckContextSurface(this)) != D3D_OK)
            {
                return (dwRet);
            }
        #endif //WIN95
#ifdef __DRAWPRIMINDEX
            CALL_HAL2ONLY(dwRet, this, DrawOneIndexedPrimitive, &dpData);
#else
            CALL_HAL2ONLY(dwRet, this, DrawOnePrimitive, &dpData);
#endif
            if (dwRet != DDHAL_DRIVER_HANDLED)
            {
                D3D_ERR ( "Driver not handled in DrawOnePrimitive" );
                // Need sensible return value in this case,
                // currently we return whatever the driver stuck in here.
            }

        } while ( (this->dwFlags & D3DDP_WAIT) && (dpData.ddrval == DDERR_WASSTILLDRAWING) );
    }
    return dpData.ddrval;
}

#endif //__DRAWPRIMFUNC

#undef __DRAWPRIMFUNC
#undef __DRAWPRIMINDEX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\drawprim.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphal.c
 *  Content:    DrawPrimitive implementation for DrawPrimitive HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "clipfunc.h"
#include "d3dfei.h"

#ifndef WIN95
#include <ntgdistr.h>
#endif

#define ALIGN32(x) x = ((DWORD)(x + 31)) & (~31);
//---------------------------------------------------------------------
// Handles strides and FVF
//
#undef DPF_MODNAME
#define DPF_MODNAME "D3DFE_updateExtents"

void D3DFE_updateExtents(LPDIRECT3DDEVICEI lpDevI)
{
    int i;
    D3DVECTOR *v = (D3DVECTOR*)lpDevI->position.lpvData;
    DWORD stride = lpDevI->position.dwStride;
    for (i = lpDevI->dwNumVertices; i; i--)
    {
        if (v->x < lpDevI->rExtents.x1)
            lpDevI->rExtents.x1 = v->x;
        if (v->x > lpDevI->rExtents.x2)
            lpDevI->rExtents.x2 = v->x;
        if (v->y < lpDevI->rExtents.y1)
            lpDevI->rExtents.y1 = v->y;
        if (v->y > lpDevI->rExtents.y2)
            lpDevI->rExtents.y2 = v->y;
        v = (D3DVECTOR*)((char*)v + stride);
    }
}
#if DBG
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckDrawPrimitive"

HRESULT CheckDrawPrimitive(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_PROCESSVERTICES* data = lpDevI;
    HRESULT ret = CheckDeviceSettings(lpDevI);
    if (ret != D3D_OK)
        return ret;
    if (!data->dwNumVertices)
    {
        D3D_ERR( "Invalid dwNumVertices in DrawPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    if(data->position.lpvData==NULL) {
        D3D_ERR( "Invalid lpvVertices param in DrawPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    switch (data->primType)
    {
    case D3DPT_POINTLIST:
                break;
    case D3DPT_LINELIST:
        if (data->dwNumVertices & 1)
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_LINESTRIP:
        if (data->dwNumVertices == 1)
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (data->dwNumVertices < 3)
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLELIST:
        if ( (data->dwNumVertices % 3) != 0 )
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    default:
        D3D_ERR( "Unknown or unsupported primitive type requested of DrawPrimitive" );
        return D3DERR_INVALIDPRIMITIVETYPE;
    }
    if (lpDevI->dwNumVertices > MAX_DX6_VERTICES)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K vertices");
        return D3DERR_TOOMANYVERTICES;
    }

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckDrawIndexedPrimitive"

HRESULT
CheckDrawIndexedPrimitive(LPDIRECT3DDEVICEI lpDevI, DWORD dwStartVertex)
{
    D3DFE_PROCESSVERTICES *data = lpDevI;
    DWORD i;

    HRESULT ret = CheckDeviceSettings(lpDevI);
    if (ret != D3D_OK)
        return ret;
    if (data->dwNumVertices <= 0 || data->dwNumIndices <= 0)
    {
        D3D_ERR( "Invalid dwNumVertices or dwNumIndices in DrawIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    if (data->dwNumVertices > 65535ul )
    {
        D3D_ERR( "DrawIndexedPrimitive vertex array > 64K" );
        return DDERR_INVALIDPARAMS;
    }

    if((data->lpwIndices==NULL) || IsBadReadPtr(data->lpwIndices,data->dwNumIndices*sizeof(WORD))) {
        D3D_ERR( "Invalid lpwIndices param in DrawIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    if(data->position.lpvData==NULL) {
        D3D_ERR( "Invalid lpvVertices param in DrawIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    switch (data->primType)
    {
    case D3DPT_LINELIST:
        if (data->dwNumIndices & 1)
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_LINESTRIP:
        if (data->dwNumIndices == 1)
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (data->dwNumIndices < 3)
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLELIST:
        if ( (data->dwNumIndices % 3) != 0 )
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    default:
        D3D_ERR( "Unknown or unsupported primitive type requested of DrawIndexedPrimitive" );
        return D3DERR_INVALIDPRIMITIVETYPE;
    }
    for (i=0; i < data->dwNumIndices; i++)
    {
        if (data->lpwIndices[i] >= data->dwNumVertices)
        {
            D3D_ERR( "Invalid index value in DrawIndexedPrimitive" );
            return DDERR_INVALIDPARAMS;
        }
    }
    if (lpDevI->dwNumPrimitives > MAX_DX6_PRIMCOUNT)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K sized primitives");
        return D3DERR_TOOMANYPRIMITIVES;
    }
    if (lpDevI->dwNumIndices * INDEX_BATCH_SCALE < lpDevI->dwNumVertices &&
        !FVF_TRANSFORMED(lpDevI->dwVIDIn))
    {
        D3D_WARN(1, "The number of indices is much less than the number of vertices.");
        D3D_WARN(1, "This will likely be inefficient. Consider using vertex buffers.");
    }
    return D3D_OK;
}
#endif // DBG
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoDrawPrimitive"

HRESULT DoDrawPrimitive(LPD3DFE_PROCESSVERTICES pv)
{
    HRESULT ret;

    if (!CheckIfNeedClipping(pv))
        return pv->DrawPrim();

    // Preserve primitive type for large begin-end primitives
    // Primitive type could be changed by the clipper
    D3DPRIMITIVETYPE oldPrimType = pv->primType;
    switch (pv->primType)
    {
    case D3DPT_POINTLIST:
        ret = ProcessClippedPoints(pv);
        break;
    case D3DPT_LINELIST:
        ret = ProcessClippedLine(pv);
        break;
    case D3DPT_LINESTRIP:
        ret = ProcessClippedLine(pv);
        break;
    case D3DPT_TRIANGLELIST:
        ret = ProcessClippedTriangleList(pv);
        break;
    case D3DPT_TRIANGLESTRIP:
        ret = ProcessClippedTriangleStrip(pv);
        break;
    case D3DPT_TRIANGLEFAN:
        ret = ProcessClippedTriangleFan(pv);
        break;
    default:
        D3D_ERR( "Unknown primitive type in DrawPrimitive" );
        ret = DDERR_GENERIC;
        break;
    }
    ClampExtents(pv);
    pv->primType = oldPrimType;
    return ret;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoDrawIndexedPrimitive"

HRESULT DoDrawIndexedPrimitive(LPD3DFE_PROCESSVERTICES pv)
{
    HRESULT ret;

    if (!CheckIfNeedClipping(pv))
        return pv->DrawIndexPrim();

    // Preserve primitive type for large begin-end primitives
    // Primitive type could be changed by the clipper
    D3DPRIMITIVETYPE oldPrimType = pv->primType;
    switch (pv->primType)
    {
    case D3DPT_LINELIST:
        ret = ProcessClippedIndexedLine(pv);
        break;
    case D3DPT_LINESTRIP:
        ret = ProcessClippedIndexedLine(pv);
        break;
    case D3DPT_TRIANGLELIST:
        ret = ProcessClippedIndexedTriangleList(pv);
            break;
    case D3DPT_TRIANGLEFAN:
        ret = ProcessClippedIndexedTriangleFan(pv);
        break;
    case D3DPT_TRIANGLESTRIP:
        ret = ProcessClippedIndexedTriangleStrip(pv);
        break;
    default:
        break;
    }
    ClampExtents(pv);
    pv->primType = oldPrimType;
    return ret;
}
//---------------------------------------------------------------------
//                              API calls
//---------------------------------------------------------------------

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveStrided"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawPrimitiveStrided(
                             D3DPRIMITIVETYPE PrimitiveType,
                             DWORD dwVertexType,
                             LPD3DDRAWPRIMITIVESTRIDEDDATA lpDrawData,
                             DWORD dwNumVertices,
                             DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
        if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
            return DDERR_INVALIDPARAMS;
        Profile(PROF_DRAWPRIMITIVESTRIDED,PrimitiveType,dwVertexType);
#endif
    //note: this check should be done in retail as well as dbg build
        if((dwVertexType & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
            return D3DERR_INVALIDVERTEXTYPE;
        this->primType = PrimitiveType;
        this->position = lpDrawData->position;
        this->normal = lpDrawData->normal;
        this->diffuse = lpDrawData->diffuse;
        this->specular = lpDrawData->specular;
        this->dwNumVertices = dwNumVertices;
        this->dwFlags = dwFlags;
        if (this->dwVIDIn != dwVertexType || !(this->dwDeviceFlags & D3DDEV_STRIDE))
        {
            this->dwDeviceFlags |= D3DDEV_STRIDE;
            this->dwVIDIn  = dwVertexType;
            ret = this->SetupFVFData(NULL);
            if (ret != D3D_OK)
                return ret;
        }
        for (DWORD i=0; i < this->nTexCoord; i++)
            this->textures[i] = lpDrawData->textureCoords[i];

        GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives and update stats

#if DBG
        ret = CheckDrawPrimitive(this);

        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        return this->ProcessPrimitive();
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}   // end of DrawPrimitiveStrided()
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitiveStrided"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawIndexedPrimitiveStrided(
                                 D3DPRIMITIVETYPE PrimitiveType,
                                 DWORD dwVertexType,
                                 LPD3DDRAWPRIMITIVESTRIDEDDATA lpDrawData,
                                 DWORD dwNumVertices,
                                 LPWORD lpwIndices,
                                 DWORD dwNumIndices,
                                 DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    
#if DBG
        if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
            return DDERR_INVALIDPARAMS;
        Profile(PROF_DRAWINDEXEDPRIMITIVESTRIDED,PrimitiveType,dwVertexType);
#endif
        //note: this check should be done in retail as well as dbg build
        if((dwVertexType & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
            return D3DERR_INVALIDVERTEXTYPE;
        this->primType = PrimitiveType;
        this->position = lpDrawData->position;
        this->normal = lpDrawData->normal;
        this->diffuse = lpDrawData->diffuse;
        this->specular = lpDrawData->specular;
        this->dwNumVertices = dwNumVertices;
        this->lpwIndices = lpwIndices;
        this->dwNumIndices = dwNumIndices;
        this->dwFlags = dwFlags;
        if (this->dwVIDIn != dwVertexType || !(this->dwDeviceFlags & D3DDEV_STRIDE))
        {
            this->dwDeviceFlags |= D3DDEV_STRIDE;
            this->dwVIDIn  = dwVertexType;
            ret = this->SetupFVFData(NULL);
            if (ret != D3D_OK)
                return ret;
        }
        for (DWORD i=0; i < this->nTexCoord; i++)
            this->textures[i] = lpDrawData->textureCoords[i];
        GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats

#if DBG
        ret = CheckDrawIndexedPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        return this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}   // end of DrawIndexedPrimitiveStrided()
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitive3"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                               DWORD dwVertexType,
                               LPVOID lpvVertices,
                               DWORD dwNumVertices,
                               DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
        if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
            return DDERR_INVALIDPARAMS;
        Profile(PROF_DRAWPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif

        /* This stuff is mandatory for the call */
        this->primType = PrimitiveType;
        this->position.lpvData = lpvVertices;
        this->dwNumVertices = dwNumVertices;
        this->dwFlags = dwFlags;
        /* This stuff depends upon the vertex type */
        if (this->dwVIDIn != dwVertexType || this->dwDeviceFlags & D3DDEV_STRIDE)
        {
            this->dwDeviceFlags &= ~D3DDEV_STRIDE;
            this->dwVIDIn  = dwVertexType;
            ret = SetupFVFData(&this->position.dwStride);
            if (ret != D3D_OK)
            {
                return ret;
            }
        }
        GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives and update stats

#if DBG
        ret = CheckDrawPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        return this->ProcessPrimitive();
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::DrawIndexedPrimitive"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawIndexedPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                                      DWORD  dwVertexType,
                                      LPVOID lpvVertices, DWORD dwNumVertices,
                                      LPWORD lpwIndices, DWORD dwNumIndices,
                                      DWORD dwFlags)
{
    HRESULT ret = D3D_OK;

    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
        if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
            return DDERR_INVALIDPARAMS;
        Profile(PROF_DRAWINDEXEDPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif
        // Mandatory part
        this->primType = PrimitiveType;
        this->dwNumVertices = dwNumVertices;
        this->lpwIndices = lpwIndices;
        this->dwNumIndices = dwNumIndices;
        this->dwFlags = dwFlags;
        this->position.lpvData = lpvVertices;

        // Stuff that depends upon dwVIDIn
        if (this->dwVIDIn != dwVertexType || this->dwDeviceFlags & D3DDEV_STRIDE)
        {
            this->dwDeviceFlags &= ~D3DDEV_STRIDE;
            this->dwVIDIn  = dwVertexType;
            ret = SetupFVFData(&this->position.dwStride);
            if (ret != D3D_OK)
            {
                return ret;
            }
        }
        GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats

#if DBG
        ret = CheckDrawIndexedPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        return this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#ifdef VTABLE_HACK
//----------------------------------------------------------------------
// Dedicated DrawPrimitive Implementation for TL vertex case
// Assumptions:
// No clipping
// No extents update
// Single threaded app
// No state change since last call
// no FVF change since last call
//
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveTL"

HRESULT D3DAPI
CDirect3DDeviceIDP2::DrawPrimitiveTL(D3DPRIMITIVETYPE PrimitiveType,
                               DWORD dwVertexType,
                               LPVOID lpvVertices,
                               DWORD dwNumVertices,
                               DWORD dwFlags)
{
    HRESULT        ret;
#if DBG
    if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif
    /* Make sure we can use the fast path */
    if (this->dwVIDIn != dwVertexType || 
        this->dwDeviceFlags & D3DDEV_STRIDE || 
        dwNumVertices >= LOWVERTICESNUMBER)
    {
        VtblDrawPrimitiveDefault();
        return DrawPrimitive(PrimitiveType, dwVertexType, lpvVertices, dwNumVertices, dwFlags);
    }
    /* This stuff is mandatory for the call */
    this->primType = PrimitiveType;
    this->dwFlags = dwFlags;
    this->dwNumVertices = dwNumVertices;
    GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives
#if DBG
    this->position.lpvData = lpvVertices;
    ret = CheckDrawPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
#endif

    DWORD vertexPoolSize = dwNumVertices * this->dwOutputSize;
    if (vertexPoolSize > this->TLVbuf_GetSize())
    {
//        try
//        {
            if (this->TLVbuf_Grow(vertexPoolSize, true) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
/*        }
        catch (HRESULT ret)
        {
            return ret;
        }
*/    }
    this->dwVertexBase = this->dwDP2VertexCount;
    DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
    this->dwDP2VertexCount = this->dwVertexBase + dwNumVertices;
    memcpy(this->TLVbuf_GetAddress(), lpvVertices, vertexPoolSize);
//    try
//    {
        ret = this->DrawPrim();
/*    }
    catch (HRESULT ret)
    {
        return ret;
    }
*/
    this->TLVbuf_Base() += vertexPoolSize;
    DDASSERT(TLVbuf_base <= TLVbuf_size);
    DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
    return ret;
}
//----------------------------------------------------------------------
// Dedicated DrawIndexedPrimitive Implementation for TL vertex case
// Assumptions:
// No clipping
// No extents update
// Single threaded app
// No state change since last call
// no FVF change since last call
//
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitiveTL"

HRESULT D3DAPI
CDirect3DDeviceIDP2::DrawIndexedPrimitiveTL(D3DPRIMITIVETYPE PrimitiveType,
                                      DWORD  dwVertexType,
                                      LPVOID lpvVertices, DWORD dwNumVertices,
                                      LPWORD lpwIndices, DWORD dwNumIndices,
                                      DWORD dwFlags)
{
    HRESULT        ret;
#if DBG
        if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
            return DDERR_INVALIDPARAMS;
        Profile(PROF_DRAWINDEXEDPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif
    /* Make sure we can use the fast path */
    if (this->dwVIDIn != dwVertexType || 
        this->dwDeviceFlags & D3DDEV_STRIDE || 
        dwNumVertices >= LOWVERTICESNUMBER)
    {
        VtblDrawIndexedPrimitiveDefault();
        return DrawIndexedPrimitive(PrimitiveType, dwVertexType, lpvVertices, 
            dwNumVertices, lpwIndices, dwNumIndices, dwFlags);
    }
    /* This stuff is mandatory for the call */
    this->primType = PrimitiveType;
    this->dwFlags = dwFlags;
    this->lpwIndices = lpwIndices;
    this->dwNumIndices = dwNumIndices;
    this->dwNumVertices = dwNumVertices;
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives
#if DBG
    this->position.lpvData = lpvVertices;
    ret = CheckDrawIndexedPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
#endif

    DWORD vertexPoolSize = dwNumVertices * this->dwOutputSize;
    if (vertexPoolSize > this->TLVbuf_GetSize())
    {
//        try
//        {
            if (this->TLVbuf_Grow(vertexPoolSize, true) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
/*        }
        catch (HRESULT ret)
        {
            return ret;
        }
*/    }
    this->dwVertexBase = this->dwDP2VertexCount;
    DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
    this->dwDP2VertexCount = this->dwVertexBase + dwNumVertices;
    memcpy(this->TLVbuf_GetAddress(), lpvVertices, vertexPoolSize);
//    try
//    {
        ret = this->DrawIndexPrim();
/*    }
    catch (HRESULT ret)
    {
        return ret;
    }
*/
    this->TLVbuf_Base() += vertexPoolSize;
    DDASSERT(TLVbuf_base <= TLVbuf_size);
    DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
    return ret;
}
//----------------------------------------------------------------------
// Dedicated DrawPrimitive Implementation for non-TL vertex case
// Assumptions:
// Single threaded app
// No state change since last call
// no FVF change since last call
//
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveFE"

HRESULT D3DAPI
CDirect3DDeviceIDP2::DrawPrimitiveFE(D3DPRIMITIVETYPE PrimitiveType,
                               DWORD dwVertexType,
                               LPVOID lpvVertices,
                               DWORD dwNumVertices,
                               DWORD dwFlags)
{
    HRESULT        ret;
#if DBG
    if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif
    /* Make sure we can use the fast path */
    if (this->dwVIDIn != dwVertexType || 
        this->dwDeviceFlags & D3DDEV_STRIDE || 
        this->dwFEFlags & D3DFE_FRONTEND_DIRTY)
    {
        VtblDrawPrimitiveDefault();
        return DrawPrimitive(PrimitiveType, dwVertexType, lpvVertices, dwNumVertices, dwFlags);
    }
    /* This stuff is mandatory for the call */
    this->primType = PrimitiveType;
    this->dwFlags = this->dwLastFlags | dwFlags;
    this->dwNumVertices = dwNumVertices;
    this->position.lpvData = lpvVertices;
#if DBG
    GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives
    ret = CheckDrawPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
#endif

    this->dwVertexPoolSize = dwNumVertices * this->dwOutputSize;
    if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
    {
//         try
//         {
            if (this->TLVbuf_Grow(this->dwVertexPoolSize, true) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
//         }
//         catch (HRESULT ret)
//         {
//             return ret;
//         }
    }
    if (dwNumVertices * sizeof(D3DFE_CLIPCODE) > this->HVbuf.GetSize())
    {
        if (this->HVbuf.Grow(dwNumVertices * sizeof(D3DFE_CLIPCODE)) != D3D_OK)
        {
            D3D_ERR( "Could not grow clip buffer" );
            ret = DDERR_OUTOFMEMORY;
            return ret;
        }
        this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
    }
    this->dwVertexBase = this->dwDP2VertexCount;
    DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
    this->dwDP2VertexCount = this->dwVertexBase + dwNumVertices;
    this->lpvOut = this->TLVbuf_GetAddress();
//    try
//    {
        switch (this->primType)
        {
        case D3DPT_POINTLIST:
            this->dwNumPrimitives = dwNumVertices;
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
            break;
        case D3DPT_LINELIST:
            this->dwNumPrimitives = dwNumVertices >> 1;
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
            break;
        case D3DPT_LINESTRIP:
            this->dwNumPrimitives = dwNumVertices - 1;
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
            break;
        case D3DPT_TRIANGLEFAN:
            this->dwNumPrimitives = dwNumVertices - 2;
            ret = this->pGeometryFuncs->ProcessTriangleFan(this);
            break;
        case D3DPT_TRIANGLESTRIP:
            this->dwNumPrimitives = dwNumVertices - 2;
            ret = this->pGeometryFuncs->ProcessTriangleStrip(this);
            break;
        case D3DPT_TRIANGLELIST:
    #ifdef _X86_
            {
                DWORD tmp;
                __asm
                {
                    mov  eax, 0x55555555    // fractional part of 1.0/3.0
                    mul  dwNumVertices
                    add  eax, 0x80000000    // Rounding
                    adc  edx, 0
                    mov  tmp, edx
                }
                this->dwNumPrimitives = tmp;
            }
    #else
            this->dwNumPrimitives = dwNumVertices / 3;
    #endif
            ret = this->pGeometryFuncs->ProcessTriangleList(this);
            break;
        }
/*    }
    catch (HRESULT ret)
    {
        return ret;
    }*/
    D3DFE_UpdateClipStatus(this);
    this->TLVbuf_Base() += this->dwVertexPoolSize;
    DDASSERT(TLVbuf_base <= TLVbuf_size);
    DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
    return ret;
}
//----------------------------------------------------------------------
// Dedicated DrawIndexedPrimitive Implementation for non-TL vertex case
// Assumptions:
// Single threaded app
// No state change since last call
// no FVF change since last call
//
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitiveFE"

HRESULT D3DAPI
CDirect3DDeviceIDP2::DrawIndexedPrimitiveFE(D3DPRIMITIVETYPE PrimitiveType,
                                      DWORD  dwVertexType,
                                      LPVOID lpvVertices, DWORD dwNumVertices,
                                      LPWORD lpwIndices, DWORD dwNumIndices,
                                      DWORD dwFlags)
{
    HRESULT        ret;
#if DBG
        if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
            return DDERR_INVALIDPARAMS;
        Profile(PROF_DRAWINDEXEDPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif
    /* Make sure we can use the fast path */
    if (this->dwVIDIn != dwVertexType || 
        this->dwDeviceFlags & D3DDEV_STRIDE || 
        this->dwFEFlags & D3DFE_FRONTEND_DIRTY)
    {
        VtblDrawIndexedPrimitiveDefault();
        return DrawIndexedPrimitive(PrimitiveType, dwVertexType, lpvVertices, 
            dwNumVertices, lpwIndices, dwNumIndices, dwFlags);
    }
    /* This stuff is mandatory for the call */
    this->primType = PrimitiveType;
    this->dwFlags = this->dwLastFlags | dwFlags;
    this->lpwIndices = lpwIndices;
    this->dwNumIndices = dwNumIndices;
    this->dwNumVertices = dwNumVertices;
    this->position.lpvData = lpvVertices;
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives
#if DBG
    ret = CheckDrawIndexedPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
#endif

    this->dwVertexPoolSize = dwNumVertices * this->dwOutputSize;
    if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
    {
//         try
//         {
            if (this->TLVbuf_Grow(this->dwVertexPoolSize, 
                (this->dwDeviceFlags & D3DDEV_DONOTCLIP)!=0) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
//         }
//         catch (HRESULT ret)
//         {
//             return ret;
//         }
    }
    if (dwNumVertices * sizeof(D3DFE_CLIPCODE) > this->HVbuf.GetSize())
    {
        if (this->HVbuf.Grow(dwNumVertices * sizeof(D3DFE_CLIPCODE)) != D3D_OK)
        {
            D3D_ERR( "Could not grow clip buffer" );
            ret = DDERR_OUTOFMEMORY;
            return ret;
        }
        this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
    }
    this->dwVertexBase = this->dwDP2VertexCount;
    DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
    this->dwDP2VertexCount = this->dwVertexBase + dwNumVertices;
    this->lpvOut = this->TLVbuf_GetAddress();
//    try
//    {
        ret = this->pGeometryFuncs->ProcessIndexedPrimitive(this);
/*    }
    catch (HRESULT ret)
    {
        return ret;
    }*/
    D3DFE_UpdateClipStatus(this);
    this->TLVbuf_Base() += this->dwVertexPoolSize;
    DDASSERT(TLVbuf_base <= TLVbuf_size);
    DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
    return ret;
}
#endif
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::ComputeSphereVisibility"

HRESULT D3DAPI
DIRECT3DDEVICEI::ComputeSphereVisibility(LPD3DVECTOR lpCenters,
                                         LPD3DVALUE lpRadii,
                                         DWORD dwNumSpheres,
                                         DWORD dwFlags,
                                         LPDWORD lpdwReturnValues)
{
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
        if (dwFlags != 0 || dwNumSpheres == 0 ||
            IsBadWritePtr(lpdwReturnValues, dwNumSpheres * sizeof(DWORD)) ||
            IsBadWritePtr(lpRadii, dwNumSpheres * sizeof(D3DVALUE)) ||
            IsBadWritePtr(lpCenters, dwNumSpheres * sizeof(LPD3DVECTOR)))
        {
            return DDERR_INVALIDPARAMS;
        }
#endif

        this->dwFlags = 0;
        if (this->dwFEFlags & (D3DFE_TRANSFORM_DIRTY | D3DFE_CLIPPLANES_DIRTY))
        {
            DoUpdateState(this);
        }
        return this->pGeometryFuncs->ComputeSphereVisibility(this,
                                                              lpCenters,
                                                              lpRadii,
                                                              dwNumSpheres,
                                                              dwFlags,
                                                              lpdwReturnValues);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ID3DFE_PVFUNCS::ComputeSphereVisibility"

HRESULT
D3DFE_PVFUNCS::ComputeSphereVisibility(LPD3DFE_PROCESSVERTICES pv,
                                       LPD3DVECTOR lpCenters,
                                       LPD3DVALUE lpRadii,
                                       DWORD dwNumSpheres,
                                       DWORD dwFlags,
                                       LPDWORD lpdwReturnValues)
{
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(pv);

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    for (DWORD i=0; i < dwNumSpheres; i++)
    {
        const D3DVALUE x = lpCenters[i].x;
        const D3DVALUE y = lpCenters[i].y;
        const D3DVALUE z = lpCenters[i].z;
        const D3DVALUE r = lpRadii[i];
        const D3DVALUE xmin = x-r;
        const D3DVALUE ymin = y-r;
        const D3DVALUE zmin = z-r;
        const D3DVALUE xmax = x+r;
        const D3DVALUE ymax = y+r;
        const D3DVALUE zmax = z+r;

        D3DVECTOR v[8] = 
        {
            {xmin, ymin, zmin},
            {xmax, ymin, zmin},
            {xmin, ymax, zmin},
            {xmax, ymax, zmin},
            {xmin, ymin, zmax},
            {xmax, ymin, zmax},
            {xmin, ymax, zmax},
            {xmax, ymax, zmax}
        };
        DWORD dwClipUnion =0;
        DWORD dwClipIntersection = ~0;
        lpDevI->CheckClipStatus((D3DVALUE*)v, sizeof(D3DVECTOR), 8, 
                                 &dwClipUnion, &dwClipIntersection);

        lpdwReturnValues[i] = dwClipUnion +  (dwClipIntersection << 12);
    }
    return D3D_OK;
}
/*
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ID3DFE_PVFUNCS::ComputeSphereVisibility"

HRESULT
D3DFE_PVFUNCS::ComputeSphereVisibility(LPD3DFE_PROCESSVERTICES pv,
                                       LPD3DVECTOR lpCenters,
                                       LPD3DVALUE lpRadii,
                                       DWORD dwNumSpheres,
                                       DWORD dwFlags,
                                       LPDWORD lpdwReturnValues)
{
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(pv);
    HRESULT ret = D3DERR_INVALIDMATRIX;

#define transform lpDevI->transform

    if (pv->dwFlags & D3DPV_FRUSTUMPLANES_DIRTY)
    {
        transform.dwFlags &= ~D3DTRANS_VALIDFRUSTUM;
        if (Inverse4x4((D3DMATRIX*)&lpDevI->mCTM,
                       (D3DMATRIX*)&transform.mCTMI))
        {
            D3D_ERR("Cannot invert current (World X View) matrix.");
            return ret;
        }
        // Transform the following clipping volume points to the model space by
        // multiplying by inverse CTM
        //
        // v1 = { 0, 0, 0, 1};
        // v2 = { 1, 0, 0, 1};
        // v3 = { 1, 1, 0, 1};
        // v4 = { 0, 1, 0, 1};
        // v5 = { 0, 0, 1, 1};
        // v6 = { 1, 0, 1, 1};
        // v7 = { 0, 1, 1, 1};
        //
        // We do it manually to speed up
        //
        D3DVECTORH v1 = {transform.mCTMI._41,
                         transform.mCTMI._42,
                         transform.mCTMI._43,
                         transform.mCTMI._44};
        D3DVECTORH v2 = {transform.mCTMI._11 + transform.mCTMI._41,
                         transform.mCTMI._12 + transform.mCTMI._42,
                         transform.mCTMI._13 + transform.mCTMI._43,
                         transform.mCTMI._14 + transform.mCTMI._44};
        D3DVECTORH v3 = {transform.mCTMI._11 + transform.mCTMI._21 + transform.mCTMI._41,
                         transform.mCTMI._12 + transform.mCTMI._22 + transform.mCTMI._42,
                         transform.mCTMI._13 + transform.mCTMI._23 + transform.mCTMI._43,
                         transform.mCTMI._14 + transform.mCTMI._24 + transform.mCTMI._44};
        D3DVECTORH v4 = {transform.mCTMI._21 + transform.mCTMI._41,
                         transform.mCTMI._22 + transform.mCTMI._42,
                         transform.mCTMI._23 + transform.mCTMI._43,
                         transform.mCTMI._24 + transform.mCTMI._44};
        D3DVECTORH v5 = {transform.mCTMI._31 + transform.mCTMI._41,
                         transform.mCTMI._32 + transform.mCTMI._42,
                         transform.mCTMI._33 + transform.mCTMI._43,
                         transform.mCTMI._34 + transform.mCTMI._44};
        D3DVECTORH v6 = {transform.mCTMI._11 + transform.mCTMI._31 + transform.mCTMI._41,
                         transform.mCTMI._12 + transform.mCTMI._32 + transform.mCTMI._42,
                         transform.mCTMI._13 + transform.mCTMI._33 + transform.mCTMI._43,
                         transform.mCTMI._14 + transform.mCTMI._34 + transform.mCTMI._44};
        D3DVECTORH v7 = {transform.mCTMI._21 + transform.mCTMI._31 + transform.mCTMI._41,
                         transform.mCTMI._22 + transform.mCTMI._32 + transform.mCTMI._42,
                         transform.mCTMI._23 + transform.mCTMI._33 + transform.mCTMI._43,
                         transform.mCTMI._24 + transform.mCTMI._34 + transform.mCTMI._44};

        // Convert vectors from homogeneous to 3D
        if (Vector4to3D(&v1))
            goto exit;
        if (Vector4to3D(&v2))
            goto exit;
        if (Vector4to3D(&v3))
            goto exit;
        if (Vector4to3D(&v4))
            goto exit;
        if (Vector4to3D(&v5))
            goto exit;
        if (Vector4to3D(&v6))
            goto exit;
        if (Vector4to3D(&v7))
            goto exit;
        // Build frustum planes
        // Left
        if (MakePlane((D3DVECTOR*)&v1, (D3DVECTOR*)&v4, (D3DVECTOR*)&v5, &transform.frustum[0]))
            goto exit;
        // Right
        if (MakePlane((D3DVECTOR*)&v2, (D3DVECTOR*)&v6, (D3DVECTOR*)&v3, &transform.frustum[1]))
            goto exit;
        // Top
        if (MakePlane((D3DVECTOR*)&v4, (D3DVECTOR*)&v3, (D3DVECTOR*)&v7, &transform.frustum[2]))
            goto exit;
        // Bottom
        if (MakePlane((D3DVECTOR*)&v1, (D3DVECTOR*)&v5, (D3DVECTOR*)&v2, &transform.frustum[3]))
            goto exit;
        // Near
        if (MakePlane((D3DVECTOR*)&v1, (D3DVECTOR*)&v2, (D3DVECTOR*)&v3, &transform.frustum[4]))
            goto exit;
        // Far
        if (MakePlane((D3DVECTOR*)&v6, (D3DVECTOR*)&v5, (D3DVECTOR*)&v7, &transform.frustum[5]))
            goto exit;

        transform.dwFlags |= D3DTRANS_VALIDFRUSTUM;
    }

    if (transform.dwFlags & D3DTRANS_VALIDFRUSTUM)
    {
        // Now we can check the spheres against the clipping planes

        for (DWORD i=0; i < dwNumSpheres; i++)
        {
            lpdwReturnValues[i] = CheckSphere(lpDevI, &lpCenters[i], lpRadii[i]);
        }
        return D3D_OK;
    }

exit:
    D3D_ERR("Non-orthogonal (world X view) matrix");
    return ret;
#undef transform
}
//---------------------------------------------------------------------
DWORD visResults[6][2] =
{
    D3DVIS_INTERSECT_LEFT   ,
    D3DVIS_OUTSIDE_LEFT     ,
    D3DVIS_INTERSECT_RIGHT  ,
    D3DVIS_OUTSIDE_RIGHT    ,
    D3DVIS_INTERSECT_TOP    ,
    D3DVIS_OUTSIDE_TOP      ,
    D3DVIS_INTERSECT_BOTTOM ,
    D3DVIS_OUTSIDE_BOTTOM   ,
    D3DVIS_INTERSECT_NEAR   ,
    D3DVIS_OUTSIDE_NEAR     ,
    D3DVIS_INTERSECT_FAR    ,
    D3DVIS_OUTSIDE_FAR
};
//---------------------------------------------------------------------
DWORD CheckSphere(LPDIRECT3DDEVICEI lpDevI, LPD3DVECTOR center, D3DVALUE radius)
{
    DWORD result = 0;
    for (int i=0; i < 6; i++)
    {
        // Compute a distance from the center to the plane
        D3DVALUE d = lpDevI->transform.frustum[i].x*center->x +
                     lpDevI->transform.frustum[i].y*center->y +
                     lpDevI->transform.frustum[i].z*center->z +
                     lpDevI->transform.frustum[i].w;
        if (d + radius < 0)
            result |= visResults[i][1];  // Outside
        else
        if (d - radius < 0)
            result |= visResults[i][0];  // Intersect
    }
    if (result & (D3DVIS_OUTSIDE_LEFT   |
                  D3DVIS_OUTSIDE_RIGHT  |
                  D3DVIS_OUTSIDE_TOP    |
                  D3DVIS_OUTSIDE_BOTTOM |
                  D3DVIS_OUTSIDE_NEAR   |
                  D3DVIS_OUTSIDE_FAR))
    {
        result |= D3DVIS_OUTSIDE_FRUSTUM;
    }
    else
    if (result)
        result |= D3DVIS_INTERSECT_FRUSTUM;

    return result;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\dpoldhal.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpoldhal.c
 *  Content:    DrawPrimitive implementation for legacy (DX2) HALs
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

#ifdef WIN95

#include "drawprim.hpp"
#include "clipfunc.h"
#include "commdrv.hpp"
#include "d3dfei.h"

extern D3DLINE LineListPrecomp[];
extern D3DLINE LineStripPrecomp[];
extern D3DTRIANGLE TriangleListPrecomp[];
extern D3DTRIANGLE TriangleStripPrecomp[];
extern D3DTRIANGLE TriangleFanPrecomp[];

#define BFCULLTEST_TVertTri(TLV0,TLV1,TLV2) (((TLV1).sx-(TLV0).sx)*((TLV2).sy-(TLV0).sy) -  \
                                         ((TLV2).sx-(TLV0).sx)*((TLV1).sy-(TLV0).sy))

#define ISCULLED(lpDevI, CullTestRes) ((CullTestRes==0.0) ||   \
                                   ((lpDevI->rstates[D3DRENDERSTATE_CULLMODE]==D3DCULL_CW) ^ (CullTestRes < 0.0)))
//---------------------------------------------------------------------
void WaitForFlip( LPDIRECT3DDEVICEI lpDevI )
{
    if (! (lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwDevCaps  & D3DDEVCAPS_CANRENDERAFTERFLIP) )
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSTarget)->lpLcl;

        if (lpLcl->ddsCaps.dwCaps & DDSCAPS_FLIP) {
            HRESULT ret;
            D3D_INFO(5, "Waiting for flip");
            do {
                ret = lpDevI->lpDDSTarget->GetFlipStatus(DDGFS_ISFLIPDONE);
            } while (ret == DDERR_WASSTILLDRAWING);
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "FlushStatesHW"

HRESULT CDirect3DDeviceIHW::FlushStates(bool bWithinPrimitive)
{
    DWORD i;

    LPDWORD lpScan = (LPDWORD) this->lpwDPBuffer;
    LPD3DTRIANGLE lpTriScan = (LPD3DTRIANGLE) this->lpHWTris;

    DWORD dwRet;
    D3DHAL_RENDERSTATEDATA StateData;
    D3DHAL_RENDERPRIMITIVEDATA PrimitiveData;
    CDDSurfaceFromMem TLBuffer(NULL);
    CDDSurfaceFromMem ExeBuffer(lpTriScan);

    if (this->dwHWOffset == 0)    return D3D_OK;
    this->dwHWOffset = 0; //zeroed to prevent re-enter by drivers's locking surfaces

    ++m_qwBatch;
    // So that currently bound textures get rebatched
    for (DWORD dwStage = 0; dwStage < this->dwMaxTextureBlendStages; dwStage++)
    {
        LPDIRECT3DTEXTUREI lpTexI = this->lpD3DMappedTexI[dwStage];
        if (NULL != lpTexI)
        {
            if(lpTexI->lpDDS != NULL)
            {
                BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS))->lpLcl);
            }
        }
    }

    // Legacy HAL, therefore we have to wait
    // until the render target has flipped.
    WaitForFlip(this);

    // Pick up Win16 lock
    LOCK_HAL( dwRet, this );
    LOCK_DIBENGINE(dwRet, this);
#if _D3D_FORCEDOUBLE
    CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE

    memset(&StateData, 0, sizeof(StateData) );
    memset(&PrimitiveData, 0, sizeof(PrimitiveData) );

    // dwHWNumCounts is the number of recorded structs with
    // primitives attached.
    for (i = 0; i < this->dwHWNumCounts+1; i += 1)
    {


        if ( this->lpHWCounts[i].wNumStateChanges )
        {
            TLBuffer.SetBits(lpScan);

            StateData.dwhContext = this->dwhContext;
            StateData.dwOffset = 0;
            StateData.dwCount = this->lpHWCounts[i].wNumStateChanges;
            StateData.lpExeBuf = TLBuffer.GetSurface();
            dwRet = (*this->lpD3DHALCallbacks->RenderState)(&StateData);
            // No provision for NOT_HANDLED

            lpScan += 2*this->lpHWCounts[i].wNumStateChanges;
            lpScan = (LPDWORD) ( (((DWORD) lpScan) + 31) & ~31);
        }

        if ( this->lpHWCounts[i].wNumVertices )
        {

            TLBuffer.SetBits((LPD3DTLVERTEX) this->lpwDPBuffer);
            ExeBuffer.SetBits(lpTriScan);

            PrimitiveData.dwhContext = this->dwhContext;
            PrimitiveData.dwOffset = 0;
            PrimitiveData.dwStatus = 0;
            PrimitiveData.lpExeBuf = ExeBuffer.GetSurface();
            PrimitiveData.dwTLOffset = 0;
            PrimitiveData.lpTLBuf = TLBuffer.GetSurface();
            PrimitiveData.diInstruction.bOpcode = D3DOP_TRIANGLE;
            PrimitiveData.diInstruction.bSize = sizeof(D3DTRIANGLE);
            PrimitiveData.diInstruction.wCount = (WORD) this->lpHWCounts[i].wNumTriangles;
            dwRet = (*this->lpD3DHALCallbacks->RenderPrimitive)(&PrimitiveData);
            // No provision for NOT_HANDLED
            lpScan = (LPDWORD)(((LPD3DTLVERTEX) lpScan) + this->lpHWCounts[i].wNumVertices);
            lpTriScan += this->lpHWCounts[i].wNumTriangles;
        }
    }
    UNLOCK_DIBENGINE( this );
    UNLOCK_HAL( this );
    this->dwHWTriIndex = 0;
    this->dwHWNumCounts = 0;
    memset(this->lpHWCounts, 0, sizeof(D3DI_HWCOUNTS) );
        return  D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveLegacyHalCall"

HRESULT
DrawPrimitiveLegacyHalCall(CDirect3DDeviceIHW * lpDevI,
                           LPD3DTLVERTEX lpVertices, LPVOID lpvData,
                           LPD3DINSTRUCTION ins, DWORD dwNumVertices, D3DVERTEXTYPE VtxType)
{
    DWORD dwRet;
    CDDSurfaceFromMem TLBuffer(lpVertices);
    CDDSurfaceFromMem ExeBuffer(lpvData);
    D3DHAL_RENDERPRIMITIVEDATA rdata;

    memset(&rdata, 0, sizeof(rdata) );

    rdata.dwhContext = lpDevI->dwhContext;
    rdata.dwOffset = 0;
    rdata.dwStatus = 0;
    rdata.lpExeBuf = ExeBuffer.GetSurface();
    rdata.dwTLOffset = 0;
    rdata.lpTLBuf = TLBuffer.GetSurface();
    rdata.diInstruction = *ins;
#ifndef WIN95
    if((dwRet = CheckContextSurface(lpDevI)) != D3D_OK)
    {
        return (dwRet);
    }
#endif //WIN95
#if _D3D_FORCEDOUBLE
    CD3DForceFPUDouble  ForceFPUDouble(lpDevI);
#endif  //_D3D_FORCEDOUBLE
    CALL_HALONLY(dwRet, lpDevI, RenderPrimitive, &rdata);
    if (dwRet != DDHAL_DRIVER_HANDLED)
    {
        D3D_ERR ( "Driver not handled in DrawPrimitive" );
        // Need sensible return value in this case,
        // currently we return whatever the driver stuck in here.
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FillLegacyHalIndices"

void
FillLegacyHalIndices(D3DPRIMITIVETYPE PrimitiveType, LPVOID lpOut,
                     LPWORD lpwIndices, DWORD dwNumPrimitives)
{
    LPD3DLINE lpTmpLines;
    LPD3DTRIANGLE lpTmpTris;
    DWORD i;
    WORD wIndex = 0;

    switch (PrimitiveType)
    {
    case D3DPT_LINELIST:
        lpTmpLines = (LPD3DLINE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpLines[i].v1 = lpwIndices[wIndex++];
            lpTmpLines[i].v2 = lpwIndices[wIndex++];
        }
        break;
    case D3DPT_LINESTRIP:
        lpTmpLines = (LPD3DLINE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpLines[i].v1 = lpwIndices[wIndex++];
            lpTmpLines[i].v2 = lpwIndices[wIndex];
        }
        break;
    case D3DPT_TRIANGLELIST:
        lpTmpTris = (LPD3DTRIANGLE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpTris[i].v1 = lpwIndices[wIndex++];
            lpTmpTris[i].v2 = lpwIndices[wIndex++];
            lpTmpTris[i].v3 = lpwIndices[wIndex++];
            lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
        }

        break;
    case D3DPT_TRIANGLESTRIP:
        lpTmpTris = (LPD3DTRIANGLE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpTris[i].v1 = lpwIndices[wIndex++];
            lpTmpTris[i].v2 = lpwIndices[wIndex++];
            lpTmpTris[i].v3 = lpwIndices[wIndex++];
            lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            i++;
            if (i<dwNumPrimitives)
            {
                lpTmpTris[i].v1 = lpTmpTris[i-1].v2;
                lpTmpTris[i].v2 = lpwIndices[wIndex--];
                lpTmpTris[i].v3 = lpTmpTris[i-1].v3;
                lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        lpTmpTris = (LPD3DTRIANGLE) lpOut;
        lpTmpTris[0].v3 = lpwIndices[wIndex++];
        lpTmpTris[0].v1 = lpwIndices[wIndex++];
        lpTmpTris[0].v2 = lpwIndices[wIndex++];
        lpTmpTris[0].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
        for (i = 1; i < dwNumPrimitives; i += 1)
        {
            lpTmpTris[i].v1 = lpTmpTris[i-1].v2;
            lpTmpTris[i].v2 = lpwIndices[wIndex++];
            lpTmpTris[i].v3 = lpTmpTris[i-1].v3;
            lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
        }
        break;
    }
}


#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveInBatchesHW"

HRESULT
DrawPrimitiveInBatchesHW(CDirect3DDeviceIHW * lpDevI, D3DPRIMITIVETYPE PrimitiveType, D3DVERTEXTYPE VertexType, LPD3DTLVERTEX lpVertices, DWORD dwNumPrimitives)
{
    DWORD i;
    D3DTLVERTEX tmpV;
    LPD3DTLVERTEX lpFirstVertex;
    D3DINSTRUCTION ins;
    HRESULT ret;

    switch (PrimitiveType)
    {
    case D3DPT_LINELIST:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, LineListPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount*2;
        }
        break;
    case D3DPT_LINESTRIP:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, LineStripPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLELIST:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, TriangleListPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += 3*ins.wCount;
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, TriangleStripPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLEFAN:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        // Save the first vertex to spoof the driver
        lpFirstVertex = lpVertices;
        tmpV = lpVertices[0];
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            tmpV = *lpVertices;
            *lpVertices = *lpFirstVertex;
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, TriangleFanPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            *lpVertices = tmpV;
            lpVertices += ins.wCount;
        }
        break;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitiveInBatchesHW"

HRESULT
CDirect3DDeviceIHW::DrawIndexedPrimitiveInBatchesHW(
                                D3DPRIMITIVETYPE PrimitiveType,
                                D3DVERTEXTYPE VertexType,
                                LPD3DTLVERTEX lpVertices,
                                DWORD dwNumPrimitives,
                                LPWORD lpwIndices)
{
    DWORD i;
    WORD tmpW;
    LPWORD lpFirstIndex;
    D3DINSTRUCTION ins;
    HRESULT ret;

    switch (PrimitiveType)
    {
    case D3DPT_LINELIST:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            FillLegacyHalIndices(PrimitiveType, this->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(this, lpVertices, this->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpwIndices += ins.wCount*2;
        }
        break;
    case D3DPT_LINESTRIP:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            FillLegacyHalIndices(PrimitiveType, this->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(this, lpVertices, this->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLELIST:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            FillLegacyHalIndices(PrimitiveType, this->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(this, lpVertices, this->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpwIndices += 3*ins.wCount;
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            FillLegacyHalIndices(PrimitiveType, this->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(this, lpVertices, this->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpwIndices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLEFAN:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        // Save the first index to spoof the driver
        lpFirstIndex = lpwIndices;
        tmpW = lpwIndices[0];
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            tmpW = *lpwIndices;
            *lpwIndices = *lpFirstIndex;
            FillLegacyHalIndices(PrimitiveType, this->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(this, lpVertices, this->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            *lpwIndices = tmpW;
            lpwIndices += ins.wCount;
        }
        break;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// This is a call for a clipped primitive
//
HRESULT CDirect3DDeviceIHW::DrawIndexPrim()
{
    LPD3DTLVERTEX lpVertices = (LPD3DTLVERTEX)this->lpvOut;
    DWORD dwNumVertices = this->dwNumVertices;
    DWORD dwNumPrimitives = this->dwNumPrimitives;
    WORD *lpwIndices = this->lpwIndices;
    HRESULT ret;

    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        ret = UpdateTextures();
        if(ret != D3D_OK)
        {
            D3D_ERR("UpdateTextures failed. Device probably doesn't support current texture (check return code).");
            return ret;
        }
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }

    // If the number of vertices is small, then just batch them.
    if ( (this->primType == D3DPT_TRIANGLELIST ||
          this->primType == D3DPT_TRIANGLEFAN ||
          this->primType == D3DPT_TRIANGLESTRIP) &&
          this->dwNumVertices < dwHWFewVertices)
    {
        LPD3DTRIANGLE lpTriOut;
        DWORD i,dwTriOutCount,iV0,iV1,iV2;
        WORD wVertexOffset;
        float fCullTestResult;
        BOOL bDoBFCulling;

        // Pad the offset, if needed.  But first save the offset to restore for
        // case in which no vertices are added to the buffer.  This is necessary
        // when renderstates are buffered before and after a non-visible primitive.
        DWORD dwHWOffsetSave = this->dwHWOffset;
        this->dwHWOffset = (this->dwHWOffset + 31) & ~31;

        if (this->dwHWOffset + dwNumVertices*sizeof(D3DTLVERTEX) >= dwHWBufferSize ||
            this->dwHWTriIndex + dwNumPrimitives >= dwHWMaxTris )
        {
            CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                                      // Release in the destructor
            ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in DrawIndexPrim");
                return ret;
            }
            dwHWOffsetSave = this->dwHWOffset;
        }

        LPVOID lpvBatchAddress = (char*)this->lpwDPBuffer + this->dwHWOffset;
        if (this->dwVIDOut == D3DFVF_TLVERTEX)
            memcpy(lpvBatchAddress, lpVertices,
                   this->dwNumVertices*sizeof(D3DTLVERTEX));
        else
        {
            // We have to map FVF vertices to the D3DTLVERTEX.
            // This is only the case when lpvOut points to the user input
            // buffer.
            HRESULT ret;
            // Output will be in the batch buffer
            if ((ret = MapFVFtoTLVertex(lpvBatchAddress)) != D3D_OK)
                return ret;
            lpVertices = (D3DTLVERTEX*)lpvBatchAddress;
        }
        lpTriOut = this->lpHWTris + this->dwHWTriIndex;
        wVertexOffset = (WORD) (this->dwHWOffset/sizeof(D3DTLVERTEX));

        dwTriOutCount=0;  bDoBFCulling=(this->rstates[D3DRENDERSTATE_CULLMODE]!=D3DCULL_NONE);

        switch (this->primType)
        {
        case D3DPT_TRIANGLELIST:
            iV0=0;  iV1=1;  iV2=2;
            for (i = 0; i < dwNumPrimitives; i++,iV0+=3,iV1+=3,iV2+=3)
            {
                if(bDoBFCulling)
                {
                    fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV1]],lpVertices[lpwIndices[iV2]]);
                    if(ISCULLED(this, fCullTestResult))
                        continue;
                }

                lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                lpTriOut->v2 = lpwIndices[iV1] + wVertexOffset;
                lpTriOut->v3 = lpwIndices[iV2] + wVertexOffset;
                lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                lpTriOut += 1;
                dwTriOutCount++;
            }
            break;

        case D3DPT_TRIANGLEFAN:
            iV0=1;  iV1=2; iV2=0;
            for (i = 0; i < dwNumPrimitives; i++,iV0++,iV1++)
            {
                if(bDoBFCulling)
                {
                    fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV1]],lpVertices[lpwIndices[iV2]]);
                    if(ISCULLED(this, fCullTestResult))
                        continue;
                }

                lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                lpTriOut->v2 = lpwIndices[iV1] + wVertexOffset;
                lpTriOut->v3 = lpwIndices[iV2] + wVertexOffset;
                lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                lpTriOut += 1;
                dwTriOutCount++;
            }
            break;

        case D3DPT_TRIANGLESTRIP:
            iV0=0;  iV1=1;  iV2=2;
            for (i = 0; i < dwNumPrimitives; i++,iV0++,iV1++,iV2++)
            {
                if(bDoBFCulling)
                {
                    fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV1]],lpVertices[lpwIndices[iV2]]);
                    if(ISCULLED(this, fCullTestResult))
                        goto SecondTri;
                }

                lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                lpTriOut->v2 = lpwIndices[iV1] + wVertexOffset;
                lpTriOut->v3 = lpwIndices[iV2] + wVertexOffset;
                lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                lpTriOut += 1;
                dwTriOutCount++;

            SecondTri:

                i++;
                if(i < dwNumPrimitives)
                {
                    iV0++,iV1++,iV2++;

                    // swap vtx order for every 2nd tri

                    if(bDoBFCulling)
                    {
                        fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV2]],lpVertices[lpwIndices[iV1]]);
                        if(ISCULLED(this, fCullTestResult))
                            continue;
                    }

                    lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                    lpTriOut->v2 = lpwIndices[iV2] + wVertexOffset;
                    lpTriOut->v3 = lpwIndices[iV1] + wVertexOffset;
                    lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                    lpTriOut += 1;
                    dwTriOutCount++;
                }
            }
            break;
        }

        if(dwTriOutCount==0)
        {
            this->dwHWOffset = dwHWOffsetSave;    //  restore unpadded offset
            return D3D_OK;  // avoid adding unused verts to output
        }

        this->lpHWCounts[this->dwHWNumCounts].wNumTriangles += (WORD) dwTriOutCount;
        this->lpHWCounts[this->dwHWNumCounts].wNumVertices += (WORD) dwNumVertices;

        this->dwHWOffset += dwNumVertices * sizeof(D3DTLVERTEX);
        this->dwHWTriIndex += dwTriOutCount;

        return D3D_OK;
    }
    else
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                                  // Release in the destructor
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in DrawIndexPrim");
            return ret;
        }
        // We have to map FVF vertices to the D3DTLVERTEX.
        // This is only the case when lpvOut points to the user input buffer.
        if (this->dwVIDOut != D3DFVF_TLVERTEX)
        {
            HRESULT ret;
            // Output will be in the TL buffer
            if ((ret = MapFVFtoTLVertex(NULL)) != D3D_OK)
                return ret;
            lpVertices = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
        }
        ret = DrawIndexedPrimitiveInBatchesHW(this->primType,
                                              D3DVT_TLVERTEX, lpVertices,
                                              dwNumPrimitives, this->lpwIndices);
        return ret;
    }
}
//---------------------------------------------------------------------
// This is a call for a clipped primitive
//
HRESULT CDirect3DDeviceIHW::DrawPrim()
{
    D3DPOINT TmpPoint;
    D3DINSTRUCTION ins = {D3DOP_POINT, sizeof(D3DPOINT), 1};
    LPD3DTLVERTEX lpVertices = (LPD3DTLVERTEX)this->lpvOut;

    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        HRESULT ret = UpdateTextures();
        if(ret != D3D_OK)
        {
            D3D_ERR("UpdateTextures failed. Device probably doesn't support current texture (check return code).");
            return ret;
        }
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }

    // If the number of vertices is small, and none require
    // clipping, then just batch them.
    if ((this->primType == D3DPT_TRIANGLELIST ||
         this->primType == D3DPT_TRIANGLEFAN ||
         this->primType == D3DPT_TRIANGLESTRIP) &&
         this->dwNumVertices < dwHWFewVertices)
    {
        LPD3DTRIANGLE lpTriOut, lpTriPrim;
        DWORD i, dwTriOutCount;
        WORD wVertexOffset;
        float fCullTestResult;
        BOOL bDoBFCulling;

        // Pad the offset, if needed.  But first save the offset to restore for
        // case in which no vertices are added to the buffer.  This is necessary
        // when renderstates are buffered before and after a non-visible primitive.
        DWORD dwHWOffsetSave = this->dwHWOffset;
        this->dwHWOffset = (this->dwHWOffset + 31) & ~31;

        if (this->dwHWOffset +
            this->dwNumVertices * sizeof(D3DTLVERTEX) >= dwHWBufferSize ||
            this->dwHWTriIndex + this->dwNumPrimitives >= dwHWMaxTris )
        {
            // Takes D3D lock (ST only).
            CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));
            HRESULT ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in DrawPrim");
                return ret;
            }
            dwHWOffsetSave = this->dwHWOffset;
        }

        LPVOID lpvBatchAddress = (char*)this->lpwDPBuffer + this->dwHWOffset;
        if (this->dwVIDOut == D3DFVF_TLVERTEX)
            memcpy(lpvBatchAddress, lpVertices,
                   this->dwNumVertices*sizeof(D3DTLVERTEX));
        else
        {
            // We have to map FVF vertices to the D3DTLVERTEX.
            // This is only the case when lpvOut points to the user input
            // buffer.
            HRESULT ret;
            // Output will be in the batch buffer
            if ((ret = MapFVFtoTLVertex(lpvBatchAddress)) != D3D_OK)
                return ret;
            lpVertices = (LPD3DTLVERTEX)lpvBatchAddress;
        }
        switch (this->primType)
        {
        case D3DPT_TRIANGLELIST:
            lpTriPrim = TriangleListPrecomp;
            break;
        case D3DPT_TRIANGLEFAN:
            lpTriPrim = TriangleFanPrecomp;
            break;
        case D3DPT_TRIANGLESTRIP:
            lpTriPrim = TriangleStripPrecomp;
            break;
        }
        wVertexOffset = (WORD) (this->dwHWOffset/sizeof(D3DTLVERTEX));
        lpTriOut = this->lpHWTris + this->dwHWTriIndex;

        bDoBFCulling = (this->rstates[D3DRENDERSTATE_CULLMODE]!=D3DCULL_NONE);

        for (dwTriOutCount=0, i = 0; i < this->dwNumPrimitives; i++, lpTriPrim += 1)
        {
            if(bDoBFCulling)
            {
                fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpTriPrim->v1],lpVertices[lpTriPrim->v2],lpVertices[lpTriPrim->v3]);
                if(ISCULLED(this, fCullTestResult))
                    continue;
            }

            lpTriOut->v1 = lpTriPrim->v1 + wVertexOffset;
            lpTriOut->v2 = lpTriPrim->v2 + wVertexOffset;
            lpTriOut->v3 = lpTriPrim->v3 + wVertexOffset;
            lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            lpTriOut += 1;
            dwTriOutCount++;
        }

        if(dwTriOutCount==0)
        {
            this->dwHWOffset = dwHWOffsetSave;    //  restore unpadded offset
            return D3D_OK;  // avoid adding unused verts to output
        }

        this->lpHWCounts[this->dwHWNumCounts].wNumTriangles += (WORD) dwTriOutCount;
        this->lpHWCounts[this->dwHWNumCounts].wNumVertices += (WORD)this->dwNumVertices;

        this->dwHWOffset += this->dwNumVertices * sizeof(D3DTLVERTEX);
        this->dwHWTriIndex += dwTriOutCount;

        return D3D_OK;
    }
    else
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                                  // Release in the destructor
        HRESULT ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in DrawPrim");
            return ret;
        }
        // We have to map FVF vertices to the D3DTLVERTEX.
        // This is only the case when lpvOut points to the user input buffer.
        if (this->dwVIDOut != D3DFVF_TLVERTEX)
        {
            HRESULT ret;
            // Output will be in the TL buffer
            if ((ret = MapFVFtoTLVertex(NULL)) != D3D_OK)
                return ret;
            lpVertices = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
        }
        if (this->primType == D3DPT_POINTLIST)
        {
            TmpPoint.wFirst = 0;
            TmpPoint.wCount = (WORD)this->dwNumPrimitives;
            return DrawPrimitiveLegacyHalCall(this, lpVertices, &TmpPoint,
                                              &ins, 0, D3DVT_TLVERTEX);
        }
        else
            return DrawPrimitiveInBatchesHW(this, this->primType,
                                            D3DVT_TLVERTEX, lpVertices,
                                            this->dwNumPrimitives);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::SetTSSI"

HRESULT
CDirect3DDeviceIHW::SetTSSI(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue)
{
    switch(dwState) {
    case D3DTSS_ADDRESS:
        return SetRenderStateInternal(D3DRENDERSTATE_TEXTUREADDRESS, dwValue);
    case D3DTSS_ADDRESSU:
        return SetRenderStateInternal(D3DRENDERSTATE_TEXTUREADDRESSU, dwValue);
    case D3DTSS_ADDRESSV:
        return SetRenderStateInternal(D3DRENDERSTATE_TEXTUREADDRESSV, dwValue);
    case D3DTSS_BORDERCOLOR:
        return SetRenderStateInternal(D3DRENDERSTATE_BORDERCOLOR, dwValue);
    case D3DTSS_MIPMAPLODBIAS:
        return SetRenderStateInternal(D3DRENDERSTATE_MIPMAPLODBIAS, dwValue);
    case D3DTSS_MAXANISOTROPY:
        return SetRenderStateInternal(D3DRENDERSTATE_ANISOTROPY, dwValue);
    }

    // Set a bit requesting mapping to DX5 renderstates
    this->dwFEFlags |= D3DFE_MAP_TSS_TO_RS;

    return D3D_OK; // return Ok for the time being?
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::MapTSSToRS"

HRESULT CDirect3DDeviceIHW::MapTSSToRS()
{
    DWORD mag = this->tsstates[0][D3DTSS_MAGFILTER];
    DWORD min = this->tsstates[0][D3DTSS_MINFILTER];
    DWORD mip = this->tsstates[0][D3DTSS_MIPFILTER];

    if(mip == D3DTFP_NONE) {
        if(min != D3DTFN_POINT && min != D3DTFN_LINEAR) {
            min = D3DTFN_LINEAR;
            D3D_WARN(2,"Unable to map D3DTSS_MINFILTER mode to driver. Rendering maybe incorrect");
        }
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, min);
    }
    else if(mip == D3DTFP_POINT) {
        if(min == D3DTFN_POINT) {
            SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPNEAREST);
        }
        else if(min == D3DTFN_LINEAR) {
            SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPLINEAR);
        }
        else {
            SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPLINEAR);
            D3D_WARN(2,"Unable to map D3DTSS_MINFILTER mode to driver. Rendering maybe incorrect");
        }
    }
    else { // mip == D3DTFP_LINEAR
        if(min == D3DTFN_POINT) {
            SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPNEAREST);
        }
        else if(min == D3DTFN_LINEAR) {
            SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPLINEAR);
        }
        else {
            SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPLINEAR);
            D3D_WARN(2,"Unable to map D3DTSS_MINFILTER mode to driver. Rendering maybe incorrect");
        }
    }
    if(mag != D3DTFG_POINT && mag != D3DTFG_LINEAR) {
        mag = D3DTFG_LINEAR;
        D3D_WARN(2,"Unable to map D3DTSS_MAGFILTER mode to driver. Rendering maybe incorrect");
    }
    SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMAG, mag);

    DWORD cop = this->tsstates[0][D3DTSS_COLOROP];
    DWORD ca1 = this->tsstates[0][D3DTSS_COLORARG1];
    DWORD ca2 = this->tsstates[0][D3DTSS_COLORARG2];
    DWORD aop = this->tsstates[0][D3DTSS_ALPHAOP];
    DWORD aa1 = this->tsstates[0][D3DTSS_ALPHAARG1];
    DWORD aa2 = this->tsstates[0][D3DTSS_ALPHAARG2];

    // Current is the same as diffuse in stage 0
    if(ca2 == D3DTA_CURRENT)
        ca2 = D3DTA_DIFFUSE;
    if(aa2 == D3DTA_CURRENT)
        aa2 = D3DTA_DIFFUSE;

    // Check if we need to disable texturing
    if(cop == D3DTOP_DISABLE ||
        (cop == D3DTOP_SELECTARG2 && ca2 == D3DTA_DIFFUSE && ((aop == D3DTOP_SELECTARG2 && aa2 == D3DTA_DIFFUSE) || aop == D3DTOP_DISABLE))
        ) {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREHANDLE, 0);
        this->dwFEFlags |= D3DFE_DISABLE_TEXTURES;
    }
    else
    {
        this->dwFEFlags &= ~D3DFE_DISABLE_TEXTURES; // re-enable textures
        m_dwStageDirty |= 1; // dirty the stage, so that UpdateTextures will send down the texture handle
        // Need to call UpdateTextures()
        this->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE;
    }

    // Check if we need to decal
    if((ca1 == D3DTA_TEXTURE && cop == D3DTOP_SELECTARG1) &&
        (aa1 == D3DTA_TEXTURE && aop == D3DTOP_SELECTARG1)) {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECAL);
    }
    // Check if we need to modulate
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_MODULATE &&
        ((aa1 == D3DTA_TEXTURE && aop == D3DTOP_SELECTARG1) || (aa2 == D3DTA_DIFFUSE && aop == D3DTOP_SELECTARG2))) {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATE);
    }
    // Check if we need to decal alpha
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_BLENDTEXTUREALPHA &&
        (aa2 == D3DTA_DIFFUSE && aop == D3DTOP_SELECTARG2)) {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECALALPHA);
    }
    // Check if we need to modulate alpha
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_MODULATE &&
        (aa2 == D3DTA_DIFFUSE && aa1 == D3DTA_TEXTURE) && aop == D3DTOP_MODULATE) {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATEALPHA);
    }
    // Check if we need to add
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_ADD &&
        (aa2 == D3DTA_DIFFUSE && aop == D3DTOP_SELECTARG2)) {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_ADD);
    }
    else {
#if DBG
        if(!(this->dwFEFlags & D3DFE_DISABLE_TEXTURES))
            D3D_WARN(2,"Mapping textureblend stage states to renderstates failed. Rendering maybe incorrect.");
#endif
    }

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::ValidateDevice"

HRESULT D3DAPI
CDirect3DDeviceIHW::ValidateDevice(LPDWORD lpdwNumPasses)
{
    // Holds D3D lock until exit.
    CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));
    HRESULT ret;
    D3DHAL_VALIDATETEXTURESTAGESTATEDATA vbod;

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice7 pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_PTR(lpdwNumPasses, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid lpdwNumPasses pointer" );
        return DDERR_INVALIDPARAMS;
    }

    {
        DWORD mag = this->tsstates[0][D3DTSS_MAGFILTER];
        DWORD min = this->tsstates[0][D3DTSS_MINFILTER];
        DWORD mip = this->tsstates[0][D3DTSS_MIPFILTER];
        DWORD texcap = this->d3dDevDesc.dpcTriCaps.dwTextureFilterCaps;
        ret = D3DERR_UNSUPPORTEDTEXTUREFILTER;
        if(mip == D3DTFP_NONE) {
            if(min == D3DTFG_POINT) {
                if(!(texcap & D3DPTFILTERCAPS_NEAREST))
                    goto err;
            }
            else if(min == D3DTFG_LINEAR) {
                if(!(texcap & D3DPTFILTERCAPS_LINEAR))
                    goto err;
            }
            else
            {
                goto err;
            }
        }
        else if(mip == D3DTFP_POINT) {
            if(min == D3DTFG_POINT) {
                if(!(texcap & D3DPTFILTERCAPS_MIPNEAREST))
                    goto err;
            }
            else if(min == D3DTFG_LINEAR) {
                if(!(texcap & D3DPTFILTERCAPS_MIPLINEAR))
                    goto err;
            }
            else
            {
                ret = D3DERR_CONFLICTINGTEXTUREFILTER;
                goto err;
            }
        }
        else if(mip == D3DTFP_LINEAR) {
            if(min == D3DTFG_POINT) {
                if(!(texcap & D3DPTFILTERCAPS_LINEARMIPNEAREST))
                    goto err;
            }
            else if(min == D3DTFG_LINEAR) {
                if(!(texcap & D3DPTFILTERCAPS_LINEARMIPLINEAR))
                    goto err;
            }
            else
            {
                ret = D3DERR_CONFLICTINGTEXTUREFILTER;
                goto err;
            }
        }
        if(mag == D3DTFG_POINT) {
            if(!(texcap & D3DPTFILTERCAPS_NEAREST))
                goto err;
        }
        else if(mag == D3DTFG_LINEAR) {
            if(!(texcap & D3DPTFILTERCAPS_LINEAR))
                goto err;
        }
        else
        {
            goto err;
        }
    }

    {
        DWORD cop = this->tsstates[0][D3DTSS_COLOROP];
        DWORD ca1 = this->tsstates[0][D3DTSS_COLORARG1];
        DWORD ca2 = this->tsstates[0][D3DTSS_COLORARG2];
        DWORD aop = this->tsstates[0][D3DTSS_ALPHAOP];
        DWORD aa1 = this->tsstates[0][D3DTSS_ALPHAARG1];
        DWORD aa2 = this->tsstates[0][D3DTSS_ALPHAARG2];
        DWORD texcap = this->d3dDevDesc.dpcTriCaps.dwTextureBlendCaps;

        // Current is the same as diffuse in stage 0
        if(ca2 == D3DTA_CURRENT)
            ca2 = D3DTA_DIFFUSE;
        if(aa2 == D3DTA_CURRENT)
            aa2 = D3DTA_DIFFUSE;

        switch (cop)
        {
        // Check decal
        case D3DTOP_SELECTARG1:
            if(!(texcap & D3DPTBLENDCAPS_DECAL))
            {
                ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                goto err;
            }
            if (ca1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aa1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDALPHAARG;
                goto err;
            }
            if (aop != D3DTOP_SELECTARG1)
            {
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        case D3DTOP_MODULATE:
            switch (aop)
            {
            // Check modulate
            case D3DTOP_SELECTARG1:
                if(!(texcap & D3DPTBLENDCAPS_MODULATE))
                {
                    ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                    goto err;
                }
                if (ca1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (ca2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (aa1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                break;
            // Check modulate (second case)
            case D3DTOP_SELECTARG2:
                if(!(texcap & D3DPTBLENDCAPS_MODULATE))
                {
                    ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                    goto err;
                }
                if (ca1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (ca2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (aa2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                break;
            // Check modulate alpha
            case D3DTOP_MODULATE:
                if(!(texcap & D3DPTBLENDCAPS_MODULATEALPHA))
                {
                    ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                    goto err;
                }
                if (ca1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (ca2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (aa1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                if (aa2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                break;
            default:
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        // Check decal alpha
        case D3DTOP_BLENDTEXTUREALPHA:
            if(!(texcap & D3DPTBLENDCAPS_DECALALPHA))
            {
                ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                goto err;
            }
            if (ca1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (ca2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aa2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDALPHAARG;
                goto err;
            }
            if (aop != D3DTOP_SELECTARG2)
            {
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        case D3DTOP_ADD:
            if(!(texcap & D3DPTBLENDCAPS_ADD))
            {
                ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                goto err;
            }
            if (ca1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (ca2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aa2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDALPHAARG;
                goto err;
            }
            if (aop != D3DTOP_SELECTARG2)
            {
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        // Check disable
        case D3DTOP_SELECTARG2:
            if (ca2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aop != D3DTOP_DISABLE)
            {
                if (aop != D3DTOP_SELECTARG2)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                    goto err;
                }
                if (aa2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
            }
            break;
        // Check disable
        case D3DTOP_DISABLE:
            break;
        default:
            ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
            goto err;
        }
    }

    *lpdwNumPasses = 1;
    return D3D_OK;

err:
    D3D_INFO(0,"Failed to validate texture stage state.");
    *lpdwNumPasses = 0;
    return ret;
}
//---------------------------------------------------------------------
// Called by the destructor
//
CDirect3DDeviceIHW::~CDirect3DDeviceIHW()
{
    CleanupTextures();
    if (this->lpHWCounts)
        D3DFree(this->lpHWCounts);
    if (this->lpHWTris)
        D3DFree(this->lpHWTris);
    if (this->wTriIndex)
        D3DFree(this->wTriIndex);
};
//---------------------------------------------------------------------
HRESULT CDirect3DDeviceIHW::Init(REFCLSID riid, LPDIRECT3DI lpD3DI,
                                 LPDIRECTDRAWSURFACE lpDDS,
                                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice)
{
    HRESULT ret;
    this->dwHWNumCounts = 0;
    this->dwHWOffset = 0;
    this->dwHWTriIndex = 0;
    if (IsEqualIID(riid, IID_IDirect3DHALDevice))
    {
        this->dwFEFlags |=  D3DFE_REALHAL;
    }
    if (D3DMalloc((void**)&this->wTriIndex, dwD3DTriBatchSize*4*sizeof(WORD)) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (wTriIndex)" );
        return DDERR_OUTOFMEMORY;
    }

    if (D3DMalloc((void**)&this->lpHWCounts, dwHWBufferSize*sizeof(D3DI_HWCOUNTS)/32 ) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (HWCounts)" );
        return DDERR_OUTOFMEMORY;
    }
    memset(this->lpHWCounts, 0, sizeof(D3DI_HWCOUNTS) );
    if (D3DMalloc((void**)&this->lpHWTris, dwHWMaxTris*sizeof(D3DTRIANGLE) ) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (HWVertices)" );
        return DDERR_OUTOFMEMORY;
    }
    ret = DIRECT3DDEVICEI::Init(riid, lpD3DI, lpDDS, pUnkOuter, lplpD3DDevice);
    if (ret != D3D_OK)
        return ret;
    if (TLVbuf.Grow(this, (__INIT_VERTEX_NUMBER*2)*sizeof(D3DTLVERTEX)) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (TLVbuf)" );
        return DDERR_OUTOFMEMORY;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::SetRenderStateI"

HRESULT
CDirect3DDeviceIHW::SetRenderStateI(D3DRENDERSTATETYPE dwState, DWORD value)
{
    LPDWORD lpRS;
    // map WRAP0 into legacy renderstate
    if (D3DRENDERSTATE_WRAP0 == dwState)
    {
        BOOLEAN ustate = (value & D3DWRAP_U) ? TRUE : FALSE;
        BOOLEAN vstate = (value & D3DWRAP_V) ? TRUE : FALSE;
        SetRenderStateI(D3DRENDERSTATE_WRAPU, ustate);
        SetRenderStateI(D3DRENDERSTATE_WRAPV, vstate);
        return D3D_OK;
    }
    if (dwState > D3DRENDERSTATE_STIPPLEPATTERN31)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwState);
        return D3D_OK;
    }
    if (dwState > D3DRENDERSTATE_FLUSHBATCH && dwState < D3DRENDERSTATE_STIPPLEPATTERN00)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwState);
        return D3D_OK;
    }
    if ( this->dwHWOffset + 8 >= dwHWBufferSize )
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                        // Release in the destructor
        HRESULT ret;
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in BeginIndexed");
            return ret;
        }
    }
    if (this->lpHWCounts[this->dwHWNumCounts].wNumVertices)
    {
        this->dwHWNumCounts += 1;
        memset(&this->lpHWCounts[this->dwHWNumCounts], 0, sizeof(D3DI_HWCOUNTS) );
    }

    lpRS = (LPDWORD) (((char *) this->lpwDPBuffer) + this->dwHWOffset);
    lpRS[0] = dwState;
    lpRS[1] = value;
    this->lpHWCounts[this->dwHWNumCounts].wNumStateChanges += 1;
    this->dwHWOffset += 8;

    return D3D_OK;
}

//---------------------------------------------------------------------
// ProcessPrimitive processes indexed, non-indexed primitives or
// vertices only as defined by "op"
//
// op = __PROCPRIMOP_NONINDEXEDPRIM by default
//
HRESULT CDirect3DDeviceIHW::ProcessPrimitive(__PROCPRIMOP op)
{
    HRESULT ret=D3D_OK;
    DWORD vertexPoolSize;

    // Grow clip flags buffer if we need clipping
    //
    if (!(this->dwDeviceFlags & D3DDEV_DONOTCLIP))
    {
        DWORD size = this->dwNumVertices * sizeof(D3DFE_CLIPCODE);
        if (size > this->HVbuf.GetSize())
        {
            if (this->HVbuf.Grow(size) != D3D_OK)
            {
                D3D_ERR( "Could not grow clip buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
        }
        this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
    }

    if (FVF_TRANSFORMED(this->dwVIDIn))
    {
        // Pass vertices directly from the user memory
        this->dwVIDOut = this->dwVIDIn;
        this->dwOutputSize = this->position.dwStride;
        this->lpvOut = this->position.lpvData;
        vertexPoolSize = this->dwNumVertices * this->dwOutputSize;

        if (this->dwDeviceFlags & D3DDEV_DONOTCLIP)
        {
            if (!(this->dwDeviceFlags & D3DDEV_DONOTUPDATEEXTENTS))
                D3DFE_updateExtents(this);

            if (op == __PROCPRIMOP_INDEXEDPRIM)
            {
                ret = this->DrawIndexPrim();
            }
            else if (op == __PROCPRIMOP_NONINDEXEDPRIM)
            {
                ret = this->DrawPrim();
            }
        }
        else
        {
            // Clear clip union and intersection flags
            DWORD clip_intersect = D3DFE_GenClipFlags(this);
            D3DFE_UpdateClipStatus(this);
            if (!clip_intersect)
            {
                this->dwFlags |= D3DPV_TLVCLIP;
                if (op == __PROCPRIMOP_INDEXEDPRIM)
                {
                    ret = DoDrawIndexedPrimitive(this);
                }
                else if (op == __PROCPRIMOP_NONINDEXEDPRIM)
                {
                    ret = DoDrawPrimitive(this);
                }
            }
        }
    }
    else
    {
        // We need to grow TL vertex buffer if we have to transform vertices
        //
        vertexPoolSize = this->dwNumVertices * this->dwOutputSize;
        if (vertexPoolSize > this->TLVbuf.GetSize())
        {
            if (this->TLVbuf.Grow(this, vertexPoolSize) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
        }
        this->lpvOut = this->TLVbuf.GetAddress();

        // Update Lighting and related flags
        DoUpdateState(this);

        // Call PSGP or our implementation
        if (op == __PROCPRIMOP_INDEXEDPRIM)
            ret = this->pGeometryFuncs->ProcessIndexedPrimitive(this);
        else if (op == __PROCPRIMOP_NONINDEXEDPRIM)
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
        else
            ret = this->pGeometryFuncs->ProcessVertices(this);

        D3DFE_UpdateClipStatus(this);
    }
    return ret;
}
#endif // WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\dphal.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphal.c
 *  Content:    DrawPrimitive implementation for DrawPrimitive HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#ifdef WIN95

#include "drawprim.hpp"
#include "clipfunc.h"
#include "d3dfei.h"

#define LOWVERTICESNUMBERDP  20

extern void SetDebugRenderState(DWORD value);

#define ALIGN32(x) x = ((DWORD)(x + 31)) & (~31);
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "MapFVFtoTLVertex1"

inline void MapFVFtoTLVertex1(LPDIRECT3DDEVICEI lpDevI, D3DTLVERTEX *pOut,
                              DWORD *pIn)
{
// Copy position
    pOut->sx  = *(D3DVALUE*)pIn++;
    pOut->sy  = *(D3DVALUE*)pIn++;
    pOut->sz  = *(D3DVALUE*)pIn++;
    pOut->rhw = *(D3DVALUE*)pIn++;
// Other fields: diffuse, specular, texture
    if (lpDevI->dwVIDOut & D3DFVF_DIFFUSE)
        pOut->color = *pIn++;
    else
    {
        pOut->color = __DEFAULT_DIFFUSE;
    }
    if (lpDevI->dwVIDOut & D3DFVF_SPECULAR)
        pOut->specular = *pIn++;
    else
    {
        pOut->specular= __DEFAULT_SPECULAR;
    }
    if (lpDevI->nOutTexCoord)
    {
        pIn = &pIn[lpDevI->dwTextureIndexToCopy << 1];
        pOut->tu = *(D3DVALUE*)&pIn[0];
        pOut->tv = *(D3DVALUE*)&pIn[1];
    }
    else
    {
        pOut->tu = 0;
        pOut->tv = 0;
    }
}
//---------------------------------------------------------------------
// All vertices from lpDevI->lpVout are copied to the output buffer, expanding
// to D3DTLVERTEX.
// The output buffer is lpAddress if it is not NULL, otherwise it is TLVbuf
//
#undef DPF_MODNAME
#define DPF_MODNAME "MapFVFtoTLVertex"

HRESULT CDirect3DDeviceIHW::MapFVFtoTLVertex(LPVOID lpAddress)
{
    int i;
    DWORD size = this->dwNumVertices * sizeof(D3DTLVERTEX);
    D3DTLVERTEX *pOut;
    if (lpAddress)
        pOut = (D3DTLVERTEX*)lpAddress;
    else
    {
    // See if TL buffer has sufficient space
        if (size > this->TLVbuf.GetSize())
        {
            if (this->TLVbuf.Grow(this, size) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
        }
        pOut = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
    }
// Map vertices
    DWORD *pIn = (DWORD*)this->lpvOut;
    for (i=this->dwNumVertices; i; i--)
    {
        MapFVFtoTLVertex1(this, pOut, pIn);
        pOut++;
        pIn = (DWORD*)((char*)pIn + this->dwOutputSize);
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// Vertices, corresponding to the primitive's indices, are converted to D3DTLVERTEX
// and copied to the TL buffer
//
#undef DPF_MODNAME
#define DPF_MODNAME "MapFVFtoTLVertexIndexed"

HRESULT CDirect3DDeviceIHW::MapFVFtoTLVertexIndexed()
{
    DWORD size = this->dwNumVertices * sizeof(D3DTLVERTEX);
    D3DTLVERTEX *pOut;
    // See if TL buffer has sufficient space
    if (size > this->TLVbuf.GetSize())
    {
        if (this->TLVbuf.Grow(this, size) != D3D_OK)
        {
            D3D_ERR( "Could not grow TL vertex buffer" );
            return DDERR_OUTOFMEMORY;
        }
    }
    pOut = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
// Map vertices
    DWORD *pIn = (DWORD*)this->lpvOut;
    for (DWORD i = 0; i < this->dwNumIndices; i++)
    {
        DWORD *pInpVertex = (DWORD*)((BYTE*)pIn + this->lpwIndices[i] * this->dwOutputSize);
        MapFVFtoTLVertex1(this, &pOut[this->lpwIndices[i]], pInpVertex);
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// Draws non-indexed primitives which do not require clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrim"

#define __DRAWPRIMFUNC
#include "dpgen.h"
//---------------------------------------------------------------------
// Draws indexed primitives which do not require clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrim"

#define __DRAWPRIMFUNC
#define __DRAWPRIMINDEX
#include "dpgen.h"

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP::Init"

HRESULT CDirect3DDeviceIDP::Init(REFCLSID riid, LPDIRECT3DI lpD3DI, 
                                 LPDIRECTDRAWSURFACE lpDDS,
                                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice)
{
    HRESULT ret;
    ret = CDirect3DDeviceIHW::Init(riid, lpD3DI, lpDDS, pUnkOuter, lplpD3DDevice);
    if (ret != D3D_OK)
        return ret;

    return D3D_OK;
}
//---------------------------------------------------------------------
// ATTENTION - These two functions should be combined into one as soon
// as ContextCreate has the new private data mechanism built in.
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP::halCreateContext"

HRESULT CDirect3DDeviceIDP::halCreateContext()
{
    HRESULT ret;
    ret = DIRECT3DDEVICEI::halCreateContext();
    if (ret != D3D_OK)
        return ret;

    this->lpDPPrimCounts = (LPD3DHAL_DRAWPRIMCOUNTS)this->lpwDPBuffer;
    memset( (char *)this->lpwDPBuffer, 0, sizeof(D3DHAL_DRAWPRIMCOUNTS));

    this->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);
    this->dwDPMaxOffset = dwD3DTriBatchSize * sizeof(D3DTRIANGLE)-sizeof(D3DTLVERTEX);

    return (D3D_OK);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "FlushStatesDP"

HRESULT
CDirect3DDeviceIDP::FlushStates(bool bWithinPrimitive)
{
    HRESULT dwRet=D3D_OK;
    if (this->dwDPOffset>sizeof(D3DHAL_DRAWPRIMCOUNTS))
    {
        ++m_qwBatch;
        // So that currently bound textures get rebatched
        for (DWORD dwStage = 0; dwStage < this->dwMaxTextureBlendStages; dwStage++)
        {
            LPDIRECT3DTEXTUREI lpTexI = this->lpD3DMappedTexI[dwStage];
            if (NULL != lpTexI)
            {
                if(lpTexI->lpDDS != NULL)
                {
                    BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS))->lpLcl);
                }
            }
        }
    
        if ((dwRet=CheckSurfaces()) != D3D_OK)
        {
            this->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);
            this->lpDPPrimCounts = (LPD3DHAL_DRAWPRIMCOUNTS)this->lpwDPBuffer;
            memset( (char *)this->lpwDPBuffer,0,sizeof(D3DHAL_DRAWPRIMCOUNTS)); //Clear header also
            if (dwRet == DDERR_SURFACELOST)
            {
                this->dwFEFlags |= D3DFE_LOSTSURFACES;
                return D3D_OK;
            }
            return dwRet;
        }

        D3DHAL_DRAWPRIMITIVESDATA dpData;
        DWORD   dwDPOffset;
        if (this->lpDPPrimCounts->wNumVertices)    //this->lpDPPrimCounts->wNumVertices==0 means the end
        {                      //force it if not
            memset(((LPBYTE)this->lpwDPBuffer+this->dwDPOffset),0,sizeof(D3DHAL_DRAWPRIMCOUNTS));
        }
        dpData.dwhContext = this->dwhContext;
        dpData.dwFlags =  0;
        dpData.lpvData = this->lpwDPBuffer;
        if (FVF_DRIVERSUPPORTED(this))
            dpData.dwFVFControl = this->dwCurrentBatchVID;
        else
        {
            if (this->dwDebugFlags & D3DDEBUG_DISABLEFVF)
                dpData.dwFVFControl = D3DFVF_TLVERTEX;
            else
                dpData.dwFVFControl = 0;    //always zero for non-FVF drivers
        }
        dpData.ddrval = 0;
        dwDPOffset=this->dwDPOffset;  //save it in case Flush returns prematurely
#if 0
        if (D3DRENDERSTATE_TEXTUREHANDLE==*((DWORD*)this->lpwDPBuffer+2))
        DPF(0,"Flushing dwDPOffset=%08lx ddihandle=%08lx",dwDPOffset,*((DWORD*)this->lpwDPBuffer+3));
#endif  //0
        //we clear this to break re-entering as SW rasterizer needs to lock DDRAWSURFACE
        this->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);

        // Spin waiting on the driver if wait requested
#if _D3D_FORCEDOUBLE
        CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE
        do {
#ifndef WIN95
            if((dwRet = CheckContextSurface(this)) != D3D_OK)
            {
                this->dwDPOffset = dwDPOffset;
                return (dwRet);
            }
#endif //WIN95
            CALL_HAL2ONLY(dwRet, this, DrawPrimitives, &dpData);
            if (dwRet != DDHAL_DRIVER_HANDLED)
            {
                D3D_ERR ( "Driver call for DrawOnePrimitive failed" );
                // Need sensible return value in this case,
                // currently we return whatever the driver stuck in here.
            }
        } while (dpData.ddrval == DDERR_WASSTILLDRAWING);
        this->lpDPPrimCounts = (LPD3DHAL_DRAWPRIMCOUNTS)this->lpwDPBuffer;
        memset( (char *)this->lpwDPBuffer,0,sizeof(D3DHAL_DRAWPRIMCOUNTS));   //Clear header also
        dwRet= dpData.ddrval;
        this->dwCurrentBatchVID = this->dwVIDOut;
    }
    return dwRet;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP::SetRenderStateI"

HRESULT 
CDirect3DDeviceIDP::SetRenderStateI(D3DRENDERSTATETYPE dwStateType,
                                    DWORD value)
{
    LPD3DHAL_DRAWPRIMCOUNTS lpPC;
    LPDWORD lpStateChange;
    HRESULT ret;
    // map WRAP0 into legacy renderstate
    if (D3DRENDERSTATE_WRAP0 == dwStateType)
    {
        BOOLEAN ustate = (value & D3DWRAP_U) ? TRUE : FALSE;
        BOOLEAN vstate = (value & D3DWRAP_V) ? TRUE : FALSE;
        SetRenderStateI(D3DRENDERSTATE_WRAPU, ustate);
        SetRenderStateI(D3DRENDERSTATE_WRAPV, vstate);
        return D3D_OK;
    }
    if (dwStateType > D3DRENDERSTATE_STIPPLEPATTERN31)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwStateType);
        return D3D_OK;
    }
    if (dwStateType > D3DRENDERSTATE_FLUSHBATCH && dwStateType < D3DRENDERSTATE_STIPPLEPATTERN00)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwStateType);
        return D3D_OK;
    }

    lpPC = this->lpDPPrimCounts;
    if (lpPC->wNumVertices) //Do we already have Vertices filled in for this count ?
    {               //Yes, then Increment count
        lpPC=this->lpDPPrimCounts=(LPD3DHAL_DRAWPRIMCOUNTS)((LPBYTE)this->lpwDPBuffer+this->dwDPOffset);
        memset( (char *)lpPC,0,sizeof(D3DHAL_DRAWPRIMCOUNTS));
        this->dwDPOffset += sizeof(D3DHAL_DRAWPRIMCOUNTS);
    }
    if (this->dwDPOffset + 2*sizeof(DWORD)  > this->dwDPMaxOffset )
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetRenderStateI");
            return ret;
        }
    }
    lpStateChange=(LPDWORD)((char *)this->lpwDPBuffer + this->dwDPOffset);
    *lpStateChange=dwStateType;
    lpStateChange ++;
    *lpStateChange=value;
    this->lpDPPrimCounts->wNumStateChanges ++;
    this->dwDPOffset += 2*sizeof(DWORD);
#if 0
    if (dwStateType == D3DRENDERSTATE_TEXTUREHANDLE && this->dwDPOffset== 0x10){
    DPF(0,"SRdwDPOffset=%08lx, dwStateType=%08lx value=%08lx ddihandle=%08lx lpStateChange=%08lx lpDPPrimCounts=%08lx",
    this->dwDPOffset,dwStateType,value,*lpStateChange,lpStateChange,this->lpDPPrimCounts);
        _asm int 3
    }
#endif //0

    return D3D_OK;
}

#endif // WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\drawprim.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drawprim.hpp
 *  Content:    DrawPrimitive common defines
 *
 ***************************************************************************/

#ifndef _DRAWPRIM_H_
#define _DRAWPRIM_H_

#define MAX_DX6_PRIMCOUNT   D3DMAXNUMPRIMITIVES
#define MAX_DX6_VERTICES    D3DMAXNUMVERTICES
#ifdef WIN95
#define LOWVERTICESNUMBER 128
#else
#define LOWVERTICESNUMBER 96
#endif
#define D3D_MAX_TLVBUF_CHANGES 5

extern HRESULT DoDrawPrimitive(LPD3DFE_PROCESSVERTICES pv);
extern HRESULT DoDrawIndexedPrimitive(LPD3DFE_PROCESSVERTICES pv);
extern HRESULT CheckDrawPrimitive(LPDIRECT3DDEVICEI lpDevI);
extern HRESULT CheckDrawIndexedPrimitive(LPDIRECT3DDEVICEI lpDevI, DWORD dwStartVertex = 0);

// All vertices from lpDevI->lpVout are copied to the output buffer, expanding
// to D3DTLVERTEX.
// The output buffer is lpAddress if it is not NULL, otherwise it is TLVbuf
//
//---------------------------------------------------------------------
#define FVF_TRANSFORMED(dwFVF) ((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
#define FVF_DRIVERSUPPORTED(lpDevI) (lpDevI->dwDeviceFlags & D3DDEV_FVF)
#define FVF_TEXCOORD_NUMBER(dwFVF) \
    (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)
//----------------------------------------------------------------------
inline DWORD MakeTexTransformFuncIndex(DWORD dwNumInpTexCoord, DWORD dwNumOutTexCoord)
{
    DDASSERT(dwNumInpTexCoord <= 4 && dwNumOutTexCoord <= 4);
    return (dwNumInpTexCoord - 1) + ((dwNumOutTexCoord - 1) << 2);
}
//---------------------------------------------------------------------
// The function should not be called by ProcessVertices!!!
//
// Computes nOutTexCoord, dwTextureCoordSizeTotal, dwTextureCoordSize and
// dwTextureIndexToCopy in case when a pre-DX6 driver is used.
//
void ComputeTCI2CopyLegacy(LPDIRECT3DDEVICEI lpDevI,
                           DWORD  dwNumInpTexCoord,
                           DWORD* pdwInpTexCoordSize,
                           BOOL bVertexTransformed);
//---------------------------------------------------------------------
// Computes size in bytes of the position component of a vertex
//
__inline DWORD GetPositionSizeFVF(DWORD fvf)
{
    DWORD size = 3 << 2;
    switch (fvf & D3DFVF_POSITION_MASK)
    {
    case D3DFVF_XYZRHW: size += 4;      break;
    case D3DFVF_XYZB1:  size += 1*4;    break;
    case D3DFVF_XYZB2:  size += 2*4;    break;
    case D3DFVF_XYZB3:  size += 3*4;    break;
    case D3DFVF_XYZB4:  size += 4*4;    break;
    case D3DFVF_XYZB5:  size += 5*4;    break;
    }
    return size;
}
//---------------------------------------------------------------------
// Computes vertex size in bytes for a the vertex ID excluding size of
// texture oordinates
//
__inline DWORD GetVertexSizeFVF(DWORD fvf)
{
    DWORD size = GetPositionSizeFVF(fvf);
    if (fvf & D3DFVF_NORMAL)
        size += 3*4;
    if (fvf & D3DFVF_RESERVED1)
        size += 4;

    if (fvf & D3DFVF_DIFFUSE)
        size+= 4;
    if (fvf & D3DFVF_SPECULAR)
        size += 4;

    return size;
}
//---------------------------------------------------------------------
// Entry is texture count. Clears all texture format bits in the FVF DWORD,
// that correspond to the texture count
// for this count
const DWORD g_TextureFormatMask[9] = {
    ~0x0000FFFF,
    ~0x0003FFFF,
    ~0x000FFFFF,
    ~0x003FFFFF,
    ~0x00FFFFFF,
    ~0x03FFFFFF,
    ~0x0FFFFFFF,
    ~0x3FFFFFFF,
    ~0xFFFFFFFF
};
//---------------------------------------------------------------------
// Computes vertex size in bytes from the vertex ID
//
// Texture formats size        00   01   10   11
const BYTE g_TextureSize[4] = {2*4, 3*4, 4*4, 4};

//---------------------------------------------------------------------
// Index is number of floats in a texture coordinate set.
// Value is texture format bits
//
const DWORD g_dwTextureFormat[5] = {0, 3, 0, 1, 2};

//---------------------------------------------------------------------
// Returns total size of texture coordinates
// Computes dwTextureCoordSize[] array - size of every texture coordinate set
//
inline DWORD ComputeTextureCoordSize(DWORD dwFVF, DWORD *dwTextureCoordSize)
{
    DWORD dwNumTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);
    DWORD dwTextureCoordSizeTotal;

    // Compute texture coordinate size
    DWORD dwTextureFormats = dwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        dwTextureCoordSizeTotal = (BYTE)dwNumTexCoord * 2 * 4;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            dwTextureCoordSize[i] = 4*2;
        }
    }
    else
    {
        DWORD dwOffset = 0;
        dwTextureCoordSizeTotal = 0;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            BYTE dwSize = g_TextureSize[dwTextureFormats & 3];
            dwTextureCoordSize[i] = dwSize;
            dwTextureCoordSizeTotal += dwSize;
            dwTextureFormats >>= 2;
        }
    }
    return dwTextureCoordSizeTotal;
}
//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "CheckDeviceSettings"
inline HRESULT CheckDeviceSettings(LPDIRECT3DDEVICEI lpDevI)
{
#if DBG
    if (!(lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE))
    {
        D3D_ERR( "Not in scene" );
        return D3DERR_SCENE_NOT_IN_SCENE;
    }
#endif
    return D3D_OK;
}
//---------------------------------------------------------------------
// Computes the number of primtives and also updates the stats accordingly
// Input:  lpDevI->primType
//         dwNumVertices
// Output: lpDevI->dwNumPrimitives
//         return value = dwNumPrimitives
#undef DPF_MODNAME
#define DPF_MODNAME "GetNumPrim"

inline __declspec(nothrow) void GetNumPrim(LPDIRECT3DDEVICEI lpDevI, DWORD dwNumVertices)
{
    lpDevI->dwNumPrimitives = 0;
    switch (lpDevI->primType)
    {
    case D3DPT_POINTLIST:
        lpDevI->dwNumPrimitives = dwNumVertices;
        break;
    case D3DPT_LINELIST:
        lpDevI->dwNumPrimitives = dwNumVertices >> 1;
        break;
    case D3DPT_LINESTRIP:
        if (dwNumVertices < 2)
            return;
        lpDevI->dwNumPrimitives = dwNumVertices - 1;
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (dwNumVertices < 3)
            return;
        lpDevI->dwNumPrimitives = dwNumVertices - 2;
        break;
    case D3DPT_TRIANGLELIST:
#ifdef _X86_
        {
            DWORD tmp;
            __asm
            {
                mov  eax, 0x55555555    // fractional part of 1.0/3.0
                mul  dwNumVertices
                add  eax, 0x80000000    // Rounding
                adc  edx, 0
                mov  tmp, edx
            }
            lpDevI->dwNumPrimitives = tmp;
        }
#else
        lpDevI->dwNumPrimitives = dwNumVertices / 3;
#endif
        break;
    }
}
//---------------------------------------------------------------------
// Sets front-end flags every time fog state is changed
//
inline void DIRECT3DDEVICEI::SetFogFlags(void)
{
    // Call ForceFVFRecompute only if fog enable state has been changed
    BOOL bFogWasEnabled = this->dwDeviceFlags & D3DDEV_FOG;
    if (this->lighting.fog_mode != D3DFOG_NONE &&
        this->rstates[D3DRENDERSTATE_FOGENABLE])
    {
        this->dwDeviceFlags |= D3DDEV_FOG;
        if (!bFogWasEnabled)
            ForceFVFRecompute();
    }
    else
    {
        this->dwDeviceFlags &= ~D3DDEV_FOG;
        if (bFogWasEnabled)
            ForceFVFRecompute();
    }
}
//---------------------------------------------------------------------
// Validates DrawPrimitive flags
//
inline BOOL IsDPFlagsValid(DWORD dwFlags)
{
    if (dwFlags & ~(D3DDP_WAIT))
    {
        D3D_ERR( "Invalid bit set in DrawPrimitive flags" );
        return FALSE;
    }
    return TRUE;
}
//---------------------------------------------------------------------
// Restore indices in the texture stages which were re-mapped for texture
// transforms
// We have to do restore if
//  - Set or Get render state is issued with _WRAP parameter
//  - Set or Get texture stage is issued with TEXCOORDINDEX as a parameter
//
inline void RestoreTextureStages(LPDIRECT3DDEVICEI pDevI)
{
    // dwVIDIn is used to force re-compute FVF in the
    // SetTextureStageState. so we save and restore it.
    DWORD dwVIDInSaved = pDevI->dwVIDIn;
    pDevI->dwDeviceFlags &= ~D3DDEV_REMAPTEXTUREINDICES;
    for (DWORD i=0; i < pDevI->dwNumTextureStages; i++)
    {
        LPD3DFE_TEXTURESTAGE pStage = &pDevI->textureStage[i];
        // Texture generation mode was stripped out of pStage->dwInpCoordIndex
        DWORD dwInpIndex = pStage->dwInpCoordIndex + pStage->dwTexGenMode;
        if (dwInpIndex != pStage->dwOutCoordIndex)
        {
            // We do not call UpdateInternalTextureStageState because it
            // will call ForceRecomputeFVF and we do not want this.
            pDevI->tsstates[pStage->dwOrgStage][D3DTSS_TEXCOORDINDEX] = dwInpIndex;

            // Filter texgen modes for DX6 drivers
            if (!IS_TLHAL_DEVICE(pDevI) && dwInpIndex > 7)
                continue;

            CDirect3DDeviceIDP2 *pDevDP2 = static_cast<CDirect3DDeviceIDP2*>(pDevI);
            pDevDP2->SetTSSI(pStage->dwOrgStage, D3DTSS_TEXCOORDINDEX, dwInpIndex);
        }
        DWORD dwState = D3DRENDERSTATE_WRAP0 + pStage->dwOutCoordIndex;
        if (pStage->dwOrgWrapMode != pDevI->rstates[dwState])
        {
            // We do not call UpdateInternaState because it
            // will call ForceRecomputeFVF and we do not want this.
            pDevI->rstates[dwState] = pStage->dwOrgWrapMode;
            pDevI->SetRenderStateI((D3DRENDERSTATETYPE)dwState, pStage->dwOrgWrapMode);
        }
    }
    pDevI->dwVIDIn = dwVIDInSaved;
}
//---------------------------------------------------------------------
// the function works when there are texture transforms.
// It computes number of output texture coordinates, texture coordinate size and format.
// It prepares texture stages to re-map texture coordinates
//
HRESULT EvalTextureTransforms(LPDIRECT3DDEVICEI pDevI, DWORD dwTexTransform,
                              DWORD *pdwOutTextureSize, DWORD *pdwOutTextureFormat);
//----------------------------------------------------------------------
// Sets texture transform pointer for every input texture coordinate set
//
void SetupTextureTransforms(LPDIRECT3DDEVICEI pDevI);
//----------------------------------------------------------------------
inline BOOL TextureTransformEnabled(LPDIRECT3DDEVICEI pDevI)
{
    return __TEXTURETRANSFORMENABLED(pDevI);
}
//---------------------------------------------------------------------
inline void ComputeOutputVertexOffsets(LPD3DFE_PROCESSVERTICES pv)
{
    DWORD i = 4*sizeof(D3DVALUE);
    pv->diffuseOffsetOut = i;
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)
        i += sizeof(DWORD);
    pv->specularOffsetOut = i;
    if (pv->dwVIDOut & D3DFVF_SPECULAR)
        i += sizeof(DWORD);
    pv->texOffsetOut = i;
}

#endif _DRAWPRIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\halscene.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   halscene.c
 *  Content:    Direct3D HAL scene capture
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   07/12/95   stevela Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

HRESULT D3DHAL_SceneCapture(LPDIRECT3DDEVICEI lpDevI,
                            BOOL bState)
{
    D3DHAL_SCENECAPTUREDATA data;
    HRESULT ret;

    if (!lpDevI->lpD3DHALCallbacks->SceneCapture) {
        return (D3D_OK);
    }

    D3D_INFO(6, "SceneCapture, setting %d dwhContext = %d",
             bState, lpDevI->dwhContext);

    memset(&data, 0, sizeof(D3DHAL_SCENECAPTUREDATA));
    data.dwhContext = lpDevI->dwhContext;
    data.dwFlag = bState ? D3DHAL_SCENE_CAPTURE_START : D3DHAL_SCENE_CAPTURE_END;

    CALL_HALONLY(ret, lpDevI, SceneCapture, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
        D3D_ERR("HAL failed to handle SceneCapture");
        return (data.ddrval);
    }

    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\haldrv.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997, 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       haldrv.cpp
 *  Content:    Direct3D HAL Driver
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "commdrv.hpp"
#include "d3dfei.h"
#include "tlhal.h"

#ifndef WIN95
#include <ntgdistr.h>
#endif

void Destroy(LPDIRECT3DDEVICEI lpDevI);
//---------------------------------------------------------------------
int
GenGetExtraVerticesNumber( LPDIRECT3DDEVICEI lpDevI )
{
    LPD3DHAL_GLOBALDRIVERDATA lpGlob = lpDevI->lpD3DHALGlobalDriverData;

    return (int)(lpGlob->dwNumVertices ?
        lpGlob->dwNumVertices : D3DHAL_DEFAULT_TL_NUM);

}
//---------------------------------------------------------------------
HRESULT CalcDDSurfInfo(LPDIRECT3DDEVICEI lpDevI, BOOL bUpdateZBufferFields)
{
    DDSURFACEDESC ddsd;
    HRESULT ddrval;
    DWORD dwWidth, dwHeight;
    unsigned long m;
    int s;

    // Get info from the surface

    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddrval = lpDevI->lpDDSTarget->GetSurfaceDesc(&ddsd);
    if (ddrval != DD_OK) {
        return ddrval;
    }

    dwWidth = ddsd.dwWidth;
    dwHeight = ddsd.dwHeight;
    if ((ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8)) == 0) {
        // palettized pixfmts will not have valid RGB Bitmasks, so avoid computing this for them

        lpDevI->red_mask = ddsd.ddpfPixelFormat.dwRBitMask;
        lpDevI->green_mask = ddsd.ddpfPixelFormat.dwGBitMask;
        lpDevI->blue_mask = ddsd.ddpfPixelFormat.dwBBitMask;
        
        if ((lpDevI->red_mask == 0x0)  ||
            (lpDevI->green_mask == 0x0) ||
            (lpDevI->blue_mask == 0x0))
        {
            D3D_ERR("All the color masks in the Render target's pixel-format must be non-zero");
            return DDERR_INVALIDPIXELFORMAT;
        }

        // these are used by Clear
        for (s = 0, m = lpDevI->red_mask; !(m & 1); s++, m >>= 1) ;
        lpDevI->red_shift = s;
        lpDevI->red_scale = 255 / (lpDevI->red_mask >> s);
        for (s = 0, m = lpDevI->green_mask; !(m & 1); s++, m >>= 1) ;
        lpDevI->green_shift = s;
        lpDevI->green_scale = 255 / (lpDevI->green_mask >> s);
        for (s = 0, m = lpDevI->blue_mask; !(m & 1); s++, m >>= 1) ;
        lpDevI->blue_shift = s;
        lpDevI->blue_scale = 255 / (lpDevI->blue_mask >> s);

        if ( (lpDevI->red_scale==0) ||
             (lpDevI->green_scale==0) ||
             (lpDevI->blue_scale==0) )
            return DDERR_INVALIDPIXELFORMAT;

        // If there is Alpha in this format
        if (ddsd.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS)
        {
            lpDevI->alpha_mask = ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
            for (s = 0, m = lpDevI->alpha_mask; !(m & 1); s++, m >>= 1) ;
            lpDevI->alpha_shift = s;
            lpDevI->alpha_scale = 255 / (lpDevI->alpha_mask >> s);
        }
        else
        {
            lpDevI->alpha_shift = lpDevI->alpha_scale = lpDevI->alpha_mask = 0;
        }
        
        lpDevI->bDDSTargetIsPalettized=FALSE;
    } else
        lpDevI->bDDSTargetIsPalettized=TRUE;

    if (lpDevI->lpDDSZBuffer_DDS7 && bUpdateZBufferFields) {
        // Get info from the surface

        DDSURFACEDESC2 ddsd2;

        memset(&ddsd2, 0, sizeof(ddsd2));
        ddsd2.dwSize = sizeof(ddsd2);
        ddrval = lpDevI->lpDDSZBuffer_DDS7->GetSurfaceDesc(&ddsd2);
        if (ddrval != DD_OK) {
            return ddrval;
        }

        if( ddsd2.ddpfPixelFormat.dwZBitMask!=0x0) {
            for (s = 0, m = ddsd2.ddpfPixelFormat.dwZBitMask; !(m & 0x1); s++, m >>= 1) ;
            lpDevI->zmask_shift=s;
        } else {
            lpDevI->zmask_shift=0;     // if ZBitMask isn't being set, then Clear2 will never be used,
                                      // so zbuf_shift/stencil_shift wont be needed anyway
        }

        if( ddsd2.ddpfPixelFormat.dwStencilBitMask!=0x0) {
            for (s = 0, m = ddsd2.ddpfPixelFormat.dwStencilBitMask; !(m & 0x1); s++, m >>= 1) ;
            lpDevI->stencilmask_shift=s;
        } else {
            lpDevI->stencilmask_shift=0;
        }
    }

    return D3D_OK;
}

// called by DDRAW
extern "C" HRESULT __stdcall Direct3D_HALCleanUp(LPD3DHAL_CALLBACKS lpD3DHALCallbacks, DWORD dwPID)
{
    D3DHAL_CONTEXTDESTROYALLDATA data;
    HRESULT ret;

    DDASSERT(lpD3DHALCallbacks!=NULL);
    if (lpD3DHALCallbacks->ContextDestroyAll==NULL) {
        // no cleanup necessary (running on d3d hel)
    return D3D_OK;
    }

    memset(&data, 0, sizeof(D3DHAL_CONTEXTDESTROYALLDATA));
    data.dwPID = dwPID;

    // I'd prefer to use CALL_HALONLY() to do the locking (to avoid doing it for the SW rasterizers),
    // but that requires a pDevI which I can't get to from the caller, which is a ddraw cleanup routine

#ifdef WIN95
    _EnterSysLevel(lpWin16Lock);
#endif

    ret = (*lpD3DHALCallbacks->ContextDestroyAll)(&data);

#ifdef WIN95
    _LeaveSysLevel(lpWin16Lock);
#endif

    return ret;
}

// ATTENTION - These two functions should be combined into one as soon
// as ContextCreate has the new private data mechanism built in.
#ifdef WIN95
HRESULT DIRECT3DDEVICEI::halCreateContext()
{
    D3DHAL_CONTEXTCREATEDATA data;
    HRESULT ret;

    D3D_INFO(6, "in halCreateContext. Creating Context for driver = %08lx", this);

    memset(&data, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));
    //
    // From DX7 onwards, drivers should be accepting
    // Surface Locals instead of the Surface interfaces
    // this future-proofs the drivers
    //
    if (IS_DX7HAL_DEVICE(this))
    {
        if (this->lpDD)
            data.lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(this->lpDD))->lpLcl;
        else
            data.lpDDLcl = NULL;

        if (lpDDSTarget)
            data.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSTarget)->lpLcl;
        else
            data.lpDDSLcl = NULL;

        if (lpDDSZBuffer)
            data.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSZBuffer)->lpLcl;
        else
            data.lpDDSZLcl = NULL;

    }
    else
    {
        data.lpDDGbl = this->lpDDGbl;
        data.lpDDS = this->lpDDSTarget;
        data.lpDDSZ = this->lpDDSZBuffer;
    }

    // Hack Alert!! dwhContext is used to inform the driver which version
    // of the D3D interface is calling it.
    data.dwhContext = 3;
    data.dwPID  = GetCurrentProcessId();
    // Hack Alert!! ddrval is used to inform the driver which driver type
    // the runtime thinks it is (DriverStyle registry setting)
    data.ddrval = this->deviceType;

    if (!IS_HW_DEVICE(this))
    {
        // The new software rasterizers want to share IM's state vector so
        // we need to pass them the rstates pointer.  They don't
        // care about dwPID so stick the pointer in there.
        data.dwPID = (DWORD)this->rstates;
    }

    /* 0 for pre-DX5 devices.
     * 1 for DX5 devices.
     * 2 for DX6 devices.
     * 3 for DX7 devices.
     */

    CALL_HALONLY(ret, this, ContextCreate, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
        D3D_ERR( "Driver did not handle ContextCreate" );
        return (DDERR_GENERIC);
    }
    this->dwhContext = data.dwhContext;

    if (D3DMalloc ((void**)&this->lpwDPBufferAlloced,
                   max(dwD3DTriBatchSize*4*sizeof(WORD),
                       dwHWBufferSize) +32) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate" );
        return (DDERR_OUTOFMEMORY);
    }
    this->lpwDPBuffer = (LPWORD) (((DWORD) this->lpwDPBufferAlloced+31) & (~31));

    // save the surface handle for later checks
    this->hSurfaceTarget = ((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;

    D3D_INFO(6, "in halCreateContext. Succeeded. dwhContext = %d", data.dwhContext);

    return (D3D_OK);
}
#else
    /*
     * On NT the kernel code creates the buffer to be used
     * for DrawPrim batching and returns it as extra data
     * in the ContextCreate request.
     */
HRESULT DIRECT3DDEVICEI::halCreateContext()
{
    D3DNTHAL_CONTEXTCREATEI ntData;
    D3DHAL_CONTEXTCREATEDATA *lpData =
        (D3DHAL_CONTEXTCREATEDATA *)&ntData;
    HRESULT ret;

    D3D_INFO(6, "in halCreateContext. Creating Context for driver = %08lx", this);

    /*
     * AnanKan: Assert here that the D3DNTHAL_CONTEXTCREATEI structure is
     * 2 DWORDS bigger than D3DHAL_CONTEXTCREATEDATA. This will be a good
     * consistency check for NT kernel updates.
     */
    memset(&ntData, 0, sizeof(ntData));
    if (IS_DX7HAL_DEVICE(this) || (dwFEFlags & D3DFE_REALHAL))
    {
        if (this->lpDD)
            lpData->lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(this->lpDD))->lpLcl;
        else
            lpData->lpDDLcl = NULL;

        if (lpDDSTarget)
            lpData->lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSTarget)->lpLcl;
        else
            lpData->lpDDSLcl = NULL;

        if (lpDDSZBuffer)
            lpData->lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSZBuffer)->lpLcl;
        else
            lpData->lpDDSZLcl = NULL;

    }
    else
    {
        lpData->lpDDGbl = lpDDGbl;
        lpData->lpDDS = lpDDSTarget;
        lpData->lpDDSZ = lpDDSZBuffer;
    }

    // Hack Alert!! dwhContext is used to inform the driver which version
    // of the D3D interface is calling it.
    lpData->dwhContext = 3;
    lpData->dwPID = GetCurrentProcessId();
    // Hack Alert!! ddrval is used to inform the driver which driver type
    // the runtime thinks it is (DriverStyle registry setting)
    lpData->ddrval = this->deviceType;

    if (IS_HW_DEVICE(this))
    {
        // The new software rasterizers want to share IM's state vector so
        // we need to pass them the rstates pointer.  They don't
        // care about dwPID so stick the pointer in there.
        lpData->dwPID = (DWORD)((ULONG_PTR)this->rstates);
    }

    /* 0 for pre-DX5 devices.
     * 1 for DX5 devices.
     * 2 for DX6 devices.
     * 3 for DX7 devices.
     */
    ntData.cjBuffer = this->dwDPBufferSize;
    ntData.pvBuffer = NULL;

    CALL_HALONLY(ret, this, ContextCreate, lpData);
    if (ret != DDHAL_DRIVER_HANDLED || lpData->ddrval != DD_OK) {
        D3D_ERR( "Driver did not handle ContextCreate" );
        return (DDERR_GENERIC);
    }
    this->dwhContext = (DWORD)((ULONG_PTR)lpData->dwhContext);

    // If the this chose not to allocate a DrawPrim buffer do
    // it for them.
    if (ntData.pvBuffer == NULL)
    {
        this->dwDPBufferSize =
            dwD3DTriBatchSize * 4 * sizeof(WORD);
        if (this->dwDPBufferSize < dwHWBufferSize)
        {
            this->dwDPBufferSize = dwHWBufferSize;
        }

        ret = D3DMalloc((void**)&this->lpwDPBufferAlloced,
                        this->dwDPBufferSize + 32);
        if (ret != DD_OK)
        {
            return ret;
        }

        ntData.pvBuffer = (LPVOID)
            (((ULONG_PTR)this->lpwDPBufferAlloced + 31) & ~31);
        ntData.cjBuffer = this->dwDPBufferSize + 32 -
            (DWORD)((ULONG_PTR)ntData.pvBuffer -
                    (ULONG_PTR)this->lpwDPBufferAlloced);
    }
    else if( (this->dwDPBufferSize &&
              ntData.cjBuffer < this->dwDPBufferSize) ||
             ntData.cjBuffer < sizeof(D3DHAL_DRAWPRIMCOUNTS) )
    {
        D3D_ERR( "Driver did not correctly allocate DrawPrim buffer");
        return (DDERR_GENERIC);
    }

    // Need to save the buffer space provided and its size
    this->lpwDPBuffer = (LPWORD)ntData.pvBuffer;

    // save the surface handle for later checks
    this->hSurfaceTarget = (DWORD)(((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSTarget)->lpLcl->hDDSurface);

    D3D_INFO(6, "in halCreateContext. Succeeded. dwhContext = %d", lpData->dwhContext);

    return (D3D_OK);
}
#endif  //WIN95

void halDestroyContext(LPDIRECT3DDEVICEI lpDevI)
{
    D3DHAL_CONTEXTDESTROYDATA data;
    HRESULT ret;

    D3D_INFO(6, "in halCreateDestroy. Destroying Context for driver = %08lx", lpDevI);
    D3D_INFO(6, "                     dwhContext = %d", lpDevI->dwhContext);

    if(lpDevI->dwhContext!=NULL) {
        memset(&data, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA));
        data.dwhContext = lpDevI->dwhContext;

        CALL_HALONLY(ret, lpDevI, ContextDestroy, &data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
            D3D_WARN(0,"Failed ContextDestroy HAL call in halDestroyContext");
            return;
        }
    }
}
//---------------------------------------------------------------------
HRESULT D3DFE_Create(LPDIRECT3DDEVICEI lpDevI,
                     LPDIRECTDRAW lpDD,
                     LPDIRECTDRAW7 lpDD7,
                     LPDIRECTDRAWSURFACE lpDDS,
                     LPDIRECTDRAWSURFACE lpZ,
                     LPDIRECTDRAWPALETTE lpPal)
{
    DDSURFACEDESC ddsd;
    HRESULT hr;
    LPD3DHAL_GLOBALDRIVERDATA lpGlob;

    /*
     * Allocate and check validity of DirectDraw surfaces
     */

    lpDevI->lpDD = lpDD;
    lpDevI->lpDDGbl = ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpGbl;
    lpDevI->lpDDSTarget = lpDDS;

    // Get DDS7 Interfaces for RenderTarget/ZBuffer

    HRESULT ret = lpDDS->QueryInterface(IID_IDirectDrawSurface7, (LPVOID*)&lpDevI->lpDDSTarget_DDS7);

    if(FAILED(ret)) {
          D3D_ERR("QI for RenderTarget DDS7 Interface failed ");
          return ret;
    }

    if(lpZ!=NULL) {
        ret = lpZ->QueryInterface(IID_IDirectDrawSurface7, (LPVOID*)&lpDevI->lpDDSZBuffer_DDS7);

        if(FAILED(ret)) {
              D3D_ERR("QI for ZBuffer DDS7 Interface failed ");

              return ret;
        }
        lpDevI->lpDDSZBuffer_DDS7->Release();
    }

    LPD3DHAL_D3DEXTENDEDCAPS lpCaps = lpDevI->lpD3DExtendedCaps;
    if (NULL == lpCaps || 0.0f == lpCaps->dvExtentsAdjust)
    {
        lpDevI->dvExtentsAdjust = 1.0f;
    }
    else
    {
        lpDevI->dvExtentsAdjust = lpCaps->dvExtentsAdjust;
    }
    lpDevI->dwClipMaskOffScreen = 0xFFFFFFFF;
    if (lpCaps != NULL)
    {
        if (lpCaps->dvGuardBandLeft   != 0.0f ||
            lpCaps->dvGuardBandRight  != 0.0f ||
            lpCaps->dvGuardBandTop    != 0.0f ||
            lpCaps->dvGuardBandBottom != 0.0f)
        {
            lpDevI->dwDeviceFlags |= D3DDEV_GUARDBAND;
            lpDevI->dwClipMaskOffScreen = ~__D3DCLIP_INGUARDBAND;
            DWORD v;
            if (GetD3DRegValue(REG_DWORD, "DisableGB", &v, 4) &&
                v != 0)
            {
                lpDevI->dwDeviceFlags &= ~D3DDEV_GUARDBAND;
                lpDevI->dwClipMaskOffScreen = 0xFFFFFFFF;
            }
#if DBG
            // Try to get test values for the guard band
            char value[80];
            if (GetD3DRegValue(REG_SZ, "GuardBandLeft", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandLeft);
            if (GetD3DRegValue(REG_SZ, "GuardBandRight", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandRight);
            if (GetD3DRegValue(REG_SZ, "GuardBandTop", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandTop);
            if (GetD3DRegValue(REG_SZ, "GuardBandBottom", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandBottom);
#endif // DBG
        }
    }

    if (!lpDevI->lpD3DHALCallbacks || ! lpDevI->lpD3DHALGlobalDriverData)
    {
        return DDERR_INVALIDOBJECT;
    }

    if (IS_HW_DEVICE(lpDevI))
    {
        // We do texture management (and hence clipped Blts) only for a real HAL.
        hr = lpDD7->CreateClipper(0, &lpDevI->lpClipper, NULL);
        if(hr != DD_OK)
        {
            D3D_ERR("Failed to create a clipper");
            return hr;
        }
    }
    else
    {
        lpDevI->lpClipper = 0;
    }

    lpGlob = lpDevI->lpD3DHALGlobalDriverData;

    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    if (lpZ)
    {
        if ((hr = lpZ->GetSurfaceDesc(&ddsd)) != DD_OK)
        {
            D3D_ERR("Failed to getsurfacedesc on z");
            return hr;
        }
        if (ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
            D3D_INFO(1, "Z buffer is in system memory.");
        }
        else if (ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            D3D_INFO(1, "Z buffer is in video memory.");
        }
        else
        {
            D3D_ERR("Z buffer not in video or system?");
        }
    }
    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    if (lpDDS)
    {
        if ((hr = lpDDS->GetSurfaceDesc(&ddsd)) != DD_OK)
        {
            D3D_ERR("Failed to getsurfacedesc on back buffer");
            return hr;
        }
        if (ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
            D3D_INFO(1, "back buffer is in system memory.");
        }
        else if (ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            D3D_INFO(1, "back buffer is in video memory.");
        }
        else
        {
            D3D_ERR("back buffer not in video or system?");
        }
        if (!(lpGlob->hwCaps.dwDeviceRenderBitDepth &
              BitDepthToDDBD(ddsd.ddpfPixelFormat.dwRGBBitCount)))
        {
            D3D_ERR("Rendering surface's RGB bit count not supported "
                    "by hardware device");
            return DDERR_INVALIDOBJECT;
        }
    }

    if (lpGlob->dwNumVertices
        && lpGlob->dwNumClipVertices < D3DHAL_NUMCLIPVERTICES)
    {
        D3D_ERR("In global driver data, dwNumClipVertices "
                "< D3DHAL_NUMCLIPVERTICES");
        lpGlob->dwNumClipVertices = D3DHAL_NUMCLIPVERTICES;
    }

    if ((hr = CalcDDSurfInfo(lpDevI,TRUE)) != DD_OK)
    {
        return hr;
    }

    RESET_HAL_CALLS(lpDevI);

    /*
     * Create our context in the HAL driver
     */
    if ((hr = lpDevI->halCreateContext()) != D3D_OK)
    {
        return hr;
    }
// Initialize the transform and lighting state
    D3DMATRIXI m;
    setIdentity(&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_VIEW, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_PROJECTION, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_WORLD,  (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_WORLD1, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_WORLD2, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_WORLD3, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE0, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE1, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE2, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE3, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE4, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE5, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE6, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE7, (D3DMATRIX*)&m);

    LIST_INITIALIZE(&lpDevI->specular_tables);
    lpDevI->specular_table = NULL;

    lpDevI->lightVertexFuncTable = &lightVertexTable;
    lpDevI->lighting.activeLights = NULL;

    lpDevI->iClipStatus = D3DSTATUS_DEFAULT;
    lpDevI->rExtents.x1 = D3DVAL(2048);
    lpDevI->rExtents.x2 = D3DVAL(0);
    lpDevI->rExtents.y1 = D3DVAL(2048);
    lpDevI->rExtents.y2 = D3DVAL(0);

    return S_OK;
}

void D3DFE_Destroy(LPDIRECT3DDEVICEI lpDevI)
{
// Destroy lighting data

    SpecularTable *spec;
    SpecularTable *spec_next;

    for (spec = LIST_FIRST(&lpDevI->specular_tables); spec; spec = spec_next)
    {
        spec_next = LIST_NEXT(spec,list);
        D3DFree(spec);
    }

    if(lpDevI->lpClipper)
    {
        lpDevI->lpClipper->Release();
    }

    delete [] lpDevI->m_pLights;

    if (lpDevI->lpD3DHALCallbacks) {
        halDestroyContext(lpDevI);
    }

#ifdef TRACK_HAL_CALLS
    D3D_INFO(0, "Made %d HAL calls", lpDevI->hal_calls);
#endif
}

void BltFillRects(LPDIRECT3DDEVICEI lpDevI, DWORD count, LPD3DRECT rect, D3DCOLOR dwFillColor)
{
    LPDIRECTDRAWSURFACE lpDDS = lpDevI->lpDDSTarget;
    HRESULT ddrval;
    DDBLTFX bltfx;
    RECT tr;
    DWORD i;
    DWORD r, g, b, a;

    // Fill with background color

    memset(&bltfx, 0, sizeof(bltfx));
    bltfx.dwSize = sizeof(bltfx);

// unlike clear callback, which just takes pure 32-bit ARGB word and forces the driver to scale it for
// the pixelformat, here we need to compute the exact fill word, depending on surface's R,G,B bitmasks

    if(lpDevI->bDDSTargetIsPalettized)
    {
         // map 24-bit color to 8-bit index used by 8bit RGB rasterizer
         CallRastService(lpDevI, RAST_SERVICE_RGB8COLORTOPIXEL, dwFillColor, &bltfx.dwFillColor);
    }
    else
    {
        DDASSERT((lpDevI->red_scale!=0)&&(lpDevI->green_scale!=0)&&(lpDevI->blue_scale!=0));
        r = RGB_GETRED(dwFillColor) / lpDevI->red_scale;
        g = RGB_GETGREEN(dwFillColor) / lpDevI->green_scale;
        b = RGB_GETBLUE(dwFillColor) / lpDevI->blue_scale;
        bltfx.dwFillColor = (r << lpDevI->red_shift) | (g << lpDevI->green_shift) | (b << lpDevI->blue_shift);
        if( lpDevI->alpha_scale!=0 )
        {
            a = RGBA_GETALPHA(dwFillColor) / lpDevI->alpha_scale;
            bltfx.dwFillColor |= (a << lpDevI->alpha_shift);
        }
    }

    for (i = 0; i < count; i++,rect++) {
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do {
            ddrval = lpDDS->Blt(&tr, NULL, NULL, DDBLT_COLORFILL, &bltfx);
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

void BltFillZRects(LPDIRECT3DDEVICEI lpDevI, unsigned long Zpixel,
                    DWORD count, LPD3DRECT rect, DWORD dwWriteMask)
{
    HRESULT ddrval;
    DDBLTFX bltfx;
    DWORD i;
    RECT tr;
    DWORD dwExtraFlags=0;

#if DBG
    if (lpDevI->lpDDSZBuffer == NULL)  // should be checked prior to call
        return;
#endif

    memset(&bltfx, 0, sizeof(DDBLTFX));
    bltfx.dwSize = sizeof(DDBLTFX);
    bltfx.dwFillDepth = Zpixel;

    // hack to pass DepthBlt WriteMask through ddraw/ddhel to blitlib
    if(dwWriteMask!=0) {
        bltfx.dwZDestConstBitDepth=dwWriteMask;
        dwExtraFlags = DDBLT_DEPTHFILLWRITEMASK;
    }

    for(i=0;i<count;i++,rect++) {
        D3D_INFO(4, "Z Clearing x1 = %d, y1 = %d, x2 = %d, y2 = %d, WriteMask %X", rect->x1, rect->y1, rect->x2, rect->y2, bltfx.dwReserved);
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do {
            ddrval = lpDevI->lpDDSZBuffer->Blt(&tr, NULL, NULL, DDBLT_DEPTHFILL | dwExtraFlags, &bltfx);
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

//---------------------------------------------------------------------
struct CHandle
{
    DWORD   m_Next;     // Used to make list of free handles
#if DBG
    DWORD   m_Tag;      // 1 - empty; 2 = taken
#endif
};

CHandleFactory::~CHandleFactory()
{
    if (m_Handles)
        delete m_Handles;
}

HRESULT CHandleFactory::Init(DWORD dwInitialSize, DWORD dwGrowSize)
{
    m_Handles = CreateHandleArray(dwInitialSize);
    if (m_Handles == NULL)
        return DDERR_OUTOFMEMORY;
    m_dwArraySize = dwInitialSize;
    m_dwGrowSize = dwGrowSize;
    m_Free = 0;
    return D3D_OK;
}

DWORD CHandleFactory::CreateNewHandle()
{
    DWORD handle = m_Free;
    if (m_Free != __INVALIDHANDLE)
    {
        m_Free = m_Handles[m_Free].m_Next;
    }
    else
    {
        handle = m_dwArraySize;
        m_Free = m_dwArraySize + 1;
        m_dwArraySize += m_dwGrowSize;
        CHandle * newHandles = CreateHandleArray(m_dwArraySize);
#if DBG
        memcpy(newHandles, m_Handles,
               (m_dwArraySize - m_dwGrowSize)*sizeof(CHandle));
#endif
        delete m_Handles;
        m_Handles = newHandles;
    }
    DDASSERT(m_Handles[handle].m_Tag == 1);
#if DBG
    m_Handles[handle].m_Tag = 2;    // Mark as taken
#endif
    return handle;
}

void CHandleFactory::ReleaseHandle(DWORD handle)
{
    DDASSERT(handle < m_dwArraySize);
    DDASSERT(m_Handles[handle].m_Tag == 2);
#if DBG
    m_Handles[handle].m_Tag = 1;    // Mark as empty
#endif

    m_Handles[handle].m_Next = m_Free;
    m_Free = handle;
}

CHandle* CHandleFactory::CreateHandleArray(DWORD dwSize)
{
    CHandle *handles = new CHandle[dwSize];
    DDASSERT(handles != NULL);
    if ( NULL == handles ) return NULL;
    for (DWORD i=0; i < dwSize; i++)
    {
        handles[i].m_Next = i+1;
#if DBG
        handles[i].m_Tag = 1;   // Mark as empty
#endif
    }
    handles[dwSize-1].m_Next = __INVALIDHANDLE;
    return handles;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\hwprov.h ===
//----------------------------------------------------------------------------
//
// hwprov.h
//
// Base hardware HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _HWPROV_H_
#define _HWPROV_H_

//----------------------------------------------------------------------------
//
// HwHalProvider
//
// Implements the base HAL provider for hardware renderers.
//
//----------------------------------------------------------------------------

class HwHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // IHalProvider.
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
};

#endif // #ifndef _HWPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\haltex.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   haltex.c
 *  Content:    Direct3D HAL texture handling
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: haltex.c,v 1.1 1995/11/21 15:12:43 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   07/11/95   stevela Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Texture functionality is not emulated.
 */

HRESULT D3DHAL_TextureCreate(LPDIRECT3DDEVICEI lpDevI,
                             LPD3DTEXTUREHANDLE lphTex,
                             LPDIRECTDRAWSURFACE lpDDS)
{
    D3DHAL_TEXTURECREATEDATA data;
    HRESULT ret;

    if (!lpDevI->lpD3DHALCallbacks->TextureCreate) {
        D3D_ERR("TextureCreate called, but no texture support.");
        return (D3DERR_TEXTURE_NO_SUPPORT);
    }

    memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
    data.dwhContext = lpDevI->dwhContext;

    data.lpDDS = lpDDS;

    D3D_INFO(6, "TextureCreate, creating texture dwhContext = %08lx, lpDDS = %08lx",
        data.dwhContext, data.lpDDS);

    CALL_HALONLY(ret, lpDevI, TextureCreate, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
        D3D_ERR("HAL failed to handle TextureCreate");
        return (D3DERR_TEXTURE_CREATE_FAILED);
    }

    *lphTex = data.dwHandle;
    D3D_INFO(6, "TextureCreate, created texture hTex = %08lx", data.dwHandle);
    return (D3D_OK);
}

HRESULT D3DHAL_TextureDestroy(LPD3DI_TEXTUREBLOCK lpBlock)
{
    LPDIRECT3DDEVICEI lpDevI=lpBlock->lpDevI;
    D3DTEXTUREHANDLE  hTex=lpBlock->hTex;

    DDASSERT(!IS_DX7HAL_DEVICE(lpDevI));

    if (!(lpDevI->lpD3DHALCallbacks->TextureDestroy))
    {
        D3D_ERR("TextureDestroy called, but no texture support.");
        return (D3DERR_TEXTURE_NO_SUPPORT);
    }

    // The following code ensures that before we ask the driver to unmap
    // the texture, we set the stages to NULL if the texture is still present
    // in any stage. This is probably not necessary, but we are just trying
    // to be extra cautious here. The CAVEAT here is that it is possible that
    // D3DHAL_TextureDestroy() is being called from DestroyDevice() and hence
    // IT COULD BE REALLY BAD TO BATCH additional commands to the device at
    // this stage. (snene - 3/2/98)
    BOOL bNeedFlush = FALSE;
    if (IS_DP2HAL_DEVICE(lpDevI)) {
        int dwStage;
        CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2 *>(lpDevI);

        // Find out the first stage with hTex and NULL out all the stages after
        for (dwStage=0;dwStage<(int)lpDevI->dwMaxTextureBlendStages; dwStage++)
        {
            if (hTex == lpDevI->tsstates[dwStage][D3DTSS_TEXTUREMAP])
            {
                // We need to do this backwards because we cannot have a texture bound to
                // stage i + 1 when there is no texture bound to stage i.
                for(int iCurStage=lpDevI->dwMaxTextureBlendStages-1; iCurStage>=dwStage; iCurStage--)
                {
                    if (lpDevI->tsstates[iCurStage][D3DTSS_TEXTUREMAP] != 0)
                    {
                        dp2dev->SetTSSI(iCurStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, 0);
                        bNeedFlush = TRUE;
                    }
                }
                break;
            }
        }
    }
    if (lpDevI->rstates[D3DRENDERSTATE_TEXTUREHANDLE] == hTex)
    {
        lpDevI->rstates[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
        lpDevI->SetRenderStateI(D3DRENDERSTATE_TEXTUREHANDLE, 0);
        bNeedFlush = TRUE;
    }

    // Make sure that we send down the command immediately to guarantee
    // that the driver gets it before we call it with Destroy
    if(bNeedFlush)
    {
        if(lpDevI->FlushStates())
        {
            D3D_ERR("Error trying to render batched commands in D3DHAL_TextureDestroy");
        }
    }
    else // Now we decide whether to flush due to a referenced texture in the batch or not
    {
        if(lpDevI->m_qwBatch <= ((LPDDRAWI_DDRAWSURFACE_INT)(lpBlock->lpD3DTextureI->lpDDS))->lpLcl->lpSurfMore->qwBatch.QuadPart)
        {
            if(lpDevI->FlushStates())
            {
                D3D_ERR("Error trying to render batched commands in D3DHAL_TextureDestroy");
            }
        }
    }

    D3DHAL_TEXTUREDESTROYDATA data;
    HRESULT ret;
    memset(&data, 0, sizeof(D3DHAL_TEXTUREDESTROYDATA));
    data.dwhContext = lpDevI->dwhContext;
    data.dwHandle = hTex;
    
    D3D_INFO(6, "TextureDestroy, destroying texture dwhContext = %08lx, hTex = %08lx",
        data.dwhContext, hTex);
    
    CALL_HALONLY(ret, lpDevI, TextureDestroy, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
        D3D_ERR("HAL failed to handle TextureDestroy");
        return (D3DERR_TEXTURE_DESTROY_FAILED);
    }

    D3D_INFO(6, "TextureDestroy, destroyed texture hTex = %08lx", hTex);
    lpBlock->hTex=0;
    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\hwprov.cpp ===
/*
 *
 * Copyright (c) Microsoft Corp. 1997
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#include "pch.cpp"
#pragma hdrstop
#include <hwprov.h>

#define nullPrimCaps {                          \
    sizeof(D3DPRIMCAPS), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0          \
}                                               \

#define nullLightCaps {                         \
    sizeof(D3DLIGHTINGCAPS), 0, 0, 0 \
}

#define transformCaps { sizeof(D3DTRANSFORMCAPS), D3DTRANSFORMCAPS_CLIP }

#define THIS_MODEL D3DLIGHTINGMODEL_RGB

#define lightingCaps {                                                  \
        sizeof(D3DLIGHTINGCAPS),                                        \
        (D3DLIGHTCAPS_POINT                                             \
         | D3DLIGHTCAPS_SPOT                                            \
         | D3DLIGHTCAPS_DIRECTIONAL),                                   \
        THIS_MODEL,                     /* dwLightingModel */           \
        0,                              /* dwNumLights (infinite) */    \
}

/*
 * Software Driver caps
 */

static D3DDEVICEDESC7 devDesc =
{
    D3DDEVCAPS_FLOATTLVERTEX,   /* devCaps */
    nullPrimCaps,               /* lineCaps */
    nullPrimCaps,               /* triCaps */
    0,                          /* dwDeviceRenderBitDepth */
    0                           /* dwDeviceZBufferBitDepth */
};

//----------------------------------------------------------------------------
//
// HwHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP HwHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) HwHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) HwHalProvider::Release(THIS)
{
    return 0;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::GetCaps
//
// Returns the HAL caps.
//
//----------------------------------------------------------------------------

STDMETHODIMP
HwHalProvider::GetCaps(LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion)
{
    D3DDeviceDescConvert(pHwDesc,
                         &pDdGbl->lpD3DGlobalDriverData->hwCaps,
                         pDdGbl->lpD3DExtendedCaps);
    *pHelDesc = devDesc;

    // Since this is HAL, it can atleast rasterize in HW
    pHwDesc->dwDevCaps |= D3DDEVCAPS_HWRASTERIZATION;

    // Set D3DPRASTERCAPS_WFOG, texture op caps and texture stage caps
    // for legacy hal drivers off device7.
    LPD3DHAL_CALLBACKS3 lpD3DHALCallbacks3 =
        (LPD3DHAL_CALLBACKS3)pDdGbl->lpD3DHALCallbacks3;
    if (dwVersion >= 3 &&
        (lpD3DHALCallbacks3 == NULL || lpD3DHALCallbacks3->DrawPrimitives2 == NULL))
    {
        pHwDesc->dpcTriCaps.dwRasterCaps |= D3DPRASTERCAPS_WFOG;
        D3D_INFO(2, "Setting D3DPRASTERCAPS_WFOG for legacy HAL driver off Device7");

        pHwDesc->dwMaxAnisotropy = 1;
        pHwDesc->wMaxTextureBlendStages = 1;
        pHwDesc->wMaxSimultaneousTextures = 1;
        D3D_INFO(2, "Setting texture stage state info for legacy HAL driver off Device7");


        pHwDesc->dwTextureOpCaps = D3DTEXOPCAPS_DISABLE;
        if ((pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_DECAL) ||
            (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_COPY))
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_SELECTARG1;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_MODULATE) ||
            (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_MODULATEALPHA))
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_MODULATE;
        }
        if (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_ADD)
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_ADD;
        }
        if (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_DECALALPHA)
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_BLENDTEXTUREALPHA;
        }
        D3D_INFO(2, "Setting textureop caps for legacy HAL driver off Device7");

        // map texture filter operations to DX6 set
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_NEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPNEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPNEAREST))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MINFPOINT;
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MAGFPOINT;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEAR) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPLINEAR) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPLINEAR))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MINFLINEAR;
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MAGFLINEAR;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPNEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPLINEAR))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MIPFPOINT;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPNEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPLINEAR))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MIPFLINEAR;
        }
        D3D_INFO(2, "Setting texturefilter caps for legacy HAL driver off Device7");
    }

#ifdef __POINTSPRITES   // may need this for DX8
    // DX6 drivers will handle DrawPrim2 and will be setting extended caps, but
    // won't be setting dvMaxPointSize yet.  Therefore, dvMaxPointSize will be 0
    // from DDraw's initial clear of lpD3DExtendedCaps.
    if ((dwVersion >= 3) && (pHwDesc->dvMaxPointSize == 0.0f))
    {
        // set max point size to pre-DX7 1.0f
        pHwDesc->dvMaxPointSize = 1.0f;
        D3D_INFO(2, "Setting dvMaxPointSize cap for legacy HAL driver off Device7");
    }
#endif

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::GetCallbacks
//
// Returns the HAL callbacks in the given DDraw global.
//
//----------------------------------------------------------------------------

STDMETHODIMP
HwHalProvider::GetInterface(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion)
{
    pInterfaceData->pGlobalData = pDdGbl->lpD3DGlobalDriverData;
    pInterfaceData->pExtCaps = pDdGbl->lpD3DExtendedCaps;
    pInterfaceData->pCallbacks  = pDdGbl->lpD3DHALCallbacks;
    pInterfaceData->pCallbacks2 = pDdGbl->lpD3DHALCallbacks2;

    pInterfaceData->pCallbacks3 = pDdGbl->lpD3DHALCallbacks3;

    if( pDdGbl->lpDDCBtmp )
        pInterfaceData->pfnGetDriverState =
            pDdGbl->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState;
    else
        pInterfaceData->pfnGetDriverState = NULL;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// GetHwHalProvider
//
// Returns the hardware HAL provider.
//
//----------------------------------------------------------------------------

static HwHalProvider g_HwHalProvider;

STDAPI
GetHwHalProvider(REFIID riid, IHalProvider **ppHalProvider, HINSTANCE *phDll,  LPDDRAWI_DIRECTDRAW_GBL pDdGbl)
{
    *phDll = NULL;
    if ( (IsEqualIID(riid,IID_IDirect3DHALDevice) ||
          IsEqualIID(riid,IID_IDirect3DTnLHalDevice)) &&
        D3DI_isHALValid(pDdGbl->lpD3DHALCallbacks))
    {
        *ppHalProvider = &g_HwHalProvider;
    }
    else
    {
        *ppHalProvider = NULL;
        return E_NOINTERFACE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\object.h ===
/*
 * $Id: object.h,v 1.2 1995/06/21 12:38:55 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef _OBJECT_H_
#define _OBJECT_H_

#include <stdlib.h>

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#include "d3dcom.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Data structures
 */
#ifdef __cplusplus

/* 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined */
struct ID3DObject;
typedef struct ID3DObject   *LPD3DOBJECT;

#else

typedef struct ID3DObject   *LPD3DOBJECT;

#endif

/*
 * ID3DObject
 */
#undef INTERFACE
#define INTERFACE ID3DObject
DECLARE_INTERFACE(ID3DObject)
{
    /*
     * ID3DObject methods
     */
    STDMETHOD(Initialise) (THIS_ LPVOID arg) PURE;
    STDMETHOD(Destroy) (THIS_ LPVOID arg) PURE;
};

#ifdef __cplusplus
};
#endif

#endif /* _OBJECT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\halbuf.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   halbuf.c
 *  Content:    Direct3D HAL buffer management
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id: halbuf.c,v 1.1 1995/11/21 15:12:30 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   06/11/95   stevela Initial rev.
 *   07/11/95   stevela stuff.
 *   17/02/96   colinmc Fixed build problem.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

#ifndef USE_SURFACE_LOCK

HRESULT D3DHAL_LockDibEngine(LPDIRECT3DDEVICEI lpDevI)
{
#ifndef WIN95
    return D3D_OK;
#else
    HRESULT ret;
    LPDDRAWI_DIRECTDRAW_GBL pdrv = lpDevI->lpDDGbl;
    LPWORD pdflags;
    BOOL isbusy;

    pdflags = pdrv->lpwPDeviceFlags;
    isbusy = 0;

    _asm
    {
        mov eax, pdflags
        bts word ptr [eax], BUSY_BIT
        adc isbusy,0
    }

    if (isbusy) {
        D3D_WARN(2, "LOCK_DIBENGINE, dibengine is busy");
        ret = DDERR_SURFACEBUSY;
    } else
        ret = DD_OK;

    return ret;
#endif
}

void D3DHAL_UnlockDibEngine(LPDIRECT3DDEVICEI lpDevI)
{
#ifndef WIN95
    return;
#else
    LPDDRAWI_DIRECTDRAW_GBL pdrv = lpDevI->lpDDGbl;
    *pdrv->lpwPDeviceFlags &= ~BUSY;
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\init.c ===
#define INITGUID

#include <objbase.h>
DEFINE_GUID( IID_IDirectDrawSurfaceNew, 0x1bab8e96,0x9cfe,0x4ce3,0xbc,0x72,0xd7,0xe9,0xe9,0x9a,0x21,0x75 );
#include <d3dp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\subwtype.h ===
#if !defined(_SUBWTYPE_H_) && !defined(__wtypes_h__)
#define _SUBWTYPE_H_

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif // !FALSE
#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
			/* size is 1 */
typedef unsigned char BYTE;

#endif // !_BYTE_DEFINED
#ifndef _WORD_DEFINED
#define _WORD_DEFINED
			/* size is 2 */
typedef unsigned short WORD;

#endif // !_WORD_DEFINED
			/* size is 4 */
typedef /* [transmit] */ unsigned int UINT;

			/* size is 4 */
typedef /* [transmit] */ int INT;

			/* size is 4 */
typedef long BOOL, *LPBOOL;

#ifndef _LONG_DEFINED
#define _LONG_DEFINED
			/* size is 4 */
typedef long LONG;

#endif // !_LONG_DEFINED
#ifndef _WPARAM_DEFINED
#define _WPARAM_DEFINED
			/* size is 4 */
typedef UINT WPARAM;

#endif // _WPARAM_DEFINED
#ifndef _DWORD_DEFINED
#define _DWORD_DEFINED
			/* size is 4 */
typedef unsigned long DWORD;

#endif // !_DWORD_DEFINED
#ifndef _LPARAM_DEFINED
#define _LPARAM_DEFINED
			/* size is 4 */
typedef LONG LPARAM;

#endif // !_LPARAM_DEFINED
#ifndef _LRESULT_DEFINED
#define _LRESULT_DEFINED
			/* size is 4 */
typedef LONG LRESULT;

#endif // !_LRESULT_DEFINED
#ifndef _LPWORD_DEFINED
#define _LPWORD_DEFINED
			/* size is 4 */
typedef WORD *LPWORD;

#endif // !_LPWORD_DEFINED
#ifndef _LPDWORD_DEFINED
#define _LPDWORD_DEFINED
			/* size is 4 */
typedef DWORD *LPDWORD;

#endif // !_LPDWORD_DEFINED
			/* size is 4 */
typedef void*	LPVOID;
typedef void	VOID;

typedef /* [string] */ char *LPSTR;

			/* size is 4 */
typedef /* [string] */ const char *LPCSTR;

			/* size is 1 */
typedef unsigned char UCHAR;

			/* size is 2 */
typedef short SHORT;

			/* size is 2 */
typedef unsigned short USHORT;

			/* size is 4 */
typedef DWORD ULONG;

			/* size is 4 */
typedef LONG HRESULT;

#ifndef GUID_DEFINED
#define GUID_DEFINED
			/* size is 16 */
typedef struct  _GUID
    {
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
    }	GUID;

#endif // !GUID_DEFINED
#if !defined( __LPGUID_DEFINED__ )
#define __LPGUID_DEFINED__
			/* size is 4 */
typedef GUID *LPGUID;

#endif // !__LPGUID_DEFINED__
#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED
#define _OBJECTID_DEFINED
			/* size is 20 */
typedef struct  _OBJECTID
    {
    GUID Lineage;
    unsigned long Uniquifier;
    }	OBJECTID;

#endif // !_OBJECTID_DEFINED
#if !defined( __IID_DEFINED__ )
#define __IID_DEFINED__
			/* size is 16 */
typedef GUID IID;

			/* size is 4 */
typedef IID *LPIID;

#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
			/* size is 16 */
typedef GUID CLSID;

			/* size is 4 */
typedef CLSID *LPCLSID;

#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#define REFIID              const IID &
#endif // !_REFIID_DEFINED
#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#define REFCLSID            const CLSID &
#endif // !_REFCLSID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#define REFIID              const IID * const
#endif // !_REFIID_DEFINED
#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#define REFCLSID            const CLSID * const
#endif // !_REFCLSID_DEFINED
#endif // !__cplusplus
#endif // !__IID_DEFINED__

#endif /* _SUBWTYPE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\lighting.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        lighting.cpp
 *  Content:     Direct3D material/light management
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "tlhal.h"

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckLightParams"

void CheckLightParams(LPD3DLIGHT7 lpData)
{
    if (!VALID_D3DLIGHT_PTR(lpData))
    {
        D3D_ERR( "Invalid D3DLIGHT pointer" );
        throw DDERR_INVALIDPARAMS;
    }
    if (lpData->dltType != D3DLIGHT_POINT &&
        lpData->dltType != D3DLIGHT_SPOT &&
        lpData->dltType != D3DLIGHT_DIRECTIONAL)
    {
        D3D_ERR( "Invalid D3DLIGHT type" );
        throw DDERR_INVALIDPARAMS;
    }

    if (lpData->dvRange < 0.0f || lpData->dvRange > D3DLIGHT_RANGE_MAX)
    {
        D3D_ERR( "Invalid D3DLIGHT range" );
        throw DDERR_INVALIDPARAMS;
    }
    if (lpData->dltType == D3DLIGHT_SPOT || lpData->dltType == D3DLIGHT_DIRECTIONAL)
    {
        float   magnitude;
        magnitude = lpData->dvDirection.x * lpData->dvDirection.x +
            lpData->dvDirection.y * lpData->dvDirection.y +
            lpData->dvDirection.z * lpData->dvDirection.z;
        if (magnitude < 0.00001f)
        {
            D3D_ERR( "Invalid D3DLIGHT direction" );
            throw DDERR_INVALIDPARAMS;
        }
        if (lpData->dltType == D3DLIGHT_SPOT)
        {
            if (lpData->dvPhi < 0.0f)
            {
                D3D_ERR( "Invalid D3DLIGHT Phi angle, must be >= 0" );
                throw DDERR_INVALIDPARAMS;
            }
            if (lpData->dvPhi > 3.1415927f)
            {
                D3D_ERR( "Invalid D3DLIGHT Phi angle, must be <= pi" );
                throw DDERR_INVALIDPARAMS;
            }
            if (lpData->dvTheta < 0.0f)
            {
                D3D_ERR( "Invalid D3DLIGHT Theta angle, must be >= 0" );
                throw DDERR_INVALIDPARAMS;
            }
            if (lpData->dvTheta > lpData->dvPhi)
            {
                D3D_ERR( "Invalid D3DLIGHT Theta angle, must be <= Phi" );
                throw DDERR_INVALIDPARAMS;
            }
            if (lpData->dvAttenuation0 < 0 ||
                lpData->dvAttenuation1 < 0 ||
                lpData->dvAttenuation2 < 0)
            {
                D3D_ERR( "Attenuation factor can not be negative" );
                throw DDERR_INVALIDPARAMS;
            }
        }
    }
    return;
}
//=====================================================================
//
//         DIRECT3DDEVICEI interface
//
//=====================================================================
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetMaterialI"

void DIRECT3DDEVICEI::SetMaterialI(LPD3DMATERIAL7 lpData)
{
    this->lighting.material = *lpData;
    this->MaterialChanged();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetMaterial"

HRESULT D3DAPI DIRECT3DDEVICEI::SetMaterial(LPD3DMATERIAL7 lpData)
{
    if (!VALID_D3DMATERIAL_PTR(lpData))
    {
        D3D_ERR( "Invalid D3DMATERIAL pointer" );
        return DDERR_INVALIDPARAMS;
    }

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            m_pStateSets->InsertMaterial(lpData);
        else
            this->SetMaterialI(lpData);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetMaterial"

HRESULT D3DAPI DIRECT3DDEVICEI::GetMaterial(LPD3DMATERIAL7 lpData)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    if (!VALID_D3DMATERIAL_PTR(lpData))
    {
        D3D_ERR( "Invalid D3DMATERIAL pointer" );
        return DDERR_INVALIDPARAMS;
    }

    *lpData = this->lighting.material;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetLightI"

void DIRECT3DDEVICEI::SetLightI(DWORD dwLightIndex, LPD3DLIGHT7 lpData)
{
    if (dwLightIndex >= m_dwNumLights)
    {
        // Now we have to grow the light array. We create new array and copy
        // old lights there.
        DIRECT3DLIGHTI *pLights = new DIRECT3DLIGHTI[dwLightIndex + 10];
        if (pLights == NULL)
        {
            D3D_ERR("Not enough memory to grow light array");
            throw DDERR_OUTOFMEMORY;
        }
        LIST_INITIALIZE(&m_ActiveLights);   // Clear active light list
        for (DWORD i = 0; i < m_dwNumLights; i++)
        {
            if (m_pLights[i].Valid())
            {
                pLights[i] = m_pLights[i];
                if (pLights[i].Enabled())
                    LIST_INSERT_ROOT(&m_ActiveLights, &pLights[i], m_List);
            }
        }
        m_dwNumLights = dwLightIndex + 10;
        DIRECT3DLIGHTI *pLightsTemp = m_pLights;
        m_pLights = pLights;
        delete [] pLightsTemp;
    }
    LPDIRECT3DLIGHTI pLight = &m_pLights[dwLightIndex];

    pLight->m_Light = *lpData;
    this->LightChanged(dwLightIndex);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetLight"

HRESULT D3DAPI DIRECT3DDEVICEI::SetLight(DWORD dwLightIndex, LPD3DLIGHT7 lpData)
{
    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        CheckLightParams(lpData);

        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            m_pStateSets->InsertLight(dwLightIndex, lpData);
        else
            this->SetLightI(dwLightIndex, lpData);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetLight"

HRESULT D3DAPI DIRECT3DDEVICEI::GetLight(DWORD dwLightIndex, LPD3DLIGHT7 lpData)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    if (!VALID_D3DLIGHT_PTR(lpData))
    {
        D3D_ERR( "Invalid D3DLIGHT pointer" );
        return DDERR_INVALIDPARAMS;
    }

    if (dwLightIndex >= m_dwNumLights)
    {
        D3D_ERR( "Invalid light index" );
        return DDERR_INVALIDPARAMS;
    }
    DIRECT3DLIGHTI *pLight = &m_pLights[dwLightIndex];
    if (!pLight->Valid())
    {
        return DDERR_INVALIDPARAMS;
    }

    *lpData = pLight->m_Light;

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::MaterialChanged"

void DIRECT3DDEVICEI::MaterialChanged()
{
    this->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_FRONTEND_DIRTY;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::LightChanged"

void DIRECT3DDEVICEI::LightChanged(DWORD dwLightIndex)
{
    dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
    // Valid flag should be set in this function, because
    // CDirect3DDeviceTL uses this flag to check if the light is set
    // first time
    m_pLights[dwLightIndex].m_LightI.flags |= D3DLIGHTI_VALID | D3DLIGHTI_DIRTY;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::LightEnableI"

void DIRECT3DDEVICEI::LightEnableI(DWORD dwLightIndex, BOOL bEnable)
{
    if (dwLightIndex >= m_dwNumLights ||
        !m_pLights[dwLightIndex].Valid())
    {
        // Set default value to the light
        D3DLIGHT7 light;
        memset(&light, 0, sizeof(light));
        light.dltType = D3DLIGHT_DIRECTIONAL;
        light.dvDirection.x = D3DVAL(0);
        light.dvDirection.y = D3DVAL(0);
        light.dvDirection.z = D3DVAL(1);
        light.dcvDiffuse.r = D3DVAL(1);
        light.dcvDiffuse.g = D3DVAL(1);
        light.dcvDiffuse.b = D3DVAL(1);
        SetLightI(dwLightIndex, &light);
    }
    LPDIRECT3DLIGHTI pLight = &m_pLights[dwLightIndex];
    if (bEnable)
    {
        if (!pLight->Enabled())
        {

            LIST_INSERT_ROOT(&m_ActiveLights, pLight, m_List);
            pLight->m_LightI.flags |= D3DLIGHTI_ENABLED;
            dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
        }
    }
    else
    {
        if (pLight->Enabled())
        {
            LIST_DELETE(pLight, m_List);
            pLight->m_LightI.flags &= ~D3DLIGHTI_ENABLED;
            dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::LightEnable"

HRESULT D3DAPI DIRECT3DDEVICEI::LightEnable(DWORD dwLightIndex, BOOL bEnable)
{
    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            m_pStateSets->InsertLightEnable(dwLightIndex, bEnable);
        else
            LightEnableI(dwLightIndex, bEnable);
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetLightEnable"

HRESULT D3DAPI DIRECT3DDEVICEI::GetLightEnable(DWORD dwLightIndex, BOOL *pbEnable)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    if (dwLightIndex >= m_dwNumLights ||
        !m_pLights[dwLightIndex].Valid())
    {
        D3D_ERR("Invalid light index OR light is not initialized");
        return DDERR_INVALIDPARAMS;
    }
    *pbEnable = m_pLights[dwLightIndex].Enabled();
    return D3D_OK;
}
//---------------------------------------------------------------------
// Update internal light state
//
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DLIGHTI::SetInternalData"

HRESULT DIRECT3DLIGHTI::SetInternalData()
{
    m_LightI.type   = m_Light.dltType;
    m_LightI.flags &= ~D3DLIGHTI_OPTIMIZATIONFLAGS;

    if (FLOAT_EQZ(m_Light.dcvSpecular.r) &&
        FLOAT_EQZ(m_Light.dcvSpecular.g) &&
        FLOAT_EQZ(m_Light.dcvSpecular.b))
    {
        m_LightI.flags |= D3DLIGHTI_SPECULAR_IS_ZERO;
    }

    if (FLOAT_EQZ(m_Light.dcvAmbient.r) &&
        FLOAT_EQZ(m_Light.dcvAmbient.g) &&
        FLOAT_EQZ(m_Light.dcvAmbient.b))
    {
        m_LightI.flags |= D3DLIGHTI_AMBIENT_IS_ZERO;
    }

    m_LightI.ambient.r = m_Light.dcvAmbient.r;
    m_LightI.ambient.g = m_Light.dcvAmbient.g;
    m_LightI.ambient.b = m_Light.dcvAmbient.b;

    m_LightI.specular.r = m_Light.dcvSpecular.r;
    m_LightI.specular.g = m_Light.dcvSpecular.g;
    m_LightI.specular.b = m_Light.dcvSpecular.b;

    m_LightI.diffuse.r = m_Light.dcvDiffuse.r;
    m_LightI.diffuse.g = m_Light.dcvDiffuse.g;
    m_LightI.diffuse.b = m_Light.dcvDiffuse.b;

    m_LightI.position.x = m_Light.dvPosition.x;
    m_LightI.position.y = m_Light.dvPosition.y;
    m_LightI.position.z = m_Light.dvPosition.z;
    m_LightI.direction.x = m_Light.dvDirection.x;
    m_LightI.direction.y = m_Light.dvDirection.y;
    m_LightI.direction.z = m_Light.dvDirection.z;
    m_LightI.attenuation0 = m_Light.dvAttenuation0;
    m_LightI.attenuation1 = m_Light.dvAttenuation1;
    m_LightI.attenuation2 = m_Light.dvAttenuation2;

    m_LightI.range = m_Light.dvRange;
    m_LightI.range_squared = m_Light.dvRange * m_Light.dvRange;

    if (m_Light.dltType == D3DLIGHT_SPOT)
    {
        m_LightI.cos_theta_by_2 = (float)cos(m_Light.dvTheta / 2.0);
        m_LightI.cos_phi_by_2 = (float)cos(m_Light.dvPhi / 2.0);

        m_LightI.falloff = m_Light.dvFalloff;
        m_LightI.inv_theta_minus_phi = m_LightI.cos_theta_by_2 -
            m_LightI.cos_phi_by_2;
        if (m_LightI.inv_theta_minus_phi != 0.0)
        {
            m_LightI.inv_theta_minus_phi = 1.0f/m_LightI.inv_theta_minus_phi;
        }
        else
        {
            m_LightI.inv_theta_minus_phi = 1.0f;
        }
    }
    if (m_Light.dltType == D3DLIGHT_DIRECTIONAL ||
        m_Light.dltType == D3DLIGHT_SPOT)
    {
        VecNormalize(m_LightI.direction);
    }

    // set internal flags
    if (m_LightI.attenuation0 != 0.0)
    {
        m_LightI.flags |= D3DLIGHTI_ATT0_IS_NONZERO;
    }
    if (m_LightI.attenuation1 != 0.0)
    {
        m_LightI.flags |= D3DLIGHTI_ATT1_IS_NONZERO;
    }
    if (m_LightI.attenuation2 != 0.0)
    {
        m_LightI.flags |= D3DLIGHTI_ATT2_IS_NONZERO;
    }
    if (m_LightI.falloff == 1.0)
    {
        m_LightI.flags |= D3DLIGHTI_LINEAR_FALLOFF;
    }
    m_LightI.flags &= ~D3DLIGHTI_DIRTY;
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\lists.hpp ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef _LISTS_H
#define _LISTS_H

#define LIST_ROOT(name, type) struct name {type *Root;}

#define LIST_MEMBER(type) struct { type **Prev; type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
    (root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    if ((element)->field.Prev)\
    {\
        *(element)->field.Prev = (element)->field.Next;\
        (element)->field.Prev = 0;\
    }\
    (element)->field.Next = 0;\
}

#define LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   type *First;\
    type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   type *Next;\
    type **Prev;    /* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
    (root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   type *Last;\
    type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   type *Prev;\
    type *Next;\
}

#define CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
    (root)->Last->field.Next = (element);\
    else\
    (root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
    (root)->First->field.Prev = (element);\
    else\
    (root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
    (current_element)->field.Prev->field.Next = (element);\
    else\
    (root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
    (root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
    (element)->field.Prev->field.Next = (element)->field.Next;\
    else\
    (root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.hpp"

void TestList(void)
{
    struct Foo
    {
    int a;
    LIST_MEMBER(Foo) ListStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
    int a;
    TAIL_QUEUE_MEMBER(Foo) TQStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
    int a;
    CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
    CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
    switch(WhichInsert)
    {
    case END:
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        WhichInsert = ROOT;
        break;
    case ROOT:
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        WhichInsert = PREVIOUS;
        break;
    case PREVIOUS:
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
        WhichInsert = DONE;
        break;
    default:
        assert(0);
    }

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

    pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
    pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
    assert(pFoo == &MyFoo3);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */


#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\pch.cpp ===
#include "ddrawpr.h"
#include <windows.h>
#include <assert.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "dpf.h"
#include "d3di.hpp"
#include "d3dpr.hpp"
#include "d3dtypesp.h"
#include "ddrawp.h"
#include "haldrv.hpp"
#include "memalloc.h"
#include "fltval.h"
#include "texman.hpp"
#include "tlhal.h"
#include "stateset.hpp"
#include "surfiter.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\stateset.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stateset.hpp
 *  Content:    State sets handling interfaces
 *
 ***************************************************************************/
#ifndef _STATESET_HPP_
#define _STATESET_HPP_

struct  CHandle;
const   DWORD __INVALIDHANDLE = 0xFFFFFFFF;

extern void InsertStateSetOp(LPDIRECT3DDEVICEI pDevI, DWORD dwOperation, DWORD dwParam, D3DSTATEBLOCKTYPE sbt);
//---------------------------------------------------------------------
// This class is used to generate sequential integer numbers (handles).
// When a handle is released it will be reused.
// Number of handles is unlimited
//
class CHandleFactory
{
public: 
    CHandleFactory() {m_dwArraySize = 0; m_Handles = NULL;}
    ~CHandleFactory();
    HRESULT Init(DWORD dwInitialSize, DWORD dwGrowSize);
    DWORD CreateNewHandle();
    void ReleaseHandle(DWORD handle);
protected:
    CHandle* CreateHandleArray(DWORD dwSize);

    CHandle        *m_Handles;      // Array of objects
    DWORD           m_dwGrowSize;   
    DWORD           m_dwArraySize;  // Number of objects in the array
    DWORD           m_Free;         // Header for free elements in the array
};
 //---------------------------------------------------------------------
// This class provides interface to the growing state set buffer
//
class CStateSetBuffer
{
public:
    CStateSetBuffer()  
        {
            m_pBuffer = NULL; 
            m_dwCurrentSize = 0; 
            m_dwBufferSize = 0;
            m_pDP2CurrCommand = 0;
        }
    CStateSetBuffer(CStateSetBuffer& src)  
        {
            m_dwCurrentSize = src.m_dwCurrentSize;
            m_dwBufferSize = src.m_dwCurrentSize;
            if(m_dwCurrentSize != 0)
            {
                m_pBuffer = new BYTE[m_dwCurrentSize];
                if(m_pBuffer == 0)
                {
                    m_dwCurrentSize = 0;
                    m_pDP2CurrCommand = 0;
                    throw DDERR_OUTOFMEMORY;
                }
                memcpy(m_pBuffer, src.m_pBuffer, m_dwCurrentSize);
            }
            else
            {
                m_pBuffer = 0;
            }
            m_pDP2CurrCommand = 0;
        }
    ~CStateSetBuffer() 
        {
            delete [] m_pBuffer;
        }
    void operator=(CStateSetBuffer& src)  
        {
            m_dwCurrentSize = src.m_dwCurrentSize; 
            if(m_dwBufferSize != m_dwCurrentSize)
            {
                m_dwBufferSize = m_dwCurrentSize;
                delete [] m_pBuffer;
                if(m_dwCurrentSize != 0)
                {
                    m_pBuffer = new BYTE[m_dwCurrentSize];
                    if(m_pBuffer == 0)
                    {
                        m_dwCurrentSize = 0;
                        m_pDP2CurrCommand = 0;
                        throw DDERR_OUTOFMEMORY;
                    }
                }
                else
                {
                    m_pBuffer = 0;
                    m_pDP2CurrCommand = 0;
                    return;
                }
            }
            memcpy(m_pBuffer, src.m_pBuffer, m_dwCurrentSize);
            m_pDP2CurrCommand = 0;
        }
    // Insert a command to the buffer. Grow buffer if necessary
    void InsertCommand(D3DHAL_DP2OPERATION, LPVOID pData, DWORD dwDataSize);
    // Reset current command
    void ResetCurrentCommand()
        {
            m_pDP2CurrCommand = 0;
        }
    // Set buffer to its initial state. Memory is not freed
    void Reset() 
        {
            m_dwCurrentSize = 0;
            m_pDP2CurrCommand = 0;
        }

    DWORD   m_dwCurrentSize;
    DWORD   m_dwBufferSize;
    BYTE    *m_pBuffer;
    //Pointer to the current position the CB1 buffer
    LPD3DHAL_DP2COMMAND m_pDP2CurrCommand;
};
//---------------------------------------------------------------------
// This class provides interface to a state set
//
const DWORD __STATESET_INITIALIZED          = 1;
// Set if we have to check if we need to restore texture stage indices
const DWORD __STATESET_NEEDCHECKREMAPPING   = 2;
class CStateSet
{
public:
    CStateSet() 
        {
            m_dwStateSetFlags = 0;
            m_dwDeviceHandle = __INVALIDHANDLE;
        }
    void InsertCommand(D3DHAL_DP2OPERATION, LPVOID pData, DWORD dwDataSize, BOOL bDriverCanHandle);
    // Mark the state set as unused. The object is not destroyed and can be
    // reused
    HRESULT Release();
    // Execute the front-end only or device state subset
    void Execute(LPDIRECT3DDEVICEI pDevI, BOOL bFrontEndBuffer);
    // Capture the current device state into the state block
    void Capture(LPDIRECT3DDEVICEI pDevI, BOOL bFrontEndBuffer);
    // Reset the current command in both buffers
    void ResetCurrentCommand()
        {
            m_FEOnlyBuffer.ResetCurrentCommand();
            m_DriverBuffer.ResetCurrentCommand();
        }
protected:
    CStateSetBuffer m_FEOnlyBuffer; // Contains commands that driver can not 
                                    // understand
    CStateSetBuffer m_DriverBuffer; // Contains commands that driver can 
                                    // understand
    DWORD   m_dwDeviceHandle;       // Some sets could not have corresponding
                                    // device buffers, so device handle is not 
                                    // equal to the user visible handle
    DWORD   m_dwStateSetFlags;
    friend class CStateSets;
};
//---------------------------------------------------------------------
// This class encapsulates handling of array of state sets
//
class CStateSets
{
public:
    CStateSets();
    ~CStateSets();
    HRESULT Init(DWORD dwFlags);
    HRESULT StartNewSet();
    void EndSet();
    // Returns current handle
    DWORD GetCurrentHandle() {return m_dwCurrentHandle;}
    // Delete state set
    void DeleteStateSet(LPDIRECT3DDEVICEI pDevI, DWORD dwHandle);
    // Returns information about state set data to be written to the device
    // Allocates a new handle for the device buffer
    void GetDeviceBufferInfo(DWORD* dwStateSetHandle, LPVOID *pBuffer, DWORD* dwBufferSize);
    // Insert a render state to the current state set
    // Throws an exception in case of error
    void InsertRenderState(D3DRENDERSTATETYPE state, DWORD dwValue, 
                           BOOL bDriverCanHandle);
    void InsertLight(DWORD dwLightIndex, LPD3DLIGHT7);
    void InsertLightEnable(DWORD dwLightIndex, BOOL bEnable);
    void InsertMaterial(LPD3DMATERIAL7);
    void InsertViewport(LPD3DVIEWPORT7);
    void InsertTransform(D3DTRANSFORMSTATETYPE state, LPD3DMATRIX lpMat);
    void InsertTextureStageState(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    void InsertTexture(DWORD dwStage, LPDIRECTDRAWSURFACE7 pTex);
    void InsertClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation);
    // Execute a state set with the specified handle
    void Execute(LPDIRECT3DDEVICEI pDevI, DWORD dwHandle);
    // Capture a state set to the the specified handle
    void Capture(LPDIRECT3DDEVICEI pDevI, DWORD dwHandle);
    // Capture predefined state
    void CreatePredefined(LPDIRECT3DDEVICEI pDevI, D3DSTATEBLOCKTYPE sbt);
    void Cleanup(DWORD dwHandle);
protected:
    const DWORD m_GrowSize;
    DWORD       m_dwMaxSets;        // Maximum number of state sets
    DWORD       m_dwCurrentHandle;
    CStateSet * m_pStateSets;       // Array of state sets
    CStateSet * m_pCurrentStateSet; 
    CHandleFactory m_DeviceHandles; // Used to create device handles
    CHandleFactory m_SetHandles;    // Used to create state sets
    CStateSet   m_BufferSet;
    DWORD       m_dwFlags;
};

// This is RESERVED0 in d3dhal.h
#define D3DDP2OP_FRONTENDDATA   4           // Used by the front-end only

// This structure is used by the front-end only
typedef struct _D3DHAL_DP2FRONTENDDATA
{
    WORD   wStage;      // texture stage
    LPVOID pTexture;    // Texture pointer
} D3DHAL_DP2FRONTENDDATA, *LPD3DHAL_DP2FRONTENDDATA;

#endif //_STATESTE_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\surfiter.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       surfiter.hpp
 *  Content:    Utility iterator classes for cubemaps and mipmaps
 *
 ***************************************************************************/
#ifndef _SURFITER_HPP_
#define _SURFITER_HPP_

/* Mipmap iterator utility class */
class CMipmapIter
{
    // Private Data

    LPDDRAWI_DDRAWSURFACE_LCL m_currlcl;

    // Public Members

public:

    // Construct and Destroy

    CMipmapIter(LPDDRAWI_DDRAWSURFACE_LCL lpLcl) : m_currlcl(lpLcl) {}
    
    // Modifiers
    inline void operator++();
    
    // Accessors
    operator const void* () const { return m_currlcl; }
    LPDDRAWI_DDRAWSURFACE_LCL operator()() const { return m_currlcl; }
};

inline void CMipmapIter::operator++()
{
    LPATTACHLIST al = m_currlcl->lpAttachList;
    while(al != NULL)
    {
        if(al->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL)
        {
            m_currlcl = al->lpAttached;
            return;
        }
        al = al->lpLink;
    }
    m_currlcl = 0;
}

/* Cubemap iterator utility class */
class CCubemapIter
{
    // Private Data

    LPDDRAWI_DDRAWSURFACE_LCL m_currlcl;
    LPATTACHLIST m_al;

    // Public Members

public:

    // Construct and Destroy

    CCubemapIter(LPDDRAWI_DDRAWSURFACE_LCL lpLcl) : m_currlcl(lpLcl), m_al(lpLcl->lpAttachList) {}
    
    // Modifiers
    inline void operator++();
    
    // Accessors
    operator const void* () const { return m_currlcl; }
    LPDDRAWI_DDRAWSURFACE_LCL operator()() const { return m_currlcl; }
};

inline void CCubemapIter::operator++()
{
    while(m_al != NULL)
    {
        DWORD &caps2 = m_al->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2;
        if((caps2 & DDSCAPS2_CUBEMAP_ALLFACES) && !(caps2 & DDSCAPS2_MIPMAPSUBLEVEL))
        {
            m_currlcl = m_al->lpAttached;
            m_al = m_al->lpLink;
            return;
        }
        m_al = m_al->lpLink;
    }
    m_currlcl = 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=d3dim700
TARGETNAME=d3dfe
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES = ..;$(INCLUDES);$(D3DDX7)\tnl
C_DEFINES = -DBUILD_D3D_LAYER $(C_DEFINES)
USE_NATIVE_EH = 1

SOURCES=\
    ..\d3dcreat.cpp \
    ..\d3ddev.cpp   \
    ..\d3diunk.cpp  \
    ..\d3dmem.cpp   \
    ..\d3dtex.cpp   \
    ..\deviunk.cpp  \
    ..\devstate.cpp \
    ..\dlld3d.cpp   \
    ..\dp2hal.cpp   \
    ..\dphal.cpp    \
    ..\dpoldhal.cpp \
    ..\drawprim.cpp \
    ..\halbuf.cpp   \
    ..\haldrv.cpp   \
    ..\halscene.cpp \
    ..\haltex.cpp   \
    ..\hwprov.cpp   \
    ..\init.c       \
    ..\lighting.cpp \
    ..\stateset.cpp \
    ..\table.cpp    \
    ..\texman.cpp   \
    ..\tldevice.cpp \
    ..\vertbuf.cpp  \
    ..\testprov.cpp \
    ..\vwport.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\table.cpp ===
#include "pch.cpp"
#pragma hdrstop

D3DLINE LineListPrecomp[] = {
    { 0, 1 }, { 2, 3 }, { 4, 5 }, { 6, 7 }, 
    { 8, 9 }, { 10, 11 }, { 12, 13 }, { 14, 15 }, 
    { 16, 17 }, { 18, 19 }, { 20, 21 }, { 22, 23 }, 
    { 24, 25 }, { 26, 27 }, { 28, 29 }, { 30, 31 }, 
    { 32, 33 }, { 34, 35 }, { 36, 37 }, { 38, 39 }, 
    { 40, 41 }, { 42, 43 }, { 44, 45 }, { 46, 47 }, 
    { 48, 49 }, { 50, 51 }, { 52, 53 }, { 54, 55 }, 
    { 56, 57 }, { 58, 59 }, { 60, 61 }, { 62, 63 }, 
    { 64, 65 }, { 66, 67 }, { 68, 69 }, { 70, 71 }, 
    { 72, 73 }, { 74, 75 }, { 76, 77 }, { 78, 79 }, 
    { 80, 81 }, { 82, 83 }, { 84, 85 }, { 86, 87 }, 
    { 88, 89 }, { 90, 91 }, { 92, 93 }, { 94, 95 }, 
    { 96, 97 }, { 98, 99 }, { 100, 101 }, { 102, 103 }, 
    { 104, 105 }, { 106, 107 }, { 108, 109 }, { 110, 111 }, 
    { 112, 113 }, { 114, 115 }, { 116, 117 }, { 118, 119 }, 
    { 120, 121 }, { 122, 123 }, { 124, 125 }, { 126, 127 }, 
    { 128, 129 }, { 130, 131 }, { 132, 133 }, { 134, 135 }, 
    { 136, 137 }, { 138, 139 }, { 140, 141 }, { 142, 143 }, 
    { 144, 145 }, { 146, 147 }, { 148, 149 }, { 150, 151 }, 
    { 152, 153 }, { 154, 155 }, { 156, 157 }, { 158, 159 }, 
    { 160, 161 }, { 162, 163 }, { 164, 165 }, { 166, 167 }, 
    { 168, 169 }, { 170, 171 }, { 172, 173 }, { 174, 175 }, 
    { 176, 177 }, { 178, 179 }, { 180, 181 }, { 182, 183 }, 
    { 184, 185 }, { 186, 187 }, { 188, 189 }, { 190, 191 }, 
    { 192, 193 }, { 194, 195 }, { 196, 197 }, { 198, 199 }, 
    { 200, 201 }, { 202, 203 }, { 204, 205 }, { 206, 207 }, 
    { 208, 209 }, { 210, 211 }, { 212, 213 }, { 214, 215 }, 
    { 216, 217 }, { 218, 219 }, { 220, 221 }, { 222, 223 }, 
    { 224, 225 }, { 226, 227 }, { 228, 229 }, { 230, 231 }, 
    { 232, 233 }, { 234, 235 }, { 236, 237 }, { 238, 239 }, 
    { 240, 241 }, { 242, 243 }, { 244, 245 }, { 246, 247 }, 
    { 248, 249 }, { 250, 251 }, { 252, 253 }, { 254, 255 }, 
    { 256, 257 }, { 258, 259 }, { 260, 261 }, { 262, 263 }, 
    { 264, 265 }, { 266, 267 }, { 268, 269 }, { 270, 271 }, 
    { 272, 273 }, { 274, 275 }, { 276, 277 }, { 278, 279 }, 
    { 280, 281 }, { 282, 283 }, { 284, 285 }, { 286, 287 }, 
    { 288, 289 }, { 290, 291 }, { 292, 293 }, { 294, 295 }, 
    { 296, 297 }, { 298, 299 }, { 300, 301 }, { 302, 303 }, 
    { 304, 305 }, { 306, 307 }, { 308, 309 }, { 310, 311 }, 
    { 312, 313 }, { 314, 315 }, { 316, 317 }, { 318, 319 }, 
    { 320, 321 }, { 322, 323 }, { 324, 325 }, { 326, 327 }, 
    { 328, 329 }, { 330, 331 }, { 332, 333 }, { 334, 335 }, 
    { 336, 337 }, { 338, 339 }, { 340, 341 }, { 342, 343 }, 
    { 344, 345 }, { 346, 347 }, { 348, 349 }, { 350, 351 }, 
    { 352, 353 }, { 354, 355 }, { 356, 357 }, { 358, 359 }, 
    { 360, 361 }, { 362, 363 }, { 364, 365 }, { 366, 367 }, 
    { 368, 369 }, { 370, 371 }, { 372, 373 }, { 374, 375 }, 
    { 376, 377 }, { 378, 379 }, { 380, 381 }, { 382, 383 }, 
    { 384, 385 }, { 386, 387 }, { 388, 389 }, { 390, 391 }, 
    { 392, 393 }, { 394, 395 }, { 396, 397 }, { 398, 399 }, 
    { 400, 401 }, { 402, 403 }, { 404, 405 }, { 406, 407 }, 
    { 408, 409 }, { 410, 411 }, { 412, 413 }, { 414, 415 }, 
    { 416, 417 }, { 418, 419 }, { 420, 421 }, { 422, 423 }, 
    { 424, 425 }, { 426, 427 }, { 428, 429 }, { 430, 431 }, 
    { 432, 433 }, { 434, 435 }, { 436, 437 }, { 438, 439 }, 
    { 440, 441 }, { 442, 443 }, { 444, 445 }, { 446, 447 }, 
    { 448, 449 }, { 450, 451 }, { 452, 453 }, { 454, 455 }, 
    { 456, 457 }, { 458, 459 }, { 460, 461 }, { 462, 463 }, 
    { 464, 465 }, { 466, 467 }, { 468, 469 }, { 470, 471 }, 
    { 472, 473 }, { 474, 475 }, { 476, 477 }, { 478, 479 }, 
    { 480, 481 }, { 482, 483 }, { 484, 485 }, { 486, 487 }, 
    { 488, 489 }, { 490, 491 }, { 492, 493 }, { 494, 495 }, 
    { 496, 497 }, { 498, 499 }, { 500, 501 }, { 502, 503 }, 
    { 504, 505 }, { 506, 507 }, { 508, 509 }, { 510, 511 },
    { 512, 513 }, { 514, 515 }, { 516, 517 }, { 518, 519 },
    { 520, 521 }, { 522, 523 }, { 524, 525 }, { 526, 527 }, 
    { 528, 529 }, { 530, 531 }, { 532, 533 }, { 534, 535 }, 
    { 536, 537 }, { 538, 539 }, { 540, 541 }, { 542, 543 }, 
    { 544, 545 }, { 546, 547 }, { 548, 549 }, { 550, 551 }, 
    { 552, 553 }, { 554, 555 }, { 556, 557 }, { 558, 559 }, 
    { 560, 561 }, { 562, 563 }, { 564, 565 }, { 566, 567 }, 
    { 568, 569 }, { 570, 571 }, { 572, 573 }, { 574, 575 }, 
    { 576, 577 }, { 578, 579 }, { 580, 581 }, { 582, 583 }, 
    { 584, 585 }, { 586, 587 }, { 588, 589 }, { 590, 591 }, 
    { 592, 593 }, { 594, 595 }, { 596, 597 }, { 598, 599 }, 
    { 600, 601 }, { 602, 603 }, { 604, 605 }, { 606, 607 }, 
    { 608, 609 }, { 610, 611 }, { 612, 613 }, { 614, 615 }, 
    { 616, 617 }, { 618, 619 }, { 620, 621 }, { 622, 623 }, 
    { 624, 625 }, { 626, 627 }, { 628, 629 }, { 630, 631 }, 
    { 632, 633 }, { 634, 635 }, { 636, 637 }, { 638, 639 }, 
    { 640, 641 }, { 642, 643 }, { 644, 645 }, { 646, 647 }, 
    { 648, 649 }, { 650, 651 }, { 652, 653 }, { 654, 655 }, 
    { 656, 657 }, { 658, 659 }, { 660, 661 }, { 662, 663 }, 
    { 664, 665 }, { 666, 667 }, { 668, 669 }, { 670, 671 }, 
    { 672, 673 }, { 674, 675 }, { 676, 677 }, { 678, 679 }, 
    { 680, 681 }, { 682, 683 }, { 684, 685 }, { 686, 687 }, 
    { 688, 689 }, { 690, 691 }, { 692, 693 }, { 694, 695 }, 
    { 696, 697 }, { 698, 699 }, { 700, 701 }, { 702, 703 }, 
    { 704, 705 }, { 706, 707 }, { 708, 709 }, { 710, 711 }, 
    { 712, 713 }, { 714, 715 }, { 716, 717 }, { 718, 719 }, 
    { 720, 721 }, { 722, 723 }, { 724, 725 }, { 726, 727 }, 
    { 728, 729 }, { 730, 731 }, { 732, 733 }, { 734, 735 }, 
    { 736, 737 }, { 738, 739 }, { 740, 741 }, { 742, 743 }, 
    { 744, 745 }, { 746, 747 }, { 748, 749 }, { 750, 751 }, 
    { 752, 753 }, { 754, 755 }, { 756, 757 }, { 758, 759 }, 
    { 760, 761 }, { 762, 763 }, { 764, 765 }, { 766, 767 }, 
    { 768, 769 }, { 770, 771 }, { 772, 773 }, { 774, 775 }, 
    { 776, 777 }, { 778, 779 }, { 780, 781 }, { 782, 783 }, 
    { 784, 785 }, { 786, 787 }, { 788, 789 }, { 790, 791 }, 
    { 792, 793 }, { 794, 795 }, { 796, 797 }, { 798, 799 }, 
    { 800, 801 }, { 802, 803 }, { 804, 805 }, { 806, 807 }, 
    { 808, 809 }, { 810, 811 }, { 812, 813 }, { 814, 815 }, 
    { 816, 817 }, { 818, 819 }, { 820, 821 }, { 822, 823 }, 
    { 824, 825 }, { 826, 827 }, { 828, 829 }, { 830, 831 }, 
    { 832, 833 }, { 834, 835 }, { 836, 837 }, { 838, 839 }, 
    { 840, 841 }, { 842, 843 }, { 844, 845 }, { 846, 847 }, 
    { 848, 849 }, { 850, 851 }, { 852, 853 }, { 854, 855 }, 
    { 856, 857 }, { 858, 859 }, { 860, 861 }, { 862, 863 }, 
    { 864, 865 }, { 866, 867 }, { 868, 869 }, { 870, 871 }, 
    { 872, 873 }, { 874, 875 }, { 876, 877 }, { 878, 879 }, 
    { 880, 881 }, { 882, 883 }, { 884, 885 }, { 886, 887 }, 
    { 888, 889 }, { 890, 891 }, { 892, 893 }, { 894, 895 }, 
    { 896, 897 }, { 898, 899 }, { 900, 901 }, { 902, 903 }, 
    { 904, 905 }, { 906, 907 }, { 908, 909 }, { 910, 911 }, 
    { 912, 913 }, { 914, 915 }, { 916, 917 }, { 918, 919 }, 
    { 920, 921 }, { 922, 923 }, { 924, 925 }, { 926, 927 }, 
    { 928, 929 }, { 930, 931 }, { 932, 933 }, { 934, 935 }, 
    { 936, 937 }, { 938, 939 }, { 940, 941 }, { 942, 943 }, 
    { 944, 945 }, { 946, 947 }, { 948, 949 }, { 950, 951 }, 
    { 952, 953 }, { 954, 955 }, { 956, 957 }, { 958, 959 }, 
    { 960, 961 }, { 962, 963 }, { 964, 965 }, { 966, 967 }, 
    { 968, 969 }, { 970, 971 }, { 972, 973 }, { 974, 975 }, 
    { 976, 977 }, { 978, 979 }, { 980, 981 }, { 982, 983 }, 
    { 984, 985 }, { 986, 987 }, { 988, 989 }, { 990, 991 }, 
    { 992, 993 }, { 994, 995 }, { 996, 997 }, { 998, 999 }, 
    { 1000, 1001 }, { 1002, 1003 }, { 1004, 1005 }, { 1006, 1007 }, 
    { 1008, 1009 }, { 1010, 1011 }, { 1012, 1013 }, { 1014, 1015 }, 
    { 1016, 1017 }, { 1018, 1019 }, { 1020, 1021 }, { 1022, 1023 }, 
    };

D3DLINE LineStripPrecomp[] = {
    { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 }, 
    { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 8 }, 
    { 8, 9 }, { 9, 10 }, { 10, 11 }, { 11, 12 }, 
    { 12, 13 }, { 13, 14 }, { 14, 15 }, { 15, 16 }, 
    { 16, 17 }, { 17, 18 }, { 18, 19 }, { 19, 20 }, 
    { 20, 21 }, { 21, 22 }, { 22, 23 }, { 23, 24 }, 
    { 24, 25 }, { 25, 26 }, { 26, 27 }, { 27, 28 }, 
    { 28, 29 }, { 29, 30 }, { 30, 31 }, { 31, 32 }, 
    { 32, 33 }, { 33, 34 }, { 34, 35 }, { 35, 36 }, 
    { 36, 37 }, { 37, 38 }, { 38, 39 }, { 39, 40 }, 
    { 40, 41 }, { 41, 42 }, { 42, 43 }, { 43, 44 }, 
    { 44, 45 }, { 45, 46 }, { 46, 47 }, { 47, 48 }, 
    { 48, 49 }, { 49, 50 }, { 50, 51 }, { 51, 52 }, 
    { 52, 53 }, { 53, 54 }, { 54, 55 }, { 55, 56 }, 
    { 56, 57 }, { 57, 58 }, { 58, 59 }, { 59, 60 }, 
    { 60, 61 }, { 61, 62 }, { 62, 63 }, { 63, 64 }, 
    { 64, 65 }, { 65, 66 }, { 66, 67 }, { 67, 68 }, 
    { 68, 69 }, { 69, 70 }, { 70, 71 }, { 71, 72 }, 
    { 72, 73 }, { 73, 74 }, { 74, 75 }, { 75, 76 }, 
    { 76, 77 }, { 77, 78 }, { 78, 79 }, { 79, 80 }, 
    { 80, 81 }, { 81, 82 }, { 82, 83 }, { 83, 84 }, 
    { 84, 85 }, { 85, 86 }, { 86, 87 }, { 87, 88 }, 
    { 88, 89 }, { 89, 90 }, { 90, 91 }, { 91, 92 }, 
    { 92, 93 }, { 93, 94 }, { 94, 95 }, { 95, 96 }, 
    { 96, 97 }, { 97, 98 }, { 98, 99 }, { 99, 100 }, 
    { 100, 101 }, { 101, 102 }, { 102, 103 }, { 103, 104 }, 
    { 104, 105 }, { 105, 106 }, { 106, 107 }, { 107, 108 }, 
    { 108, 109 }, { 109, 110 }, { 110, 111 }, { 111, 112 }, 
    { 112, 113 }, { 113, 114 }, { 114, 115 }, { 115, 116 }, 
    { 116, 117 }, { 117, 118 }, { 118, 119 }, { 119, 120 }, 
    { 120, 121 }, { 121, 122 }, { 122, 123 }, { 123, 124 }, 
    { 124, 125 }, { 125, 126 }, { 126, 127 }, { 127, 128 }, 
    { 128, 129 }, { 129, 130 }, { 130, 131 }, { 131, 132 }, 
    { 132, 133 }, { 133, 134 }, { 134, 135 }, { 135, 136 }, 
    { 136, 137 }, { 137, 138 }, { 138, 139 }, { 139, 140 }, 
    { 140, 141 }, { 141, 142 }, { 142, 143 }, { 143, 144 }, 
    { 144, 145 }, { 145, 146 }, { 146, 147 }, { 147, 148 }, 
    { 148, 149 }, { 149, 150 }, { 150, 151 }, { 151, 152 }, 
    { 152, 153 }, { 153, 154 }, { 154, 155 }, { 155, 156 }, 
    { 156, 157 }, { 157, 158 }, { 158, 159 }, { 159, 160 }, 
    { 160, 161 }, { 161, 162 }, { 162, 163 }, { 163, 164 }, 
    { 164, 165 }, { 165, 166 }, { 166, 167 }, { 167, 168 }, 
    { 168, 169 }, { 169, 170 }, { 170, 171 }, { 171, 172 }, 
    { 172, 173 }, { 173, 174 }, { 174, 175 }, { 175, 176 }, 
    { 176, 177 }, { 177, 178 }, { 178, 179 }, { 179, 180 }, 
    { 180, 181 }, { 181, 182 }, { 182, 183 }, { 183, 184 }, 
    { 184, 185 }, { 185, 186 }, { 186, 187 }, { 187, 188 }, 
    { 188, 189 }, { 189, 190 }, { 190, 191 }, { 191, 192 }, 
    { 192, 193 }, { 193, 194 }, { 194, 195 }, { 195, 196 }, 
    { 196, 197 }, { 197, 198 }, { 198, 199 }, { 199, 200 }, 
    { 200, 201 }, { 201, 202 }, { 202, 203 }, { 203, 204 }, 
    { 204, 205 }, { 205, 206 }, { 206, 207 }, { 207, 208 }, 
    { 208, 209 }, { 209, 210 }, { 210, 211 }, { 211, 212 }, 
    { 212, 213 }, { 213, 214 }, { 214, 215 }, { 215, 216 }, 
    { 216, 217 }, { 217, 218 }, { 218, 219 }, { 219, 220 }, 
    { 220, 221 }, { 221, 222 }, { 222, 223 }, { 223, 224 }, 
    { 224, 225 }, { 225, 226 }, { 226, 227 }, { 227, 228 }, 
    { 228, 229 }, { 229, 230 }, { 230, 231 }, { 231, 232 }, 
    { 232, 233 }, { 233, 234 }, { 234, 235 }, { 235, 236 }, 
    { 236, 237 }, { 237, 238 }, { 238, 239 }, { 239, 240 }, 
    { 240, 241 }, { 241, 242 }, { 242, 243 }, { 243, 244 }, 
    { 244, 245 }, { 245, 246 }, { 246, 247 }, { 247, 248 }, 
    { 248, 249 }, { 249, 250 }, { 250, 251 }, { 251, 252 }, 
    { 252, 253 }, { 253, 254 }, { 254, 255 }, { 255, 256 },
    { 256, 257 }, { 257, 258 }, { 258, 259 }, { 259, 260 }, 
    { 260, 261 }, { 261, 262 }, { 262, 263 }, { 263, 264 }, 
    { 264, 265 }, { 265, 266 }, { 266, 267 }, { 267, 268 }, 
    { 268, 269 }, { 269, 270 }, { 270, 271 }, { 271, 272 }, 
    { 272, 273 }, { 273, 274 }, { 274, 275 }, { 275, 276 }, 
    { 276, 277 }, { 277, 278 }, { 278, 279 }, { 279, 280 }, 
    { 280, 281 }, { 281, 282 }, { 282, 283 }, { 283, 284 }, 
    { 284, 285 }, { 285, 286 }, { 286, 287 }, { 287, 288 }, 
    { 288, 289 }, { 289, 290 }, { 290, 291 }, { 291, 292 }, 
    { 292, 293 }, { 293, 294 }, { 294, 295 }, { 295, 296 }, 
    { 296, 297 }, { 297, 298 }, { 298, 299 }, { 299, 300 }, 
    { 300, 301 }, { 301, 302 }, { 302, 303 }, { 303, 304 }, 
    { 304, 305 }, { 305, 306 }, { 306, 307 }, { 307, 308 }, 
    { 308, 309 }, { 309, 310 }, { 310, 311 }, { 311, 312 }, 
    { 312, 313 }, { 313, 314 }, { 314, 315 }, { 315, 316 }, 
    { 316, 317 }, { 317, 318 }, { 318, 319 }, { 319, 320 }, 
    { 320, 321 }, { 321, 322 }, { 322, 323 }, { 323, 324 }, 
    { 324, 325 }, { 325, 326 }, { 326, 327 }, { 327, 328 }, 
    { 328, 329 }, { 329, 330 }, { 330, 331 }, { 331, 332 }, 
    { 332, 333 }, { 333, 334 }, { 334, 335 }, { 335, 336 }, 
    { 336, 337 }, { 337, 338 }, { 338, 339 }, { 339, 340 }, 
    { 340, 341 }, { 341, 342 }, { 342, 343 }, { 343, 344 }, 
    { 344, 345 }, { 345, 346 }, { 346, 347 }, { 347, 348 }, 
    { 348, 349 }, { 349, 350 }, { 350, 351 }, { 351, 352 }, 
    { 352, 353 }, { 353, 354 }, { 354, 355 }, { 355, 356 }, 
    { 356, 357 }, { 357, 358 }, { 358, 359 }, { 359, 360 }, 
    { 360, 361 }, { 361, 362 }, { 362, 363 }, { 363, 364 }, 
    { 364, 365 }, { 365, 366 }, { 366, 367 }, { 367, 368 }, 
    { 368, 369 }, { 369, 370 }, { 370, 371 }, { 371, 372 }, 
    { 372, 373 }, { 373, 374 }, { 374, 375 }, { 375, 376 }, 
    { 376, 377 }, { 377, 378 }, { 378, 379 }, { 379, 380 }, 
    { 380, 381 }, { 381, 382 }, { 382, 383 }, { 383, 384 }, 
    { 384, 385 }, { 385, 386 }, { 386, 387 }, { 387, 388 }, 
    { 388, 389 }, { 389, 390 }, { 390, 391 }, { 391, 392 }, 
    { 392, 393 }, { 393, 394 }, { 394, 395 }, { 395, 396 }, 
    { 396, 397 }, { 397, 398 }, { 398, 399 }, { 399, 400 }, 
    { 400, 401 }, { 401, 402 }, { 402, 403 }, { 403, 404 }, 
    { 404, 405 }, { 405, 406 }, { 406, 407 }, { 407, 408 }, 
    { 408, 409 }, { 409, 410 }, { 410, 411 }, { 411, 412 }, 
    { 412, 413 }, { 413, 414 }, { 414, 415 }, { 415, 416 }, 
    { 416, 417 }, { 417, 418 }, { 418, 419 }, { 419, 420 }, 
    { 420, 421 }, { 421, 422 }, { 422, 423 }, { 423, 424 }, 
    { 424, 425 }, { 425, 426 }, { 426, 427 }, { 427, 428 }, 
    { 428, 429 }, { 429, 430 }, { 430, 431 }, { 431, 432 }, 
    { 432, 433 }, { 433, 434 }, { 434, 435 }, { 435, 436 }, 
    { 436, 437 }, { 437, 438 }, { 438, 439 }, { 439, 440 }, 
    { 440, 441 }, { 441, 442 }, { 442, 443 }, { 443, 444 }, 
    { 444, 445 }, { 445, 446 }, { 446, 447 }, { 447, 448 }, 
    { 448, 449 }, { 449, 450 }, { 450, 451 }, { 451, 452 }, 
    { 452, 453 }, { 453, 454 }, { 454, 455 }, { 455, 456 }, 
    { 456, 457 }, { 457, 458 }, { 458, 459 }, { 459, 460 }, 
    { 460, 461 }, { 461, 462 }, { 462, 463 }, { 463, 464 }, 
    { 464, 465 }, { 465, 466 }, { 466, 467 }, { 467, 468 }, 
    { 468, 469 }, { 469, 470 }, { 470, 471 }, { 471, 472 }, 
    { 472, 473 }, { 473, 474 }, { 474, 475 }, { 475, 476 }, 
    { 476, 477 }, { 477, 478 }, { 478, 479 }, { 479, 480 }, 
    { 480, 481 }, { 481, 482 }, { 482, 483 }, { 483, 484 }, 
    { 484, 485 }, { 485, 486 }, { 486, 487 }, { 487, 488 }, 
    { 488, 489 }, { 489, 490 }, { 490, 491 }, { 491, 492 }, 
    { 492, 493 }, { 493, 494 }, { 494, 495 }, { 495, 496 }, 
    { 496, 497 }, { 497, 498 }, { 498, 499 }, { 499, 500 }, 
    { 500, 501 }, { 501, 502 }, { 502, 503 }, { 503, 504 }, 
    { 504, 505 }, { 505, 506 }, { 506, 507 }, { 507, 508 }, 
    { 508, 509 }, { 509, 510 }, { 510, 511 }, { 511, 512 }, 
    };

D3DTRIANGLE TriangleListPrecomp[] = {
    { 0, 1, 2, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 3, 4, 5, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 6, 7, 8, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 9, 10, 11, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 12, 13, 14, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 15, 16, 17, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 18, 19, 20, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 21, 22, 23, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 24, 25, 26, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 27, 28, 29, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 30, 31, 32, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 33, 34, 35, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 36, 37, 38, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 39, 40, 41, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 42, 43, 44, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 45, 46, 47, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 48, 49, 50, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 51, 52, 53, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 54, 55, 56, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 57, 58, 59, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 60, 61, 62, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 63, 64, 65, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 66, 67, 68, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 69, 70, 71, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 72, 73, 74, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 75, 76, 77, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 78, 79, 80, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 81, 82, 83, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 84, 85, 86, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 87, 88, 89, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 90, 91, 92, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 93, 94, 95, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 96, 97, 98, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 99, 100, 101, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 102, 103, 104, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 105, 106, 107, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 108, 109, 110, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 111, 112, 113, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 114, 115, 116, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 117, 118, 119, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 120, 121, 122, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 123, 124, 125, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 126, 127, 128, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 129, 130, 131, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 132, 133, 134, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 135, 136, 137, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 138, 139, 140, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 141, 142, 143, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 144, 145, 146, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 147, 148, 149, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 150, 151, 152, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 153, 154, 155, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 156, 157, 158, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 159, 160, 161, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 162, 163, 164, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 165, 166, 167, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 168, 169, 170, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 171, 172, 173, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 174, 175, 176, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 177, 178, 179, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 180, 181, 182, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 183, 184, 185, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 186, 187, 188, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 189, 190, 191, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 192, 193, 194, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 195, 196, 197, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 198, 199, 200, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 201, 202, 203, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 204, 205, 206, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 207, 208, 209, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 210, 211, 212, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 213, 214, 215, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 216, 217, 218, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 219, 220, 221, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 222, 223, 224, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 225, 226, 227, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 228, 229, 230, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 231, 232, 233, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 234, 235, 236, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 237, 238, 239, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 240, 241, 242, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 243, 244, 245, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 246, 247, 248, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 249, 250, 251, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 252, 253, 254, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 255, 256, 257, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 258, 259, 260, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 261, 262, 263, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 264, 265, 266, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 267, 268, 269, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 270, 271, 272, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 273, 274, 275, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 276, 277, 278, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 279, 280, 281, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 282, 283, 284, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 285, 286, 287, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 288, 289, 290, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 291, 292, 293, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 294, 295, 296, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 297, 298, 299, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 300, 301, 302, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 303, 304, 305, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 306, 307, 308, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 309, 310, 311, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 312, 313, 314, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 315, 316, 317, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 318, 319, 320, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 321, 322, 323, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 324, 325, 326, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 327, 328, 329, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 330, 331, 332, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 333, 334, 335, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 336, 337, 338, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 339, 340, 341, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 342, 343, 344, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 345, 346, 347, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 348, 349, 350, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 351, 352, 353, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 354, 355, 356, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 357, 358, 359, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 360, 361, 362, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 363, 364, 365, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 366, 367, 368, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 369, 370, 371, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 372, 373, 374, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 375, 376, 377, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 378, 379, 380, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 381, 382, 383, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 384, 385, 386, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 387, 388, 389, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 390, 391, 392, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 393, 394, 395, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 396, 397, 398, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 399, 400, 401, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 402, 403, 404, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 405, 406, 407, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 408, 409, 410, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 411, 412, 413, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 414, 415, 416, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 417, 418, 419, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 420, 421, 422, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 423, 424, 425, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 426, 427, 428, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 429, 430, 431, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 432, 433, 434, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 435, 436, 437, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 438, 439, 440, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 441, 442, 443, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 444, 445, 446, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 447, 448, 449, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 450, 451, 452, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 453, 454, 455, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 456, 457, 458, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 459, 460, 461, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 462, 463, 464, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 465, 466, 467, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 468, 469, 470, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 471, 472, 473, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 474, 475, 476, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 477, 478, 479, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 480, 481, 482, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 483, 484, 485, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 486, 487, 488, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 489, 490, 491, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 492, 493, 494, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 495, 496, 497, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 498, 499, 500, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 501, 502, 503, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 504, 505, 506, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 507, 508, 509, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 510, 511, 512, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 513, 514, 515, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 516, 517, 518, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 519, 520, 521, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 522, 523, 524, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 525, 526, 527, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 528, 529, 530, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 531, 532, 533, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 534, 535, 536, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 537, 538, 539, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 540, 541, 542, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 543, 544, 545, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 546, 547, 548, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 549, 550, 551, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 552, 553, 554, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 555, 556, 557, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 558, 559, 560, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 561, 562, 563, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 564, 565, 566, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 567, 568, 569, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 570, 571, 572, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 573, 574, 575, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 576, 577, 578, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 579, 580, 581, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 582, 583, 584, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 585, 586, 587, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 588, 589, 590, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 591, 592, 593, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 594, 595, 596, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 597, 598, 599, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 600, 601, 602, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 603, 604, 605, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 606, 607, 608, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 609, 610, 611, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 612, 613, 614, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 615, 616, 617, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 618, 619, 620, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 621, 622, 623, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 624, 625, 626, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 627, 628, 629, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 630, 631, 632, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 633, 634, 635, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 636, 637, 638, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 639, 640, 641, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 642, 643, 644, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 645, 646, 647, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 648, 649, 650, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 651, 652, 653, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 654, 655, 656, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 657, 658, 659, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 660, 661, 662, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 663, 664, 665, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 666, 667, 668, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 669, 670, 671, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 672, 673, 674, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 675, 676, 677, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 678, 679, 680, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 681, 682, 683, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 684, 685, 686, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 687, 688, 689, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 690, 691, 692, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 693, 694, 695, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 696, 697, 698, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 699, 700, 701, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 702, 703, 704, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 705, 706, 707, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 708, 709, 710, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 711, 712, 713, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 714, 715, 716, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 717, 718, 719, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 720, 721, 722, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 723, 724, 725, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 726, 727, 728, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 729, 730, 731, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 732, 733, 734, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 735, 736, 737, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 738, 739, 740, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 741, 742, 743, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 744, 745, 746, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 747, 748, 749, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 750, 751, 752, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 753, 754, 755, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 756, 757, 758, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 759, 760, 761, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 762, 763, 764, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 765, 766, 767, D3DTRIFLAG_EDGEENABLETRIANGLE },
};

D3DTRIANGLE TriangleStripPrecomp[] = {
    { 0, 1, 2, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 1, 3, 2, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 2, 3, 4, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 3, 5, 4, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 4, 5, 6, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 5, 7, 6, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 6, 7, 8, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 7, 9, 8, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 8, 9, 10, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 9, 11, 10, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 10, 11, 12, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 11, 13, 12, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 12, 13, 14, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 13, 15, 14, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 14, 15, 16, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 15, 17, 16, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 16, 17, 18, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 17, 19, 18, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 18, 19, 20, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 19, 21, 20, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 20, 21, 22, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 21, 23, 22, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 22, 23, 24, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 23, 25, 24, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 24, 25, 26, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 25, 27, 26, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 26, 27, 28, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 27, 29, 28, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 28, 29, 30, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 29, 31, 30, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 30, 31, 32, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 31, 33, 32, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 32, 33, 34, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 33, 35, 34, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 34, 35, 36, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 35, 37, 36, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 36, 37, 38, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 37, 39, 38, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 38, 39, 40, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 39, 41, 40, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 40, 41, 42, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 41, 43, 42, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 42, 43, 44, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 43, 45, 44, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 44, 45, 46, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 45, 47, 46, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 46, 47, 48, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 47, 49, 48, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 48, 49, 50, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 49, 51, 50, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 50, 51, 52, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 51, 53, 52, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 52, 53, 54, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 53, 55, 54, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 54, 55, 56, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 55, 57, 56, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 56, 57, 58, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 57, 59, 58, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 58, 59, 60, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 59, 61, 60, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 60, 61, 62, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 61, 63, 62, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 62, 63, 64, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 63, 65, 64, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 64, 65, 66, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 65, 67, 66, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 66, 67, 68, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 67, 69, 68, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 68, 69, 70, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 69, 71, 70, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 70, 71, 72, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 71, 73, 72, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 72, 73, 74, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 73, 75, 74, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 74, 75, 76, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 75, 77, 76, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 76, 77, 78, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 77, 79, 78, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 78, 79, 80, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 79, 81, 80, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 80, 81, 82, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 81, 83, 82, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 82, 83, 84, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 83, 85, 84, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 84, 85, 86, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 85, 87, 86, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 86, 87, 88, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 87, 89, 88, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 88, 89, 90, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 89, 91, 90, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 90, 91, 92, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 91, 93, 92, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 92, 93, 94, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 93, 95, 94, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 94, 95, 96, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 95, 97, 96, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 96, 97, 98, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 97, 99, 98, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 98, 99, 100, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 99, 101, 100, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 100, 101, 102, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 101, 103, 102, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 102, 103, 104, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 103, 105, 104, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 104, 105, 106, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 105, 107, 106, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 106, 107, 108, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 107, 109, 108, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 108, 109, 110, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 109, 111, 110, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 110, 111, 112, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 111, 113, 112, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 112, 113, 114, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 113, 115, 114, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 114, 115, 116, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 115, 117, 116, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 116, 117, 118, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 117, 119, 118, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 118, 119, 120, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 119, 121, 120, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 120, 121, 122, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 121, 123, 122, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 122, 123, 124, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 123, 125, 124, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 124, 125, 126, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 125, 127, 126, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 126, 127, 128, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 127, 129, 128, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 128, 129, 130, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 129, 131, 130, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 130, 131, 132, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 131, 133, 132, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 132, 133, 134, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 133, 135, 134, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 134, 135, 136, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 135, 137, 136, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 136, 137, 138, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 137, 139, 138, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 138, 139, 140, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 139, 141, 140, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 140, 141, 142, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 141, 143, 142, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 142, 143, 144, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 143, 145, 144, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 144, 145, 146, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 145, 147, 146, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 146, 147, 148, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 147, 149, 148, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 148, 149, 150, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 149, 151, 150, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 150, 151, 152, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 151, 153, 152, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 152, 153, 154, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 153, 155, 154, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 154, 155, 156, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 155, 157, 156, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 156, 157, 158, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 157, 159, 158, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 158, 159, 160, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 159, 161, 160, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 160, 161, 162, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 161, 163, 162, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 162, 163, 164, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 163, 165, 164, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 164, 165, 166, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 165, 167, 166, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 166, 167, 168, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 167, 169, 168, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 168, 169, 170, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 169, 171, 170, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 170, 171, 172, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 171, 173, 172, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 172, 173, 174, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 173, 175, 174, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 174, 175, 176, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 175, 177, 176, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 176, 177, 178, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 177, 179, 178, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 178, 179, 180, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 179, 181, 180, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 180, 181, 182, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 181, 183, 182, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 182, 183, 184, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 183, 185, 184, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 184, 185, 186, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 185, 187, 186, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 186, 187, 188, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 187, 189, 188, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 188, 189, 190, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 189, 191, 190, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 190, 191, 192, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 191, 193, 192, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 192, 193, 194, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 193, 195, 194, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 194, 195, 196, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 195, 197, 196, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 196, 197, 198, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 197, 199, 198, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 198, 199, 200, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 199, 201, 200, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 200, 201, 202, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 201, 203, 202, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 202, 203, 204, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 203, 205, 204, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 204, 205, 206, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 205, 207, 206, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 206, 207, 208, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 207, 209, 208, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 208, 209, 210, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 209, 211, 210, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 210, 211, 212, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 211, 213, 212, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 212, 213, 214, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 213, 215, 214, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 214, 215, 216, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 215, 217, 216, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 216, 217, 218, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 217, 219, 218, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 218, 219, 220, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 219, 221, 220, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 220, 221, 222, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 221, 223, 222, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 222, 223, 224, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 223, 225, 224, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 224, 225, 226, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 225, 227, 226, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 226, 227, 228, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 227, 229, 228, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 228, 229, 230, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 229, 231, 230, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 230, 231, 232, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 231, 233, 232, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 232, 233, 234, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 233, 235, 234, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 234, 235, 236, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 235, 237, 236, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 236, 237, 238, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 237, 239, 238, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 238, 239, 240, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 239, 241, 240, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 240, 241, 242, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 241, 243, 242, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 242, 243, 244, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 243, 245, 244, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 244, 245, 246, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 245, 247, 246, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 246, 247, 248, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 247, 249, 248, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 248, 249, 250, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 249, 251, 250, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 250, 251, 252, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 251, 253, 252, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 252, 253, 254, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 253, 255, 254, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 254, 255, 256, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 255, 257, 256, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    };

D3DTRIANGLE TriangleFanPrecomp[] = {
    { 1, 2, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 2, 3, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 3, 4, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 4, 5, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 5, 6, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 6, 7, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 7, 8, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 8, 9, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 9, 10, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 10, 11, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 11, 12, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 12, 13, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 13, 14, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 14, 15, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 15, 16, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 16, 17, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 17, 18, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 18, 19, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 19, 20, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 20, 21, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 21, 22, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 22, 23, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 23, 24, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 24, 25, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 25, 26, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 26, 27, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 27, 28, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 28, 29, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 29, 30, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 30, 31, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 31, 32, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 32, 33, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 33, 34, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 34, 35, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 35, 36, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 36, 37, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 37, 38, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 38, 39, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 39, 40, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 40, 41, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 41, 42, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 42, 43, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 43, 44, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 44, 45, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 45, 46, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 46, 47, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 47, 48, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 48, 49, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 49, 50, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 50, 51, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 51, 52, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 52, 53, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 53, 54, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 54, 55, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 55, 56, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 56, 57, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 57, 58, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 58, 59, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 59, 60, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 60, 61, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 61, 62, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 62, 63, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 63, 64, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 64, 65, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 65, 66, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 66, 67, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 67, 68, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 68, 69, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 69, 70, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 70, 71, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 71, 72, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 72, 73, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 73, 74, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 74, 75, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 75, 76, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 76, 77, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 77, 78, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 78, 79, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 79, 80, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 80, 81, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 81, 82, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 82, 83, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 83, 84, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 84, 85, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 85, 86, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 86, 87, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 87, 88, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 88, 89, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 89, 90, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 90, 91, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 91, 92, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 92, 93, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 93, 94, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 94, 95, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 95, 96, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 96, 97, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 97, 98, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 98, 99, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 99, 100, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 100, 101, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 101, 102, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 102, 103, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 103, 104, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 104, 105, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 105, 106, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 106, 107, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 107, 108, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 108, 109, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 109, 110, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 110, 111, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 111, 112, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 112, 113, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 113, 114, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 114, 115, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 115, 116, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 116, 117, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 117, 118, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 118, 119, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 119, 120, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 120, 121, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 121, 122, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 122, 123, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 123, 124, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 124, 125, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 125, 126, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 126, 127, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 127, 128, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 128, 129, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 129, 130, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 130, 131, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 131, 132, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 132, 133, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 133, 134, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 134, 135, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 135, 136, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 136, 137, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 137, 138, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 138, 139, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 139, 140, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 140, 141, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 141, 142, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 142, 143, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 143, 144, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 144, 145, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 145, 146, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 146, 147, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 147, 148, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 148, 149, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 149, 150, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 150, 151, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 151, 152, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 152, 153, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 153, 154, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 154, 155, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 155, 156, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 156, 157, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 157, 158, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 158, 159, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 159, 160, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 160, 161, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 161, 162, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 162, 163, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 163, 164, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 164, 165, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 165, 166, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 166, 167, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 167, 168, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 168, 169, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 169, 170, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 170, 171, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 171, 172, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 172, 173, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 173, 174, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 174, 175, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 175, 176, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 176, 177, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 177, 178, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 178, 179, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 179, 180, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 180, 181, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 181, 182, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 182, 183, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 183, 184, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 184, 185, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 185, 186, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 186, 187, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 187, 188, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 188, 189, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 189, 190, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 190, 191, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 191, 192, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 192, 193, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 193, 194, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 194, 195, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 195, 196, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 196, 197, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 197, 198, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 198, 199, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 199, 200, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 200, 201, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 201, 202, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 202, 203, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 203, 204, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 204, 205, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 205, 206, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 206, 207, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 207, 208, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 208, 209, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 209, 210, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 210, 211, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 211, 212, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 212, 213, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 213, 214, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 214, 215, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 215, 216, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 216, 217, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 217, 218, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 218, 219, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 219, 220, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 220, 221, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 221, 222, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 222, 223, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 223, 224, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 224, 225, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 225, 226, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 226, 227, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 227, 228, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 228, 229, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 229, 230, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 230, 231, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 231, 232, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 232, 233, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 233, 234, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 234, 235, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 235, 236, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 236, 237, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 237, 238, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 238, 239, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 239, 240, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 240, 241, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 241, 242, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 242, 243, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 243, 244, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 244, 245, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 245, 246, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 246, 247, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 247, 248, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 248, 249, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 249, 250, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 250, 251, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 251, 252, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 252, 253, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 253, 254, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 254, 255, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 255, 256, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 256, 257, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
};

/* This can be (and should be) replaced by LineListPrecomp */
WORD TriangleListPrecompDP[][3] = {
    { 0, 1, 2 }, { 3, 4, 5 },
    { 6, 7, 8 }, { 9, 10, 11 },
    { 12, 13, 14 }, { 15, 16, 17 },
    { 18, 19, 20 }, { 21, 22, 23 },
    { 24, 25, 26 }, { 27, 28, 29 },
    { 30, 31, 32 }, { 33, 34, 35 },
    { 36, 37, 38 }, { 39, 40, 41 },
    { 42, 43, 44 }, { 45, 46, 47 },
    { 48, 49, 50 }, { 51, 52, 53 },
    { 54, 55, 56 }, { 57, 58, 59 },
    { 60, 61, 62 }, { 63, 64, 65 },
    { 66, 67, 68 }, { 69, 70, 71 },
    { 72, 73, 74 }, { 75, 76, 77 },
    { 78, 79, 80 }, { 81, 82, 83 },
    { 84, 85, 86 }, { 87, 88, 89 },
    { 90, 91, 92 }, { 93, 94, 95 },
    { 96, 97, 98 }, { 99, 100, 101 },
    { 102, 103, 104 }, { 105, 106, 107 },
    { 108, 109, 110 }, { 111, 112, 113 },
    { 114, 115, 116 }, { 117, 118, 119 },
    { 120, 121, 122 }, { 123, 124, 125 },
    { 126, 127, 128 }, { 129, 130, 131 },
    { 132, 133, 134 }, { 135, 136, 137 },
    { 138, 139, 140 }, { 141, 142, 143 },
    { 144, 145, 146 }, { 147, 148, 149 },
    { 150, 151, 152 }, { 153, 154, 155 },
    { 156, 157, 158 }, { 159, 160, 161 },
    { 162, 163, 164 }, { 165, 166, 167 },
    { 168, 169, 170 }, { 171, 172, 173 },
    { 174, 175, 176 }, { 177, 178, 179 },
    { 180, 181, 182 }, { 183, 184, 185 },
    { 186, 187, 188 }, { 189, 190, 191 },
    { 192, 193, 194 }, { 195, 196, 197 },
    { 198, 199, 200 }, { 201, 202, 203 },
    { 204, 205, 206 }, { 207, 208, 209 },
    { 210, 211, 212 }, { 213, 214, 215 },
    { 216, 217, 218 }, { 219, 220, 221 },
    { 222, 223, 224 }, { 225, 226, 227 },
    { 228, 229, 230 }, { 231, 232, 233 },
    { 234, 235, 236 }, { 237, 238, 239 },
    { 240, 241, 242 }, { 243, 244, 245 },
    { 246, 247, 248 }, { 249, 250, 251 },
    { 252, 253, 254 }, { 255, 256, 257 },
    { 258, 259, 260 }, { 261, 262, 263 },
    { 264, 265, 266 }, { 267, 268, 269 },
    { 270, 271, 272 }, { 273, 274, 275 },
    { 276, 277, 278 }, { 279, 280, 281 },
    { 282, 283, 284 }, { 285, 286, 287 },
    { 288, 289, 290 }, { 291, 292, 293 },
    { 294, 295, 296 }, { 297, 298, 299 },
    { 300, 301, 302 }, { 303, 304, 305 },
    { 306, 307, 308 }, { 309, 310, 311 },
    { 312, 313, 314 }, { 315, 316, 317 },
    { 318, 319, 320 }, { 321, 322, 323 },
    { 324, 325, 326 }, { 327, 328, 329 },
    { 330, 331, 332 }, { 333, 334, 335 },
    { 336, 337, 338 }, { 339, 340, 341 },
    { 342, 343, 344 }, { 345, 346, 347 },
    { 348, 349, 350 }, { 351, 352, 353 },
    { 354, 355, 356 }, { 357, 358, 359 },
    { 360, 361, 362 }, { 363, 364, 365 },
    { 366, 367, 368 }, { 369, 370, 371 },
    { 372, 373, 374 }, { 375, 376, 377 },
    { 378, 379, 380 }, { 381, 382, 383 },
    { 384, 385, 386 }, { 387, 388, 389 },
    { 390, 391, 392 }, { 393, 394, 395 },
    { 396, 397, 398 }, { 399, 400, 401 },
    { 402, 403, 404 }, { 405, 406, 407 },
    { 408, 409, 410 }, { 411, 412, 413 },
    { 414, 415, 416 }, { 417, 418, 419 },
    { 420, 421, 422 }, { 423, 424, 425 },
    { 426, 427, 428 }, { 429, 430, 431 },
    { 432, 433, 434 }, { 435, 436, 437 },
    { 438, 439, 440 }, { 441, 442, 443 },
    { 444, 445, 446 }, { 447, 448, 449 },
    { 450, 451, 452 }, { 453, 454, 455 },
    { 456, 457, 458 }, { 459, 460, 461 },
    { 462, 463, 464 }, { 465, 466, 467 },
    { 468, 469, 470 }, { 471, 472, 473 },
    { 474, 475, 476 }, { 477, 478, 479 },
    { 480, 481, 482 }, { 483, 484, 485 },
    { 486, 487, 488 }, { 489, 490, 491 },
    { 492, 493, 494 }, { 495, 496, 497 },
    { 498, 499, 500 }, { 501, 502, 503 },
    { 504, 505, 506 }, { 507, 508, 509 },
    { 510, 511, 512 }, { 513, 514, 515 },
    { 516, 517, 518 }, { 519, 520, 521 },
    { 522, 523, 524 }, { 525, 526, 527 },
    { 528, 529, 530 }, { 531, 532, 533 },
    { 534, 535, 536 }, { 537, 538, 539 },
    { 540, 541, 542 }, { 543, 544, 545 },
    { 546, 547, 548 }, { 549, 550, 551 },
    { 552, 553, 554 }, { 555, 556, 557 },
    { 558, 559, 560 }, { 561, 562, 563 },
    { 564, 565, 566 }, { 567, 568, 569 },
    { 570, 571, 572 }, { 573, 574, 575 },
    { 576, 577, 578 }, { 579, 580, 581 },
    { 582, 583, 584 }, { 585, 586, 587 },
    { 588, 589, 590 }, { 591, 592, 593 },
    { 594, 595, 596 }, { 597, 598, 599 },
    { 600, 601, 602 }, { 603, 604, 605 },
    { 606, 607, 608 }, { 609, 610, 611 },
    { 612, 613, 614 }, { 615, 616, 617 },
    { 618, 619, 620 }, { 621, 622, 623 },
    { 624, 625, 626 }, { 627, 628, 629 },
    { 630, 631, 632 }, { 633, 634, 635 },
    { 636, 637, 638 }, { 639, 640, 641 },
    { 642, 643, 644 }, { 645, 646, 647 },
    { 648, 649, 650 }, { 651, 652, 653 },
    { 654, 655, 656 }, { 657, 658, 659 },
    { 660, 661, 662 }, { 663, 664, 665 },
    { 666, 667, 668 }, { 669, 670, 671 },
    { 672, 673, 674 }, { 675, 676, 677 },
    { 678, 679, 680 }, { 681, 682, 683 },
    { 684, 685, 686 }, { 687, 688, 689 },
    { 690, 691, 692 }, { 693, 694, 695 },
    { 696, 697, 698 }, { 699, 700, 701 },
    { 702, 703, 704 }, { 705, 706, 707 },
    { 708, 709, 710 }, { 711, 712, 713 },
    { 714, 715, 716 }, { 717, 718, 719 },
    { 720, 721, 722 }, { 723, 724, 725 },
    { 726, 727, 728 }, { 729, 730, 731 },
    { 732, 733, 734 }, { 735, 736, 737 },
    { 738, 739, 740 }, { 741, 742, 743 },
    { 744, 745, 746 }, { 747, 748, 749 },
    { 750, 751, 752 }, { 753, 754, 755 },
    { 756, 757, 758 }, { 759, 760, 761 },
    { 762, 763, 764 }, { 765, 766, 767 },
};

WORD TriangleStripPrecompDP[][3] = {
    { 0, 1, 2 }, { 1, 3, 2 },
    { 2, 3, 4 }, { 3, 5, 4 },
    { 4, 5, 6 }, { 5, 7, 6 },
    { 6, 7, 8 }, { 7, 9, 8 },
    { 8, 9, 10 }, { 9, 11, 10 },
    { 10, 11, 12 }, { 11, 13, 12 },
    { 12, 13, 14 }, { 13, 15, 14 },
    { 14, 15, 16 }, { 15, 17, 16 },
    { 16, 17, 18 }, { 17, 19, 18 },
    { 18, 19, 20 }, { 19, 21, 20 },
    { 20, 21, 22 }, { 21, 23, 22 },
    { 22, 23, 24 }, { 23, 25, 24 },
    { 24, 25, 26 }, { 25, 27, 26 },
    { 26, 27, 28 }, { 27, 29, 28 },
    { 28, 29, 30 }, { 29, 31, 30 },
    { 30, 31, 32 }, { 31, 33, 32 },
    { 32, 33, 34 }, { 33, 35, 34 },
    { 34, 35, 36 }, { 35, 37, 36 },
    { 36, 37, 38 }, { 37, 39, 38 },
    { 38, 39, 40 }, { 39, 41, 40 },
    { 40, 41, 42 }, { 41, 43, 42 },
    { 42, 43, 44 }, { 43, 45, 44 },
    { 44, 45, 46 }, { 45, 47, 46 },
    { 46, 47, 48 }, { 47, 49, 48 },
    { 48, 49, 50 }, { 49, 51, 50 },
    { 50, 51, 52 }, { 51, 53, 52 },
    { 52, 53, 54 }, { 53, 55, 54 },
    { 54, 55, 56 }, { 55, 57, 56 },
    { 56, 57, 58 }, { 57, 59, 58 },
    { 58, 59, 60 }, { 59, 61, 60 },
    { 60, 61, 62 }, { 61, 63, 62 },
    { 62, 63, 64 }, { 63, 65, 64 },
    { 64, 65, 66 }, { 65, 67, 66 },
    { 66, 67, 68 }, { 67, 69, 68 },
    { 68, 69, 70 }, { 69, 71, 70 },
    { 70, 71, 72 }, { 71, 73, 72 },
    { 72, 73, 74 }, { 73, 75, 74 },
    { 74, 75, 76 }, { 75, 77, 76 },
    { 76, 77, 78 }, { 77, 79, 78 },
    { 78, 79, 80 }, { 79, 81, 80 },
    { 80, 81, 82 }, { 81, 83, 82 },
    { 82, 83, 84 }, { 83, 85, 84 },
    { 84, 85, 86 }, { 85, 87, 86 },
    { 86, 87, 88 }, { 87, 89, 88 },
    { 88, 89, 90 }, { 89, 91, 90 },
    { 90, 91, 92 }, { 91, 93, 92 },
    { 92, 93, 94 }, { 93, 95, 94 },
    { 94, 95, 96 }, { 95, 97, 96 },
    { 96, 97, 98 }, { 97, 99, 98 },
    { 98, 99, 100 }, { 99, 101, 100 },
    { 100, 101, 102 }, { 101, 103, 102 },
    { 102, 103, 104 }, { 103, 105, 104 },
    { 104, 105, 106 }, { 105, 107, 106 },
    { 106, 107, 108 }, { 107, 109, 108 },
    { 108, 109, 110 }, { 109, 111, 110 },
    { 110, 111, 112 }, { 111, 113, 112 },
    { 112, 113, 114 }, { 113, 115, 114 },
    { 114, 115, 116 }, { 115, 117, 116 },
    { 116, 117, 118 }, { 117, 119, 118 },
    { 118, 119, 120 }, { 119, 121, 120 },
    { 120, 121, 122 }, { 121, 123, 122 },
    { 122, 123, 124 }, { 123, 125, 124 },
    { 124, 125, 126 }, { 125, 127, 126 },
    { 126, 127, 128 }, { 127, 129, 128 },
    { 128, 129, 130 }, { 129, 131, 130 },
    { 130, 131, 132 }, { 131, 133, 132 },
    { 132, 133, 134 }, { 133, 135, 134 },
    { 134, 135, 136 }, { 135, 137, 136 },
    { 136, 137, 138 }, { 137, 139, 138 },
    { 138, 139, 140 }, { 139, 141, 140 },
    { 140, 141, 142 }, { 141, 143, 142 },
    { 142, 143, 144 }, { 143, 145, 144 },
    { 144, 145, 146 }, { 145, 147, 146 },
    { 146, 147, 148 }, { 147, 149, 148 },
    { 148, 149, 150 }, { 149, 151, 150 },
    { 150, 151, 152 }, { 151, 153, 152 },
    { 152, 153, 154 }, { 153, 155, 154 },
    { 154, 155, 156 }, { 155, 157, 156 },
    { 156, 157, 158 }, { 157, 159, 158 },
    { 158, 159, 160 }, { 159, 161, 160 },
    { 160, 161, 162 }, { 161, 163, 162 },
    { 162, 163, 164 }, { 163, 165, 164 },
    { 164, 165, 166 }, { 165, 167, 166 },
    { 166, 167, 168 }, { 167, 169, 168 },
    { 168, 169, 170 }, { 169, 171, 170 },
    { 170, 171, 172 }, { 171, 173, 172 },
    { 172, 173, 174 }, { 173, 175, 174 },
    { 174, 175, 176 }, { 175, 177, 176 },
    { 176, 177, 178 }, { 177, 179, 178 },
    { 178, 179, 180 }, { 179, 181, 180 },
    { 180, 181, 182 }, { 181, 183, 182 },
    { 182, 183, 184 }, { 183, 185, 184 },
    { 184, 185, 186 }, { 185, 187, 186 },
    { 186, 187, 188 }, { 187, 189, 188 },
    { 188, 189, 190 }, { 189, 191, 190 },
    { 190, 191, 192 }, { 191, 193, 192 },
    { 192, 193, 194 }, { 193, 195, 194 },
    { 194, 195, 196 }, { 195, 197, 196 },
    { 196, 197, 198 }, { 197, 199, 198 },
    { 198, 199, 200 }, { 199, 201, 200 },
    { 200, 201, 202 }, { 201, 203, 202 },
    { 202, 203, 204 }, { 203, 205, 204 },
    { 204, 205, 206 }, { 205, 207, 206 },
    { 206, 207, 208 }, { 207, 209, 208 },
    { 208, 209, 210 }, { 209, 211, 210 },
    { 210, 211, 212 }, { 211, 213, 212 },
    { 212, 213, 214 }, { 213, 215, 214 },
    { 214, 215, 216 }, { 215, 217, 216 },
    { 216, 217, 218 }, { 217, 219, 218 },
    { 218, 219, 220 }, { 219, 221, 220 },
    { 220, 221, 222 }, { 221, 223, 222 },
    { 222, 223, 224 }, { 223, 225, 224 },
    { 224, 225, 226 }, { 225, 227, 226 },
    { 226, 227, 228 }, { 227, 229, 228 },
    { 228, 229, 230 }, { 229, 231, 230 },
    { 230, 231, 232 }, { 231, 233, 232 },
    { 232, 233, 234 }, { 233, 235, 234 },
    { 234, 235, 236 }, { 235, 237, 236 },
    { 236, 237, 238 }, { 237, 239, 238 },
    { 238, 239, 240 }, { 239, 241, 240 },
    { 240, 241, 242 }, { 241, 243, 242 },
    { 242, 243, 244 }, { 243, 245, 244 },
    { 244, 245, 246 }, { 245, 247, 246 },
    { 246, 247, 248 }, { 247, 249, 248 },
    { 248, 249, 250 }, { 249, 251, 250 },
    { 250, 251, 252 }, { 251, 253, 252 },
    { 252, 253, 254 }, { 253, 255, 254 },
    { 254, 255, 256 }, { 255, 257, 256 },
};

WORD TriangleFanPrecompDP[][3] = {
    { 1, 2, 0 }, { 2, 3, 0 },
    { 3, 4, 0 }, { 4, 5, 0 },
    { 5, 6, 0 }, { 6, 7, 0 },
    { 7, 8, 0 }, { 8, 9, 0 },
    { 9, 10, 0 }, { 10, 11, 0 },
    { 11, 12, 0 }, { 12, 13, 0 },
    { 13, 14, 0 }, { 14, 15, 0 },
    { 15, 16, 0 }, { 16, 17, 0 },
    { 17, 18, 0 }, { 18, 19, 0 },
    { 19, 20, 0 }, { 20, 21, 0 },
    { 21, 22, 0 }, { 22, 23, 0 },
    { 23, 24, 0 }, { 24, 25, 0 },
    { 25, 26, 0 }, { 26, 27, 0 },
    { 27, 28, 0 }, { 28, 29, 0 },
    { 29, 30, 0 }, { 30, 31, 0 },
    { 31, 32, 0 }, { 32, 33, 0 },
    { 33, 34, 0 }, { 34, 35, 0 },
    { 35, 36, 0 }, { 36, 37, 0 },
    { 37, 38, 0 }, { 38, 39, 0 },
    { 39, 40, 0 }, { 40, 41, 0 },
    { 41, 42, 0 }, { 42, 43, 0 },
    { 43, 44, 0 }, { 44, 45, 0 },
    { 45, 46, 0 }, { 46, 47, 0 },
    { 47, 48, 0 }, { 48, 49, 0 },
    { 49, 50, 0 }, { 50, 51, 0 },
    { 51, 52, 0 }, { 52, 53, 0 },
    { 53, 54, 0 }, { 54, 55, 0 },
    { 55, 56, 0 }, { 56, 57, 0 },
    { 57, 58, 0 }, { 58, 59, 0 },
    { 59, 60, 0 }, { 60, 61, 0 },
    { 61, 62, 0 }, { 62, 63, 0 },
    { 63, 64, 0 }, { 64, 65, 0 },
    { 65, 66, 0 }, { 66, 67, 0 },
    { 67, 68, 0 }, { 68, 69, 0 },
    { 69, 70, 0 }, { 70, 71, 0 },
    { 71, 72, 0 }, { 72, 73, 0 },
    { 73, 74, 0 }, { 74, 75, 0 },
    { 75, 76, 0 }, { 76, 77, 0 },
    { 77, 78, 0 }, { 78, 79, 0 },
    { 79, 80, 0 }, { 80, 81, 0 },
    { 81, 82, 0 }, { 82, 83, 0 },
    { 83, 84, 0 }, { 84, 85, 0 },
    { 85, 86, 0 }, { 86, 87, 0 },
    { 87, 88, 0 }, { 88, 89, 0 },
    { 89, 90, 0 }, { 90, 91, 0 },
    { 91, 92, 0 }, { 92, 93, 0 },
    { 93, 94, 0 }, { 94, 95, 0 },
    { 95, 96, 0 }, { 96, 97, 0 },
    { 97, 98, 0 }, { 98, 99, 0 },
    { 99, 100, 0 }, { 100, 101, 0 },
    { 101, 102, 0 }, { 102, 103, 0 },
    { 103, 104, 0 }, { 104, 105, 0 },
    { 105, 106, 0 }, { 106, 107, 0 },
    { 107, 108, 0 }, { 108, 109, 0 },
    { 109, 110, 0 }, { 110, 111, 0 },
    { 111, 112, 0 }, { 112, 113, 0 },
    { 113, 114, 0 }, { 114, 115, 0 },
    { 115, 116, 0 }, { 116, 117, 0 },
    { 117, 118, 0 }, { 118, 119, 0 },
    { 119, 120, 0 }, { 120, 121, 0 },
    { 121, 122, 0 }, { 122, 123, 0 },
    { 123, 124, 0 }, { 124, 125, 0 },
    { 125, 126, 0 }, { 126, 127, 0 },
    { 127, 128, 0 }, { 128, 129, 0 },
    { 129, 130, 0 }, { 130, 131, 0 },
    { 131, 132, 0 }, { 132, 133, 0 },
    { 133, 134, 0 }, { 134, 135, 0 },
    { 135, 136, 0 }, { 136, 137, 0 },
    { 137, 138, 0 }, { 138, 139, 0 },
    { 139, 140, 0 }, { 140, 141, 0 },
    { 141, 142, 0 }, { 142, 143, 0 },
    { 143, 144, 0 }, { 144, 145, 0 },
    { 145, 146, 0 }, { 146, 147, 0 },
    { 147, 148, 0 }, { 148, 149, 0 },
    { 149, 150, 0 }, { 150, 151, 0 },
    { 151, 152, 0 }, { 152, 153, 0 },
    { 153, 154, 0 }, { 154, 155, 0 },
    { 155, 156, 0 }, { 156, 157, 0 },
    { 157, 158, 0 }, { 158, 159, 0 },
    { 159, 160, 0 }, { 160, 161, 0 },
    { 161, 162, 0 }, { 162, 163, 0 },
    { 163, 164, 0 }, { 164, 165, 0 },
    { 165, 166, 0 }, { 166, 167, 0 },
    { 167, 168, 0 }, { 168, 169, 0 },
    { 169, 170, 0 }, { 170, 171, 0 },
    { 171, 172, 0 }, { 172, 173, 0 },
    { 173, 174, 0 }, { 174, 175, 0 },
    { 175, 176, 0 }, { 176, 177, 0 },
    { 177, 178, 0 }, { 178, 179, 0 },
    { 179, 180, 0 }, { 180, 181, 0 },
    { 181, 182, 0 }, { 182, 183, 0 },
    { 183, 184, 0 }, { 184, 185, 0 },
    { 185, 186, 0 }, { 186, 187, 0 },
    { 187, 188, 0 }, { 188, 189, 0 },
    { 189, 190, 0 }, { 190, 191, 0 },
    { 191, 192, 0 }, { 192, 193, 0 },
    { 193, 194, 0 }, { 194, 195, 0 },
    { 195, 196, 0 }, { 196, 197, 0 },
    { 197, 198, 0 }, { 198, 199, 0 },
    { 199, 200, 0 }, { 200, 201, 0 },
    { 201, 202, 0 }, { 202, 203, 0 },
    { 203, 204, 0 }, { 204, 205, 0 },
    { 205, 206, 0 }, { 206, 207, 0 },
    { 207, 208, 0 }, { 208, 209, 0 },
    { 209, 210, 0 }, { 210, 211, 0 },
    { 211, 212, 0 }, { 212, 213, 0 },
    { 213, 214, 0 }, { 214, 215, 0 },
    { 215, 216, 0 }, { 216, 217, 0 },
    { 217, 218, 0 }, { 218, 219, 0 },
    { 219, 220, 0 }, { 220, 221, 0 },
    { 221, 222, 0 }, { 222, 223, 0 },
    { 223, 224, 0 }, { 224, 225, 0 },
    { 225, 226, 0 }, { 226, 227, 0 },
    { 227, 228, 0 }, { 228, 229, 0 },
    { 229, 230, 0 }, { 230, 231, 0 },
    { 231, 232, 0 }, { 232, 233, 0 },
    { 233, 234, 0 }, { 234, 235, 0 },
    { 235, 236, 0 }, { 236, 237, 0 },
    { 237, 238, 0 }, { 238, 239, 0 },
    { 239, 240, 0 }, { 240, 241, 0 },
    { 241, 242, 0 }, { 242, 243, 0 },
    { 243, 244, 0 }, { 244, 245, 0 },
    { 245, 246, 0 }, { 246, 247, 0 },
    { 247, 248, 0 }, { 248, 249, 0 },
    { 249, 250, 0 }, { 250, 251, 0 },
    { 251, 252, 0 }, { 252, 253, 0 },
    { 253, 254, 0 }, { 254, 255, 0 },
    { 255, 256, 0 }, { 256, 257, 0 },
    { 257, 258, 0 },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\stateset.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stateset.cpp
 *  Content:    State sets handling
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

//=====================================================================
//      CStateSets interface
//
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::CStateSets"

CStateSets::CStateSets(): m_GrowSize(10)
{
    m_dwMaxSets = 0;
    m_dwCurrentHandle = __INVALIDHANDLE;
    m_pStateSets = NULL;
    // Init handle factory
    m_SetHandles.Init(m_GrowSize, m_GrowSize);
    m_SetHandles.CreateNewHandle(); // Reserve handle 0
    m_DeviceHandles.Init(m_GrowSize, m_GrowSize);
    m_DeviceHandles.CreateNewHandle(); // Reserve handle 0
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::~CStateSets"

CStateSets::~CStateSets()
{
    delete [] m_pStateSets;
    m_SetHandles.ReleaseHandle(0);
    m_DeviceHandles.ReleaseHandle(0);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Init"

HRESULT CStateSets::Init(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::StartNewSet"

HRESULT CStateSets::StartNewSet()
{
    m_dwCurrentHandle = m_SetHandles.CreateNewHandle();
    if (m_dwCurrentHandle == __INVALIDHANDLE)
        return DDERR_OUTOFMEMORY;
    if (m_dwCurrentHandle >= m_dwMaxSets)
    {
        // Time to grow the array
        CStateSet *pNew = new CStateSet[m_dwMaxSets + m_GrowSize];
        if (pNew == NULL)
        {
            m_SetHandles.ReleaseHandle(m_dwCurrentHandle);
            return DDERR_OUTOFMEMORY;
        }
        for (DWORD i=0; i < m_dwMaxSets; i++)
            pNew[i] = m_pStateSets[i];
        delete [] m_pStateSets;
        m_pStateSets = pNew;
        m_dwMaxSets += m_GrowSize;
    }
    m_BufferSet.m_FEOnlyBuffer.Reset();
    m_BufferSet.m_DriverBuffer.Reset();
    m_pCurrentStateSet = &m_BufferSet;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::EndSet"

void CStateSets::EndSet()
{
    m_pStateSets[m_dwCurrentHandle] = *m_pCurrentStateSet;
    m_pCurrentStateSet = &m_pStateSets[m_dwCurrentHandle];
    m_pCurrentStateSet->m_dwStateSetFlags |= __STATESET_INITIALIZED;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::DeleteStateSet"

void CStateSets::DeleteStateSet(LPDIRECT3DDEVICEI pDevI, DWORD dwHandle)
{
    if (dwHandle >= m_dwMaxSets)
    {
        D3D_ERR("State block handle is greater than available number of blocks");
        throw D3DERR_INVALIDSTATEBLOCK;
    }
    CStateSet *pStateSet = &m_pStateSets[dwHandle];
    if (!(pStateSet->m_dwStateSetFlags & __STATESET_INITIALIZED))
    {
        D3D_ERR("State block is not initialized");
        throw D3DERR_INVALIDSTATEBLOCK;
    }

    // Pass delete instruction to the driver only if there was some data recorded
    if (pStateSet->m_DriverBuffer.m_dwCurrentSize > 0)
        InsertStateSetOp(pDevI, D3DHAL_STATESETDELETE, pStateSet->m_dwDeviceHandle, (D3DSTATEBLOCKTYPE)0);

    Cleanup(dwHandle);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Cleanup"

void CStateSets::Cleanup(DWORD dwHandle)
{
    CStateSet &pStateSet = m_pStateSets[dwHandle];
    m_SetHandles.ReleaseHandle(dwHandle);
    if (pStateSet.m_dwDeviceHandle != __INVALIDHANDLE)
        m_DeviceHandles.ReleaseHandle(pStateSet.m_dwDeviceHandle);
    pStateSet.Release();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Capture"

void CStateSets::Capture(LPDIRECT3DDEVICEI pDevI, DWORD dwHandle)
{
    if (dwHandle >= m_dwMaxSets)
    {
        D3D_ERR("Invalid state block handle");
        throw D3DERR_INVALIDSTATEBLOCK;
    }
    CStateSet *pStateSet = &m_pStateSets[dwHandle];
    if (!(pStateSet->m_dwStateSetFlags & __STATESET_INITIALIZED))
    {
        D3D_ERR("State block not initialized");
        throw D3DERR_INVALIDSTATEBLOCK;
    }
    pStateSet->Capture(pDevI, TRUE);
    if (pStateSet->m_DriverBuffer.m_dwCurrentSize > 0)
    {
        pStateSet->Capture(pDevI, FALSE);
        InsertStateSetOp(pDevI, D3DHAL_STATESETCAPTURE, pStateSet->m_dwDeviceHandle, (D3DSTATEBLOCKTYPE)0);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::CreatePredefined"

void CStateSets::CreatePredefined(LPDIRECT3DDEVICEI pDevI, D3DSTATEBLOCKTYPE sbt)
{
    static D3DRENDERSTATETYPE ALLrstates[] =
    {
        D3DRENDERSTATE_TEXTUREPERSPECTIVE,
        D3DRENDERSTATE_ANTIALIAS,
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_COLORKEYENABLE,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_EXTENTS,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRENDERSTATE_COLORKEYBLENDENABLE
    };
    static D3DTEXTURESTAGESTATETYPE ALLtsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESS,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS
    };
    static D3DRENDERSTATETYPE PIXELrstates[] =
    {
        D3DRENDERSTATE_TEXTUREPERSPECTIVE,
        D3DRENDERSTATE_ANTIALIAS,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_COLORKEYENABLE,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRENDERSTATE_COLORKEYBLENDENABLE
    };
    static D3DTEXTURESTAGESTATETYPE PIXELtsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESS,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS
    };
    static D3DRENDERSTATETYPE VERTEXrstates[] =
    {
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_EXTENTS,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE
    };
    static D3DTEXTURESTAGESTATETYPE VERTEXtsstates[] =
    {
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_TEXTURETRANSFORMFLAGS
    };

    DWORD i;

    switch(sbt)
    {
    case (D3DSTATEBLOCKTYPE)0:
        break;
    case D3DSBT_ALL:
        for(i = 0; i < sizeof(ALLrstates) / sizeof(D3DRENDERSTATETYPE); ++i)
            InsertRenderState(ALLrstates[i], pDevI->rstates[ALLrstates[i]], pDevI->CanHandleRenderState(ALLrstates[i]));

        for (i = 0; i < pDevI->dwMaxTextureBlendStages; i++)
            for(DWORD j = 0; j < sizeof(ALLtsstates) / sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
                InsertTextureStageState(i, ALLtsstates[j], pDevI->tsstates[i][ALLtsstates[j]]);

        // Capture textures
        for (i = 0; i < pDevI->dwMaxTextureBlendStages; i++)
        {
            LPDIRECTDRAWSURFACE7 pTexture;
            if (pDevI->lpD3DMappedTexI[i])
            {
                if(pDevI->lpD3DMappedTexI[i]->D3DManaged())
                    pTexture = pDevI->lpD3DMappedTexI[i]->lpDDSSys;
                else
                    pTexture = pDevI->lpD3DMappedTexI[i]->lpDDS;
            }
            else
            {
                pTexture = NULL;
            }
            InsertTexture(i, pTexture);
        }

        // Capture current viewport
        InsertViewport(&pDevI->m_Viewport);

        // Capture current transforms
        InsertTransform(D3DTRANSFORMSTATE_WORLD, (LPD3DMATRIX)&pDevI->transform.world[0]);
        InsertTransform(D3DTRANSFORMSTATE_VIEW, (LPD3DMATRIX)&pDevI->transform.view);
        InsertTransform(D3DTRANSFORMSTATE_PROJECTION, (LPD3DMATRIX)&pDevI->transform.proj);
        InsertTransform(D3DTRANSFORMSTATE_WORLD1, (LPD3DMATRIX)&pDevI->transform.world[1]);
        InsertTransform(D3DTRANSFORMSTATE_WORLD2, (LPD3DMATRIX)&pDevI->transform.world[2]);
        InsertTransform(D3DTRANSFORMSTATE_WORLD3, (LPD3DMATRIX)&pDevI->transform.world[3]);
        for (i = 0; i < pDevI->dwMaxTextureBlendStages; i++)
        {
            InsertTransform((D3DTRANSFORMSTATETYPE)(D3DTRANSFORMSTATE_TEXTURE0 + i), (LPD3DMATRIX)&pDevI->mTexture[i]);
        }

        // Capture current clip-planes
        for (i = 0; i < pDevI->transform.dwMaxUserClipPlanes; i++)
        {
            InsertClipPlane(i, (LPD3DVALUE)&pDevI->transform.userClipPlane[i]);
        }

        // Capture current material
        InsertMaterial(&pDevI->lighting.material);

        // Capture current lights
        for (i = 0; i < pDevI->m_dwNumLights; i++)
        {
            if(pDevI->m_pLights[i].Valid())
            {
                InsertLight(i, &pDevI->m_pLights[i].m_Light);
                if(pDevI->m_pLights[i].Enabled())
                {
                    InsertLightEnable(i, TRUE);
                }
                else
                {
                    InsertLightEnable(i, FALSE);
                }
            }
        }
        break;

    case D3DSBT_PIXELSTATE:
        for(i = 0; i < sizeof(PIXELrstates) / sizeof(D3DRENDERSTATETYPE); ++i)
            InsertRenderState(PIXELrstates[i], pDevI->rstates[PIXELrstates[i]], pDevI->CanHandleRenderState(PIXELrstates[i]));

        for (i = 0; i < pDevI->dwMaxTextureBlendStages; i++)
            for(DWORD j = 0; j < sizeof(PIXELtsstates) / sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
                InsertTextureStageState(i, PIXELtsstates[j], pDevI->tsstates[i][PIXELtsstates[j]]);
        break;

    case D3DSBT_VERTEXSTATE:
        for(i = 0; i < sizeof(VERTEXrstates) / sizeof(D3DRENDERSTATETYPE); ++i)
            InsertRenderState(VERTEXrstates[i], pDevI->rstates[VERTEXrstates[i]], pDevI->CanHandleRenderState(VERTEXrstates[i]));

        for (i = 0; i < pDevI->dwMaxTextureBlendStages; i++)
            for(DWORD j = 0; j < sizeof(VERTEXtsstates) / sizeof(D3DTEXTURESTAGESTATETYPE); ++j)
                InsertTextureStageState(i, VERTEXtsstates[j], pDevI->tsstates[i][VERTEXtsstates[j]]);

        // Capture current light enables
        for (i = 0; i < pDevI->m_dwNumLights; i++)
        {
            if(pDevI->m_pLights[i].Valid())
            {
                if(pDevI->m_pLights[i].Enabled())
                {
                    InsertLightEnable(i, TRUE);
                }
                else
                {
                    InsertLightEnable(i, FALSE);
                }
            }
        }
        break;

    default:
        throw DDERR_INVALIDPARAMS;
   }
}
//---------------------------------------------------------------------
// Allocates device handle if necessary
// And returns information of the device buffer
//
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::GetDeviceBufferInfo"

void CStateSets::GetDeviceBufferInfo(DWORD* dwStateSetHandle,
                                     LPVOID *pBuffer,
                                     DWORD* dwBufferSize)
{
    if (m_pCurrentStateSet->m_DriverBuffer.m_dwCurrentSize != 0)
    {
        // Allocate  a handle for the device
        m_pCurrentStateSet->m_dwDeviceHandle = m_DeviceHandles.CreateNewHandle();
        if (m_pCurrentStateSet->m_dwDeviceHandle == __INVALIDHANDLE)
        {
            D3D_ERR("Cannot allocate device handle for a state block");
            throw DDERR_OUTOFMEMORY;
        }
    }
    *dwStateSetHandle = m_pCurrentStateSet->m_dwDeviceHandle;
    *pBuffer = (LPVOID)m_pCurrentStateSet->m_DriverBuffer.m_pBuffer;
    *dwBufferSize = m_pCurrentStateSet->m_DriverBuffer.m_dwCurrentSize;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertRenderState"

void CStateSets::InsertRenderState(D3DRENDERSTATETYPE state, DWORD dwValue,
                                      BOOL bDriverCanHandle)
{
    struct
    {
        D3DRENDERSTATETYPE state;
        DWORD dwValue;
    } data = {state, dwValue};
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_RENDERSTATE,
                                      &data, sizeof(data),
                                      m_dwFlags & D3DFE_STATESETS && bDriverCanHandle);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertLight"

void CStateSets::InsertLight(DWORD dwLightIndex, LPD3DLIGHT7 pData)
{
    struct
    {
        D3DHAL_DP2SETLIGHT header;
        D3DLIGHT7   light;
    } data;
    data.header.dwIndex = dwLightIndex;
    data.header.dwDataType = D3DHAL_SETLIGHT_DATA;
    data.light= *pData;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETLIGHT, &data, sizeof(data),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertLightEnable"

void CStateSets::InsertLightEnable(DWORD dwLightIndex, BOOL bEnable)
{
    D3DHAL_DP2SETLIGHT data;
    data.dwIndex = dwLightIndex;
    if (bEnable)
        data.dwDataType = D3DHAL_SETLIGHT_ENABLE;
    else
        data.dwDataType = D3DHAL_SETLIGHT_DISABLE;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETLIGHT, &data, sizeof(data),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertViewport"

void CStateSets::InsertViewport(LPD3DVIEWPORT7 lpVwpData)
{
    D3DHAL_DP2VIEWPORTINFO data2;
    data2.dwX = lpVwpData->dwX;
    data2.dwY = lpVwpData->dwY;
    data2.dwWidth = lpVwpData->dwWidth;
    data2.dwHeight = lpVwpData->dwHeight;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_VIEWPORTINFO, &data2, sizeof(data2),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);

    D3DHAL_DP2ZRANGE data1;
    data1.dvMinZ = lpVwpData->dvMinZ;
    data1.dvMaxZ = lpVwpData->dvMaxZ;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_ZRANGE, &data1, sizeof(data1),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);

    m_pCurrentStateSet->ResetCurrentCommand();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertMaterial"

void CStateSets::InsertMaterial(LPD3DMATERIAL7 pData)
{
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETMATERIAL,
                                      pData, sizeof(D3DMATERIAL7),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);

    m_pCurrentStateSet->ResetCurrentCommand();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertClipPlane"

void CStateSets::InsertClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
    D3DHAL_DP2SETCLIPPLANE data;
    data.dwIndex = dwPlaneIndex;
    data.plane[0] = pPlaneEquation[0];
    data.plane[1] = pPlaneEquation[1];
    data.plane[2] = pPlaneEquation[2];
    data.plane[3] = pPlaneEquation[3];
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETCLIPPLANE,
                                      &data, sizeof(data),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertTransform"

void CStateSets::InsertTransform(D3DTRANSFORMSTATETYPE state, LPD3DMATRIX lpMat)
{
    D3DHAL_DP2SETTRANSFORM data;
    data.xfrmType = state;
    data.matrix = *lpMat;
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_SETTRANSFORM,
                                      &data, sizeof(data),
                                      m_dwFlags & D3DFE_STATESETS && m_dwFlags & D3DFE_TLHAL);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertTextureStageState"

void CStateSets::InsertTextureStageState(DWORD dwStage,
                                            D3DTEXTURESTAGESTATETYPE type,
                                            DWORD dwValue)
{
    D3DHAL_DP2TEXTURESTAGESTATE data = {(WORD)dwStage, type, dwValue};
    m_pCurrentStateSet->InsertCommand(D3DDP2OP_TEXTURESTAGESTATE,
                                      &data, sizeof(data),
                                      m_dwFlags & D3DFE_STATESETS);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::InsertTexture"

void CStateSets::InsertTexture(DWORD dwStage, LPDIRECTDRAWSURFACE7 pTex)
{
    D3DHAL_DP2FRONTENDDATA data = {(WORD)dwStage, (LPVOID)pTex};
    // Only the front-end will parse this instruction
    m_pCurrentStateSet->InsertCommand((D3DHAL_DP2OPERATION)D3DDP2OP_FRONTENDDATA, &data, sizeof(data), FALSE);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSets::Execute"

void CStateSets::Execute(LPDIRECT3DDEVICEI pDevI, DWORD dwHandle)
{
#if DBG
    if (dwHandle >= m_dwMaxSets)
    {
        D3D_ERR("Invalid state block handle");
        throw D3DERR_INVALIDSTATEBLOCK;
    }
#endif
    CStateSet *pStateSet = &m_pStateSets[dwHandle];
#if DBG
    if (!(pStateSet->m_dwStateSetFlags & __STATESET_INITIALIZED))
    {
        D3D_ERR("State block not initialized");
        throw D3DERR_INVALIDSTATEBLOCK;
    }
#endif
    // Parse recorded data first
    pStateSet->Execute(pDevI, TRUE);
    // If the hardware buffer is not empty, we pass recorded data to it
    if (pStateSet->m_DriverBuffer.m_dwCurrentSize > 0)
    {
        pStateSet->Execute(pDevI, FALSE);
        InsertStateSetOp(pDevI, D3DHAL_STATESETEXECUTE, pStateSet->m_dwDeviceHandle, (D3DSTATEBLOCKTYPE)0);
    }
}
//=====================================================================
//      CStateSet interface
//
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::Release"

HRESULT CStateSet::Release()
{
     if (!(m_dwStateSetFlags & __STATESET_INITIALIZED))
        return D3DERR_INVALIDSTATEBLOCK;
    m_dwStateSetFlags &= ~__STATESET_INITIALIZED;
    m_FEOnlyBuffer.Reset();
    m_DriverBuffer.Reset();
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::InsertCommand"

void CStateSet::InsertCommand(D3DHAL_DP2OPERATION op, LPVOID pData,
                                 DWORD dwDataSize,
                                 BOOL bDriverCanHandle)
{
    if (op == D3DDP2OP_TEXTURESTAGESTATE ||
        (op == D3DDP2OP_RENDERSTATE &&
        ((LPD3DHAL_DP2RENDERSTATE)pData)->RenderState >= D3DRENDERSTATE_WRAP0 &&
        ((LPD3DHAL_DP2RENDERSTATE)pData)->RenderState <= D3DRENDERSTATE_WRAP7))
    {
        m_dwStateSetFlags |= __STATESET_NEEDCHECKREMAPPING;
    }
    if (bDriverCanHandle)
        m_DriverBuffer.InsertCommand(op, pData, dwDataSize);
    else
        m_FEOnlyBuffer.InsertCommand(op, pData, dwDataSize);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::Execute"

void CStateSet::Execute(LPDIRECT3DDEVICEI pDevI, BOOL bFrontEndBuffer)
{
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;
    try
    {
        // Texture stages could be re-mapped during texture transform processing.
        // Before we set new values we have to restore original ones
        if (pDevI->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES &&
            m_dwStateSetFlags & __STATESET_NEEDCHECKREMAPPING)
        {
            RestoreTextureStages(pDevI);
            pDevI->ForceFVFRecompute();
        }

        if (bFrontEndBuffer)
        {
            p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
            dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
        }
        else
        {
            p = (DWORD*)m_DriverBuffer.m_pBuffer;
            dwSize = m_DriverBuffer.m_dwCurrentSize;
            pDevI->dwFEFlags |= D3DFE_EXECUTESTATEMODE;
        }
        pEnd = (DWORD*)((BYTE*)p + dwSize);
        while (p < pEnd)
        {
            LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
            p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
            switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
            {
            case D3DDP2OP_RENDERSTATE:
                {
                    if(pDevI->dwFEFlags & D3DFE_EXECUTESTATEMODE)
                    {
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            D3DRENDERSTATETYPE dwState = (D3DRENDERSTATETYPE)*p++;
                            DWORD dwValue = *p++;
                            if (pDevI->rstates[dwState] != dwValue)
                            {
                                if (!(pDevI->rsVec[dwState >> D3D_RSVEC_SHIFT] & (1ul << (dwState & D3D_RSVEC_MASK))))
                                { // Fast path. We do not need any processing done in UpdateInternalState other than updating rstates array
                                    pDevI->rstates[dwState] = dwValue;
                                }
                                else
                                {
                                    pDevI->UpdateInternalState(dwState, dwValue);
                                }
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetRenderState");
                            }
                        }
                    }
                    else
                    {
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            D3DRENDERSTATETYPE dwState = (D3DRENDERSTATETYPE)*p++;
                            DWORD dwValue = *p++;
                            if (pDevI->rstates[dwState] != dwValue)
                            {
                                if (!(pDevI->rsVec[dwState >> D3D_RSVEC_SHIFT] & (1ul << (dwState & D3D_RSVEC_MASK))))
                                { // Fast path. We do not need any processing done in UpdateInternalState other than updating rstates array
                                    pDevI->rstates[dwState] = dwValue;
                                    HRESULT ret = pDevI->SetRenderStateI(dwState, dwValue);
                                    if(ret != D3D_OK)
                                        throw ret;
                                }
                                else
                                {
                                    pDevI->UpdateInternalState(dwState, dwValue);
                                    if (pDevI->CanHandleRenderState(dwState))
                                    {
                                        HRESULT ret = pDevI->SetRenderStateI(dwState, dwValue);
                                        if(ret != D3D_OK)
                                            throw ret;
                                    }
                                }
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetRenderState");
                            }
                        }
                    }
                    break;
                }
            case D3DDP2OP_SETLIGHT:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETLIGHT));
                        switch (pData->dwDataType)
                        {
                        case D3DHAL_SETLIGHT_ENABLE:
                            pDevI->LightEnableI( pData->dwIndex, TRUE );
                            break;
                        case D3DHAL_SETLIGHT_DISABLE:
                            pDevI->LightEnableI( pData->dwIndex, FALSE );
                            break;
                        case D3DHAL_SETLIGHT_DATA:
                            pDevI->SetLightI(pData->dwIndex, (D3DLIGHT7 *)p);
                            p = (LPDWORD)((LPBYTE)p + sizeof(D3DLIGHT7));
                            break;
                        }
                    }
                    break;
                }
            case D3DDP2OP_SETMATERIAL:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2SETMATERIAL pData = (LPD3DHAL_DP2SETMATERIAL)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETMATERIAL));
                        pDevI->SetMaterialI(pData);
                    }
                    break;
                }
            case D3DDP2OP_SETTRANSFORM:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        D3DHAL_DP2SETTRANSFORM *pData = (D3DHAL_DP2SETTRANSFORM*)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETTRANSFORM));
                        pDevI->SetTransformI(pData->xfrmType, &pData->matrix);
                    }
                    break;
                }
            case D3DDP2OP_TEXTURESTAGESTATE:
                {
                    if (pDevI->dwFEFlags & D3DFE_EXECUTESTATEMODE)
                    {
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                            p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
                            DWORD dwStage = pData->wStage;
                            DWORD dwState = pData->TSState;
                            DWORD dwValue = pData->dwValue;
                            if (pDevI->tsstates[dwStage][dwState] != dwValue)
                            {
                                // Fast path. We do not need any processing done in UpdateInternalTSS other than updating tsstates array
                                if (pDevI->NeedInternalTSSUpdate(dwState))
                                    pDevI->UpdateInternalTextureStageState(dwStage, (D3DTEXTURESTAGESTATETYPE)dwState, dwValue);
                                else
                                    pDevI->tsstates[dwStage][dwState] = dwValue;
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetTextureStageState");
                            }
                        }
                    }
                    else
                    {
                        for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                        {
                            LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                            p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
                            DWORD dwStage = pData->wStage;
                            DWORD dwState = pData->TSState;
                            DWORD dwValue = pData->dwValue;
                            if (pDevI->tsstates[dwStage][dwState] != dwValue)
                            {
                                // Fast path. We do not need any processing done in UpdateInternalTSS other than updating tsstates array
                                if (pDevI->NeedInternalTSSUpdate(dwState))
                                {
                                    if(pDevI->UpdateInternalTextureStageState(dwStage, (D3DTEXTURESTAGESTATETYPE)dwState, dwValue))
                                        continue;
                                }
                                else
                                {
                                    pDevI->tsstates[dwStage][dwState] = dwValue;
                                }
                                if (dwStage >= pDevI->dwMaxTextureBlendStages)
                                    continue;
                                HRESULT ret = pDevI->SetTSSI(dwStage, (D3DTEXTURESTAGESTATETYPE)dwState, dwValue);
                                if(ret != D3D_OK)
                                    throw ret;
                            }
                            else
                            {
                                D3D_WARN(4,"Ignoring redundant SetTextureStageState");
                            }
                        }
                    }
                    break;
                }
            case D3DDP2OP_FRONTENDDATA:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
                        HRESULT ret = pDevI->SetTexture(pData->wStage, (LPDIRECTDRAWSURFACE7)pData->pTexture);
                        if (ret != D3D_OK)
                            throw ret;
                    }
                    break;
                }
            case D3DDP2OP_VIEWPORTINFO:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        D3DVIEWPORT7 viewport;
                        LPD3DHAL_DP2VIEWPORTINFO lpVwpData = (LPD3DHAL_DP2VIEWPORTINFO)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VIEWPORTINFO));
                        viewport.dwX      = lpVwpData->dwX;
                        viewport.dwY      = lpVwpData->dwY;
                        viewport.dwWidth  = lpVwpData->dwWidth;
                        viewport.dwHeight = lpVwpData->dwHeight;

                        // The next command has to be D3DDP2OP_ZRANGE
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
                        LPD3DHAL_DP2ZRANGE pData = (LPD3DHAL_DP2ZRANGE)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2ZRANGE));
                        viewport.dvMinZ      = pData->dvMinZ;
                        viewport.dvMaxZ      = pData->dvMaxZ;

                        pDevI->SetViewportI(&viewport);
                    }
                    break;
                }
            case D3DDP2OP_SETCLIPPLANE:
                {
                    for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                    {
                        D3DHAL_DP2SETCLIPPLANE *pData = (D3DHAL_DP2SETCLIPPLANE*)p;
                        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETCLIPPLANE));
                        pDevI->SetClipPlaneI(pData->dwIndex, pData->plane);
                    }
                    break;
                }
#ifdef DBG
            default:
                DDASSERT(FALSE);
#endif
            }
        }
        pDevI->dwFEFlags &= ~D3DFE_EXECUTESTATEMODE;
    }
    catch(HRESULT ret)
    {
        pDevI->dwFEFlags &= ~D3DFE_EXECUTESTATEMODE;
        throw ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSet::Capture"

void CStateSet::Capture(LPDIRECT3DDEVICEI pDevI, BOOL bFrontEndBuffer)
{
    DWORD *p;
    DWORD dwSize;
    DWORD *pEnd;
    if (bFrontEndBuffer)
    {
        p = (DWORD*)m_FEOnlyBuffer.m_pBuffer;
        dwSize = m_FEOnlyBuffer.m_dwCurrentSize;
    }
    else
    {
        p = (DWORD*)m_DriverBuffer.m_pBuffer;
        dwSize = m_DriverBuffer.m_dwCurrentSize;
    }
    pEnd = (DWORD*)((BYTE*)p + dwSize);
    while (p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)p;
        p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
        switch ((D3DHAL_DP2OPERATION)pCommand->bCommand)
        {
        case D3DDP2OP_RENDERSTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    const D3DRENDERSTATETYPE state = (D3DRENDERSTATETYPE)*p++;
                    *p++ = pDevI->rstates[state];
                }
                break;
            }
        case D3DDP2OP_SETLIGHT:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETLIGHT));
                    if(pData->dwIndex >= pDevI->m_dwNumLights)
                    {
                        D3D_ERR("Unable to capture light state (light not set?)");
                        throw D3DERR_LIGHT_SET_FAILED;
                    }
                    switch (pData->dwDataType)
                    {
                    case D3DHAL_SETLIGHT_ENABLE:
                        if(!pDevI->m_pLights[pData->dwIndex].Enabled())
                            pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
                        break;
                    case D3DHAL_SETLIGHT_DISABLE:
                        if(pDevI->m_pLights[pData->dwIndex].Enabled())
                            pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
                        break;
                    case D3DHAL_SETLIGHT_DATA:
                        *((LPD3DLIGHT7)p) = pDevI->m_pLights[pData->dwIndex].m_Light;
                        p = (LPDWORD)((LPBYTE)p + sizeof(D3DLIGHT7));
                        break;
                    }
                }
                break;
            }
        case D3DDP2OP_SETMATERIAL:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETMATERIAL pData = (LPD3DHAL_DP2SETMATERIAL)p;
                    *pData = pDevI->lighting.material;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETMATERIAL));
                }
                break;
            }
        case D3DDP2OP_SETTRANSFORM:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETTRANSFORM pData = (LPD3DHAL_DP2SETTRANSFORM)p;
                    switch(pData->xfrmType)
                    {
                    case D3DTRANSFORMSTATE_WORLD:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.world[0]);
                        break;
                    case D3DTRANSFORMSTATE_WORLD1:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.world[1]);
                        break;
                    case D3DTRANSFORMSTATE_WORLD2:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.world[2]);
                        break;
                    case D3DTRANSFORMSTATE_WORLD3:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.world[3]);
                        break;
                    case D3DTRANSFORMSTATE_VIEW:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.view);
                        break;
                    case D3DTRANSFORMSTATE_PROJECTION:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->transform.proj);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE0:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[0]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE1:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[1]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE2:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[2]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE3:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[3]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE4:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[4]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE5:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[5]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE6:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[6]);
                        break;
                    case D3DTRANSFORMSTATE_TEXTURE7:
                        pData->matrix = *((LPD3DMATRIX)&pDevI->mTexture[7]);
                        break;
                    }
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETTRANSFORM));
                }
                break;
            }
        case D3DDP2OP_TEXTURESTAGESTATE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                    pData->dwValue = pDevI->tsstates[pData->wStage][pData->TSState];
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
                }
                break;
            }
        case D3DDP2OP_FRONTENDDATA:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2FRONTENDDATA pData = (LPD3DHAL_DP2FRONTENDDATA)p;
                    if (pDevI->lpD3DMappedTexI[pData->wStage])
                    {
                        if(pDevI->lpD3DMappedTexI[pData->wStage]->D3DManaged())
                            pData->pTexture = pDevI->lpD3DMappedTexI[pData->wStage]->lpDDSSys;
                        else
                            pData->pTexture = pDevI->lpD3DMappedTexI[pData->wStage]->lpDDS;
                    }
                    else
                    {
                        pData->pTexture = NULL;
                    }
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2FRONTENDDATA));
                }
                break;
            }
        case D3DDP2OP_VIEWPORTINFO:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    D3DVIEWPORT7 viewport;
                    LPD3DHAL_DP2VIEWPORTINFO lpVwpData = (LPD3DHAL_DP2VIEWPORTINFO)p;
                    lpVwpData->dwX      = pDevI->m_Viewport.dwX;
                    lpVwpData->dwY      = pDevI->m_Viewport.dwY;
                    lpVwpData->dwWidth  = pDevI->m_Viewport.dwWidth;
                    lpVwpData->dwHeight = pDevI->m_Viewport.dwHeight;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2VIEWPORTINFO));
                    // The next command has to be D3DDP2OP_ZRANGE
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2COMMAND));
                    LPD3DHAL_DP2ZRANGE pData = (LPD3DHAL_DP2ZRANGE)p;
                    pData->dvMinZ = pDevI->m_Viewport.dvMinZ;
                    pData->dvMaxZ = pDevI->m_Viewport.dvMaxZ;
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2ZRANGE));
                }
                break;
            }
        case D3DDP2OP_SETCLIPPLANE:
            {
                for(DWORD i = 0; i < (DWORD)pCommand->wStateCount; ++i)
                {
                    LPD3DHAL_DP2SETCLIPPLANE pData = (LPD3DHAL_DP2SETCLIPPLANE)p;
                    *((LPD3DVECTORH)pData->plane) = pDevI->transform.userClipPlane[pData->dwIndex];
                    p = (DWORD*)((BYTE*)p +  sizeof(D3DHAL_DP2SETCLIPPLANE));
                }
                break;
            }
#ifdef DBG
        default:
            DDASSERT(FALSE);
#endif
        }
    }
}
//=====================================================================
//      CStateSetBuffer interface
//
#undef DPF_MODNAME
#define DPF_MODNAME "CStateSetBuffer::InsertCommand"

void CStateSetBuffer::InsertCommand(D3DHAL_DP2OPERATION op, LPVOID pData, DWORD dwDataSize)
{
    const DWORD GROWSIZE = 1024;
    if (m_pDP2CurrCommand != 0 && m_pDP2CurrCommand->bCommand == op)
    {
        if (dwDataSize + m_dwCurrentSize <= m_dwBufferSize)
        {
            ++m_pDP2CurrCommand->wStateCount;
            memcpy(m_pBuffer + m_dwCurrentSize, pData, dwDataSize);
            m_dwCurrentSize += dwDataSize;
            return;
        }
    }
    // Check for space
    if (sizeof(D3DHAL_DP2COMMAND) + dwDataSize + m_dwCurrentSize > m_dwBufferSize)
    {
        // We need to grow the buffer
        DWORD dwNewBufferSize = max(m_dwBufferSize + GROWSIZE, sizeof(D3DHAL_DP2COMMAND) + dwDataSize + m_dwCurrentSize);
        BYTE *pTmp = new BYTE[dwNewBufferSize];
        if (pTmp == NULL)
        {
            D3D_ERR("Not enough memory to create state block buffer");
            throw DDERR_OUTOFMEMORY;
        }
        if (m_pBuffer)
        {
            memcpy(pTmp, m_pBuffer, m_dwCurrentSize);
            delete [] m_pBuffer;
        }
        m_pBuffer = pTmp;
        m_dwBufferSize = dwNewBufferSize;
    }
    // Add new instruction
    m_pDP2CurrCommand = (LPD3DHAL_DP2COMMAND)(m_pBuffer + m_dwCurrentSize);
    m_pDP2CurrCommand->bCommand = op;
    m_pDP2CurrCommand->bReserved = 0;
    m_pDP2CurrCommand->wStateCount = 1;
    m_dwCurrentSize += sizeof(D3DHAL_DP2COMMAND);
    memcpy(m_pBuffer + m_dwCurrentSize, pData, dwDataSize);
    m_dwCurrentSize += dwDataSize;
    return;
}
//=====================================================================
void InsertStateSetOp(LPDIRECT3DDEVICEI pDevI, DWORD dwOperation, DWORD dwParam, D3DSTATEBLOCKTYPE sbt)
{
    CDirect3DDeviceIDP2 *device = static_cast<CDirect3DDeviceIDP2*>(pDevI);
    LPD3DHAL_DP2STATESET pData;
    pData = (LPD3DHAL_DP2STATESET)device->GetHalBufferPointer(D3DDP2OP_STATESET, sizeof(*pData));
    pData->dwOperation = dwOperation;
    pData->dwParam = dwParam;
    pData->sbType = sbt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\testprov.cpp ===
//----------------------------------------------------------------------------
//
// testprov.cpp
//
// Test HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

//#ifdef DEBUG_PIPELINE

#include "testprov.h"
#include "testfile.h"
#include "stdio.h"

// Real rasterizer data
static D3DHALPROVIDER_INTERFACEDATA CurInterfaceData;
static IHalProvider    *pCurHalProvider;    // Real HAL provider

// Test provider data
static CTestHalProvider g_TestHalProvider;
static D3DHALPROVIDER_INTERFACEDATA TestInterfaceData;
static D3DHAL_CALLBACKS  TestCallbacks;
static D3DHAL_CALLBACKS2 TestCallbacks2;
static D3DHAL_CALLBACKS3 TestCallbacks3;
static char szFileName[_MAX_PATH] = "";     // Output file name
static FILE *fout = NULL;                   // Output file
DWORD g_dwTestHalFlags = 0;                   // Could be set from debugger

// Bits for g_dwTestHalFlags
const DWORD __TESTHAL_OUTPUTFILE    = 1;    // If need output to test file
const DWORD __TESTHAL_NORENDER      = 2;    // If no rendering needed

//---------------------------------------------------------------------
// Provides access to DIRECTDRAWSURFACE memory;
// In the constructor the surface is locked.
// In the destructor it is unlocked.
// LPBYTE() or LPVOID() casts will get pointer to the surface bits.
//
class CLockedDDSurface
{
public:
    CLockedDDSurface(LPDIRECTDRAWSURFACE surface);
    ~CLockedDDSurface();
    operator LPVOID() {return descr.lpSurface;}
    operator LPBYTE() {return (LPBYTE)descr.lpSurface;}
protected:
    DDSURFACEDESC descr;
    LPDIRECTDRAWSURFACE pSurface;
};

CLockedDDSurface::CLockedDDSurface(LPDIRECTDRAWSURFACE surface)
{
    pSurface = surface;
    memset (&descr, 0, sizeof(descr));
    descr.dwSize = sizeof(descr);
    surface->Lock(NULL, &descr,  0, NULL);
}

CLockedDDSurface::~CLockedDDSurface()
{
    if (descr.lpSurface)
        pSurface->Unlock(descr.lpSurface);
}
//---------------------------------------------------------------------
void PutHeader(DWORD id, DWORD size)
{
    if (fout)
    {
        fwrite(&id, sizeof(DWORD), 1, fout);
        fwrite(&size, sizeof(DWORD), 1, fout);
    }
}
//---------------------------------------------------------------------
DWORD GetCurrentPosition()
{
    if (fout)
        return ftell(fout);
    else
        return 0;
}
//---------------------------------------------------------------------
void SetCurrentPosition(DWORD offset)
{
    if (fout)
        fseek(fout, offset, SEEK_SET);
}
//---------------------------------------------------------------------
void PutBuffer(LPVOID buffer, DWORD size)
{
    if (fout)
    {
        fwrite(buffer, 1, size, fout);
    }
}
//---------------------------------------------------------------------
// Implementation of test callbacks
//
DWORD __stdcall
TestDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        TFREC_DRAWONEPRIMITIVE rec;
        PutHeader(TFID_DRAWONEPRIMITIVE,
                  sizeof(rec) + data->dwNumVertices*sizeof(D3DTLVERTEX));
        rec.primitiveType = data->PrimitiveType;
        rec.vertexCount = data->dwNumVertices;
        rec.vertexType = data->VertexType;
        rec.dwFlags = data->dwFlags;
        PutBuffer(&rec, sizeof(rec));
        PutBuffer(data->lpvVertices, sizeof(D3DTLVERTEX)*data->dwNumVertices);
    }

    if (CurInterfaceData.pCallbacks2->DrawOnePrimitive &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks2->DrawOnePrimitive(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        TFREC_DRAWONEINDEXEDPRIMITIVE rec;
        PutHeader(TFID_DRAWONEINDEXEDPRIMITIVE,
                  sizeof(rec) +
                  data->dwNumVertices*sizeof(D3DTLVERTEX) +
                  data->dwNumIndices*sizeof(WORD));
        rec.primitiveType = data->PrimitiveType;
        rec.vertexCount = data->dwNumVertices;
        rec.vertexType = data->VertexType;
        rec.dwFlags = data->dwFlags;
        rec.indexCount = data->dwNumIndices;
        PutBuffer(&rec, sizeof(rec));
        PutBuffer(data->lpvVertices, sizeof(D3DTLVERTEX)*data->dwNumVertices);
        PutBuffer(data->lpwIndices, sizeof(WORD)*data->dwNumIndices);
    }

    if (CurInterfaceData.pCallbacks2->DrawOneIndexedPrimitive &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks2->DrawOneIndexedPrimitive(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        DWORD endPos = 0;
        LPVOID header = data->lpvData;
        PutHeader(0,0);     // Dummy header. Will be filled later
        DWORD startPos = GetCurrentPosition();
        for (;;)
        {
            DWORD nStates = ((D3DHAL_DRAWPRIMCOUNTS*)header)->wNumStateChanges;
            DWORD nVertices = ((D3DHAL_DRAWPRIMCOUNTS*)header)->wNumVertices;
            DWORD size;
        // Primitive header
            PutBuffer(header, sizeof(D3DHAL_DRAWPRIMCOUNTS));
            header = (char*)header + sizeof(D3DHAL_DRAWPRIMCOUNTS);
        // States
            size = nStates * sizeof(WORD);
            PutBuffer(header, size);
            header = (char*)header + size;
            header = (LPVOID)(((LONG_PTR)header + 31) & ~31);  //32 bytes aligned
        // Vertices
            if (!nVertices)
                break;
            size = nVertices * sizeof(D3DTLVERTEX);
            PutBuffer(header, size);

        }
        // Write record header
        endPos = GetCurrentPosition();
        SetCurrentPosition(startPos - sizeof(TF_HEADER));
        PutHeader(TFID_DRAWPRIMITIVES, endPos - startPos);
        SetCurrentPosition(endPos);
    }

    if (CurInterfaceData.pCallbacks2->DrawPrimitives &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks2->DrawPrimitives(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        TFREC_DRAWPRIMITIVES2 rec;
        rec.dwFlags = 0;
        PutBuffer(&rec, sizeof(rec));
        PutHeader(TFID_DRAWPRIMITIVES, sizeof(rec));
    }

    if (CurInterfaceData.pCallbacks3->DrawPrimitives2 &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks3->DrawPrimitives2(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestRenderState(LPD3DHAL_RENDERSTATEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        // mem should be destroyed before calling to real driver to unlock
        // the surface
        CLockedDDSurface mem(data->lpExeBuf);
        LPD3DSTATE      pState;
        pState = (LPD3DSTATE)(LPBYTE(mem) + data->dwOffset);
        PutHeader(TFID_RENDERSTATE, sizeof(DWORD) + data->dwCount*sizeof(D3DSTATE));
        PutBuffer(&data->dwCount, sizeof(DWORD));
        for (DWORD i = 0; i < data->dwCount; i++)
        {
            PutBuffer(&pState, sizeof(D3DSTATE));
                pState++;
        }
    }

    if (CurInterfaceData.pCallbacks->RenderState)
        return CurInterfaceData.pCallbacks->RenderState(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        // mem and tlmem should be destroyed before calling the real driver
        // to unlock the surface
        CLockedDDSurface mem(data->lpExeBuf);
        CLockedDDSurface tlmem(data->lpTLBuf);
        LPBYTE        lpPrimData;
        LPD3DTLVERTEX lpTLData;
        DWORD         i;
        DWORD         primitiveDataSize;
        DWORD         count = data->diInstruction.wCount;
        TFREC_RENDERPRIMITIVE rec;

        // Find the pointer to the first primitive structure
        lpPrimData = (LPBYTE)mem + data->dwOffset;

        // Find the pointer to the vertex data
        // Find the pointer to the first TL vertex
        lpTLData = (LPD3DTLVERTEX)((LPBYTE)tlmem + data->dwTLOffset);

        rec.status = data->dwStatus;
        rec.vertexType = D3DVT_TLVERTEX;
        // Find out number of vertices, primitive type and
        // size of primitive data
        switch (data->diInstruction.bOpcode)
        {
        case D3DOP_POINT:
            rec.primitiveType = D3DPT_POINTLIST;
            rec.vertexCount = count;
            primitiveDataSize = count*sizeof(D3DPOINT);
                break;
        case D3DOP_LINE:
            rec.primitiveType = D3DPT_LINELIST;
            rec.vertexCount = count*2;
            primitiveDataSize = count*sizeof(D3DLINE);
                break;
        case D3DOP_SPAN:
            rec.primitiveType = D3DPT_POINTLIST;
            rec.vertexCount = count;
            primitiveDataSize = count*sizeof(D3DSPAN);
                break;
        case D3DOP_TRIANGLE:
            rec.primitiveType = D3DPT_TRIANGLELIST;
            rec.vertexCount = count*3;
            primitiveDataSize = count*sizeof(D3DTRIANGLE);
                break;
        }

        PutHeader(TFID_RENDERPRIMITIVE,
                  sizeof(D3DINSTRUCTION) +
                  sizeof(rec) + rec.vertexCount*sizeof(D3DTLVERTEX) +
                  primitiveDataSize);
        PutBuffer(&rec, sizeof(rec));
        PutBuffer(&data->diInstruction, sizeof(D3DINSTRUCTION));

        // Parse the structures based on the instruction
        switch (data->diInstruction.bOpcode)
        {
        case D3DOP_POINT:
        {
                LPD3DPOINT lpPoint = (LPD3DPOINT)lpPrimData;
                for (i = 0; i < count; i++)
            {
                PutBuffer(lpPoint, sizeof(D3DPOINT));
                PutBuffer(&lpTLData[lpPoint->wFirst],
                          lpPoint->wCount*sizeof(D3DTLVERTEX));
                lpPoint++;
                }
                break;
        }
        case D3DOP_LINE:
        {
                LPD3DLINE lpLine = (LPD3DLINE)lpPrimData;
                for (i = 0; i < count; i++)
            {
                PutBuffer(lpLine, sizeof(D3DLINE));
                PutBuffer(&lpTLData[lpLine->v1], sizeof(D3DTLVERTEX));
                PutBuffer(&lpTLData[lpLine->v2], sizeof(D3DTLVERTEX));
                lpLine++;
                }
                break;
        }
        case D3DOP_SPAN:
        {
                LPD3DSPAN lpSpan = (LPD3DSPAN)lpPrimData;
                for (i = 0; i < count; i++)
            {
                PutBuffer(lpSpan, sizeof(D3DSPAN));
                PutBuffer(&lpTLData[lpSpan->wFirst],
                          lpSpan->wCount*sizeof(D3DTLVERTEX));
                lpSpan++;
                }
                break;
        }
        case D3DOP_TRIANGLE:
        {
                LPD3DTRIANGLE lpTri = (LPD3DTRIANGLE)lpPrimData;
                for (i = 0; i < count; i++)
            {
                PutBuffer(lpTri, sizeof(D3DTRIANGLE));
                PutBuffer(&lpTLData[lpTri->v1], sizeof(D3DTLVERTEX));
                PutBuffer(&lpTLData[lpTri->v2], sizeof(D3DTLVERTEX));
                PutBuffer(&lpTLData[lpTri->v3], sizeof(D3DTLVERTEX));
                lpTri++;
                }
                break;
        }
        }
    }

    if (CurInterfaceData.pCallbacks->RenderPrimitive &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks->RenderPrimitive(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestSceneCapture(LPD3DHAL_SCENECAPTUREDATA pData)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        PutHeader(TFID_SCENECAPTURE, sizeof(DWORD));
        PutBuffer(&pData->dwFlag, sizeof(DWORD));
        fflush(fout);
    }

    if (CurInterfaceData.pCallbacks->SceneCapture)
        return CurInterfaceData.pCallbacks->SceneCapture(pData);
    else
        return DDHAL_DRIVER_HANDLED;
}
//----------------------------------------------------------------------------
//
// TestHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP CTestHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// CTestHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTestHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// TestHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTestHalProvider::Release(THIS)
{
    if (fout)
    {
        fclose(fout);
        fout = NULL;
    }
    return pCurHalProvider->Release();
}
//----------------------------------------------------------------------------
//
// GetTestProvider
//
// Input:
//      riid and pCurrentHalProvider are equal to
//      the currently selected provider.
//      GlobalData  - data provided by DDraw
//      fileName    - output file name
//      dwFlagsInp  - currently not used
//
// Returns:
//      the test HAL provider in ppHalProvider.
//
// Notes:
//      Only one instance of the test HAL is handled correctly.
//
//----------------------------------------------------------------------------
STDAPI GetTestHalProvider(REFIID riid,
                          DDRAWI_DIRECTDRAW_GBL *GlobalData,
                          IHalProvider **ppHalProvider,
                          IHalProvider * pCurrentHalProvider,
                          DWORD dwFlagsInp)
{
    *ppHalProvider = &g_TestHalProvider;
    pCurHalProvider = pCurrentHalProvider;

    g_dwTestHalFlags |= __TESTHAL_NORENDER;
    if (GetD3DRegValue(REG_SZ, "TestHalFile", &szFileName, _MAX_PATH) &&
        szFileName[0] != 0)
    {
        g_dwTestHalFlags |= __TESTHAL_OUTPUTFILE;
    }
    DWORD dwValue;
    if (GetD3DRegValue(REG_DWORD, "TestHalDoRender", &dwValue, sizeof(DWORD)) &&
        dwValue != 0)
    {
        g_dwTestHalFlags &= ~__TESTHAL_NORENDER;
    }
// Get interface from the current hal provider to call to it
    pCurrentHalProvider->GetInterface(GlobalData, &CurInterfaceData, 4);

    TestInterfaceData = CurInterfaceData;
    TestInterfaceData.pCallbacks  = &TestCallbacks;
    TestInterfaceData.pCallbacks2 = &TestCallbacks2;
    TestInterfaceData.pCallbacks3 = &TestCallbacks3;

// Initialize callbacks we do not care of

    TestCallbacks  = *CurInterfaceData.pCallbacks;
    TestCallbacks2 = *CurInterfaceData.pCallbacks2;
    TestCallbacks3 = *CurInterfaceData.pCallbacks3;

// Initialize callbacks that we want to intersept

    TestCallbacks.RenderState = &TestRenderState;
    TestCallbacks.RenderPrimitive = &TestRenderPrimitive;
    TestCallbacks.SceneCapture = &TestSceneCapture;

    TestCallbacks2.DrawOnePrimitive = &TestDrawOnePrimitive;
    TestCallbacks2.DrawOneIndexedPrimitive = &TestDrawOneIndexedPrimitive;
    TestCallbacks2.DrawPrimitives = &TestDrawPrimitives;

    TestCallbacks3.DrawPrimitives2 = &TestDrawPrimitives2;

    fout = NULL;
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        fout = fopen(szFileName, "wb");
        if (!fout)
            return DDERR_GENERIC;
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// CTestHalProvider::GetInterface
//
// Returns  test provider interface and real rasterizer global data.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTestHalProvider::GetInterface(THIS_
                               LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                               LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                               DWORD dwVersion)
{
    *pInterfaceData = TestInterfaceData;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// TestHalProvider::GetCaps
//
// Returns real rasterizer caps.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CTestHalProvider::GetCaps(THIS_
                          LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                          LPD3DDEVICEDESC7 pHwDesc,
                          LPD3DDEVICEDESC7 pHelDesc,
                          DWORD dwVersion)
{
    return pCurHalProvider->GetCaps(pDdGbl, pHwDesc, pHelDesc, dwVersion);
}

//#endif //DEBUG_PIPELINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\commdrv.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       commdrv.h
 *  Content:    Common driver structures
 *
 ***************************************************************************/

#ifndef _COMMDRV_H_
#define _COMMDRV_H_

#include "haldrv.hpp"

extern int      GenGetExtraVerticesNumber( LPDIRECT3DDEVICEI lpDevI );
extern LPD3DTLVERTEX    GenGetExtraVerticesPointer( LPDIRECT3DDEVICEI lpDevI );
extern HRESULT DrawPrim(LPDIRECT3DDEVICEI);
extern HRESULT DrawIndexPrim(LPDIRECT3DDEVICEI);
extern HRESULT DrawPrimLegacy(LPDIRECT3DDEVICEI);
extern HRESULT DrawIndexPrimLegacy(LPDIRECT3DDEVICEI);
extern HRESULT DrawPrimCB(LPDIRECT3DDEVICEI);
extern HRESULT DrawIndexPrimCB(LPDIRECT3DDEVICEI);
//---------------------------------------------------------------------
// This class builds a DDRAWSURFACE around memory bits
//
class CDDSurfaceFromMem
{
public:
    CDDSurfaceFromMem(LPVOID lpvMemory)
        {
            gblTL.fpVidMem = (ULONG_PTR)lpvMemory;
            lclTL.lpGbl = &gblTL;
            exeTL.lpLcl = &lclTL;
        }
    ~CDDSurfaceFromMem() {};
    LPDIRECTDRAWSURFACE GetSurface() {return (LPDIRECTDRAWSURFACE) &exeTL;}
    void SetBits(LPVOID lpvMemory)   {gblTL.fpVidMem = (ULONG_PTR)lpvMemory;}
protected:
    DDRAWI_DDRAWSURFACE_INT exeTL;
    DDRAWI_DDRAWSURFACE_LCL lclTL;
    DDRAWI_DDRAWSURFACE_GBL gblTL;
};
#endif /* _COMMDRV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\testprov.h ===
//----------------------------------------------------------------------------
//
// testprov.h
//
// Test HAL provider class.
//
// Test HAL provider is an itermediate object between D3DIM and
// real HAL provider. Itis used to print some data sent to a driver to a
// file. After that the real HAL driver is called.
// Test HAL provider is enabled by specifying non-empty string key "TestFile"
// under DIRECT3D key in the registry. The specified string is the name for
// a binary file to output data to. File format is described in TESTFILE.H
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#ifndef _TESTPROV_H_
#define _TESTPROV_H_

class CTestHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // IHalProvider.
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
};
//----------------------------------------------------------------------------
//
// GetTestProvider
//
// Input:
//      riid and pCurrentHalProvider are equal to the currently selected provider.
//      GlobalData  - data provided by DDraw
//      fileName    - output file name
//      dwFlags     - currently not used
//
// Returns:
//      the test HAL provider in ppHalProvider.
//      D3D_OK if success
//
//----------------------------------------------------------------------------
STDAPI GetTestHalProvider(REFIID riid,
                          DDRAWI_DIRECTDRAW_GBL *pGlobalData,
                          IHalProvider **ppHalProvider,
                          IHalProvider * pCurrentHalProvider,
                          DWORD dwFlags);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\texman.hpp ===
#ifndef TEXMAN_INCLUDED
#define TEXMAN_INCLUDED

typedef class TextureCacheManager *LPTextureCacheManager;

class TextureHeap 
{
    enum { InitialSize = 1023 };

    DWORD m_next, m_size;
    LPDIRECT3DTEXTUREI *m_data_p;

    DWORD parent(DWORD k) const { return k / 2; }
    DWORD lchild(DWORD k) const { return k * 2; }
    DWORD rchild(DWORD k) const { return k * 2 + 1; }
    void heapify(DWORD k);

public:

    TextureHeap(DWORD size = InitialSize);
    ~TextureHeap();
    bool Initialize();

    DWORD length() const { return m_next - 1; }
    const LPDIRECT3DTEXTUREI minCost() const { return m_data_p[1]; }

    bool add(LPDIRECT3DTEXTUREI);
    LPDIRECT3DTEXTUREI extractMin();
    LPDIRECT3DTEXTUREI extractMax();
    LPDIRECT3DTEXTUREI extractNotInScene(DWORD dwScene);
    void del(DWORD k);
    void update(DWORD k, BOOL inuse, DWORD priority, DWORD ticks); 
    void resetAllTimeStamps(DWORD ticks);
};

class TextureCacheManager {
    
    TextureHeap *m_heap_p;
    unsigned int tcm_ticks, m_dwScene, m_dwNumHeaps;
    LPDIRECT3DI	lpDirect3DI;
#if COLLECTSTATS
    D3DDEVINFO_TEXTUREMANAGER m_stats;
#endif

    // Free the LRU texture 
    BOOL FreeTextures(DWORD dwStage, DWORD dwCount);
    
public:
    //remove all HW handles and release surface
    void remove(LPDIRECT3DTEXTUREI lpD3DTexI);  
    
    HRESULT allocNode(LPDIRECT3DTEXTUREI lpD3DTexI, LPDIRECT3DDEVICEI lpDevI);
    TextureCacheManager(LPDIRECT3DI lpD3DI);
    ~TextureCacheManager();
    HRESULT Initialize();
    
    void RemoveFromHeap(LPDIRECT3DTEXTUREI lpD3DTexI) 
    { 
        m_heap_p[lpD3DTexI->ddsd.dwTextureStage].del(lpD3DTexI->m_dwHeapIndex); 
    }
    void UpdatePriority(LPDIRECT3DTEXTUREI lpD3DTexI) 
    { 
        if(lpD3DTexI->m_dwHeapIndex)
            m_heap_p[lpD3DTexI->ddsd.dwTextureStage].update(lpD3DTexI->m_dwHeapIndex, lpD3DTexI->m_bInUse, lpD3DTexI->m_dwPriority, lpD3DTexI->m_dwTicks); 
    }
#if COLLECTSTATS
    void IncTotSz(DWORD dwSize)
    {
        ++m_stats.dwTotalManaged;
        m_stats.dwTotalBytes += dwSize;
    }
    void DecTotSz(DWORD dwSize)
    {
        --m_stats.dwTotalManaged;
        m_stats.dwTotalBytes -= dwSize;
    }
    void IncNumSetTexInVid()
    {
        ++m_stats.dwNumUsedTexInVid;
    }
    void IncNumTexturesSet()
    {
        ++m_stats.dwNumTexturesUsed;
    }
    void IncBytesDownloaded(LPDDRAWI_DDRAWSURFACE_LCL lpLcl, LPRECT lpRect)
    {
        m_stats.dwApproxBytesDownloaded += BytesDownloaded(lpLcl, lpRect);
    }
    void ResetStatCounters()
    {
        m_stats.bThrashing = 0;
        m_stats.dwApproxBytesDownloaded = 0;
        m_stats.dwNumEvicts = 0;
        m_stats.dwNumVidCreates = 0;
        m_stats.dwNumUsedTexInVid = 0;
        m_stats.dwNumTexturesUsed = 0;
    }
    void GetStats(LPD3DDEVINFO_TEXTUREMANAGER stats)
    {
        memcpy(stats, &m_stats, sizeof(D3DDEVINFO_TEXTUREMANAGER));
    }
#endif
    void EvictTextures(); // Empty the entire cache
    BOOL CheckIfLost(); // check if any of the managed textures are lost
    void TimeStamp(LPDIRECT3DTEXTUREI);
    void SceneStamp() { ++m_dwScene; }
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\texman.cpp ===
#include "pch.cpp"
#pragma hdrstop

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::TextureHeap"

TextureHeap::TextureHeap(DWORD size)
{
    m_next = 1;
    m_size = size + 1;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::~TextureHeap"

TextureHeap::~TextureHeap()
{
    delete[] m_data_p;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::Initialize"
bool TextureHeap::Initialize()
{
    m_data_p = new LPDIRECT3DTEXTUREI[m_size];
    if(m_data_p == 0)
    {
        D3D_ERR("Failed to allocate texture heap.");
        return false;
    }
    memset(m_data_p, 0, sizeof(LPDIRECT3DTEXTUREI) * m_size);
    return true;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::heapify"

void TextureHeap::heapify(DWORD k)
{
    while(true)
    {
        DWORD smallest;
        DWORD l = lchild(k);
        DWORD r = rchild(k);
        if(l < m_next)
            if(m_data_p[l]->Cost() < m_data_p[k]->Cost())
                smallest = l;
            else
                smallest = k;
        else
            smallest = k;
        if(r < m_next)
            if(m_data_p[r]->Cost() < m_data_p[smallest]->Cost())
                smallest = r;
        if(smallest != k)
        {
            LPDIRECT3DTEXTUREI t = m_data_p[k];
            m_data_p[k] = m_data_p[smallest];
            m_data_p[k]->m_dwHeapIndex = k;
            m_data_p[smallest] = t;
            m_data_p[smallest]->m_dwHeapIndex = smallest;
            k = smallest;
        }
        else
            break;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::add"

bool TextureHeap::add(LPDIRECT3DTEXTUREI lpD3DTexI)
{
    if(m_next == m_size)
    {
        m_size = m_size * 2 - 1;
        LPDIRECT3DTEXTUREI *p = new LPDIRECT3DTEXTUREI[m_size];
        if(p == 0)
        {
            D3D_ERR("Failed to allocate memory to grow heap.");
            m_size = (m_size + 1) / 2; // restore size
            return false;
        }
        memcpy(p + 1, m_data_p + 1, sizeof(LPDIRECT3DTEXTUREI) * (m_next - 1));
        delete[] m_data_p;
        m_data_p = p;
    }
    ULONGLONG Cost = lpD3DTexI->Cost();
    for(DWORD k = m_next; k > 1; k = parent(k))
        if(Cost < m_data_p[parent(k)]->Cost())
        {
            m_data_p[k] = m_data_p[parent(k)];
            m_data_p[k]->m_dwHeapIndex = k;
        }
        else
            break;
    m_data_p[k] = lpD3DTexI;
    m_data_p[k]->m_dwHeapIndex = k;
    ++m_next;
    return true;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::extractMin"

LPDIRECT3DTEXTUREI TextureHeap::extractMin()
{
    LPDIRECT3DTEXTUREI lpD3DTexI = m_data_p[1];
    --m_next;
    m_data_p[1] = m_data_p[m_next];
    m_data_p[1]->m_dwHeapIndex = 1;
    heapify(1);
    lpD3DTexI->m_dwHeapIndex = 0;
    return lpD3DTexI;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::extractMax"

LPDIRECT3DTEXTUREI TextureHeap::extractMax()
{
    // When extracting the max element from the heap, we don't need to
    // search the entire heap, but just the leafnodes. This is because
    // it is guaranteed that parent nodes are cheaper than the leaf nodes
    // so once you have looked through the leaves, you won't find anything
    // cheaper.
    // NOTE: (lchild(i) >= m_next) is true only for leaf nodes.
    // ALSO NOTE: You cannot have a rchild without a lchild, so simply
    //            checking for lchild is sufficient.
    unsigned max = m_next - 1;
    ULONGLONG maxcost = 0;
    for(unsigned i = max; lchild(i) >= m_next; --i)
    {
        ULONGLONG Cost = m_data_p[i]->Cost();
        if(maxcost < Cost)
        {
            maxcost = Cost;
            max = i;
        }
    }
    LPDIRECT3DTEXTUREI lpD3DTexI = m_data_p[max];
    if(lpD3DTexI->m_bInUse)
    {
        max = 0;
        maxcost = 0;
        for(i = m_next - 1; i > 0; --i)
        {
            ULONGLONG Cost = m_data_p[i]->Cost();
            if(maxcost < Cost && !m_data_p[i]->m_bInUse)
            {
                maxcost = Cost;
                max = i;
            }
        }
        if(max == 0) // All textures in use
            return NULL;
        lpD3DTexI = m_data_p[max];
    }
    del(max);
    return lpD3DTexI;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::extractNotInScene"

LPDIRECT3DTEXTUREI TextureHeap::extractNotInScene(DWORD dwScene)
{
    for(unsigned i = 1; i < m_next; ++i)
    {
        if(m_data_p[i]->m_dwScene != dwScene)
        {
            LPDIRECT3DTEXTUREI lpD3DTexI = m_data_p[i];
            del(i);
            return lpD3DTexI;
        }
    }
    return NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::del"

void TextureHeap::del(DWORD k)
{
    LPDIRECT3DTEXTUREI lpD3DTexI = m_data_p[k];
    --m_next;
    ULONGLONG Cost = m_data_p[m_next]->Cost();
    if(Cost < lpD3DTexI->Cost())
    {
        while(k > 1)
        {
            if(Cost < m_data_p[parent(k)]->Cost())
            {
                m_data_p[k] = m_data_p[parent(k)];
                m_data_p[k]->m_dwHeapIndex = k;
            }
            else
                break;
            k = parent(k);
        }
        m_data_p[k] = m_data_p[m_next];
        m_data_p[k]->m_dwHeapIndex = k;
    }
    else
    {
        m_data_p[k] = m_data_p[m_next];
        m_data_p[k]->m_dwHeapIndex = k;
        heapify(k);
    }
    lpD3DTexI->m_dwHeapIndex = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::update"

void TextureHeap::update(DWORD k, BOOL inuse, DWORD priority, DWORD ticks)
{
    LPDIRECT3DTEXTUREI lpD3DTexI = m_data_p[k];
    ULONGLONG Cost;
#ifdef _X86_
    _asm
    {
        mov     edx, inuse;
        shl     edx, 31;
        mov     eax, priority;
        mov     ecx, eax;
        shr     eax, 1;
        or      edx, eax;
        mov     DWORD PTR Cost + 4, edx;
        shl     ecx, 31;
        mov     eax, ticks;
        shr     eax, 1;
        or      eax, ecx;
        mov     DWORD PTR Cost, eax;
    }
#else
    Cost = ((ULONGLONG)inuse << 63) + ((ULONGLONG)priority << 31) + ((ULONGLONG)(ticks >> 1));
#endif
    if(Cost < lpD3DTexI->Cost())
    {
        while(k > 1)
        {
            if(Cost < m_data_p[parent(k)]->Cost())
            {
                m_data_p[k] = m_data_p[parent(k)];
                m_data_p[k]->m_dwHeapIndex = k;
            }
            else
                break;
            k = parent(k);
        }
        lpD3DTexI->m_bInUse = inuse;
        lpD3DTexI->m_dwPriority = priority;
        lpD3DTexI->m_dwTicks = ticks;
        lpD3DTexI->m_dwHeapIndex = k;
        m_data_p[k] = lpD3DTexI;
    }
    else
    {
        lpD3DTexI->m_bInUse = inuse;
        lpD3DTexI->m_dwPriority = priority;
        lpD3DTexI->m_dwTicks = ticks;
        heapify(k);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureHeap::resetAllTimeStamps"

void TextureHeap::resetAllTimeStamps(DWORD ticks)
{
    for(unsigned i = 1; i < m_next; ++i)
    {
        update(i, m_data_p[i]->m_bInUse, m_data_p[i]->m_dwPriority, ticks);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::TextureCacheManager"

TextureCacheManager::TextureCacheManager(LPDIRECT3DI lpD3DI)
{
    tcm_ticks = 0;
    m_dwScene = 0;
    m_dwNumHeaps = 0;
    lpDirect3DI=lpD3DI;
#if COLLECTSTATS
    m_stats.dwWorkingSet = 0;
    m_stats.dwWorkingSetBytes = 0;
    m_stats.dwTotalManaged = 0;
    m_stats.dwTotalBytes = 0;
    m_stats.dwLastPri = 0;
#endif
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::~TextureCacheManager"

TextureCacheManager::~TextureCacheManager()
{
    EvictTextures();
    delete[] m_heap_p;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::Initialize"

HRESULT TextureCacheManager::Initialize()
{
    DDASSERT(((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl);
    LPD3DHAL_GLOBALDRIVERDATA lpD3DHALGlobalDriverData = ((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->lpD3DGlobalDriverData;
    if(lpD3DHALGlobalDriverData != NULL)
        if(lpD3DHALGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_SEPARATETEXTUREMEMORIES)
        {
            m_dwNumHeaps = ((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->lpD3DExtendedCaps->wMaxSimultaneousTextures;
            DDASSERT(m_dwNumHeaps);
            if(m_dwNumHeaps < 1)
            {
                D3D_ERR("Max simultaneous textures not set. Forced to 1.");
                m_dwNumHeaps = 1;
            }
            D3D_INFO(2, "Number of heaps set to %u.", m_dwNumHeaps);
        }
        else
            m_dwNumHeaps = 1;
    else
        m_dwNumHeaps = 1;
    m_heap_p = new TextureHeap[m_dwNumHeaps];
    if(m_heap_p == 0)
    {
        D3D_ERR("Out of memory allocating texture heap.");
        return E_OUTOFMEMORY;
    }
    for(DWORD i = 0; i < m_dwNumHeaps; ++i)
    {
        if(m_heap_p[i].Initialize() == FALSE)
            return E_OUTOFMEMORY;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::FreeTextures"

BOOL TextureCacheManager::FreeTextures(DWORD dwStage, DWORD dwBytes)
{
    if(m_heap_p[dwStage].length() == 0)
        return false;
    LPDIRECT3DTEXTUREI rc;
    for(unsigned i = 0; m_heap_p[dwStage].length() != 0 && i < dwBytes; i += rc->m_dwVidBytes)
    {
        // Find the LRU texture and remove it.
        rc = m_heap_p[dwStage].minCost();
        if(rc->m_bInUse)
            return false;
        if(rc->m_dwScene == m_dwScene)
        {
            if(((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->lpD3DGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
            {
                D3D_WARN(0, "Trying to locate texture not used in current scene...");
                rc = m_heap_p[dwStage].extractNotInScene(m_dwScene);
                if(rc == NULL)
                {
                    D3D_ERR("No such texture found. Cannot evict textures used in current scene.");
                    return false;
                }
                D3D_WARN(0, "Texture found!");
                remove(rc);
#if COLLECTSTATS
                m_stats.dwLastPri = rc->m_dwPriority;
                ++m_stats.dwNumEvicts;
#endif
            }
            else
            {
                D3D_WARN(1, "Texture cache thrashing. Removing MRU texture.");
                rc = m_heap_p[dwStage].extractMax();
                if(rc == NULL)
                {
                    D3D_ERR("All textures in use, cannot evict texture.");
                    return false;
                }
                remove(rc);
#if COLLECTSTATS
                m_stats.bThrashing = TRUE;
                m_stats.dwLastPri = rc->m_dwPriority;
                ++m_stats.dwNumEvicts;
#endif
            }
        }
        else
        {
            rc = m_heap_p[dwStage].extractMin();
            remove(rc);
#if COLLECTSTATS
            m_stats.dwLastPri = rc->m_dwPriority;
            ++m_stats.dwNumEvicts;
#endif
        }
        D3D_INFO(2, "Removed texture with timestamp %u,%u (current = %u).", rc->m_dwPriority, rc->m_dwTicks, tcm_ticks);
    }
    return true;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::allocNode"

HRESULT TextureCacheManager::allocNode(LPDIRECT3DTEXTUREI lpD3DTexI, LPDIRECT3DDEVICEI lpDevI)
{
    HRESULT ddrval;
    DWORD trycount = 0, bytecount = lpD3DTexI->m_dwBytes;
    // We need to make sure that we don't evict any mapped textures
    for(DWORD dwStage = 0; dwStage < lpDevI->dwMaxTextureBlendStages; ++dwStage)
    {
        if(lpDevI->lpD3DMappedTexI[dwStage])
        {
            lpDevI->lpD3DMappedTexI[dwStage]->m_bInUse = TRUE;
            UpdatePriority(lpDevI->lpD3DMappedTexI[dwStage]);
        }
    }
    // Attempt to allocate a texture.
    do
    {
        ++trycount;
        DDASSERT(lpD3DTexI->lpDDS == NULL);
        ddrval = lpDirect3DI->lpDD7->CreateSurface(&lpD3DTexI->ddsd, &lpD3DTexI->lpDDS, NULL);
        if (DD_OK == ddrval) // No problem, there is enough memory.
        {
            static_cast<DIRECT3DTEXTURED3DM*>(lpD3DTexI)->MarkDirtyPointers();
            lpD3DTexI->m_dwScene = m_dwScene;
            lpD3DTexI->m_dwTicks = tcm_ticks;
            DDASSERT(lpD3DTexI->m_dwHeapIndex == 0);
            if(!m_heap_p[lpD3DTexI->ddsd.dwTextureStage].add(lpD3DTexI))
            {
                ddrval = DDERR_OUTOFMEMORY;
                goto exit2;
            }
#if COLLECTSTATS
            ++m_stats.dwWorkingSet;
            m_stats.dwWorkingSetBytes += lpD3DTexI->m_dwVidBytes;
            ++m_stats.dwNumVidCreates;
#endif
        }
        else if(ddrval == DDERR_OUTOFVIDEOMEMORY) // If out of video memory
        {
            if (!FreeTextures(lpD3DTexI->ddsd.dwTextureStage, bytecount))
            {
                D3D_ERR("all Freed no further video memory available");
                ddrval = DDERR_OUTOFVIDEOMEMORY;        //nothing left
                goto exit1;
            }
            bytecount <<= 1;
        }
        else
        {
            D3D_ERR("Unexpected error got in allocNode %08x", ddrval);
            goto exit1;
        }
    }
    while(ddrval == DDERR_OUTOFVIDEOMEMORY);
    if(trycount > 1)
    {
        D3DTextureUpdate(static_cast<LPUNKNOWN>(&(lpDirect3DI->mD3DUnk)));
        D3D_WARN(1, "Allocated texture after %u tries.", trycount);
    }
    if (lpD3DTexI->ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED1))
    {
        LPDIRECTDRAWPALETTE lpDDPal;
        if (DD_OK != (ddrval = lpD3DTexI->lpDDSSys->GetPalette(&lpDDPal)))
        {
            D3D_ERR("failed to check for palette on texture");
            goto exit3;
        }
        if (DD_OK != (ddrval = lpD3DTexI->lpDDS->SetPalette(lpDDPal)))
        {
            lpDDPal->Release();
            D3D_ERR("SetPalette returned error");
            goto exit3;
        }
        lpDDPal->Release();
    }
    { // scope for CLockD3DST
        // Mark everything dirty before copying sysmem to vidmem
        // else CopySurface will not copy anything
        lpD3DTexI->bDirty = TRUE;
        CLockD3DST lockObject(lpDevI, DPF_MODNAME, REMIND("")); // we access DDraw gbl in CopySurface
        // 0xFFFFFFFF is equivalent to ALL_FACES, but in addition indicates to CopySurface
        // that this is a sysmem -> vidmem transfer.
        if (DD_OK != (ddrval = lpDevI->CopySurface(lpD3DTexI->lpDDS, NULL, lpD3DTexI->lpDDSSys, NULL, 0xFFFFFFFF)))
        {
            D3D_ERR("CopySurface returned error");
            goto exit3;
        }
        lpD3DTexI->bDirty = FALSE;
    }
    lpD3DTexI->DDS1Tex.lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(lpD3DTexI->lpDDS))->lpLcl;
    lpD3DTexI->m_hTex = ((LPDDRAWI_DDRAWSURFACE_INT)lpD3DTexI->lpDDS)->lpLcl->lpSurfMore->dwSurfaceHandle;
    ddrval = D3D_OK;
    goto exit1;
exit3:
    m_heap_p[lpD3DTexI->ddsd.dwTextureStage].del(lpD3DTexI->m_dwHeapIndex);
exit2:
    lpD3DTexI->lpDDS->Release();
    lpD3DTexI->lpDDS = NULL;
exit1:
    for(dwStage = 0; dwStage < lpDevI->dwMaxTextureBlendStages; ++dwStage)
    {
        if(lpDevI->lpD3DMappedTexI[dwStage])
        {
            lpDevI->lpD3DMappedTexI[dwStage]->m_bInUse = FALSE;
            UpdatePriority(lpDevI->lpD3DMappedTexI[dwStage]);
        }
    }
    return ddrval;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::remove"

//remove all HW handles and release surface
void TextureCacheManager::remove(LPDIRECT3DTEXTUREI lpD3DTexI)
{
    LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&lpD3DTexI->blocks);
    while(tBlock)
    {
        CLockD3DST lockObject(tBlock->lpDevI, DPF_MODNAME, REMIND(""));
        D3DI_RemoveTextureHandle(tBlock);
        tBlock=LIST_NEXT(tBlock,list);
    }
    D3D_INFO(7,"removing lpD3DTexI=%08lx lpDDS=%08lx",lpD3DTexI,lpD3DTexI->lpDDS);
    lpD3DTexI->lpDDS->Release();
    lpD3DTexI->lpDDS = NULL;
    lpD3DTexI->m_hTex = 0;
#if COLLECTSTATS
    --m_stats.dwWorkingSet;
    m_stats.dwWorkingSetBytes -= lpD3DTexI->m_dwVidBytes;
#endif
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::EvictTextures"

void TextureCacheManager::EvictTextures()
{
    for(DWORD i = 0; i < m_dwNumHeaps; ++i)
        while(m_heap_p[i].length())
        {
            LPDIRECT3DTEXTUREI lpD3DTexI = m_heap_p[i].extractMin();
            remove(lpD3DTexI);
        }
    D3DTextureUpdate(static_cast<LPUNKNOWN>(&(lpDirect3DI->mD3DUnk)));
    tcm_ticks = 0;
    m_dwScene = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::CheckIfLost"

BOOL TextureCacheManager::CheckIfLost()
{
    for(DWORD i = 0; i < m_dwNumHeaps; ++i)
    {
        if(m_heap_p[i].length())
        {
            if(((LPDDRAWI_DDRAWSURFACE_INT)(m_heap_p[i].minCost()->lpDDS))->lpLcl->dwFlags & DDRAWISURF_INVALID)
                return TRUE;
            else
                return FALSE;
        }
    }
    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::TimeStamp"

void TextureCacheManager::TimeStamp(LPDIRECT3DTEXTUREI lpD3DTexI)
{
    lpD3DTexI->m_dwScene = m_dwScene;
    m_heap_p[lpD3DTexI->ddsd.dwTextureStage].update(lpD3DTexI->m_dwHeapIndex, lpD3DTexI->m_bInUse, lpD3DTexI->m_dwPriority, tcm_ticks);
    unsigned tickp2 = tcm_ticks + 2;
    if(tickp2 > tcm_ticks)
    {
        tcm_ticks = tickp2;
    }
    else // counter has overflowed. Let's reset all timestamps to zero
    {
        D3D_INFO(2, "Timestamp counter overflowed. Reseting timestamps for all textures.");
        tcm_ticks = 0;
        for(DWORD i = 0; i < m_dwNumHeaps; ++i)
            m_heap_p[i].resetAllTimeStamps(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\tldevice.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       tldevice.cpp
 *
 *  Content:    Support code for device with transformation and lighting
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

#include "tlhal.h"
#include "drawprim.hpp"
#include "pvvid.h"
//=====================================================================
//
//      CDirect3DDevice7 interface
//
//=====================================================================
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::Init"

HRESULT CDirect3DDevice7::Init(
     REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
     IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice)
{
#if 0
    // Stateblocks are always emulated on DX7
    DWORD value = 0;
    GetD3DRegValue(REG_DWORD, "EmulateStateBlocks", &value, sizeof(DWORD));
    if(value == 0)
    {
        // All DX7 devices should support state sets
        this->dwFEFlags |= D3DFE_STATESETS;
    }
#endif

    HRESULT ret = CDirect3DDeviceIDP2::Init(riid, lpD3DI, lpDDS, pUnkOuter, lplpD3DDevice);
    if (ret != D3D_OK)
        return ret;

    // Do device specific initialization here
    return D3D_OK;
}
//---------------------------------------------------------------------
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::WriteStateSetToDevice"

void CDirect3DDevice7::WriteStateSetToDevice(D3DSTATEBLOCKTYPE sbt)
{
    DWORD  dwDeviceHandle;
    LPVOID pBuffer;
    DWORD  dwBufferSize;
    
    m_pStateSets->GetDeviceBufferInfo(&dwDeviceHandle, &pBuffer, &dwBufferSize);

    // If device buffer is empty we do not create the set state macro in the device
    if (dwBufferSize == 0)
        return;

    DWORD dwByteCount = dwBufferSize + (sizeof(D3DHAL_DP2STATESET) + sizeof(D3DHAL_DP2COMMAND)) * 2;

    // Check to see if there is space to add a new command for space
    if (dwByteCount + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        // Request the driver to grow the command buffer upon flush
        dp2data.dwReqCommandBufSize = dwByteCount;
        dp2data.dwFlags |= D3DHALDP2_REQCOMMANDBUFSIZE;
        HRESULT ret = FlushStates();
        dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
        if (ret != D3D_OK)
            throw ret;
        // Check if the driver did give us what we need or do it ourselves
        ret = GrowCommandBuffer(this->lpDirect3DI, dwByteCount);
        if (ret != D3D_OK)
        {
            D3D_ERR("Could not grow Command Buffer");
            throw ret;
        }
    }

    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_STATESET;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    LPD3DHAL_DP2STATESET pData = (LPD3DHAL_DP2STATESET)(lpDP2CurrCommand + 1);
    pData->dwOperation = D3DHAL_STATESETBEGIN;
    pData->dwParam = dwDeviceHandle;
    pData->sbType = sbt;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);

    // Copy the entire state macro to the DP2 buffer
    memcpy(pData + 1, pBuffer, dwBufferSize);

    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pData + 1) + dwBufferSize);
    lpDP2CurrCommand->bCommand = D3DDP2OP_STATESET;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    pData = (LPD3DHAL_DP2STATESET)(lpDP2CurrCommand + 1);
    pData->dwOperation = D3DHAL_STATESETEND;
    pData->dwParam = dwDeviceHandle;
    pData->sbType = sbt;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);

    dwDP2CommandLength += dwByteCount;

    HRESULT ret = FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to render batched commands in WriteStateSetToDevice");
        throw ret;
    }
    else
    {
        if(this->dwFEFlags & D3DFE_LOSTSURFACES)
        {
            D3D_ERR("State blocks lost in WriteStateSetToDevice");
            throw DDERR_SURFACELOST;
        }
    }
}
//---------------------------------------------------------------------
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::TexBltI"

HRESULT CDirect3DDevice7::TexBltI(LPDDRAWI_DDRAWSURFACE_LCL lpDst,
                                  LPDDRAWI_DDRAWSURFACE_LCL lpSrc,
                                  LPPOINT p, RECTL *r, DWORD dwFlags)
{
    HRESULT ret = D3D_OK;
#ifdef  WINNT
    // WINNT allows delay create of Kernel object
    // if such a create fails, we can't pass handle to driver
    if(dwFEFlags & D3DFE_REALHAL)
    {
        if (!lpSrc->hDDSurface && !CompleteCreateSysmemSurface(lpSrc))
        {
            return DDERR_GENERIC;
        }
        if (lpDst && !lpDst->hDDSurface && !CompleteCreateSysmemSurface(lpDst))
        {
            return DDERR_GENERIC;
        }
    }
#endif
    // If the driver supports the GetSysmemBltStatus call, then the driver can
    // do the Blt asynchronously. In this case, set the HARDWAREOP_STARTED
    // flags so that Locks and Blts to the surface(s) in concern spin until
    // the async Blt is finished.
    if((lpSrc->lpSurfMore->lpDD_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus != NULL)
        && (lpSrc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        lpSrc->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPSOURCE;
    }
    if (bDP2CurrCmdOP == D3DDP2OP_TEXBLT)
    { // Last instruction is a tex blt, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2TEXBLT) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2TEXBLT lpTexBlt = (LPD3DHAL_DP2TEXBLT)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpTexBlt->dwDDDestSurface   = lpDst == NULL ? 0 : lpDst->lpSurfMore->dwSurfaceHandle;
            lpTexBlt->dwDDSrcSurface    = lpSrc->lpSurfMore->dwSurfaceHandle;
            lpTexBlt->pDest             = *p;
            lpTexBlt->rSrc              = *r;
            lpTexBlt->dwFlags           = dwFlags;
            dwDP2CommandLength += sizeof(D3DHAL_DP2TEXBLT);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXBLT) > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in TexBltI");
            return ret;
        }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_TEXBLT;
    bDP2CurrCmdOP = D3DDP2OP_TEXBLT;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2TEXBLT lpTexBlt = (LPD3DHAL_DP2TEXBLT)(lpDP2CurrCommand + 1);
    lpTexBlt->dwDDDestSurface   = lpDst == NULL ? 0 : lpDst->lpSurfMore->dwSurfaceHandle;
    lpTexBlt->dwDDSrcSurface    = lpSrc->lpSurfMore->dwSurfaceHandle;
    lpTexBlt->pDest             = *p;
    lpTexBlt->rSrc              = *r;
    lpTexBlt->dwFlags           = dwFlags;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TEXBLT);
    return ret;
}
//---------------------------------------------------------------------
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::SetPriorityI"

HRESULT CDirect3DDevice7::SetPriorityI(LPDDRAWI_DDRAWSURFACE_LCL lpDst, DWORD dwPriority)
{
    HRESULT ret = D3D_OK;
    if (bDP2CurrCmdOP == D3DDP2OP_SETPRIORITY)
    { // Last instruction is a set priority, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2SETPRIORITY) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2SETPRIORITY lpSetPriority = (LPD3DHAL_DP2SETPRIORITY)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpSetPriority->dwDDSurface    = lpDst->lpSurfMore->dwSurfaceHandle;
            lpSetPriority->dwPriority     = dwPriority;
            dwDP2CommandLength += sizeof(D3DHAL_DP2SETPRIORITY);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETPRIORITY) > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetPriorityI");
            return ret;
        }
    }
    // Add new setpriority instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_SETPRIORITY;
    bDP2CurrCmdOP = D3DDP2OP_SETPRIORITY;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2SETPRIORITY lpSetPriority = (LPD3DHAL_DP2SETPRIORITY)(lpDP2CurrCommand + 1);
    lpSetPriority->dwDDSurface = lpDst->lpSurfMore->dwSurfaceHandle;
    lpSetPriority->dwPriority  = dwPriority;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETPRIORITY);
    return ret;
}
//---------------------------------------------------------------------
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::SetTexLODI"

HRESULT CDirect3DDevice7::SetTexLODI(LPDDRAWI_DDRAWSURFACE_LCL lpDst, DWORD dwLOD)
{
    HRESULT ret = D3D_OK;
    if (bDP2CurrCmdOP == D3DDP2OP_SETTEXLOD)
    { // Last instruction is a set LOD, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2SETTEXLOD) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2SETTEXLOD lpSetTexLOD = (LPD3DHAL_DP2SETTEXLOD)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpSetTexLOD->dwDDSurface      = lpDst->lpSurfMore->dwSurfaceHandle;
            lpSetTexLOD->dwLOD            = dwLOD;
            dwDP2CommandLength += sizeof(D3DHAL_DP2SETTEXLOD);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETTEXLOD) > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetTexLODI");
            return ret;
        }
    }
    // Add new set LOD instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_SETTEXLOD;
    bDP2CurrCmdOP = D3DDP2OP_SETTEXLOD;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2SETTEXLOD lpSetTexLOD = (LPD3DHAL_DP2SETTEXLOD)(lpDP2CurrCommand + 1);
    lpSetTexLOD->dwDDSurface = lpDst->lpSurfMore->dwSurfaceHandle;
    lpSetTexLOD->dwLOD       = dwLOD;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETTEXLOD);
    return ret;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::UpdatePalette"
//---------------------------------------------------------------------
// This function should be called from PaletteUpdateNotify
//
HRESULT CDirect3DDevice7::UpdatePalette(
        DWORD dwPaletteHandle,
        DWORD dwStartIndex,
        DWORD dwNumberOfIndices,
        LPPALETTEENTRY pFirstIndex)
{
    HRESULT ret = D3D_OK;
    DWORD   dwSizeChange=sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2UPDATEPALETTE) + dwNumberOfIndices*sizeof(PALETTEENTRY);
    if (bDP2CurrCmdOP == D3DDP2OP_UPDATEPALETTE)
    { // Last instruction is a tex blt, append this one to it
    }
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in TexBltI");
            return ret;
        }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_UPDATEPALETTE;
    bDP2CurrCmdOP = D3DDP2OP_UPDATEPALETTE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2UPDATEPALETTE lpUpdatePal = (LPD3DHAL_DP2UPDATEPALETTE)(lpDP2CurrCommand + 1);
    lpUpdatePal->dwPaletteHandle=dwPaletteHandle;
    lpUpdatePal->wStartIndex=(WORD)dwStartIndex;
    lpUpdatePal->wNumEntries=(WORD)dwNumberOfIndices;
    memcpy((LPVOID)(lpUpdatePal+1),(LPVOID)pFirstIndex,
        dwNumberOfIndices*sizeof(PALETTEENTRY));
    dwDP2CommandLength += dwSizeChange;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::SetPalette"
//---------------------------------------------------------------------
// This function should be called from PaletteAssociateNotify
//
HRESULT CDirect3DDevice7::SetPalette(DWORD dwPaletteHandle,
                                     DWORD dwPaletteFlags,
                                     DWORD dwSurfaceHandle )
{
    HRESULT ret = D3D_OK;
    DWORD   dwSizeChange;
    if (bDP2CurrCmdOP == D3DDP2OP_SETPALETTE)
    { // Last instruction is a tex blt, append this one to it
    }

    dwSizeChange=sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETPALETTE);
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in TexBltI");
            return ret;
        }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_SETPALETTE;
    bDP2CurrCmdOP = D3DDP2OP_UPDATEPALETTE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    LPD3DHAL_DP2SETPALETTE lpSetPal = (LPD3DHAL_DP2SETPALETTE)(lpDP2CurrCommand + 1);
    lpSetPal->dwPaletteHandle=dwPaletteHandle;
    lpSetPal->dwPaletteFlags=dwPaletteFlags;
    lpSetPal->dwSurfaceHandle=dwSurfaceHandle;
    dwDP2CommandLength += dwSizeChange;
    return ret;
}
//---------------------------------------------------------------------
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::UpdateTextures"

HRESULT CDirect3DDevice7::UpdateTextures()
{
    HRESULT result = D3D_OK;
    DWORD dwSavedFlags = this->dwFlags;
    this->dwFlags |= D3DPV_WITHINPRIMITIVE;
    for (DWORD dwStage = 0; dwStage < this->dwMaxTextureBlendStages; dwStage++)
    {
        D3DTEXTUREHANDLE dwDDIHandle;
        LPDIRECT3DTEXTUREI lpTexI = this->lpD3DMappedTexI[dwStage];
        if(lpTexI)
        {
            if (lpTexI->InVidmem())
            {
                if (lpTexI->bDirty)
                {

                    CLockD3DST lockObject(this, DPF_MODNAME, REMIND("")); // we access DDraw gbl in CopySurface
                    // 0xFFFFFFFF is equivalent to ALL_FACES, but in addition indicates to CopySurface
                    // that this is a sysmem -> vidmem transfer.
                    result = CopySurface(lpTexI->lpDDS,NULL,lpTexI->lpDDSSys,NULL,0xFFFFFFFF);
                    if (DD_OK != result)
                    {
                        D3D_ERR("Error copying surface while updating textures");
                        goto l_exit;
                    }
                    else
                    {
                        lpTexI->bDirty=FALSE;
                        D3D_INFO(4,"UpdateTextures: Dirty texture updated");
                    }
                }
            }
            else
            {
                if(lpTexI->D3DManaged())
                {
                    // Not in vidmem, so we need to call GetTextureDDIHandle
                    m_dwStageDirty |= (1 << dwStage);
                }
            }
            if (m_dwStageDirty & (1 << dwStage))
            {
                result = GetTextureDDIHandle(lpTexI, &dwDDIHandle);
                if (result != D3D_OK)
                {
                    D3D_ERR("Failed to get texture handle");
                    goto l_exit;
                }
                BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)lpTexI->lpDDS)->lpLcl);
                m_dwStageDirty &= ~(1 << dwStage); // reset stage dirty
            }
            else
            {
                continue; // Ok, then nothing needs to be done further
            }
        }
        else if (m_dwStageDirty & (1 << dwStage))
        {
            dwDDIHandle = 0;    //tell driver to disable this texture
            m_dwStageDirty &= ~(1 << dwStage); // reset stage dirty
        }
        else
        {
            continue;
        }
        result = SetTSSI(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, dwDDIHandle);
        if(result != D3D_OK)
        {
            D3D_ERR("Failed to batch set texture instruction");
            goto l_exit;
        }
        // Update runtime copy of state.
        this->tsstates[dwStage][D3DTSS_TEXTUREMAP] = dwDDIHandle;
    }
l_exit:
    this->dwFlags = dwSavedFlags;
    return result;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::GetTextureDDIHandle"

HRESULT CDirect3DDevice7::GetTextureDDIHandle(LPDIRECT3DTEXTUREI lpTexI, D3DTEXTUREHANDLE *phTex)
{
    if(lpTexI->D3DManaged())
    {
        if(!lpTexI->InVidmem())
        {
            HRESULT ret = lpDirect3DI->lpTextureManager->allocNode(lpTexI, this);
            if (D3D_OK != ret)
            {
                D3D_ERR("Failed to create video memory surface");
                return ret;
            }
        }
        lpDirect3DI->lpTextureManager->TimeStamp(lpTexI);
    }
    *phTex = lpTexI->m_hTex;
    return D3D_OK;
}

void CDirect3DDevice7::SetRenderTargetI(LPDIRECTDRAWSURFACE pRenderTarget, LPDIRECTDRAWSURFACE pZBuffer)
{
    LPD3DHAL_DP2SETRENDERTARGET pData;
    pData = (LPD3DHAL_DP2SETRENDERTARGET)GetHalBufferPointer(D3DDP2OP_SETRENDERTARGET, sizeof(*pData));
    pData->hRenderTarget = ((LPDDRAWI_DDRAWSURFACE_INT)pRenderTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;
    if (pZBuffer)
        pData->hZBuffer = ((LPDDRAWI_DDRAWSURFACE_INT)pZBuffer)->lpLcl->lpSurfMore->dwSurfaceHandle;
    else
        pData->hZBuffer = 0;

    // Flush before switching RenderTarget..
    HRESULT ret = FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to FlushStates in SetRenderTarget");
        throw ret;
    }

}
void CDirect3DDevice7::SetRenderTargetINoFlush(LPDIRECTDRAWSURFACE pRenderTarget, LPDIRECTDRAWSURFACE pZBuffer)
{
    LPD3DHAL_DP2SETRENDERTARGET pData;
    pData = (LPD3DHAL_DP2SETRENDERTARGET)GetHalBufferPointer(D3DDP2OP_SETRENDERTARGET, sizeof(*pData));
    pData->hRenderTarget = ((LPDDRAWI_DDRAWSURFACE_INT)pRenderTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;
    if (pZBuffer)
        pData->hZBuffer = ((LPDDRAWI_DDRAWSURFACE_INT)pZBuffer)->lpLcl->lpSurfMore->dwSurfaceHandle;
    else
        pData->hZBuffer = 0;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::CanDoTexBlt"

bool CDirect3DDevice7::CanDoTexBlt(LPDDRAWI_DDRAWSURFACE_LCL lpDDSSrcSubFace_lcl,
                                   LPDDRAWI_DDRAWSURFACE_LCL lpDDSDstSubFace_lcl)
{
    if(dwFEFlags & D3DFE_REALHAL)
    {
        DWORD &srccaps     = lpDDSSrcSubFace_lcl->ddsCaps.dwCaps;
        DWORD &dstcaps     = lpDDSDstSubFace_lcl->ddsCaps.dwCaps;
        DDCORECAPS &ddcaps = ((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->ddCaps;
        if(srccaps & DDSCAPS_VIDEOPORT)
        {
            return false;
        }
        DDPIXELFORMAT &srcpf = PixelFormat(lpDDSSrcSubFace_lcl);
        DDPIXELFORMAT &dstpf = PixelFormat(lpDDSDstSubFace_lcl);
        if(!MatchDDPIXELFORMAT(&srcpf, &dstpf))
        {
            return false;
        }
        else if((srcpf.dwFlags & DDPF_FOURCC) && srcpf.dwFourCC == dstpf.dwFourCC &&
            !(ddcaps.dwCaps2 & DDCAPS2_COPYFOURCC))
        {
            return false;
        }
        if(ddcaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS)
        {
            if(srccaps & DDSCAPS_SYSTEMMEMORY)
            {
                if((dstcaps & DDSCAPS_NONLOCALVIDMEM) && (this->d3dDevDesc.dwDevCaps & D3DDEVCAPS_CANBLTSYSTONONLOCAL))
                {
                    return true;
                }
                else if((dstcaps & DDSCAPS_LOCALVIDMEM) && (ddcaps.dwSVBCaps & DDCAPS_BLT))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else if(srccaps & DDSCAPS_NONLOCALVIDMEM)
            {
                LPDDNONLOCALVIDMEMCAPS &lpnlvcaps = ((LPDDRAWI_DIRECTDRAW_INT)lpDirect3DI->lpDD7)->lpLcl->lpGbl->lpddNLVCaps;
                DDASSERT(lpnlvcaps);
                if((dstcaps & DDSCAPS_LOCALVIDMEM) && (lpnlvcaps->dwNLVBCaps & DDCAPS_BLT))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else if(srccaps & DDSCAPS_LOCALVIDMEM)
            {
                if((dstcaps & DDSCAPS_LOCALVIDMEM) && (ddcaps.dwCaps & DDCAPS_BLT))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
        else
        {
            if(srccaps & DDSCAPS_SYSTEMMEMORY)
            {
                if((dstcaps & DDSCAPS_VIDEOMEMORY) && (ddcaps.dwSVBCaps & DDCAPS_BLT))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else if(srccaps & DDSCAPS_VIDEOMEMORY)
            {
                if((dstcaps & DDSCAPS_VIDEOMEMORY) && (ddcaps.dwCaps & DDCAPS_BLT))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
    }
    return false;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::ClearI"

void CDirect3DDevice7::ClearI(DWORD dwFlags, DWORD clrCount, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
    DWORD dwCommandSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2CLEAR) + sizeof(RECT) * (clrCount - 1);

    // Check to see if there is space to add a new command for space
    if (dwCommandSize + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        HRESULT ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in CDirect3DDevice7::ClearI");
            throw ret;
        }
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_CLEAR;
    bDP2CurrCmdOP = D3DDP2OP_CLEAR;
    lpDP2CurrCommand->bReserved = 0;
    wDP2CurrCmdCnt = (WORD)clrCount;
    lpDP2CurrCommand->wStateCount = wDP2CurrCmdCnt;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    dwDP2CommandLength += dwCommandSize;

    // Write data
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(lpDP2CurrCommand + 1);
    pData->dwFlags = dwFlags;
    pData->dwFillColor = dwColor;
    pData->dvFillDepth = dvZ;
    pData->dwFillStencil = dwStencil;
    memcpy(pData->Rects, clrRects, clrCount * sizeof(D3DRECT));
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDevice7::GetInfo"

HRESULT D3DAPI CDirect3DDevice7::GetInfo(DWORD dwDevInfoID, LPVOID pDevInfoStruct, DWORD dwSize)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid DIRECT3DDEVICE7 pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (dwSize == 0 || !VALID_D3DDEVINFOSTRUCT_PTR(pDevInfoStruct, dwSize))
    {
        D3D_ERR( "Invalid structure pointer or size" );
        return DDERR_INVALIDOBJECT;
    }
    memset(pDevInfoStruct, 0, dwSize);
#if DBG
    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)
    {
        D3D_WARN( 2, "GetInfo called within a scene" );
    }
    if( this->pfnGetDriverState == NULL )
    {
        D3D_ERR( "GetDriverState not implemented by the driver" );
        DDASSERT( this->pfnGetDriverState );
    }
#endif
    try
    {
        switch(dwDevInfoID)
        {
#if COLLECTSTATS
        case D3DDEVINFOID_TEXTUREMANAGER:
            if(!(((LPDDRAWI_DIRECTDRAW_INT)(this->lpDirect3DI->lpDD7))->lpLcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANMANAGETEXTURE))
            {
                lpDirect3DI->lpTextureManager->GetStats((LPD3DDEVINFO_TEXTUREMANAGER)pDevInfoStruct);
                return D3D_OK;
            }
            break;
#else
        case D3DDEVINFOID_TEXTUREMANAGER:
            D3D_WARN( 0, "Stats not collected in this build" );
            return S_FALSE;
#endif
        default:
            if(GetInfoInternal(dwDevInfoID, pDevInfoStruct, dwSize))
                return D3D_OK;
        }

        HRESULT hr = FlushStates();
        if(hr != D3D_OK)
        {
            D3D_ERR("Error flushing device");
            return hr;
        }
    }
    catch(HRESULT ret)
    {
        memset(pDevInfoStruct, 0, dwSize);
        return ret;
    }

    HRESULT hr;
    DDHAL_GETDRIVERSTATEDATA dsd;
    dsd.dwFlags = dwDevInfoID;
    dsd.dwhContext = this->dwhContext;
    dsd.lpdwStates = (LPDWORD)pDevInfoStruct;
    dsd.dwLength = dwSize;
    LOCK_HAL(hr, this);
    hr = this->pfnGetDriverState(&dsd);
    UNLOCK_HAL(this);
    if (hr != DDHAL_DRIVER_HANDLED)
    {
        D3D_WARN( 1, "Device information query unsupported" );
        memset(pDevInfoStruct, 0, dwSize);
        return S_FALSE;
    }
    else if (dsd.ddRVal != DD_OK)
    {
        D3D_INFO(1,"Driver failed GetInfo");
        memset(pDevInfoStruct, 0, dwSize);
        return E_FAIL;
    }

    return D3D_OK;    
}
//=====================================================================
//
//      CDirect3DDeviceTL interface
//
//=====================================================================
CDirect3DDeviceTL::CDirect3DDeviceTL()
{
    deviceType = D3DDEVTYPE_DX7TLHAL;
    m_rsMax = D3D_MAXRENDERSTATES;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::Init"

HRESULT CDirect3DDeviceTL::Init(
     REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
     IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice)
{
    this->dwFEFlags |= D3DFE_TLHAL;

#if 0
    // Stateblocks are always emulated on DX7
    DWORD value = 0;
    GetD3DRegValue(REG_DWORD, "EmulateStateBlocks", &value, sizeof(DWORD));
    if(value == 0)
    {
        // All DX7 devices should support state sets
        this->dwFEFlags |= D3DFE_STATESETS;
    }
#endif

    HRESULT ret = CDirect3DDevice7::Init(riid, lpD3DI, lpDDS, pUnkOuter, lplpD3DDevice);
    if (ret != D3D_OK)
        return ret;

    // Do device specific initialization here
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::MaterialChanged"

void CDirect3DDeviceTL::MaterialChanged()
{
    // Update front-end state (for ProcessVertices calls)
    DIRECT3DDEVICEI::MaterialChanged();

    // Driver should not be called because it will execute the macro)
    if (this->dwFEFlags & D3DFE_EXECUTESTATEMODE)
        return;

    LPD3DHAL_DP2SETMATERIAL pData;
    pData = (LPD3DHAL_DP2SETMATERIAL)GetHalBufferPointer(D3DDP2OP_SETMATERIAL, sizeof(*pData));
    *pData = this->lighting.material;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::SetClipPlaneI"

void CDirect3DDeviceTL::SetClipPlaneI(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
    // Update front-end state (for DrawPrimitiveStrided calls)
    DIRECT3DDEVICEI::SetClipPlaneI(dwPlaneIndex, pPlaneEquation);
    // Driver should not be called because it will execute the macro)
    if (this->dwFEFlags & D3DFE_EXECUTESTATEMODE)
        return;
#if DBG
    if (dwPlaneIndex >= this->transform.dwMaxUserClipPlanes)
    {
        D3D_WARN(1, "Device does not support that many clipping planes");
        return;
    }
#endif
    LPD3DHAL_DP2SETCLIPPLANE pData;
    pData = (LPD3DHAL_DP2SETCLIPPLANE)GetHalBufferPointer(D3DDP2OP_SETCLIPPLANE, sizeof(*pData));
    pData->dwIndex = dwPlaneIndex;
    pData->plane[0] = pPlaneEquation[0];
    pData->plane[1] = pPlaneEquation[1];
    pData->plane[2] = pPlaneEquation[2];
    pData->plane[3] = pPlaneEquation[3];
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::LightChanged"

void CDirect3DDeviceTL::LightChanged(DWORD dwLightIndex)
{
    // Update front-end state (for ProcessVertices calls)
    LPDIRECT3DLIGHTI pLight = &m_pLights[dwLightIndex];
    BOOL bValid = pLight->Valid(); // Valid bit will be set in LightChanged
    DIRECT3DDEVICEI::LightChanged(dwLightIndex);

    // If this is first time we set the light data, we call HALL to create
    // light. HAL could grow the internal light list at this time
    if (!bValid)
    {
        LPD3DHAL_DP2CREATELIGHT pData;
        pData = (LPD3DHAL_DP2CREATELIGHT)GetHalBufferPointer(D3DDP2OP_CREATELIGHT, sizeof(*pData));
        pData->dwIndex = dwLightIndex;
        pLight->m_LightI.flags |= D3DLIGHTI_VALID;
    }

    if (this->dwFEFlags & D3DFE_EXECUTESTATEMODE)
        return;

    LPD3DHAL_DP2SETLIGHT pData;
    pData = (LPD3DHAL_DP2SETLIGHT)GetHalBufferPointer(D3DDP2OP_SETLIGHT,
                                                      sizeof(*pData)+sizeof(D3DLIGHT7));
    pData->dwIndex = dwLightIndex;
    pData->dwDataType = D3DHAL_SETLIGHT_DATA;
    *(D3DLIGHT7 *)((LPBYTE)pData + sizeof(D3DHAL_DP2SETLIGHT)) =
        pLight->m_Light;
}
//---------------------------------------------------------------------
// Nothing to do here, because render state is used to enable/disable
// lights
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::LightEnableI"

void CDirect3DDeviceTL::LightEnableI(DWORD dwLightIndex, BOOL bEnable)
{
    DIRECT3DDEVICEI::LightEnableI(dwLightIndex, bEnable);
    if (!(this->dwFEFlags & D3DFE_EXECUTESTATEMODE))
    {
        LPD3DHAL_DP2SETLIGHT pData;
        pData = (LPD3DHAL_DP2SETLIGHT)GetHalBufferPointer(D3DDP2OP_SETLIGHT, sizeof(*pData));
        pData->dwIndex = dwLightIndex;
        if (bEnable)
            pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
        else
            pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::SetTransformI"

void CDirect3DDeviceTL::SetTransformI(D3DTRANSFORMSTATETYPE type,
                                               LPD3DMATRIX pMat)
{
    DDASSERT(pMat != NULL);
    DIRECT3DDEVICEI::SetTransformI(type, pMat);
    if (!(this->dwFEFlags & D3DFE_EXECUTESTATEMODE))
    {
        LPD3DHAL_DP2SETTRANSFORM pData;
        pData = (LPD3DHAL_DP2SETTRANSFORM)GetHalBufferPointer(D3DDP2OP_SETTRANSFORM, sizeof(*pData));
        pData->xfrmType = type;
        pData->matrix = *pMat;
    }
}
//---------------------------------------------------------------------
// ProcessPrimitive processes indexed and non-indexed primitives
// as defined by "op"
// It is assumed that only untransformed vertices are passed to this function
//
// op = __PROCPRIMOP_NONINDEXEDPRIM by default
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::ProcessPrimitive"

HRESULT CDirect3DDeviceTL::ProcessPrimitive(__PROCPRIMOP op)
{
    HRESULT ret;

#if DBG
    // Do some validation
    if (!FVF_TRANSFORMED(this->dwVIDIn))
    {
        if (this->rstates[D3DRENDERSTATE_VERTEXBLEND])
        {
            if(this->rstates[D3DRENDERSTATE_VERTEXBLEND] + 1 > this->d3dDevDesc.wMaxVertexBlendMatrices)
            {
                D3D_WARN(1, "Device does not support that many blend weights");
            }
        }
    }
#endif

    this->dwVIDOut = this->dwVIDIn;
    if (this->dwDeviceFlags & D3DDEV_STRIDE)
    {
        DWORD dwTexCoordSizeDummy[8];
        DWORD dwFVF = this->dwVIDIn;
        DWORD dwPositionSize = GetPositionSizeFVF(dwFVF);
        DWORD dwVertexSize = GetVertexSizeFVF(dwFVF) +
                            ComputeTextureCoordSize(dwFVF, dwTexCoordSizeDummy);
        this->dwOutputSize = dwVertexSize;
        this->dwVertexPoolSize = this->dwNumVertices * dwVertexSize;
        if (this->TLVbuf_Grow(this->dwVertexPoolSize, true) != D3D_OK)
        {
            D3D_ERR( "Could not grow TL vertex buffer" );
            return DDERR_OUTOFMEMORY;
        }
        ret = this->StartPrimVB(this->TLVbuf_GetVBI(), 0);
        if (ret != D3D_OK)
            return ret;
        D3DVALUE *p = (D3DVALUE*)this->TLVbuf_GetAddress();
        for (DWORD n = this->dwNumVertices; n; n--)
        {
            // XYZ and wheights
            memcpy(p, this->position.lpvData, dwPositionSize);
            p = (D3DVALUE*)((BYTE*)p + dwPositionSize);
            this->position.lpvData = (char*)this->position.lpvData + this->position.dwStride;
            if (dwFVF & D3DFVF_NORMAL)
            {
                *p++ = ((D3DVALUE*)this->normal.lpvData)[0];
                *p++ = ((D3DVALUE*)this->normal.lpvData)[1];
                *p++ = ((D3DVALUE*)this->normal.lpvData)[2];
                this->normal.lpvData = (char*)this->normal.lpvData + this->normal.dwStride;
            }
            if (dwFVF & D3DFVF_RESERVED1)
            {
                *p++ = 0;
            }
            if (dwFVF & D3DFVF_DIFFUSE)
            {
                *p++ = *(D3DVALUE*)this->diffuse.lpvData;
                this->diffuse.lpvData = (char*)this->diffuse.lpvData + this->diffuse.dwStride;
            }
            if (dwFVF & D3DFVF_SPECULAR)
            {
                *p++ = *(D3DVALUE*)this->specular.lpvData;
                this->specular.lpvData = (char*)this->specular.lpvData + this->specular.dwStride;
            }
            for (DWORD i=0; i < this->nTexCoord; i++)
            {
                DWORD dwSize = dwTexCoordSizeDummy[i];
                memcpy(p, this->textures[i].lpvData, dwSize);
                this->textures[i].lpvData = (char*)this->textures[i].lpvData + this->textures[i].dwStride;
                p = (D3DVALUE*)((char*)p + dwSize);
            }
        }
    }
    else
    {
        // Pass vertices directly from the user memory
        this->dwOutputSize = this->position.dwStride;
        this->lpvOut = this->position.lpvData;
        this->dwVertexPoolSize = this->dwNumVertices * this->dwOutputSize;

        ret = this->StartPrimUserMem(this->position.lpvData);
        if (ret != D3D_OK)
            return ret;
    }

    if (op == __PROCPRIMOP_INDEXEDPRIM)
    {
        ret = this->DrawIndexPrim();
    }
    else
    { // Non indexed primitive
        ret = this->DrawPrim();
    }
    if (ret != D3D_OK)
        return ret;
    return this->EndPrim();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::UpdateDrvViewInfo"

void CDirect3DDeviceTL::UpdateDrvViewInfo(LPD3DVIEWPORT7 lpVwpData)
{
    // Update viewport size
    CDirect3DDeviceIDP2::UpdateDrvViewInfo(lpVwpData);

    // Update Z range
    LPD3DHAL_DP2ZRANGE pData;
    pData = (LPD3DHAL_DP2ZRANGE)GetHalBufferPointer(D3DDP2OP_ZRANGE, sizeof(*pData));
    pData->dvMinZ = lpVwpData->dvMinZ;
    pData->dvMaxZ = lpVwpData->dvMaxZ;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceTL::SetupFVFData"

HRESULT CDirect3DDeviceTL::SetupFVFData(DWORD *pdwInpVertexSize)
{
    this->dwFEFlags &= ~D3DFE_FVF_DIRTY;
    this->nTexCoord = FVF_TEXCOORD_NUMBER(this->dwVIDIn);
    DWORD dwSize = GetVertexSizeFVF(this->dwVIDIn);
    // Add size of texture coordinates
    DWORD dwTextureFormats = this->dwVIDIn >> 16;
    for (DWORD i=this->nTexCoord; i; i--)
    {
        dwSize += g_TextureSize[dwTextureFormats & 0x3];
        dwTextureFormats >>= 2;
    }
    if (pdwInpVertexSize)
        *pdwInpVertexSize = dwSize;

    // In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden
    // by vertex alpha
    this->lighting.alpha = (DWORD)this->lighting.materialAlpha;
    this->lighting.alphaSpecular = (DWORD)this->lighting.materialAlphaS;

    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\d3ditype.h ===
//----------------------------------------------------------------------------
//
// d3ditype.h
//
// Standard types and supporting declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DITYPE_H_
#define _D3DITYPE_H_

#ifndef FASTCALL
#ifdef _X86_
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif
#endif

#ifndef CDECL
#ifdef _X86_
#define CDECL __cdecl
#else
#define CDECL
#endif
#endif

// Sized types.
#ifndef _BASETSD_H_
typedef signed char             INT8, *PINT8;
typedef short int               INT16, *PINT16;
typedef int                     INT32, *PINT32;
typedef __int64                 INT64, *PINT64;
typedef unsigned char           UINT8, *PUINT8;
typedef unsigned short int      UINT16, *PUINT16;
typedef unsigned int            UINT32, *PUINT32;
typedef unsigned __int64        UINT64, *PUINT64;
#endif

// Basic float types.
typedef float                   FLOAT, *PFLOAT;
typedef double                  DOUBLE, *PDOUBLE;

typedef struct _D3DVECTORH
{
    D3DVALUE x;
    D3DVALUE y;
    D3DVALUE z;
    D3DVALUE w;
} D3DVECTORH, *LPD3DVECTORH;

#endif // #ifndef _D3DITYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\dditypes.hpp ===
/*
 * $Id: dditypes.h,v 1.28 1995/11/21 14:46:07 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef __DDITYPES_H__
#define __DDITYPES_H__

#include "d3di.hpp"


#endif /* dditypes.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\vertbuf.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:    vertbuf.cpp
 *  Content:    Direct3DVertexBuffer implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date    By    Reason
 *   ====    ==    ======
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "d3dfei.h"
#include "clipfunc.h"
#include "pvvid.h"

// The bit is set when a vertex buffer was the destination in a ProcessVerticesCall
// with clipping enabled. We cannot pass such a buffer to TL HAL, because some vertices
// could be in the screen space and some in the clipping space. There is no DDI to pass
// clip codes together with a vertex buffer
const DWORD D3DPV_CLIPCODESGENERATED = D3DPV_RESERVED2;

const DWORD D3DVOP_RENDER = 1 << 31;
const DWORD D3DVBCAPS_VALID = D3DVBCAPS_SYSTEMMEMORY |
                              D3DVBCAPS_WRITEONLY |
                              D3DVBCAPS_OPTIMIZED |
                              D3DVBCAPS_DONOTCLIP;

void hookVertexBufferToD3D(LPDIRECT3DI lpDirect3DI,
                                 LPDIRECT3DVERTEXBUFFERI lpVBufI)
{

    LIST_INSERT_ROOT(&lpDirect3DI->vbufs, lpVBufI, list);
    lpVBufI->lpDirect3DI = lpDirect3DI;

    lpDirect3DI->numVBufs++;
}

/*
 * Direct3DVertexBuffer::QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::QueryInterface"

HRESULT D3DAPI CDirect3DVertexBuffer::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
#if DBG
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(ppvObj)) {
        D3D_ERR( "Invalid pointer to pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    *ppvObj = NULL;
    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IDirect3DVertexBuffer7))
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DVERTEXBUFFER7>(this));
        return(D3D_OK);
    }
    else
    {
        D3D_ERR( "Don't know this riid" );
        return (E_NOINTERFACE);
    }
} /* CDirect3DVertexBuffer::QueryInterface */

/*
 * Direct3DVertexBuffer::AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::AddRef"

ULONG D3DAPI CDirect3DVertexBuffer::AddRef()
{
    DWORD        rcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
#if DBG
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return 0;
    }
#endif
    this->refCnt++;
    rcnt = this->refCnt;

    return (rcnt);

} /* Direct3DVertexBuffer::AddRef */

/*
  * Direct3DVertexBuffer::Release
  *
*/
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::Release"

ULONG D3DAPI CDirect3DVertexBuffer::Release()
{
    DWORD            lastrefcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
#if DBG
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return 0;
    }
#endif
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;

    if( lastrefcnt == 0 )
    {
        delete this;
        return 0;
    }

    return lastrefcnt;

} /* D3DTex3_Release */
//---------------------------------------------------------------------
// Internal version.
// No D3D lock, no checks
//
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::CreateVertexBufferI"

HRESULT DIRECT3DI::CreateVertexBufferI(LPD3DVERTEXBUFFERDESC lpDesc,
                                       LPDIRECT3DVERTEXBUFFER7 *lplpVBuf,
                                       DWORD dwFlags)
{
    CDirect3DVertexBuffer*     lpVBufI;
    HRESULT ret = D3D_OK;

    *lplpVBuf = NULL;

    lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(new CDirect3DVertexBuffer(this));
    if (!lpVBufI) {
        D3D_ERR("failed to allocate space for vertex buffer");
        return (DDERR_OUTOFMEMORY);
    }

    if ((ret=lpVBufI->Init(this, lpDesc, dwFlags))!=D3D_OK)
    {
        D3D_ERR("Failed to initialize the vertex buffer object");
        delete lpVBufI;
        return ret;
    }
    *lplpVBuf = (LPDIRECT3DVERTEXBUFFER7)lpVBufI;

    return(D3D_OK);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::CreateVertexBuffer"

HRESULT D3DAPI DIRECT3DI::CreateVertexBuffer(
    LPD3DVERTEXBUFFERDESC lpDesc,
    LPDIRECT3DVERTEXBUFFER7* lplpVBuf,
    DWORD dwFlags)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
#if DBG
    /*
     * validate parms
     */
    if (!VALID_DIRECT3D_PTR(this))
    {
        D3D_ERR( "Invalid Direct3D pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(lplpVBuf))
    {
        D3D_ERR( "Invalid pointer to pointer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if ((lpDesc->dwCaps & D3DVBCAPS_VALID) != lpDesc->dwCaps)
    {
        D3D_ERR("Invalid caps");
        return DDERR_INVALIDCAPS;
    }
    if (dwFlags != 0)
    {
        D3D_ERR("Invalid dwFlags");
        return DDERR_INVALIDPARAMS;
    }
#endif
    return CreateVertexBufferI(lpDesc, lplpVBuf, dwFlags);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::constructor"

CDirect3DVertexBuffer::CDirect3DVertexBuffer(LPDIRECT3DI lpD3DI)
{
    refCnt = 1;
    /*
     * Put this vertex buffer in the list of those owned by the
     * Direct3D object
     */
    hookVertexBufferToD3D(lpD3DI, this);
    srcVOP = dstVOP = dwPVFlags = position.dwStride = dwLockCnt = 0;
    position.lpvData = NULL;
    clipCodes = NULL;
    lpDDSVB = NULL;
    dwCaps = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::destructor"

CDirect3DVertexBuffer::~CDirect3DVertexBuffer()
{
    /*
    * Remove ourselves from the Direct3D object
    */
    LIST_DELETE(this, list);
    this->lpDirect3DI->numVBufs--;
    delete [] clipCodes;
    if (lpDDSVB)
    {
        lpDDSVB->Release();
        lpDDS1VB->Release();
    }
}
//---------------------------------------------------------------------
//
// Create the vertex memory buffer through DirectDraw
//
// Notes:
//    this->dwMemType should be set before calling this function
//    this->dwCaps should be set too.
//    this->dwMemType is set to DDSCAPS_VIDEOMEMORY is the VB was driver allocated
//

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::CreateMemoryBuffer"
HRESULT CDirect3DVertexBuffer::CreateMemoryBuffer(
    LPDIRECT3DI lpD3DI,
    LPDIRECTDRAWSURFACE7 *lplpSurface7,
    LPDIRECTDRAWSURFACE  *lplpSurface,
    LPVOID *lplpMemory,
    DWORD dwBufferSize)
{
    HRESULT ret;
    DDSURFACEDESC2 ddsd;
    memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS | DDSD_FVF;
    ddsd.dwWidth = dwBufferSize;
    ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER;
    ddsd.ddsCaps.dwCaps2 = this->dwMemType;
    ddsd.dwFVF = this->fvf; // Let driver know about the FVF

    // The meaning of DDSCAPS_VIDEOMEMORY and DDSCAPS_SYSTEMEMORY are
    // slightly different in case of VBs. the former only means that
    // the buffer is driver allocated and could be in any memory type.
    // The latter means that the driver did not care to allocate VBs
    // hence they are always in DDraw allocated system memory.

    // The reason we try video memory followed by system memory
    // (rather than simply not specifying the memory type) is for
    // drivers which do not care to do any special VB allocations, we
    // do not want DDraw to take the Win16 lock for locking system memory
    // surfaces.

    bool bTLHAL = DDGBL(lpD3DI)->lpD3DGlobalDriverData &&
            (DDGBL(lpD3DI)->lpD3DGlobalDriverData->hwCaps.dwDevCaps &
             D3DDEVCAPS_HWTRANSFORMANDLIGHT);

    if ((this->dwCaps & D3DVBCAPS_SYSTEMMEMORY) || !(bTLHAL || FVF_TRANSFORMED(fvf)))
    {
        // This VB cannot reside in driver friendly memory since either:
        // 1. The app explicitly specified system memory
        // 2. The vertex buffer is untransformed and it is not a T&L hal
        //    thus the driver will never see this VB
        D3D_INFO(8, "Trying to create a sys mem vertex buffer");
        ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        ret = lpD3DI->lpDD7->CreateSurface(&ddsd, lplpSurface7, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Could not allocate the Vertex buffer.");
            return ret;
        }
    }
    else
    {
        // Try explicit video memory first
        ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        if ((this->dwCaps & D3DVBCAPS_DONOTCLIP) || bTLHAL)
            ddsd.ddsCaps.dwCaps |= this->dwCaps & DDSCAPS_WRITEONLY;
        D3D_INFO(8, "Trying to create a vid mem vertex buffer");
#ifdef __DISABLE_VIDMEM_VBS__
        if ((lpD3DI->bDisableVidMemVBs == TRUE) ||
            (lpD3DI->lpDD7->CreateSurface(&ddsd, lplpSurface7, NULL) != DD_OK))
#else  //__DISABLE_VIDMEM_VBS__
        if (lpD3DI->lpDD7->CreateSurface(&ddsd, lplpSurface7, NULL) != DD_OK)
#endif //__DISABLE_VIDMEM_VBS__
        {
            // If that failed, or user requested sys mem, try explicit system
            // memory
            D3D_INFO(6, "Trying to create a sys mem vertex buffer");
            ddsd.ddsCaps.dwCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_WRITEONLY);
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
            ret = lpD3DI->lpDD7->CreateSurface(&ddsd, lplpSurface7, NULL);
            if (ret != DD_OK)
            {
                D3D_ERR("Could not allocate the Vertex buffer.");
                return ret;
            }
        }
        else
        {
            this->dwMemType = DDSCAPS_VIDEOMEMORY;
            // Stick in our pointer so that we can be notified about mode changes
            DDSLCL(*lplpSurface7)->lpSurfMore->lpVB = static_cast<LPVOID>(this);
        }
    }
    ret = (*lplpSurface7)->QueryInterface(IID_IDirectDrawSurfaceNew, (LPVOID*)lplpSurface);
    if (ret != DD_OK)
    {
        D3D_ERR("failed to QI for DDS1");
        return ret;
    }
    ret = (*lplpSurface7)->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
    if (ret != DD_OK)
    {
        D3D_ERR("Could not lock vertex buffer.");
        return ret;
    }
    *lplpMemory = ddsd.lpSurface;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::init"

HRESULT CDirect3DVertexBuffer::Init(LPDIRECT3DI lpD3DI, LPD3DVERTEXBUFFERDESC lpDesc, DWORD dwFlags)
{
    HRESULT ret;

    bReallyOptimized = FALSE;
    dwCaps = lpDesc->dwCaps;
    fvf = lpDesc->dwFVF;
    dwNumVertices = lpDesc->dwNumVertices;
#ifdef VTABLE_HACK
    // Copy with vtable
    lpVtbl = *((LPVOID**)this);
    memcpy(newVtbl, lpVtbl, sizeof(PVOID)*D3DVB_NUM_VIRTUAL_FUNCTIONS);
    // Point to the new one
    *((LPVOID*)this) = (LPVOID)newVtbl;
#endif // VTABLE_HACK
    if (dwNumVertices > MAX_DX6_VERTICES)
    {
        D3D_ERR("Direct3D for DirectX 6.0 cannot handle greater than 64K vertices");
        return D3DERR_TOOMANYVERTICES;
    }
    if (lpDesc->dwCaps & D3DVBCAPS_OPTIMIZED)
    {
        D3D_ERR("D3DVBCAPS_OPTIMIZED flag should not be set");
        return DDERR_INVALIDPARAMS;
    }

    this->nTexCoord = FVF_TEXCOORD_NUMBER(fvf);
    this->dwTexCoordSizeTotal = ComputeTextureCoordSize(this->fvf, this->dwTexCoordSize);
    position.dwStride = GetVertexSizeFVF(this->fvf) + this->dwTexCoordSizeTotal;
    if (position.dwStride == 0)
    {
        D3D_ERR("Vertex size is zero according to the FVF id");
        return D3DERR_INVALIDVERTEXFORMAT;
    }

    if (dwFlags & D3DVBFLAGS_CREATEMULTIBUFFER)
        dwMemType = 0;
    else
        dwMemType = DDSCAPS2_VERTEXBUFFER;
#ifdef DBG
    // Allocate space for one more vertex and fill with deadbeef. Used to check for
    // overwrites during unlock
    ret = CreateMemoryBuffer(lpD3DI, &lpDDSVB, &lpDDS1VB, &position.lpvData,
                             position.dwStride * (dwNumVertices + 1));
    if (ret != D3D_OK)
        return ret;
    LPDWORD pPad = (LPDWORD)((LPBYTE)(position.lpvData) + position.dwStride * dwNumVertices);
    for (unsigned i = 0; i < position.dwStride / sizeof(DWORD); ++i)
        *pPad++ = 0xdeadbeef;
#else
    ret = CreateMemoryBuffer(lpD3DI, &lpDDSVB, &lpDDS1VB, &position.lpvData,
                             position.dwStride * dwNumVertices);
    if (ret != D3D_OK)
        return ret;
#endif

    /* Classify the operations that can be done using this VB */
    if ((fvf & D3DFVF_POSITION_MASK))
    {
        if ((fvf & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW)
        {
            D3D_INFO(4, "D3DFVF_XYZ set. Can be source VB for Transform");
            srcVOP = D3DVOP_TRANSFORM | D3DVOP_EXTENTS | D3DVOP_CLIP;
        }
        else
        {
            D3D_INFO(4, "D3DFVF_XYZRHW set. Can be dest VB for Transform");
            dstVOP = D3DVOP_TRANSFORM | D3DVOP_EXTENTS;
            srcVOP = D3DVOP_EXTENTS;
            if ((dwCaps & D3DVBCAPS_DONOTCLIP) == 0)
            {
                clipCodes = new D3DFE_CLIPCODE[dwNumVertices];
                if (clipCodes == NULL)
                {
                    D3D_ERR("Could not allocate space for clip flags");
                    return DDERR_OUTOFMEMORY;
                }
                memset(clipCodes, 0, dwNumVertices * sizeof(D3DFE_CLIPCODE));
                dstVOP |= D3DVOP_CLIP;
            }
        }
    }
    if (srcVOP & D3DVOP_TRANSFORM)
    {
        D3D_INFO(4, "Can be src VB for lighting.");
        srcVOP |= D3DVOP_LIGHT;
    }
    if (fvf & D3DFVF_DIFFUSE)
    {
        D3D_INFO(4, "D3DFVF_DIFFUSE set. Can be dest VB for lighting");
        dstVOP |= D3DVOP_LIGHT;
    }
    if (dstVOP & D3DVOP_TRANSFORM)
    {
        D3D_INFO(4, "VB can be rendered");
        srcVOP |= D3DVOP_RENDER;
    }

    return(D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::Lock"

HRESULT D3DAPI CDirect3DVertexBuffer::Lock(DWORD dwFlags, LPVOID* lplpData, DWORD* lpdwSize)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    HRESULT ret;
#if DBG
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (IsBadWritePtr( lplpData, sizeof(LPVOID)))
    {
        D3D_ERR( "Invalid lpData pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (lpdwSize)
    {
        if (IsBadWritePtr( lpdwSize, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid lpData pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
#endif
    if (this->dwCaps & D3DVBCAPS_OPTIMIZED)
    {
        D3D_ERR("Cannot lock optimized vertex buffer");
        return(D3DERR_VERTEXBUFFEROPTIMIZED);
    }
    if (!this->position.lpvData)
    {
        // Unlock if previous lock was broken due to mode switch
        if (DDSGBL(lpDDSVB)->dwUsageCount > 0)
        {
            DDASSERT(DDSGBL(lpDDSVB)->dwUsageCount == 1);
            D3D_INFO(2, "Lock: Unlocking broken VB lock");
            lpDDSVB->Unlock(NULL);
        }
        if (lpDevIBatched)
        {
            ret = lpDevIBatched->FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Could not flush batch referring to VB during Lock");
                return ret;
            }
        }
#ifdef DBG
        LPVOID pOldBuf = (LPVOID)((LPDDRAWI_DDRAWSURFACE_INT)lpDDSVB)->lpLcl->lpGbl->fpVidMem;
#endif // DBG
        // Do a real Lock
        DDSURFACEDESC2 ddsd;
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        ret = lpDDSVB->Lock(NULL, &ddsd, dwFlags | DDLOCK_NOSYSLOCK, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Lock: Could not lock Vertex Buffer: %08x", ret);
            return ret;
        }
        position.lpvData = ddsd.lpSurface;
#if DBG
        if(ddsd.lpSurface != pOldBuf)
        {
            D3D_INFO(2, "Driver swapped VB pointer in Lock");
        }
        LPDWORD pPad = (LPDWORD)((LPBYTE)(position.lpvData) + position.dwStride * dwNumVertices);
        for (unsigned i = 0; i < position.dwStride / sizeof(DWORD); ++i)
            *pPad++ = 0xdeadbeef;
#endif
    }
#ifdef VTABLE_HACK
    /* Single threaded or Multi threaded app ? */
    if (!(((LPDDRAWI_DIRECTDRAW_INT)lpDirect3DI->lpDD)->lpLcl->dwLocalFlags & DDRAWILCL_MULTITHREADED))
        VtblLockFast();
#endif // VTABLE_HACK
    return this->LockI(dwFlags, lplpData, lpdwSize);
}

//---------------------------------------------------------------------
// Side effect:
//      position.lpvData is set.
//
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::LockI"

HRESULT D3DAPI CDirect3DVertexBuffer::LockI(DWORD dwFlags, LPVOID* lplpData,
                                            DWORD* lpdwSize)
{
    dwLockCnt++;
    D3D_INFO(6, "VB Lock: %lx Lock Cnt =%d", this, dwLockCnt);
    if (!(dwFlags & (DDLOCK_READONLY | DDLOCK_NOOVERWRITE)) && lpDevIBatched)
    {
        HRESULT ret;
        if (dwFlags & DDLOCK_OKTOSWAP)
        {
            ret = lpDevIBatched->FlushStatesReq(position.dwStride * dwNumVertices);
#if DBG
            if (!(this->dwCaps & D3DVBCAPS_OPTIMIZED))
            {
                // Make sure the size of the new buffer is the same
                DDASSERT(position.dwStride * (dwNumVertices + 1) <= DDSGBL(lpDDSVB)->dwLinearSize);
                // Write deadbeaf in the pad area
                LPDWORD pPad = (LPDWORD)((LPBYTE)(position.lpvData) + position.dwStride * dwNumVertices);
                for (unsigned i = 0; i < position.dwStride / sizeof(DWORD); ++i)
                    *pPad++ = 0xdeadbeef;
            }
#endif
        }
        else
            ret = lpDevIBatched->FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Could not flush batch referring to VB during Lock");
            return ret;
        }
    }
    *lplpData = position.lpvData;
    if (lpdwSize)
        *lpdwSize = position.dwStride * dwNumVertices;
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::Unlock"

HRESULT D3DAPI CDirect3DVertexBuffer::Unlock()
{
    if (dwLockCnt)
    {
        dwLockCnt--;
    }
#ifdef DBG
    if (!(this->dwCaps & D3DVBCAPS_OPTIMIZED))
    {
        // Check for VB overruns
        LPDWORD pPad = (LPDWORD)((LPBYTE)(position.lpvData) + position.dwStride * dwNumVertices);
        for (unsigned i = 0; i < position.dwStride / sizeof(DWORD); ++i)
            if (*pPad++ != 0xdeadbeef)
            {
                D3D_ERR("Vertex buffer was overrun. Make sure that you do not write past the VB size!");
                return D3DERR_VERTEXBUFFERUNLOCKFAILED;
            }
        D3D_INFO(6, "VB Unlock: %lx Lock Cnt =%d", this, dwLockCnt);
    }
#endif
    return D3D_OK;
}

// Called from FlushStates to undo cached VB pointer so that the next lock causes a driver lock
// This is necessary if the we did not flush with SWAPVERTEXBUFFER.
void CDirect3DVertexBuffer::UnlockI()
{
    if ((this->dwMemType == DDSCAPS_VIDEOMEMORY) && (dwLockCnt == 0))
    {
#ifdef VTABLE_HACK
        VtblLockDefault();
#endif
        lpDDSVB->Unlock(NULL);
        position.lpvData = 0;
    }
    else if (dwLockCnt !=0 )
    {
        D3D_WARN(4, "App has a lock on VB %08x so driver call may be slow", this);
    }
}

#ifndef WIN95
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::LockWorkAround"

HRESULT CDirect3DVertexBuffer::LockWorkAround(CDirect3DDeviceIDP2 *pDev)
{
    if (this->dwMemType == DDSCAPS_VIDEOMEMORY)
    {
#ifdef DBG
        LPVOID pOldBuf = (LPVOID)((LPDDRAWI_DDRAWSURFACE_INT)lpDDSVB)->lpLcl->lpGbl->fpVidMem;
#endif // DBG
        // Do a real Lock
        DDSURFACEDESC2 ddsd;
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        HRESULT ret = lpDDSVB->Lock(NULL, &ddsd, DDLOCK_OKTOSWAP | DDLOCK_NOSYSLOCK, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Lock: Could not lock Vertex Buffer: %08x", ret);
            return ret;
        }
        position.lpvData = ddsd.lpSurface;
        pDev->alignedBuf = ddsd.lpSurface;
#ifdef DBG
        if(ddsd.lpSurface != pOldBuf)
        {
            D3D_INFO(2, "Driver swapped TLVBuf pointer in Lock");
        }
#endif
        // Make sure the size of the new buffer is the same
        DDASSERT(position.dwStride * (dwNumVertices + 1) <= DDSGBL(lpDDSVB)->dwLinearSize);
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::UnlockWorkAround"

void CDirect3DVertexBuffer::UnlockWorkAround()
{
    if ((this->dwMemType == DDSCAPS_VIDEOMEMORY) &&
        (position.lpvData != 0))
    {
        lpDDSVB->Unlock(NULL);
        position.lpvData = 0;
    }
}

#endif // WIN95

// Cause us to go thru the slow path and force a lock
// The slow path will do the unlock if necessary. This
// is because we are called from DDraw's invalidate
// surface code and it might not be the best time to
// call back ddraw to unlock the surface.
void CDirect3DVertexBuffer::BreakLock()
{
    D3D_INFO(6, "Notified of restore on VB %08x", this);
#ifdef VTABLE_HACK
    VtblLockDefault();
#endif
    position.lpvData = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::GetVertexBufferDesc"

HRESULT D3DAPI CDirect3DVertexBuffer::GetVertexBufferDesc(LPD3DVERTEXBUFFERDESC lpDesc)
{
#if DBG
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (IsBadWritePtr( lpDesc, lpDesc->dwSize))
    {
        D3D_ERR( "Invalid lpData pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (! VALID_D3DVERTEXBUFFERDESC_PTR(lpDesc) )
    {
        D3D_ERR( "Invalid D3DVERTEXBUFFERDESC" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    lpDesc->dwCaps = dwCaps;
    lpDesc->dwFVF = fvf;
    lpDesc->dwNumVertices = this->dwNumVertices;
    return D3D_OK;
}
//---------------------------------------------------------------------
// Common validation for ProcessVertices and ProcessVerticesStrided
//
HRESULT CDirect3DVertexBuffer::ValidateProcessVertices(
                    DWORD vertexOP,
                    DWORD dwDstIndex,
                    DWORD dwCount,
                    LPVOID lpSrc,
                    LPDIRECT3DDEVICE7 lpDevice,
                    DWORD dwFlags)
{
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this))
    {
        D3D_ERR( "Invalid destination Direct3DVertexBuffer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (!VALID_DIRECT3DDEVICE_PTR(lpDevice))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
    if (lpDevI->ValidateFVF(this->fvf) != D3D_OK)
    {
        D3D_ERR("Invalid vertex buffer FVF for the device");
        return DDERR_INVALIDPARAMS;
    }
    if (dwFlags & ~D3DPV_DONOTCOPYDATA)
    {
        D3D_ERR( "Invalid dwFlags set" );
        return DDERR_INVALIDPARAMS;
    }
    if ((dwDstIndex + dwCount) > this->dwNumVertices)
    {
        D3D_ERR( "Vertex count plus destination index is greater than number of vertices" );
        return DDERR_INVALIDPARAMS;
    }
    // Validate Dst Vertex Formats
    if (lpSrc)
    {
        if ((this->dstVOP & vertexOP) != vertexOP)
            goto error;
    }
    else
    {
        if ((this->fvf & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
        {
            if (vertexOP & ~(D3DVOP_CLIP | D3DVOP_EXTENTS))
                goto error;
        }
        else
        {
            if (vertexOP & ~(D3DVOP_CLIP))
                goto error;
        }
    }
    return D3D_OK;
error:
    D3D_ERR("Destination VB cannot support this operation");
    return D3DERR_INVALIDVERTEXFORMAT;
}
//---------------------------------------------------------------------
// Common part for ProcessVertices and ProcessVerticesStrided
//
HRESULT CDirect3DVertexBuffer::DoProcessVertices(
                            LPDIRECT3DVERTEXBUFFERI lpSrcI,
                            LPDIRECT3DDEVICEI lpDevI,
                            DWORD vertexOP,
                            DWORD dwSrcIndex,
                            DWORD dwDstIndex,
                            DWORD dwFlags)
{
    lpDevI->lpClipFlags = clipCodes + dwDstIndex;
    // Compute needed output FVF
    {
        DWORD dwInputVertexSize;
        HRESULT ret = lpDevI->SetupFVFDataCommon(&dwInputVertexSize);
        if (ret != D3D_OK)
            return ret;
        // Make sure we have specular in output VB if the current state settings
        // require us to write to specular
        if (vertexOP & D3DVOP_LIGHT)
            if (lpDevI->rstates[D3DRENDERSTATE_SPECULARENABLE] || lpDevI->rstates[D3DRENDERSTATE_FOGENABLE])
                if (!(fvf & D3DFVF_SPECULAR))
                {
                    D3D_ERR("Destination VB FVF format cannot be used with the current D3D settings");
                    return D3DERR_INVALIDVERTEXFORMAT;
                }
        // Check number of texture coordinates and texture formats in the
        // destination VB are the same as in the computed FVF
        DWORD dwComputedOutFVF = lpDevI->dwVIDOut & 0xFFFF0000;
        if (lpDevI->nOutTexCoord > this->nTexCoord ||
            ((fvf & dwComputedOutFVF) != dwComputedOutFVF))
        {
            D3D_ERR("Destination VB FVF format cannot be used with the current D3D settings");
            return D3DERR_INVALIDVERTEXFORMAT;
        }
    }
    // Output
    lpDevI->lpvOut = LPVOID(LPBYTE(position.lpvData) + dwDstIndex * position.dwStride);
    lpDevI->dwOutputSize = this->position.dwStride;
    lpDevI->dwVIDOut = fvf;

    // Set up vertex pointers, because SetupFVFData works with "computed" FVF
    UpdateGeometryLoopData(lpDevI);

    // Save current flags to restore later
    DWORD dwOrigDeviceFlags = lpDevI->dwDeviceFlags;
    if (vertexOP & D3DVOP_CLIP)
    {
        lpDevI->dwDeviceFlags &= ~D3DDEV_DONOTCLIP;
        this->dwPVFlags |= D3DPV_CLIPCODESGENERATED;
    }
    else
    {
        lpDevI->dwDeviceFlags |= D3DDEV_DONOTCLIP;
    }

    if (vertexOP & D3DVOP_LIGHT)
        lpDevI->dwDeviceFlags |= D3DDEV_LIGHTING;
    else
        lpDevI->dwDeviceFlags &= ~D3DDEV_LIGHTING;

    if (vertexOP & D3DVOP_EXTENTS)
    {
        lpDevI->dwDeviceFlags &= ~D3DDEV_DONOTUPDATEEXTENTS;
    }
    else
    {
        lpDevI->dwDeviceFlags |= D3DDEV_DONOTUPDATEEXTENTS;
    }

    DoUpdateState(lpDevI);

    if (lpSrcI)
    {
        if (lpSrcI->bReallyOptimized)
        { // SOA
          // Assume that SOA.lpvData is the same as position.lpvData
            lpDevI->SOA.lpvData = lpSrcI->position.lpvData;
            lpDevI->SOA.dwStride = lpSrcI->dwNumVertices;
            lpDevI->dwSOAStartVertex = dwSrcIndex;
            lpDevI->dwOutputSize = position.dwStride;
        }
        else
        { // AOS FVF
            lpDevI->dwOutputSize = position.dwStride;
            lpDevI->position.lpvData = LPVOID(LPBYTE(lpSrcI->position.lpvData) + dwSrcIndex * lpSrcI->position.dwStride);
            lpDevI->position.dwStride = lpSrcI->position.dwStride;
        }
    }

    if (dwFlags & D3DPV_DONOTCOPYDATA)
    {
        lpDevI->dwFlags |= D3DPV_DONOTCOPYDIFFUSE | D3DPV_DONOTCOPYSPECULAR |
                           D3DPV_DONOTCOPYTEXTURE;
        // If D3DIM generates colors or texture, we should clear DONOTCOPY bits
        if (lpDevI->dwFlags & D3DPV_LIGHTING)
        {
            lpDevI->dwFlags &= ~D3DPV_DONOTCOPYDIFFUSE;
            if (lpDevI->dwDeviceFlags & D3DDEV_SPECULARENABLE)
                lpDevI->dwFlags &= ~D3DPV_DONOTCOPYSPECULAR;
        }
        if (lpDevI->dwFlags & D3DPV_FOG)
            lpDevI->dwFlags &= ~D3DPV_DONOTCOPYSPECULAR;
        // If front-end is asked to do something with texture coordinates
        // we disable DONOTCOPYTEXTURE
        if (__TEXTURETRANSFORMENABLED(lpDevI) || lpDevI->dwFlags2 & __FLAGS2_TEXGEN)
        {
            lpDevI->dwFlags &= ~D3DPV_DONOTCOPYTEXTURE;
        }
    }

    lpDevI->pGeometryFuncs->ProcessVertices(lpDevI);

    // This bit should be cleared, because for ProcessVertices calls user should
    // set texture stage indices and wrap modes himself
    lpDevI->dwDeviceFlags &= ~D3DDEV_REMAPTEXTUREINDICES;

    if (!(lpDevI->dwDeviceFlags & D3DDEV_DONOTCLIP))
        D3DFE_UpdateClipStatus(lpDevI);
    // Restore _DONOTCLIP & _DONOTUPDATEEXTENTS flags
    const DWORD PRESERVED_FLAGS = D3DDEV_DONOTCLIP |
                                  D3DDEV_DONOTUPDATEEXTENTS |
                                  D3DDEV_LIGHTING;
    lpDevI->dwDeviceFlags = (dwOrigDeviceFlags & PRESERVED_FLAGS) |
                            (lpDevI->dwDeviceFlags & ~PRESERVED_FLAGS);

    // Force recompute fvf next time around
    lpDevI->ForceFVFRecompute();

    // Unlock the VB
    Unlock();

    // If we used SOA then the dwVIDIn <-> position.dwStride relationship
    // violated. This fixes that. This is required since in non VB code
    // we will not recompute position.dwStride if FVF matched dwVIDIn.
    if (lpSrcI)
        lpDevI->position.dwStride = lpSrcI->position.dwStride;

    return D3D_OK;
}
//---------------------------------------------------------------------
// lpSrc should be NULL for XYZRHW buffers
//
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::ProcessVertices"

HRESULT D3DAPI CDirect3DVertexBuffer::ProcessVertices(DWORD vertexOP, DWORD dwDstIndex, DWORD dwCount,
                                                      LPDIRECT3DVERTEXBUFFER7 lpSrc,
                                                      DWORD dwSrcIndex,
                                                      LPDIRECT3DDEVICE7 lpDevice, DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpSrcI;
    LPDIRECT3DDEVICEI lpDevI;
    HRESULT ret = D3D_OK;

#if DBG
    ret = this->ValidateProcessVertices(vertexOP, dwDstIndex, dwCount, lpSrc, lpDevice, dwFlags);
    if (ret != D3D_OK)
        return ret;
    lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
    if (lpSrc != NULL)
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(lpSrc))
        {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        lpSrcI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpSrc);
        if (lpDevI->ValidateFVF(lpSrcI->fvf) != D3D_OK)
        {
            D3D_ERR("Invalid source vertex buffer FVF for the device");
            return DDERR_INVALIDPARAMS;
        }
        // Validate Src Vertex Formats
        if ((lpSrcI->srcVOP & vertexOP) != vertexOP)
        {
            D3D_ERR("Source VB cannot support this operation");
            return D3DERR_INVALIDVERTEXFORMAT;
        }
        if ((dwSrcIndex + dwCount) > lpSrcI->dwNumVertices)
        {
            D3D_ERR( "Source index plus vertex count is greater than number of vertices" );
            return DDERR_INVALIDPARAMS;
        }
        if (!(vertexOP & D3DVOP_TRANSFORM))
        {
            D3D_ERR("D3DVOP_TRANSFORM flag should be set");
            return DDERR_INVALIDPARAMS;
        }
        // Source to ProcessVertices must be in system memory. This is for reasons similar
        // to why we insist on sys mem VB for SW rast. For instance, a driver may have optimized
        // the VB into some cryptic format which D3D FE will have no clue to decipher.
        if (!(lpSrcI->dwCaps & D3DVBCAPS_SYSTEMMEMORY))
        {
            D3D_ERR("Source VB must be created with D3DVBCAPS_SYSTEMMEMORY");
            return DDERR_INVALIDPARAMS;
        }
    }
#else
    lpSrcI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpSrc);
    lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
#endif

    CLockD3DMT lockObject(lpDevI, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    lpDevI->dwNumVertices = dwCount;

    // Lock the VBs
    LPVOID lpVoid;
    // We call the API level lock since dest VB may be in vid mem. This function will fail for
    // optimized VBs and that is OK since we cannot write out optimized vertices anyway.
    ret = Lock(DDLOCK_WAIT, &lpVoid, NULL);
    if (ret != D3D_OK)
    {
        D3D_ERR("Could not lock the vertex buffer");
        return ret;
    }

    if (lpSrc == NULL)
    {
        lpDevI->lpvOut = LPVOID(LPBYTE(position.lpvData) + dwDstIndex * position.dwStride);
        if ((fvf & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW)
        {
            if (vertexOP & D3DVOP_CLIP)
            {
                CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.
                if (lpDevI->dwFEFlags & (D3DFE_TRANSFORM_DIRTY | D3DFE_CLIPPLANES_DIRTY))
                {
                    DoUpdateState(lpDevI);
                }
                lpDevI->CheckClipStatus((D3DVALUE*)lpDevI->lpvOut,
                                         position.dwStride,
                                         dwCount,
                                         &lpDevI->dwClipUnion,
                                         &lpDevI->dwClipIntersection);
                D3DFE_UpdateClipStatus(lpDevI);
            }
        }
        else
        {
            // For transformed vertices we support only clip code generation and extens
            lpDevI->lpClipFlags = clipCodes + dwDstIndex;
            lpDevI->position.lpvData = lpDevI->lpvOut;
            lpDevI->position.dwStride = position.dwStride;
            lpDevI->dwOutputSize = position.dwStride;
            if (vertexOP & D3DVOP_CLIP)
            {
                D3DFE_GenClipFlags(lpDevI);
                D3DFE_UpdateClipStatus(lpDevI);
                // Mark this buffer as "transformed" for clipping
                dwPVFlags |= D3DPV_TLVCLIP;
            }
            if (vertexOP & D3DVOP_EXTENTS)
            {
                D3DFE_updateExtents(lpDevI);
            }
        }
        Unlock();
        return D3D_OK;
    }
    // Safe to LockI since source is guaranteed to be in system memory
    // Cannot call API Lock since we need to be able to lock optimized VBs
    ret = lpSrcI->LockI(DDLOCK_WAIT | DDLOCK_READONLY, &lpVoid, NULL);
    if (ret != D3D_OK)
    {
        D3D_ERR("Could not lock the vertex buffer");
        return ret;
    }

    dwPVFlags &= ~D3DPV_TLVCLIP;    // Mark the dest VB as "not transformed" for clipping
    lpDevI->dwFlags = (lpSrcI->dwPVFlags & D3DPV_SOA) | D3DPV_VBCALL;
    lpDevI->dwDeviceFlags &= ~D3DDEV_STRIDE;

    // Input
    lpDevI->dwVIDIn = lpSrcI->fvf;

    ret = this->DoProcessVertices(lpSrcI, lpDevI, vertexOP, dwSrcIndex, dwDstIndex, dwFlags);
    if (ret != D3D_OK)
        lpSrcI->Unlock();
    else
        ret = lpSrc->Unlock();
    return ret;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::ProcessVerticesStrided"

HRESULT D3DAPI CDirect3DVertexBuffer::ProcessVerticesStrided(DWORD vertexOP, DWORD dwDstIndex, DWORD dwCount,
                                                      LPD3DDRAWPRIMITIVESTRIDEDDATA lpDrawData,
                                                      DWORD dwSrcFVF,
                                                      LPDIRECT3DDEVICE7 lpDevice, DWORD dwFlags)
{
    LPDIRECT3DDEVICEI lpDevI;
    HRESULT ret = D3D_OK;

#if DBG
    ret = this->ValidateProcessVertices(vertexOP, dwDstIndex, dwCount, lpDrawData, lpDevice, dwFlags);
    if (ret != D3D_OK)
        return ret;
    lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
    if (lpDevI->ValidateFVF(dwSrcFVF) != D3D_OK)
    {
        D3D_ERR("Invalid source FVF for the device");
        return DDERR_INVALIDPARAMS;
    }
    if ((dwSrcFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
    {
        D3D_ERR("ProcessVerticesStrided cannot handle transformed vertices");
        return D3DERR_INVALIDVERTEXTYPE;
    }
    if (!(vertexOP & D3DVOP_TRANSFORM))
    {
        D3D_ERR("D3DVOP_TRANSFORM flag should be set");
        return DDERR_INVALIDPARAMS;
    }
#else
    lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
#endif

    CLockD3DMT lockObject(lpDevI, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    // Lock the VBs
    LPVOID lpVoid;
    // We call the API level lock since dest VB may be in vid mem. This function will fail for
    // optimized VBs and that is OK since we cannot write out optimized vertices anyway.
    ret = Lock(DDLOCK_WAIT, &lpVoid, NULL);
    if (ret != D3D_OK)
    {
        D3D_ERR("Could not lock the vertex buffer");
        return ret;
    }

    dwPVFlags &= ~D3DPV_TLVCLIP;    // Mark the dest VB as "not transformed" for clipping
    lpDevI->dwDeviceFlags |= D3DDEV_STRIDE;
    lpDevI->dwFlags = D3DPV_VBCALL;

    // Input
    lpDevI->dwNumVertices = dwCount;
    lpDevI->dwVIDIn = dwSrcFVF;
    lpDevI->position = lpDrawData->position;
    lpDevI->normal = lpDrawData->normal;
    lpDevI->diffuse = lpDrawData->diffuse;
    lpDevI->specular = lpDrawData->specular;
    for (DWORD i=0; i < this->nTexCoord; i++)
        lpDevI->textures[i] = lpDrawData->textureCoords[i];

    return this->DoProcessVertices(NULL, lpDevI, vertexOP, 0, dwDstIndex, dwFlags);
}
//---------------------------------------------------------------------
#ifdef DBG
HRESULT DIRECT3DDEVICEI::CheckDrawPrimitiveVB(LPDIRECT3DVERTEXBUFFER7 lpVBuf, DWORD dwStartVertex, DWORD dwNumVertices, DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI;
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(lpVBuf))
    {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (this->ValidateFVF(lpVBufI->fvf) != D3D_OK)
    {
        D3D_ERR("Invalid vertex buffer FVF for the device");
        return DDERR_INVALIDPARAMS;
    }
    if (!IsDPFlagsValid(dwFlags))
    {
        D3D_ERR("Invalid Flags in dwFlags field");
        return DDERR_INVALIDPARAMS;
    }
    if (!(dwDeviceFlags & D3DDEV_DONOTCLIP) && (lpVBufI->clipCodes == NULL) && (lpVBufI->srcVOP & D3DVOP_RENDER))
    {
        D3D_ERR("Vertex buffer does not support clipping");
        return DDERR_INVALIDPARAMS;
    }
    if (!(IS_HW_DEVICE(this) || (lpVBufI->dwCaps & D3DVBCAPS_SYSTEMMEMORY)))
    {
        D3D_ERR("Cannot use vid mem vertex buffers with SW devices");
        return DDERR_INVALIDPARAMS;
    }
    /* If we are on HAL with an untransformed vid mem VB then we disallow
       This will happen only on T&L HW. The reason we disallow this is that
       it'll be very slow so this is not an interesting thing to do anyway */
    if ( !IS_TLHAL_DEVICE(this) &&
         !(lpVBufI->dwCaps & D3DVBCAPS_SYSTEMMEMORY) &&
         !FVF_TRANSFORMED(lpVBufI->fvf) )
    {
        D3D_ERR("DrawPrimitiveVB: Untransformed VB for HAL device must be created with D3DVBCAPS_SYSTEMMEMORY");
        return DDERR_INVALIDPARAMS;
    }
    if (lpVBufI->dwLockCnt)
    {
        D3D_ERR("Cannot render using a locked vertex buffer");
        return D3DERR_VERTEXBUFFERLOCKED;
    }
    if (dwStartVertex + dwNumVertices > lpVBufI->dwNumVertices)
    {
        D3D_ERR("Vertex range is outside the vertex buffer");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}
#endif
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DrawIndexedPrimitiveVB"

HRESULT D3DAPI DIRECT3DDEVICEI::DrawIndexedPrimitiveVB(D3DPRIMITIVETYPE dptPrimitiveType,
                                                       LPDIRECT3DVERTEXBUFFER7 lpVBuf,
                                                       DWORD dwStartVertex, DWORD dwNumVertices,
                                                       LPWORD lpwIndices, DWORD dwIndexCount,
                                                       DWORD dwFlags)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    HRESULT ret;
    LPDIRECT3DVERTEXBUFFERI lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
#if DBG
    ret = CheckDrawPrimitiveVB(lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;
    Profile(PROF_DRAWINDEXEDPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#endif
    this->dwFlags = dwFlags | lpVBufI->dwPVFlags;
    this->primType = dptPrimitiveType;
    this->dwNumVertices = dwNumVertices;
    this->dwNumIndices = dwIndexCount;
    this->lpwIndices = lpwIndices;
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats
#if DBG
    if (dwNumPrimitives > MAX_DX6_PRIMCOUNT)
    {
        D3D_ERR("D3D for DX7 cannot handle greater that 64K sized primitives");
        return D3DERR_TOOMANYPRIMITIVES;
    }
#endif

    if (lpVBufI->srcVOP & D3DVOP_RENDER || IS_TLHAL_DEVICE(this))
    { // TLVERTEX or TLHAL

        this->dwOutputSize = lpVBufI->position.dwStride;
        this->position.dwStride = lpVBufI->position.dwStride;
        this->dwVIDOut = lpVBufI->fvf;
        DWORD dwOldVidIn = this->dwVIDIn;
        this->dwVIDIn = lpVBufI->fvf;
        BOOL bNoClipping = this->dwDeviceFlags & D3DDEV_DONOTCLIP ||
                           (!(lpVBufI->dwPVFlags & D3DPV_CLIPCODESGENERATED) && IS_TLHAL_DEVICE(this));
        if (IS_DP2HAL_DEVICE(this))
        {
            this->nTexCoord = lpVBufI->nTexCoord;
            CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
            ret = dev->StartPrimVB(lpVBufI, dwStartVertex);
             if (ret != D3D_OK)
                return ret;
            lpVBufI->lpDevIBatched = this;
#ifdef VTABLE_HACK
            if (bNoClipping && !IS_MT_DEVICE(this))
                VtblDrawIndexedPrimitiveVBTL();
#endif
            this->nOutTexCoord = lpVBufI->nTexCoord;
        }
        else
        {
            // needed for legacy drivers' DrawIndexPrim code
            this->lpvOut = (BYTE*)(lpVBufI->position.lpvData) +
                           dwStartVertex * this->dwOutputSize;
            ComputeTCI2CopyLegacy(this, lpVBufI->nTexCoord, lpVBufI->dwTexCoordSize, TRUE);
        }
        if (bNoClipping)
        {
            return DrawIndexPrim();
        }
        else
        {
            this->dwTextureCoordSizeTotal = lpVBufI->dwTexCoordSizeTotal;
            for (DWORD i=0; i < this->nOutTexCoord; i++)
            {
                this->dwTextureCoordSize[i] = lpVBufI->dwTexCoordSize[i];
            }
            this->lpClipFlags = lpVBufI->clipCodes + dwStartVertex;
            this->dwClipUnion = ~0; // Force clipping
            if (dwOldVidIn != lpVBufI->fvf)
            {
                ComputeOutputVertexOffsets(this);
            }
            // If lpvData is NULL, it is a driver allocated buffer which
            // means IS_DPHAL_DEVICE() is true.
            // We need to lock such a buffer only if we need to clip
            if (!lpVBufI->position.lpvData)
            {
                // Lock VB
                DDSURFACEDESC2 ddsd;
                memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
                ddsd.dwSize = sizeof(DDSURFACEDESC2);
                ret = lpVBufI->lpDDSVB->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_READONLY | DDLOCK_NOSYSLOCK, NULL);
                if (ret != DD_OK)
                {
                    D3D_ERR("Could not lock vertex buffer.");
                    return ret;
                }
                this->lpvOut = (BYTE*)(ddsd.lpSurface) +
                               dwStartVertex * this->dwOutputSize;

                // Draw with clipping
                this->position.lpvData = this->lpvOut;
#if DBG
                ret = CheckDrawIndexedPrimitive(this, dwStartVertex);
                if (ret == D3D_OK)
                    ret = DoDrawIndexedPrimitive(this);
#else
                ret = DoDrawIndexedPrimitive(this);
#endif
                // Unlock VB
                if (ret == D3D_OK)
                    return lpVBufI->lpDDSVB->Unlock(NULL);
                else
                    lpVBufI->lpDDSVB->Unlock(NULL);
                return ret;
            }
            else
            {
                // Draw with clipping
                this->lpvOut = (BYTE*)lpVBufI->position.lpvData + dwStartVertex * this->dwOutputSize;
                this->position.lpvData = this->lpvOut;
#if DBG
                ret = CheckDrawIndexedPrimitive(this, dwStartVertex);
                if (ret != D3D_OK)
                    return ret;
#endif
                return DoDrawIndexedPrimitive(this);
            }
        }
    }
    else
    {
        if (lpVBufI->bReallyOptimized)
        {
           // Assume that SOA.lpvData is the same as position.lpvData
            this->SOA.lpvData = lpVBufI->position.lpvData;
            this->SOA.dwStride = lpVBufI->dwNumVertices;
            this->dwSOAStartVertex = dwStartVertex;
        }
        else
        {
            this->position.lpvData = (BYTE*)(lpVBufI->position.lpvData) +
                                     dwStartVertex * lpVBufI->position.dwStride;
            this->position.dwStride = lpVBufI->position.dwStride;
#ifdef VTABLE_HACK
            if (IS_DP2HAL_DEVICE(this) && !IS_MT_DEVICE(this))
            {
                CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
                dev->lpDP2LastVBI = lpVBufI;
                dev->VtblDrawIndexedPrimitiveVBFE();
            }
#endif
        }
        if (this->dwVIDIn != lpVBufI->fvf || this->dwDeviceFlags & D3DDEV_STRIDE)
        {
            this->dwDeviceFlags &= ~D3DDEV_STRIDE;
            this->dwVIDIn = lpVBufI->fvf;
            ret = SetupFVFData(NULL);
            if (ret != D3D_OK)
                goto l_exit;
        }
#if DBG
        ret = CheckDrawIndexedPrimitive(this, dwStartVertex);
        if (ret != D3D_OK)
            goto l_exit;
#endif
        ret = this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
l_exit:
        // If we used SOA then the dwVIDIn <-> position.dwStride relationship
        // violated. This fixes that. This is required since in non VB code
        // we will not recompute position.dwStride if FVF matched dwVIDIn.
        this->position.dwStride = lpVBufI->position.dwStride;
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DrawPrimitiveVB"

HRESULT D3DAPI DIRECT3DDEVICEI::DrawPrimitiveVB(D3DPRIMITIVETYPE dptPrimitiveType,
                                                LPDIRECT3DVERTEXBUFFER7 lpVBuf,
                                                DWORD dwStartVertex, DWORD dwNumVertices,
                                                DWORD dwFlags)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock
    HRESULT ret;
    LPDIRECT3DVERTEXBUFFERI lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
#if DBG
    ret = CheckDrawPrimitiveVB(lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;
    Profile(PROF_DRAWPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#endif
    this->dwFlags = dwFlags | lpVBufI->dwPVFlags;
    this->primType = dptPrimitiveType;
    this->dwNumVertices = dwNumVertices;
    GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives and update stats
#if DBG
    if (dwNumPrimitives > MAX_DX6_PRIMCOUNT)
    {
        D3D_ERR("D3D for DX7 cannot handle greater that 64K sized primitives");
        return D3DERR_TOOMANYPRIMITIVES;
    }
#endif
    if (lpVBufI->srcVOP & D3DVOP_RENDER || IS_TLHAL_DEVICE(this))
    { // TLVERTEX or TLHAL
        this->position.dwStride = lpVBufI->position.dwStride;
        this->dwOutputSize = lpVBufI->position.dwStride;
        DWORD dwOldVidIn = this->dwVIDIn;
        this->dwVIDIn = lpVBufI->fvf;
        this->dwVIDOut = lpVBufI->fvf;
        BOOL bNoClipping = this->dwDeviceFlags & D3DDEV_DONOTCLIP ||
                           (!(lpVBufI->dwPVFlags & D3DPV_CLIPCODESGENERATED) && IS_TLHAL_DEVICE(this));
        if (IS_DP2HAL_DEVICE(this))
        {
            this->nTexCoord = lpVBufI->nTexCoord;
            CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
            ret = dev->StartPrimVB(lpVBufI, dwStartVertex);
            if (ret != D3D_OK)
                return ret;
            lpVBufI->lpDevIBatched = this;
#ifdef VTABLE_HACK
            if (bNoClipping && !IS_MT_DEVICE(this))
                VtblDrawPrimitiveVBTL();
#endif
            this->nOutTexCoord = lpVBufI->nTexCoord;
        }
        else
        {
            // needed for legacy drivers' DrawPrim code
            this->lpvOut = (BYTE*)(lpVBufI->position.lpvData) +
                           dwStartVertex * this->dwOutputSize;
            ComputeTCI2CopyLegacy(this, lpVBufI->nTexCoord, lpVBufI->dwTexCoordSize, TRUE);
        }
        if (bNoClipping)
        {
            return DrawPrim();
        }
        else
        {
            this->dwTextureCoordSizeTotal = lpVBufI->dwTexCoordSizeTotal;
            for (DWORD i=0; i < this->nOutTexCoord; i++)
            {
                this->dwTextureCoordSize[i] = lpVBufI->dwTexCoordSize[i];
            }
            this->lpClipFlags = lpVBufI->clipCodes + dwStartVertex;
            this->dwClipUnion = ~0; // Force clipping
            if (dwOldVidIn != lpVBufI->fvf)
            {
                ComputeOutputVertexOffsets(this);
            }
            // If lpvData is NULL, it is a driver allocated buffer which
            // means IS_DPHAL_DEVICE() is true.
            // We need to lock such a buffer only if we need to clip
            if (!lpVBufI->position.lpvData)
            {
                // Lock VB
                DDSURFACEDESC2 ddsd;
                memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
                ddsd.dwSize = sizeof(DDSURFACEDESC2);
                ret = lpVBufI->lpDDSVB->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_READONLY | DDLOCK_NOSYSLOCK, NULL);
                if (ret != DD_OK)
                {
                    D3D_ERR("Could not lock vertex buffer.");
                    return ret;
                }
                this->lpvOut = (BYTE*)(ddsd.lpSurface) +
                               dwStartVertex * this->dwOutputSize;

                // Draw with clipping
                this->position.lpvData = this->lpvOut;
#if DBG
                ret=CheckDrawPrimitive(this);
                if (ret == D3D_OK)
                    ret = DoDrawPrimitive(this);
#else
                ret = DoDrawPrimitive(this);
#endif
                // Unlock VB
                if (ret == D3D_OK)
                    return lpVBufI->lpDDSVB->Unlock(NULL);
                else
                    lpVBufI->lpDDSVB->Unlock(NULL);
                return ret;
            }
            else
            {
                // Draw with clipping
                this->lpvOut = (BYTE*)lpVBufI->position.lpvData + dwStartVertex * this->dwOutputSize;
                this->position.lpvData = this->lpvOut;
#if DBG
                ret=CheckDrawPrimitive(this);
                if (ret != D3D_OK)
                    return ret;
#endif
                return DoDrawPrimitive(this);
            }
        }
    }
    else
    {
        if (lpVBufI->bReallyOptimized)
        {
           // Assume that SOA.lpvData is the same as position.lpvData
            this->SOA.lpvData = lpVBufI->position.lpvData;
            this->SOA.dwStride = lpVBufI->dwNumVertices;
            this->dwSOAStartVertex = dwStartVertex;
        }
        else
        {
            this->position.lpvData = (BYTE*)(lpVBufI->position.lpvData) +
                                     dwStartVertex * lpVBufI->position.dwStride;
            this->position.dwStride = lpVBufI->position.dwStride;
#ifdef VTABLE_HACK
            if (IS_DP2HAL_DEVICE(this) && !IS_MT_DEVICE(this) && IS_FPU_SETUP(this))
            {
                CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
                dev->lpDP2LastVBI = lpVBufI;
                dev->VtblDrawPrimitiveVBFE();
            }
#endif
        }
        if (this->dwVIDIn != lpVBufI->fvf || this->dwDeviceFlags & D3DDEV_STRIDE)
        {
            this->dwDeviceFlags &= ~D3DDEV_STRIDE;
            this->dwVIDIn = lpVBufI->fvf;
            ret = SetupFVFData(NULL);
            if (ret != D3D_OK)
                goto l_exit;
        }
#if DBG
        ret=CheckDrawPrimitive(this);
        if (ret != D3D_OK)
            goto l_exit;
#endif
        ret = this->ProcessPrimitive();
l_exit:
        // If we used SOA then the dwVIDIn <-> position.dwStride relationship
        // violated. This fixes that. This is required since in non VB code
        // we will not recompute position.dwStride if FVF matched dwVIDIn.
        this->position.dwStride = lpVBufI->position.dwStride;
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DVertexBuffer::Optimize"

HRESULT D3DAPI CDirect3DVertexBuffer::Optimize(LPDIRECT3DDEVICE7 lpDevice, DWORD dwFlags)
{
    HRESULT ret;
    LPDIRECT3DDEVICEI lpDevI;
    DWORD bufferSize;
    LPDIRECTDRAWSURFACE7 lpSurface7;
    LPDIRECTDRAWSURFACE  lpSurface;
    LPVOID lpMemory;


// Validate parms
    if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (!VALID_DIRECT3DDEVICE_PTR(lpDevice))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
    if (dwFlags != 0)
    {
        D3D_ERR("dwFlags should be zero");
        return DDERR_INVALIDPARAMS;
    }

    CLockD3DMT lockObject(lpDevI, DPF_MODNAME, REMIND(""));

    if (lpDevI->ValidateFVF(this->fvf) != D3D_OK)
    {
        D3D_ERR("Invalid vertex buffer FVF for the device");
        return DDERR_INVALIDPARAMS;
    }
    if (this->dwCaps & D3DVBCAPS_OPTIMIZED)
    {
        D3D_ERR("The vertex buffer already optimized");
        return D3DERR_VERTEXBUFFEROPTIMIZED;
    }
    if (this->dwLockCnt != 0)
    {
        D3D_ERR("Could not optimize locked vertex buffer");
        return D3DERR_VERTEXBUFFERLOCKED;
    }
    if (IS_TLHAL_DEVICE(lpDevI) && (this->dwCaps & D3DVBCAPS_SYSTEMMEMORY)==0)
    {
        if (this->dwPVFlags & D3DPV_CLIPCODESGENERATED || (!IS_HW_DEVICE(lpDevI)))
        {
            // silently ignore since we'll be either
            // using our front end or this is ref rast
            // Either way we need no special optimization
            goto success;
        }
        DDSURFACEDESC2 ddsd;
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        ddsd.dwFlags = DDSD_CAPS | DDSD_FVF | DDSD_SRCVBHANDLE;
        ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER;
        ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        ddsd.ddsCaps.dwCaps2 = DDSCAPS2_VERTEXBUFFER;
        ddsd.dwFVF = this->fvf; // Let driver know about the FVF
        ddsd.dwSrcVBHandle = DDSLCL(this->lpDDSVB)->lpSurfMore->dwSurfaceHandle;
        if (lpDevI->lpDirect3DI->lpDD7->CreateSurface(&ddsd, &lpSurface7, NULL) != DD_OK)
        {
            // Driver could not or did not want to optimize the VB
            goto success;
        }
        ret = lpSurface7->QueryInterface(IID_IDirectDrawSurfaceNew, (LPVOID*)&lpSurface);
        if (ret != DD_OK)
        {
            D3D_ERR("failed to QI for DDS1");
            lpSurface7->Release();
            return ret;
        }
        // Destroy old surfaces
        lpDDSVB->Release();
        lpDDS1VB->Release();
        // And use new ones
        lpDDSVB = lpSurface7;
        lpDDS1VB = lpSurface;

        this->dwCaps |= D3DVBCAPS_OPTIMIZED;
#ifdef VTABLE_HACK
        VtblLockDefault();
#endif // VTABLE_HACK
        return D3D_OK;
    }
    else
    {
    // Do nothing for transformed vertices
        if ((this->fvf & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
        {
            goto success;
        }
    // Get the buffer size to allocate
        bufferSize = lpDevI->pGeometryFuncs->ComputeOptimizedVertexBufferSize
                                                    (this->fvf, this->position.dwStride,
                                                     dwNumVertices);
    // Create new surfaces for optimized vertex buffer
        if (bufferSize == 0)
        {
            goto success;
        }

        ret = CreateMemoryBuffer(lpDevI->lpDirect3DI, &lpSurface7, &lpSurface,
                                 &lpMemory, bufferSize);
        if (ret != D3D_OK)
            return ret;
    // Try to optimize
    // If optimized vertex buffer are not supported by the implementation
    // it returns E_NOTIMPL. In this case we still set D3DVBCAPS_OPTIMIZED to prevent
    // locking of the vertex buffer. But bReallyOptimized is set to FALSE, to use
    // the original buffer.
        ret = lpDevI->pGeometryFuncs->OptimizeVertexBuffer
            (fvf, dwNumVertices, position.dwStride, position.lpvData,
             lpMemory, dwFlags);

        if (ret)
        {
            lpSurface7->Release();
            lpSurface->Release();
            if (ret == E_NOTIMPL)
            {
                goto success;
            }
            else
            {
                D3D_ERR("Failed to optimize vertex buffer");
                return ret;
            }
        }
        bReallyOptimized = TRUE;
        this->dwPVFlags |= D3DPV_SOA;
    // Destroy old surfaces
        lpDDSVB->Release();
        lpDDS1VB->Release();
    // And use new ones
        lpDDSVB = lpSurface7;
        lpDDS1VB = lpSurface;
        position.lpvData = lpMemory;
    success:
        this->dwCaps |= D3DVBCAPS_OPTIMIZED;
#ifdef VTABLE_HACK
        // Disable all fast path optimizations
        VtblLockDefault();
        if (this->lpDevIBatched)
        {
            this->lpDevIBatched->VtblDrawPrimitiveVBDefault();
            this->lpDevIBatched->VtblDrawIndexedPrimitiveVBDefault();
        }
#endif
        return D3D_OK;
    }
}

#ifdef VTABLE_HACK
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DrawPrimitiveVBTL"

HRESULT D3DAPI CDirect3DDeviceIDP2::DrawPrimitiveVBTL(D3DPRIMITIVETYPE dptPrimitiveType,
                                                LPDIRECT3DVERTEXBUFFER7 lpVBuf,
                                                DWORD dwStartVertex, DWORD dwNumVertices,
                                                DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
#if DBG
    HRESULT ret = CheckDrawPrimitiveVB(lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;
    Profile(PROF_DRAWPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#endif
    if ((lpVBufI == lpDP2CurrBatchVBI) && (this->dwVIDIn))
    {
        this->primType = dptPrimitiveType;
        this->dwNumVertices = dwNumVertices;
        this->dwFlags = dwFlags | lpVBufI->dwPVFlags;
        this->dwVertexBase = dwStartVertex;
        GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives
#if DBG
        if (dwNumPrimitives > MAX_DX6_PRIMCOUNT)
        {
            D3D_ERR("D3D for DX7 cannot handle greater that 64K sized primitives");
            return D3DERR_TOOMANYPRIMITIVES;
        }
#endif
        this->dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = max(this->dwDP2VertexCount, this->dwVertexBase + this->dwNumVertices);
        lpVBufI->lpDevIBatched = this;
        return DrawPrim();
    }
    VtblDrawPrimitiveVBDefault();
    return DrawPrimitiveVB(dptPrimitiveType, lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DrawIndexedPrimitiveVBTL"

HRESULT D3DAPI CDirect3DDeviceIDP2::DrawIndexedPrimitiveVBTL(D3DPRIMITIVETYPE dptPrimitiveType,
                                                       LPDIRECT3DVERTEXBUFFER7 lpVBuf,
                                                       DWORD dwStartVertex, DWORD dwNumVertices,
                                                       LPWORD lpwIndices, DWORD dwIndexCount,
                                                       DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
#if DBG
    HRESULT ret = CheckDrawPrimitiveVB(lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;
    Profile(PROF_DRAWINDEXEDPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#endif
    if ((lpVBufI == lpDP2CurrBatchVBI) && (this->dwVIDIn))
    {
        this->primType = dptPrimitiveType;
        this->dwNumVertices = dwNumVertices;
        this->dwFlags = dwFlags | lpVBufI->dwPVFlags;
        this->dwVertexBase = dwStartVertex;
        this->dwNumIndices = dwIndexCount;
        this->lpwIndices = lpwIndices;
        GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives
#if DBG
        if (dwNumPrimitives > MAX_DX6_PRIMCOUNT)
        {
            D3D_ERR("D3D for DX7 cannot handle greater that 64K sized primitives");
            return D3DERR_TOOMANYPRIMITIVES;
        }
#endif
        this->dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = max(this->dwDP2VertexCount, this->dwVertexBase + this->dwNumVertices);
        lpVBufI->lpDevIBatched = this;
        return DrawIndexPrim();
    }
    VtblDrawIndexedPrimitiveVBDefault();
    return DrawIndexedPrimitiveVB(dptPrimitiveType, lpVBuf, dwStartVertex, dwNumVertices, lpwIndices, dwIndexCount, dwFlags);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DrawPrimitiveVBFE"

HRESULT D3DAPI CDirect3DDeviceIDP2::DrawPrimitiveVBFE(D3DPRIMITIVETYPE dptPrimitiveType,
                                                LPDIRECT3DVERTEXBUFFER7 lpVBuf,
                                                DWORD dwStartVertex, DWORD dwNumVertices,
                                                DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
    HRESULT ret;
#if DBG
    ret = CheckDrawPrimitiveVB(lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;
    Profile(PROF_DRAWPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#endif
    if ((lpVBufI == lpDP2LastVBI) &&
        !(this->dwFEFlags & D3DFE_FRONTEND_DIRTY))
    {
        this->primType = dptPrimitiveType;
        this->dwNumVertices = dwNumVertices;
        this->dwFlags = this->dwLastFlags | dwFlags | lpVBufI->dwPVFlags;
        this->position.lpvData = (BYTE*)(lpVBufI->position.lpvData) +
                                 dwStartVertex * lpVBufI->position.dwStride;
#if DBG
        GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives
        if (dwNumPrimitives > MAX_DX6_PRIMCOUNT)
        {
            D3D_ERR("D3D for DX7 cannot handle greater that 64K sized primitives");
            return D3DERR_TOOMANYPRIMITIVES;
        }
#endif
        this->dwVertexPoolSize = dwNumVertices * this->dwOutputSize;
        if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
        {
//         try
//         {
            if (this->TLVbuf_Grow(this->dwVertexPoolSize, true) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
//         }
//         catch (HRESULT ret)
//         {
//             return ret;
//         }
        }
        if (dwNumVertices * sizeof(D3DFE_CLIPCODE) > this->HVbuf.GetSize())
        {
            if (this->HVbuf.Grow(dwNumVertices * sizeof(D3DFE_CLIPCODE)) != D3D_OK)
            {
                D3D_ERR( "Could not grow clip buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
            this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
        }
        DDASSERT(this->dwDP2VertexCount * this->dwOutputSize == this->TLVbuf_Base());
        this->dwVertexBase = this->dwDP2VertexCount;
        DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
        dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = this->dwVertexBase + this->dwNumVertices;
        this->lpvOut = this->TLVbuf_GetAddress();
//        try
//        {
        switch (this->primType)
        {
        case D3DPT_POINTLIST:
            this->dwNumPrimitives = dwNumVertices;
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
            break;
        case D3DPT_LINELIST:
            this->dwNumPrimitives = dwNumVertices >> 1;
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
            break;
        case D3DPT_LINESTRIP:
            this->dwNumPrimitives = dwNumVertices - 1;
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
            break;
        case D3DPT_TRIANGLEFAN:
            this->dwNumPrimitives = dwNumVertices - 2;
            ret = this->pGeometryFuncs->ProcessTriangleFan(this);
            break;
        case D3DPT_TRIANGLESTRIP:
            this->dwNumPrimitives = dwNumVertices - 2;
            ret = this->pGeometryFuncs->ProcessTriangleStrip(this);
            break;
        case D3DPT_TRIANGLELIST:
    #ifdef _X86_
            {
                DWORD tmp;
                __asm
                {
                    mov  eax, 0x55555555    // fractional part of 1.0/3.0
                    mul  dwNumVertices
                    add  eax, 0x80000000    // Rounding
                    adc  edx, 0
                    mov  tmp, edx
                }
                this->dwNumPrimitives = tmp;
            }
    #else
            this->dwNumPrimitives = dwNumVertices / 3;
    #endif
            ret = this->pGeometryFuncs->ProcessTriangleList(this);
            break;
        }
//        }
//        catch (HRESULT ret)
//        {
//            return ret;
//        }
        D3DFE_UpdateClipStatus(this);
        this->TLVbuf_Base() += this->dwVertexPoolSize;
        DDASSERT(TLVbuf_base <= TLVbuf_size);
        DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
        return ret;
    }
    VtblDrawPrimitiveVBDefault();
    return DrawPrimitiveVB(dptPrimitiveType, lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DrawIndexedPrimitiveVBFE"

HRESULT D3DAPI CDirect3DDeviceIDP2::DrawIndexedPrimitiveVBFE(D3DPRIMITIVETYPE dptPrimitiveType,
                                                       LPDIRECT3DVERTEXBUFFER7 lpVBuf,
                                                       DWORD dwStartVertex, DWORD dwNumVertices,
                                                       LPWORD lpwIndices, DWORD dwIndexCount,
                                                       DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
    HRESULT ret;
#if DBG
    ret = CheckDrawPrimitiveVB(lpVBuf, dwStartVertex, dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;
    Profile(PROF_DRAWINDEXEDPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#endif
    if ((lpVBufI == lpDP2LastVBI) &&
        !(this->dwFEFlags & D3DFE_FRONTEND_DIRTY))
    {
        this->primType = dptPrimitiveType;
        this->dwNumVertices = dwNumVertices;
        this->dwFlags = this->dwLastFlags | dwFlags | lpVBufI->dwPVFlags;
        this->dwVertexBase = 0;
        this->dwNumIndices = dwIndexCount;
        this->lpwIndices = lpwIndices;
        GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives
        this->position.lpvData = (BYTE*)(lpVBufI->position.lpvData) +
                                 dwStartVertex * lpVBufI->position.dwStride;
#if DBG
        if (dwNumPrimitives > MAX_DX6_PRIMCOUNT)
        {
            D3D_ERR("D3D for DX7 cannot handle greater that 64K sized primitives");
            return D3DERR_TOOMANYPRIMITIVES;
        }
#endif
        this->dwVertexPoolSize = dwNumVertices * this->dwOutputSize;
        if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
        {
//         try
//         {
            if (this->TLVbuf_Grow(this->dwVertexPoolSize,
                (this->dwDeviceFlags & D3DDEV_DONOTCLIP)!=0) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
//         }
//         catch (HRESULT ret)
//         {
//             return ret;
//         }
        }
        if (dwNumVertices * sizeof(D3DFE_CLIPCODE) > this->HVbuf.GetSize())
        {
            if (this->HVbuf.Grow(dwNumVertices * sizeof(D3DFE_CLIPCODE)) != D3D_OK)
            {
                D3D_ERR( "Could not grow clip buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
            this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
        }
        this->dwVertexBase = this->dwDP2VertexCount;
        DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
        dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = this->dwVertexBase + this->dwNumVertices;
        this->lpvOut = this->TLVbuf_GetAddress();
//        try
//        {
            ret = this->pGeometryFuncs->ProcessIndexedPrimitive(this);
//        }
//        catch (HRESULT ret)
//        {
//            return ret;
//        }
        D3DFE_UpdateClipStatus(this);
        this->TLVbuf_Base() += this->dwVertexPoolSize;
        DDASSERT(TLVbuf_base <= TLVbuf_size);
        DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
        return ret;
    }
    VtblDrawIndexedPrimitiveVBDefault();
    return DrawIndexedPrimitiveVB(dptPrimitiveType, lpVBuf, dwStartVertex, dwNumVertices, lpwIndices, dwIndexCount, dwFlags);
}
#endif // VTABLE_HACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\tlhal.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       tlhal.h
 *  Content:    Support code for HALs with hardware transform & light
 *
 ***************************************************************************/
#ifndef _TLHAL_H_
#define _TLHAL_H_

#include "drawprim.hpp"
//---------------------------------------------------------------------
// DirectX7 device
//
class CDirect3DDevice7 : public CDirect3DDeviceIDP2
{
public: 
    CDirect3DDevice7() { deviceType = D3DDEVTYPE_DX7HAL; m_tssMax = D3DTSS_MAX;}
    ~CDirect3DDevice7() { CleanupTextures(); }
    HRESULT TexBltI(LPDDRAWI_DDRAWSURFACE_LCL lpDst,
                    LPDDRAWI_DDRAWSURFACE_LCL lpSrc,
                    LPPOINT p, RECTL *r, DWORD dwFlags);
    HRESULT SetPriorityI(LPDDRAWI_DDRAWSURFACE_LCL lpDst, DWORD dwPriority);
    HRESULT SetTexLODI(LPDDRAWI_DDRAWSURFACE_LCL lpDst, DWORD dwLOD);
    HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                         IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice);
    void WriteStateSetToDevice(D3DSTATEBLOCKTYPE);
    HRESULT UpdatePalette(DWORD,DWORD,DWORD,LPPALETTEENTRY);
    HRESULT SetPalette(DWORD,DWORD,DWORD);
    HRESULT UpdateTextures();
    HRESULT GetTextureDDIHandle(LPDIRECT3DTEXTUREI lpTexI, D3DTEXTUREHANDLE *hTex);
    void SetRenderTargetI(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
    void SetRenderTargetINoFlush(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
    bool CanDoTexBlt(LPDDRAWI_DDRAWSURFACE_LCL lpDDSSrcSubFace_lcl, 
                     LPDDRAWI_DDRAWSURFACE_LCL lpDDSDstSubFace_lcl);
    void ClearI(DWORD dwFlags, DWORD clrCount, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);
    HRESULT D3DAPI GetInfo(DWORD dwDevInfoID, LPVOID pDevInfoStruct, DWORD dwSize);
};
//---------------------------------------------------------------------
// Device, that supports hardware Transformation and Lighting
//
class CDirect3DDeviceTL : public CDirect3DDevice7
{
public: 
    CDirect3DDeviceTL();
    ~CDirect3DDeviceTL() { CleanupTextures(); }

    void LightEnableI(DWORD dwLightIndex, BOOL bEnable);

    HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                         IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice);
    void UpdateDrvViewInfo(LPD3DVIEWPORT7 lpVwpData);
    void SetTransformI(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT SetupFVFData(DWORD *pdwInpVertexSize);
protected:
    HRESULT ProcessPrimitive(__PROCPRIMOP op);
    void LightChanged(DWORD dwLightIndex);
    void MaterialChanged();
    void SetClipPlaneI(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation);
};

#endif /* _TLHAL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\genlight.h ===
#ifndef __GENLIGHT_H__
#define __GENLIGHT_H__

typedef struct _SpecularTable 
{
    LIST_MEMBER(_SpecularTable) list;
    float          power;          /* shininess power */
    unsigned char   table[260]; /* space for overflows */
} SpecularTable;

void RLDDI_DoLights(D3DVALUE ar, D3DVALUE ag, D3DVALUE ab, int count,
                    D3DLIGHTINGELEMENT* elements, size_t in_size,
                    unsigned long *out, size_t out_size, int lightc, 
                    D3DI_LIGHT* lightv, D3DMATERIAL* mat, D3DVALUE gain, 
                    SpecularTable* tab);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\genpick.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   genpick.h
 *  Content:    Generic picking function prototypes
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id: commdrv.h,v 1.2 1995/12/04 11:30:59 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   17/05/96   v-jonsh Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _GENPICK_H_
#define _GENPICK_H_

#include "commdrv.hpp"

extern int  GenPickTriangle(LPDIRECT3DDEVICEI lpDevI,
                            D3DTLVERTEX*   base,
                            D3DTRIANGLE*   tri,
                            D3DRECT*   rect,
                            D3DVALUE*  result);

extern HRESULT  GenPickTriangles(LPDIRECT3DDEVICEI lpDevI,
                                 LPDIRECTDRAWSURFACE lpDDExeBuf,
                                 LPBYTE      lpData,
                                 D3DINSTRUCTION* ins,
                                 D3DTRIANGLE*    tri,
                                 LPD3DRECTV      extent,
                                 D3DRECT*    pick_region);

extern HRESULT  GenAddPickRecord(LPDIRECT3DDEVICEI lpDevI,
                                 D3DOPCODE op,
                                 int offset,
                                 float result);

extern HRESULT  GenGetPickRecords(LPDIRECT3DDEVICEI lpDevI,
                                  D3DI_PICKDATA* pdata);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\fe\vwport.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   vwport.c
 *  Content:    Direct3D viewport functions
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3DViewport object
 */

#include "d3dfei.h"
#include "drawprim.hpp"

//---------------------------------------------------------------------
// Update pre-computed constants related to viewport
//
// This functions should be called every time the viewport parameters are
// changed
//
// Notes:
//      1. scaleY and offsetY are computed to flip Y axes from up to down.
//      2. Mclip matrix is computed multiplied by Mshift matrix
//
const D3DVALUE SMALL_NUMBER = 0.000001f;
// Maximum number of clear rectangles considered legal.
// This limit is set by NT kernel for Clear2 callback
const DWORD MAX_CLEAR_RECTS  = 0x1000;

void
UpdateViewportCache(LPDIRECT3DDEVICEI device, D3DVIEWPORT7 *data)
{
#if DBG
    // Bail if we are going to cause any divide by zero exceptions.
    // The likely reason is that we have a bogus viewport set by
    // TLVertex execute buffer app.
    if (data->dwWidth == 0 || data->dwHeight == 0)
    {
        D3D_ERR("Viewport width or height is zero");
        throw DDERR_INVALIDPARAMS;
    }
    if (data->dvMaxZ < 0 ||
        data->dvMinZ < 0 ||
        data->dvMaxZ > 1 ||
        data->dvMinZ > 1)
    {
        D3D_ERR("dvMaxZ and dvMinZ should be between 0 and 1");
        throw DDERR_INVALIDPARAMS;
    }
    if (data->dvMaxZ < data->dvMinZ)
    {
        D3D_ERR("dvMaxZ should not be smaller than dvMinZ");
        throw DDERR_INVALIDPARAMS;
    }
#endif // DBG
    const D3DVALUE eps = 0.001f;
    if (data->dvMaxZ - data->dvMinZ < eps)
    {
        // When we clip, we transform vertices from the screen space to the
        // clipping space. With the above condition it is impossible. So we do
        // a little hack here by setting dvMinZ and dvMaxZ to different values
        if (data->dvMaxZ >= 0.5f)
            data->dvMinZ = data->dvMaxZ - eps;
        else
            data->dvMaxZ = data->dvMinZ + eps;
    }
    D3DFE_VIEWPORTCACHE *cache = &device->vcache;
    cache->dvX = D3DVAL(data->dwX);
    cache->dvY = D3DVAL(data->dwY);
    cache->dvWidth = D3DVAL(data->dwWidth);
    cache->dvHeight = D3DVAL(data->dwHeight);

    cache->scaleX  = cache->dvWidth;
    cache->scaleY  = - cache->dvHeight;
    cache->scaleZ  = D3DVAL(data->dvMaxZ - data->dvMinZ);
    cache->offsetX = cache->dvX;
    cache->offsetY = cache->dvY + cache->dvHeight;
    cache->offsetZ = D3DVAL(data->dvMinZ);
    // Small offset is added to prevent generation of negative screen
    // coordinates (this could happen because of precision errors).
    cache->offsetX += SMALL_NUMBER;
    cache->offsetY += SMALL_NUMBER;

    cache->scaleXi = D3DVAL(1) / cache->scaleX;
    cache->scaleYi = D3DVAL(1) / cache->scaleY;
    cache->scaleZi = D3DVAL(1) / cache->scaleZ;
    cache->minX = cache->dvX;
    cache->maxX = cache->dvX + cache->dvWidth;
    cache->minY = cache->dvY;
    cache->maxY = cache->dvY + cache->dvHeight;
    cache->minXi = FTOI(cache->minX);
    cache->maxXi = FTOI(cache->maxX);
    cache->minYi = FTOI(cache->minY);
    cache->maxYi = FTOI(cache->maxY);
    if (device->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        LPD3DHAL_D3DEXTENDEDCAPS lpCaps = device->lpD3DExtendedCaps;

        // Because we clip by guard band window we have to use its extents
        cache->minXgb = lpCaps->dvGuardBandLeft;
        cache->maxXgb = lpCaps->dvGuardBandRight;
        cache->minYgb = lpCaps->dvGuardBandTop;
        cache->maxYgb = lpCaps->dvGuardBandBottom;

        D3DVALUE w = 2.0f / cache->dvWidth;
        D3DVALUE h = 2.0f / cache->dvHeight;
        D3DVALUE ax1 = -(lpCaps->dvGuardBandLeft - cache->dvX)   * w + 1.0f;
        D3DVALUE ax2 =  (lpCaps->dvGuardBandRight  - cache->dvX) * w - 1.0f;
        D3DVALUE ay1 =  (lpCaps->dvGuardBandBottom - cache->dvY) * h - 1.0f;
        D3DVALUE ay2 = -(lpCaps->dvGuardBandTop - cache->dvY)    * h + 1.0f;
        cache->gb11 = 2.0f / (ax1 + ax2);
        cache->gb41 = cache->gb11 * (ax1 - 1.0f) * 0.5f;
        cache->gb22 = 2.0f / (ay1 + ay2);
        cache->gb42 = cache->gb22 * (ay1 - 1.0f) * 0.5f;

        cache->Kgbx1 = 0.5f * (1.0f - ax1);
        cache->Kgbx2 = 0.5f * (1.0f + ax2);
        cache->Kgby1 = 0.5f * (1.0f - ay1);
        cache->Kgby2 = 0.5f * (1.0f + ay2);
    }
    else
    {
        cache->minXgb = cache->minX;
        cache->maxXgb = cache->maxX;
        cache->minYgb = cache->minY;
        cache->maxYgb = cache->maxY;
    }
}
//---------------------------------------------------------------------
DWORD
ProcessRects(LPDIRECT3DDEVICEI pDevI, DWORD dwCount, LPD3DRECT rects)
{
    RECT vwport;
    DWORD i,j;

    /*
     * Rip through the rects and validate that they
     * are within the viewport.
     */

    if(dwCount == 0 && rects == NULL)
    {
        dwCount = 1;
    }
#if DBG
    else if(rects == NULL)
    {
        D3D_ERR("invalid clear rectangle parameter rects == NULL");
        throw DDERR_INVALIDPARAMS;
    }
#endif

    if (dwCount > pDevI->clrCount) {
        if (D3DRealloc((void**)&pDevI->clrRects, dwCount * sizeof(D3DRECT)) != DD_OK)
        {
            pDevI->clrCount = 0;
            pDevI->clrRects = NULL;
            D3D_ERR("failed to allocate space for rects");
            throw DDERR_OUTOFMEMORY;
        }
    }
    pDevI->clrCount = dwCount;

    // If nothing is specified, assume the viewport needs to be cleared
    if (!rects)
    {
        pDevI->clrRects[0].x1 = pDevI->m_Viewport.dwX;
        pDevI->clrRects[0].y1 = pDevI->m_Viewport.dwY;
        pDevI->clrRects[0].x2 = pDevI->m_Viewport.dwX + pDevI->m_Viewport.dwWidth;
        pDevI->clrRects[0].y2 = pDevI->m_Viewport.dwY + pDevI->m_Viewport.dwHeight;
        return 1;
    }
    else
    {
        vwport.left   = pDevI->m_Viewport.dwX;
        vwport.top    = pDevI->m_Viewport.dwY;
        vwport.right  = pDevI->m_Viewport.dwX + pDevI->m_Viewport.dwWidth;
        vwport.bottom = pDevI->m_Viewport.dwY + pDevI->m_Viewport.dwHeight;

        j=0;
        for (i = 0; i < dwCount; i++)
        {
            if (IntersectRect((LPRECT)(pDevI->clrRects + j), &vwport, (LPRECT)(rects + i)))
                j++;
        }
        return j;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetViewportI"

void DIRECT3DDEVICEI::SetViewportI(LPD3DVIEWPORT7 lpData)
{
    // We have to check parameters here, because viewport could be changed
    // after creating a state set
    DWORD uSurfWidth,uSurfHeight;
    LPDIRECTDRAWSURFACE lpDDS = this->lpDDSTarget;

    uSurfWidth=    ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wWidth;
    uSurfHeight=   ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wHeight;

    if (lpData->dwX > uSurfWidth ||
        lpData->dwY > uSurfHeight ||
        lpData->dwX + lpData->dwWidth > uSurfWidth ||
        lpData->dwY + lpData->dwHeight > uSurfHeight)
    {
        D3D_ERR("Viewport outside the render target surface");
        throw DDERR_INVALIDPARAMS;
    }

    this->m_Viewport = *lpData;

    // Update front-end data
    UpdateViewportCache(this, &this->m_Viewport);

    if (!(this->dwFEFlags & D3DFE_EXECUTESTATEMODE))
    {
        // Download viewport data
        this->UpdateDrvViewInfo(&this->m_Viewport);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetViewport"

HRESULT D3DAPI DIRECT3DDEVICEI::SetViewport(LPD3DVIEWPORT7 lpData)
{
    if (!VALID_D3DVIEWPORT_PTR(lpData))
    {
        D3D_ERR( "Invalid D3DVIEWPORT7 pointer" );
        return DDERR_INVALIDPARAMS;
    }
    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            m_pStateSets->InsertViewport(lpData);
        else
            SetViewportI(lpData);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetViewport"

HRESULT
D3DAPI DIRECT3DDEVICEI::GetViewport(LPD3DVIEWPORT7 lpData)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    if (!VALID_D3DVIEWPORT_PTR(lpData))
    {
        D3D_ERR( "Invalid D3DVIEWPORT2 pointer" );
        return DDERR_INVALIDPARAMS;
    }

    *lpData = this->m_Viewport;

    return (D3D_OK);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::Clear"
extern void BltFillRects(LPDIRECT3DDEVICEI, DWORD, LPD3DRECT, D3DCOLOR);
extern void BltFillZRects(LPDIRECT3DDEVICEI, unsigned long,DWORD, LPD3DRECT, DWORD);

#define bDoRGBClear ((dwFlags & D3DCLEAR_TARGET)!=0)
#define bDoZClear   ((dwFlags & D3DCLEAR_ZBUFFER)!=0)
#define bDoStencilClear ((dwFlags & D3DCLEAR_STENCIL)!=0)


HRESULT
D3DAPI DIRECT3DDEVICEI::Clear(DWORD dwCount, LPD3DRECT rects, DWORD dwFlags,
                              D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
#if DBG
    if (IsBadWritePtr(rects, dwCount * sizeof(D3DRECT)))
    {
        D3D_ERR( "Invalid rects pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    try
    {
        HRESULT err;
        LPDDPIXELFORMAT pZPixFmt=NULL;
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        if (dwCount > MAX_CLEAR_RECTS)
        {
            D3D_ERR("Cannot support more than 64K rectangles");
            return DDERR_INVALIDPARAMS;
        }
        if (!(lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR))
        {
            if (bDoStencilClear||bDoZClear)
            {
                if(lpDDSZBuffer==NULL)
                {
                    // unlike Clear(), specifying a Zbuffer-clearing flag without a zbuffer will
                    // be considered an error
#if DBG
                    if(bDoZClear)
                    {
                        D3D_ERR("Invalid flag D3DCLEAR_ZBUFFER: no zbuffer is associated with device");
                    }
                    if(bDoStencilClear)
                    {
                        D3D_ERR("Invalid flag D3DCLEAR_STENCIL: no zbuffer is associated with device");
                    }
#endif
                    return D3DERR_ZBUFFER_NOTPRESENT;
                }
                pZPixFmt=&((LPDDRAWI_DDRAWSURFACE_INT) lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;
                if(bDoStencilClear)
                {
                    if(!(pZPixFmt->dwFlags & DDPF_STENCILBUFFER))
                    {
                        D3D_ERR("Invalid flag D3DCLEAR_STENCIL; current zbuffer's pixel format doesnt support stencil bits");
                        return D3DERR_STENCILBUFFER_NOTPRESENT;
                    }
                }
            }
        }
        if (!(dwFlags & (D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)))
        {
            D3D_ERR("No valid flags passed to Clear");
            return DDERR_INVALIDPARAMS;
        }

        // bad clear values just cause wacky results but no crashes, so OK to allow in retail bld

        DDASSERT(!bDoZClear || ((dvZ>=0.0) && (dvZ<=1.0)));
        DDASSERT(!bDoStencilClear || !pZPixFmt || (dwStencil <= (DWORD)((1<<pZPixFmt->dwStencilBitDepth)-1)));

        dwCount = ProcessRects(this, dwCount, rects);

        // Call DDI specific Clear routine
        ClearI(dwFlags, dwCount, dwColor, dvZ, dwStencil);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}

void DIRECT3DDEVICEI::ClearI(DWORD dwFlags, DWORD clrCount, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
    HRESULT err;
    // Flush any outstanding geometry to put framebuffer/Zbuffer in a known state for Clears that
    // don't use tris (i.e. HAL Clears and Blts).  Note this doesn't work for tiled architectures
    // outside of Begin/EndScene, this will be fixed later


    if ((err = FlushStates()) != D3D_OK)
    {
        D3D_ERR("Error trying to render batched commands in D3DFE_Clear2");
        throw  err;
    }

    if (lpD3DHALCallbacks3->Clear2)
    {
        // Clear2 HAL Callback exists
        D3DHAL_CLEAR2DATA Clear2Data;
        Clear2Data.dwhContext   = dwhContext;
        Clear2Data.dwFlags      = dwFlags;
        // Here I will follow the ClearData.dwFillColor convention that
        // color word is raw 32bit ARGB, unadjusted for surface bit depth
        Clear2Data.dwFillColor  = dwColor;
        // depth/stencil values both passed straight from user args
        Clear2Data.dvFillDepth  = dvZ;
        Clear2Data.dwFillStencil= dwStencil;
        Clear2Data.lpRects      = clrRects;
        Clear2Data.dwNumRects   = clrCount;
        Clear2Data.ddrval       = D3D_OK;
    #ifndef WIN95
        if((err = CheckContextSurface(this)) != D3D_OK)
        {
            throw err;
        }
    #endif
        CALL_HAL3ONLY(err, this, Clear2, &Clear2Data);
        if (err != DDHAL_DRIVER_HANDLED)
        {
            throw DDERR_UNSUPPORTED;
        }
        else if (Clear2Data.ddrval != DD_OK)
        {
            throw Clear2Data.ddrval;
        }
        else
            return;
    }


    if (lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
    {
        if (bDoStencilClear)
        {
            D3D_ERR("Invalid flag D3DCLEAR_STENCIL: this ZBUFFERLESSHSR device doesn't support Clear2()");
            throw D3DERR_ZBUFFER_NOTPRESENT;
        }
        if (bDoZClear)
        {
            if (!(lpD3DHALCallbacks2->Clear) || (dvZ!=1.0))
            {
                D3D_WARN(3,"Ignoring D3DCLEAR_ZBUFFER since this ZBUFFERLESSHSR device doesn't even support Clear() or Z!=1");
                dwFlags &= ~(D3DCLEAR_ZBUFFER);
            }
        }
    }
    LPDDPIXELFORMAT pZPixFmt;
    if (NULL != lpDDSZBuffer)
    {
        pZPixFmt = &((LPDDRAWI_DDRAWSURFACE_INT) lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;
    }
    else
    {
        pZPixFmt = NULL;
    }
    if (lpD3DHALCallbacks2->Clear)
    {
        if(bDoZClear || bDoStencilClear)
        {
            if((pZPixFmt!=NULL) && //PowerVR need no Zbuffer
               (DDPF_STENCILBUFFER & pZPixFmt->dwFlags)
              )
            {
                // if surface has stencil bits, must verify either Clear2 callback exists or
                // we're using SW rasterizers (which require the special WriteMask DDHEL blt)
                // This case should not be hit since we check right at the
                // driver initialization time if the driver doesnt report Clear2
                // yet it supports stencils
                if(((LPDDRAWI_DDRAWSURFACE_INT)lpDDSZBuffer)->lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                {
                    goto Emulateclear;
                }
                else
                {
                    D3D_ERR("Driver HAL doesn't provide Clear2 callback, cannot use Clear2 with HW stencil surfaces");
                    throw DDERR_INVALIDPIXELFORMAT;
                }
            }
            // if Clear2 callback doesnt exist and it's a z-only surface and not doing zclear to
            // non-max value then Clear2 is attempting to do no more than Clear could do, so it's
            // safe to call Clear() instead of Clear2(), which will take advantage of older
            // drivers that implement Clear but not Clear2

            dwFlags &= ~D3DCLEAR_STENCIL;   // Device cannot do stencil
        }
        D3DHAL_CLEARDATA ClearData;
        if (bDoZClear && dvZ != 1.0)
        {
            ClearData.dwFlags   = dwFlags & ~D3DCLEAR_ZBUFFER;
            dwFlags = D3DCLEAR_ZBUFFER;
        }
        else
        {
            ClearData.dwFlags   = dwFlags;
            dwFlags = 0;
        }
        if (ClearData.dwFlags)
        {
            ClearData.dwhContext   = dwhContext;
            // Here I will follow the ClearData.dwFillColor convention that
            // color word is raw 32bit ARGB, unadjusted for surface bit depth
            ClearData.dwFillColor  = dwColor;
            // must clear to 0xffffffff because legacy drivers expect this
            ClearData.dwFillDepth  = 0xffffffff;
            ClearData.lpRects      = clrRects;
            ClearData.dwNumRects   = clrCount;
            ClearData.ddrval       = D3D_OK;
    #ifndef WIN95
            if((err = CheckContextSurface(this)) != D3D_OK)
            {
                throw err;
            }
    #endif
            CALL_HAL2ONLY(err, this, Clear, &ClearData);
            if (err != DDHAL_DRIVER_HANDLED)
            {
                throw DDERR_UNSUPPORTED;
            }
        }
    }
Emulateclear:
    // Fall back to Emulation using Blt

    if(bDoRGBClear)
    {
        BltFillRects(this, clrCount, clrRects, dwColor);
        //ok to not return possible errors from Blt?
    }

    if ((bDoZClear || bDoStencilClear) && NULL != pZPixFmt)
    {
        DWORD   dwZbufferClearValue=0;
        DWORD   dwZbufferClearMask=0;
        DDASSERT(pZPixFmt->dwZBufferBitDepth<=32);
        DDASSERT(pZPixFmt->dwStencilBitDepth<32);
        DDASSERT(pZPixFmt->dwZBitMask!=0x0);
        DDASSERT((0xFFFFFFFF == (pZPixFmt->dwZBitMask | pZPixFmt->dwStencilBitMask)) |
            ((DWORD)((1<<pZPixFmt->dwZBufferBitDepth)-1) == (pZPixFmt->dwZBitMask | pZPixFmt->dwStencilBitMask)));
        DDASSERT(0==(pZPixFmt->dwZBitMask & pZPixFmt->dwStencilBitMask));
        if(bDoZClear)
        {
            dwZbufferClearMask = pZPixFmt->dwZBitMask;
            // special case the common cases
            if(dvZ==1.0)
            {
                dwZbufferClearValue=pZPixFmt->dwZBitMask;
            }
            else if(dvZ > 0.0)
            {
                dwZbufferClearValue=((DWORD)((dvZ*(pZPixFmt->dwZBitMask >> zmask_shift))+0.5)) << zmask_shift;
            }
        }
        if(bDoStencilClear)
        {
            DDASSERT(pZPixFmt->dwStencilBitMask!=0x0);
            DDASSERT(pZPixFmt->dwFlags & DDPF_STENCILBUFFER);
            dwZbufferClearMask |= pZPixFmt->dwStencilBitMask;
            // special case the common case
            if(dwStencil!=0)
            {
                dwZbufferClearValue |=(dwStencil << stencilmask_shift) & pZPixFmt->dwStencilBitMask;
            }
        }
        if (dwZbufferClearMask == (pZPixFmt->dwStencilBitMask | pZPixFmt->dwZBitMask))
        {
            // do Stencil & Z Blt together, using regular DepthFill blt which will be faster
            // than the writemask blt because its write-only, instead of read-modify-write
            dwZbufferClearMask = 0;
        }
        BltFillZRects(this, dwZbufferClearValue, clrCount, clrRects, dwZbufferClearMask);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\d3dfe.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dfe.hpp
 *  Content:    Direct3D internal include file
 *              for geometry pipeline implementations
 *
 ***************************************************************************/
#ifndef _D3DFE_H

#include "d3d.h"
#include "lists.hpp"
#include "d3dmem.h"
#include "d3ditype.h"

//---------------------------------------------------------------------
// The CSetD3DFPstate is used to facilitate the changing of FPU settings.
// In the constructor the optimal FPU state is set. In the destructor the
// old state is restored.
//
class CD3DFPstate
{
public:
    CD3DFPstate()
        {
        #ifdef _X86_
            WORD wTemp, wSave;
            wSavedFP = FALSE;
            // Disable floating point exceptions and go to single mode
                __asm fstcw wSave
                if (wSave & 0x300 ||            // Not single mode
                    0x3f != (wSave & 0x3f) ||   // Exceptions enabled
                    wSave & 0xC00)              // Not round to nearest mode
                {
                    __asm {
                        mov ax, wSave
                        and ax, not 300h    ;; single mode
                        or  ax, 3fh         ;; disable all exceptions
                        and ax, not 0xC00   ;; round to nearest mode
                        mov wTemp, ax
                        fldcw   wTemp
                    }
                    wSavedFP = TRUE;
                }
                wSaveFP = wSave;
        #endif
        }
    ~CD3DFPstate()
        {
        #ifdef _X86_
            WORD wSave = wSaveFP;
            if (wSavedFP)
                __asm {
                    fnclex
                    fldcw   wSave
                }
        #endif
        }
protected:
#ifdef _X86_
    WORD wSaveFP;
    WORD wSavedFP;  // WORD-sized to make the data an even DWORD
#endif
};

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

// this is not available for alpha or IA64
#ifndef LONG_MAX
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#endif

//--------------------------------------------------------------------
// Base definitions
//

// Default color values that should be used when ther is no lighting and
// color in vertices provided
const DWORD __DEFAULT_DIFFUSE = 0xFFFFFFFF;
const DWORD __DEFAULT_SPECULAR = 0;

const DWORD VER_IN_BATCH = 8;      // Size of Microsoft's internal clip vertex batch

typedef WORD D3DFE_CLIPCODE;

struct BATCHBUFFER;
//---------------------------------------------------------------------
struct _D3DFE_LIGHTING;
typedef struct _D3DFE_LIGHTING D3DFE_LIGHTING;

struct _D3DI_LIGHT;
typedef struct _D3DI_LIGHT D3DI_LIGHT;

class D3DFE_PROCESSVERTICES;
typedef class D3DFE_PROCESSVERTICES* LPD3DFE_PROCESSVERTICES;

extern "C"
{
typedef void (*LIGHT_VERTEX_FUNC)(LPD3DFE_PROCESSVERTICES pv,
                                  D3DI_LIGHT *light,
                                  D3DVERTEX *pInpCoord, 
                                  D3DVECTOR *pInpNormal,
                                  D3DLIGHTINGELEMENT *pEyeSpaceData);
typedef void (*PFN_LIGHTLOOP)(LPD3DFE_PROCESSVERTICES pv, 
                              DWORD dwVerCount,
                              BATCHBUFFER *pBatchBuffer,
                              D3DI_LIGHT *light, 
                              D3DVERTEX *in,
                              D3DVECTOR *pNormal,
                              DWORD *pDiffuse,
                              DWORD *pSpecular);
}
//---------------------------------------------------------------------
// "link" member should be the last, because we copy the structure using
// offsetof(D3DMATRIXI, link)
//
typedef struct _D3DMATRIXI
{
    D3DVALUE            _11, _12, _13, _14;
    D3DVALUE            _21, _22, _23, _24;
    D3DVALUE            _31, _32, _33, _34;
    D3DVALUE            _41, _42, _43, _44;
} D3DMATRIXI, *LPD3DMATRIXI;
//---------------------------------------------------------------------
// This is per texture stage data
//
typedef struct _D3DFE_TEXTURESTAGE
{
    DWORD       dwInpCoordIndex;    // Original value of the texture stage - input index
    DWORD       dwInpOffset;        // Texture coord offset in the FVF vertex
    DWORD       dwOutCoordIndex;    // Input index of the texture set is mapped to this 
                                    // output index
    DWORD       dwOrgStage;         // Original texture stage 
    DWORD       dwOrgWrapMode;      // Original WRAP mode
    D3DMATRIXI *pmTextureTransform; // NULL if texture transform is disabled for the stage
    // Bits 0-1 - (number of input  texture coordinates - 1)
    // Bits 2-3 - (number of output texture coordinates - 1)
    DWORD       dwTexTransformFuncIndex; 
    DWORD       dwTexGenMode;       // Mode of texture generation
} D3DFE_TEXTURESTAGE, *LPD3DFE_TEXTURESTAGE;
//---------------------------------------------------------------------
typedef struct _RECTV
{
    union
    {
        D3DVALUE x1;
        D3DVALUE dvX1;
    };
    union
    {
        D3DVALUE y1;
        D3DVALUE dvY1;
    };
    union
    {
        D3DVALUE x2;
        D3DVALUE dvX2;
    };
    union
    {
        D3DVALUE y2;
        D3DVALUE dvY2;
    };
} D3DRECTV, *LPD3DRECTV;
//---------------------------------------------------------------------
/*
 * Lighting defines
 */
typedef struct _SpecularTable
{
    LIST_MEMBER(_SpecularTable) list;
    float   power;          /* shininess power */
    float   table[260];     /* space for overflows */
} SpecularTable;

typedef struct {D3DVALUE r,g,b;} D3DFE_COLOR;
//---------------------------------------------------------------------
// Internal version of lightdata and constants for "flags" member of D3DI_LIGHT
//
const DWORD D3DLIGHTI_ATT0_IS_NONZERO   = 1 << 0;
const DWORD D3DLIGHTI_ATT1_IS_NONZERO   = 1 << 1;  
const DWORD D3DLIGHTI_ATT2_IS_NONZERO   = 1 << 2;   
const DWORD D3DLIGHTI_LINEAR_FALLOFF    = 1 << 3;
// Set when light data is changed
const DWORD D3DLIGHTI_DIRTY             = 1 << 4;
// This flag depends on D3DRENDERSTATE_SPACULARENABLE and light specular color
const DWORD D3DLIGHTI_COMPUTE_SPECULAR  = 1 << 5;
// Set when light data is set
const DWORD D3DLIGHTI_VALID             = 1 << 6;
// Set when the light is enabled
const DWORD D3DLIGHTI_ENABLED           = 1 << 7;        
const DWORD D3DLIGHTI_SPECULAR_IS_ZERO  = 1 << 8;
const DWORD D3DLIGHTI_AMBIENT_IS_ZERO   = 1 << 9;
const DWORD D3DLIGHTI_OPTIMIZATIONFLAGS = D3DLIGHTI_SPECULAR_IS_ZERO |
                                          D3DLIGHTI_AMBIENT_IS_ZERO  |
                                          D3DLIGHTI_ATT0_IS_NONZERO  |
                                          D3DLIGHTI_ATT1_IS_NONZERO  |
                                          D3DLIGHTI_ATT2_IS_NONZERO  |
                                          D3DLIGHTI_LINEAR_FALLOFF;
//--------------------------------------------------------------------
// Members of this structure should be aligned as stated
typedef struct _D3DI_LIGHT
{
    // Should be QWORD aligned
    D3DVECTOR       model_position; // In the camera or model space
    D3DLIGHTTYPE    type;
    // Should be QWORD aligned
    D3DVECTOR       model_direction;// In the camera or model space
    D3DVALUE        falloff;
    // Should be QWORD aligned
    DWORD           flags;
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DFE_COLOR     diffuseMat;     // Material diffuse times light color
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DFE_COLOR     specularMat;    // Material specular times light color
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DFE_COLOR     ambientMat;     // Material specular times light color
    D3DVALUE        inv_theta_minus_phi;
    // Should be QWORD aligned
    D3DVECTOR       halfway;        // Used by directional, parallel-point and 
                                    // spot lights when camera is in infinity
    struct _D3DI_LIGHT *next;       // Next in the active light list
    // Should be QWORD aligned
    D3DFE_COLOR     diffuse;        // Original color scaled to 0 - 255
    D3DFE_COLOR     specular;       // Original color scaled to 0 - 255
    D3DFE_COLOR     ambient;        // Original color scaled to 0 - 255

    LIGHT_VERTEX_FUNC lightVertexFunc;  // Function to light a D3DVERTEX

    D3DVALUE        range_squared;
    D3DVALUE        attenuation0;
    D3DVALUE        attenuation1;
    D3DVALUE        attenuation2;
    D3DVALUE        cos_theta_by_2;
    D3DVALUE        cos_phi_by_2;
    D3DVECTOR       position;       // In the world space
    D3DVECTOR       direction;      // In the world space
    D3DVALUE        range;
    LPVOID          pPSGPData;      // Pointer to a PSGP specific "per light" data
// Microsoft's pipeline specific data
    PFN_LIGHTLOOP   pfnLightFirst;  // Used in multi-loop pipeline for first lights
    PFN_LIGHTLOOP   pfnLightNext;   // Used in multi-loop pipeline for not first lights
} D3DI_LIGHT, *LPD3DI_LIGHT;
//---------------------------------------------------------------------
// Bits for lighting flags (dwLightingFlags
//
const DWORD __LIGHT_VERTEXTRANSFORMED = 1;  // Vertex is in the camera space
const DWORD __LIGHT_NORMALTRANSFORMED = 2;  // Normal is in the camera space
const DWORD __LIGHT_SPECULARCOMPUTED  = 4;
const DWORD __LIGHT_DIFFUSECOMPUTED   = 8;
//---------------------------------------------------------------------
// Members of this structure should be aligned as stated
//
typedef struct _D3DFE_LIGHTING
{
// Temporary data used when computing lighting
    // Should be QWORD aligned
    D3DFE_COLOR       diffuse;
    DWORD             alpha;          // Alpha to use for output vertex color
                                      // (could be overriden by vertex difuse
                                      // color) (0-255) shifted left by 24 bits
    // Should be QWORD aligned
    D3DFE_COLOR       diffuse0;       // Ca*Cma + Cme
    float            *currentSpecTable;
    // Should be QWORD aligned
    D3DFE_COLOR       specular;
    DWORD             outDiffuse;     // Result of lighting
    // Should be QWORD aligned
    D3DVECTOR         model_eye;      // camera position in model or camera space
    DWORD             vertexAmbient;  // Provided with a vertex
    // Should be QWORD aligned
    D3DFE_COLOR       ambientSceneScaled;   // Scene ambient color (scaled 0.0-255.0)
    DWORD             vertexDiffuse;  // Provided with a vertex
    // Should be QWORD aligned
    D3DFE_COLOR       ambientScene;         // Scene ambient color (0.0-1.0)
    DWORD             outSpecular;    // Result of lighting
    // Should be QWORD aligned
    D3DVECTOR         directionToCamera;    // Direction to camera in the model space
                                            // Used in model space lighting
    DWORD             vertexSpecular;       // Provided with a vertex
    // Should be QWORD aligned
    D3DMATERIAL7      material;
    DWORD             dwLightingFlags;
    DWORD             alphaSpecular;  // Alpha to use for output specular vertex color
                                      // (could be overriden by vertex specular
                                      // color) (0-255) shifted left by 24 bits
// End of temporary data
    D3DI_LIGHT       *activeLights;
    int               fog_mode;
    D3DVALUE          fog_density;
    D3DVALUE          fog_start;
    D3DVALUE          fog_end;
    D3DVALUE          fog_factor;     // 255 / (fog_end - fog_start)
    D3DVALUE          specThreshold;  // If a dot product less than this value,
                                      // specular factor is zero
    DWORD             ambient_save;   // Original unscaled color
    int               materialAlpha;  // Current material diffuse alpha (0-255)
                                      // shifted left by 24 bits
    int               materialAlphaS; // Current material specular alpha (0-255)
                                      // shifted left by 24 bits
    DWORD             dwDiffuse0;     // Packed diffuse0    
    DWORD             dwAmbientSrcIndex;    // 0 - diffuse, 1 - specular
    DWORD             dwDiffuseSrcIndex;    // 0 - diffuse, 1 - specular
    DWORD             dwSpecularSrcIndex;   // 0 - diffuse, 1 - specular
    DWORD             dwEmissiveSrcIndex;   // 0 - diffuse, 1 - specular
} D3DFE_LIGHTING;
//---------------------------------------------------------------------
// Some data precomputed for a current viewport
// ATTENTION: If you want to add or re-arrange data, contact IOURIT or ANUJG
//
typedef struct _D3DFE_VIEWPORTCACHE
{
// Coefficients to compute screen coordinates from normalized window
// coordinates
    D3DVALUE scaleX;            // dvWidth
    D3DVALUE scaleY;            // -dvHeight
    D3DVALUE offsetX;           // dvX
    D3DVALUE offsetY;           // dvY + dvHeight
    D3DVALUE scaleZ;            // dvMaxZ - dvMinZ
    D3DVALUE offsetZ;           // dvY + dvHeight
// Min and max window values with gaurd band in pixels
    D3DVALUE minXgb;
    D3DVALUE minYgb;
    D3DVALUE maxXgb;
    D3DVALUE maxYgb;
// Min and max values for viewport window in pixels
    D3DVALUE minX;              // offsetX - scaleX
    D3DVALUE minY;              // offsetY - scaleY
    D3DVALUE maxX;              // offsetX + scaleX
    D3DVALUE maxY;              // offsetY + scaleY
// Coefficients to transform a vertex to perform the guard band clipping
// x*gb11 + w*gb41
// y*gb22 + w*gb42
//
    D3DVALUE gb11;
    D3DVALUE gb22;
    D3DVALUE gb41;
    D3DVALUE gb42;
// Coefficients to apply clipping rules for the guard band clipping
// They are used by clipping routins
// w*Kgbx1 < x < w*Kgbx2
// w*Kgby1 < y < w*Kgby2
//
    D3DVALUE Kgbx1;
    D3DVALUE Kgby1;
    D3DVALUE Kgbx2;
    D3DVALUE Kgby2;

    D3DVALUE dvX;               // dwX
    D3DVALUE dvY;               // dwY
    D3DVALUE dvWidth;           // dwWidth
    D3DVALUE dvHeight;          // dwHeight
// Coefficients to compute screen coordinates from normalized window
// coordinates
    D3DVALUE scaleXi;           // Inverse of scaleX
    D3DVALUE scaleYi;           // Inverse of scaleY
    D3DVALUE scaleZi;           // Inverse of scaleZ
// Min and max values for viewport window in pixels (integer version)
    int      minXi;             // offsetX - scaleX
    int      minYi;             // offsetY - scaleY
    int      maxXi;             // offsetX + scaleX
    int      maxYi;             // offsetY + scaleY
} D3DFE_VIEWPORTCACHE;
//---------------------------------------------------------------------
// Process vertices interface
//
// Bits for process vertices flags
// 8 bits are reserved for Draw Primitive flags
//
// D3DDEV_STRIDE D3DPV_SOA
//      0         1       position.dwStride = number of vertices in SOA
//      0         0       position.dwStride = contiguous vertex size
//      1         0       vertex is not contiguous, all dwStride fields are used
//      1         1       reserved
//      1         1       reserved
//
const DWORD D3DPV_FOG            = 1 << 8;  // Need to apply fog
const DWORD D3DPV_DOCOLORVERTEX  = 1 << 9;  // Need to apply color vertex
const DWORD D3DPV_LIGHTING       = 1 << 10; // Need to apply lighting 
const DWORD D3DPV_SOA            = 1 << 12; // SOA structure is used
const DWORD D3DPV_COLORVERTEX_E  = 1 << 13; // Need to replace emissive material color
const DWORD D3DPV_COLORVERTEX_D  = 1 << 14; // Need to replace diffuse material color
const DWORD D3DPV_COLORVERTEX_S  = 1 << 15; // Need to replace specular material color
const DWORD D3DPV_COLORVERTEX_A  = 1 << 16; // Need to replace ambient material color
// Set by ProcessVertices call with D3DPV_DONOTCOPYDATA flag set
// Specular color should not be copied to the output vertex
const DWORD D3DPV_DONOTCOPYSPECULAR = 1 << 20;
// Set when one pass clipping and vertex processing is used
const DWORD D3DPV_ONEPASSCLIPPING= 1 << 21; 
const DWORD D3DPV_RESERVED1      = 1 << 22;
const DWORD D3DPV_RESERVED2      = 1 << 23;
const DWORD D3DPV_RESERVED3      = 1 << 24;
// This indicates that the primitive is non clipped, but we pretend that it is
// clipped to generate DP2HAL inline primitive. Can only be set by tri fan.
const DWORD D3DPV_NONCLIPPED     = 1 << 25;
// Propagated from dwFEFlags
const DWORD D3DPV_FRUSTUMPLANES_DIRTY = 1 << 26;
// Set if the geometry loop is called from VertexBuffer::ProcessVertices.
// Processing is different because the output buffer FVF format is defined by
// user, not by SetupFVFData function.
const DWORD D3DPV_VBCALL         = 1 << 27;
// Set by ProcessVertices call with D3DPV_DONOTCOPYDATA flag set
// Texture coordinates should not be copied to the output vertex
const DWORD D3DPV_DONOTCOPYTEXTURE = 1 << 28;
// To mark whether we are doing TLVERTEX clipping or not
const DWORD D3DPV_TLVCLIP        = 1 << 29;
// Mictosoft internal !!! Set when only transformation is required 
// (no lightng or texture copy)
const DWORD D3DPV_TRANSFORMONLY  = 1 << 30; 
// Set by ProcessVertices call with D3DPV_DONOTCOPYDATA flag set
// Diffuse color should not be copied to the output vertex
const DWORD D3DPV_DONOTCOPYDIFFUSE = 1 << 31;
// These flags persist from call to call till something cuses them to change
const DWORD D3DPV_PERSIST = D3DPV_FOG                   |
                            D3DPV_LIGHTING              |
                            D3DPV_DONOTCOPYDIFFUSE      |
                            D3DPV_DONOTCOPYSPECULAR     |
                            D3DPV_DONOTCOPYTEXTURE      |
                            D3DPV_TRANSFORMONLY         |
                            D3DPV_TLVCLIP               ;

// Bits for dwDeviceFlags
//
const DWORD D3DDEV_GUARDBAND     = 1 << 1;  // Use guard band clipping
const DWORD D3DDEV_RANGEBASEDFOG = 1 << 2;  // Set if range based fog is enabled
// This bit is set if fog mode is not FOG_NONE and fog is enabled
const DWORD D3DDEV_FOG           = 1 << 3;
const DWORD D3DDEV_FVF           = 1 << 4;  // FVF supported
const DWORD D3DDEV_DONOTSTRIPELEMENTS = 1 << 6; // Copy of D3DFVFCAPS_DONOTSTRIPELEMENTS

// These are bits in dwDeviceFlags that could be changed, but not
// necessary per every primitive.
//
// Set when D3DRENDERSTATE_SPECULARENABLE is TRUE
const DWORD D3DDEV_SPECULARENABLE       = 1 << 11;   
// Set if diffuse color should be interpolated during clipping
const DWORD D3DDEV_INTERPOLATE_COLOR    = 1 << 12;   
// Set if specular color should be interpolated during clipping
const DWORD D3DDEV_INTERPOLATE_SPECULAR = 1 << 13;
// This flag is for PSGP only. PSGP implementation should clear the flag
const DWORD D3DDEV_FRUSTUMPLANES_DIRTY  = 1 << 14;
// This flag is for PSGP only. PSGP implementation should clear the flag
const DWORD D3DDEV_TEXTRANSFORMDIRTY    = 1 << 15; // Need to re-evaluate texture transforms
// The flag is set when the number of output texture coord is greater then the 
// number of the input ones. This could happen when the same texture transform 
// matrix is used with the same input texture coord set. In this case we save
// texture indices from the texture stages in the textureStages and map all 
// indices sequentially.
const DWORD D3DDEV_REMAPTEXTUREINDICES  = 1 << 16;  

// These two flags are for PSGP only. PSGP implementation should clear the flags
const DWORD D3DDEV_TRANSFORMDIRTY       = 1 << 17; // Transform matrix has been changed
const DWORD D3DDEV_LIGHTSDIRTY          = 1 << 18; // Lights have been changed

const DWORD D3DDEV_DONOTCLIP            = 1 << 19; // Clipping is disabled
const DWORD D3DDEV_DONOTUPDATEEXTENTS   = 1 << 20; // Extents computation is disabled
// Set, if driver does not support FVF and there is no texture coordinates in
// the vertex
const DWORD D3DDEV_NOFVFANDNOTEXTURE    = 1 << 21;
// This flag is set if the current TLVbuf is write only
const DWORD D3DDEV_TLVBUFWRITEONLY      = 1 << 22;
// World-view matrix does not have scale, so we can do lighting 
// in the model space
const DWORD D3DDEV_MODELSPACELIGHTING   = 1 << 23;  
// Set if viewer is local (used for lighting)
const DWORD D3DDEV_LOCALVIEWER          = 1 << 24;  
// Set if we wave to normalize normals after transforming them to the camera space
const DWORD D3DDEV_NORMALIZENORMALS     = 1 << 25;  
// Set if we wave to do texture transform
const DWORD D3DDEV_TEXTURETRANSFORM     = 1 << 26; 
// Set if the last draw primitive call was strided
const DWORD D3DDEV_STRIDE               = 1 << 27; 
// Set if D3DRENDERSTATE_COLORVERTEX is TRUE
const DWORD D3DDEV_COLORVERTEX          = 1 << 28;
// Set if position in camera space is always needed
const DWORD D3DDEV_POSITIONINCAMERASPACE= 1 << 29;
// Set if normal in camera space is always needed
const DWORD D3DDEV_NORMALINCAMERASPACE  = 1 << 30;
// Set if D3DRENDERSTATE_LIGHTING is set
const DWORD D3DDEV_LIGHTING             = 1 << 31;
//--------------------------------------------------------------------
// Clipper defines
//

// Six standard clipping planes plus six user defined clipping planes.
// See rl\d3d\d3d\d3dtypes.h.
//

#define MAX_CLIPPING_PLANES 12

// Space for vertices generated/copied while clipping one triangle

#define MAX_CLIP_VERTICES   (( 2 * MAX_CLIPPING_PLANES ) + 3 )

// 3 verts. -> 1 tri, 4 v -> 2 t, N vertices -> (N - 2) triangles

#define MAX_CLIP_TRIANGLES  ( MAX_CLIP_VERTICES - 2 )

const DWORD MAX_FVF_TEXCOORD = 8;

class ClipVertex
{
public:
    D3DVALUE    hx;                 // Clipping space coordinates. Must be in this order
    D3DVALUE    hy;
    D3DVALUE    hz;
    D3DVALUE    hw;
    int         clip;
    D3DCOLOR    color;
    D3DCOLOR    specular;
    D3DVALUE    sx;                 // Screen space coordinates. Must be in this order
    D3DVALUE    sy;
    D3DVALUE    sz;
    D3DVALUE    rhw;
    ClipVertex *next;
    D3DVALUE    tex[MAX_FVF_TEXCOORD*4];
};

typedef struct _ClipTriangle
{
    ClipVertex  *v[3];
} ClipTriangle;

typedef struct _D3DI_CLIPSTATE
{
    ClipVertex  *clip_vbuf1[MAX_CLIP_VERTICES];
    ClipVertex  *clip_vbuf2[MAX_CLIP_VERTICES];
    ClipVertex **current_vbuf;  // clip_vbuf1 or clip_vbuf2
    ClipVertex  clip_vertices[MAX_CLIP_VERTICES];
    CBufferDDS   clipBuf;      // Used for TL vertices, generated by the clipper
    CBufferDDS   clipBufPrim;  // Used for primitives, generated by the clipper
                              // for execute buffers
    int         clip_vertices_used;
    DWORD       clip_color;
    DWORD       clip_specular;
    LPDIRECTDRAWSURFACE lpDDExeBuf; // Current user execute buffer
    LPVOID      lpvExeBufMem;       // Current memory for user execute buffer
} D3DI_CLIPSTATE, *LPD3DI_CLIPSTATE;

// These bit are set when a vertex is clipped by a frustum plane

#define CLIPPED_LEFT    (D3DCLIP_GEN5 << 1)
#define CLIPPED_RIGHT   (D3DCLIP_GEN5 << 2)
#define CLIPPED_TOP     (D3DCLIP_GEN5 << 3)
#define CLIPPED_BOTTOM  (D3DCLIP_GEN5 << 4)
#define CLIPPED_FRONT   (D3DCLIP_GEN5 << 5)
#define CLIPPED_BACK    (D3DCLIP_GEN5 << 6)

#define CLIPPED_ENABLE  (D3DCLIP_GEN5 << 7) /* wireframe enable flag */

// These bit are set when a vertex is clipped by a user clipping plane

const DWORD CLIPPED_GEN0 = D3DCLIP_GEN5 << 8;
const DWORD CLIPPED_GEN1 = D3DCLIP_GEN5 << 9;
const DWORD CLIPPED_GEN2 = D3DCLIP_GEN5 << 10;
const DWORD CLIPPED_GEN3 = D3DCLIP_GEN5 << 11;
const DWORD CLIPPED_GEN4 = D3DCLIP_GEN5 << 12;
const DWORD CLIPPED_GEN5 = D3DCLIP_GEN5 << 13;

// Guard band clipping bits
//
// A guard bit is set when a point is out of guard band
// Guard bits should be cleared before a call to clip a triangle, because
// they are the same as CLIPPED_... bits
//
// Example of clipping bits setting for X coordinate:
//
// if -w < x < w           no clipping bit is set
// if -w*ax1 < x <= -w     D3DCLIP_LEFT bit is set
// if x < -w*ax1           __D3DCLIPGB_LEFT bit is set
//
#define __D3DCLIPGB_LEFT    (D3DCLIP_GEN5 << 1)
#define __D3DCLIPGB_RIGHT   (D3DCLIP_GEN5 << 2)
#define __D3DCLIPGB_TOP     (D3DCLIP_GEN5 << 3)
#define __D3DCLIPGB_BOTTOM  (D3DCLIP_GEN5 << 4)
#define __D3DCLIPGB_ALL (__D3DCLIPGB_LEFT | __D3DCLIPGB_RIGHT | \
                         __D3DCLIPGB_TOP | __D3DCLIPGB_BOTTOM)

const DWORD __D3DCLIP_USERPLANES =  D3DCLIP_GEN0 | D3DCLIP_GEN1 | D3DCLIP_GEN2 | 
                                    D3DCLIP_GEN3 | D3DCLIP_GEN4 | D3DCLIP_GEN5;
// If only these bits are set, then this point is inside the guard band
//
#define __D3DCLIP_INGUARDBAND (D3DCLIP_LEFT | D3DCLIP_RIGHT | \
                               D3DCLIP_TOP  | D3DCLIP_BOTTOM)

//---------------------------------------------------------------------
// Bits in the dwFlags2 
//
// The bit is set when the texture transform is enabled
const DWORD __FLAGS2_TEXTRANSFORM0 = 1 << 0;
const DWORD __FLAGS2_TEXTRANSFORM1 = 1 << 1;
const DWORD __FLAGS2_TEXTRANSFORM2 = 1 << 2;
const DWORD __FLAGS2_TEXTRANSFORM3 = 1 << 3;
const DWORD __FLAGS2_TEXTRANSFORM4 = 1 << 4;
const DWORD __FLAGS2_TEXTRANSFORM5 = 1 << 5;
const DWORD __FLAGS2_TEXTRANSFORM6 = 1 << 6;
const DWORD __FLAGS2_TEXTRANSFORM7 = 1 << 7;

const DWORD __FLAGS2_TEXTRANSFORM = __FLAGS2_TEXTRANSFORM0 |
                                    __FLAGS2_TEXTRANSFORM1 |
                                    __FLAGS2_TEXTRANSFORM2 |
                                    __FLAGS2_TEXTRANSFORM3 |
                                    __FLAGS2_TEXTRANSFORM4 |
                                    __FLAGS2_TEXTRANSFORM5 |
                                    __FLAGS2_TEXTRANSFORM6 |
                                    __FLAGS2_TEXTRANSFORM7;
// The bit is set when the texture coordinate set is taken from the vertex data
// (position or normal)
const DWORD __FLAGS2_TEXGEN0 = 1 << 16;
const DWORD __FLAGS2_TEXGEN1 = 1 << 17;
const DWORD __FLAGS2_TEXGEN2 = 1 << 18;
const DWORD __FLAGS2_TEXGEN3 = 1 << 19;
const DWORD __FLAGS2_TEXGEN4 = 1 << 20;
const DWORD __FLAGS2_TEXGEN5 = 1 << 21;
const DWORD __FLAGS2_TEXGEN6 = 1 << 22;
const DWORD __FLAGS2_TEXGEN7 = 1 << 23;

const DWORD __FLAGS2_TEXGEN = __FLAGS2_TEXGEN0 |
                              __FLAGS2_TEXGEN1 |
                              __FLAGS2_TEXGEN2 |
                              __FLAGS2_TEXGEN3 |
                              __FLAGS2_TEXGEN4 |
                              __FLAGS2_TEXGEN5 |
                              __FLAGS2_TEXGEN6 |
                              __FLAGS2_TEXGEN7;
//---------------------------------------------------------------------
#define __TEXTURETRANSFORMENABLED(pv) pv->dwFlags2 & __FLAGS2_TEXTRANSFORM

const DWORD __MAXUSERCLIPPLANES = 6;
//---------------------------------------------------------------------
// Visible states, input and output data
//
class D3DFE_PROCESSVERTICES
{
public:
    D3DFE_PROCESSVERTICES();
    virtual HRESULT SetRenderStateI(D3DRENDERSTATETYPE, DWORD) = 0;
// State
    // Should be QWORD aligned
    D3DMATRIXI mTexture[D3DDP_MAXTEXCOORD];  // Texture transform;
    D3DMATRIXI mCTM2[3];
    D3DMATRIXI mWV2[3];
    D3DMATRIXI mWVI2[3];
    D3DMATRIXI mWV;                 // Transforms to camera space (Mworld*Mview)
    D3DMATRIXI mWVI;                // Inverse mWV
    D3DMATRIXI mCTM;                // Current Transformation Matrix
                                    // supported by driver
    // Should be QWORD aligned
    D3DFE_LIGHTING lighting;        // Lighting state
    // Should be QWORD aligned
    D3DFE_VIEWPORTCACHE vcache;     // Data, computed fromto viewport settings
    DWORD    dwClipUnion;           // OR of all vertex clip flags
    DWORD    dwClipIntersection;    // AND of all vertex clip flags
    DWORD    dwTextureIndexToCopy;  // Used for not FVF devices. Used by PSGP
    D3DVALUE dvExtentsAdjust;       // Replicated here from device caps

    // Current texture stage vector
    LPVOID   *pD3DMappedTexI;
    D3DI_CLIPSTATE  ClipperState;   // State for triangle/line clipper
    union {
        D3DDP_PTRSTRIDE normal;
        DWORD dwSOAStartVertex;
    };
    D3DDP_PTRSTRIDE diffuse;
    // Cache line should start here
    D3DPRIMITIVETYPE primType;
    DWORD   dwNumVertices;  // Number of vertices to process
    DWORD   dwFlags;        // Flags word describing what to do
    // Location of the first vertex in the vertex buffer (DP2 DDI)
    // ATTENTION May be we can get rid of it?
    DWORD   dwVertexBase;
    DWORD   dwNumIndices;           // 0 for non-indexed primitive
    LPWORD  lpwIndices;
    DWORD   dwNumPrimitives;
    DWORD   dwDP2VertexCount;       // Number of vertices in DP2 vertex buffer
                                    // Internal data for Microsoft implementation

    // Cache line should start here
    DWORD   dwVIDIn;        // Vertex ID of input vertices
    DWORD   dwDeviceFlags;          // Flags that are constant per device
                                    // D3DPV_.. and primitive flags are combined
    DWORD   dwOutputSize;   // Output vertex size
    DWORD   dwFEFlags;      // MS internal use Only!!
    DWORD   dwVIDOut;       // Vertex ID of output vertices
    LPVOID  lpvOut;                 // Output pointer (output always packed)

    DWORD   dwVertexPoolSize;       // Size of vertices in the un-clipped part of a primitive
                                    // in bytes, put to the DP2 vertex buffer
                                    // Internal data for Microsoft implementation
    union {
        D3DDP_PTRSTRIDE position;   // dwStride should always be set !!!
        D3DDP_PTRSTRIDE SOA;
    };
    D3DFE_CLIPCODE* lpClipFlags;          // Clip flags to output
    DWORD   nTexCoord;      // Number of the input texture coordinate sets
    DWORD   nOutTexCoord;   // Number of the output texture coordinate sets to process.
                            // WARNING. It could be different from the texture count in dwVIDOut
                            // (it could be zero for example when dwVIDOut has 1 texture coord set).
                            // If D3DDEV_REMAPTEXTUREINDICES is set this is equal
                            // to the number of active texture stages
    // Total size of all output texture coordinates in bytes
    DWORD   dwTextureCoordSizeTotal;    
    D3DDP_PTRSTRIDE specular;
    D3DDP_PTRSTRIDE textures[D3DDP_MAXTEXCOORD];
    // Size of output texture coordinate sets in bytes
    DWORD   dwTextureCoordSize[D3DDP_MAXTEXCOORD];
    // Size of input texture coordinate sets in bytes
    DWORD   dwInpTextureCoordSize[D3DDP_MAXTEXCOORD];
// Output
    LPDWORD  lpdwRStates;           // Current render state vector
    D3DRECTV rExtents;              // Extents rectangle to update, if required
    D3DFE_TEXTURESTAGE textureStage[D3DDP_MAXTEXCOORD]; // Texture state stages
    DWORD   dwNumTextureStages;     // Used when we have to re-map texture indices
    // This array is used when we do not do re-mapping of texture coordinates
    D3DMATRIXI *pmTexture[D3DDP_MAXTEXCOORD]; 
    D3DVECTORH userClipPlane[__MAXUSERCLIPPLANES];
    DWORD   dwFlags2;       // Low 8 bits are texture transform enable: 
                            // bit 0 corresponds to the texture stage 0
                            // Bits 8-15 are for user clipping plane
                            // Bits 16-23 are set if corresponding texture coord set
                            // is taken from the vertex data (position or normal)
    DWORD   dwNumVerBlends;                 // Number of weights for vertex blending
    DWORD   dwMaxUserClipPlanes;
    virtual HRESULT DrawPrim()=0;           // Use to pass non-indexed primitives to the driver
    virtual HRESULT DrawIndexPrim()=0;      // Use to pass indexed primitives to driver
    virtual HRESULT DrawClippedPrim()=0;    // Use to pass clipped non-indexed primitives to driver
// Internal data for Microsoft implementation
    DWORD   texOffset;              // Offsets in the input FVF vertex. Recomputed
    DWORD   normalOffset;           // when FVF is changed.
    DWORD   diffuseOffset;          // 
    DWORD   specularOffset;
    DWORD   texOffsetOut;           // Offsets in the output FVF vertex. Recomputed
    DWORD   diffuseOffsetOut;       // when FVF is changed.
    DWORD   specularOffsetOut;
    DWORD   dwClipMaskOffScreen;    // When and this mask with the clip code we 
                                    // have bits that are outside the guard band
    ClipVertex  clipVer[VER_IN_BATCH];  // Clip vertices. Used in processing 
                                        // and clipping in the one loop
    DWORD   dwFirstClippedVertex;   // Index of the first vertex with non-zero clip code
    DWORD dwMaxTextureIndices;      // Max number of texture coord sets
};
//---------------------------------------------------------------------
// Prototype for the function to be written for a given processor implementation
//
// Returns clip intersection.
//

class ID3DFE_PVFUNCS
{
public:
    virtual ~ID3DFE_PVFUNCS() { };
    virtual DWORD ProcessVertices(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessPrimitive(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessIndexedPrimitive(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT OptimizeVertexBuffer
        (DWORD  dwFVFID,            // Vertex type. XYZ position is allowed
         DWORD  dwNumVertices,      // Number of vertices
         DWORD  dwVertexSize,       // Vertex size in bytes
         LPVOID lpSrcBuffer,        // Source buffer.
         LPVOID lpDstBuffer,        // Output buffer.
         DWORD  dwFlags)            // Should be zero for now
        {return E_NOTIMPL;}
    // Returns number of bytes to allocate for an optimized vertex buffer
    // This function is called before OptimizeVertexBuffer
    virtual DWORD  ComputeOptimizedVertexBufferSize
        (DWORD dwFVF,               // Vertex type
         DWORD dwVertexSize,        // Vertex size in bytes
         DWORD dwNumVertices)       // Number of vertices
        {return 0;}
    // This function could be used if PSGP doesn't want to implement complete
    // clipping pipeline
    // Parameters:
    //      pv  - state data
    //      tri - triangle to clip
    //      clipVertexPointer - pointer to an array of pointers to
    //                          generated vertices
    // Returns:
    //      Number of vertices in clipped triangle
    //      0, if the triangle is off screen
    virtual int ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                   ClipTriangle *tri,
                                   ClipVertex ***clipVertexPointer) = 0;
    virtual HRESULT ComputeSphereVisibility( LPD3DFE_PROCESSVERTICES pPV,
                                             LPD3DVECTOR lpCenters,
                                             LPD3DVALUE lpRadii,
                                             DWORD dwNumSpheres,
                                             DWORD dwFlags,
                                             LPDWORD lpdwReturnValues) = 0;
    virtual HRESULT ProcessTriangleList(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessTriangleFan(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessTriangleStrip(LPD3DFE_PROCESSVERTICES)=0;
};

typedef ID3DFE_PVFUNCS *LPD3DFE_PVFUNCS;

//---------------------------------------------------------------------
// Direct3D implementation of PVFUNCS
//
class D3DFE_PVFUNCS : public ID3DFE_PVFUNCS
{
public:
    DWORD ProcessVertices(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessPrimitive(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessIndexedPrimitive(LPD3DFE_PROCESSVERTICES);
    int ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                   ClipTriangle *tri,
                                   ClipVertex ***clipVertexPointer);
    HRESULT ComputeSphereVisibility( LPD3DFE_PROCESSVERTICES pPV,
                                             LPD3DVECTOR lpCenters,
                                             LPD3DVALUE lpRadii,
                                             DWORD dwNumSpheres,
                                             DWORD dwFlags,
                                             LPDWORD lpdwReturnValues);
    HRESULT ProcessTriangleList(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessTriangleFan(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessTriangleStrip(LPD3DFE_PROCESSVERTICES);
private:
    HRESULT ProcessLineStrip(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessLineList(D3DFE_PROCESSVERTICES *pv);
};

// GeometrySetup function takes a DWORD describing the dirty bits and the new state vector
// and passes back the 3 new leaf routines to use.
typedef HRESULT (D3DAPI *LPD3DFE_CONTEXTCREATE)(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);

// Global pointer to Processor specific PV setup routine
// This is defined in dlld3d.cpp
extern LPD3DFE_CONTEXTCREATE pfnFEContextCreate;

#endif // _D3DFE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\testfile.h ===
//----------------------------------------------------------------------------
//
// testfile.h
//
// Defines for file with test data.
//
// File format:
//      File contains chunks of data. Each chunk has four-byte ID, four-byte data size field and
//      "size" number of bytes of data.
//      Chunks:
//          ID          Meaning           Data
//          1       Scene capture       DWORD flags
//          2       Render state        DWORD states count
//                                      States (D3DSTATE*count)
//          3       Render primitive    DWORD status
//                                      D3DPRIMITIVETYPE primitive type
//                                      DWORD number of vertices
//                                      D3DVERTEXTYPE vertex type
//                                      D3DINSTRUCTION
//                                        Primitive record (D3DPOINT, D3DLINE ...)
//                                        Primitive vertices (TLVERTEX)
//                                        ...
//          4       Draw one primitive  D3DPRIMITIVETYPE primitive type
//                                      DWORD number of vertices
//                                      D3DVERTEXTYPE vertex type
//                                      Vertices
//          5       Draw one indexed    D3DPRIMITIVETYPE primitive type
//                      primitive       DWORD number of vertices
//                                      DWORD number of indices
//                                      D3DVERTEXTYPE vertex type
//                                      Vertices
//                                      Indices (WORD)
//          6       Draw primitives     The same as DDI data, but without 32 byte
//                                      alignment.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#ifndef _TESTFILE_H_
#define _TESTFILE_H_

// TF stands for "TestFile"
typedef struct
{
    DWORD id;           // record ID
    DWORD size;         // size of data in bytes (exclude size of REC_HEADER)
} TF_HEADER;

// ID for test file records
const DWORD TFID_SCENECAPTURE               = 1;
const DWORD TFID_RENDERSTATE                = 2;
const DWORD TFID_RENDERPRIMITIVE            = 3;
const DWORD TFID_DRAWONEPRIMITIVE           = 4;
const DWORD TFID_DRAWONEINDEXEDPRIMITIVE    = 5;
const DWORD TFID_DRAWPRIMITIVES             = 6;
const DWORD TFID_DRAWPRIMITIVES2            = 7;

// Fixed size record headers
typedef struct
{
    DWORD               status;
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
} TFREC_RENDERPRIMITIVE;

typedef struct
{
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
    DWORD               dwFlags;
} TFREC_DRAWONEPRIMITIVE;

typedef struct
{
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
    DWORD               indexCount;
    DWORD               dwFlags;
} TFREC_DRAWONEINDEXEDPRIMITIVE;

typedef struct
{
    DWORD               dwFlags;
} TFREC_DRAWPRIMITIVES;

typedef struct
{
    DWORD               dwFlags;
} TFREC_DRAWPRIMITIVES2;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\d3dmem.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dmem.h
 *  Content:    Direct3D memory access include file
 *
 ***************************************************************************/
#ifndef _D3DMEM_H_
#define _D3DMEM_H_

 class DIRECT3DDEVICEI;

 /*
 * Register a set of functions to be used in place of malloc, realloc
 * and free for memory allocation.  The functions D3DMalloc, D3DRealloc
 * and D3DFree will use these functions.  The default is to use the
 * ANSI C library routines malloc, realloc and free.
 */
typedef LPVOID (*D3DMALLOCFUNCTION)(size_t);
typedef LPVOID (*D3DREALLOCFUNCTION)(LPVOID, size_t);
typedef VOID (*D3DFREEFUNCTION)(LPVOID);

/*
 * Allocate size bytes of memory and return a pointer to it in *p_return.
 * Returns D3DERR_BADALLOC with *p_return unchanged if the allocation fails.
 */
HRESULT D3DAPI      D3DMalloc(LPVOID* p_return, size_t size);

/*
 * Change the size of an allocated block of memory.  A pointer to the
 * block is passed in in *p_inout.  If *p_inout is NULL then a new
 * block is allocated.  If the reallocation is successful, *p_inout is
 * changed to point to the new block.  If the allocation fails,
 * *p_inout is unchanged and D3DERR_BADALLOC is returned.
 */
HRESULT D3DAPI      D3DRealloc(LPVOID* p_inout, size_t size);

/*
 * Free a block of memory previously allocated with D3DMalloc or
 * D3DRealloc.
 */
VOID D3DAPI     D3DFree(LPVOID p);

HRESULT MallocAligned(void** p_return, size_t size);
void FreeAligned(void* p);
HRESULT ReallocAligned(void** p_inout, size_t size);

/* Base class for all D3D classes to use our special allocation functions everywhere */
class CD3DAlloc
{
public:
    void* operator new(size_t s)
    {
        void *p;
        MallocAligned(&p,s);
        return p;
    };
    void operator delete(void* p)
    {
        FreeAligned(p);
    };
};
//---------------------------------------------------------------------
// This class manages growing buffer, aligned to 32 byte boundary
// Number if bytes should be power of 2.
// D3DMalloc is used to allocate memory
//
class CAlignedBuffer32
{
public:
    CAlignedBuffer32()  {size = 0; allocatedBuf = 0; alignedBuf = 0;}
    ~CAlignedBuffer32() {if (allocatedBuf) D3DFree(allocatedBuf);}
    // Returns aligned buffer address
    LPVOID GetAddress() {return alignedBuf;}
    // Returns aligned buffer size
    DWORD GetSize() {return size;}
    HRESULT Grow(DWORD dwSize);
    HRESULT CheckAndGrow(DWORD dwSize)
        {
            if (dwSize > size)
                return Grow(dwSize + 1024);
            else
                return D3D_OK;
        }
protected:
    LPVOID allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size;
};

// Forward declarations
class DIRECT3DDEVICEI;
class CDirect3DVertexBuffer;
class CDirect3DDeviceIDP2;
//----------------------------------------------------------------------
// This class manages a growing buffer using DDraw Surfaces.
class CBufferDDS
{
protected:
    LPDIRECTDRAWSURFACE allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size;
public:
    CBufferDDS()
    {
        size = 0;
        allocatedBuf = 0;
        alignedBuf = 0;
    }
    ~CBufferDDS()
    {
        if (allocatedBuf)
            allocatedBuf->Release();
    }
    // Returns aligned buffer address
    LPVOID GetAddress()
    {
        return (LPBYTE)alignedBuf;
    }
    // Returns aligned buffer size
    DWORD GetSize()
    {
        return size;
    }
    LPDIRECTDRAWSURFACE GetDDS()
    {
        return allocatedBuf;
    }
    HRESULT CheckAndGrow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize)
    {
        if (dwSize > size)
            return Grow(lpDevI, dwSize + 1024);
        else
            return D3D_OK;
    }
    HRESULT Grow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize);
    // define these later on in this file after CDirect3DVertexBuffer is defined
};
//----------------------------------------------------------------------
// This class manages a growing vertex buffer.
// Allocate it in driver friendly memory.
// Do not use except for DP2 DDI
class CBufferVB
{
protected:
    LPDIRECT3DVERTEXBUFFER7 allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size, base;
public:
    CBufferVB()
    {
        size = 0;
        allocatedBuf = 0;
        alignedBuf = 0;
        base = 0;
    }
    ~CBufferVB()
    {
        if (allocatedBuf)
            allocatedBuf->Release();
    }
    // Returns aligned buffer address
    LPVOID GetAddress()
    {
        return (LPBYTE)alignedBuf + base;
    }
    // Returns aligned buffer size
    DWORD GetSize() { return size - base; }
    HRESULT Grow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize);
    DWORD& Base() { return base; }
    // define these later on in this file after CDirect3DVertexBuffer is defined
    inline CDirect3DVertexBuffer* GetVBI();
    inline LPDIRECTDRAWSURFACE GetDDS();
    HRESULT CheckAndGrow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize)
        {
            if (dwSize > size)
                return Grow(lpDevI, dwSize + 1024);
            else
                return D3D_OK;
        }
    friend CDirect3DDeviceIDP2;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\fltval.h ===
/*
 * $Id: fltval.h,v 1.7 1995/12/01 18:07:12 dave Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef __D3DFLOAT__
#define __D3DFLOAT__

/*
 * Convert a value to fixed point at given precision.
 */
#define VALTOFXP(d,prec) ((int)SAFE_FLOAT_TO_INT((d) * (double)(1 << (prec))))
extern double RLDDIConvertIEEE[];

__inline int QVALTOFXP(double d, int prec)
{
    double tmp = d+RLDDIConvertIEEE[prec];
    return *(int *)&tmp;
}

/*
 * Convert from fixed point to value.
 */
#define FXPTOVAL(f,prec) ((float)(((double)(f)) / (double)(1 << (prec))))

/*
 * Convert from integer to fixed point.
 */
#define ITOFXP(i,prec)	((i) << (prec))

/*
 * Convert from fixed point to integer, truncating.
 */
#define FXPTOI(f,prec)	((int)((f) >> (prec)))

/*
 * Convert from fixed point to nearest integer greater or equal to f.
 */
#define FXPCEIL(f,prec) ((int)(((f) + (1 << (prec)) - 1) >> (prec)))

/*
 * Convert a double to fixed point at given precision.
 */
#define DTOVALP(d,prec) ((float) (d))

/*
 * Convert from fixed point to double.
 */
#define VALPTOD(f,prec)	((double) (f))

/*
 * Convert from integer to fixed point.
 */
#define ITOVALP(i,prec) ((float)(i))

/*
 * Convert from fixed point to integer, truncating.
 */
#define VALPTOI(f,prec)	((int)(f))

/*
 * Convert from fixed point to integer, rounding.
 */
#define VALPROUND(f,prec) ((int)((f) + 0.5))

/*
 * Convert between fixed point precisions.
 */
#define VALPTOVALP(f,from,to) (f)

/*
 * Increase the precision of a value.
 */
#define INCPREC(f,amount)	(f)

/*
 * Decrease the precision of a value.
 */
#define DECPREC(f,amount)	(f)

#define RLDDIFMul8(a, b)		((a) * (b))

#define RLDDIFMul12(a, b)		((a) * (b))

#define RLDDIFMul16(a, b)		((a) * (b))

#define RLDDIFMul24(a, b)		((a) * (b))

#define RLDDIFInvert12(a)		(1.0f / (a))

#define RLDDIFInvert16(a)		(1.0f / (a))

#define RLDDIFInvert24(a)		(1.0f / (a))

#define RLDDIFMulDiv(a, b, c)	((a) * (b) / (c))

#define RLDDIFDiv24(a, b)		((a) / (b))

#define RLDDIFDiv16(a, b)		((a) / (b))

#define RLDDIFDiv12(a, b)		((a) / (b))

#define RLDDIFDiv8(a, b)		((a) / (b))

/*
 * RLDDIFDiv8, checking for overflow.
 */
#define RLDDICheckDiv8(a, b)      ((a) / (b))

/*
 * RLDDIFDiv16, checking for overflow.
 */
#define RLDDICheckDiv16(a, b)	((a) / (b))

#define RLDDIGetZStep(zl, zr, zm, h3, h1) \
	(((zr - zm) * h3 - (zl - zm) * h1) / denom)

#include <limits.h>
#if defined(i386)
#define SAFE_FLOAT_TO_INT(f)	((f) > LONG_MAX	   \
				 ? LONG_MAX				           \
				 : (f) < LONG_MIN			       \
				 ? LONG_MIN				           \
                                 : (int)(f))
#else
#define SAFE_FLOAT_TO_INT(f)    ((int)(f))
#endif

/*
 * Normal precision used to store numbers.
 */
#define NORMAL_PREC     16
#define DTOVAL(d)       DTOVALP(d,NORMAL_PREC)
#define VALTOD(f)       VALPTOD(f,NORMAL_PREC)
#define ITOVAL(i)       ITOVALP(i,NORMAL_PREC)
#define VALTOI(f)       VALPTOI(f,NORMAL_PREC)
#define VALROUND(f)     VALPROUND(f,NORMAL_PREC)
#define VALTOFX(f)      VALTOFXP(f,NORMAL_PREC)
#define FXTOVAL(f)      FXPTOVAL(f,NORMAL_PREC)
#define ITOFX(i)        ITOFXP(i,NORMAL_PREC)
#define FXTOI(f)        FXPTOI(f,NORMAL_PREC)
#define FXROUND(f)      FXPROUND(f,NORMAL_PREC)
#define FXFLOOR(f)      FXPTOI(f,NORMAL_PREC)
#define FXCEIL(f)       FXPCEIL(f,NORMAL_PREC)
#define VALTOFX24(f)    VALTOFXP(f,24)
#define FX24TOVAL(f)    FXPTOVAL(f,24)
#define VALTOFX20(f)    VALTOFXP(f,20)
#define FX20TOVAL(f)    FXPTOVAL(f,20)
#define VALTOFX12(f)    VALTOFXP(f,12)
#define FX12TOVAL(f)    FXPTOVAL(f,12)
#define VALTOFX8(f)     VALTOFXP(f,8)
#define FX8TOVAL(f)     FXPTOVAL(f,8)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\d3di.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3di.hpp
 *  Content:    Direct3D internal include file
 *
 *  $Id:
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *
 ***************************************************************************/

#ifndef _D3DI_HPP
#define _D3DI_HPP

#include "ddrawp.h"
#include "d3dp.h"
#include "d3dmem.h"

#if !defined(BUILD_DDDDK)
extern "C" {
#include "ddrawi.h"
};
#include "object.h"
#include "lists.hpp"

#include <d3ditype.h>
#include <d3dutil.h>

#include <d3dfe.hpp>

// Allow vtable hacking
#define VTABLE_HACK

// DEBUG_PIPELINE is defined to check performance and to allow to choose
// diifferent paths in the geometry pipeline

#if DBG
#define DEBUG_PIPELINE
#endif // DBG

#ifndef WIN95
// This is NT only
// Comment this out to disable registry based VidMemVB enables
#define __DISABLE_VIDMEM_VBS__
#endif

//--------------------------------------------------------------------
const DWORD __INIT_VERTEX_NUMBER = 1024;// Initial number of vertices in TL and
                                        // clip flag buffers
const DWORD __MAX_VERTEX_SIZE = 180;    // Max size of FVF vertex in bytes
//--------------------------------------------------------------------
/*
 * Registry defines
 */
#define RESPATH    "Software\\Microsoft\\Direct3D\\Drivers"
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

#define STATS_FONT_FACE "Terminal"
#define STATS_FONT_SIZE 9

#if COLLECTSTATS
DWORD BytesDownloaded(LPDDRAWI_DDRAWSURFACE_LCL lpLcl, LPRECT lpRect);
#endif

extern HINSTANCE hGeometryDLL;

/*
 * CPU family and features flags
 */
extern DWORD dwCPUFamily, dwCPUFeatures;
extern char szCPUString[];

// MMX available
#define D3DCPU_MMX          0x00000001L

// FCOMI and CMOV are both supported
#define D3DCPU_FCOMICMOV    0x00000002L

// Reads block until satisfied
#define D3DCPU_BLOCKINGREAD 0x00000004L

// Extended 3D support available
#define D3DCPU_X3D          0x00000008L

// Pentium II CPU
#define D3DCPU_PII          0x000000010L

// Streaming SIMD Extensions (aka Katmai) CPU
#define D3DCPU_SSE          0x000000020L

// Intel Willamette CPU
#define D3DCPU_WLMT         0x000000040L

#define DEFAULT_GAMMA   DTOVAL(1.4)

/*
    INDEX_BATCH_SCALE is the constant which is used by DrawIndexedPrim
    to deterimine if the number of primitives being drawn is small
    relative to the number of vertices being passed.  If it is then
    the prims are dereferenced in batches and sent to DrawPrim.
*/
#define INDEX_BATCH_SCALE   2

#endif // BUILD_DDDDK

#if !defined(BUILD_DDDDK)

class DIRECT3DDEVICEI;
class CStateSets;

typedef class DIRECT3DI *LPDIRECT3DI;
typedef class DIRECT3DDEVICEI *LPDIRECT3DDEVICEI;
typedef class DIRECT3DLIGHTI *LPDIRECT3DLIGHTI;
typedef class DIRECT3DTEXTUREI *LPDIRECT3DTEXTUREI;
typedef class CDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFERI;

class CDirect3DUnk : public IUnknown
{
public:
    unsigned refCnt;    /* Reference count object */
public:
    LPDIRECT3DI pD3DI;
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();
};

class DIRECT3DI :  public IDirect3D7,
                   public CD3DAlloc
{
public: //Private Data

    /*** Object Relations ***/

    /* Devices */
    int             numDevs;/* Number of devices */
    struct _devices { DIRECT3DDEVICEI* Root;} devices;
    /* Associated IDirect3DDevices */

    /* Vertex Buffers */
    int             numVBufs; /* Number of vertex buffers */
    LIST_ROOT(_vbufs, CDirect3DVertexBuffer) vbufs;
    /* Created IDirect3DVertexBuffers */

    /* Textures */
    LIST_ROOT(_textures, DIRECT3DTEXTUREI) textures;

    /*** Object Data ***/

    CDirect3DUnk mD3DUnk;

    //RLDDIRegistry*      lpReg;  /* Registry */
    struct _D3DBUCKET  *lpFreeList; /* Free linked list  */
    struct _D3DBUCKET  *lpBufferList;/* link list of headers of big chunks allocated*/
    class TextureCacheManager   *lpTextureManager;
    /*
     * DirectDraw Interface
     */
    LPDIRECTDRAW lpDD;
    LPDIRECTDRAW7 lpDD7;    /* needed for CreateSurface to get LPDIRECTDRAWSURFACE7 */

    // HACK.  D3D needs a DD1 DDRAWI interface because it uses CreateSurface1 internally
    // for exebufs, among other things.   But the D3DI object cannot keep a reference
    // to its parent DD object because it is aggegrated with the DD obj, so that would constitute
    // a circular reference that would prevent deletion. So QI for DD1 interface, copy it into D3DI
    // and release it, then point lpDD at the copy. (disgusting)
    // More disgusting still: These need to be large enough to hold ddrawex interface structs

    DDRAWI_DIRECTDRAW_INT DDInt_DD1;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */

#if COLLECTSTATS
    // For displaying stats
    HFONT m_hFont;

    // Various counters for stats
    DWORD m_setpris, m_setLODs, m_texCreates, m_texDestroys;
#endif

#ifdef __DISABLE_VIDMEM_VBS__
    BOOL bDisableVidMemVBs;
#endif //__DISABLE_VIDMEM_VBS__

public: //Private methods
    DIRECT3DI(); // Constructor called Direct3DCreate()
    ~DIRECT3DI(); // Destructor called by CDirect3DUnk::Release()
    HRESULT Initialize(IUnknown* pUnkOuter, LPDDRAWI_DIRECTDRAW_INT pDDrawInt);
    HRESULT EnumDevices(LPD3DENUMDEVICESCALLBACK7, LPVOID, DWORD, DWORD);
    // Internal CreateVertexBuffer
    HRESULT CreateVertexBufferI(LPD3DVERTEXBUFFERDESC, LPDIRECT3DVERTEXBUFFER7*, DWORD);
    // Device flushing
    HRESULT FlushDevicesExcept(LPDIRECT3DDEVICEI pDev);
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    HRESULT D3DAPI EnumDevices(LPD3DENUMDEVICESCALLBACK7, LPVOID);
    HRESULT D3DAPI CreateDevice(REFCLSID, LPDIRECTDRAWSURFACE7, LPDIRECT3DDEVICE7*);
    HRESULT D3DAPI CreateVertexBuffer(LPD3DVERTEXBUFFERDESC, LPDIRECT3DVERTEXBUFFER7*, DWORD);
    HRESULT D3DAPI EnumZBufferFormats(REFCLSID, LPD3DENUMPIXELFORMATSCALLBACK, LPVOID);
    HRESULT D3DAPI EvictManagedTextures();

#if COLLECTSTATS
    // Stats collection funcs
    void ResetTexStats();
    void GetTexStats(LPD3DDEVINFO_TEXTURING);
    void IncNumSetPris()
    {
        ++m_setpris;
    }
    void IncNumSetLODs()
    {
        ++m_setLODs;
    }
    void IncNumTexCreates()
    {
        ++m_texCreates;
    }
    void IncNumTexDestroys()
    {
        ++m_texDestroys;
    }
    DWORD GetNumSetPris()
    {
        return m_setpris;
    }
    DWORD GetNumSetLODs()
    {
        return m_setLODs;
    }
    DWORD GetNumTexCreates()
    {
        return m_texCreates;
    }
    DWORD GetNumTexDestroys()
    {
        return m_texDestroys;
    }
    DWORD GetNumTexLocks()
    {
        return ((LPDDRAWI_DIRECTDRAW_INT)lpDD7)->lpLcl->dwNumTexLocks;
    }
    DWORD GetNumTexGetDCs()
    {
        return ((LPDDRAWI_DIRECTDRAW_INT)lpDD7)->lpLcl->dwNumTexGetDCs;
    }
#endif
};

typedef DIRECT3DI* LPDIRECT3DI;

#include "d3dhal.h"
#include "halprov.h"

//---------------------------------------------------------------------
typedef HRESULT (*PFNDRVSETRENDERTARGET)(LPDIRECTDRAWSURFACE7, LPDIRECTDRAWSURFACE7,
                                         LPDIRECTDRAWPALETTE, LPDIRECT3DDEVICEI);

typedef struct _D3DBUCKET
{
    struct _D3DBUCKET *next;
    union
    {
    LPVOID  lpD3DDevI;
    LPDDRAWI_DDRAWSURFACE_LCL lpLcl;
    LPVOID  lpBuffer;
    LPDIRECT3DTEXTUREI lpD3DTexI;
    };
    union
    {
    HRESULT (__cdecl *pfnFlushStates)(LPVOID);
    unsigned int ticks;
    };
    LPDIRECTDRAWSURFACE *lplpDDSZBuffer;    //if not NULL, points to lpDDSZBuffer in Direct3DDeviceI
} D3DBUCKET,*LPD3DBUCKET;

typedef struct _D3DI_TEXTUREBLOCK
{
    LIST_MEMBER(_D3DI_TEXTUREBLOCK) list;
    /* Next block in IDirect3DTexture */
    LIST_MEMBER(_D3DI_TEXTUREBLOCK) devList;
    /* Next block in IDirect3DDevice */

    LPDIRECT3DDEVICEI           lpDevI;

    /*  this texture block refers to either an
     * IDirect3DTexture/IDirect3DTexture2, so one of these pointers will
     * always be NULL
     */
    LPDIRECT3DTEXTUREI          lpD3DTextureI;
    /* pointer to internal struct for IDirect3DTexture/IDirect3DTexture2 */

    D3DTEXTUREHANDLE            hTex;
    /* texture handle */
} D3DI_TEXTUREBLOCK;
typedef struct _D3DI_TEXTUREBLOCK *LPD3DI_TEXTUREBLOCK;

// Function to compute lighting
//
typedef struct _LIGHT_VERTEX_FUNC_TABLE
{
    LIGHT_VERTEX_FUNC   pfnDirectional;
    LIGHT_VERTEX_FUNC   pfnPointSpot;
// Used in multi-loop pipeline
    PFN_LIGHTLOOP       pfnDirectionalFirst;
    PFN_LIGHTLOOP       pfnDirectionalNext;
    PFN_LIGHTLOOP       pfnPointSpotFirst;
    PFN_LIGHTLOOP       pfnPointSpotNext;
} LIGHT_VERTEX_FUNC_TABLE;
//---------------------------------------------------------------------
class DIRECT3DLIGHTI : public CD3DAlloc
{
public:
    DIRECT3DLIGHTI() {m_LightI.flags = 0;}   // VALID bit is not set
    HRESULT SetInternalData();
    BOOL Enabled() {return (m_LightI.flags & D3DLIGHTI_ENABLED);}
    BOOL Valid()   {return (m_LightI.flags & D3DLIGHTI_VALID);}

    LIST_MEMBER(DIRECT3DLIGHTI) m_List;     // Active light list member
    D3DLIGHT7   m_Light;
    D3DI_LIGHT  m_LightI;
};
//---------------------------------------------------------------------
//
// Bits for D3DFRONTEND flags (dwFEFlags in DIRECT3DDEVICEI)
//
const DWORD D3DFE_WORLDMATRIX_DIRTY         = 1 << 0;   // World matrix dirty bits
const DWORD D3DFE_WORLDMATRIX1_DIRTY        = 1 << 1;   // must be sequential !!!
const DWORD D3DFE_WORLDMATRIX2_DIRTY        = 1 << 2;
const DWORD D3DFE_WORLDMATRIX3_DIRTY        = 1 << 3;
const DWORD D3DFE_TLVERTEX                  = 1 << 5;
const DWORD D3DFE_REALHAL                   = 1 << 6;
const DWORD D3DFE_PROJMATRIX_DIRTY          = 1 << 8;
const DWORD D3DFE_VIEWMATRIX_DIRTY          = 1 << 9;
// Set when we need to check world-view matrix for orthogonality
const DWORD D3DFE_NEEDCHECKWORLDVIEWVMATRIX = 1 << 10;
// Set when some state has been changed and we have to go through the slow path
// Currently the bit is set when one of the following bits is set:
//     D3DFE_PROJMATRIX_DIRTY 
//     D3DFE_VIEWMATRIX_DIRTY 
//     D3DFE_WORLDMATRIX_DIRTY 
//     D3DFE_WORLDMATRIX1_DIRTY 
//     D3DFE_WORLDMATRIX2_DIRTY 
//     D3DFE_WORLDMATRIX3_DIRTY 
//     D3DFE_VERTEXBLEND_DIRTY
//     D3DFE_LIGHTS_DIRTY 
//     D3DFE_MATERIAL_DIRTY 
//     D3DFE_FVF_DIRTY 
//     D3DFE_CLIPPLANES_DIRTY
const DWORD D3DFE_FRONTEND_DIRTY            = 1 << 11;
// We are in recording state set mode
const DWORD D3DFE_RECORDSTATEMODE           = 1 << 12;
// We are in execution state set mode
// In this mode the front-and executes recorded states but does not pass
// them to the driver (the states will be passed using a set state handle)
const DWORD D3DFE_EXECUTESTATEMODE          = 1 << 13;
const DWORD D3DFE_NEED_TRANSFORM_LIGHTS     = 1 << 14;
const DWORD D3DFE_MATERIAL_DIRTY            = 1 << 15;
const DWORD D3DFE_CLIPPLANES_DIRTY          = 1 << 16;
const DWORD D3DFE_LIGHTS_DIRTY              = 1 << 18;
// This bit is set when vertex blending state is dirty
const DWORD D3DFE_VERTEXBLEND_DIRTY         = 1 << 19;
// Set if the Current Transformation Matrix has been changed
// Reset when frustum planes in the model space have been computed
const DWORD D3DFE_FRUSTUMPLANES_DIRTY       = 1 << 20;
const DWORD D3DFE_WORLDVIEWMATRIX_DIRTY     = 1 << 21;
const DWORD D3DFE_FVF_DIRTY                 = 1 << 22;
// This bit set if UpdateManagedTextures() needs to be called
const DWORD D3DFE_NEED_TEXTURE_UPDATE       = 1 << 23;
// This bit set if mapping DX6 texture blend modes to renderstates is desired
const DWORD D3DFE_MAP_TSS_TO_RS             = 1 << 24;
const DWORD D3DFE_INVWORLDVIEWMATRIX_DIRTY  = 1 << 25;

//
const DWORD D3DFE_LOSTSURFACES              = 1 << 27;
// This bit set if texturing is disabled
const DWORD D3DFE_DISABLE_TEXTURES          = 1 << 28;
// Clip matrix is used to transform user clipping planes
// to the clipping space
const DWORD D3DFE_CLIPMATRIX_DIRTY          = 1 << 29;
// HAL supports Transformation and Lighting
const DWORD D3DFE_TLHAL                     = 1 << 30;
// HAL supports state sets
const DWORD D3DFE_STATESETS                 = 1 << 31;

const DWORD D3DFE_TRANSFORM_DIRTY = D3DFE_PROJMATRIX_DIRTY |
                                    D3DFE_VIEWMATRIX_DIRTY |
                                    D3DFE_WORLDMATRIX_DIRTY |
                                    D3DFE_WORLDMATRIX1_DIRTY |
                                    D3DFE_WORLDMATRIX2_DIRTY |
                                    D3DFE_WORLDMATRIX3_DIRTY |
                                    D3DFE_VERTEXBLEND_DIRTY;

const DWORD D3DDEVBOOL_HINTFLAGS_INSCENE       = 1 << 0; // Are we in a scene?
const DWORD D3DDEVBOOL_HINTFLAGS_MULTITHREADED = 1 << 1; // multithreaded device
const DWORD D3DDEVBOOL_HINTFLAGS_FPUSETUP      = 1 << 3; // Means the FPU is already in preferred state.

//---------------------------------------------------------------------
//
// Bits for dwDebugFlags
//
// Set if DisableFVF key is not 0 in registry and driver supports FVF
const DWORD D3DDEBUG_DISABLEFVF = 1 << 0;
#ifdef WIN95
// Disable Draw Primitive DDI
const DWORD D3DDEBUG_DISABLEDP  = 1 << 1;
// Disable Draw Primitive 2 DDI
const DWORD D3DDEBUG_DISABLEDP2 = 1 << 2;
#endif // WIN95

#ifdef  WIN95
#define _D3D_FORCEDOUBLE    1
#else   //WIN95
#define _D3D_FORCEDOUBLE    0
#endif  //WIN95
#if _D3D_FORCEDOUBLE
// Set if ForceDouble key is not 0 in the registry and driver is pre-DX6 REALHAL
const DWORD D3DDEBUG_FORCEDOUBLE= 1 << 2;
#endif  //_D3D_FORCEDOUBLE

//---------------------------------------------------------------------
// Bits for transform.dwFlags
//

// Frastum plane equations are valid
const DWORD D3DTRANS_VALIDFRUSTUM   = 1 << 2;
//---------------------------------------------------------------------
typedef struct _D3DFE_TRANSFORM
{
    D3DMATRIXI  proj;
    D3DMATRIXI  view;
    D3DMATRIXI  world[4];   // Up to 4 world matrix
    D3DMATRIXI  mPC;        // Mproj * Mclip
    D3DMATRIXI  mVPC;       // Mview * PC
    D3DMATRIXI  mVPCI;      // Inverse Mview * PC, used to transform clipping planes
    D3DMATRIXI  mCTMI;      // Inverse current transformation matrix
    D3DVECTORH  frustum[6]; // Normalized plane equations for viewing frustum
                                // in the model space
    D3DVECTORH  userClipPlane[D3DMAXUSERCLIPPLANES];

    DWORD       dwMaxUserClipPlanes;    // Number provided by the driver
    DWORD       dwFlags;
} D3DFE_TRANSFORM;

typedef void (*D3DFEDestroyProc)(LPDIRECT3DDEVICEI lpD3DDevI);

extern DWORD dwD3DTriBatchSize, dwTriBatchSize, dwLineBatchSize;
extern DWORD dwHWBufferSize, dwHWMaxTris;
extern DWORD dwHWFewVertices;

typedef enum {
    D3DDEVTYPE_OLDHAL = 1,
    D3DDEVTYPE_DPHAL,
    D3DDEVTYPE_DP2HAL,          // DX6 HAL
    D3DDEVTYPE_DX7HAL,          // DX7 HAL w/out T&L, with state sets
    D3DDEVTYPE_DX7TLHAL
} D3DDEVICETYPE;
//---------------------------------------------------------------------
typedef HRESULT (DIRECT3DDEVICEI::*PFN_DRAWPRIM)();

//---------------------------------------------------------------------
// This type is used to define operation for ProcessPrimitive
//
typedef enum
{
    __PROCPRIMOP_INDEXEDPRIM,       // Process indexed primitive
    __PROCPRIMOP_NONINDEXEDPRIM,    // Process non-indexed primitive
} __PROCPRIMOP;
//---------------------------------------------------------------------
#ifdef _IA64_   // Removes IA64 compiler alignment warnings
  #pragma pack(16)
#endif

#ifdef _AXP64_   // Removes AXP64 compiler alignment warnings
  #pragma pack(16)
#endif

// We modify the compiler generated VTable for DIRECT3DDEVICEI object. To make
// life easy, all virtual functions are defined in DIRECT3DDEVICEI. Also since
// DEVICEI has multiple inheritance, there are more than 1 VTable.
// Currently we assume that it only inherits from IDirect3DDevice7 and
// D3DFE_PROCESSVERTICES and, in that order! Thus IDirect3DDevice7 and
// DIRECT3DDEVICEI share the same vtable. This is the VTable we copy and
// modify. The define below is the total entries in this vtable. It is the
// sum of the methods in IDirect3DDevice7 (incl. IUnknown) (49) and all the
// virtual methods in DIRECT3DDEVICEI ()
#define D3D_NUM_API_FUNCTIONS (49)
#define D3D_NUM_VIRTUAL_FUNCTIONS (D3D_NUM_API_FUNCTIONS+38)

// These constants are based on the assumption that rsVec array is an array
// of 32-bit intergers
const D3D_RSVEC_SHIFT = 5; // log2(sizeof(DWORD)*8);
const D3D_RSVEC_MASK = sizeof(DWORD) * 8 - 1;

class DIRECT3DDEVICEI : public IDirect3DDevice7,
                        public CD3DAlloc,
                        public D3DFE_PROCESSVERTICES
{
public: // Private Data

    ULONGLONG           m_qwBatch; // current batch number

    DWORD               dwHintFlags;
    // Pointer to the PV funcs that we need to call
    LPD3DFE_PVFUNCS     pGeometryFuncs;
    // buffer for H vertices
    CAlignedBuffer32    HVbuf;              // Used for clip flags

// Should be cache line aligned. Now it is not
    D3DDEVICETYPE       deviceType;         // Device Type

    /*** Object Relations ***/
    LPDIRECT3DI         lpDirect3DI;        // parent
    LIST_MEMBER(DIRECT3DDEVICEI)list;       // Next device IDirect3D

    /* Textures */
    LIST_ROOT(_dmtextures, _D3DI_TEXTUREBLOCK) texBlocks;
    /* Ref to created IDirect3DTextures */

    /* Viewports */
    D3DVIEWPORT7    m_Viewport;
    DWORD           clrCount;   // Number of rects allocated
    LPD3DRECT       clrRects;   // Rects used for clearing

    /* Reference count object */
    unsigned refCnt;

    // for DX3-style devices aggregated onto ddraw, guid should be IID_IDirect3DRGBDevice,
    // IID_IDirect3DHALDevice, etc.  for DX5 and beyond, guid is IID_IDirect3DDevice,
    // IID_IDirect3DDevice2, etc
    GUID        guid;

    LPD3DHAL_CALLBACKS      lpD3DHALCallbacks; /* HW specific */
    LPD3DHAL_GLOBALDRIVERDATA   lpD3DHALGlobalDriverData; /* HW specific */
    LPD3DHAL_CALLBACKS2         lpD3DHALCallbacks2;    /* HW specific */
    LPD3DHAL_CALLBACKS3         lpD3DHALCallbacks3; /* DX6 DDI */

    /* DirectDraw objects that we are holding references to */

    LPDIRECTDRAW lpDD;    // DirectDraw object
    LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;    //
    LPDIRECTDRAWSURFACE lpDDSTarget;    // Render target
    LPDIRECTDRAWSURFACE lpDDSZBuffer;   // Z buffer
    LPDIRECTDRAWPALETTE lpDDPalTarget;  // Palette for render target (if any)

    // these are saved for use by new GetRenderTarget and anything else that requires DDS4 functionality
    LPDIRECTDRAWSURFACE7 lpDDSTarget_DDS7;
    LPDIRECTDRAWSURFACE7 lpDDSZBuffer_DDS7;

    // Front end data
    D3DFE_TRANSFORM     transform;      // Transformation state
    int                 iClipStatus;    // Clipping status
    DWORD               dwhContext;     // Driver context

// RenderTarget/ZBuf bit depth info used by Clear to Blt
     DWORD              red_mask;
     DWORD              red_scale;
     DWORD              red_shift;
     DWORD              green_mask;
     DWORD              green_scale;
     DWORD              green_shift;
     DWORD              blue_mask;
     DWORD              blue_scale;
     DWORD              blue_shift;
     DWORD              alpha_mask;
     DWORD              alpha_scale;
     DWORD              alpha_shift;
     DWORD              zmask_shift,stencilmask_shift;
     BOOL               bDDSTargetIsPalettized;  // true if 4 or 8 bit rendertarget

// Pipeline state info
    DWORD               dwDebugFlags;       // See debug bits above

#ifndef WIN95
    DWORD_PTR           hSurfaceTarget;
#else
    DWORD               hSurfaceTarget;
#endif

#ifdef TRACK_HAL_CALLS
    DWORD hal_calls;
#endif

    //--------------- Lights start -----------------------
    DIRECT3DLIGHTI      *m_pLights;         // Growable light array
    DWORD               m_dwNumLights;      // Size of m_Lights array
    LIST_ROOT(_dlights, DIRECT3DLIGHTI) m_ActiveLights;

    LIST_ROOT(name10,_SpecularTable) specular_tables;
    SpecularTable*    specular_table;
    LIGHT_VERTEX_FUNC_TABLE *lightVertexFuncTable;
    //--------------- Lights end -----------------------

    /* Provider backing this driver */
    IHalProvider*       pHalProv;
    HINSTANCE           hDllProv;

    /* Device description */
    D3DDEVICEDESC7   d3dDevDesc;

    /*
     *  Pointer to texture objects for currently installed textures.  NULL indicates
     *  that the texture is either not set (rstate NULL) or that the handle to tex3 pointer
     *  mapping is not done.  This mapping is expensive, so it is deferred until needed.
     *
     *  This is needed for finding the WRAPU,V mode for texture index clipping (since
     *  the WRAPU,V state is part of the device).
     */
    LPDIRECT3DTEXTUREI          lpD3DMappedTexI[D3DHAL_TSS_MAXSTAGES];
    LPD3DI_TEXTUREBLOCK         lpD3DMappedBlock[D3DHAL_TSS_MAXSTAGES];
    DWORD                       dwMaxTextureBlendStages; // Max number of blend stages supported by a driver
    DWORD                       m_dwStageDirty;
    LPDIRECTDRAWCLIPPER         lpClipper;

    /*
     * DrawPrimitives batching
     */


    // Buffer to put DrawPrimitives stuff into
    // Used for both legacy and DrawPrimitive HALs
    WORD *lpwDPBuffer;
    WORD *lpwDPBufferAlloced;
#ifndef WIN95
    DWORD dwDPBufferSize;
#endif
    DWORD dwCurrentBatchVID;        // Current FVF type in the batch buffer

    LPD3DHAL_D3DEXTENDEDCAPS lpD3DExtendedCaps;  /* HW specific */
    LPDWORD rstates;

    // Runtime copy of texture stage states
    DWORD tsstates[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];

    // Object to record state sets
    CStateSets * m_pStateSets;

    // This is a function provided by sw rasterizers.
    // Currently, its only function is to provide an RGB8 clear color.
    // It should be non-NULL for anything that supports an 8 bit RGB output
    // type.
    PFN_RASTSERVICE pfnRastService;

    //
    // This is function pointer is obtained through the
    // HalProvider interface. For real_hals, it is found in all DX7+
    // drivers in pDdGbl->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState
    // Of the software drivers, only Refrast supports it in its DX7+ mode.
    LPDDHAL_GETDRIVERSTATE pfnGetDriverState;

    // Max TSS that can be passed to the driver
    D3DTEXTURESTAGESTATETYPE m_tssMax;
    // Max RS that can be passed to the driver, used for CanHandleRenderState
    D3DRENDERSTATETYPE m_rsMax;
    // We use 32-bit ints for rsVec. The size if computed using ceil(D3D_MAXRENDERSTATES/32)
    DWORD rsVec[(D3D_MAXRENDERSTATES + D3D_RSVEC_MASK) >> D3D_RSVEC_SHIFT];
    DWORD rsVecRetired[(D3D_MAXRENDERSTATES + D3D_RSVEC_MASK) >> D3D_RSVEC_SHIFT];
#if COLLECTSTATS
    D3DDEVINFO_TEXTURING m_texstats;
#endif
#ifdef VTABLE_HACK
    // This points to the original (compiler generated) read-only vtable of DIRECT3DDEVICEI
    PVOID* lpVtbl;
    // The new vtable which is a read/write copy of the original to allow hacking
    PVOID newVtbl[D3D_NUM_VIRTUAL_FUNCTIONS];
#endif // VTABLE_HACK
#ifdef PROFILE4
    DWORD m_dwProfStart, m_dwProfStop;
#endif // PROFILE4
#ifdef PROFILE
    DWORD m_dwProfStart, m_dwProfStop;
#endif // PROFILE
public: // virtual methods
    DIRECT3DDEVICEI();
    virtual ~DIRECT3DDEVICEI(); // 0
    virtual HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice); // 1
    virtual HRESULT FlushStates(bool bWithinPrimitive = false)=0;    // 2 // Use to flush current batch to the driver
    virtual HRESULT FlushStatesReq(DWORD) { return FlushStates(); }; // 3
    virtual HRESULT ProcessPrimitive(__PROCPRIMOP op = __PROCPRIMOP_NONINDEXEDPRIM)=0; // 4
    virtual HRESULT CheckSurfaces();    // 5 // Check if the surfaces necessary for rendering are lost
    virtual void WriteStateSetToDevice(D3DSTATEBLOCKTYPE) {} // 6
    // Function to download viewport info to the driver
    virtual void UpdateDrvViewInfo(LPD3DVIEWPORT7 lpVwpData) {}; // 7
    virtual void UpdateDrvWInfo() {}; // 8
    virtual HRESULT halCreateContext(); // 9
    // This function is used when in SetRenderTarget the driver context is
    // recreated
    virtual HRESULT UpdateDriverStates(); // 10
    virtual HRESULT ValidateFVF(DWORD dwFVF); // 11
    virtual HRESULT SetupFVFData(DWORD *pdwInpVertexSize); // 12

    virtual void LightChanged(DWORD dwLightIndex); // 13
    virtual void MaterialChanged(); // 14
    virtual void SetTransformI(D3DTRANSFORMSTATETYPE, LPD3DMATRIX); // 15
    virtual void SetViewportI(LPD3DVIEWPORT7); // 16
    virtual HRESULT D3DAPI SetTextureStageStateFast(DWORD dwStage,
                                                    D3DTEXTURESTAGESTATETYPE dwState,
                                                    DWORD dwValue); // 17
    virtual HRESULT D3DAPI SetRenderStateFast(D3DRENDERSTATETYPE, DWORD); // 18
    virtual void LightEnableI(DWORD dwLightIndex, BOOL); // 19
    virtual HRESULT UpdateTextures(); // 20
    virtual void SetRenderTargetI(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE); // 21
    virtual bool CanDoTexBlt(LPDDRAWI_DDRAWSURFACE_LCL lpDDSSrcSubFace_lcl,
                             LPDDRAWI_DDRAWSURFACE_LCL lpDDSDstSubFace_lcl); // 22
    virtual void ClearI(DWORD dwFlags, DWORD clrCount, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil); // 23
#ifdef VTABLE_HACK
    virtual HRESULT D3DAPI DrawPrimitiveTL(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD) // 24
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawPrimitiveVBTL(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, DWORD) // 25
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawIndexedPrimitiveTL(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, LPWORD, DWORD, DWORD) // 26
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawIndexedPrimitiveVBTL(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, LPWORD, DWORD, DWORD) // 27
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawPrimitiveFE(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD) // 28
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawIndexedPrimitiveFE(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, LPWORD, DWORD, DWORD) // 29
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawPrimitiveVBFE(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, DWORD) // 30
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
    virtual HRESULT D3DAPI DrawIndexedPrimitiveVBFE(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, LPWORD, DWORD, DWORD) // 31
    { // Dummy function, should never be called
        DDASSERT(1);
        return DDERR_GENERIC;
    };
#endif
    virtual void SetClipPlaneI(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation); // 32
    virtual HRESULT D3DAPI SetTextureInternal(DWORD, LPDIRECTDRAWSURFACE7); // 33
    virtual HRESULT D3DAPI ApplyStateBlockInternal(DWORD); // 34
    virtual HRESULT SetTSSI(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD) = 0; // 35
    virtual HRESULT D3DAPI PreLoadFast(LPDIRECTDRAWSURFACE7); // 36
public: // non virtual methods
    BOOL UpdateInternalTextureStageState(DWORD dwStage,
                                         D3DTEXTURESTAGESTATETYPE dwState,
                                         DWORD dwValue);
    HRESULT stateInitialize(BOOL bZEnable);
    HRESULT checkDeviceSurface(LPDIRECTDRAWSURFACE lpDDS, LPDIRECTDRAWSURFACE lpZbuffer, LPGUID pGuid);
    HRESULT HookToD3D(LPDIRECT3DI lpD3DI);
    HRESULT UnhookFromD3D();
    HRESULT SetupFVFDataCommon(DWORD *pdwInpVertexSize);
    void CleanupTextures();
    BOOL NeedInternalTSSUpdate(DWORD dwState)
    {
        return dwState == D3DTSS_TEXCOORDINDEX || dwState >= D3DTSS_TEXTURETRANSFORMFLAGS ||
               dwState == D3DTSS_COLOROP;
    }
    // Always use this function to update "rstates", because we have to
    // set some internal flags when "rstats" is changed.
    void UpdateInternalState(D3DRENDERSTATETYPE type, DWORD value);
    // Checks for 'retired' render state - returns TRUE if not retired
    BOOL CheckForRetiredRenderState(D3DRENDERSTATETYPE type)
    {
        if (!(rsVecRetired[type >> D3D_RSVEC_SHIFT] & (1ul << (type & D3D_RSVEC_MASK))))
        {
            // not retired
            return TRUE;
        }
        return FALSE;
    }
    // Checks if we can pass the render state to the driver
    BOOL CanHandleRenderState(D3DRENDERSTATETYPE type)
    {
        if (type >= m_rsMax)
        {
            // not an error condition because we don't send front-end stuff to
            // non-TL Hal devices, for example, but don't send to HAL anyway
            return FALSE;
        }
        return TRUE;
    };

    // Update internal state
    void SetMaterialI(LPD3DMATERIAL7);
    void SetLightI(DWORD dwLightIndex, LPD3DLIGHT7);
    inline void SetFogFlags(void);
    void ForceFVFRecompute(void) { dwVIDIn = 0; dwFEFlags |= D3DFE_FVF_DIRTY | D3DFE_FRONTEND_DIRTY; };
    HRESULT CopySurface(LPDIRECTDRAWSURFACE7 lpDDSDst, LPRECT lpDestRect,
                        LPDIRECTDRAWSURFACE7 lpDDSSrc, LPRECT lpSrcRect,
                        DWORD dwFlags);
    HRESULT GetTextureDDIHandle(LPDIRECT3DTEXTUREI lpTexI,
                                LPD3DI_TEXTUREBLOCK* lplpBlock);
    LPD3DI_TEXTUREBLOCK HookTexture(LPDIRECT3DTEXTUREI lpD3DText);
    LPD3DI_TEXTUREBLOCK D3DI_FindTextureBlock(LPDIRECT3DTEXTUREI lpTex);
    void BatchTexture(LPDDRAWI_DDRAWSURFACE_LCL lpLcl)
    {
        if(m_qwBatch > lpLcl->lpSurfMore->qwBatch.QuadPart)
            lpLcl->lpSurfMore->qwBatch.QuadPart = m_qwBatch;
    }
    HRESULT VerifyTextureCaps(LPDIRECT3DTEXTUREI lpTexI);
    HRESULT CheckDrawPrimitiveVB(LPDIRECT3DVERTEXBUFFER7 lpVBuf, DWORD dwStartVertex, DWORD dwNumVertices, DWORD dwFlags);
    void DisplayStats();
    void CheckClipStatus(D3DVALUE * pPositions, DWORD dwStride, DWORD dwNumVertices,
                         DWORD *pdwClipUnion, DWORD *pdwClipIntersection);
    HRESULT VerifyTexture(DWORD dwStage, LPDIRECTDRAWSURFACE7 lpTex);
    HRESULT SetRenderStateInternal(D3DRENDERSTATETYPE, DWORD);
    BOOL GetInfoInternal(DWORD dwDevInfoID, LPVOID pDevInfoStruct, DWORD dwSize);
#if COLLECTSTATS
    void ResetTexStats();
    void GetTexStats(LPD3DDEVINFO_TEXTURING);
    void IncNumLoads()
    {
        ++m_texstats.dwNumLoads;
    }
    void IncNumTexturesSet()
    {
        ++m_texstats.dwNumSet;
    }
    void IncNumPreLoads()
    {
        ++m_texstats.dwNumPreLoads;
    }
    void IncBytesDownloaded(LPDDRAWI_DDRAWSURFACE_LCL lpLcl, LPRECT lpRect)
    {
        m_texstats.dwApproxBytesLoaded += BytesDownloaded(lpLcl, lpRect);
    }
#endif
#ifdef VTABLE_HACK
    void VtblPreLoadFast()
    {
        // DIRECT3DDEVICEI::PreLoadFast
        newVtbl[24] = lpVtbl[D3D_NUM_API_FUNCTIONS+36];
    }
    void VtblApplyStateBlockRecord()
    {
        // IDirect3DDevice7::ApplyStateBlock
        newVtbl[39] = lpVtbl[39];
    }
    void VtblApplyStateBlockExecute()
    {
        // IDirect3DDevice7::ApplyStateBlockInternal
        newVtbl[39] = lpVtbl[D3D_NUM_API_FUNCTIONS+34];
    }
    void VtblSetTextureRecord()
    {
        // IDirect3DDevice7::SetTexture
        newVtbl[35] = lpVtbl[35];
    }
    void VtblSetTextureExecute()
    {
        // IDirect3DDevice7::SetTextureInternal
        newVtbl[35] = lpVtbl[D3D_NUM_API_FUNCTIONS+33];
    }
    void VtblSetTextureStageStateRecord()
    {
        // IDirect3DDevice7::SetTextureStageState
        newVtbl[37] = lpVtbl[37];
    }
    void VtblSetTextureStageStateExecute()
    {
        // IDirect3DDevice7::SetTextureStageStateI
        newVtbl[37] = lpVtbl[D3D_NUM_API_FUNCTIONS+17];
    }
    void VtblSetRenderStateRecord()
    {
        // IDirect3DDevice7::SetRenderState
        newVtbl[20] = lpVtbl[20];
    }
    void VtblSetRenderStateExecute()
    {
        // DIRECT3DDEVICEI::SetRenderStateFast
        newVtbl[20] = lpVtbl[D3D_NUM_API_FUNCTIONS+18];
    }
    void VtblDrawPrimitiveDefault()
    {
        // IDirect3DDevice7::DrawPrimitive
        newVtbl[25] = lpVtbl[25];
    }
    void VtblDrawPrimitiveTL()
    {
        // DIRECT3DDEVICEI::DrawPrimitiveTL
        newVtbl[25] = lpVtbl[D3D_NUM_API_FUNCTIONS+24];
    }
    void VtblDrawPrimitiveVBDefault()
    {
        // IDirect3DDevice7::DrawPrimitiveVB
        newVtbl[31] = lpVtbl[31];
    }
    void VtblDrawPrimitiveVBTL()
    {
        // DIRECT3DDEVICEI::DrawPrimitiveVBTL
        newVtbl[31] = lpVtbl[D3D_NUM_API_FUNCTIONS+25];
    }
    void VtblDrawIndexedPrimitiveDefault()
    {
        // IDirect3DDevice7::DrawIndexedPrimitive
        newVtbl[26] = lpVtbl[26];
    }
    void VtblDrawIndexedPrimitiveTL()
    {
        // DIRECT3DDEVICEI::DrawIndexedPrimitiveTL
        newVtbl[26] = lpVtbl[D3D_NUM_API_FUNCTIONS+26];
    }
    void VtblDrawIndexedPrimitiveVBDefault()
    {
        // IDirect3DDevice7::DrawIndexedPrimitiveVB
        newVtbl[32] = lpVtbl[32];
    }
    void VtblDrawIndexedPrimitiveVBTL()
    {
        // DIRECT3DDEVICEI::DrawIndexedPrimitiveVBTL
        newVtbl[32] = lpVtbl[D3D_NUM_API_FUNCTIONS+27];
    }
    void VtblDrawPrimitiveFE()
    {
        // DIRECT3DDEVICEI::DrawPrimitiveFE
        newVtbl[25] = lpVtbl[D3D_NUM_API_FUNCTIONS+28];
    }
    void VtblDrawIndexedPrimitiveFE()
    {
        // DIRECT3DDEVICEI::DrawIndexedPrimitiveFE
        newVtbl[26] = lpVtbl[D3D_NUM_API_FUNCTIONS+29];
    }
    void VtblDrawPrimitiveVBFE()
    {
        // DIRECT3DDEVICEI::DrawPrimitiveFE
        newVtbl[31] = lpVtbl[D3D_NUM_API_FUNCTIONS+30];
    }
    void VtblDrawIndexedPrimitiveVBFE()
    {
        // DIRECT3DDEVICEI::DrawIndexedPrimitiveFE
        newVtbl[32] = lpVtbl[D3D_NUM_API_FUNCTIONS+31];
    }
#endif

#if DBG
#define PROF_DRAWPRIMITIVEDEVICE2           0x0003
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE2    0x0004
#define PROF_DRAWPRIMITIVESTRIDED           0x0005
#define PROF_DRAWINDEXEDPRIMITIVESTRIDED    0x0006
#define PROF_DRAWPRIMITIVEDEVICE3           0x0007
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE3    0x0008
#define PROF_DRAWPRIMITIVEVB                0x0009
#define PROF_DRAWINDEXEDPRIMITIVEVB         0x000a
    DWORD   dwCaller;
    DWORD   dwPrimitiveType[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType1[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType2[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    void    Profile(DWORD, D3DPRIMITIVETYPE, DWORD);
#else
    #define Profile(a,b,c)
#endif
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DDevice7 Methods
    HRESULT D3DAPI GetCaps(LPD3DDEVICEDESC7);
    HRESULT D3DAPI EnumTextureFormats(LPD3DENUMPIXELFORMATSCALLBACK, LPVOID);
    HRESULT D3DAPI BeginScene();
    HRESULT D3DAPI EndScene();
    HRESULT D3DAPI GetDirect3D(LPDIRECT3D7*);
    HRESULT D3DAPI Clear(DWORD, LPD3DRECT, DWORD, D3DCOLOR, D3DVALUE, DWORD);
    HRESULT D3DAPI SetRenderTarget(LPDIRECTDRAWSURFACE7, DWORD);
    HRESULT D3DAPI GetRenderTarget(LPDIRECTDRAWSURFACE7 *);
    HRESULT D3DAPI SetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI GetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI MultiplyTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI SetViewport(LPD3DVIEWPORT7);
    HRESULT D3DAPI GetViewport(LPD3DVIEWPORT7);
    HRESULT D3DAPI SetMaterial(LPD3DMATERIAL7);
    HRESULT D3DAPI GetMaterial(LPD3DMATERIAL7);
    HRESULT D3DAPI SetLight(DWORD, LPD3DLIGHT7);
    HRESULT D3DAPI GetLight(DWORD, LPD3DLIGHT7);
    HRESULT D3DAPI GetRenderState(D3DRENDERSTATETYPE, LPDWORD);
    HRESULT D3DAPI SetRenderState(D3DRENDERSTATETYPE, DWORD);
    HRESULT D3DAPI DrawPrimitive(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI SetClipStatus(LPD3DCLIPSTATUS);
    HRESULT D3DAPI GetClipStatus(LPD3DCLIPSTATUS);
    HRESULT D3DAPI DrawPrimitiveStrided(D3DPRIMITIVETYPE, DWORD, LPD3DDRAWPRIMITIVESTRIDEDDATA, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveStrided(D3DPRIMITIVETYPE, DWORD, LPD3DDRAWPRIMITIVESTRIDEDDATA, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawPrimitiveVB(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveVB(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI ComputeSphereVisibility(LPD3DVECTOR, LPD3DVALUE, DWORD, DWORD, LPDWORD);
    HRESULT D3DAPI GetTexture(DWORD, LPDIRECTDRAWSURFACE7 *);
    HRESULT D3DAPI SetTexture(DWORD, LPDIRECTDRAWSURFACE7);
    HRESULT D3DAPI GetTextureStageState(DWORD, D3DTEXTURESTAGESTATETYPE, LPDWORD);
    HRESULT D3DAPI DuplicateStateBlock(DWORD InHandle, LPDWORD OutHandle);
    HRESULT D3DAPI OverlayStateBlock(DWORD Handle);
    HRESULT D3DAPI BeginStateBlock();
    HRESULT D3DAPI EndStateBlock(LPDWORD);
    HRESULT D3DAPI DeleteStateBlock(DWORD);
    HRESULT D3DAPI ApplyStateBlock(DWORD);
    HRESULT D3DAPI CaptureStateBlock(DWORD Handle);
    HRESULT D3DAPI SetTextureStageState(DWORD dwStage,
                                        D3DTEXTURESTAGESTATETYPE dwState,
                                        DWORD dwValue);
    HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses) = 0;
    HRESULT D3DAPI Load(LPDIRECTDRAWSURFACE7 lpDest, LPPOINT lpDestPoint,
                        LPDIRECTDRAWSURFACE7 lpSrc, LPRECT lpSrcRect,
                        DWORD dwFlags);
    HRESULT D3DAPI LightEnable(DWORD dwLightIndex, BOOL);
    HRESULT D3DAPI GetLightEnable(DWORD dwLightIndex, BOOL*);
    HRESULT D3DAPI PreLoad(LPDIRECTDRAWSURFACE7 lpTex);
    HRESULT D3DAPI GetInfo(DWORD dwDevInfoID, LPVOID pDevInfoStruct, DWORD dwSize);
    HRESULT D3DAPI SetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation);
    HRESULT D3DAPI GetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation);
    HRESULT D3DAPI CreateStateBlock(D3DSTATEBLOCKTYPE sbt, LPDWORD pdwHandle);
};

// There is only DP2 HAL on NT
#ifdef WIN95

typedef struct _D3DHAL_DRAWPRIMCOUNTS *LPD3DHAL_DRAWPRIMCOUNTS;

// Legacy HAL batching is done with these structs.
typedef struct _D3DI_HWCOUNTS {
    WORD wNumStateChanges;      // Number of state changes batched
    WORD wNumVertices;          // Number of vertices in tri list
    WORD wNumTriangles;         // Number of triangles in tri list
} D3DI_HWCOUNTS, *LPD3DI_HWCOUNTS;


class CDirect3DDeviceIHW : public DIRECT3DDEVICEI
{
private: // Data
    /* Legacy HALs */

    // Buffer of counts structures that keep track of the
    // number of render states and vertices buffered
    LPD3DI_HWCOUNTS lpHWCounts;

    // Buffer of triangle structures.
    LPD3DTRIANGLE lpHWTris;

    // Byte offset into lpHWVertices. This gets incremented
    // by 8 when a render state is batched and by 32*dwNumVertices
    // when a primitive is batched.
    DWORD dwHWOffset;

    // Max value of dwHWOffset. Used to decide whether to flush.
    DWORD dwHWMaxOffset;

    // Index into lpHWTris.
    DWORD dwHWTriIndex;

    // Number of counts structures used so far. This actually
    // gives the number of primitives batched and the index of
    // the counts structure to batch render states into.
    DWORD dwHWNumCounts;

    WORD *wTriIndex;

    HRESULT DrawIndexedPrimitiveInBatchesHW(D3DPRIMITIVETYPE PrimitiveType,
                                            D3DVERTEXTYPE VertexType,
                                            LPD3DTLVERTEX lpVertices,
                                            DWORD dwNumPrimitives,
                                            LPWORD lpwIndices);
protected:
    CBufferDDS TLVbuf;
public:
    CDirect3DDeviceIHW() { deviceType = D3DDEVTYPE_OLDHAL; }
    ~CDirect3DDeviceIHW(); // Called by CDirect3DDeviceUnk::Release()
    HRESULT SetRenderStateI(D3DRENDERSTATETYPE, DWORD);
    HRESULT DrawPrim();
    HRESULT DrawIndexPrim();
    HRESULT DrawClippedPrim() {return DrawPrim();}
    HRESULT FlushStates(bool bWithinPrimitive = false);
    HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses);
    HRESULT SetTSSI(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    HRESULT MapTSSToRS();

    HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice);
    HRESULT ProcessPrimitive(__PROCPRIMOP op = __PROCPRIMOP_NONINDEXEDPRIM);
    HRESULT MapFVFtoTLVertex(LPVOID lpAddress);
    HRESULT MapFVFtoTLVertexIndexed();
};

class CDirect3DDeviceIDP : public CDirect3DDeviceIHW
{
private: // Data
    /* data members of DIRECT3DDEVICEI that are specific to DX5 DrawPrimitive HAL drivers
       should go here */
    /* DrawPrimitive-aware HALs */

    // pointer to current prim counts struct
    LPD3DHAL_DRAWPRIMCOUNTS lpDPPrimCounts;

    // Byte offset into buffer (we are currently
    // using the device's wTriIndex)
    DWORD dwDPOffset;

    // Maximum offset. If dwDPOffset exceeds this, it is
    // time to flush.
    DWORD dwDPMaxOffset;

public:
    CDirect3DDeviceIDP() { deviceType = D3DDEVTYPE_DPHAL; }
    ~CDirect3DDeviceIDP() { CleanupTextures(); }
    HRESULT SetRenderStateI(D3DRENDERSTATETYPE, DWORD);
    HRESULT DrawPrim();
    HRESULT DrawIndexPrim();
    HRESULT DrawClippedPrim() {return DrawPrim();}
    HRESULT FlushStates(bool bWithinPrimitive = false);

    HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice);
    HRESULT halCreateContext();
};

#define IS_DPHAL_DEVICE(lpDevI) ((lpDevI)->deviceType == D3DDEVTYPE_DPHAL)

#endif // WIN95

// Flags passed by the runtime to the DDI batching code via PV structure
// to enable new DDI batching to be done efficiently. These flags are
// marked as reserved in d3dfe.hpp
const DWORD D3DPV_WITHINPRIMITIVE = D3DPV_RESERVED1; // This flags that the flush has occured
                                                     // within an primitive. This indicates
                                                     // that we should not flush the vertex buffer

// If the vertices are in user memory
const DWORD D3DPV_USERMEMVERTICES = D3DPV_RESERVED3;
//---------------------------------------------------------------------
class CDirect3DDeviceIDP2 : public DIRECT3DDEVICEI
{
public: // data
    static const DWORD dwD3DDefaultCommandBatchSize;

    // This is the VB interface corresponding to the dp2data.lpDDVertex
    // This is kept so that the VB can be released when done
    // which cannot be done from just the LCL pointer which is lpDDVertex
    CDirect3DVertexBuffer* lpDP2CurrBatchVBI;
    DWORD TLVbuf_size;
    DWORD TLVbuf_base;
#ifdef VTABLE_HACK
    // Cached dwFlags for fast path
    DWORD dwLastFlags;
    // Last VB used in a call that involved D3D's FE.
    CDirect3DVertexBuffer* lpDP2LastVBI;
#endif
    DWORD dwDP2CommandBufSize;
    DWORD dwDP2CommandLength;

    // Cache line should start here

    // Pointer to the actual data in CB1
    LPVOID lpvDP2Commands;


    //Pointer to the current position the CB1 buffer
    LPD3DHAL_DP2COMMAND lpDP2CurrCommand;
    // Perf issue: replace the below 3 fields by a 32 bit D3DHAL_DP2COMMAND struct
    WORD wDP2CurrCmdCnt; // Mirror of Count field if the current command
    BYTE bDP2CurrCmdOP;  // Mirror of Opcode of the current command
    BYTE bDummy;         // Force DWORD alignment of next member

    D3DHAL_DRAWPRIMITIVES2DATA dp2data;

    // The buffer we currently batch into
    LPDIRECTDRAWSURFACE7 lpDDSCB1;
    LPDIRECT3DVERTEXBUFFER7 allocatedBuf;
    LPVOID alignedBuf;

    // Count read/write <-> write-only transistions
    DWORD dwTLVbufChanges;
    // Flags specific to DP2 device
    DWORD dwDP2Flags;
    // If a mode switch occurs just before a TLVbuf_Grow which requires to create a new
    // VB, then the create will fail. This will leave the device in a state where
    // allocatedBuf is NULL. This is bad since many places in the code we derefence this
    // without checking for NULL. To have a contained fix, we create a small dummy system
    // memory VB at device create and if we ever fail the grow due to mode switch, we assign
    // this VB instead to allocated buf and set the TLVbuf_size to 0.
    LPDIRECT3DVERTEXBUFFER7 pNullVB;

protected: // methods
    inline void ClearBatch(bool);
    HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice);
    HRESULT GrowCommandBuffer(LPDIRECT3DI lpD3DI, DWORD dwSize);
#if DBG
    void ValidateVertex(LPDWORD lpdwVertex);
    void ValidateCommand(LPD3DHAL_DP2COMMAND lpCmd);
#endif
public:
    CDirect3DDeviceIDP2() { deviceType = D3DDEVTYPE_DP2HAL; }

    ~CDirect3DDeviceIDP2(); // Called by CDirect3DDeviceUnk::Release()
    HRESULT FlushStates(bool bWithinPrimitive = false);
    HRESULT FlushStatesReq(DWORD dwReqSize);
    HRESULT SetRenderStateI(D3DRENDERSTATETYPE, DWORD);
    HRESULT DrawPrim();
    HRESULT DrawIndexPrim();
    HRESULT DrawClippedPrim();
    HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses);
    HRESULT SetTSSI(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    // Called from DrawPrimitiveVB if a vertex buffer or TL buffer is used for rendering
    HRESULT StartPrimVB(LPDIRECT3DVERTEXBUFFERI vb, DWORD dwStartVertex);
    // Called if user memory buffer is used for rendering
    HRESULT StartPrimUserMem(LPVOID memory);
    // Called if TL buffer of used memory was used for rendering
    HRESULT EndPrim();

    HRESULT CheckSurfaces();

    void UpdateDrvViewInfo(LPD3DVIEWPORT7 lpVwpData);
    void UpdateDrvWInfo();
    // This function is used when in SetRenderTarget the driver context is
    // recreated
    HRESULT UpdateDriverStates();
    HRESULT SetupFVFData(DWORD *pdwInpVertexSize);
    HRESULT ProcessPrimitive(__PROCPRIMOP op = __PROCPRIMOP_NONINDEXEDPRIM);
    // Returns aligned buffer address
    LPVOID TLVbuf_GetAddress()
    {
        return (LPBYTE)alignedBuf + TLVbuf_base;
    }
    // Returns aligned buffer size
    DWORD TLVbuf_GetSize() { return TLVbuf_size - TLVbuf_base; }
    DWORD& TLVbuf_Base() { return TLVbuf_base; }
    // define these later on in this file after CDirect3DVertexBuffer is defined
    inline CDirect3DVertexBuffer* TLVbuf_GetVBI();
    inline LPDIRECTDRAWSURFACE TLVbuf_GetDDS();
    HRESULT TLVbuf_Grow(DWORD dwSize, bool bWriteOnly);
    // Initializes command header in the DP2 command buffer,
    // reserves space for the comamnd data and returns pointer to the command
    // data
    // Throws an HRESULT exception in case of error
    LPVOID GetHalBufferPointer(D3DHAL_DP2OPERATION op, DWORD dwDataSize);
    HRESULT D3DAPI DrawPrimitiveTL(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI DrawPrimitiveVBTL(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveTL(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveVBTL(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawPrimitiveFE(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveFE(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawPrimitiveVBFE(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveVBFE(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER7, DWORD, DWORD, LPWORD, DWORD, DWORD);
};
//  macros to characterize device

#define IS_DP2HAL_DEVICE(lpDevI) ((lpDevI)->deviceType >= D3DDEVTYPE_DP2HAL)
#define IS_DX7HAL_DEVICE(lpDevI) ((lpDevI)->deviceType >= D3DDEVTYPE_DX7HAL)
#define IS_TLHAL_DEVICE(lpDevI) ((lpDevI)->deviceType >= D3DDEVTYPE_DX7TLHAL)
#define IS_MT_DEVICE(lpDevI) ( (lpDevI)->dwHintFlags & D3DDEVBOOL_HINTFLAGS_MULTITHREADED )
#define IS_HW_DEVICE(lpDevI) ((lpDevI)->dwFEFlags & D3DFE_REALHAL)
#define IS_FPU_SETUP(lpDevI) ((lpDevI)->dwHintFlags & D3DDEVBOOL_HINTFLAGS_FPUSETUP )

/*
 * Internal version of Direct3DTexture object; it has data after the vtable
 */
class DIRECT3DTEXTUREI : public CD3DAlloc
{
public:

    /*** Object Relations ***/
    LIST_ROOT(_blocks, _D3DI_TEXTUREBLOCK) blocks;
    /* Devices we're associated with */
    /* Next member in texture chain */
    LIST_MEMBER(DIRECT3DTEXTUREI) m_List;

    /*** Object Data ***/
    LPDIRECT3DI             lpDirect3DI;
    DDRAWI_DDRAWSURFACE_INT DDS1Tex;  //we need to keep the legacy
    LPDIRECTDRAWSURFACE7    lpDDS;
    LPDIRECTDRAWSURFACE7    lpDDSSys;
    DDSURFACEDESC2          ddsd;
    DWORD                   m_dwBytes;
    DWORD                   m_dwVidBytes;
    DWORD                   m_dwScene;
    DWORD                   m_dwPriority;
    DWORD                   m_dwTicks;
    DWORD                   m_dwHeapIndex;
    DWORD                   m_dwLOD;
    D3DTEXTUREHANDLE        m_hTex;
    BOOL                    m_bInUse;
    BOOL                    bDirty;

    /*
    * The special IUnknown interface for the aggregate that does
    * not punt to the parent object.
    */

public:
    DIRECT3DTEXTUREI();
    virtual HRESULT Initialize(LPDIRECT3DI lpDirect3DI, LPDIRECTDRAWSURFACE7 pDDS);
    virtual void Destroy();
    ULONGLONG Cost() const
    {
#ifdef _X86_
        ULONGLONG retval;
        _asm
        {
            mov     ebx, this;
            mov     edx, [ebx]DIRECT3DTEXTUREI.m_bInUse;
            shl     edx, 31;
            mov     eax, [ebx]DIRECT3DTEXTUREI.m_dwPriority;
            mov     ecx, eax;
            shr     eax, 1;
            or      edx, eax;
            mov     DWORD PTR retval + 4, edx;
            shl     ecx, 31;
            mov     eax, [ebx]DIRECT3DTEXTUREI.m_dwTicks;
            shr     eax, 1;
            or      eax, ecx;
            mov     DWORD PTR retval, eax;
        }
        return retval;
#else
        return ((ULONGLONG)m_bInUse << 63) + ((ULONGLONG)m_dwPriority << 31) + ((ULONGLONG)(m_dwTicks >> 1));
#endif
    }
    bool D3DManaged()
    {
        return this->lpDDSSys != NULL;
    }
    bool InVidmem()
    {
        return m_dwHeapIndex != 0;
    }

    void AddRef()
    {
        LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)(D3DManaged() ? this->lpDDSSys : this->lpDDS);
        ++(surf_int->dwIntRefCnt);
        ++(surf_int->lpLcl->dwLocalRefCnt);
        ++(surf_int->lpLcl->lpGbl->dwRefCnt);
    }
    void Release()
    {
        LPDDRAWI_DDRAWSURFACE_INT surf_int = (LPDDRAWI_DDRAWSURFACE_INT)(D3DManaged() ? this->lpDDSSys : this->lpDDS);
        if(surf_int->dwIntRefCnt > 1)  // only do this short way when it's not going away
        {
            --(surf_int->dwIntRefCnt);
            --(surf_int->lpLcl->dwLocalRefCnt);
            --(surf_int->lpLcl->lpGbl->dwRefCnt);
        }
        else
        {
            ((LPDIRECTDRAWSURFACE7)surf_int)->Release();
        }
    }

    virtual HRESULT SetPriority(DWORD dwPriority);
    virtual HRESULT GetPriority(LPDWORD lpdwPriority);
    virtual HRESULT SetLOD(DWORD dwLOD);
    virtual HRESULT GetLOD(LPDWORD lpdwLOD);
};

// DIRECT3DTEXTUREM is used when the texture is desired
// to be driver managed
class DIRECT3DTEXTUREM : public DIRECT3DTEXTUREI
{
public:
    HRESULT SetPriority(DWORD dwPriority);
    HRESULT GetPriority(LPDWORD lpdwPriority);
    HRESULT SetLOD(DWORD dwLOD);
    HRESULT GetLOD(LPDWORD lpdwLOD);
};

// DIRECT3DTEXTUREM is used when the texture is desired
// to be managed by Direct3D
class DIRECT3DTEXTURED3DM : public DIRECT3DTEXTUREM
{
public:
    void Destroy();
    HRESULT Initialize(LPDIRECT3DI lpDirect3DI, LPDIRECTDRAWSURFACE7 pDDS);
    void MarkDirtyPointers();
    HRESULT SetPriority(DWORD dwPriority);
    HRESULT SetLOD(DWORD dwLOD);
};

#define D3DVB_NUM_VIRTUAL_FUNCTIONS 10
// Internal VB create flag:
#define D3DVBFLAGS_CREATEMULTIBUFFER    0x80000000L

class CDirect3DVertexBuffer : public IDirect3DVertexBuffer7,
                              public CD3DAlloc
{
private:
    HRESULT CreateMemoryBuffer(LPDIRECT3DI lpD3DI,
                               LPDIRECTDRAWSURFACE7 *lplpSurface7,
                               LPDIRECTDRAWSURFACE  *lplpS,
                               LPVOID *lplpMemory,
                               DWORD dwBufferSize);
#ifdef VTABLE_HACK
    // The new vtable which is a read/write copy of the original to allow hacking
    PVOID newVtbl[D3DVB_NUM_VIRTUAL_FUNCTIONS];
#endif // VTABLE_HACK
    // Internal data
    DWORD dwPVFlags;
    LPDIRECT3DDEVICEI lpDevIBatched; // Is this VB batched in a device ? If so we need to flush the device
                                     // on Lock
    DWORD dwLockCnt;
    /* position.lpData = start of vertex buffer data
     * position.dwStride = Number of bytes per vertex
     */
    union {
        D3DDP_PTRSTRIDE position;
        D3DDP_PTRSTRIDE SOA;
    };
    DWORD dwNumVertices;
    DWORD fvf; // Used in Input and Output
    DWORD dwCaps;
    DWORD dwMemType; // DDSCAPS_VIDEOMEMORY, DDSCAPS2_VERTEXBUFFER
    DWORD srcVOP, dstVOP;
    DWORD nTexCoord;                        // Number of texture coordinates
    DWORD dwTexCoordSize[D3DDP_MAXTEXCOORD];// Size of every texture coordinate set
    DWORD dwTexCoordSizeTotal;              // Total size of all texture coordinates
    int             refCnt; /* Reference count */
    D3DFE_CLIPCODE* clipCodes;
    LPDIRECTDRAWSURFACE7 lpDDSVB; // DDraw Surface containing the actual VB memory
    LPDIRECTDRAWSURFACE lpDDS1VB; // same dds, legacy interface for legacy hal.
    BOOL bReallyOptimized;        // VB could have OPTIMIZED caps set, but be
                                  // not optimized
    /*** Object Relations */
    LPDIRECT3DI                 lpDirect3DI; /* Parent */
    LIST_MEMBER(CDirect3DVertexBuffer)list;  /* Next vertex buffer in IDirect3D */

    // Friends
    friend void hookVertexBufferToD3D(LPDIRECT3DI, LPDIRECT3DVERTEXBUFFERI);
    friend class DIRECT3DDEVICEI;
    friend class CDirect3DDeviceIDP2;
#ifdef VTABLE_HACK
    // This points to the original (compiler generated) read-only vtable of DIRECT3DDEVICEI
    PVOID* lpVtbl;
#endif // VTABLE_HACK
public:
    CDirect3DVertexBuffer(LPDIRECT3DI);
    ~CDirect3DVertexBuffer();
    HRESULT Init(LPDIRECT3DI, LPD3DVERTEXBUFFERDESC, DWORD);
    LPDIRECTDRAWSURFACE GetDDS() { return lpDDS1VB; }
    HRESULT Restore() { return lpDDSVB->Restore(); }
    void UnlockI();
    void BreakLock();
#ifndef WIN95
    HRESULT LockWorkAround(CDirect3DDeviceIDP2 *pDev);
    void UnlockWorkAround();
#endif // WIN95

    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj); // 0
    ULONG D3DAPI AddRef(); // 1
    ULONG D3DAPI Release(); // 2

    // IDirect3DVertexBuffer Methods
    HRESULT D3DAPI Lock(DWORD, LPVOID*, LPDWORD); // 3
    HRESULT D3DAPI Unlock(); // 4
    HRESULT D3DAPI ProcessVertices(DWORD, DWORD, DWORD, LPDIRECT3DVERTEXBUFFER7, DWORD, LPDIRECT3DDEVICE7, DWORD); // 5
    HRESULT D3DAPI GetVertexBufferDesc(LPD3DVERTEXBUFFERDESC); // 6
    HRESULT D3DAPI Optimize(LPDIRECT3DDEVICE7 lpDevI, DWORD dwFlags); // 7
    HRESULT D3DAPI ProcessVerticesStrided(DWORD, DWORD, DWORD, LPD3DDRAWPRIMITIVESTRIDEDDATA, DWORD, LPDIRECT3DDEVICE7, DWORD); // 8
protected:
    // Internal Lock
    virtual HRESULT D3DAPI LockI(DWORD, LPVOID*, LPDWORD); // 9
#ifdef VTABLE_HACK
    void VtblLockDefault()
    {
        // 3: IDirect3DVertexBuffer7::Lock
        newVtbl[3] = lpVtbl[3];
    }
    void VtblLockFast()
    {
        // 9: CDirect3DVertexBuffer::LockI
        newVtbl[3] = lpVtbl[9];
    }
#endif // VTABLE_HACK
    HRESULT ValidateProcessVertices(DWORD vertexOP,
                                    DWORD dwDstIndex,
                                    DWORD dwCount,
                                    LPVOID lpSrc,
                                    LPDIRECT3DDEVICE7 lpDevice,
                                    DWORD dwFlags);
    HRESULT DoProcessVertices(LPDIRECT3DVERTEXBUFFERI lpSrcI,
                              LPDIRECT3DDEVICEI lpDevI,
                              DWORD vertexOP,
                              DWORD dwSrcIndex,
                              DWORD dwDstIndex,
                              DWORD dwFlags);
};

// Now that LPDIRECT3DVERTEXBUFFERI is defined...
inline CDirect3DVertexBuffer* CDirect3DDeviceIDP2::TLVbuf_GetVBI()
{
    return static_cast<CDirect3DVertexBuffer*>(allocatedBuf);
}

inline LPDIRECTDRAWSURFACE CDirect3DDeviceIDP2::TLVbuf_GetDDS()
{
    return TLVbuf_GetVBI()->GetDDS();
}

// The instance of the class providing a guaranteed implementation
// This is defined / instantiated in pipeln\helxfrm.cpp
extern D3DFE_PVFUNCS GeometryFuncsGuaranteed;

extern void
D3DDeviceDescConvert(LPD3DDEVICEDESC7 lpOut,
                     LPD3DDEVICEDESC_V1 lpV1,
                     LPD3DHAL_D3DEXTENDEDCAPS lpExt);

#endif
// @@END_MSINTERNAL

#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cbldfncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void C_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void C_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\halprov.h ===
//----------------------------------------------------------------------------
//
// halprov.h
//
// Defines the IHalProvider interface.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _HALPROV_H_
#define _HALPROV_H_

// The following stuff is for Ramp Rasterizer.
typedef enum _RastRampServiceType
{
    RAMP_SERVICE_CREATEMAT              = 0,
    RAMP_SERVICE_DESTORYMAT             = 1,
    RAMP_SERVICE_SETMATDATA             = 2,
    RAMP_SERVICE_SETLIGHTSTATE          = 3,
    // This returns base, size, and a texture ramp.
    // Arg1 is a pointer to RAMP_RANGE_INFO.
    RAMP_SERVICE_FIND_LIGHTINGRANGE     = 4,
    // This service only calls BeginSceneHook. Both arg1 and arg2 are ignored.
    RAMP_SERVICE_CLEAR                  = 5,
    // Arg1 is a D3DMATERIALHANDLE, arg2 is a DWORD* to get the pixel value.
    RAMP_SERVICE_MATERIAL_TO_PIXEL      = 6,
    // Arg1 is 0 if end scene, != 0 if begin scene
    RAMP_SERVICE_SCENE_CAPTURE          = 8,
    // Arg1 is hTex
    RAMP_SERVICE_PALETTE_CHANGED        = 9,
} RastRampServiceType;

typedef enum _RastServiceType
{
    // Arg1 is a D3DCOLOR, and Arg2 is a DWORD* to get the pixel value
    RAST_SERVICE_RGB8COLORTOPIXEL              = 0,
} RastServiceType;

typedef HRESULT (*PFN_RASTRAMPSERVICE)
    (ULONG_PTR dwCtx, RastRampServiceType srvType, ULONG_PTR arg1, LPVOID arg2);

typedef HRESULT (*PFN_RASTSERVICE)
    (ULONG_PTR dwCtx, RastServiceType srvType, DWORD arg1, LPVOID arg2);

typedef struct _D3DHALPROVIDER_INTERFACEDATA
{
    DWORD                       dwSize;
    LPD3DHAL_GLOBALDRIVERDATA   pGlobalData;
    LPD3DHAL_D3DEXTENDEDCAPS    pExtCaps;
    LPD3DHAL_CALLBACKS          pCallbacks;
    LPD3DHAL_CALLBACKS2         pCallbacks2;
    LPD3DHAL_CALLBACKS3         pCallbacks3;

    PFN_RASTSERVICE             pfnRastService;
    LPDDHAL_GETDRIVERSTATE      pfnGetDriverState;
} D3DHALPROVIDER_INTERFACEDATA, *LPD3DHALPROVIDER_INTERFACEDATA;


#undef INTERFACE
#define INTERFACE IHalProvider

DECLARE_INTERFACE_(IHalProvider, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IHalProvider.
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion) PURE;
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion) PURE;
};

STDAPI GetHwHalProvider(REFCLSID riid,
                        IHalProvider **ppHalProvider, HINSTANCE *phDll, LPDDRAWI_DIRECTDRAW_GBL pDdGbl);
STDAPI GetSwHalProvider(REFCLSID riid,
                        IHalProvider **ppHalProvider, HINSTANCE *phDll);

STDAPI GetSwZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF);
STDAPI GetSwTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd, DWORD dwD3DDeviceVersion);

#endif // #ifndef _HALPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cbufread.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color reading routines for Blending.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "cbufread.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

//-----------------------------------------------------------------------------
//
// Read_B8G8R8
//
// Reads output buffer in BGR-888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8(PUINT8 pBits)
{
    return (*pBits | (*(pBits+1))<<8 | (*(pBits+2))<<16 | 0xff000000);
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8X8
//
// Reads output buffer in BGR-888x8 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8X8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface | 0xff000000;
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8A8
//
// Reads output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8A8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface;
}

//-----------------------------------------------------------------------------
//
// Read_B5G6R5
//
// Reads output in BGR-565 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G6R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 8 ) & 0xf8,
                (( uPixel >> 3) & 0xfc ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5
//
// Reads output in BGR-555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G5R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 7 ) & 0xf8,
                (( uPixel >> 2) & 0xf8 ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5A1
//
// Reads output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G5R5A1(PUINT8 pBits)
{
    INT16 iPixel = *(PINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( iPixel >> 7 ) & 0xf8,
                (( iPixel >> 2) & 0xf8 ),
                (( iPixel << 3) & 0xf8 ),
                (iPixel >> 15) & 0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_Palette8
//
// Reads output in Palette8 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_Palette8(PUINT8 pBits)
{
    // ATTENTION - This is not correct. But We assume Palette8 format will
    // normally not be used for alpha blending.
    return (D3DCOLOR)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\haldrv.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 - 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3di.h
 *  Content:    Direct3D HAL driver include file
 *
 ***************************************************************************/

#ifndef _HALDRV_H_
#define _HALDRV_H_

#undef DPF_MODNAME
#define DPF_MODNAME     "Direct3D HAL"

#define SURFACE_MEMORY(surf) \
(LPVOID)(((LPDDRAWI_DDRAWSURFACE_INT)(surf))->lpLcl->lpGbl->fpVidMem)

#ifdef TRACK_HAL_CALLS
#define RESET_HAL_CALLS(lpDevI) ((lpDevI)->hal_calls = 0)
#define TRACK_HAL_CALL(lpDevI) ((lpDevI)->hal_calls++)
#else
#define RESET_HAL_CALLS(lpDevI)
#define TRACK_HAL_CALL(lpDevI)
#endif


#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str


#ifdef WIN95

extern void _stdcall    GetpWin16Lock( LPVOID FAR *);
extern void _stdcall    _EnterSysLevel( LPVOID );
extern void _stdcall    _LeaveSysLevel( LPVOID );
extern LPVOID           lpWin16Lock;

#define LOCK_HAL(ret, lpDevI)                                           \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        _EnterSysLevel(lpWin16Lock);                                    \
    }                                                                   \
    ret = D3D_OK;                                                       \
}

#define UNLOCK_HAL(lpDevI)                                              \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        _LeaveSysLevel(lpWin16Lock);                                    \
    }                                                                   \
}

HRESULT D3DHAL_LockDibEngine(LPDIRECT3DDEVICEI lpDevI);
void D3DHAL_UnlockDibEngine(LPDIRECT3DDEVICEI lpDevI);

#define LOCK_DIBENGINE(ret, lpDevI)                                     \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        ret = D3DHAL_LockDibEngine(lpDevI);                             \
    }                                                                   \
    else    {                                                           \
        ret = D3D_OK;                                                   \
    }                                                                   \
}

#define UNLOCK_DIBENGINE(lpDevI)                                        \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        D3DHAL_UnlockDibEngine(lpDevI);                                 \
    }                                                                   \
}

#else // WIN95

#define LOCK_HAL(ret, lpDevI) ret = DD_OK
#define UNLOCK_HAL(lpDevI)
#define LOCK_DIBENGINE(ret, lpDevI) ret = DD_OK
#define UNLOCK_DIBENGINE(lpDevI)

#endif // WIN95


#define CALL_HALONLY_NOLOCK(ret, lpDevI, call, data)                          \
{                                                                             \
    if (lpDevI->lpD3DHALCallbacks->call) {                                    \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCallbacks->call)(data);                   \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}

#define CALL_HAL2ONLY_NOLOCK(ret, lpDevI, call, data)                         \
{                                                                             \
    if (lpDevI->lpD3DHALCallbacks2->call) {                                   \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCallbacks2->call)(data);                  \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}

#define CALL_HALCBONLY_NOLOCK(ret, lpDevI, call, data)                        \
{                                                                             \
    if (lpDevI->lpD3DHALCommandBufferCallbacks->call) {                       \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCommandBufferCallbacks->call)(data);      \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}

#define CALL_HAL3ONLY_NOLOCK(ret, lpDevI, call, data)                         \
{                                                                             \
    if (lpDevI->lpD3DHALCallbacks3->call) {                                   \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCallbacks3->call)(data);                  \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}


#define CALL_HALONLY(ret, lpDevI, call, data)                           \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HALONLY_NOLOCK(ret, lpDevI, call, data);                   \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}

#define CALL_HALCBONLY(ret, lpDevI, call, data)                         \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HALCBONLY_NOLOCK(ret, lpDevI, call, data);                 \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}

#define CALL_HAL2ONLY(ret, lpDevI, call, data)                          \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HAL2ONLY_NOLOCK(ret, lpDevI, call, data);                  \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}
//-----------------------------------------------------------------------
// Call for callbacks that are not required to be implemented
//
#define CALL_HAL3ONLY_OPTIONAL(ret, lpDevI, call, data)                 \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    if (lpDevI->lpD3DHALCallbacks3->call)                               \
    {                                                                   \
        CALL_HAL3ONLY(ret, lpDevI, call, data);                         \
    }                                                                   \
}
//-----------------------------------------------------------------------
#define CALL_HAL3ONLY(ret, lpDevI, call, data)                          \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HAL3ONLY_NOLOCK(ret, lpDevI, call, data);                  \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}

HRESULT D3DHAL_TextureCreate(LPDIRECT3DDEVICEI, LPD3DTEXTUREHANDLE, LPDIRECTDRAWSURFACE);
HRESULT D3DHAL_TextureDestroy(LPD3DI_TEXTUREBLOCK);
HRESULT D3DFE_SetViewportData(LPDIRECT3DDEVICEI, DWORD, LPD3DVIEWPORT2);
HRESULT D3DHAL_MaterialGetData(LPDIRECT3DDEVICEI, D3DMATERIALHANDLE, LPD3DMATERIAL);
HRESULT D3DHAL_LightSet(LPDIRECT3DDEVICEI, DWORD, LPD3DI_LIGHT);
HRESULT D3DHAL_SceneCapture(LPDIRECT3DDEVICEI, BOOL);

/*********************
 * HEL Calls
 *********************/

extern HRESULT D3DFE_Create(LPDIRECT3DDEVICEI lpDevI,
                            LPDIRECTDRAW lpDD,
                            LPDIRECTDRAW7 lpDD7,
                            LPDIRECTDRAWSURFACE lpDDS,
                            LPDIRECTDRAWSURFACE lpZ,
                            LPDIRECTDRAWPALETTE lpPal);
extern void D3DFE_Destroy(LPDIRECT3DDEVICEI lpDevI);

DWORD   D3DFE_QueryTextureFormat (LPDIRECT3DDEVICEI, LPDDSURFACEDESC*);
HRESULT D3DFE_UpdateTexture (LPDIRECT3DDEVICEI, DWORD, D3DTEXTUREHANDLE);
HRESULT D3DFE_Clear2(LPDIRECT3DDEVICEI lpDevI, DWORD dwFlags,DWORD numRect, LPD3DRECT lpRect, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);

#ifndef WIN95
__inline HRESULT CheckContextSurface(LPDIRECT3DDEVICEI lpDevI)
{
    if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface)
    {
        D3DHAL_SETRENDERTARGETDATA rtData;
        HRESULT ret;

        rtData.dwhContext = lpDevI->dwhContext;
        if (lpDevI->dwFEFlags & D3DFE_REALHAL)
        {
            if (lpDevI->lpDDSTarget)
                rtData.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl;
            else
                rtData.lpDDSLcl = NULL;
            
            if (lpDevI->lpDDSZBuffer)
                rtData.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSZBuffer)->lpLcl;
            else
                rtData.lpDDSZLcl = NULL;
            
        }
        else
        {
            rtData.lpDDS = lpDevI->lpDDSTarget;
            rtData.lpDDSZ = lpDevI->lpDDSZBuffer;
        }
        rtData.ddrval = 0;
        CALL_HAL2ONLY(ret, lpDevI, SetRenderTarget, &rtData);
        if (ret != DDHAL_DRIVER_HANDLED)
        {
            D3D_ERR ( "Driver did not handle SetRenderTarget" );
            // Need sensible return value in this case,
            // currently we return whatever the lpDevI stuck in here.
            return rtData.ddrval;
        }
        lpDevI->hSurfaceTarget = (DWORD)(((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface);
    }
    return(D3D_OK);
}
#endif //WIN95

// This struct is used for FindLightingRange RampService
typedef struct tagRAMP_RANGE_INFO
{
    DWORD base;
    DWORD size;
    LPVOID pTexRampMap;
    BOOL specular;
}RAMP_RANGE_INFO;

// This inline is for calling RastService when nothing special is required.
inline HRESULT CallRastService(LPDIRECT3DDEVICEI lpDevI,
                               RastServiceType ServiceType,
                               DWORD arg1,
                               LPVOID arg2)
{
    if (lpDevI->pfnRastService != NULL)
    {
        return lpDevI->pfnRastService(lpDevI->dwhContext,
                                     ServiceType, arg1, arg2);
    }
    else
    {
        return D3D_OK;
    }
}

#endif /* _HALDRV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cbufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR C_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR C_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR C_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR C_BufRead_Palette8(PUINT8 pBits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cbufwrt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color writing routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "cbufwrt.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

extern UINT16 g_uDitherTable[16];
//-----------------------------------------------------------------------------
//
// Write_B8G8R8X8_NoDither
//
// Writes output in BGR-888 format, aligned to 32 bits.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, 0x00);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8A8_NoDither
//
// Writes output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, pCtx->SI.uBA>>8);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_NoDither
//
// Writes output in BGR-565 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  0) & 0xf800) |
        ((pCtx->SI.uBG >>  5) & 0x07e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_Dither
//
// Writes output in BGR-565 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 2;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x3f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 11);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_NoDither
//
// Writes output in BGR-555 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_Dither
//
// Writes output in BGR-555 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_NoDither
//
// Writes output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f) |
        ((pCtx->SI.uBA >>  0) & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_Dither
//
// Writes output in BGRA-1555 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10) | (pCtx->SI.uBA & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8_NoDither
//
// Writes output in BGR-888 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    PUINT8 pSurface = (PUINT8)pS->pSurface;
    *pSurface++ = pCtx->SI.uBB>>8;
    *pSurface++ = pCtx->SI.uBG>>8;
    *pSurface++ = pCtx->SI.uBR>>8;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_Palette8_NoDither
//
// Writes output to the RGB8 palette format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uMapIdx = MAKE_RGB8(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8, pCtx->SI.uBB>>8);

    *(PUINT8)pS->pSurface = (UINT8)(pCtx->pRampMap[uMapIdx]);

    // just returns for C, since we really can't loop with function calls
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\inc\span.h ===
//----------------------------------------------------------------------------
//
// span.h
//
// Structures which define the interface between the edge walker to the
// span interpolator.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPAN_H_
#define _SPAN_H_

#include <d3ditype.h>
#include <d3dhal.h>

#ifdef __cplusplus
extern "C" {
#endif

// TBD make this machine independent
// don't leave any space between the elements of these structures
// currently smallest element is a UINT16, may have to change this to pack(1)
// if UINT8's are used.
#include <pshpack2.h>

// Limits, shifts and scaling factors for RASTSPAN and RASTPRIM data.
// C_*_LIMIT is the constant integer form of the limit for cases where
// direct integer comparisons can be done.
#define Z_LIMIT         g_fTwoPow31
#define C_Z_LIMIT       0x4f000000
#define Z16_FRAC_SHIFT  15
#define Z16_FRAC_SCALE  g_fTwoPow15
#define OO_Z16_FRAC_SCALE g_fOoTwoPow15
#define Z16_SHIFT       31
#define Z16_SCALE       g_fNearTwoPow31
#define OO_Z16_SCALE    g_fOoNearTwoPow31
#define Z32_FRAC_SHIFT  0
#define Z32_FRAC_SCALE  g_fOne
#define OO_Z32_FRAC_SCALE g_fOoNearTwoPow31
#define Z32_SHIFT       31
#define Z32_SCALE       g_fNearTwoPow31
#define OO_Z32_SCALE    g_fOoNearTwoPow31

#define TEX_LIMIT       g_fTwoPow31
#define C_TEX_LIMIT     0x4f000000
#define TEX_SHIFT       20
#define TEX_SCALE       g_fTwoPow20
#define OO_TEX_SCALE    g_fOoTwoPow20

#define COLOR_LIMIT     g_fTwoPow15
#define C_COLOR_LIMIT   0x47000000
#define COLOR_SHIFT     8
#define COLOR_SCALE     g_fTwoPow8

#define INDEX_COLOR_LIMIT   g_fTwoPow30
#define C_INDEX_COLOR_LIMIT 0x4e800000
#define INDEX_COLOR_SHIFT   16
#define INDEX_COLOR_SCALE   g_fTwoPow16
#define INDEX_COLOR_VERTEX_SHIFT 8
// Shift to go from fixed-point value in vertex color to proper shift.
#define INDEX_COLOR_FIXED_SHIFT (INDEX_COLOR_SHIFT - INDEX_COLOR_VERTEX_SHIFT)

#define LOD_LIMIT       g_fTwoPow15
#define C_LOD_LIMIT     0x47000000
#define LOD_SHIFT       11
#define LOD_SCALE       g_fTwoPow11
#define LOD_MIN         (-15)

#define OOW_LIMIT       g_fTwoPow31
#define C_OOW_LIMIT     0x4f000000
#define OOW_SHIFT       31
#define OOW_SCALE       g_fNearTwoPow31
#define OO_OOW_SCALE    g_fOoNearTwoPow31
#define W_SHIFT         16
#define W_SCALE         g_fTwoPow16
#define OO_W_SCALE      g_fOoTwoPow16
#define OOW_W_SHIFT     (OOW_SHIFT + W_SHIFT)
#define OOW_W_SCALE     g_fTwoPow47

#define FOG_LIMIT       g_fTwoPow15
#define C_FOG_LIMIT     0x47000000
#define FOG_SHIFT       8
#define FOG_SCALE       g_fTwoPow8
#define FOG_ONE_SCALE   g_fTwoPow16
#define FOG_255_SCALE   g_fTwoPow8

#define TEX_FINAL_SHIFT 16
#define TEX_FINAL_FRAC_MASK (0xffff)
#define TEX_TO_FINAL_SHIFT (TEX_SHIFT - TEX_FINAL_SHIFT)
// Multiply with span W so that [U|V]oW times resulting W is in the
// final shift position.  1 / (W_SHIFT + TEX_TO_FINAL_SHIFT).
#define TEX_UVW_TO_FINAL_SCALE g_fOoTwoPow20
// Divide by span OoW so that [U|V]oW times resulting W is in the
// final shift position.  OOW_SHIFT - TEX_TO_FINAL_SHIFT.
#define TEX_OOW_TO_FINAL_SCALE g_fTwoPow27

#define RAST_DIRTYBITS_SIZE     (((D3D_MAXRENDERSTATES + (D3DHAL_TSS_MAXSTAGES * D3DHAL_TSS_STATESPERSTAGE)) >> 3) + 2)
#define RAST_TSS_DIRTYBIT( _Stage, _State ) \
    ((UINT32)(D3D_MAXRENDERSTATES + \
      ((_Stage) * D3DHAL_TSS_STATESPERSTAGE) + (_State)))

typedef struct _UV_UNION {
    union {
        D3DVALUE    tu;
        D3DVALUE    dvTU;

        INT32 iU;
        FLOAT fU;

        INT32 iUoW;        // 1.11.20 texture coordinates
        FLOAT fUoW;

        INT32 iDUoWDX;         // 1.11.20
        FLOAT fDUoWDX;

        INT32 iDUoWDY; // 1.11.20
        FLOAT fDUoWDY;
    };
    union {
        D3DVALUE    tv;
        D3DVALUE    dvTV;

        INT32 iV;
        FLOAT fV;

        INT32 iVoW;        // 1.11.20 texture coordinates
        FLOAT fVoW;

        INT32 iDVoWDX;         // 1.11.20
        FLOAT fDVoWDX;

        INT32 iDVoWDY; // 1.11.20
        FLOAT fDVoWDY;
    };
}UV_UNION;

// General per span data.  This structure is designed to be qword aligned.
typedef struct tagD3DI_RASTSPAN
{
    // Space separated things are quad words and are intended to be
    // quad word aligned.
    UINT16 uPix;            // count of pixels to render
    INT16 iDFog;            // 1.7.8 delta fog
    UINT16 uX;              // 16.0 start X
    UINT16 uY;              // 16.0 start Y

    INT16 iLOD;             // 1.4.11 start LOD
    INT16 iDLOD;            // 1.4.11 delta LOD (so piecewise linear LOD interp
                            //                  is possible)
    union
    {
        UINT32 uZ;          // 16.15 start Z
        FLOAT fZ;
    };

    // If texture stuff (iOoW, iUoW1, etc.) is 32 bits (even if we iterate
    // them at 16 bits under MMX sometimes)
    union
    {
        INT32 iW;           // 1.15.16 first inverted W of span
        FLOAT fW;
    };
    union
    {
        INT32 iOoW;         // 1.31 start 1/W (signed since they are target
                            //                 of MMX multiply)
        FLOAT fOoW;
    };

    UV_UNION UVoW[D3DHAL_TSS_MAXSTAGES];

    union
    {
        struct
        {
            UINT16 uB, uG, uR, uA;  // 8.8 start colors
        };
        struct
        {
            INT32 iIdx, iIdxA;      // 1.8.16 ramp start color and alpha
        };
    };

    UINT16 uBS, uGS, uRS;  // 8.8 start specular colors
    // Specular alpha is fog.  This prevents specular color from
    // being unioned with the texture 2 coordinates below.
    UINT16 uFog;           // 1.7.8 start fog value


    // Pointers into surface and Z buffers interpolated by the edge walker.
    PUINT8 pSurface;
    PUINT8 pZ;

    UINT8 pPad[16];

#ifdef _IA64_
    UINT8 Padding[24];
#endif // _IA64_

} D3DI_RASTSPAN, *PD3DI_RASTSPAN;   // sizeof(D3DI_RASTSPAN) == 64
typedef CONST D3DI_RASTSPAN *PCD3DI_RASTSPAN;

// D3DI_RASTPRIM uFlags
#define D3DI_RASTPRIM_X_DEC     (0x00000001L)   // Else X increments.

// General per primitive for edge walking and span scanning.
// Can be expanded to suit the edge walker.
// The information the span rasterizer needs is sensitive to qwords for
// the MMX rasterizers.
typedef struct tagD3DI_RASTPRIM
{
    UINT32 uFlags;
    UINT16 uSpans;              // count of spans
    UINT16 uResvd1;             // perhaps we want to expand uSpans to 32 bits,
                                // or perhaps 16 flag bits are enough

    // X gradients
    union
    {
        INT32 iDZDX;            // 1.16.15
        FLOAT fDZDX;
    };
    union
    {
        INT32 iDOoWDX;          // 1.31
        FLOAT fDOoWDX;
    };

    UV_UNION DUVoWDX[D3DHAL_TSS_MAXSTAGES];

    union
    {
        struct
        {
            INT16 iDBDX, iDGDX, iDRDX, iDADX;   // 1.7.8
        };
        struct
        {
            FLOAT fDBDX, fDGDX, fDRDX, fDADX;
        };
        struct
        {
            INT32 iDIdxDX, iDIdxADX;            // 1.8.16
        };
    };

    struct
    {
        union
        {
            struct
            {
                INT16 iDBSDX, iDGSDX, iDRSDX; // 1.7.8
            };
            struct
            {
                FLOAT fDBSDX, fDGSDX, fDRSDX;
                FLOAT fPad; // Padding to keep this set of attributes
                            // an even multiple of quadwords.
            };
        };
    };

    // Y gradients for some attributes so that span routines
    // can do per-pixel mipmapping.
    UV_UNION DUVoWDY[D3DHAL_TSS_MAXSTAGES];


    union
    {
        INT32 iDOoWDY;          // 1.31
        FLOAT fDOoWDY;
    };

    struct tagD3DI_RASTPRIM *pNext;

    // Pad to an even multiple of 32 bytes for cache alignment.
    UINT8 uPad[72];

#ifdef _IA64_
    UINT8 Padding[24];
#endif // _IA64_

    // Anything else needed

} D3DI_RASTPRIM, *PD3DI_RASTPRIM;
typedef CONST D3DI_RASTPRIM *PCD3DI_RASTPRIM;

// D3DI_SPANTEX uFlags
#define D3DI_SPANTEX_HAS_TRANSPARENT    (0x00000001L)
#define D3DI_SPANTEX_SURFACES_LOCKED    (0x00000002L)
#define D3DI_SPANTEX_MAXMIPLEVELS_DIRTY (0x00000004L)
// Palette with alpha
#define D3DI_SPANTEX_ALPHAPALETTE          (0x00000008L)

//  D3DI_SPANTEX uFormat - NOTE: these enumerations match the sequence in the
//  array of DDPIXELFORMAT structures defined for matching in texture creation
//
//  NOTE: these must be kept consistent with the RRPixelFormats for the reference rasterizer
typedef enum _D3DI_SPANTEX_FORMAT
{
    D3DI_SPTFMT_NULL     = 0,
    D3DI_SPTFMT_B8G8R8   = 1,
    D3DI_SPTFMT_B8G8R8A8 = 2,
    D3DI_SPTFMT_B8G8R8X8 = 3,
    D3DI_SPTFMT_B5G6R5   = 4,
    D3DI_SPTFMT_B5G5R5   = 5,
    D3DI_SPTFMT_PALETTE4 = 6,
    D3DI_SPTFMT_PALETTE8 = 7,
    D3DI_SPTFMT_B5G5R5A1 = 8,
    D3DI_SPTFMT_B4G4R4   = 9,
    D3DI_SPTFMT_B4G4R4A4 =10,
    D3DI_SPTFMT_L8       =11,       /* 8 bit luminance-only */
    D3DI_SPTFMT_L8A8     =12,       /* 16 bit alpha-luminance */
    D3DI_SPTFMT_U8V8     =13,       /* 16 bit bump map format */
    D3DI_SPTFMT_U5V5L6   =14,       /* 16 bit bump map format with luminance */
    D3DI_SPTFMT_U8V8L8   =15,       /* 24 bit bump map format with luminance */

    D3DI_SPTFMT_UYVY     =16,       /* UYVY format for PC98 compliance */
    D3DI_SPTFMT_YUY2     =17,       /* YUY2 format for PC98 compliance */
    D3DI_SPTFMT_DXT1    =18,       /* S3 texture compression technique 1 */
    D3DI_SPTFMT_DXT2    =19,       /* S3 texture compression technique 2 */
    D3DI_SPTFMT_DXT3    =20,       /* S3 texture compression technique 3 */
    D3DI_SPTFMT_DXT4    =21,       /* S3 texture compression technique 4 */
    D3DI_SPTFMT_DXT5    =22,       /* S3 texture compression technique 5 */
    D3DI_SPTFMT_B2G3R3   =23,       /* 8 bit RGB texture format */

    D3DI_SPTFMT_Z16S0    =32,
    D3DI_SPTFMT_Z24S8    =33,
    D3DI_SPTFMT_Z15S1    =34,
    D3DI_SPTFMT_Z32S0    =35,
    D3DI_SPTFMT_S1Z15    =36,
    D3DI_SPTFMT_S8Z24    =37,

    // NOTE: this must be changed in conjunction with RR_STYPE in ref\inc\refrast.hpp

    D3DI_SPTFMT_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DI_SPANTEX_FORMAT;


// This encompasses all needed info about a chain of DD surfaces being used
// as a potentially mipmapped texture.
#define SPANTEX_MAXCLOD   11        // up to 2kx2k texture, all we can do with MMX INT16
                                    // U's and V's
typedef struct tagD3DI_SPANTEX
{
    UINT32  dwSize;

    INT32   iGeneration;            // incremented when the texture changes
    UINT32  uFlags;                 // perspective, etc.
    D3DI_SPANTEX_FORMAT  Format;    // pixel format of the texture
    D3DTEXTUREADDRESS TexAddrU, TexAddrV; // texture address mode
    D3DTEXTUREMAGFILTER  uMagFilter;// TEX3 style filter information
    D3DTEXTUREMINFILTER  uMinFilter;// ATTENTION we could express this information more compactly
    D3DTEXTUREMIPFILTER  uMipFilter;
    D3DCOLOR BorderColor;           // border color for the texture
                                    // (for D3DTADDRESS_BORDER)
    D3DCOLOR TransparentColor;      // color key on texture read

    FLOAT fLODBias;                 // Texture3 LOD bias value.

    PUINT8  pBits[SPANTEX_MAXCLOD]; // pointer for each LOD
    PUINT32 pRampmap;               // set by ramp rasterizer, if necessary
    PUINT32 pPalette;               // pointer to palette, if necessary
    INT32   iPaletteSize;           // size of palette
    INT32   cLOD;                   // contains count of levels - 1 (0 means 1 level)
                                    // to use
    INT32   cLODTex;                // contains count of levels - 1 (0 means 1 level)
                                    // that are actually in the texture
                                    // cLODTex >= cLOD is always true
    INT32   iMaxMipLevel;           // index of largest mip map to use.  0 means use largest.
    INT     iMaxScaledLOD;          // ((cLOD + 1) scaled by LOD_SCALE) - 1.
    INT16   iSizeU, iSizeV;         // LOD 0 size (only support power of 2
                                    // textures)
    INT16   iShiftU, iShiftV;       // LOD 0 log2 size (valid for power-of-2
                                    // size only)
    INT16   iShiftPitch[SPANTEX_MAXCLOD]; // log2 pitch for each LOD
#if (SPANTEX_MAXCLOD & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT16   iPitchPad;
#endif
    UINT16  uMaskU, uMaskV;         // LOD 0 (1<<log2(size))-1
    // Variables for arithmetic address computation.  Computed by DoTexAddrSetup.
    INT16   iFlipMaskU, iFlipMaskV;
    INT16   iClampMinU, iClampMinV;
    INT16   iClampMaxU, iClampMaxV;
    INT16   iClampEnU, iClampEnV;

    LPDIRECTDRAWSURFACE pSurf[SPANTEX_MAXCLOD]; // Added for TextureGetSurf
                                                // and Lock/Unlock Texture

} D3DI_SPANTEX, *PD3DI_SPANTEX;

// Color structure for blending etc. with enough room for 8.8 colors.
// Even for 8 bit colors, this is convenient for lining up the colors
// as we desire in MMX for 16 bit multiplies
typedef struct tagD3DI_RASTCOLOR
{
    UINT16 uB, uG, uR, uA;
} D3DI_RASTCOLOR, *PD3DI_RASTCOLOR;

// This structure has all the temporary storage needed for all the iterated
// values to route the span information between the layers.
// TBD there is lots more to add here, do texture mapping first
typedef struct tagD3DI_SPANITER
{
    // make the colors use the same order as RASTCOLOR above
    UINT16 uBB, uBG, uBR, uBA;  // 8.8 blended color
    UINT16 uFogB, uFogG, uFogR, uFog;   // 8.8 fog color, 0.16 fog value
    INT16  iFogBDX, iFogGDX, iFogRDX, iDFog;  // 1.7.8 fog color deltas
    UINT32 uZDeferred;          // storage for Z for deferred Z write

    UV_UNION TexUV[D3DHAL_TSS_MAXSTAGES];
    D3DCOLOR    TexCol[D3DHAL_TSS_MAXSTAGES];  // [Texture]

    INT32 iDW;              // to remember last delta W in
    UINT16 uDitherOffset;
    INT16  iXStep;          // 1 or -1
    INT16 iSpecialW;        // negative for first or last 3 pixels of span
    INT16 bStencilPass;     // 1 if stencil test passed, otherwise 0
    union
    {
        INT32 iOoW;         // previous OoW to pass between texaddr stages
        FLOAT fOoW;
    };
} D3DI_SPANITER, *PD3DI_SPANITER;

// Z compare macro
// This does depend on the result of a compare being 0 or 1 (for the final XOR, since C
// doesn't have a logical XOR), but this has been true on all processors and
// compilers for some time.
#define ZCMP16(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Assumes the most significant bit of Z is 0 (31 bit Z)
#define ZCMP32(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Alpha Test compare macro
#define ACMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iAAndMask) - (p)->iANeg) >= 0) ^ (p)->iAXorMask)

// Stencil Test compare macro
#define SCMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iSAndMask) - (p)->iSNeg) >= 0) ^ (p)->iSXorMask)


// Helper macro that converts [0, 0xff] to [0, 5], linearly
#define RGB8_CHANNEL(rgb)   ((((rgb) * 5) + 0x80) >> 8)

// Defines conversion from 24 bit RGB to 8 bit palette index.  Each color has 6 values
// resulting in 6**3 == 216 required colors in the palette.
#define MAKE_RGB8(r, g, b) (RGB8_CHANNEL(r) * 36       \
                 + RGB8_CHANNEL(g) * 6                 \
                 + RGB8_CHANNEL(b))

// forward declaration of D3DI_RASTCTX
struct tagD3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX          D3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX         *PD3DI_RASTCTX;
typedef CONST struct tagD3DI_RASTCTX   *PCD3DI_RASTCTX;

// typedef for each rendering layer
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef void (CDECL *PFNSPANLAYER)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS);
typedef void (CDECL *PFNTEXADDRESS)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS, INT32 iTex);

// typedef texture read functions
// this is an actual function so it can be called multiple times
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef D3DCOLOR (CDECL *PFNTEXREAD)(INT32 iU, INT32 iV, INT32 iShiftU,
                                     PUINT8 pBits, PD3DI_SPANTEX pTex);

// Typedef for span rendering function pointers.
typedef HRESULT (CDECL *PFNRENDERSPANS)(PD3DI_RASTCTX pCtx);

// typedef for alpha blending functions.
typedef void (CDECL *PFNBLENDFUNC)(PUINT16 pR, PUINT16 pG, PUINT16 pB,
                                   PUINT16 pA, D3DCOLOR DestC,
                                   PD3DI_RASTCTX pCtx);

// typedef for buffer read functions.
typedef D3DCOLOR (CDECL *PFNBUFREAD)(PUINT8 pBits);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDGET)(PD3DI_RASTCOLOR pArg1,
                                     PD3DI_RASTCOLOR pArg2,
                                     PD3DI_RASTCOLOR pInput,
                                     PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                     INT32 iTex);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDOP)(PD3DI_RASTCOLOR pOut,
                                    PD3DI_RASTCOLOR pArg1,
                                    PD3DI_RASTCOLOR pArg2,
                                    PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                    INT32 iTex);

// Prototype for set of bead selections.
typedef enum tagD3DI_BEADSET
{
    D3DIBS_CMMX = 1,        // C emulation of MMX beads
    D3DIBS_MMX = 2,         // MMX beads
    D3DIBS_C = 3,           // C beads
    D3DIBS_RAMP = 4,        // Ramp beads
    D3DIBS_MMXASRGB = 5,    // MMX selected for RGB rasterizer
} D3DI_BEADSET;

// General span scanning context
struct tagD3DI_RASTCTX
{
    UINT32   dwSize;

    //////////////////////////////////////////////////////////////////////
    // Temporary storage for span rendering routines.  Could be global.
    // Not set by caller, and not changed by SpanInit.
    //

    D3DI_SPANITER SI;

    //////////////////////////////////////////////////////////////////////
    // Data that must be set by caller before a SpanInit.
    //

    // we may want to put a pointer to a DDSURFACEDESC or something like it
    // instead of this
    PUINT8 pSurfaceBits;
    INT iSurfaceStride;
    INT iSurfaceStep;
    INT iSurfaceBitCount;
    INT iSurfaceType;     // or however we end up expressing this
    PUINT32 pRampMap;     // pointer to ramp map, if necessary
    LPDIRECTDRAWSURFACE pDDS;

    PUINT8 pZBits;
    INT iZStride;
    INT iZStep;
    INT iZBitCount;
    LPDIRECTDRAWSURFACE pDDSZ;

    // Clip area.
    RECT Clip;

    // Sign of face area that should be culled.  Zero is clockwise,
    // one is CCW and everything else means no culling.
    UINT uCullFaceSign;

    union
    {
        DWORD pdwRenderState[D3D_MAXRENDERSTATES];
        FLOAT pfRenderState[D3D_MAXRENDERSTATES];
    };

    // Since we are adjusting the order of texIdx in the vertex to suit that
    // defined in state TEXCOORDINDEX, we need a copy of adjusted WRAP state.
    // This is declared immediately after pdwRenderState so that we can share
    // a register with it in the assembly code.
    // WARNING WARNING - THIS ABSOLUTELY NEEDS TO BE FOLLOWING pdwRenderState
    // IMMEDIATELY. ASM CODE DEPENDS ON THIS.
    DWORD pdwWrap[D3DHAL_TSS_MAXSTAGES];

    union
    {
    DWORD pdwTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];
    FLOAT pfTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];
    };

    // first texture object contains information for texture for first pair
    // of texture coordinates, second contains texture for second pair of
    // texture coordinates, etc.
    PD3DI_SPANTEX pTexture[D3DHAL_TSS_MAXSTAGES];
    // Number of active textures. 0 - texture off; 1 - pTexture[0] is valid
    // 2 - both pTexture[0] and pTexture[1] are valid
    UINT cActTex;
    // Number of active texture stages for blending. It's set in spaninit()
    // and used in TexBlend_TexM_Gen.
    UINT cActBldStage;

    // Dirty bits for render states.
    // ATTENTION - We can reduce the size  to have one bit for each group of
    // states when we implement the light weighted beed chooser.
    // Right now, it's set by SetRenderState and cleared after SpanInit is
    // called. The bit corresponding to D3DHAL_MAX_RSTATES_AND_STAGES is set
    // whenever a state is changed.
    UINT8 StatesDirtyBits[RAST_DIRTYBITS_SIZE];

#if (RAST_DIRTYBITS_SIZE & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT8   StatesDirtyBitsPad0;
#endif
#if (RAST_DIRTYBITS_SIZE & 2) != 0
    // Pad following fields to a DWORD boundary.
    INT16   StatesDirtyBitsPad1;
#endif

    // Version# of the D3DDevice corresponding to this Context
    UINT32  uDevVer;

    //////////////////////////////////////////////////////////////////////
    // Data is set by SpanInit given the input above.
    //

    // Span rendering entry point.
    PFNRENDERSPANS  pfnRenderSpans;

    // function pointers for the beads
    PFNSPANLAYER    pfnBegin;
    PFNSPANLAYER    pfnLoopEnd;
    PFNSPANLAYER    pfnTestPassEnd;
    PFNSPANLAYER    pfnTestFailEnd;

    PFNTEXADDRESS   pfnTexAddr[D3DHAL_TSS_MAXSTAGES];
    PFNSPANLAYER    pfnTexAddrEnd;
    PFNTEXREAD      pfnTexRead[D3DHAL_TSS_MAXSTAGES];
    PFNSPANLAYER    pfnTexBlendEnd;
    PFNTEXBLENDGET  pfnTexBlendGetColor[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDGET  pfnTexBlendGetAlpha[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDOP   pfnTexBlendOpColor[D3DHAL_TSS_MAXSTAGES];
    PFNTEXBLENDOP   pfnTexBlendOpAlpha[D3DHAL_TSS_MAXSTAGES];

    PFNSPANLAYER    pfnColorGenEnd;
    PFNSPANLAYER    pfnAlphaTestPassEnd;
    PFNSPANLAYER    pfnAlphaTestFailEnd;
    PFNBLENDFUNC    pfnSrcBlend;
    PFNBLENDFUNC    pfnDestBlend;
    PFNBUFREAD      pfnBufRead;
    PFNSPANLAYER    pfnColorBlendEnd;

    // Optional bead that can be called after every pixel for rasterizers
    // which loop beads rather than returning.
    PFNSPANLAYER    pfnPixelEnd;

    // Optional bead that can be called after every span for rasterizers
    // which loop spans rather than returning.
    PFNSPANLAYER    pfnSpanEnd;

    // arithmetic Z variables
    INT32 iZAndMask, iZNeg, iZXorMask;

    // arithmetic Alpha test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iAAndMask, iANeg, iAXorMask;
    // 8.8 Alpha reference value
    INT32 iARef;

    // arithmetic stencil test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iSAndMask, iSNeg, iSXorMask;

    // Pointer to first RASTPRIM.
    PD3DI_RASTPRIM pPrim;

    // Pointer to next context.
    PD3DI_RASTCTX pNext;

    // Current BeadTable to use
    D3DI_BEADSET BeadSet;

    // Bit 0 set disables ml1, etc.
#define MMX_FP_DISABLE_MASK_NUM 1
    DWORD dwMMXFPDisableMask[MMX_FP_DISABLE_MASK_NUM];

    // RampLightingDriver, should be NULL except for RampRast and 8 bit palettized RGB
    // output surface cases.
    LPVOID pRampDrv;
    // RAMP_RANGE_INFO RampInfo;
    DWORD RampBase;
    DWORD RampSize;
    PUINT32 pTexRampMap;
    BOOL bRampSpecular;

#ifdef DBG
#define NAME_LEN    128
    char    szTest[NAME_LEN];
    char    szTestFail[NAME_LEN];
    char    szTexAddr[D3DHAL_TSS_MAXSTAGES][NAME_LEN];
    char    szTexRead[D3DHAL_TSS_MAXSTAGES][NAME_LEN];
    char    szTexBlend[NAME_LEN];
    char    szColorGen[NAME_LEN];
    char    szAlphaTest[NAME_LEN];
    char    szColorBlend[NAME_LEN];
    char    szSrcBlend[NAME_LEN];
    char    szDestBlend[NAME_LEN];
    char    szBufRead[NAME_LEN];
    char    szBufWrite[NAME_LEN];
#undef  NAME_LEN
#endif
};

// Data passed to the span rendering functions looks like this:
//
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   |   RASTSPAN (as many as RASTPRIM.uSpans says there are)
// |   RASTPRIM
// |   |   RASTSPAN
// |   NULL
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   NULL
// NULL
//
// The given RASTCTX is the head of a list of contexts.  Each context
// points to a list of RASTPRIMs.  Each RASTPRIM structure is immediately
// followed by RASTPRIM.uSpans RASTSPAN structures.

// Prototype for state validation call.
HRESULT SpanInit(PD3DI_RASTCTX pCtx);

// This is used to pack a FVF vertex into one understand by OptRast so it
// does not need to figure out where to get the data it needs. This struct
// can be modified to accommodate more data and it can be broken into more
// specilized and smalled structs.
// Right now, it is an extension of D3DTLVERTEX, and the extra uv is at the
// very end so that OptRast can treat it as a D3DTLVERTEX if only the first
// part of the data needs to be accessed.
typedef struct _RAST_GENERIC_VERTEX {
    union {
    D3DVALUE    sx;             /* Screen coordinates */
    D3DVALUE    dvSX;
    };
    union {
    D3DVALUE    sy;
    D3DVALUE    dvSY;
    };
    union {
    D3DVALUE    sz;
    D3DVALUE    dvSZ;
    };
    union {
    D3DVALUE    rhw;            /* Reciprocal of homogeneous w */
    D3DVALUE    dvRHW;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DCOLOR    specular;       /* Specular component of vertex */
    D3DCOLOR    dcSpecular;
    };
    UV_UNION  texCoord[D3DHAL_TSS_MAXSTAGES]; /* Texture coordinates */
}RAST_GENERIC_VERTEX, *PRAST_GENERIC_VERTEX;

// Vertex types supported by OptRast
typedef enum _RAST_VERTEX_TYPE
{
    RAST_TLVERTEX       = 1,    /* (Legacy) TL vertex */
    RAST_GENVERTEX      = 2,    /* Generic FVF vertex */
    RAST_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
}RAST_VERTEX_TYPE;

#include <poppack.h>

#ifdef __cplusplus
}
#endif

#endif // _SPAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cloop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void C_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cbufwrt.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void C_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cspnpars.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// C_RenderSpansAny
//
// All mode general span routine.
//
//-----------------------------------------------------------------------------
HRESULT C_RenderSpansAny(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            pCtx->pfnBegin(pCtx, pP, pS);

            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cspnutil.cpp ===
//----------------------------------------------------------------------------
//
// cspnutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cspnpars.h ===
//----------------------------------------------------------------------------
//
// cspnpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

HRESULT C_RenderSpansAny(PD3DI_RASTCTX pCtx);

#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cspnutil.h ===
//----------------------------------------------------------------------------
//
// cspnutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

//-----------------------------------------------------------------------------
//
// imul32h_s20
//
// Returns (x*y)>>20
//
//-----------------------------------------------------------------------------
inline INT32 imul32h_s20(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        shrd eax, edx, 20
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 20);
#endif
}


#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\link\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=d3dim700
TARGETNAME=d3dim700
TARGETPATH=obj

TARGETTYPE=DYNLINK
DLLDEF=$O\$(TARGETNAME).def

!IFDEF D3DBBT
X3DLIB=x3dbbt.lib
KINTELLIB=ikpsgp7bbt.lib
WINTELLIB=iwpsgp7bbt.lib
!ELSE
X3DLIB=x3d.lib
KINTELLIB=ikpsgp700.lib
WINTELLIB=iwpsgp700.lib
!ENDIF

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

TARGETLIBS = \
        $(BASEDIR)\public\sdk\lib\*\gdi32.lib\
        $(BASEDIR)\public\sdk\lib\*\user32.lib\
        $(BASEDIR)\public\sdk\lib\*\advapi32.lib\
        $(BASEDIR)\public\sdk\lib\*\uuid.lib

!if !($(AMD64) || $(IA64))
TARGETLIBS=$(TARGETLIBS) \
           $(D3DDX7)\lib\$(PLAT_DIR)\*\$(KINTELLIB) \
           $(D3DDX7)\lib\$(PLAT_DIR)\*\$(WINTELLIB) \
           $(D3DDX7)\lib\$(PLAT_DIR)\*\$(X3DLIB)
!endif

LINKLIBS = \
        $(D3DDX7)\util\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dutil.lib \
        $(D3DDX7)\tnl\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dtnl.lib \
        $(D3DDX7)\fe\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dfe.lib \
        $(D3DDX7)\rast\mmxemul\$(PLAT_DIR)\$(_OBJ_DIR)\*\mmxemul.lib \
        $(D3DDX7)\rast\cspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rcspan.lib \
        $(D3DDX7)\rast\mlspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rmlspan.lib \
        $(D3DDX7)\rast\spaninit\$(PLAT_DIR)\$(_OBJ_DIR)\*\rspanini.lib \
        $(D3DDX7)\rast\setup\$(PLAT_DIR)\$(_OBJ_DIR)\*\rsetup.lib \
        $(D3DDX7)\rast\d3dif\$(PLAT_DIR)\$(_OBJ_DIR)\*\rd3dif.lib

!if !($(AMD64) || $(IA64))
LINKLIBS=$(LINKLIBS) \
        $(D3DDX7)\rast\mmxspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rmmxspan.lib \
!endif

DLLENTRY = _DllMainCRTStartup

SOURCES = ..\d3dim700.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\ctexfilt.h ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void TexFiltBilinear(D3DCOLOR *pOut, INT32 iUFrac, INT32 iVFrac, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\ctexfilt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "ctexfilt.h"

//-----------------------------------------------------------------------------
//
// TexFiltBilinear
//
// Given the basic bilinear equations
//
// A = C00 + U*(C10 - C00)
// B = C01 + U*(C11 - C01)
// C = A + V*(B-A)
//
// This routine is based on the re-arrangement of this equation into
//
// C = C00*(1-U-V+U*V) + C10*(U-U*V) + C10(V-U*V) + C11*(U*V)
// or
// C = C00*s1 + C10*s2 + C10*s3 + C11*s4
//
//-----------------------------------------------------------------------------
void TexFiltBilinear(D3DCOLOR *pOut, INT32 iU, INT32 iV, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11)
{
#define SIMPLE_BILINEAR 1
#ifdef SIMPLE_BILINEAR
    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    r00 = r00 + ((iU*(r10 - r00)) >> 16);
    g00 = g00 + ((iU*(g10 - g00)) >> 16);
    b00 = b00 + ((iU*(b10 - b00)) >> 16);
    a00 = a00 + ((iU*(a10 - a00)) >> 16);

    r01 = r01 + ((iU*(r11 - r01)) >> 16);
    g01 = g01 + ((iU*(g11 - g01)) >> 16);
    b01 = b01 + ((iU*(b11 - b01)) >> 16);
    a01 = a01 + ((iU*(a11 - a01)) >> 16);

    r00 = r00 + ((iV*(r01 - r00)) >> 16);
    g00 = g00 + ((iV*(g01 - g00)) >> 16);
    b00 = b00 + ((iV*(b01 - b00)) >> 16);
    a00 = a00 + ((iV*(a01 - a00)) >> 16);

#else
    // another potential implementation
    INT32 s1, s2, s3, s4;
    s4 = (iU * iV)>>16;         // (0.16 * 0.16) >> 16 = 0.16
    s3 = iV - s4;
    s2 = iU - s4;
    s1 = 0x10000 - iV - s2;

    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    // 8.0 * 0.16 == 8.16 >> 16 == 8.0
    r00 = (r00*s1 + r10*s2 + r01*s3 + r11*s4)>>16;
    g00 = (g00*s1 + g10*s2 + g01*s3 + g11*s4)>>16;
    b00 = (b00*s1 + b10*s2 + b01*s3 + b11*s4)>>16;
    a00 = (a00*s1 + a10*s2 + a01*s3 + a11*s4)>>16;
#endif

    *pOut = RGBA_MAKE(r00, g00, b00, a00);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
#include "cspnutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\makefile.inc ===
$(GENTGT)\pmfns_mh.h: ..\pmfns_mh.mh $(RAST_STD_M4)

$(GENTGT)\pmfns.cpp: ..\pmfns.mcp $(RAST_STD_M4)

$(GENTGT)\dprim2.cpp: ..\dprim2.mcp $(RAST_STD_M4)

$(GENTGT)\refif.cpp: ..\refif.mcp $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\cbldfncs.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "cbldfncs.h"

//-----------------------------------------------------------------------------
//
// SrcBlendZero
//
// (0, 0, 0, 0) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// SrcBlendOne
//
// (1, 1, 1, 1) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = pCtx->SI.uBR;
    *pG = pCtx->SI.uBG;
    *pB = pCtx->SI.uBB;
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcColor
//
// (Rs, Gs, Bs, As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*(pCtx->SI.uBR>>8);
    *pG = (pCtx->SI.uBG>>8)*(pCtx->SI.uBG>>8);
    *pB = (pCtx->SI.uBB>>8)*(pCtx->SI.uBB>>8);
    *pA = (pCtx->SI.uBA>>8)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*(pCtx->SI.uBR>>8);
    *pG = (0xff - (pCtx->SI.uBG>>8))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (pCtx->SI.uBB>>8))*(pCtx->SI.uBB>>8);
    *pA = (0xff - (pCtx->SI.uBA>>8))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlpha
//
// (As, As, As, As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (UINT16)RGBA_GETRED(DestC)  *(pCtx->SI.uBR>>8);
    *pG = (UINT16)RGBA_GETGREEN(DestC)*(pCtx->SI.uBG>>8);
    *pB = (UINT16)RGBA_GETBLUE(DestC) *(pCtx->SI.uBB>>8);
    *pA = (UINT16)RGBA_GETALPHA(DestC)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*(pCtx->SI.uBR>>8);
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*(pCtx->SI.uBB>>8);
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlphaSat
//
// f = min(as, 1-Ad); (f, f, f, 1) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// DestBlendZero
//
// (0, 0, 0, 0) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// DestBlendOne
//
// (1, 1, 1, 1) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  <<8);
    *pG = ((UINT16)RGBA_GETGREEN(DestC)<<8);
    *pB = ((UINT16)RGBA_GETBLUE(DestC) <<8);
    *pA = ((UINT16)RGBA_GETALPHA(DestC)<<8);
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcColor
//
// (Rs, Gs, Bs, As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (pCtx->SI.uBG>>8)*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (pCtx->SI.uBB>>8)*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (pCtx->SI.uBA>>8)*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (pCtx->SI.uBG>>8))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (pCtx->SI.uBB>>8))*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (pCtx->SI.uBA>>8))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlpha
//
// (As, As, As, As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = ((UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = ((UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = ((UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlphaSat
//
// f = min(As, 1-Ad); (f, f, f, 1) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (UINT16)RGBA_GETALPHA(DestC)<<8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\makefile.inc ===
$(GENTGT)\ccrbd_mh.h: ..\ccrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ccrgn_mh.h: ..\ccrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctest_mh.h: ..\ctest_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctxa_mh.h: ..\ctxa_mh.mh ..\ctexaddr.mh $(RAST_STD_M4)


$(GENTGT)\ctxbd_mh.h: ..\ctxbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctxrd_mh.h: ..\ctxrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctstf_mh.h: ..\ctstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\catest_mh.h: ..\catest_mh.mh $(RAST_STD_M4)

$(GENTGT)\cbeadtbl.cpp: ..\cbeadtbl.mcp $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\cclrbld.cpp: ..\cclrbld.mcp $(RAST_STD_M4)

$(GENTGT)\cclrgen.cpp: ..\cclrgen.mcp $(RAST_STD_M4)

$(GENTGT)\cloop.cpp: ..\cloop.mcp ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctest.cpp: ..\ctest.mcp $(RAST_STD_M4)

$(GENTGT)\ctxaddr.cpp: ..\ctxaddr.mcp ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctxblend.cpp: ..\ctxblend.mcp $(RAST_STD_M4)

$(GENTGT)\ctexread.cpp: ..\ctexread.mcp $(RAST_STD_M4)

$(GENTGT)\catest.cpp: ..\catest.mcp $(RAST_STD_M4)

$(GENTGT)\ctstfail.cpp: ..\ctstfail.mcp ..\ctexaddr.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\cspan\sources.inc ===
TARGETNAME = rcspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        $O\catest.cpp\
        $O\cbeadtbl.cpp\
        ..\cbldfncs.cpp\
        ..\cbufread.cpp\
        ..\cbufwrt.cpp\
        $O\cclrbld.cpp\
        $O\cclrgen.cpp\
        $O\cloop.cpp\
        ..\cspnpars.cpp\
        ..\cspnutil.cpp\
        $O\ctest.cpp\
        $O\ctxaddr.cpp\
        $O\ctxblend.cpp\
        ..\ctexfilt.cpp\
        $O\ctexread.cpp\
        $O\ctstfail.cpp

NTTARGETFILE0 = \
        $O\catest_mh.h\
        $O\ccrbd_mh.h\
        $O\ccrgn_mh.h\
        $O\ctest_mh.h\
        $O\ctxa_mh.h\
        $O\ctxbd_mh.h\
        $O\ctxrd_mh.h\
        $O\ctstf_mh.h\
        $O\cbeadtbl.cpp\
        $O\cclrbld.cpp\
        $O\cclrgen.cpp\
        $O\cloop.cpp\
        $O\ctest.cpp\
        $O\ctxaddr.cpp\
        $O\ctxblend.cpp\
        $O\ctexread.cpp\
        $O\catest.cpp\
        $O\ctstfail.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3di.hpp>
#include <haldrv.hpp>

#include <dpf.h>

#include <rast.h>
#include "d3dif.hpp"
#include "swprov.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\d3dif.cpp ===
//----------------------------------------------------------------------------
//
// d3dif.cpp
//
// shared interface functions
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// FindOutSurfFormat
//
// Converts a DDPIXELFORMAT to D3DI_SPANTEX_FORMAT.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT pDdPixFmt,
                  D3DI_SPANTEX_FORMAT *pFmt)
{
    if (pDdPixFmt->dwFlags & DDPF_ZBUFFER)
    {
        switch(pDdPixFmt->dwZBitMask)
        {
        default:
        case 0x0000FFFF: *pFmt = D3DI_SPTFMT_Z16S0; break;
        case 0xFFFFFF00: *pFmt = D3DI_SPTFMT_Z24S8; break;
        case 0x0000FFFE: *pFmt = D3DI_SPTFMT_Z15S1; break;
        case 0xFFFFFFFF: *pFmt = D3DI_SPTFMT_Z32S0; break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_BUMPDUDV)
    {
        UINT uFmt = pDdPixFmt->dwBumpDvBitMask;
        switch (uFmt)
        {
        case 0x0000ff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 24:
                *pFmt = D3DI_SPTFMT_U8V8L8;
                break;
            case 16:
                *pFmt = D3DI_SPTFMT_U8V8;
                break;
            }
            break;

        case 0x000003e0:
            *pFmt = D3DI_SPTFMT_U5V5L6;
            break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED8)
    {
        *pFmt = D3DI_SPTFMT_PALETTE8;
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED4)
    {
        *pFmt = D3DI_SPTFMT_PALETTE4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y'))
    {
        *pFmt = D3DI_SPTFMT_UYVY;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2'))
    {
        *pFmt = D3DI_SPTFMT_YUY2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '1'))
    {
        *pFmt = D3DI_SPTFMT_DXT1;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '2'))
    {
        *pFmt = D3DI_SPTFMT_DXT2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '3'))
    {
        *pFmt = D3DI_SPTFMT_DXT3;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '4'))
    {
        *pFmt = D3DI_SPTFMT_DXT4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '5'))
    {
        *pFmt = D3DI_SPTFMT_DXT5;
    }
    else
    {
        UINT uFmt = pDdPixFmt->dwGBitMask | pDdPixFmt->dwRBitMask;

        if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
        {
            uFmt |= pDdPixFmt->dwRGBAlphaBitMask;
        }

        switch (uFmt)
        {
        case 0x00ffff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 32:
                *pFmt = D3DI_SPTFMT_B8G8R8X8;
                break;
            case 24:
                *pFmt = D3DI_SPTFMT_B8G8R8;
                break;
            }
            break;
        case 0xffffff00:
            *pFmt = D3DI_SPTFMT_B8G8R8A8;
            break;
        case 0xffe0:
            if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
            {
                *pFmt = D3DI_SPTFMT_B5G5R5A1;
            }
            else
            {
                *pFmt = D3DI_SPTFMT_B5G6R5;
            }
            break;
        case 0x07fe0:
            *pFmt = D3DI_SPTFMT_B5G5R5;
            break;
        case 0xff0:
            *pFmt = D3DI_SPTFMT_B4G4R4;
            break;
        case 0xfff0:
            *pFmt = D3DI_SPTFMT_B4G4R4A4;
            break;
        case 0xff:
            *pFmt = D3DI_SPTFMT_L8;
            break;
        case 0xffff:
            *pFmt = D3DI_SPTFMT_L8A8;
            break;
        case 0xfc:
            *pFmt = D3DI_SPTFMT_B2G3R3;
            break;
        default:
            *pFmt = D3DI_SPTFMT_NULL;
            break;
        }
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// ValidTextureSize
//
// checks for power of two texture size
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidTextureSize(INT16 iuSize, INT16 iuShift,
                 INT16 ivSize, INT16 ivShift)
{
    if (iuSize == 1)
    {
        if (ivSize == 1)
        {
            return TRUE;
        }
        else
        {
            return !(ivSize & (~(1 << ivShift)));
        }
    }
    else
    {
        if (ivSize == 1)
        {
            return !(iuSize & (~(1 << iuShift)));
        }
        else
        {
            return (!(iuSize & (~(1 << iuShift)))
                    && !(iuSize & (~(1 << iuShift))));
        }
    }
}

//----------------------------------------------------------------------------
//
// ValidMipmapSize
//
// Computes size of next smallest mipmap level, clamping at 1
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize)
{
    if (iPreSize == 1)
    {
        if (iSize == 1)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return ((iPreSize >> 1) == iSize);
    }
}


//----------------------------------------------------------------------------
//
// TextureFormats
//
// Returns all the texture formats supported by our rasterizer.
// Right now, it's called at device creation time to fill the driver gloabl
// data.
//
//----------------------------------------------------------------------------

#define NUM_SUPPORTED_TEXTURE_FORMATS   22

int
TextureFormats(LPDDSURFACEDESC* lplpddsd, DWORD dwVersion, SW_RAST_TYPE RastType)
{
    int i = 0;

    if (RastType == SW_RAST_MMX && dwVersion < 3)
    {
        static DDSURFACEDESC mmx_ddsd[1];

        /* pal8 */
        mmx_ddsd[i].dwSize = sizeof(mmx_ddsd[0]);
        mmx_ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        mmx_ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        mmx_ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        mmx_ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
        mmx_ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;

        i++;

        *lplpddsd = mmx_ddsd;

        return i;
    }

    static DDSURFACEDESC ddsd_RGBMMX_Dev3[NUM_SUPPORTED_TEXTURE_FORMATS];
    static DDSURFACEDESC ddsd_RGBMMX_Dev2[NUM_SUPPORTED_TEXTURE_FORMATS];
    DDSURFACEDESC *ddsd;

    if (dwVersion >= 3)
    {
        ddsd = ddsd_RGBMMX_Dev3;
    }
    else
    {
        ddsd = ddsd_RGBMMX_Dev2;
    }

    /* 888 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;

    i++;

    /* 8888 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;

    i++;

    /* 565 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xf800;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x07e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    /* 555 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0x7c00;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x03e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    /* pal4 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED4 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 4;

    i++;

    /* pal8 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;

    i++;

    if (dwVersion >= 3)
    {
        /* 1555 */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0x8000;
        ddsd[i].ddpfPixelFormat.dwRBitMask = 0x7c00;
        ddsd[i].ddpfPixelFormat.dwGBitMask = 0x03e0;
        ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

        i++;

        // A formats for PC98 consistency
        // 4444 ARGB (it is already supported by S3 Virge)
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xf000;
        ddsd[i].ddpfPixelFormat.dwRBitMask        = 0x0f00;
        ddsd[i].ddpfPixelFormat.dwGBitMask        = 0x00f0;
        ddsd[i].ddpfPixelFormat.dwBBitMask        = 0x000f;

        i++;
    }

    if ((dwVersion >= 2) && (RastType == SW_RAST_REFNULL))
    {
        // 332 8-bit RGB
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwRBitMask = 0xe0;
        ddsd[i].ddpfPixelFormat.dwGBitMask = 0x1c;
        ddsd[i].ddpfPixelFormat.dwBBitMask = 0x03;

        i++;
    }

    if (dwVersion >= 3)
    {
        /* 8 bit luminance-only */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0xff;

        i++;

        /* 16 bit alpha-luminance */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff00;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0xff;

        i++;
    }

    *lplpddsd = ddsd;

    return i;
}

//----------------------------------------------------------------------------
//
// ZBufferFormats
//
// Must return union of all the Z buffer formats supported by all rasterizers.
// CreateDevice will screen out device-specific ones (i.e. ones ramp doesnt handle) later.
// Called at device creation time and by DDHEL to validate software ZBuffer
// creation.
//
//----------------------------------------------------------------------------

#define NUM_SUPPORTED_ZBUFFER_FORMATS   4

int
ZBufferFormats(DDPIXELFORMAT** ppDDPF)
{
    static DDPIXELFORMAT DDPF[NUM_SUPPORTED_ZBUFFER_FORMATS];

    int i = 0;

    memset(&DDPF[0],0,sizeof(DDPF));

    /* 16 bit Z; no stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER;
    DDPF[i].dwZBufferBitDepth = 16;
    DDPF[i].dwStencilBitDepth = 0;
    DDPF[i].dwZBitMask = 0xffff;
    DDPF[i].dwStencilBitMask = 0x0000;

    i++;

    /* 24 bit Z; 8 bit stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 8;
    DDPF[i].dwZBitMask = 0xffffff00;
    DDPF[i].dwStencilBitMask = 0x000000ff;

    i++;

    *ppDDPF = DDPF;

    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\d3dif.hpp ===
//----------------------------------------------------------------------------
//
// d3dif.hpp
//
// D3D front-end/rasterizer interface header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DIF_HPP_
#define _D3DIF_HPP_

#include <setup.hpp>

// For Primitive function prototypes.
#include <pmfns_mh.h>

// Vertex data is aligned on 32-byte boundaries.
#define DP_VTX_ALIGN 32

// Flags for uflags of D3DContex
#define D3DCONTEXT_IN_BEGIN             0x0001
#define D3DCONTEXT_TEXTURE_LOCKED       0x0002
#define D3DCONTEXT_APPHACK_MSGOLF       0x0004

// Flags for D3DDEVICEDESC dwDeviceZBufferBitDepth
// Note: This must be replicated in ddraw\ddd3dapi.h so DDHEL can pick them up
//       It only affect what legacy apps see when using GetCaps or EnumDevices,
//       internally ZBufferFormats() is checked when on ZBuffer creation.
//       Note stencil formats should have no representation in this flag word
//       becase legacy apps will be fooled into trying to create a Z-only surface
//       at the DDBD bitdepth and fail.   New apps should ignore dwDeviceZBufferBitDepth
//       and use EnumZBufferFormats

#define D3DSWRASTERIZER_ZBUFFERBITDEPTHFLAGS (DDBD_16)

// Macros used to access DDRAW surface info.
#define DDSurf_Width(lpLcl) ( (lpLcl)->lpGbl->wWidth )
#define DDSurf_Pitch(lpLcl) ( (lpLcl)->lpGbl->lPitch )
#define DDSurf_Height(lpLcl) ( (lpLcl)->lpGbl->wHeight )
#define DDSurf_BitDepth(lpLcl) \
    ( (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      (lpLcl->lpGbl->ddpfSurface.dwRGBBitCount) : \
      (lpLcl->lpGbl->lpDD->vmiData.ddpfDisplay.dwRGBBitCount) \
    )
#define DDSurf_PixFmt(lpLcl) \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      ((lpLcl)->lpGbl->ddpfSurface) : \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay) \
    )
#define VIDEO_MEMORY(pDDS) \
    (!(((LPDDRAWI_DDRAWSURFACE_INT) (pDDS))->lpLcl->lpGbl->dwGlobalFlags & \
    DDRAWISURFGBL_SYSMEMREQUESTED))
#define SURFACE_LOCKED(pDDS) \
    (((LPDDRAWI_DDRAWSURFACE_INT)(pDDS))->lpLcl->lpGbl->dwUsageCount > 0)

// Macro to retrieve SPANTEX pointer
#define HANDLE_TO_SPANTEX(hTex) \
    (*(PD3DI_SPANTEX *)ULongToPtr(hTex))

// Check the return value and return if something wrong.
// Assume hr has been declared
#define HR_RET(exp)                                                           \
{                                                                             \
    hr = (exp);                                                               \
    if (hr != D3D_OK)                                                           \
    {                                                                         \
        return hr;                                                            \
    }                                                                         \
}

// Triangle/Line/Point function
#define PFN_TRIANGLE_5ARG_DEFAULT (D3DTRIFLAG_EDGEENABLE1 | \
                                   D3DTRIFLAG_EDGEENABLE2 | \
                                   D3DTRIFLAG_EDGEENABLE3)

typedef HRESULT (*PFN_TRIANGLE)(LPVOID pCtx, PUINT8 pV0, PUINT8 pV1,
                                PUINT8 pV2,
                                WORD wFlags /*= PFN_TRIANGLE_5ARG_DEFAULT */);
typedef HRESULT (*PFN_POINT)(LPVOID pCtx, PUINT8 pV0);
typedef HRESULT (*PFN_LINE)(LPVOID pCtx, PUINT8 pV0, PUINT8 pV1);
typedef void (*PFN_STORELASTPIXELSTATE)(LPVOID pCtx, BOOL bStore);
typedef HRESULT (*PFN_DP2SETRENDERSTATES)(LPVOID pCtx,
                                        DWORD dwFvf,
                                        LPD3DHAL_DP2COMMAND pCmd,
                                        LPDWORD lpdwRuntimeRStates);
typedef HRESULT (*PFN_DP2TEXTURESTAGESTATE)(LPVOID pCtx,
                                            DWORD dwFvf,
                                            LPD3DHAL_DP2COMMAND pCmd);

typedef HRESULT (*PFN_DP2SETVIEWPORT)(LPVOID pCtx, LPD3DHAL_DP2COMMAND pCmd);
typedef HRESULT (*PFN_DP2SETWRANGE)(LPVOID pCtx, LPD3DHAL_DP2COMMAND pCmd);

typedef struct _PRIMITIVE_FUNTIONS
{
    PFN_TRIANGLE pfnTri;
    PFN_POINT pfnPoint;
    PFN_LINE pfnLine;
    PFN_STORELASTPIXELSTATE pfnStoreLastPixelState;
    PFN_DP2SETRENDERSTATES pfnDp2SetRenderStates;
    PFN_DP2TEXTURESTAGESTATE pfnDp2TextureStageState;
    PFN_DP2SETVIEWPORT pfnDp2SetViewport;
    PFN_DP2SETWRANGE pfnDp2SetWRange;
}PRIMITIVE_FUNTIONS;

typedef enum _SW_RAST_TYPE
{
    SW_RAST_REFNULL = 1,
    SW_RAST_RGB = 2,
    SW_RAST_MMX = 3,
    SW_RAST_MMXASRGB = 4,
}SW_RAST_TYPE;

// Records the stride and the member offsets of the current FVF vertex type
// Used to pack a FVF vertex into one known by the rasterizer, such as
// RAST_GENERIC_VERTEX
typedef struct _FVFDATA
{
    // 0 means no according field
    INT16 offsetRHW;
    INT16 offsetDiff;
    INT16 offsetSpec;
    INT16 offsetTex[D3DHAL_TSS_MAXSTAGES];

    UINT16 stride;

    RAST_VERTEX_TYPE vtxType;

    DWORD preFVF;
    INT TexIdx[D3DHAL_TSS_MAXSTAGES];
    UINT cActTex;
}FVFDATA;

// Class used for the context returned to D3DIM.
class D3DContext
{
public:
    D3DI_RASTCTX m_RastCtx;

    // InBegin and TextureLockd flags
    // TextureLockd bit is set/cleared by texture Lock/Unlock functions.
    // It is used by texture Lock/Unlock and Begin functions.
    // InBegin bit is set by Begin and cleared by End
    unsigned short m_uFlags;

    // This is init'ed according to the fill mode.
    // It is init'ed after state change and before rendering
    PRIMITIVE_FUNTIONS m_fnPrims;

    // Used to store the old last pixel setting when drawing line strips.
    UINT uOldFlags;

    inline BOOL IsTextureOff(void);

    inline void UpdatePrimFunctionTbl(void);    // Init m_pfnTri
    inline BOOL IsAnyStatesChanged(void);
    inline BOOL IsStateChanged(UINT32 uState);
    inline void StateChanged(UINT32 uState);
    inline void SetAllStatesDirtyBits(void);
    inline void ClearAllStatesDirtyBits(void);
    inline void ClearStateDirtyBit(UINT32 uState);

    // FVF stuff
    FVFDATA m_fvfData;


#if DBG
    inline HRESULT ValidatePrimType(D3DPRIMITIVETYPE PrimitiveType);
#endif

    PrimProcessor m_PrimProc;

    UINT32 dwSize;

    D3DContext(void){};
    ~D3DContext(void){};

    HRESULT Initialize(LPDIRECTDRAWSURFACE pDDS,
        LPDIRECTDRAWSURFACE pDDSZ, DWORD BeadSet, DWORD devVer);
    HRESULT FillContext(LPDIRECTDRAWSURFACE pDDS, LPDIRECTDRAWSURFACE pDDSZ);
    HRESULT SetViewport(LPD3DHAL_DP2VIEWPORTINFO pVpt);
    HRESULT TextureSetState(PD3DI_SPANTEX pSpanTex, DWORD dwState, DWORD dwValue);
    HRESULT ValidateTextureStageState(void);
    HRESULT UpdateActiveTexStageCount(void);

    inline PD3DI_RASTCTX GetRastCtx(void){return &m_RastCtx;};

    HRESULT Begin(void);
    inline HRESULT End(BOOL bNotFlush = TRUE);
    inline void BeginPrimSet(D3DPRIMITIVETYPE PrimType, RAST_VERTEX_TYPE VertType)
        {m_PrimProc.BeginPrimSet(PrimType, VertType);};
    inline void StoreLastPixelState(BOOL bStore);
    inline PRIMITIVE_FUNTIONS *GetFunsTbl(void){return &m_fnPrims;};

    void RastUnlockSpanTexture(void);
    HRESULT RastLockSpanTexture(void);
    void UpdateColorKeyAndPalette(void);
    void RemoveTexture(PD3DI_SPANTEX pSpanTex);
    HRESULT InitSpanTexture(PD3DI_SPANTEX pSpanTex, LPDIRECTDRAWSURFACE pDDS);
    HRESULT SetSizesSpanTexture(PD3DI_SPANTEX pSpanTex);

    HRESULT SetRenderState(UINT32 uState, UINT32 uStateVal);
    HRESULT UpdateRenderStates(LPDWORD puStateChange, UINT cStateChanges);
    HRESULT UpdateAllRenderStates(LPDWORD puStates);
    HRESULT SetTextureStageState(DWORD dwStage, DWORD dwState, DWORD uStateVal);
    HRESULT Dp2SetRenderStates(LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates);
    HRESULT Dp2TextureStageState(LPD3DHAL_DP2COMMAND pCmd, DWORD dwFvf);
    void MapTextureStageState( DWORD dwStage );
    void MapLegacyTextureBlend( void );
    void MapLegacyTextureFilter( void );

    inline HRESULT CheckDrawOnePrimitive(
        LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData);
    inline HRESULT CheckDrawOneIndexedPrimitive(
        LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pOneIdxPrimData);
    inline HRESULT DrawOnePrimitive(PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices);
    inline HRESULT DrawOneIndexedPrimitive(PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices);

    // Check if a triangle is culled or not. It's only used for wireframe and
    // point mode. It's done in PrimProc.Tri for solid mode.
    inline BOOL NotCulled(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                                             LPD3DTLVERTEX pV2);

    // FVF stuff
    HRESULT FASTCALL CheckFVF(DWORD dwFVF);
    void FASTCALL PackGenVertex(PUINT8 pFvfVtx, RAST_GENERIC_VERTEX *pGenVtx);
    inline UINT16 GetFvfStride(void){return m_fvfData.stride;};
    inline RAST_VERTEX_TYPE GetFvfVertexType(void){return m_fvfData.vtxType;};

    inline void BeginSceneHook(void);
    inline void EndSceneHook(void);
};

inline void D3DContext::StoreLastPixelState(BOOL bStore)
{
    if (bStore)
    {
        uOldFlags = m_PrimProc.GetFlags();
        m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);
    }
    else
    {
        m_PrimProc.SetFlags(uOldFlags & PPF_DRAW_LAST_LINE_PIXEL);
    }
}

inline BOOL D3DContext::NotCulled(LPD3DTLVERTEX pV0,
              LPD3DTLVERTEX pV1, LPD3DTLVERTEX pV2)
{
    if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE)
    {
        return TRUE;
    }

    FLOAT x1, y1, x2x1, x3x1, y2y1, y3y1, fDet;

    x1 = pV0->sx;
    y1 = pV0->sy;
    x2x1 = pV1->sx - x1;
    y2y1 = pV1->sy - y1;
    x3x1 = pV2->sx - x1;
    y3y1 = pV2->sy - y1;

    fDet = x2x1 * y3y1 - x3x1 * y2y1;

    if (0. == fDet)
    {
        return FALSE;
    }
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_CULLMODE] )
    {
    case D3DCULL_CW:
        if ( fDet > 0.f )
        {
            return FALSE;
        }
        break;
    case D3DCULL_CCW:
        if ( fDet < 0.f )
        {
            return FALSE;
        }
        break;
    }
    return TRUE;
}
// Update m_pfnPrims according to the current fill mode, device type
// and vertextype. It's called when fill mode or FVF type chang.
inline void D3DContext::UpdatePrimFunctionTbl(void)
{
    if (m_fvfData.vtxType == RAST_GENVERTEX)
    {
        m_fnPrims.pfnPoint = RGB_PointPack;
        m_fnPrims.pfnLine = RGB_LinePack;
    }
    else
    {
        m_fnPrims.pfnPoint = RGB_PointNoPack;
        m_fnPrims.pfnLine = RGB_LineNoPack;
    }
    switch (m_RastCtx.pdwRenderState[D3DRENDERSTATE_FILLMODE])
    {
    case D3DFILL_POINT:
        if (m_fvfData.vtxType == RAST_GENVERTEX)
        {
            m_fnPrims.pfnTri = RGB_TriPackPoint;
        }
        else
        {
            m_fnPrims.pfnTri = RGB_TriNoPackPoint;
        }
        break;
    case D3DFILL_WIREFRAME:
        if (m_fvfData.vtxType == RAST_GENVERTEX)
        {
            m_fnPrims.pfnTri = RGB_TriPackWireframe;
        }
        else
        {
            m_fnPrims.pfnTri = RGB_TriNoPackWireframe;
        }
        break;
        break;
    case D3DFILL_SOLID:
    default:
        if (m_fvfData.vtxType == RAST_GENVERTEX)
        {
            m_fnPrims.pfnTri = RGB_TriPackSolid;
        }
        else
        {
            m_fnPrims.pfnTri = RGB_TriNoPackSolid;
        }
        break;
    }
}

// The following inline functions are provided to manipulate StatesDirtyBits.
// StatesDirtyBits is used to store one dirty bit for each render state. It
// contains (D3DHAL_MAX_RSTATES_AND_STAGES>>3+1) bytes.
// For a particular state, say uState,
// it is represented by i'th bit of j'th byte, where i=(uState & 7) and
// j=uState>>3. So,
// StatesDirtyBits[uState>>3]&(1<<(uState&7)) gives the bit info. for uState
// StatesDirtyBits[uState>>3] |= (1<<(uState&7)) sets the bit to 1
// StatesDirtyBits[uState>>3] &= ~(1 <<(uState&7)) clears the bit to 0

// Check if any render states have changed. The info. is stored in the bit
// corresponding to D3DHAL_MAX_RSTATES_AND_STAGES.
inline BOOL D3DContext::IsAnyStatesChanged()
{
    return (m_RastCtx.StatesDirtyBits[D3DHAL_MAX_RSTATES_AND_STAGES>>3] &
        (1<<(D3DHAL_MAX_RSTATES_AND_STAGES & 7)));
}
// Check if uState has changed.
inline BOOL D3DContext::IsStateChanged(UINT32 uState)
{
    return (m_RastCtx.StatesDirtyBits[uState>>3] & (1<<(uState & 7)));
};

// uState has changed so set the according dirty bit and the AnyStates bit.
inline void D3DContext::StateChanged(UINT32 uState)
{
    m_RastCtx.StatesDirtyBits[uState>>3] |= (1<<(uState & 7));
    m_RastCtx.StatesDirtyBits[D3DHAL_MAX_RSTATES_AND_STAGES>>3] |=
        (1<<(D3DHAL_MAX_RSTATES_AND_STAGES & 7));
};

// Called after bead chooser to clear all the dirty bits.
inline void D3DContext::ClearAllStatesDirtyBits(void)
{
    memset(m_RastCtx.StatesDirtyBits, 0, sizeof(UINT8) * RAST_DIRTYBITS_SIZE);
};

// Called at context creation time to set all the dirty bits.
inline void D3DContext::SetAllStatesDirtyBits(void)
{
    memset(m_RastCtx.StatesDirtyBits, 7, sizeof(UINT8) * RAST_DIRTYBITS_SIZE);
};

// Clear the dirty bit corresponding to uState.
inline void D3DContext::ClearStateDirtyBit(UINT32 uState)
{
    m_RastCtx.StatesDirtyBits[uState>>3] &= ~(1 << (uState & 7));
}
inline BOOL D3DContext::IsTextureOff(void)
{
    return
        (m_RastCtx.cActTex == 0 ||
        (m_RastCtx.cActTex == 1 && m_RastCtx.pTexture[0] == NULL) ||
        (m_RastCtx.cActTex == 2 &&
         (m_RastCtx.pTexture[0] == NULL ||
          m_RastCtx.pTexture[1] == NULL)));
}
extern "C" HRESULT WINAPI
DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern "C" HRESULT WINAPI
DDInternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl );

// Lock surfaces before rendering
inline HRESULT LockSurface(LPDIRECTDRAWSURFACE pDDS, LPVOID *ppData)
{
    if (pDDS)
    {
        if (!VIDEO_MEMORY(pDDS))
        {
            if (SURFACE_LOCKED(pDDS))
            return DDERR_SURFACEBUSY;
            *ppData = (LPVOID)SURFACE_MEMORY(pDDS);
            return DD_OK;
        }
        else
        {
            HRESULT ddrval;
            do
            {
                LPDDRAWI_DDRAWSURFACE_INT lpInt;

                lpInt = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
                ddrval = DDInternalLock(lpInt->lpLcl, ppData);
            } while (ddrval == DDERR_WASSTILLDRAWING);
            return ddrval;
        }
    }
    return DD_OK;
}
// Unlock surfaces after rendering
inline void UnlockSurface(LPDIRECTDRAWSURFACE pDDS)
{
    if (pDDS && VIDEO_MEMORY(pDDS))
    {
        LPDDRAWI_DDRAWSURFACE_INT lpInt;

        lpInt = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
        DDInternalUnlock(lpInt->lpLcl);
    }
}
// After rendering cleanup: flush primitive processor, unlock textures
inline HRESULT
D3DContext::End(BOOL bNotFlush)
{
    if (m_uFlags & D3DCONTEXT_IN_BEGIN)
    {
        HRESULT hr = m_PrimProc.End();

        // Unlock texture if this is not called in the middle of drawPrims to
        // flush for possible state changes. In the 2nd case, let
        // SetRenderState to handle it.
        if (bNotFlush)
        {
            RastUnlockSpanTexture();
        }

        // Unlock surfaces
        UnlockSurface(m_RastCtx.pDDS);
        if (m_RastCtx.pDDSZ != NULL)
        {
            UnlockSurface(m_RastCtx.pDDSZ);
        }

        m_uFlags &= ~D3DCONTEXT_IN_BEGIN;
        return (hr);
    }
    else
    {
        // In the case of DrawPrims being called just to set render states,
        // Begin is actually not called.
        return D3D_OK;
    }
}

// Following primitive functions are shared by RGB/REF rasterizers
HRESULT FASTCALL
DoDrawOneIndexedPrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices);
HRESULT FASTCALL
DoDrawOnePrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices);
HRESULT FASTCALL
DoDrawOneEdgeFlagTriangleFan(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 UINT cVertices,
                 UINT32 dwEdgeFlags);
HRESULT FASTCALL
DoRendPoints(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DPOINT pPt);
HRESULT FASTCALL
DoRendLines(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DLINE pLine);
HRESULT FASTCALL
DoRendTriangles(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DTRIANGLE pTri);
HRESULT FASTCALL
DoDrawPrimitives2(LPVOID pCtx,
                  PRIMITIVE_FUNTIONS *pfnPrims,
                  UINT16 dwStride,
                  DWORD dwFvf,
                  PUINT8 pVtx,
                  LPD3DHAL_DP2COMMAND *ppCmd,
                  LPDWORD lpdwRStates,
                  BOOL bWireframe = FALSE
                  );


inline HRESULT
D3DContext::DrawOnePrimitive(PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices)
{
    m_PrimProc.BeginPrimSet(PrimType, m_fvfData.vtxType);
    return DoDrawOnePrimitive((LPVOID)this,
                                    &m_fnPrims,
                                    m_fvfData.stride,
                                    (PUINT8)pVtx,
                                    PrimType,
                                    cVertices);

}

inline HRESULT
D3DContext::DrawOneIndexedPrimitive(PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices)
{
    m_PrimProc.BeginPrimSet(PrimType, m_fvfData.vtxType);
    return DoDrawOneIndexedPrimitive((LPVOID)this,
                                    &m_fnPrims,
                                    m_fvfData.stride,
                                    (PUINT8)pVtx,
                                    puIndices,
                                    PrimType,
                                    cIndices);
}

// Macros to check if a pointer is valid
#if DBG
#define VALID_D3DCONTEX_PTR(pDCtx)  ((pDCtx)->dwSize == sizeof(D3DContext))
#define VALID_D3DI_RASTCTX_PTR(pRastCtx) \
            ((pRastCtx)->dwSize == sizeof(D3DI_RASTCTX))
#define VALID_D3DI_SPANTEX_PTR(pSpanTex) \
            ((pSpanTex)->dwSize == sizeof(D3DI_SPANTEX))
#define VALID_D3DI_SPANTEX_PTR_PTR(ppSpanTex) \
            ((ppSpanTex) && VALID_D3DI_SPANTEX_PTR(*(ppSpanTex)))
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    if ((data_ptr) == NULL)   \
    {   \
        D3D_INFO(0, "in %s, data pointer = NULL", (caller_name));  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
    pCtx = (type)((data_ptr)->dwhContext); \
    if (!pCtx) \
    {   \
        D3D_INFO(0, "in %s, dwhContext = NULL", (caller_name));    \
        (data_ptr)->ddrval = D3DHAL_CONTEXT_BAD;  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}
#else // !DBG
#define VALID_D3DCONTEX_PTR(pDCtx)              1
#define VALID_D3DI_RASTCTX_PTR(pRastCtx)        1
#define VALID_D3DI_SPANTEX_PTR(pSpanTex)        1
#define VALID_D3DI_SPANTEX_PTR_PTR(ppSpanTex)   1
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    pCtx = (type)((data_ptr)->dwhContext); \
}
#endif // !DBG

// Validate D3DCxt. pDCtx should be declared before this macro
#define VALIDATE_D3DCONTEXT(caller_name, data_ptr)  \
{   \
    VALIDATE_CONTEXT(caller_name, data_ptr, pDCtx, D3DContext*); \
    if (!VALID_D3DCONTEX_PTR(pDCtx) ||  \
        !VALID_D3DI_RASTCTX_PTR((pDCtx)->GetRastCtx()))    \
    {   \
        D3D_INFO(0, "in %s, invalid dwhContext", (caller_name));    \
        (data_ptr)->ddrval = D3DHAL_CONTEXT_BAD;  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}

// Validate ReferenceRasterizer. pRefRast should be declared before this macro
#define VALIDATE_REFRAST_CONTEXT(caller_name, data_ptr)  \
{   \
    VALIDATE_CONTEXT(caller_name, data_ptr, pRefRast, ReferenceRasterizer*);\
}

#define CHECK_FVF(ret, pDCtx, dwFlags)  \
{   \
    if ((ret = pDCtx->CheckFVF(dwFlags)) != DD_OK)  \
    {   \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}

HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT pDdPixFmt,
                  D3DI_SPANTEX_FORMAT *pFmt);

extern int
TextureFormats(LPDDSURFACEDESC* lplpddsd, DWORD dwVersion, SW_RAST_TYPE RastType);

extern int
ZBufferFormats(DDPIXELFORMAT** ppDDPF);

BOOL FASTCALL
ValidTextureSize(INT16 iuSize, INT16 iuShift,
                             INT16 ivSize, INT16 ivShift);
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize);

DWORD __stdcall
RastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData, DWORD BeadSet);

DWORD __stdcall
RastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData, DWORD BeadSet);

DWORD __stdcall
RastContextCreateC(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextCreateMMX(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextCreateMMXAsRGB(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData);

DWORD __stdcall
RastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData);

DWORD __stdcall
RastTextureCreate(LPD3DHAL_TEXTURECREATEDATA pTexData);

DWORD __stdcall
RastTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pTexDestroyData);

DWORD __stdcall
RastTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pTexGetSurf);

DWORD __stdcall
RastRenderState(LPD3DHAL_RENDERSTATEDATA pStateData);

DWORD __stdcall
RastRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA pRenderData);

DWORD __stdcall
RastDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData);

DWORD __stdcall
RastDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
                            pOneIdxPrimData);

DWORD __stdcall
RastDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA pDrawPrimData);

DWORD __stdcall
RastValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData);

DWORD __stdcall
RastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data);

DWORD __stdcall
RefRastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data);

#endif // #ifndef _D3DIF_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\rastctx.cpp ===
//----------------------------------------------------------------------------
//
// rastctx.cpp
//
// Context functions + state functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// Unlock previous texture if necessary. It's called before the texture handle
// is going to be changed.
#define CHECK_AND_UNLOCK_TEXTURE    \
{   \
    if (m_uFlags & D3DCONTEXT_TEXTURE_LOCKED)   \
    {   \
        RastUnlockSpanTexture();    \
    }   \
}

//----------------------------------------------------------------------------
//
// FillContext
//
// Fill the context with the info. from the surfaces.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::FillContext(LPDIRECTDRAWSURFACE pDDS,
                               LPDIRECTDRAWSURFACE pDDSZ)
{
    HRESULT hr;

    LPDDRAWI_DDRAWSURFACE_LCL pLcl =
        ((LPDDRAWI_DDRAWSURFACE_INT)(pDDS))->lpLcl;
    m_RastCtx.iSurfaceStride = DDSurf_Pitch(pLcl);
    m_RastCtx.iSurfaceBitCount = DDSurf_BitDepth(pLcl);
    m_RastCtx.iSurfaceStep = m_RastCtx.iSurfaceBitCount/8;
    HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLcl)),
        (D3DI_SPANTEX_FORMAT *)&(m_RastCtx.iSurfaceType)));
    m_RastCtx.Clip.left = m_RastCtx.Clip.top = 0;
    m_RastCtx.Clip.bottom = DDSurf_Height(pLcl);
    m_RastCtx.Clip.right = DDSurf_Width(pLcl);

    if (pDDSZ != NULL)
    {
        pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pDDSZ))->lpLcl;
        m_RastCtx.pZBits = (PUINT8)SURFACE_MEMORY(pDDSZ);
        m_RastCtx.iZStride = DDSurf_Pitch(pLcl);
        m_RastCtx.iZBitCount = DDSurf_BitDepth(pLcl);
        m_RastCtx.iZStep = m_RastCtx.iZBitCount/8;
    }
    else
    {
        m_RastCtx.pZBits = NULL;
        m_RastCtx.iZStride = 0;
        m_RastCtx.iZBitCount = 0;
        m_RastCtx.iZStep = 0;
    }

    m_RastCtx.pDDS = pDDS;
    m_RastCtx.pDDSZ = pDDSZ;

    m_RastCtx.dwSize = sizeof(D3DI_RASTCTX);

    // Make sure SpanInit is called at least once
    SetAllStatesDirtyBits();

    // Check for MsGolf AppHack
    if (pLcl->lpSurfMore->lpDD_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_FORCEMODULATED)
    {
        m_uFlags |= D3DCONTEXT_APPHACK_MSGOLF;
    }

    return D3D_OK;
}

HRESULT
D3DContext::Initialize(LPDIRECTDRAWSURFACE pDDS,
                       LPDIRECTDRAWSURFACE pDDSZ,
                       DWORD BeadSet,
                       DWORD devVer)
{
    HRESULT hr;

    // Initialize the primitive processor.
    HR_RET(m_PrimProc.Initialize());

    memset(&m_RastCtx, 0, sizeof(m_RastCtx));

    m_uFlags = 0;
    HR_RET(FillContext(pDDS, pDDSZ));

    m_PrimProc.SetCtx(&m_RastCtx);

    dwSize = sizeof(D3DContext);

    // Initialize bead table enum
    m_RastCtx.BeadSet = (D3DI_BEADSET)BeadSet;

    // Init FVF data as legacy TL vertex
    m_fvfData.preFVF = -1;
    CheckFVF(D3DFVF_TLVERTEX);

    m_RastCtx.uDevVer = devVer;

    // All render and texture stage state is initialized by
    // DIRECT3DDEVICEI::stateInitialize

    // Init prim function table. It will be updated for, or when FVF
    // control word changes or when fill mode changes.
    m_fnPrims.pfnTri = RGB_TriNoPackSolid;
    m_fnPrims.pfnPoint = RGB_PointNoPack;
    m_fnPrims.pfnLine = RGB_LineNoPack;
    // This one should be always the same.
    m_fnPrims.pfnStoreLastPixelState = RGB_StoreLastPixelState;
    m_fnPrims.pfnDp2SetRenderStates = RGB_Dp2SetRenderStates;
    m_fnPrims.pfnDp2TextureStageState = RGB_Dp2TextureStageState;
    m_fnPrims.pfnDp2SetViewport = RGB_Dp2SetViewport;
    m_fnPrims.pfnDp2SetWRange = RGB_Dp2SetWRange;

    // Enable MMX Fast Paths (Monolithics) if a registry key for it is not 0
    m_RastCtx.dwMMXFPDisableMask[0] = 0x0;       // enable MMX FP's by default
    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey) )
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwDisableMask[MMX_FP_DISABLE_MASK_NUM] = {0x0};
        DWORD dwSize = 4;

        // only code up looking at one mask, for now
        DDASSERT(MMX_FP_DISABLE_MASK_NUM == 1);

        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "MMXFPDisableMask0", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD )
        {
           dwDisableMask[0] = dwValue;
        }
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "MMX Fast Path", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD)
        {
            if (dwValue == 0)
            {
                // Override MMXFPDisableMask0 and disable all MMX Fast Paths
                m_RastCtx.dwMMXFPDisableMask[0] = 0xffffffff;
            }
            else
            {
                // Take all MMX paths not disabled by MMXFPDisableMask0
                m_RastCtx.dwMMXFPDisableMask[0] = dwDisableMask[0];
            }
        }

        RegCloseKey( hKey );
    }

    return D3D_OK;
}

HRESULT
D3DContext::SetViewport(LPD3DHAL_DP2VIEWPORTINFO pVpt)
{
    m_RastCtx.Clip.left = pVpt->dwX;
    m_RastCtx.Clip.top = pVpt->dwY;
    m_RastCtx.Clip.bottom = pVpt->dwY + pVpt->dwHeight;
    m_RastCtx.Clip.right = pVpt->dwX + pVpt->dwWidth;
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastContextCreateC
//
// Calls RastContextCreate with the C bead set.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateC(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_C);
}

//----------------------------------------------------------------------------
//
// RastContextCreateMMX
//
// Calls RastContextCreate with the MMX bead set.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateMMX(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_MMX);
}

//----------------------------------------------------------------------------
//
// RastContextCreateMMXAsRGB
//
// Calls RastContextCreate with the MMX bead set, but remember that we
// came from RGB.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateMMXAsRGB(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_MMXASRGB);
}

//----------------------------------------------------------------------------
//
// RastContextCreate
//
// Creates a RASTCTX and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData, DWORD BeadSet)
{
    DDASSERT(pCtxData != NULL);

    D3DContext *pDCtx = new D3DContext;

    if (pDCtx == NULL)
    {
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    pCtxData->ddrval =
        pDCtx->Initialize(pCtxData->lpDDS,
                          pCtxData->lpDDSZ,
                          BeadSet,
                          (DWORD)pCtxData->dwhContext);

    pCtxData->dwhContext = (ULONG_PTR)pDCtx;

    PD3DI_RASTCTX pCtx = pDCtx->GetRastCtx();
    if (D3DI_SPTFMT_PALETTE8 == pCtx->iSurfaceType)
    {
        // 8 bit surfaces no longer supported by DX7
        // AnanKan: Need to return a proer error message.
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastContextDestroy
//
// Destroy a rast context.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastContextDestroy", pCtxDestroyData);

    PD3DI_RASTCTX pCtx = pDCtx->GetRastCtx();
    delete pDCtx;

    pCtxDestroyData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}


//----------------------------------------------------------------------------
//
// ValidateTextureStageState
//
// Utility function that returns an appropriate D3DERR_ if the current
// multi-texture setup can not be rendered, D3D_OK otherwise.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::ValidateTextureStageState(void)
{
#if DBG
    if ((m_RastCtx.pTexture[0] == m_RastCtx.pTexture[1]) &&
        (m_RastCtx.pTexture[0] != NULL) )
    {
        // except under very special circumstances, this will not work in RGB/MMX
        // since we keep a lot of stage state in the D3DI_SPANTEX structure
        D3D_ERR("(Rast) ValidateTextureStageState Warning, pTexture[0] == pTexture[1]");
    }
#endif
    for (INT i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_COLOROP])
        {
        default:
            return D3DERR_UNSUPPORTEDCOLOROPERATION;
        case D3DTOP_DISABLE:
            return D3D_OK;  // don't have to validate further if the stage is disabled
        case D3DTOP_SELECTARG1:
        case D3DTOP_SELECTARG2:
        case D3DTOP_MODULATE:
        case D3DTOP_MODULATE2X:
        case D3DTOP_MODULATE4X:
        case D3DTOP_ADD:
        case D3DTOP_ADDSIGNED:
        case D3DTOP_BLENDDIFFUSEALPHA:
        case D3DTOP_BLENDTEXTUREALPHA:
        case D3DTOP_BLENDFACTORALPHA:
        case D3DTOP_BLENDTEXTUREALPHAPM:
        case D3DTOP_ADDSIGNED2X:
        case D3DTOP_SUBTRACT:
        case D3DTOP_ADDSMOOTH:
        case D3DTOP_MODULATEALPHA_ADDCOLOR:
        case D3DTOP_MODULATECOLOR_ADDALPHA:
            break;
        }

        switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_COLORARG1] &
                ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
        {
        default:
            return D3DERR_UNSUPPORTEDCOLORARG;
        case (D3DTA_TEXTURE):
            break;
        }

        switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_COLORARG2] &
                ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
        {
        default:
            return D3DERR_UNSUPPORTEDCOLORARG;
        case (D3DTA_TFACTOR):
        case (D3DTA_CURRENT):
        case (D3DTA_DIFFUSE):
        case (D3DTA_SPECULAR):
            break;
        }

        switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_ALPHAOP])
        {
        default:
            return D3DERR_UNSUPPORTEDALPHAOPERATION;
        case D3DTOP_DISABLE:
            break;
        case D3DTOP_SELECTARG1:
        case D3DTOP_SELECTARG2:
        case D3DTOP_MODULATE:
        case D3DTOP_MODULATE2X:
        case D3DTOP_MODULATE4X:
        case D3DTOP_ADD:
        case D3DTOP_ADDSIGNED:
        case D3DTOP_BLENDDIFFUSEALPHA:
        case D3DTOP_BLENDTEXTUREALPHA:
        case D3DTOP_BLENDFACTORALPHA:
        case D3DTOP_BLENDTEXTUREALPHAPM:
        case D3DTOP_ADDSIGNED2X:
        case D3DTOP_SUBTRACT:
        case D3DTOP_ADDSMOOTH:
            // only validate alpha args if alpha op is not disable
            switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_ALPHAARG1] &
                    ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
            {
            default:
                return D3DERR_UNSUPPORTEDALPHAARG;
            case (D3DTA_TEXTURE):
                break;
            }

            switch(m_RastCtx.pdwTextureStageState[i][D3DTSS_ALPHAARG2] &
                    ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
            {
            default:
                return D3DERR_UNSUPPORTEDALPHAARG;
            case (D3DTA_TFACTOR):
            case (D3DTA_CURRENT):
            case (D3DTA_DIFFUSE):
            case (D3DTA_SPECULAR):
                break;
            }
            break;
        }

    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastValidateTextureStageState
//
// Returns whether the current multitexture setup can be rendered and, if
// so, the number of passes required to render it.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastValidateTextureStageState", pData);

    pData->dwNumPasses = 1;

    pData->ddrval = pDCtx->ValidateTextureStageState();

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastSetRenderTarget
//
// Update a rast context with the info from a new render target.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastSetRenderTarget", pTgtData);

    pTgtData->ddrval = pDCtx->FillContext(pTgtData->lpDDS, pTgtData->lpDDSZ);

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// SetRenderState
//
// Check to see if a state change requires an update to the D3DCTX.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::SetRenderState(UINT32 uState, UINT32 uStateVal)
{
    // Assume d3dim has filtered out unchanged states
    StateChanged(uState);

    m_RastCtx.pdwRenderState[uState] = uStateVal;

    switch(uState)
    {
    case D3DRENDERSTATE_FOGENABLE      :
    case D3DRENDERSTATE_FOGCOLOR       :
    case D3DRENDERSTATE_FOGTABLEMODE   :
    case D3DRENDERSTATE_FOGTABLESTART  :
    case D3DRENDERSTATE_FOGTABLEEND    :
    case D3DRENDERSTATE_FOGTABLEDENSITY:
        break;
    case D3DRENDERSTATE_CULLMODE:
        // Set face culling sign from state.
        switch(uStateVal)
        {
        case D3DCULL_CCW:
            m_RastCtx.uCullFaceSign = 1;
            break;
        case D3DCULL_CW:
            m_RastCtx.uCullFaceSign = 0;
            break;
        case D3DCULL_NONE:
            m_RastCtx.uCullFaceSign = 2;
            break;
        }
        break;
    case D3DRENDERSTATE_ZENABLE:
        if ( (D3DZB_FALSE != uStateVal) && (NULL == m_RastCtx.pDDSZ) )
        {
            DPF(0, "(ERROR) (Rast) SetRenderState: Can't set D3DRENDERSTATE_ZENABLE to %d if there is no Z Buffer", uStateVal);
            m_RastCtx.pdwRenderState[uState] = D3DZB_FALSE;
        }
        break;
    case D3DRENDERSTATE_LASTPIXEL:
        // Set last-pixel flag from state.
        if (uStateVal)
        {
            m_PrimProc.SetFlags(PPF_DRAW_LAST_LINE_PIXEL);
        }
        else
        {
            m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);
        }
        break;


        // map legacy modes with one-to-one mappings to texture stage 0
    case D3DRENDERSTATE_TEXTUREADDRESS:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ADDRESS] =
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ADDRESSU] =
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ADDRESSV] = uStateVal;
        MapTextureStageState(0);
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSU:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ADDRESSU] = uStateVal;
        MapTextureStageState(0);
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSV:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ADDRESSV] = uStateVal;
        MapTextureStageState(0);
        break;
    case D3DRENDERSTATE_MIPMAPLODBIAS:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPMAPLODBIAS] = uStateVal;
        MapTextureStageState(0);
        break;
    case D3DRENDERSTATE_BORDERCOLOR:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_BORDERCOLOR] = uStateVal;
        MapTextureStageState(0);
        break;

    case D3DRENDERSTATE_TEXTUREMAG:
    case D3DRENDERSTATE_TEXTUREMIN:
        // map legacy filtering/sampling state to texture stage 0
        MapLegacyTextureFilter();
        // assign to current texture
        MapTextureStageState(0);
        break;

    case D3DRENDERSTATE_TEXTUREMAPBLEND:
        // map legacy blending state to texture stage 0
        MapLegacyTextureBlend();
        break;

        // map legacy WRAPU/V to per-index controls
    case D3DRENDERSTATE_WRAPU:
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_U;
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] |= ((uStateVal) ? D3DWRAP_U : 0);
        StateChanged(D3DRENDERSTATE_WRAP0);
        break;
    case D3DRENDERSTATE_WRAPV:
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_V;
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] |= ((uStateVal) ? D3DWRAP_V : 0);
        StateChanged(D3DRENDERSTATE_WRAP0);
        break;

//
// NOTE - this compututation of cActTex does not account for blend-only stages
//
    case D3DRENDERSTATE_TEXTUREHANDLE:

        CHECK_AND_UNLOCK_TEXTURE;

        // map handle thru to stage 0
        m_RastCtx.pdwTextureStageState[0][D3DTSS_TEXTUREMAP] = uStateVal;
        m_RastCtx.pTexture[1] = NULL;
        // set up for single stage
        if (uStateVal == 0)
        {
            m_RastCtx.pTexture[0] = NULL;
        }
        else
        {
            m_RastCtx.pTexture[0] = HANDLE_TO_SPANTEX(uStateVal);
        }
        // map stage 0 state to first texture
        MapTextureStageState(0);
        UpdateActiveTexStageCount();
        break;

    }

    return D3D_OK;
}

HRESULT
D3DContext::SetTextureStageState(DWORD dwStage, DWORD dwState, DWORD uStateVal)
{
    // Assume d3dim has filtered out unchanged states
    StateChanged(RAST_TSS_DIRTYBIT(dwStage, dwState));

    m_RastCtx.pdwTextureStageState[dwStage][dwState] = uStateVal;
    switch (dwState)
    {
    case D3DTSS_TEXTUREMAP:
        // Silently zero out legacy handle.  They didn't mean it.
        if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] != 0 &&
            uStateVal != 0)
        {
            m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
        }

        CHECK_AND_UNLOCK_TEXTURE;

        if (uStateVal == 0)
        {
            if (dwStage == 0)
            {
                if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] == 0 )
                {
                    m_RastCtx.pTexture[0] = NULL;
                }
            }
            else
            {
                m_RastCtx.pTexture[dwStage] = NULL;
            }
            // disables higher stages also, but don't clear pTexture[i]'s
            // since they may be used later when this stage is set to non-NULL
        }
        else
        {
            // if lower stages are null, this will be noted by UpdateActiveTexStageCount
            m_RastCtx.pTexture[dwStage] = HANDLE_TO_SPANTEX(uStateVal);
        }

#if DBG
        if (m_RastCtx.pTexture[dwStage])
        {
            int iTexCount = 0;
            for (int i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
            {
                if (m_RastCtx.pTexture[dwStage] == m_RastCtx.pTexture[i])
                {
                    iTexCount ++;
                }
            }
            if (iTexCount > 1)
            {
                D3D_ERR( "Same texture handle was used more than once." );
                return DDERR_INVALIDPARAMS;
            }
        }
#endif
        // map stage state to texture
        MapTextureStageState(dwStage);
        UpdateActiveTexStageCount();
        break;

    // map single set ADDRESS to both U and V controls for stages 0 & 1
    case D3DTSS_ADDRESS:
        m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSU] = uStateVal;
        m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSV] = uStateVal;
        MapTextureStageState(dwStage);
        break;
    case D3DTSS_ADDRESSU:
    case D3DTSS_ADDRESSV:
    case D3DTSS_MIPMAPLODBIAS:
    case D3DTSS_MAXMIPLEVEL:
    case D3DTSS_BORDERCOLOR:
    case D3DTSS_MAGFILTER:
    case D3DTSS_MINFILTER:
    case D3DTSS_MIPFILTER:
         MapTextureStageState(dwStage);
        break;
    case D3DTSS_COLOROP:
    case D3DTSS_COLORARG1:
    case D3DTSS_COLORARG2:
    case D3DTSS_ALPHAOP:
    case D3DTSS_ALPHAARG1:
    case D3DTSS_ALPHAARG2:
        // anything that effects the validity of the texture blending
        // could change the number of active texture stages
        UpdateActiveTexStageCount();
        break;
    }

    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// UpdateActiveTexStageCount - Steps through per-stage renderstate and computes
// a count of currently active texture stages.  For legacy texture, the count
// is at most one.
//
//-----------------------------------------------------------------------------
HRESULT D3DContext::UpdateActiveTexStageCount( void )
{
    HRESULT hr;
    UINT cNewActTex = 0;

    // conservative but correct
    if ((hr = ValidateTextureStageState()) == D3D_OK)
    {
        // always one active texture stage for legacy texture mode
        if ( NULL != m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] )
        {
            cNewActTex = 1;
        }
        else
        {
            // count number of contiguous-from-zero active texture blend stages
            for ( INT iStage=0; iStage<D3DHAL_TSS_MAXSTAGES; iStage++ )
            {
                // check for disabled stage (subsequent are thus inactive)
                // also conservatively checks for incorrectly enabled stage (might be legacy)
                if ( ( m_RastCtx.pdwTextureStageState[iStage][D3DTSS_COLOROP] == D3DTOP_DISABLE ) ||
                     ( m_RastCtx.pTexture[iStage] == NULL ) )
                {
                    break;
                }

                // stage is active
                cNewActTex ++;
            }
        }
    }
    if (m_RastCtx.cActTex != cNewActTex)
    {
        CHECK_AND_UNLOCK_TEXTURE;
        StateChanged(D3DRENDERSTATE_TEXTUREHANDLE);
        m_RastCtx.cActTex = cNewActTex;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// UpdateRenderStates
//
// Update a list of render states and notify components of state change.
//
//----------------------------------------------------------------------------
HRESULT D3DContext::
UpdateRenderStates(LPDWORD puStateChange, UINT cStateChanges)
{
    HRESULT hr;
    INT i;
    UINT32 State, StateVal;

    if (cStateChanges == 0)
    {
        return D3D_OK;
    }

    // Update the D3DCTX
    for (i = 0; i < (INT)cStateChanges; i++)
    {
        State = *puStateChange ++;
        StateVal = * puStateChange++;
        HR_RET(SetRenderState(State, StateVal));
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// UpdateAllRenderStates
//
// Update all render states.
// It is still kept here because we probably need it in the case of fail-over.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::UpdateAllRenderStates(LPDWORD puStates)
{
    HRESULT hr, hrSet;
    INT i;

    DDASSERT(puStates != NULL);

    // Update D3DCTX.
    // Attempt to set as many states as possible, even if there are
    // errors on some.  This allows context initialization to work
    // even though some of the states fail due to dependencies on
    // other state, such as active texture handles.
    // SetRenderState failures are noted and returned eventually,
    // even if everything else succeeds.
    hrSet = D3D_OK;
    for (i = 0; i < D3DHAL_MAX_RSTATES_AND_STAGES; i++)
    {
        if ((hr = SetRenderState(i, puStates[i])) != D3D_OK)
        {
            hrSet = hr;
        }
    }

    return hrSet;
}

//----------------------------------------------------------------------------
//
// Dp2SetRenderStates
//
// Called by Drawprim2 to set render states..
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::Dp2SetRenderStates(LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates)
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr;
    D3DHAL_DP2RENDERSTATE *pRenderState =
                                    (D3DHAL_DP2RENDERSTATE *)(pCmd + 1);
    // Flush the prim proc before any state changs
    HR_RET(End(FALSE));

    for (i = 0; i < (INT)wStateCount; i++, pRenderState++)
    {
        UINT32 type = (UINT32) pRenderState->RenderState;

        // Set the runtime copy (if necessary)
        if (NULL != lpdwRuntimeRStates)
        {
            lpdwRuntimeRStates[pRenderState->RenderState] = pRenderState->dwState;
        }

            // Set the state
        HR_RET(SetRenderState(pRenderState->RenderState,
                            pRenderState->dwState));
    }

    hr = Begin();
    return hr;
}
//----------------------------------------------------------------------------
//
// Begin - Before rendering preparation
//
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::Begin(void)
{
    HRESULT hr;

    DDASSERT((m_uFlags & D3DCONTEXT_IN_BEGIN) == 0);

    // ATTENTION call this less often?
    UpdateColorKeyAndPalette();

    // Check for state changes
    if (IsAnyStatesChanged())
    {
        // Check for fillmode change
        if (IsStateChanged(D3DRENDERSTATE_FILLMODE))
        {
            UpdatePrimFunctionTbl();
        }

        BOOL bMaxMipLevelsDirty = FALSE;
        for (INT j = 0; j < (INT)m_RastCtx.cActTex; j++)
        {
            PD3DI_SPANTEX pSpanTex = m_RastCtx.pTexture[j];
            if (pSpanTex)
            {
                bMaxMipLevelsDirty = bMaxMipLevelsDirty || (pSpanTex->uFlags & D3DI_SPANTEX_MAXMIPLEVELS_DIRTY);
            }
        }

        if (IsStateChanged(D3DRENDERSTATE_TEXTUREHANDLE) ||
            IsStateChanged(RAST_TSS_DIRTYBIT(0, D3DTSS_TEXTUREMAP)) ||
            IsStateChanged(RAST_TSS_DIRTYBIT(1, D3DTSS_TEXTUREMAP)) ||
            bMaxMipLevelsDirty)
        {
            // Relock texture if texture handles have changed.
            // SetRenderState should have already unlocked the texture.
            if (m_uFlags & D3DCONTEXT_TEXTURE_LOCKED)
            {
                RastUnlockSpanTexture();
            }
            HR_RET(RastLockSpanTexture());
        }

        // Check for WRAP state change
        for (int iWrap=0; iWrap<8; iWrap++)
        {
            D3DRENDERSTATETYPE iWrapState = (D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0+iWrap);
            if (IsStateChanged(iWrapState))
            {
                int i;
                for (i=0; i < D3DHAL_TSS_MAXSTAGES; i++)
                {
                    if (m_fvfData.TexIdx[i] == iWrap)
                    {
                        m_RastCtx.pdwWrap[i] = m_RastCtx.pdwRenderState[iWrapState];
                    }
                }
            }
        }

        // Notify primitive Processor of state change.
        m_PrimProc.StateChanged();

        // Clear state dirtybits
        ClearAllStatesDirtyBits();

        // Must call SpanInit AFTER texture is locked, since this
        // sets various flags and fields that are needed for bead choosing
        // Call SpanInit to setup the beads
        HR_RET(SpanInit(&m_RastCtx));
    }

    // If texture is not locked yet, lock it
    if (!(m_uFlags & D3DCONTEXT_TEXTURE_LOCKED))
    {
        HR_RET(RastLockSpanTexture());
    }

    // Lock rendering target.
    if ((hr=LockSurface(m_RastCtx.pDDS, (LPVOID *)&(m_RastCtx.pSurfaceBits))) != D3D_OK)
    {
        RastUnlockSpanTexture();
        return hr;
    }
    if (m_RastCtx.pDDSZ != NULL)
    {
        if ((hr=LockSurface(m_RastCtx.pDDSZ, (LPVOID *)&(m_RastCtx.pZBits))) != D3D_OK)
        {
            RastUnlockSpanTexture();
            UnlockSurface(m_RastCtx.pDDS);
            return hr;
        }
    }
    else
    {
        m_RastCtx.pZBits = NULL;
    }

    // Prepare the primitive processor
    m_PrimProc.Begin();
    m_uFlags |= D3DCONTEXT_IN_BEGIN;

    return D3D_OK;

}


//-----------------------------------------------------------------------------
//
// MapTextureStageState - Maps statestage texture state to spantex object
//
//-----------------------------------------------------------------------------
void
D3DContext::MapTextureStageState( DWORD dwStage )
{
    if (m_RastCtx.pTexture[dwStage] == NULL) return;
    //
    // assign texture state from stage 0
    //
    m_RastCtx.pTexture[dwStage]->TexAddrU = (D3DTEXTUREADDRESS)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSU]);
    m_RastCtx.pTexture[dwStage]->TexAddrV = (D3DTEXTUREADDRESS)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_ADDRESSV]);
    m_RastCtx.pTexture[dwStage]->BorderColor = (D3DCOLOR)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_BORDERCOLOR]);
    m_RastCtx.pTexture[dwStage]->uMagFilter = (D3DTEXTUREMAGFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAGFILTER]);
    m_RastCtx.pTexture[dwStage]->uMinFilter = (D3DTEXTUREMINFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MINFILTER]);
    m_RastCtx.pTexture[dwStage]->uMipFilter = (D3DTEXTUREMIPFILTER)(m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MIPFILTER]);
    m_RastCtx.pTexture[dwStage]->fLODBias = m_RastCtx.pfTextureStageState[dwStage][D3DTSS_MIPMAPLODBIAS];

    if (m_RastCtx.pTexture[dwStage]->iMaxMipLevel != (INT32)m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAXMIPLEVEL])
    {
        m_RastCtx.pTexture[dwStage]->iMaxMipLevel = (INT32)m_RastCtx.pdwTextureStageState[dwStage][D3DTSS_MAXMIPLEVEL];
        m_RastCtx.pTexture[dwStage]->uFlags |= D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;
    }
}

//-----------------------------------------------------------------------------
//
// MapLegacyTextureFilter -
//
//-----------------------------------------------------------------------------
void
D3DContext::MapLegacyTextureFilter( void )
{
    // D3D legacy filter specifications are (XXXMIP)YYY where XXX is the
    // mip filter and YYY is the filter used within an LOD

    // map MAG filter - legacy support is point or linear (and maybe aniso)
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREMAG] )
    {
    default:
    case D3DFILTER_NEAREST:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MAGFILTER] = D3DTFG_POINT;
        break;
    case D3DFILTER_LINEAR:
        // select based on aniso enable
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MAGFILTER] = D3DTFG_LINEAR;
        break;
    }
    // map MIN and MIP filter at the same time - legacy support
    // has them intermingled...
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREMIN] )
    {
    case D3DFILTER_NEAREST:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MINFILTER] = D3DTFN_POINT;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPFILTER] = D3DTFP_NONE;
        break;
    case D3DFILTER_MIPNEAREST:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MINFILTER] = D3DTFN_POINT;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPFILTER] = D3DTFP_POINT;
        break;
    case D3DFILTER_LINEARMIPNEAREST:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MINFILTER] = D3DTFN_POINT;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
        break;
    case D3DFILTER_LINEAR:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MINFILTER] = D3DTFN_LINEAR;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPFILTER] = D3DTFP_NONE;
        break;
    case D3DFILTER_MIPLINEAR:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MINFILTER] = D3DTFN_LINEAR;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPFILTER] = D3DTFP_POINT;
        break;
    case D3DFILTER_LINEARMIPLINEAR:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MINFILTER] = D3DTFN_LINEAR;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
        break;
    }
}

//-----------------------------------------------------------------------------
//
// MapLegacyTextureBlend - Maps legacy (pre-DX6) texture blend modes to DX6
// texture blending controls.  Uses per-stage program mode (first stage only).
// This mapping is done whenever the legacy TBLEND renderstate is set, and
// does overwrite any previously set DX6 texture blending controls.
//
//-----------------------------------------------------------------------------
void
D3DContext::MapLegacyTextureBlend( void )
{
    // disable texture blend processing stage 1 (this also disables subsequent stages)
    m_RastCtx.pdwTextureStageState[1][D3DTSS_COLOROP] = D3DTOP_DISABLE;

    // set texture blend processing stage 0 to match legacy mode
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND] )
    {
    default:
    case D3DTBLEND_DECALMASK: // unsupported - do decal
    case D3DTBLEND_DECAL:
    case D3DTBLEND_COPY:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLOROP]   = D3DTOP_SELECTARG1;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG1;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        break;

    case D3DTBLEND_MODULATEMASK: // unsupported - do modulate
    case D3DTBLEND_MODULATE:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLOROP]   = D3DTOP_MODULATE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG1;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_MODULATEALPHA:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLOROP]   = D3DTOP_MODULATE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAOP]   = D3DTOP_MODULATE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_DECALALPHA:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLOROP]   = D3DTOP_BLENDTEXTUREALPHA;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_ADD:
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLOROP]   = D3DTOP_ADD;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_RastCtx.pdwTextureStageState[0][D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;
    }

    // since we change [D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP), we can go from DISABLE to
    // something else, and we can need to update the TexStageCount
    UpdateActiveTexStageCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\rasttex.cpp ===
//----------------------------------------------------------------------------
//
// rasttex.cpp
//
// Texture functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// SetSizesSpanTexture
//
// Initialize pSpanTex data using current iMaxMipLevel info, Getting the
// surfaces from pSurf.  Assumes InitSpanTexture has been called first.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::SetSizesSpanTexture(PD3DI_SPANTEX pSpanTex)
{
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);
    LPDIRECTDRAWSURFACE pDDS = pSpanTex->pSurf[iFirstSurf];
    INT i;

    // Init
    pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;

    pSpanTex->iSizeU = (INT16)DDSurf_Width(pLcl);
    pSpanTex->iSizeV = (INT16)DDSurf_Height(pLcl);
    pSpanTex->uMaskU = (INT16)(pSpanTex->iSizeU - 1);
    pSpanTex->uMaskV = (INT16)(pSpanTex->iSizeV - 1);
    pSpanTex->iShiftU = (INT16)IntLog2(pSpanTex->iSizeU);
    if (0 != DDSurf_BitDepth(pLcl))
    {
        pSpanTex->iShiftPitch[0] =
                (INT16)IntLog2((UINT32)(DDSurf_Pitch(pLcl) * 8)/DDSurf_BitDepth(pLcl));
    }
    else
    {
        pSpanTex->iShiftPitch[0] =
                (INT16)IntLog2(((UINT32)DDSurf_Width(pLcl) * 8));
    }
    pSpanTex->iShiftV = (INT16)IntLog2(pSpanTex->iSizeV);
    pSpanTex->uMaskV = pSpanTex->uMaskV;

    // Check if the texture size is power of 2
    if (!ValidTextureSize(pSpanTex->iSizeU, pSpanTex->iShiftU,
                          pSpanTex->iSizeV, pSpanTex->iShiftV))
    {
        return DDERR_INVALIDPARAMS;
    }

    // Check for mipmap if any.
    // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
    // mipmap. They are init'ed with the first texture size.
    INT16 iPreSizeU = pSpanTex->iSizeU, iPreSizeV = pSpanTex->iSizeV;
    for ( i = iFirstSurf + 1; i <= pSpanTex->cLODTex; i++)
    {
        pDDS = pSpanTex->pSurf[i];
        // Check for invalid mipmap texture size
        pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;
        if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width(pLcl)) ||
            !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height(pLcl)))
        {
            return DDERR_INVALIDPARAMS;
        }
        if (0 != DDSurf_BitDepth(pLcl))
        {
            pSpanTex->iShiftPitch[i - iFirstSurf] =
                (INT16)IntLog2(((UINT32)DDSurf_Pitch(pLcl)*8)/DDSurf_BitDepth(pLcl));
        }
        else
        {
            pSpanTex->iShiftPitch[i - iFirstSurf] =
                (INT16)IntLog2(((UINT32)DDSurf_Width(pLcl)*8));
        }
        iPreSizeU = (INT16)DDSurf_Width(pLcl);
        iPreSizeV = (INT16)DDSurf_Height(pLcl);
    }
    pSpanTex->cLOD = pSpanTex->cLODTex - iFirstSurf;
    pSpanTex->iMaxScaledLOD = ((pSpanTex->cLOD + 1) << LOD_SHIFT) - 1;
    pSpanTex->uFlags &= ~D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// InitSpanTexture
//
// Initializes the entire array of pSurf's (regardless of iMaxMipLevel) pointed
// to by the root surface of pDDS.  Sets all pSpanTex state that will not ever
// change in SetSizesSpanTexture.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::InitSpanTexture(PD3DI_SPANTEX pSpanTex, LPDIRECTDRAWSURFACE pDDS)
{
    HRESULT hr;
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    DDSCAPS ddscaps;
    static INT32 iGeneration = 0;

    // Init
    pSpanTex->iGeneration = iGeneration++;

    // Note that all pSpanTex elements are initialized to 0
    pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;

    // Set the transparent bit and the transparent color with pSurf[0]
    // initially
    if ((pLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) != 0)
    {
        pSpanTex->uFlags |= D3DI_SPANTEX_HAS_TRANSPARENT;
        pSpanTex->TransparentColor =
            pLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
    }
    else
    {
        pSpanTex->uFlags &= ~D3DI_SPANTEX_HAS_TRANSPARENT;
    }

    HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLcl)), &(pSpanTex->Format)));

    if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8 ||
        pSpanTex->Format == D3DI_SPTFMT_PALETTE4)
    {
        if (pLcl->lpDDPalette)
        {
            LPDDRAWI_DDRAWPALETTE_GBL   pPal = pLcl->lpDDPalette->lpLcl->lpGbl;
            if (pPal->dwFlags & DDRAWIPAL_ALPHA)
            {
                pSpanTex->uFlags |= D3DI_SPANTEX_ALPHAPALETTE;
            }
            pSpanTex->pPalette = (PUINT32)pPal->lpColorTable;
        }
        if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8)
        {
            pSpanTex->iPaletteSize = 256;
        }
        else
        {
            // PALETTE4
            pSpanTex->iPaletteSize = 16;
        }
    }
    pSpanTex->TexAddrU = D3DTADDRESS_WRAP;
    pSpanTex->TexAddrV = D3DTADDRESS_WRAP;
    pSpanTex->BorderColor = RGBA_MAKE(0xff, 0x00, 0xff, 0xff);

    // assign first pSurf here (mipmap chain gets assigned below)
    pSpanTex->pSurf[0] = pDDS;

    // Check for mipmap if any.
    LPDIRECTDRAWSURFACE pTmpS;
    // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
    // mipmap. They are init'ed with the first texture size.
    INT16 iPreSizeU = pSpanTex->iSizeU, iPreSizeV = pSpanTex->iSizeV;
    for (;;)
    {
        memset(&ddscaps, 0, sizeof(DDSCAPS));
        ddscaps.dwCaps = DDSCAPS_TEXTURE;
        hr = pDDS->GetAttachedSurface(&ddscaps, &pTmpS);    //implicit AddRef
        if (hr == DDERR_NOTFOUND)
        {
            break;
        }
        else if (hr != D3D_OK)
        {
            return hr;
        }
        pDDS = pTmpS;

        pSpanTex->cLODTex ++;
        pSpanTex->pSurf[pSpanTex->cLODTex] = pTmpS;
    }

    pSpanTex->dwSize = sizeof(D3DI_SPANTEX);

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RemoveTexture
//
// Check to see if the to-be-destroyed pSpanTex is currently used by the
// context. If yes, set the according entry to be NULL to disable texture.
//
//----------------------------------------------------------------------------
void D3DContext::RemoveTexture(PD3DI_SPANTEX pSpanTex)
{
    INT i;
    INT cActTex = (INT)m_RastCtx.cActTex;

    for (i = 0; i < cActTex; i++)
    {
        if (m_RastCtx.pTexture[i] == pSpanTex)
        {
            // NULL out the according texture and set dirty bits
            m_RastCtx.cActTex --;
            StateChanged(D3DRENDERSTATE_TEXTUREHANDLE);
            m_RastCtx.pTexture[i] = NULL;
            for (int j=pSpanTex->cLODTex;j>0;j--)   //release attached surfs
            {
                pSpanTex->pSurf[j]->Release();
            }
        }
    }
}
//----------------------------------------------------------------------------
//
// RastTextureCreate
//
// Creates a RAST texture and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureCreate(LPD3DHAL_TEXTURECREATEDATA pTexData)
{
    PD3DI_SPANTEX *ppSpanTex;
    PD3DI_SPANTEX pSpanTex;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureCreate", pTexData);

    // Create the span texture
    ppSpanTex = new PD3DI_SPANTEX;
    pSpanTex = new D3DI_SPANTEX;
    if (ppSpanTex == NULL || pSpanTex == NULL)
    {
        delete ppSpanTex;
        delete pSpanTex;
        D3D_ERR("(Rast) Out of memory in RastTextureCreate");
        pTexData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }
    memset(pSpanTex, 0, sizeof(D3DI_SPANTEX));

    // Point indirector to this texture initially.
    *ppSpanTex = pSpanTex;

    // Init the span texture
    if ((pTexData->ddrval = pDCtx->InitSpanTexture(pSpanTex, pTexData->lpDDS))
        != D3D_OK)
    {
        delete ppSpanTex;
        delete pSpanTex;
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pTexData->ddrval = pDCtx->SetSizesSpanTexture(pSpanTex))
        != D3D_OK)
    {
        delete ppSpanTex;
        delete pSpanTex;
        return DDHAL_DRIVER_HANDLED;
    }

    // ppSpanTex is used as the texture handle returned to d3dim.
    pTexData->dwHandle = (UINT32)(ULONG_PTR)ppSpanTex;

    pTexData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastTextureDestroy
//
// Destroy a RAST texture.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pTexDestroyData)
{
    PD3DI_SPANTEX *ppSpanTex;
    PD3DI_SPANTEX pSpanTex;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureDestroy", pTexDestroyData);
    if (!VALID_D3DI_SPANTEX_PTR_PTR(
        (PD3DI_SPANTEX*)ULongToPtr(pTexDestroyData->dwHandle)))
    {
        D3D_ERR("(Rast) in RastTextureDestroy, invalid texture handle");
        pTexDestroyData->ddrval = DDERR_INVALIDPARAMS;
        return DDHAL_DRIVER_HANDLED;
    }

    // Find the texture
    ppSpanTex = (PD3DI_SPANTEX *)ULongToPtr(pTexDestroyData->dwHandle);
    pSpanTex = *ppSpanTex;

    pDCtx->RemoveTexture(pSpanTex);

    // Delete it
    if (pSpanTex)
    {
        delete ppSpanTex;
        delete pSpanTex;
    }
    else
    {
        pTexDestroyData->ddrval = DDERR_INVALIDPARAMS;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastTextureGetSurf
//
// Returns the surface pointer associate with a texture handle.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pTexGetSurf)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureGetSurf", pTexGetSurf);

    // Check out the span texture
    PD3DI_SPANTEX pSpanTex;
    pSpanTex = HANDLE_TO_SPANTEX(pTexGetSurf->dwHandle);

    if (pSpanTex)
    {
        pTexGetSurf->lpDDS = (UINT_PTR)pSpanTex->pSurf[0];
        pTexGetSurf->ddrval = D3D_OK;
    }
    else
    {
        pTexGetSurf->ddrval = DDERR_INVALIDPARAMS;
    }
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastLockSpanTexture
//
// Lock current texture surface before the texture bits are accessed.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::RastLockSpanTexture(void)
{
    INT i, j;
    PD3DI_SPANTEX pSpanTex;
    HRESULT hr;

    if (IsTextureOff())
    {
        return D3D_OK;
    }

    DDASSERT((m_uFlags & D3DCONTEXT_TEXTURE_LOCKED) == 0);

    for (j = 0;
        j < (INT)m_RastCtx.cActTex;
        j++)
    {
        pSpanTex = m_RastCtx.pTexture[j];
        if (pSpanTex->uFlags & D3DI_SPANTEX_MAXMIPLEVELS_DIRTY)
        {
            hr = SetSizesSpanTexture(pSpanTex);
            if (hr != D3D_OK)
            {
                goto EH_Unlock;
            }
        }
        INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);

        // Currently recursive locks are not allowed.
        DDASSERT((pSpanTex->uFlags & D3DI_SPANTEX_SURFACES_LOCKED) == 0);

        for (i = iFirstSurf; i <= pSpanTex->cLODTex; i++)
        {
            hr = LockSurface(pSpanTex->pSurf[i],
                            (LPVOID*)&(pSpanTex->pBits[i-iFirstSurf]));
            if (hr != D3D_OK)
            {
                // Unlock any partial mipmap locks we've taken, as
                // RastUnlock can only handle entire textures being
                // locked or unlocked.
                while (--i >= 0)
                {
                    UnlockSurface(pSpanTex->pSurf[i]);
                }

                // Make sure that i is signed and that the above
                // loop exited properly.
                DDASSERT(i < 0);

                goto EH_Unlock;
            }
        }

        pSpanTex->uFlags |= D3DI_SPANTEX_SURFACES_LOCKED;
    }

    m_uFlags |= D3DCONTEXT_TEXTURE_LOCKED;

    return D3D_OK;

 EH_Unlock:
    if (j > 0)
    {
        // Unlock complete textures we've already locked.
        // RastUnlock will check the flags to figure
        // out which ones to unlock.
        RastUnlockSpanTexture();
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// RastUnlockTexture
//
// Unlock texture surface after the texture bits are accessed.
// The input is a D3DI_SPANTEX. NULL texture needs to be checked before this
// function gets called.
//
//----------------------------------------------------------------------------
void
D3DContext::RastUnlockSpanTexture(void)
{
    INT i, j;
    PD3DI_SPANTEX pSpanTex;;

    if (IsTextureOff())
    {
        return;
    }

    DDASSERT((m_uFlags & D3DCONTEXT_TEXTURE_LOCKED) != 0);

    for (j = 0;
        j < (INT)m_RastCtx.cActTex;
        j++)
    {
        pSpanTex = m_RastCtx.pTexture[j];

        INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);
        // RastUnlock is used for cleanup in RastLock so it needs to
        // be able to handle partially locked mipmap chains.
        if (pSpanTex->uFlags & D3DI_SPANTEX_SURFACES_LOCKED)
        {
            for (i = iFirstSurf; i <= pSpanTex->cLODTex; i++)
            {
                UnlockSurface(pSpanTex->pSurf[i]);
            }

            pSpanTex->uFlags &= ~D3DI_SPANTEX_SURFACES_LOCKED;
        }
    }
    m_uFlags &= ~D3DCONTEXT_TEXTURE_LOCKED;
}

//----------------------------------------------------------------------------
//
// UpdateColorKeyAndPalette
//
// Updates the color key value and palette.
//
// Also, if the ColorKey enable for the texture has changed, set the texture handle
// dirty bit so the new mode is recognized in span init.
//
//----------------------------------------------------------------------------
void
D3DContext::UpdateColorKeyAndPalette(void)
{
    INT j;
    PD3DI_SPANTEX pSpanTex;

    // Set the transparent bit and the transparent color with pSurf[0]
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    for (j = 0;
        j < (INT)m_RastCtx.cActTex;
        j++)
    {
        pSpanTex = m_RastCtx.pTexture[j];
        if ((pSpanTex != NULL) && (pSpanTex->pSurf[0] != NULL))
        {
            pLcl = ((LPDDRAWI_DDRAWSURFACE_INT) pSpanTex->pSurf[0])->lpLcl;

            // Palette might be changed
            if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8 ||
                    pSpanTex->Format == D3DI_SPTFMT_PALETTE4)
            {
                    if (pLcl->lpDDPalette)
                    {
                            LPDDRAWI_DDRAWPALETTE_GBL   pPal = pLcl->lpDDPalette->lpLcl->lpGbl;
                            if (pPal->dwFlags & DDRAWIPAL_ALPHA)
                            {
                                    pSpanTex->uFlags |= D3DI_SPANTEX_ALPHAPALETTE;
                            }
                            pSpanTex->pPalette = (PUINT32)pPal->lpColorTable;
                    }
            }

            if ((pLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) != 0)
            {
                // texture has a ColorKey value
                pSpanTex->TransparentColor =
                    pLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                if (!(pSpanTex->uFlags & D3DI_SPANTEX_HAS_TRANSPARENT))
                {
                    pSpanTex->uFlags |= D3DI_SPANTEX_HAS_TRANSPARENT;

                    // make sure this state change is recognized, and a new
                    // texture read function is used
                    StateChanged(RAST_TSS_DIRTYBIT(j, D3DTSS_TEXTUREMAP));
                }
            }
            else
            {
                // texture does not have a ColorKey value
                if (pSpanTex->uFlags & D3DI_SPANTEX_HAS_TRANSPARENT)
                {
                    pSpanTex->uFlags &= ~D3DI_SPANTEX_HAS_TRANSPARENT;

                    // make sure this state change is recognized, and a new
                    // texture read function is used
                    StateChanged(RAST_TSS_DIRTYBIT(j, D3DTSS_TEXTUREMAP));
                }
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// Dp2TextureStageState
//
// Called by Drawprim2 to set texture stage states..
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::Dp2TextureStageState(LPD3DHAL_DP2COMMAND pCmd, DWORD dwFvf)
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr;
    LPD3DHAL_DP2TEXTURESTAGESTATE pTexStageState =
                                    (D3DHAL_DP2TEXTURESTAGESTATE  *)(pCmd + 1);
    // Flush the prim proc before any state changs
    HR_RET(End(FALSE));

    for (i = 0; i < (INT)wStateCount; i++, pTexStageState++)
    {
        HR_RET(SetTextureStageState((DWORD)pTexStageState->wStage,
                                    (DWORD)pTexStageState->TSState,
                                    pTexStageState->dwValue));
    }

    HR_RET(CheckFVF(dwFvf));

    hr = Begin();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\dxshad.h ===
/*--

$Revision: 1 $

Copyright (c) 1995, Microsoft Corporation

--*/
#ifndef _DXSHAD_H_
#define _DXSHAD_H_

//////////////////////////////////////////////////////////////////////////
//
//  Needed extensions to D3D to support hardware, per pixel style shadows
//
//////////////////////////////////////////////////////////////////////////

typedef struct _D3DSHADOWDATA {
    DWORD               dwSize;            /* Size of structure */
    DWORD               dwFlags;           /* Flags */
    LPDIRECTDRAWSURFACE lpDDSZBuffer;      /* Shadow z-buffer surface */
    D3DMATRIX*          lpD3DMatrixEye;    /* Eye space transform matrix */
    D3DMATRIX*          lpD3DMatrixLight;  /* Light space transform matrix */
    D3DVALUE            dvAttenuation;     /* Attenuation of light in shadow */
    D3DVALUE            dvZBiasMin;        /* Minimum z bias */
    D3DVALUE            dvZBiasMax;        /* Maximum z bias */
    D3DVALUE            dvUJitter;         /* Shadow sample jitter in u */
    D3DVALUE            dvVJitter;         /* Shadow sample jitter in v */
    DWORD               dwFilterSize;      /* Size of shadow filter */
} D3DSHADOWDATA, *LPD3DSHADOWDATA;

// D3DSHADOWDATA dwFlags
#define D3DSZBUF_ZBIAS      1
#define D3DSZBUF_UVJITTER   2
#define D3DSZBUF_TRIANGLEFILTER   4         /* for experimental purposes */

// This structure is how shadow information is communicated
// to the HAL
typedef struct _D3DI_SHADOWDATA{
    DWORD               dwSize;            /* Size of structure */
    DWORD               dwFlags;           /* Flags */
    DDSURFACEDESC       ddsdShadZ;         /* Shadow z-buffer surface */
    DWORD               dwShadZMaskU;      /* ~(ddsdShadZ.dwWidth-1) */
    DWORD               dwShadZMaskV;      /* ~(ddsdShadZ.dwHeight-1) */
    D3DMATRIX           MatrixShad;        /* Embedded Concatenated screen to light space matrix */
    D3DVALUE            dvAttenuation;     /* Attenuation of light in shadow */
    D3DVALUE            dvZBiasMin;        /* Minimum z bias */
    D3DVALUE            dvZBiasRange;      /* Maximum z bias - Minimum z bias */
    D3DVALUE            dvUJitter;         /* 4.4 integer jitter in u */
    D3DVALUE            dvVJitter;         /* 4.4 integer jitter in v */
    DWORD               dwFilterSize;      /* Size of shadow filter */
    DWORD               dwFilterArea;      /* dwFilterSize*dwFilterSize */
} D3DI_SHADOWDATA, *LPD3DI_SHADOWDATA;

// Additional D3DI_SHADOWDATA dwFlags
#define D3DSHAD_ENABLE  0x80000000          // set to enable shadowing

typedef enum _D3DSHADOWFILTERSIZE {
    D3DSHADOWFILTERSIZE_1x1 = 1,
    D3DSHADOWFILTERSIZE_2x2,
    D3DSHADOWFILTERSIZE_3x3,
    D3DSHADOWFILTERSIZE_4x4,
    D3DSHADOWFILTERSIZE_5x5,
    D3DSHADOWFILTERSIZE_6x6,
    D3DSHADOWFILTERSIZE_7x7,
    D3DSHADOWFILTERSIZE_8x8,
} D3DSHADOWFILTERSIZE;

#endif  // _DXSHAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\mlrfns.h ===
#ifndef _CMLRFNS_H_
#define _CMLRFNS_H_

#ifdef __cplusplus
  extern "C" {
#endif

HRESULT MMXMLRast_1(PD3DI_RASTCTX);
HRESULT MMXMLRast_2(PD3DI_RASTCTX);
HRESULT MMXMLRast_3(PD3DI_RASTCTX);
HRESULT MMXMLRast_4(PD3DI_RASTCTX);
HRESULT MMXMLRast_5(PD3DI_RASTCTX);
HRESULT MMXMLRast_6(PD3DI_RASTCTX);
HRESULT MMXMLRast_7(PD3DI_RASTCTX);
HRESULT MMXMLRast_8(PD3DI_RASTCTX);
HRESULT MMXMLRast_9(PD3DI_RASTCTX);
HRESULT MMXMLRast_10(PD3DI_RASTCTX);
HRESULT MMXMLRast_11(PD3DI_RASTCTX);
HRESULT MMXMLRast_12(PD3DI_RASTCTX);
HRESULT MMXMLRast_13(PD3DI_RASTCTX);
HRESULT MMXMLRast_14(PD3DI_RASTCTX);
HRESULT MMXMLRast_15(PD3DI_RASTCTX);
HRESULT MMXMLRast_16(PD3DI_RASTCTX);
HRESULT MMXMLRast_17(PD3DI_RASTCTX);
HRESULT MMXMLRast_18(PD3DI_RASTCTX);
HRESULT MMXMLRast_19(PD3DI_RASTCTX);
HRESULT MMXMLRast_20(PD3DI_RASTCTX);
HRESULT MMXMLRast_21(PD3DI_RASTCTX);
HRESULT MMXMLRast_22(PD3DI_RASTCTX);
HRESULT MMXMLRast_23(PD3DI_RASTCTX);
HRESULT MMXMLRast_24(PD3DI_RASTCTX);
HRESULT MMXMLRast_25(PD3DI_RASTCTX);
HRESULT MMXMLRast_26(PD3DI_RASTCTX);
HRESULT MMXMLRast_27(PD3DI_RASTCTX);
HRESULT MMXMLRast_28(PD3DI_RASTCTX);

#ifdef __cplusplus
}
#endif


HRESULT CMLRast_1(PD3DI_RASTCTX);
HRESULT CMLRast_2(PD3DI_RASTCTX);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\drawprim.cpp ===
//----------------------------------------------------------------------------
//
// drawprim.cpp
//
// Implements DrawOnePrimitive, DrawOneIndexedPrimitive and
// DrawPrimitives.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// CheckFVF
//
// Check a FVF control word and then init m_fvfData accordingly
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
D3DContext::CheckFVF(DWORD dwFVF)
{
    // check if FVF controls have changed
    if ( (m_fvfData.preFVF == dwFVF) &&
         (m_fvfData.TexIdx[0] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[0][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[1] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[1][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[2] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[2][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[3] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[3][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[4] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[4][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[5] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[5][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[6] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[6][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.TexIdx[7] == (INT)(0xffff&m_RastCtx.pdwTextureStageState[7][D3DTSS_TEXCOORDINDEX])) &&
         (m_fvfData.cActTex == m_RastCtx.cActTex) )
    {
        return D3D_OK;
    }
#if DBG
    // This is added here per Iouri's request. It will make it easier for him
    // to test his code for legacy drivers.
    if (dwFVF == 0)
    {
        dwFVF = D3DFVF_TLVERTEX;
    }
#endif

    memset(&m_fvfData, 0, sizeof(FVFDATA));
    m_fvfData.preFVF = dwFVF;
    INT32 i;
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        m_fvfData.TexIdx[i] = 0xffff&m_RastCtx.pdwTextureStageState[i][D3DTSS_TEXCOORDINDEX];
    }
    m_fvfData.cActTex = m_RastCtx.cActTex;

#if DBG
    // We only support max 8 texture coords
    if (m_fvfData.TexIdx[0] > 7 || m_fvfData.TexIdx[1] > 7)
    {
        D3D_WARN(0, "(Rast) Texture coord index bigger than max supported.");
        return DDERR_INVALIDPARAMS;
    }
#endif

    // Update the copy of wrap states in RastCtx
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        m_RastCtx.pdwWrap[i] = m_RastCtx.pdwRenderState[
                (D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0+m_fvfData.TexIdx[i])];
    }

    // do either true FVF parsing or legacy TLVERTEX handling
    if ( (m_RastCtx.BeadSet != D3DIBS_RAMP) &&
         ( (dwFVF != D3DFVF_TLVERTEX) ||
           (0 != m_fvfData.TexIdx[0]) ||
           (m_RastCtx.cActTex > 1) ) )
    {   // New (non TL)FVF vertex
        // XYZ
        if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED1 | D3DFVF_RESERVED2 |
             D3DFVF_NORMAL)) ||
             ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
        {
            // can't set reserved bits, shouldn't have normals in
            // output to rasterizers, and must have coordinates
            return DDERR_INVALIDPARAMS;
        }
        m_fvfData.stride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            m_fvfData.offsetRHW = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            m_fvfData.offsetDiff = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            m_fvfData.offsetSpec = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
#if DBG
        INT iTexIdx0 = m_fvfData.TexIdx[0], iTexIdx1 = m_fvfData.TexIdx[1];
        if (iTexCount > 0)
        {
            // set offset for Textures
            for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i ++)
            {
                INT iTexIdx = m_fvfData.TexIdx[i];
               if ( iTexIdx >= iTexCount)
               {
                   D3D_WARN(1, "(Rast)Texture coord index bigger than texture coord count.");
                   iTexIdx = 0;
               }
               m_fvfData.offsetTex[i] = (SHORT)(m_fvfData.stride +
                                   2*sizeof(D3DVALUE)*iTexIdx);
            }
            // update stride
            m_fvfData.stride += (USHORT)(iTexCount * (sizeof(D3DVALUE) * 2));
        }
#else
        if (iTexCount > 0)
        {
            // set offset for Textures
            for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i ++)
            {
                m_fvfData.offsetTex[i] = (SHORT)(m_fvfData.stride +
                                    2*sizeof(D3DVALUE)*m_fvfData.TexIdx[i]);
            }
            // update stride
            m_fvfData.stride += (USHORT)(iTexCount * (sizeof(D3DVALUE) * 2));
        }
#endif

        m_fvfData.vtxType = RAST_GENVERTEX;
    }
    else
    {
        // (Legacy) TL vertex
        if (0 < m_fvfData.TexIdx[0])
        {
            D3D_ERR("(Rast) Texture coord index bigger than 0 for legacy TL vertex.");
            return DDERR_INVALIDPARAMS;
        }
        m_fvfData.stride = sizeof(D3DTLVERTEX);
        m_fvfData.vtxType = RAST_TLVERTEX;
    }

    UpdatePrimFunctionTbl();

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PackGenVertex
//
// Pack a FvFVertex into RAST_GENERIC_VERTEX. This is called for every non TL
// FVF vertex. It can be optimized for speed later.
//
//----------------------------------------------------------------------------
void FASTCALL
D3DContext::PackGenVertex(PUINT8 pFvfVtx, RAST_GENERIC_VERTEX *pGenVtx)
{
    pGenVtx->sx = *((D3DVALUE *)pFvfVtx);
    pGenVtx->sy = *((D3DVALUE *)pFvfVtx + 1);
    pGenVtx->sz = *((D3DVALUE *)pFvfVtx + 2);
    if (m_fvfData.offsetRHW)
    {
        pGenVtx->rhw = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetRHW));
    }
    else
    {
        pGenVtx->rhw = 1.0f;
    }
    if (m_fvfData.offsetDiff)
    {
        pGenVtx->color = *((D3DCOLOR *)(pFvfVtx + m_fvfData.offsetDiff));
    }
    else
    {
        pGenVtx->color = __DEFAULT_DIFFUSE;
    }
    if (m_fvfData.offsetSpec)
    {
        pGenVtx->specular = *((D3DCOLOR *)(pFvfVtx + m_fvfData.offsetSpec));
    }
    else
    {
        pGenVtx->specular = __DEFAULT_SPECULAR;
    }
    for (INT32 i = 0; i < (INT32)m_fvfData.cActTex; i++)
    {
       if (m_fvfData.offsetTex[i])
       {
           pGenVtx->texCoord[i].tu = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex[i]));
           pGenVtx->texCoord[i].tv = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex[i]) + 1);
       }
       else
       {
           pGenVtx->texCoord[i].tu = 0.0f;
           pGenVtx->texCoord[i].tv = 0.0f;
       }
    }
}

//----------------------------------------------------------------------------
//
// DoDrawOnePrimitive
//
// Draw one list of primitives. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOnePrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    switch (PrimType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cVertices; i > 0; i--)
        {
            HR_RET(pfnPrims->pfnPoint(pCtx, pVtx));
            pVtx += FvfStride;
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cVertices / 2; i > 0; i--)
        {
            pV0 = pVtx;
            pVtx += FvfStride;
            pV1 = pVtx;
            pVtx += FvfStride;
            HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
        }
        break;
    case D3DPT_LINESTRIP:
        {
            pV1 = pVtx;

            // Disable last-pixel setting for shared verties and store prestate.
            pfnPrims->pfnStoreLastPixelState(pCtx, 1);

            // Initial pV0.
            for (i = (INT)cVertices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pVtx += FvfStride;
                pV1 = pVtx;
                HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
            }

            // Restore last-pixel setting.
            pfnPrims->pfnStoreLastPixelState(pCtx, 0);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + FvfStride;
                HR_RET(pfnPrims->pfnLine(pCtx, pV1, pV0));
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cVertices; i > 0; i -= 3)
        {
            pV0 = pVtx;
            pVtx += FvfStride;
            pV1 = pVtx;
            pVtx += FvfStride;
            pV2 = pVtx;
            pVtx += FvfStride;
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx;
            pVtx += FvfStride;
            pV2 = pVtx;
            pVtx += FvfStride;

            for (i = (INT)cVertices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pVtx += FvfStride;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pVtx += FvfStride;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV2, pV1, PFN_TRIANGLE_5ARG_DEFAULT));
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = pVtx;
            pVtx += FvfStride;
            // Preload initial pV0.
            pV1 = pVtx;
            pVtx += FvfStride;
            for (i = (INT)cVertices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pVtx;
                pVtx += FvfStride;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));
            }
        }
        break;

    default:
        D3D_ERR("(Rast) Unknown or unsupported primitive type "
            "requested of DrawOnePrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawOneIndexedPrimitive
//
// Draw one list of indexed primitives. It's called by
// RastDrawOneIndexedPrimitive.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOneIndexedPrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    switch(PrimType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            HR_RET(pfnPrims->pfnPoint(pCtx, pV0));
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pV1 = pVtx + FvfStride * (*puIndices++);
            HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            pfnPrims->pfnStoreLastPixelState(pCtx, 1);
            // Initial pV1.
            pV1 = pVtx + FvfStride * (*puIndices++);
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
            }
            // Restore last-pixel setting.
            pfnPrims->pfnStoreLastPixelState(pCtx, 0);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + FvfStride * (*puIndices);
                HR_RET(pfnPrims->pfnLine(pCtx, pV1, pV0));
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pV1 = pVtx + FvfStride * (*puIndices++);
            pV2 = pVtx + FvfStride * (*puIndices++);
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx + FvfStride * (*puIndices++);
            pV2 = pVtx + FvfStride * (*puIndices++);

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV2, pV1, PFN_TRIANGLE_5ARG_DEFAULT));
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = pVtx + FvfStride * (*puIndices++);
            // Preload initial pV0.
            pV1 = pVtx + FvfStride * (*puIndices++);
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, PFN_TRIANGLE_5ARG_DEFAULT));
            }
        }
        break;

    default:
        D3D_ERR("(Rast) Unknown or unsupported primitive type "
            "requested of DrawOneIndexedPrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawOneEdgeFlagTriangleFan
//
// Draw one list of triangle fans. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOneEdgeFlagTriangleFan(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 UINT cVertices,
                 UINT32 dwEdgeFlags)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    pV2 = pVtx;
    pVtx += FvfStride;
    pV0 = pVtx;
    pVtx += FvfStride;
    pV1 = pVtx;
    pVtx += FvfStride;
    WORD wFlags = 0;
    if(dwEdgeFlags & 0x2)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    if(dwEdgeFlags & 0x1)
        wFlags |= D3DTRIFLAG_EDGEENABLE3;
    if(cVertices == 3) {
        if(dwEdgeFlags & 0x4)
            wFlags |= D3DTRIFLAG_EDGEENABLE2;
        HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, wFlags));
        return D3D_OK;
    }
    HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, wFlags));
    UINT32 dwMask = 0x4;
    for (i = (INT)cVertices - 4; i > 0; i--)
    {
        pV0 = pV1;
        pV1 = pVtx;
        pVtx += FvfStride;
        if(dwEdgeFlags & dwMask)
        {
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, D3DTRIFLAG_EDGEENABLE1));
        }
        else
        {
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, 0));
        }
        dwMask <<= 1;
    }
    pV0 = pV1;
    pV1 = pVtx;
    wFlags = 0;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    dwMask <<= 1;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE2;
    HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, wFlags));

    return D3D_OK;
}

#if DBG
//----------------------------------------------------------------------------
//
// ValidatePrimType
//
// Check if the primitive type is supported. We could remove this function
// after we have implemented all primitive types and then depend on D3DIM
// to check if the primitive type is valid.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::ValidatePrimType(D3DPRIMITIVETYPE PrimitiveType)
{
    switch(PrimitiveType)
    {
    case D3DPT_POINTLIST:
    case D3DPT_LINELIST:
    case D3DPT_LINESTRIP:
    case D3DPT_TRIANGLELIST:
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        break;
    default:
        D3D_ERR("(Rast) PrimitiveType not supported by the new rasterizer.");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}
#endif
//----------------------------------------------------------------------------
//
// CheckDrawOnePrimitive
//
// Check if the DRAWONEPRIMITIVEDATA is valid.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::CheckDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData)
{
#if DBG
    HRESULT hr;

    if (pOnePrimData == NULL ||
        pOnePrimData->dwhContext == 0 ||
        pOnePrimData->lpvVertices == NULL)
    {
        D3D_ERR("(Rast) Invalid data passed to the new rasterizer.");
        return DDERR_INVALIDPARAMS;
    }

    HR_RET(ValidatePrimType(pOnePrimData->PrimitiveType));
#endif
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// CheckDrawOneIndexedPrimitive
//
// Check if the DRAWONEINDEXEDPRIMITIVEDATA is valid.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::CheckDrawOneIndexedPrimitive(
                         LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pOneIdxPrimData)
{
#if DBG
    HRESULT hr;

    if (pOneIdxPrimData == NULL ||
        pOneIdxPrimData->dwhContext == 0 ||
        pOneIdxPrimData->lpvVertices == NULL ||
        pOneIdxPrimData->lpwIndices == NULL)
    {
        D3D_ERR("(Rast) Invalid data passed to the new rasterizer.");
        return DDERR_INVALIDPARAMS;
    }

    HR_RET(ValidatePrimType(pOneIdxPrimData->PrimitiveType));
#endif
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastDrawOnePrimitive
//
// Draw one list of primitives. This is called by D3DIM for API DrawPrimitive.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData)
{
    HRESULT hr;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastDrawOnePrimitive", pOnePrimData);

    if ((pOnePrimData->ddrval =
        pDCtx->CheckDrawOnePrimitive(pOnePrimData)) != DD_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Check for FVF vertex, and init FVF related fileds if necessary
    // Assume the control word is passed in through dwFlags
    CHECK_FVF(pOnePrimData->ddrval, pDCtx, (DWORD)pOnePrimData->dwFVFControl);

    pOnePrimData->ddrval = pDCtx->Begin();
    if (pOnePrimData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    pOnePrimData->ddrval =
        pDCtx->DrawOnePrimitive((PUINT8)pOnePrimData->lpvVertices,
                         pOnePrimData->PrimitiveType,
                         pOnePrimData->dwNumVertices);

    hr = pDCtx->End();
    if (pOnePrimData->ddrval == D3D_OK)
    {
        pOnePrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastDrawOneIndexedPrimitive
//
// Draw one list of primitives. This is called by D3DIM for API
// DrawIndexedPrimitive.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
                            pOneIdxPrimData)
{
    HRESULT hr;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastDrawOneIndexedPrimitive", pOneIdxPrimData);

    if ((pOneIdxPrimData->ddrval =
         pDCtx->CheckDrawOneIndexedPrimitive(pOneIdxPrimData)) != DD_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Check for FVF vertex, and init FVF related fileds if necessary
    // Assume the control word is passed in through dwFlags
    CHECK_FVF(pOneIdxPrimData->ddrval, pDCtx, (DWORD)pOneIdxPrimData->dwFVFControl);

    pOneIdxPrimData->ddrval = pDCtx->Begin();
    if (pOneIdxPrimData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    pOneIdxPrimData->ddrval =
        pDCtx->DrawOneIndexedPrimitive((PUINT8)pOneIdxPrimData->lpvVertices,
                                pOneIdxPrimData->lpwIndices,
                                pOneIdxPrimData->PrimitiveType,
                                pOneIdxPrimData->dwNumIndices);

    hr = pDCtx->End();
    if (pOneIdxPrimData->ddrval == D3D_OK)
    {
        pOneIdxPrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastDrawPrimitives
//
// This is called by D3DIM for a list of batched API DrawPrimitive calls.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA pDrawPrimData)
{
    PUINT8  pData = (PUINT8)pDrawPrimData->lpvData;
    LPD3DHAL_DRAWPRIMCOUNTS pDrawPrimitiveCounts;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastDrawPrimitives", pDrawPrimData);

    pDrawPrimitiveCounts = (LPD3DHAL_DRAWPRIMCOUNTS)pData;

    // Check for FVF vertex when there are actually something to be drawn, and
    // init FVF related fileds if necessary Assume the control word is passed
    // in through dwReserved
    if (pDrawPrimitiveCounts->wNumVertices > 0)
    {
        CHECK_FVF(pDrawPrimData->ddrval, pDCtx, pDrawPrimData->dwFVFControl);
    }

    // Skip state check and texture lock if the first thing is state change
    if (pDrawPrimitiveCounts->wNumStateChanges == 0)
    {
        pDrawPrimData->ddrval =pDCtx->Begin();
        if (pDrawPrimData->ddrval != D3D_OK)
        {
            goto EH_Exit;
        }
    }

    // Loop through the data, update render states
    // and then draw the primitive
    for (;;)
    {
        pDrawPrimitiveCounts = (LPD3DHAL_DRAWPRIMCOUNTS)pData;
        pData += sizeof(D3DHAL_DRAWPRIMCOUNTS);

        //
        // Update render states
        //

        if (pDrawPrimitiveCounts->wNumStateChanges > 0)
        {
            // Flush the prim proc before any state changs
            pDrawPrimData->ddrval = pDCtx->End(FALSE);
            if (pDrawPrimData->ddrval != D3D_OK)
            {
                return DDHAL_DRIVER_HANDLED;
            }

            pDrawPrimData->ddrval =
                pDCtx->UpdateRenderStates((LPDWORD)pData,
                                   pDrawPrimitiveCounts->wNumStateChanges);
            if (pDrawPrimData->ddrval != D3D_OK)
            {
                goto EH_Exit;
            }

            pData += pDrawPrimitiveCounts->wNumStateChanges *
                sizeof(DWORD) * 2;
        }

        // Check for exit
        if (pDrawPrimitiveCounts->wNumVertices == 0)
        {
            break;
        }

        // Align pointer to vertex data
        pData = (PUINT8)
            ((UINT_PTR)(pData + (DP_VTX_ALIGN - 1)) & ~(DP_VTX_ALIGN - 1));

        // Delayed change until we really need to render something
        if (pDrawPrimitiveCounts->wNumStateChanges > 0)
        {
            // We might have a new texture so lock.
            pDrawPrimData->ddrval = pDCtx->Begin();
            if (pDrawPrimData->ddrval != D3D_OK)
            {
                goto EH_Exit;
            }
        }

        //
        // Primitives
        //
        pDrawPrimData->ddrval =
            pDCtx->DrawOnePrimitive((PUINT8)pData,
                        (D3DPRIMITIVETYPE)pDrawPrimitiveCounts->wPrimitiveType,
                        pDrawPrimitiveCounts->wNumVertices);
        if (pDrawPrimData->ddrval != DD_OK)
        {
            goto EH_Exit;
        }

        pData += pDrawPrimitiveCounts->wNumVertices * pDCtx->GetFvfStride();
    }

 EH_Exit:
    HRESULT hr;

    hr = pDCtx->End();

    if (pDrawPrimData->ddrval == D3D_OK)
    {
        pDrawPrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\mmxemul.h ===
//-----------------------------------------------------------------------------
//
// This file contains headers for routines that emulate MMX instructions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// union for playing with 16 bit multiplies
typedef union tagVAL32 {
    INT32 i;
    struct {
        INT16 l;
        INT16 h;
    } i16;
} VAL32;

UINT16 MMX_addsw(INT16 x, INT16 y);
INT16  MMX_addusw(UINT16 x, UINT16 y);
UINT16 MMX_cmpeqw(INT16 x, INT16 y);
UINT16 MMX_cmpgtw(INT16 x, INT16 y);
INT16  MMX_mulhw(INT16 x, INT16 y);
INT16  MMX_mullw(INT16 x, INT16 y);
INT16  MMX_subsw(INT16 x, INT16 y);
UINT16 MMX_subusw(UINT16 x, UINT16 y);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\sources.inc ===
TARGETNAME = rd3dif
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;..\..\..\ref\rast;..\..\..\ref\inc;$(D3DDX7)\tnl;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        ..\d3dif.cpp\
        ..\swprov.cpp\
        ..\drawprim.cpp\
        $O\dprim2.cpp\
        ..\rendprim.cpp\
        ..\rastctx.cpp\
        ..\rasttex.cpp\
        $O\pmfns.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

NTTARGETFILE0 = \
        $O\pmfns_mh.h\
        $O\pmfns.cpp\
        $O\dprim2.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\mlspan.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Monolithic Rasterizer Functions - Public Header File
//
///////////////////////////////////////////////////////////////////////////////


#ifndef _MONOSPAN_H
#define _MONOSPAN_H

#include "span.h"

DllExport HRESULT Monolithic_RenderSpansTestSelector(PD3DI_RASTCTX pCtx);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mlspan\cmlrast.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains C span loops.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

HRESULT
CMLRast_1(
    PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            UINT16 uPix = pS->uPix;
            INT iSurfaceStep;
            INT iZStep;

            if (pP->uFlags & D3DI_RASTPRIM_X_DEC) {
                iZStep = -pCtx->iZStep;
                iSurfaceStep = -pCtx->iSurfaceStep;
                pCtx->SI.iXStep = -1;   // for dithering
            } else {
                iZStep = pCtx->iZStep;
                iSurfaceStep = pCtx->iSurfaceStep;
                pCtx->SI.iXStep = 1;
            }

            while (1) {
                UINT16 uZ = (UINT16)(pS->uZ>>15);
                UINT16 uZB = *((UINT16*)pS->pZ);
                pS->uZ += pP->iDZDX;
                if ((pCtx->iZXorMask)^(uZ > uZB)) {
                    *((UINT16*)pS->pZ) = uZ;
                    pCtx->SI.uBB = pS->uB;
                    pCtx->SI.uBG = pS->uG;
                    pCtx->SI.uBR = pS->uR;
                    pCtx->SI.uBA = pS->uA;
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    pCtx->SI.uBB = (UINT16)min((UINT32)pCtx->SI.uBB + (UINT32)pS->uBS, 0xffff);
                    pCtx->SI.uBG = (UINT16)min((UINT32)pCtx->SI.uBG + (UINT32)pS->uGS, 0xffff);
                    pCtx->SI.uBR = (UINT16)min((UINT32)pCtx->SI.uBR + (UINT32)pS->uRS, 0xffff);
                    pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                    pS->uRS += pP->iDRSDX;
                    *(PUINT16)pS->pSurface =
                        ((pCtx->SI.uBR >>  1) & 0x7c00) |
                        ((pCtx->SI.uBG >>  6) & 0x03e0) |
                        ((pCtx->SI.uBB >> 11) & 0x001f) |
                        0x8000;
                } else {
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
                        pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                        pS->uRS += pP->iDRSDX;
                    }
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_FOGENABLE]) {
                        pS->uFog += (INT16)pS->iDFog;
                        pCtx->SI.uFogB += pCtx->SI.iFogBDX;
                        pCtx->SI.uFogG += pCtx->SI.iFogGDX;
                        pCtx->SI.uFogR += pCtx->SI.iFogRDX;
                    }
                }
                if (--uPix <= 0)
                    break;
                pS->pZ += iZStep;
                pS->pSurface += iSurfaceStep;
#ifdef DBG
                // handy for debug to see where we are
                pS->uX += (INT16)pCtx->SI.iXStep;
#endif
            }

            pS++;
        }

        pP = pP->pNext;
    }

    return D3D_OK;
}

HRESULT
CMLRast_2(
    PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            UINT16 uPix = pS->uPix;
            INT iSurfaceStep;
            INT iZStep;

            if (pP->uFlags & D3DI_RASTPRIM_X_DEC) {
                iZStep = -pCtx->iZStep;
                iSurfaceStep = -pCtx->iSurfaceStep;
                pCtx->SI.iXStep = -1;   // for dithering
            } else {
                iZStep = pCtx->iZStep;
                iSurfaceStep = pCtx->iSurfaceStep;
                pCtx->SI.iXStep = 1;
            }

            while (1) {
                UINT16 uZ = (UINT16)(pS->uZ>>15);
                UINT16 uZB = *((UINT16*)pS->pZ);
                pS->uZ += pP->iDZDX;
                if ((pCtx->iZXorMask)^(uZ > uZB)) {
                    *((UINT16*)pS->pZ) = uZ;
                    pCtx->SI.uBB = pS->uB;
                    pCtx->SI.uBG = pS->uG;
                    pCtx->SI.uBR = pS->uR;
                    pCtx->SI.uBA = pS->uA;
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    pCtx->SI.uBB = (UINT16)min((UINT32)pCtx->SI.uBB + (UINT32)pS->uBS, 0xffff);
                    pCtx->SI.uBG = (UINT16)min((UINT32)pCtx->SI.uBG + (UINT32)pS->uGS, 0xffff);
                    pCtx->SI.uBR = (UINT16)min((UINT32)pCtx->SI.uBR + (UINT32)pS->uRS, 0xffff);
                    pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                    pS->uRS += pP->iDRSDX;
                    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                                             pCtx->SI.uBB>>8, 0xff);
                    PUINT32 pSurface = (PUINT32)pS->pSurface;
                    *pSurface = uARGB;
                } else {
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
                        pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                        pS->uRS += pP->iDRSDX;
                    }
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_FOGENABLE]) {
                        pS->uFog += (INT16)pS->iDFog;
                        pCtx->SI.uFogB += pCtx->SI.iFogBDX;
                        pCtx->SI.uFogG += pCtx->SI.iFogGDX;
                        pCtx->SI.uFogR += pCtx->SI.iFogRDX;
                    }
                }
                if (--uPix <= 0)
                    break;
                pS->pZ += iZStep;
                pS->pSurface += iSurfaceStep;
#ifdef DBG
                // handy for debug to see where we are
                pS->uX += (INT16)pCtx->SI.iXStep;
#endif
            }

            pS++;
        }

        pP = pP->pNext;
    }

    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mlspan\nothing.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// Does nothing and is only used as a test to see if bead selector can get here.
//
//-----------------------------------------------------------------------------
HRESULT Monolithic_RenderSpansTestSelector(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            //pCtx->pfnBegin(pCtx, pP, pS);
            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mlspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
#include "mlspan.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\swprov.cpp ===
//----------------------------------------------------------------------------
//
// swprov.cpp
//
// Implements software rasterizer HAL provider.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "d3dref.h"


#define MAX_CLIPPING_PLANES     12
#define MAX_CLIP_VERTICES       (( 2 * MAX_CLIPPING_PLANES ) + 3 )
#define MAX_VERTEX_COUNT 2048
#define BASE_VERTEX_COUNT (MAX_VERTEX_COUNT - MAX_CLIP_VERTICES)

extern HRESULT
RastService(DWORD dwCtx,
                RastServiceType srvType, DWORD arg1, LPVOID arg2);

#define nullPrimCaps \
{                                                                             \
    sizeof(D3DPRIMCAPS), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                \
}

#define nullTransCaps \
{                                                                             \
    sizeof(D3DTRANSFORMCAPS), 0                                               \
}

#define nullLightCaps \
{                                                                             \
    sizeof(D3DLIGHTINGCAPS), 0, 0, 0                                          \
}

D3DDEVICEDESC7 g_nullDevDesc =
{
    0,                          /* dwDevCaps */
    nullPrimCaps,               /* lineCaps */
    nullPrimCaps,               /* triCaps */
    0, 0,
    0, 0,
};

static D3DDEVICEDESC7 rgbDevDesc = {0};
static D3DHAL_D3DEXTENDEDCAPS OptSwExtCaps;
static BOOL g_bFilledRGBCaps = FALSE;

static void
FillOutDeviceCaps( void )
{
    //
    //  set device description
    //
    rgbDevDesc.dwDevCaps =
        D3DDEVCAPS_FLOATTLVERTEX        |
        D3DDEVCAPS_EXECUTESYSTEMMEMORY  |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY  |
        D3DDEVCAPS_DRAWPRIMTLVERTEX     ;

    rgbDevDesc.dpcTriCaps.dwSize = sizeof(D3DPRIMCAPS);
    rgbDevDesc.dpcTriCaps.dwMiscCaps =
        D3DPMISCCAPS_CULLNONE |
        D3DPMISCCAPS_CULLCW   |
        D3DPMISCCAPS_CULLCCW  ;
    rgbDevDesc.dpcTriCaps.dwRasterCaps =
        D3DPRASTERCAPS_DITHER                   |
        D3DPRASTERCAPS_ROP2                     |
        D3DPRASTERCAPS_XOR                      |
    //    D3DPRASTERCAPS_PAT                      |
        D3DPRASTERCAPS_ZTEST                    |
        D3DPRASTERCAPS_SUBPIXEL                 |
        D3DPRASTERCAPS_SUBPIXELX                |
        D3DPRASTERCAPS_FOGVERTEX                |
        D3DPRASTERCAPS_FOGTABLE                 |
    //    D3DPRASTERCAPS_STIPPLE                  |
    //    D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   |
    //    D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
    //    D3DPRASTERCAPS_ANTIALIASEDGES           |
        D3DPRASTERCAPS_MIPMAPLODBIAS            |
    //    D3DPRASTERCAPS_ZBIAS                    |
    //    D3DPRASTERCAPS_ZBUFFERLESSHSR           |
        D3DPRASTERCAPS_FOGRANGE                 |
//        D3DPRASTERCAPS_WFOG                   |
        D3DPRASTERCAPS_ZFOG ;
    //    D3DPRASTERCAPS_ANISOTROPY               ;
        rgbDevDesc.dpcTriCaps.dwZCmpCaps =
        D3DPCMPCAPS_NEVER        |
        D3DPCMPCAPS_LESS         |
        D3DPCMPCAPS_EQUAL        |
        D3DPCMPCAPS_LESSEQUAL    |
        D3DPCMPCAPS_GREATER      |
        D3DPCMPCAPS_NOTEQUAL     |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS       ;
    rgbDevDesc.dpcTriCaps.dwSrcBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      |
        D3DPBLENDCAPS_BOTHSRCALPHA     |
        D3DPBLENDCAPS_BOTHINVSRCALPHA  ;
    rgbDevDesc.dpcTriCaps.dwDestBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      ;
    rgbDevDesc.dpcTriCaps.dwAlphaCmpCaps =
    rgbDevDesc.dpcTriCaps.dwZCmpCaps;
    rgbDevDesc.dpcTriCaps.dwShadeCaps =
        D3DPSHADECAPS_COLORFLATRGB       |
        D3DPSHADECAPS_COLORGOURAUDRGB    |
        D3DPSHADECAPS_SPECULARFLATRGB    |
        D3DPSHADECAPS_SPECULARGOURAUDRGB |
        D3DPSHADECAPS_ALPHAFLATBLEND     |
        D3DPSHADECAPS_ALPHAGOURAUDBLEND  |
        D3DPSHADECAPS_FOGFLAT            |
        D3DPSHADECAPS_FOGGOURAUD         ;
    rgbDevDesc.dpcTriCaps.dwTextureCaps =
        D3DPTEXTURECAPS_PERSPECTIVE  |
        D3DPTEXTURECAPS_POW2         |
        D3DPTEXTURECAPS_ALPHA        |
        D3DPTEXTURECAPS_TRANSPARENCY |
        D3DPTEXTURECAPS_ALPHAPALETTE |
        D3DPTEXTURECAPS_BORDER       |
        D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
        D3DPTEXTURECAPS_ALPHAPALETTE             ;
    rgbDevDesc.dpcTriCaps.dwTextureFilterCaps =
        D3DPTFILTERCAPS_NEAREST          |
        D3DPTFILTERCAPS_LINEAR           |
        D3DPTFILTERCAPS_MIPNEAREST       |
        D3DPTFILTERCAPS_MIPLINEAR        |
        D3DPTFILTERCAPS_LINEARMIPNEAREST |
        D3DPTFILTERCAPS_LINEARMIPLINEAR  |
        D3DPTFILTERCAPS_MINFPOINT        |
        D3DPTFILTERCAPS_MINFLINEAR       |
        D3DPTFILTERCAPS_MIPFPOINT        |
        D3DPTFILTERCAPS_MIPFLINEAR       |
        D3DPTFILTERCAPS_MAGFPOINT        |
        D3DPTFILTERCAPS_MAGFLINEAR       ;
    rgbDevDesc.dpcTriCaps.dwTextureBlendCaps =
        D3DPTBLENDCAPS_DECAL         |
        D3DPTBLENDCAPS_MODULATE      |
        D3DPTBLENDCAPS_DECALALPHA    |
        D3DPTBLENDCAPS_MODULATEALPHA |
        // D3DPTBLENDCAPS_DECALMASK     |
        // D3DPTBLENDCAPS_MODULATEMASK  |
        D3DPTBLENDCAPS_COPY          |
        D3DPTBLENDCAPS_ADD           ;
    rgbDevDesc.dpcTriCaps.dwTextureAddressCaps =
        D3DPTADDRESSCAPS_WRAP          |
        D3DPTADDRESSCAPS_MIRROR        |
        D3DPTADDRESSCAPS_CLAMP         |
        D3DPTADDRESSCAPS_BORDER        |
        D3DPTADDRESSCAPS_INDEPENDENTUV ;
    rgbDevDesc.dpcTriCaps.dwStippleWidth = 4;
    rgbDevDesc.dpcTriCaps.dwStippleHeight = 4;

    //  line caps - copy tricaps and modify
    memcpy( &rgbDevDesc.dpcLineCaps, &rgbDevDesc.dpcTriCaps, sizeof(D3DPRIMCAPS) );

    rgbDevDesc.dwDeviceRenderBitDepth = DDBD_8 | DDBD_16 | DDBD_24 | DDBD_32;
    rgbDevDesc.dwDeviceZBufferBitDepth = D3DSWRASTERIZER_ZBUFFERBITDEPTHFLAGS;

    // DX5 stuff (should be in sync with the extended caps reported below)
    rgbDevDesc.dwMinTextureWidth = 1;
    rgbDevDesc.dwMaxTextureWidth = 1024;
    rgbDevDesc.dwMinTextureHeight = 1;
    rgbDevDesc.dwMaxTextureHeight = 1024;

    //
    //  set extended caps
    //
    OptSwExtCaps.dwSize = sizeof(OptSwExtCaps);

    OptSwExtCaps.dwMinTextureWidth = 1;
    OptSwExtCaps.dwMaxTextureWidth = 1024;
    OptSwExtCaps.dwMinTextureHeight = 1;
    OptSwExtCaps.dwMaxTextureHeight = 1024;

    OptSwExtCaps.dwMinStippleWidth = 0; // stipple unsupported
    OptSwExtCaps.dwMaxStippleWidth = 0;
    OptSwExtCaps.dwMinStippleHeight = 0;
    OptSwExtCaps.dwMaxStippleHeight = 0;

    OptSwExtCaps.dwMaxTextureRepeat = 256;
    OptSwExtCaps.dwMaxTextureAspectRatio = 0; // no limit
    OptSwExtCaps.dwMaxAnisotropy = 1;
    OptSwExtCaps.dvGuardBandLeft  = -4096.f;
    OptSwExtCaps.dvGuardBandTop   = -4096.f;
    OptSwExtCaps.dvGuardBandRight  = 4095.f;
    OptSwExtCaps.dvGuardBandBottom = 4095.f;
    OptSwExtCaps.dvExtentsAdjust = 0.;    //  AA kernel is 1.0 x 1.0
    OptSwExtCaps.dwStencilCaps =
        D3DSTENCILCAPS_KEEP   |
        D3DSTENCILCAPS_ZERO   |
        D3DSTENCILCAPS_REPLACE|
        D3DSTENCILCAPS_INCRSAT|
        D3DSTENCILCAPS_DECRSAT|
        D3DSTENCILCAPS_INVERT |
        D3DSTENCILCAPS_INCR   |
        D3DSTENCILCAPS_DECR;
    OptSwExtCaps.dwFVFCaps = 8;
    OptSwExtCaps.dwTextureOpCaps =
        D3DTEXOPCAPS_DISABLE                   |
        D3DTEXOPCAPS_SELECTARG1                |
        D3DTEXOPCAPS_SELECTARG2                |
        D3DTEXOPCAPS_MODULATE                  |
        D3DTEXOPCAPS_MODULATE2X                |
        D3DTEXOPCAPS_MODULATE4X                |
        D3DTEXOPCAPS_ADD                       |
        D3DTEXOPCAPS_ADDSIGNED                 |
//        D3DTEXOPCAPS_ADDSIGNED2X               |
//        D3DTEXOPCAPS_SUBTRACT                  |
//        D3DTEXOPCAPS_ADDSMOOTH                 |
        D3DTEXOPCAPS_BLENDDIFFUSEALPHA         |
        D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
        D3DTEXOPCAPS_BLENDFACTORALPHA          |
        D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       ;
//        D3DTEXOPCAPS_BLENDCURRENTALPHA         |
//        D3DTEXOPCAPS_PREMODULATE               |
//        D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    |
//        D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    |
//        D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
//        D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
    OptSwExtCaps.wMaxTextureBlendStages = 8;
    OptSwExtCaps.wMaxSimultaneousTextures = 8;

    // DX7
    OptSwExtCaps.dwMaxActiveLights = 0;
    OptSwExtCaps.dvMaxVertexW = 10000.;
    OptSwExtCaps.wMaxUserClipPlanes = 0;
    OptSwExtCaps.wMaxVertexBlendMatrices = 0;
    OptSwExtCaps.dwVertexProcessingCaps = 0;

    OptSwExtCaps.dwReserved1 = 0;
    OptSwExtCaps.dwReserved2 = 0;
    OptSwExtCaps.dwReserved3 = 0;
    OptSwExtCaps.dwReserved4 = 0;

    g_bFilledRGBCaps = TRUE;
}
//----------------------------------------------------------------------------
//
// SwHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP SwHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// SwHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) SwHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// SwHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) SwHalProvider::Release(THIS)
{
    return 0;
}

//----------------------------------------------------------------------------
//
// SwHalProvider::GetCaps
//
// Returns software rasterizer caps.
//
//----------------------------------------------------------------------------

STDMETHODIMP
OptRastHalProvider::GetCaps(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion)
{
    *pHwDesc = g_nullDevDesc;

    if( g_bFilledRGBCaps == FALSE )
    {
        FillOutDeviceCaps();
        // add extended caps to rgbDevDesc
        D3DDeviceDescConvert(&rgbDevDesc,NULL,&OptSwExtCaps);
    }

    *pHelDesc = rgbDevDesc;
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// OptRastHalProvider::GetInterface
//
// Returns driver interface data for opt rast.
//
//----------------------------------------------------------------------------

static D3DHAL_GLOBALDRIVERDATA SwDriverData =
{
    sizeof(D3DHAL_GLOBALDRIVERDATA),
    // The rest is filled in at runtime.
};

static D3DHAL_CALLBACKS OptRastCallbacksC =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateC,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    NULL,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS OptRastCallbacksMMX =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateMMX,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    NULL,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS OptRastCallbacksMMXAsRGB =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateMMXAsRGB,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    NULL,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS2 OptRastCallbacks2 =
{
    sizeof(D3DHAL_CALLBACKS2),
    D3DHAL2_CB32_SETRENDERTARGET |
        D3DHAL2_CB32_DRAWONEPRIMITIVE |
        D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE |
        D3DHAL2_CB32_DRAWPRIMITIVES,
    RastSetRenderTarget,
    NULL,
    RastDrawOnePrimitive,
    RastDrawOneIndexedPrimitive,
    RastDrawPrimitives
};

static D3DHAL_CALLBACKS3 OptRastCallbacks3 =
{
    sizeof(D3DHAL_CALLBACKS3),
    D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE |
        D3DHAL3_CB32_DRAWPRIMITIVES2,
    NULL, // Clear2
    NULL, //lpvReserved
    RastValidateTextureStageState,
    RastDrawPrimitives2,
};

static void DevDesc7ToDevDescV1( D3DDEVICEDESC_V1 *pOut, D3DDEVICEDESC7 *pIn )
{

    // These fields are not available in D3DDEVICEDESC7.
    // Zeroing them out, the front-end should not be using them
    //     DWORD            dwFlags
    //     D3DCOLORMODEL    dcmColorModel
    //     D3DTRANSFORMCAPS dtcTransformCaps
    //     BOOL             bClipping
    //     D3DLIGHTINGCAPS  dlcLightingCaps
    //     DWORD            dwMaxBufferSize
    //     DWORD            dwMaxVertexCount
    //     DWORD            dwMinStippleWidth, dwMaxStippleWidth
    //     DWORD            dwMinStippleHeight, dwMaxStippleHeight;
    //
    ZeroMemory( pOut, sizeof( D3DDEVICEDESC_V1 ) );
    pOut->dwSize = sizeof( D3DDEVICEDESC_V1 );

    // These are available in D3DDEVICEDESC7 so copy field by field
    // to avoid any future problems based on the assumptions of size
    pOut->dwDevCaps = pIn->dwDevCaps;
    pOut->dpcLineCaps = pIn->dpcLineCaps;
    pOut->dpcTriCaps = pIn->dpcTriCaps;
    pOut->dwDeviceRenderBitDepth = pIn->dwDeviceRenderBitDepth;
    pOut->dwDeviceZBufferBitDepth = pIn->dwDeviceZBufferBitDepth;
}


STDMETHODIMP
OptRastHalProvider::GetInterface(THIS_
                                 LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                                 LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                                 DWORD dwVersion)
{
    if( g_bFilledRGBCaps == FALSE )
    {
        FillOutDeviceCaps();
        // add extended caps to rgbDevDesc
        D3DDeviceDescConvert(&rgbDevDesc,NULL,&OptSwExtCaps);
    }

    //
    // Need to fix up SwDriverData.hwCaps (D3DDEVICEDESC) from
    // rgbDevDesc (D3DDEVICEDESC7)
    //
    DevDesc7ToDevDescV1( &SwDriverData.hwCaps, &rgbDevDesc );

    SW_RAST_TYPE RastType;
    switch(m_BeadSet)
    {
    default:
    case D3DIBS_C:
        RastType = SW_RAST_RGB;
        break;
    case D3DIBS_MMX:
        RastType = SW_RAST_MMX;
        break;
    case D3DIBS_MMXASRGB:
        RastType = SW_RAST_MMXASRGB;
        break;
    }
    // Vertex counts are left zero.
    SwDriverData.dwNumTextureFormats =
        TextureFormats(&SwDriverData.lpTextureFormats, dwVersion, RastType);
    SwDriverData.dwNumVertices = BASE_VERTEX_COUNT;
    SwDriverData.dwNumClipVertices = MAX_CLIP_VERTICES;
    pInterfaceData->pGlobalData = &SwDriverData;

    pInterfaceData->pExtCaps = &OptSwExtCaps;

    switch(m_BeadSet)
    {
    case D3DIBS_MMX:        pInterfaceData->pCallbacks = &OptRastCallbacksMMX;      break;
    case D3DIBS_MMXASRGB:   pInterfaceData->pCallbacks = &OptRastCallbacksMMXAsRGB; break;
    case D3DIBS_C:          pInterfaceData->pCallbacks = &OptRastCallbacksC;        break;
    }
    pInterfaceData->pCallbacks2 = &OptRastCallbacks2;
    pInterfaceData->pCallbacks3 = &OptRastCallbacks3;

    pInterfaceData->pfnRastService = NULL;
    pInterfaceData->pfnGetDriverState = NULL;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// OptRastHalProvider
//
// Constructor for OptRastHalProvider to allow a bit of private state to be
// kept to indicate which optimized rasterizer is to be used.
//
//----------------------------------------------------------------------------
OptRastHalProvider::OptRastHalProvider(THIS_
                       DWORD BeadSet)
{
    m_BeadSet = BeadSet;
}

//----------------------------------------------------------------------------
//
// GetSwProvider
//
// Returns the appropriate software HAL provider based on the given GUID.
//
//----------------------------------------------------------------------------

static OptRastHalProvider g_OptRastHalProviderC(D3DIBS_C);
static OptRastHalProvider g_OptRastHalProviderMMX(D3DIBS_MMX);
static OptRastHalProvider g_OptRastHalProviderMMXAsRGB(D3DIBS_MMXASRGB);

STDAPI GetSwHalProvider(REFIID riid, IHalProvider **ppHalProvider,
                        HINSTANCE *phDll)
{
    *phDll = NULL;
    if (IsEqualIID(riid, IID_IDirect3DRGBDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderC;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMMXDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderMMX;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMMXAsRGBDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderMMXAsRGB;
    }
    else if (IsEqualIID(riid, IID_IDirect3DRefDevice) ||
             IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        // try to get provider from external DLL ref device
        PFNGETREFHALPROVIDER pfnGetRefHalProvider;
        if (NULL == (pfnGetRefHalProvider =
            (PFNGETREFHALPROVIDER)LoadReferenceDeviceProc("GetRefHalProvider")))
        {
            *ppHalProvider = NULL;
            return E_NOINTERFACE;
        }
        D3D_INFO(0,"GetSwHalProvider: getting provider from d3dref");
        pfnGetRefHalProvider(riid, ppHalProvider, phDll);
    }
    else
    {
        *ppHalProvider = NULL;
        return E_NOINTERFACE;
    }

    // As a debugging aid, allow the particular rasterizer to be forced
    // via a registry setting.  This lets a developer run an app on any
    // rasterizer regardless of what it asks for.

    LONG iRet;
    HKEY hKey;

    iRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RESPATH, 0, KEY_READ, &hKey);
    if (iRet == ERROR_SUCCESS)
    {
        DWORD dwData, dwType;
        DWORD dwDataSize;

        dwDataSize = sizeof(dwData);
        iRet = RegQueryValueEx(hKey, "ForceRgbRasterizer", NULL,
                               &dwType, (BYTE *)&dwData, &dwDataSize);
        if (iRet == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            dwDataSize == sizeof(dwData))
        {
            switch(dwData)
            {
            case 1:
            case 2:
                *ppHalProvider = &g_OptRastHalProviderC;
                break;
            case 3:
                *ppHalProvider = &g_OptRastHalProviderMMX;
                break;
            case 4:
            case 5:
                // try to get provider from external DLL ref device
                PFNGETREFHALPROVIDER pfnGetRefHalProvider;
                if (NULL == (pfnGetRefHalProvider =
                             (PFNGETREFHALPROVIDER)LoadReferenceDeviceProc("GetRefHalProvider")))
                {
                    *ppHalProvider = NULL;
                    return E_NOINTERFACE;
                }
                D3D_INFO(0,"GetSwHalProvider: getting provider from d3dref");
                pfnGetRefHalProvider(riid, ppHalProvider, phDll);
                break;
            case 6:
                *ppHalProvider = &g_OptRastHalProviderMMXAsRGB;
                break;
            case 0:
                // no override for 0
                break;
            default:
                D3D_ERR("(Rast) Unknown ForceRgbRasterizer setting - no force");
                break;
            }

            D3D_INFO(0, "(Rast) ForceRgbRasterizer to %d", dwData);
        }

        RegCloseKey(hKey);
    }

    return S_OK;
}

STDAPI GetSwTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd, DWORD dwD3DDeviceVersion) {

    // assumes it can't get an invalid RIID.
    if(IsEqualIID(riid, IID_IDirect3DHALDevice) ||
       IsEqualIID(riid, IID_IDirect3DTnLHalDevice) ||
       IsEqualIID(riid, IID_IDirect3DRampDevice))
    {
        D3D_WARN(2,"(Rast) GetSWTextureFormats Internal Error: HAL and Ramp GUIDs are not valid args");
        *lplpddsd=NULL;
        return 0;
    }

    if(IsEqualIID(riid, IID_IDirect3DRefDevice) ||
       IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        // try to get provider from external DLL ref device
        PFNGETREFTEXTUREFORMATS pfnGetRefTextureFormats;
        if (NULL == (pfnGetRefTextureFormats =
                     (PFNGETREFTEXTUREFORMATS)LoadReferenceDeviceProc("GetRefTextureFormats")))
        {
            D3D_WARN(2,"(Rast) GetSWTextureFormats Internal Error: d3dref.dll not found");
            *lplpddsd=NULL;
            return 0;
        }
        D3D_INFO(0,"GetSwHalProvider: getting provider from d3dref");
        return pfnGetRefTextureFormats(riid, lplpddsd, dwD3DDeviceVersion);
    }

    SW_RAST_TYPE RastType = SW_RAST_RGB;
    if (IsEqualIID(riid, IID_IDirect3DMMXDevice))
    {
        RastType = SW_RAST_MMX;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMMXAsRGBDevice))
    {
        RastType = SW_RAST_MMXASRGB;
    }

    return TextureFormats(lplpddsd,dwD3DDeviceVersion, RastType);
}

STDAPI GetSwZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF) {

    // assumes it can't get an invalid RIID.
    if(IsEqualIID(riid, IID_IDirect3DHALDevice) ||
       IsEqualIID(riid, IID_IDirect3DTnLHalDevice) ||
        IsEqualIID(riid, IID_IDirect3DRampDevice))
    {
        D3D_WARN(2,"(Rast) GetSWZBufferFormats Internal Error: HAL and Ramp GUIDs are not valid args");
        *ppDDPF=NULL;
        return 0;
    }

    if (IsEqualIID(riid, IID_IDirect3DRefDevice) ||
        IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        // try to get Z buffer formats from external DLL ref device
        PFNGETREFZBUFFERFORMATS pfnGetRefZBufferFormats;
        if (NULL == (pfnGetRefZBufferFormats =
            (PFNGETREFZBUFFERFORMATS)LoadReferenceDeviceProc("GetRefZBufferFormats")))
        {
            D3D_WARN(2,"(Rast) GetSWZBufferFormats Internal Error: d3dref.dll not found");
            *ppDDPF=NULL;
            return 0;
        }
        return pfnGetRefZBufferFormats(riid, ppDDPF);
    }

    return ZBufferFormats(ppDDPF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\rendprim.cpp ===
//----------------------------------------------------------------------------
//
// rendprim.cpp
//
// RastRenderState and RastRenderPrimitive.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#define DDS_LCL(x) ((LPDDRAWI_DDRAWSURFACE_INT)(x))->lpLcl

//----------------------------------------------------------------------------
//
// RendPoint
//
// Draw lists of points. Called by RastRenderPrimitive() for drawing points.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendPoints(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DPOINT pPt)
{
    INT i;
    LPD3DTLVERTEX pV;

    for (i = pIns->wCount; i > 0; i--)
    {
        INT iPts;
        for (iPts = pPt->wCount, pV = pVtx + pPt->wFirst;
             iPts > 0;
             iPts --, pV ++)
        {
            HRESULT hr;
            HR_RET(pfnPrims->pfnPoint(pCtx, (PUINT8)pV));
        }
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RendLine
//
// Draw a list of lines. Called by RastRenderPrimitive() for drawing lines.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendLines(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DLINE pLine)
{
    INT i;
    LPD3DTLVERTEX pV0, pV1;

    for (i = pIns->wCount; i > 0; i --)
    {
        HRESULT hr;
        pV0 = pVtx + pLine->v1;
        pV1 = pVtx + pLine->v2;
        pLine = (LPD3DLINE)((PINT8)pLine + pIns->bSize);
        HR_RET(pfnPrims->pfnLine(pCtx, (PUINT8)pV0, (PUINT8)pV1));
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RendTriangle
//
// Draw a list of triangles. Called by RastRenderPrimitive() for drawing
// triangles.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendTriangles(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DTRIANGLE pTri)
{
    LPD3DTLVERTEX pV0, pV1, pV2;
    INT i;
    for (i = pIns->wCount; i > 0; i --)
    {
        HRESULT hr;
        pV0 = pVtx + pTri->v1;
        pV1 = pVtx + pTri->v2;
        pV2 = pVtx + pTri->v3;
        HR_RET(pfnPrims->pfnTri(pCtx, (PUINT8)pV0, (PUINT8)pV1, 
                                (PUINT8)pV2, pTri->wFlags));
        pTri = (LPD3DTRIANGLE)((PINT8)pTri + pIns->bSize);
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastRenderPrimitive
//
// Called by Execute() for drawing primitives.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA pRenderData)
{
    LPD3DINSTRUCTION pIns;
    LPD3DTLVERTEX pVtx;
    PUINT8 pData, pPrim;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastRenderPrimitive", pRenderData);

    if (pDCtx->GetRastCtx()->pdwRenderState[D3DRENDERSTATE_ZVISIBLE])
    {
        pRenderData->dwStatus &= ~D3DSTATUS_ZNOTVISIBLE;
        pRenderData->ddrval = D3D_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    // Find out necessary data
    pData = (PUINT8)(DDS_LCL(pRenderData->lpExeBuf)->lpGbl->fpVidMem);
    pIns = &pRenderData->diInstruction;
    pPrim = pData + pRenderData->dwOffset;
    pVtx = (LPD3DTLVERTEX)
                ((PUINT8)DDS_LCL(pRenderData->lpTLBuf)->lpGbl->fpVidMem
                + pRenderData->dwTLOffset);

    pRenderData->ddrval = pDCtx->Begin();
    if (pRenderData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Render
    switch (pIns->bOpcode) {
    case D3DOP_POINT:
        pDCtx->BeginPrimSet(D3DPT_POINTLIST, RAST_TLVERTEX);
        pRenderData->ddrval = DoRendPoints((LPVOID)pDCtx, pDCtx->GetFunsTbl(),
                                        pIns, pVtx, (LPD3DPOINT)pPrim);
        break;
    case D3DOP_LINE:
        pDCtx->BeginPrimSet(D3DPT_LINELIST, RAST_TLVERTEX);
        pRenderData->ddrval = DoRendLines((LPVOID)pDCtx, pDCtx->GetFunsTbl(),
                                        pIns, pVtx, (LPD3DLINE)pPrim);
        break;
    case D3DOP_TRIANGLE:
        pDCtx->BeginPrimSet(D3DPT_TRIANGLELIST, RAST_TLVERTEX);
        pRenderData->ddrval = DoRendTriangles((LPVOID)pDCtx, pDCtx->GetFunsTbl(),
                                        pIns, pVtx, (LPD3DTRIANGLE)pPrim);
        break;
    default:
        D3D_ERR("(Rast) Wrong Opcode passed to the new rasterizer.");
        pRenderData->ddrval =  DDERR_INVALIDPARAMS;
        break;
    }

    HRESULT hr;

    hr = pDCtx->End();
    if (pRenderData->ddrval == D3D_OK)
    {
        pRenderData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastRenderPrimitive
//
// Called by Execute() for setting render states.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastRenderState(LPD3DHAL_RENDERSTATEDATA pStateData)
{
    PUINT8 pData;
    LPD3DSTATE pState;
    INT i;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastRenderState", pStateData);

    // Updates D3DCTX
    pData = (PUINT8) (((LPDDRAWI_DDRAWSURFACE_INT)
        (pStateData->lpExeBuf))->lpLcl->lpGbl->fpVidMem);
    for (i = 0, pState = (LPD3DSTATE) (pData + pStateData->dwOffset);
         i < (INT)pStateData->dwCount;
         i ++, pState ++)
    {
        UINT32 type = (UINT32) pState->drstRenderStateType;

        // Set the state
        pStateData->ddrval = pDCtx->SetRenderState(type, pState->dwArg[0]);
        if (pStateData->ddrval != D3D_OK)
        {
            return DDHAL_DRIVER_HANDLED;
        }
    }

    return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxemul\mmxemul.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains routines that emulate MMX instructions in ordinary C
// for algorithm development.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "d3dtypesp.h"
#include "d3ditype.h"
#include "mmxemul.h"

UINT16 MMX_addsw(INT16 x, INT16 y)
{
    INT32 z = x + y;
    if (z > 0x7fff)
        z = 0x7fff;
    if (z < -32768)
        z = -32768;
    return (INT16)z;
}

INT16  MMX_addusw(UINT16 x, UINT16 y)
{
    INT32 z = (INT32)x + (INT32)y;
    if (z > 0xffff)
        z = 0xffff;
    if (z < 0)
        z = 0;
    return (UINT16)z;
}

UINT16 MMX_cmpeqw(INT16 x, INT16 y)
{
    if (x == y) {
        return 0xffff;
    } else {
        return 0x0;
    }
}

UINT16 MMX_cmpgtw(INT16 x, INT16 y)
{
    if (x > y) {
        return 0xffff;
    } else {
        return 0x0;
    }
}

// Emulate 16 bit MMX style multiplies
// Note that MULHW only works with signed operands, but MULLW works for
// signed and unsigned operands.
INT16 MMX_mulhw(INT16 x, INT16 y)
{
    INT32 z = x*y;
    INT16 r = (INT16)(z>>16);
    return r;
}

INT16 MMX_mullw(INT16 x, INT16 y)
{
    INT32 z = x*y;
    INT16 r = z & 0xffff;
    return r;
}

INT16 MMX_subsw(INT16 x, INT16 y)
{
    INT32 z = x - y;
    if (z > 0x7fff)
        z = 0x7fff;
    if (z < -32768)
        z = -32768;
    return (INT16)z;
}

UINT16 MMX_subusw(UINT16 x, UINT16 y)
{
    INT32 z = (INT32)x - (INT32)y;
    if (z > 0xffff)
        z = 0xffff;
    if (z < 0)
        z = 0;
    return (UINT16)z;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\bldfuncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

void MMX_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void MMX_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\bufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR MMX_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR MMX_BufRead_Palette8(PUINT8 pBits);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\d3dif\swprov.hpp ===
//----------------------------------------------------------------------------
//
// swprov.hpp
//
// Base software HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SWPROV_HPP_
#define _SWPROV_HPP_

//----------------------------------------------------------------------------
//
// SwHalProvider
//
// Implements the base HAL provider for the software rasterizers.
//
//----------------------------------------------------------------------------

class SwHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
};

//----------------------------------------------------------------------------
//
// OptRastHalProvider
//
// Specific provider for the optimized software rasterizer.
//
//----------------------------------------------------------------------------

class OptRastHalProvider : public SwHalProvider
{
private:
    DWORD m_BeadSet;
public:
    OptRastHalProvider(THIS_
                       DWORD);
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
};

#endif // #ifndef _SWPROV_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\bufwrite.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void MMX_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\loop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

void MMX_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\rast.h ===
//----------------------------------------------------------------------------
//
// rast.h
//
// Umbrella header file for the rasterizers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAST_H_
#define _RAST_H_

#ifndef DllExport
#define DllExport   __declspec( dllexport )
#endif

#include <d3ditype.h>
#include <d3dutil.h>
#include <span.h>

typedef enum _RASTSurfaceType
{
    RAST_STYPE_NULL     = 0,
    RAST_STYPE_B8G8R8   = 1,
    RAST_STYPE_B8G8R8A8 = 2,
    RAST_STYPE_B8G8R8X8 = 3,
    RAST_STYPE_B5G6R5   = 4,
    RAST_STYPE_B5G5R5   = 5,
    RAST_STYPE_PALETTE4 = 6,
    RAST_STYPE_PALETTE8 = 7,
    RAST_STYPE_B5G5R5A1 = 8,
    RAST_STYPE_B4G4R4   = 9,
    RAST_STYPE_B4G4R4A4 =10,
    RAST_STYPE_L8       =11,          // 8 bit luminance-only
    RAST_STYPE_L8A8     =12,          // 16 bit alpha-luminance
    RAST_STYPE_U8V8     =13,          // 16 bit bump map format
    RAST_STYPE_U5V5L6   =14,          // 16 bit bump map format with luminance
    RAST_STYPE_U8V8L8   =15,          // 24 bit bump map format with luminance
    RAST_STYPE_UYVY     =16,          // UYVY format (PC98 compliance)
    RAST_STYPE_YUY2     =17,          // YUY2 format (PC98 compliance)
    RAST_STYPE_DXT1    =18,          // S3 texture compression technique 1
    RAST_STYPE_DXT2    =19,          // S3 texture compression technique 2
    RAST_STYPE_DXT3    =20,          // S3 texture compression technique 3
    RAST_STYPE_DXT4    =21,          // S3 texture compression technique 4
    RAST_STYPE_DXT5    =22,          // S3 texture compression technique 5
    RAST_STYPE_B2G3R3   =23,          // 8 bit RGB texture format

    RAST_STYPE_Z16S0    =32,
    RAST_STYPE_Z24S8    =33,
    RAST_STYPE_Z15S1    =34,
    RAST_STYPE_Z32S0    =35,

} RASTSurfaceType;


#endif // #ifndef _RAST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\setup.hpp ===
//----------------------------------------------------------------------------
//
// setup.hpp
//
// Setup declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SETUP_HPP_
#define _SETUP_HPP_

#pragma warning(disable:4786)

#include "stp_base.h"

// PrimProcessor flags.
#define PPF_IN_BEGIN                    0x00000001
#define PPF_STATE_CHANGED               0x00000002
#define PPF_NORMALIZE_RHW               0x00000004
#define PPF_DRAW_LAST_LINE_PIXEL        0x00000008

// Bounds for normalized RHWs.  These are not quite the ideal bounds to
// avoid over- and underflow after normalization when at least one RHW is
// guaranteed to be at the bounds.  There is no reason it
// has to be normalized to [0,1] anway, other than to try and spread
// the values across the desired range.
#define NORMALIZED_RHW_MIN g_fZero
#define NORMALIZED_RHW_MAX g_fp95

//----------------------------------------------------------------------------
//
// PrimProcessor
//
// Accepts primitives to be rasterized.  Primitive and span descriptions
// are put into a buffer for later processing by the span-level code.
//
//----------------------------------------------------------------------------

class DllExport PrimProcessor
{
public:
    PrimProcessor(void);
    HRESULT Initialize(void);
    ~PrimProcessor(void);

    inline UINT GetFlags(void);
    inline void SetFlags(UINT uFlags);
    inline void ClrFlags(UINT uFlags);

    inline void StateChanged();

    void SetCtx(PD3DI_RASTCTX pCtx);

    void BeginPrimSet(D3DPRIMITIVETYPE PrimType,
                      RAST_VERTEX_TYPE VertType);

    HRESULT Point(LPD3DTLVERTEX pV0,
                  LPD3DTLVERTEX pFlatVtx);
    HRESULT Line(LPD3DTLVERTEX pV0,
                 LPD3DTLVERTEX pV1,
                 LPD3DTLVERTEX pFlatVtx);
    HRESULT Tri(LPD3DTLVERTEX pV0,
                LPD3DTLVERTEX pV1,
                LPD3DTLVERTEX pV2);

    void Begin(void);
    HRESULT End(void);

    HRESULT AllocSpans(PUINT pcSpans, PD3DI_RASTSPAN *ppSpan);
    void FreeSpans(UINT cSpans);

private:
    // Original FP control word.
    UINT16 m_uFpCtrl;

    // Buffer space and current pointer.
    PUINT8 m_pBuffer;
    PUINT8 m_pBufferStart;
    PUINT8 m_pBufferEnd;
    PUINT8 m_pCur;

    // Flags.
    UINT m_uPpFlags;

    //
    // Intermediate results shared between methods.
    //

    SETUPCTX m_StpCtx;

    // Previous primitive, for primitive chaining.
    PD3DI_RASTPRIM m_pOldPrim;

    // Attribute function table index.
    INT m_iAttrFnIdx;

    // Old primitive and vertex types.
    D3DPRIMITIVETYPE m_PrimType;
    RAST_VERTEX_TYPE m_VertType;

    //
    // Triangle values.
    //

    // Y values and trapezoid heights.
    INT m_iY1, m_iY2;
    UINT m_uHeight10, m_uHeight21, m_uHeight20;

    // Triangle X extent.
    INT m_iXWidth;

    // Original RHW saved during RHW normalization.
    D3DVALUE m_dvV0RHW;
    D3DVALUE m_dvV1RHW;
    D3DVALUE m_dvV2RHW;

    //
    // Point methods.
    //
    void NormalizePointRHW(LPD3DTLVERTEX pV0);
    void FillPointSpan(LPD3DTLVERTEX pV0, PD3DI_RASTSPAN pSpan);

    //
    // Line methods.
    //
    void NormalizeLineRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1);
    BOOL PointDiamondCheck(INT32 iXFrac, INT32 iYFrac,
                           BOOL bSlopeIsOne, BOOL bSlopeIsPosOne);
    BOOL LineSetup(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1);

    //
    // Triangle methods.
    //
    void NormalizeTriRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                         LPD3DTLVERTEX pV2);
    BOOL TriSetup(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1, LPD3DTLVERTEX pV2);
    inline void SetTriFunctions(void);

    //
    // Buffer management methods.
    //
    inline void ResetBuffer(void);
    HRESULT Flush(void);
    HRESULT FlushPartial(void);
    HRESULT AppendPrim(void);

#if DBG
    //
    // Debug methods.  Only callable within DBG builds.
    //
    inline HRESULT ValidateVertex(LPD3DTLVERTEX pV);
#endif
};

//----------------------------------------------------------------------------
//
// PrimProcessor::GetFlags
//
// Returns the current PrimProcessor flags.
//
//----------------------------------------------------------------------------

inline UINT
PrimProcessor::GetFlags(void)
{
    return m_uPpFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::SetFlags
//
// Sets the given flags.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::SetFlags(UINT uFlags)
{
    m_uPpFlags |= uFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ClrFlags
//
// Clears the given flags.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::ClrFlags(UINT uFlags)
{
    m_uPpFlags &= ~uFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::StateChanged
//
// Notifies the PrimProcessor that state has changed.
// Could be done through SetFlags but this hides the actual implementation.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::StateChanged(void)
{
    m_uPpFlags |= PPF_STATE_CHANGED;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ComputeIntCarry
//
// Takes an FP coordinate value and span delta and computes integer form
// for int/carry arithmetic.
//
// NOTE: Assumes iV already computed.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

// Prototype is:
// inline void
// PrimProcessor::ComputeIntCarry(FLOAT fV, FLOAT fDVDS, PINTCARRYVAL pICY)
//
// Fraction is biased by one to handle exactly-integer coordinate
// values properly.

#define ComputeIntCarry(fV, fDVDS, pICY)                                      \
    ((pICY)->iFrac = (SCALED_FRACTION((fV) - FLOORF(fV)) - 1) & 0x7fffffff,   \
     (pICY)->iNC = FTOI(fDVDS),                                               \
     (pICY)->iDFrac = SCALED_FRACTION((fDVDS) - (pICY)->iNC),                 \
     (pICY)->iCY = FLOAT_LTZ(fDVDS) ? (pICY)->iNC - 1 : (pICY)->iNC + 1)

//----------------------------------------------------------------------------
//
// PrimProcessor::GetPrim
//
// Moves prim pointer to the next position in the buffer, flushing
// to make space if necessary.  Checks to see if there's space for
// at least one span also since it doesn't make much sense to not
// flush if there's exactly enough space for just the prim structure.
//
// Does not update m_pCur until CommitPrim.  m_pCur == pPrim
// indicates pPrim is not fully valid.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

#define GET_PRIM()                                                            \
{                                                                             \
    if (m_pCur + (sizeof(D3DI_RASTPRIM) + sizeof(D3DI_RASTSPAN)) >            \
        m_pBufferEnd)                                                         \
    {                                                                         \
        HRESULT hr;                                                           \
                                                                              \
        RSHRRET(Flush());                                                     \
    }                                                                         \
                                                                              \
    m_StpCtx.pPrim = (PD3DI_RASTPRIM)m_pCur;                                  \
}

//----------------------------------------------------------------------------
//
// PrimProcessor::CommitPrim
//
// Commits the current primitive space so that spans may be added.
// The primitive data can be partly or fulled cleared as part of
// the commit.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

#define COMMIT_PRIM(bClearAll)                                                \
{                                                                             \
    m_pCur = (PUINT8)(m_StpCtx.pPrim + 1);                                    \
                                                                              \
    if (m_pOldPrim != NULL)                                                   \
    {                                                                         \
        m_pOldPrim->pNext = m_StpCtx.pPrim;                                   \
    }                                                                         \
    m_pOldPrim = m_StpCtx.pPrim;                                              \
                                                                              \
    if (bClearAll)                                                            \
    {                                                                         \
        memset(m_StpCtx.pPrim, 0, sizeof(*m_StpCtx.pPrim));                   \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        m_StpCtx.pPrim->uSpans = 0;                                           \
        m_StpCtx.pPrim->pNext = NULL;                                         \
    }                                                                         \
}

#define ALLOC_SPANS(pStpCtx, pcSpans, ppSpan) \
    ((PrimProcessor *)pStpCtx->PrimProcessor)->AllocSpans(pcSpans, ppSpan)
#define FREE_SPANS(pStpCtx, cSpans) \
    ((PrimProcessor *)pStpCtx->PrimProcessor)->FreeSpans(cSpans)

// Compute texture difference times 1/W.
#define PERSP_TEXTURE_DELTA(fTb, fRb, fTa, fTRa, iWrap)                       \
    ((TextureDiff((fTb), (fTa), (iWrap)) + (fTa)) * (fRb) - (fTRa))

// Extract components from a packed color.
#define SPLIT_COLOR(uPacked, uB, uG, uR, uA)                                  \
    ((uB) = (UINT)RGBA_GETBLUE(uPacked),                                      \
     (uG) = (UINT)RGBA_GETGREEN(uPacked),                                     \
     (uR) = (UINT)RGBA_GETRED(uPacked),                                       \
     (uA) = (UINT)RGBA_GETALPHA(uPacked))

// Compute FP deltas from the difference of the given packed color
// and the given components.
#define COLOR_DELTA(uPacked, uB, uG, uR, uA, fDB, fDG, fDR, fDA)              \
    ((fDB) = (FLOAT)((INT)((UINT)RGBA_GETBLUE(uPacked)-(uB)) << COLOR_SHIFT), \
     (fDG) = (FLOAT)((INT)((UINT)RGBA_GETGREEN(uPacked)-(uG)) << COLOR_SHIFT),\
     (fDR) = (FLOAT)((INT)((UINT)RGBA_GETRED(uPacked)-(uR)) << COLOR_SHIFT),  \
     (fDA) = (FLOAT)((INT)((UINT)RGBA_GETALPHA(uPacked)-(uA)) << COLOR_SHIFT))

// Extract components from a packed index color.
// Applies a .5F offset to the color index to effect rounding
// when the color index is truncated.
#define SPLIT_IDX_COLOR(uPacked, iIdx, iA)                                    \
    ((iIdx) = (INT32)CI_MASKALPHA(uPacked) + (1<<(INDEX_COLOR_VERTEX_SHIFT-1)),                                   \
     (iA) = (INT32)CI_GETALPHA(uPacked))

#define IDX_COLOR_DELTA(uPacked, iIdx, iA, fDIdx, fDA)                        \
    ((fDIdx) = (FLOAT)((((INT32)CI_MASKALPHA(uPacked) +                       \
                    (1<<(INDEX_COLOR_VERTEX_SHIFT-1))) - (iIdx)) <<           \
                       INDEX_COLOR_FIXED_SHIFT),                              \
     (fDA) = (FLOAT)(((INT32)CI_GETALPHA(uPacked) - (iA)) <<                  \
                     INDEX_COLOR_SHIFT))

#endif // #ifndef _SETUP_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mlspan\sources.inc ===
TARGETNAME = rmlspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\cmlrast.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxemul\sources.inc ===
TARGETNAME = mmxemul
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\mmxemul.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\inc\stp_base.h ===
//----------------------------------------------------------------------------
//
// stp_base.h
//
// Basic types shared between C++ and assembly.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _STP_BASE_H_
#define _STP_BASE_H_

// Generic set of attribute values.  Used for holding current values
// and deltas.
typedef struct tagATTRSET
{
    union
    {
        struct
        {
            PUINT8 pSurface, pZ;
        };
        struct
        {
            INT32 ipSurface, ipZ;
        };
    };

    union
    {
        FLOAT fZ;
        INT32 iZ;
        UINT32 uZ;
    };
    union
    {
        FLOAT fOoW;
        INT32 iOoW;
    };

    union
    {
        struct
        {
            FLOAT fUoW[D3DHAL_TSS_MAXSTAGES], fVoW[D3DHAL_TSS_MAXSTAGES];
        };
        struct
        {
            INT32 iUoW[D3DHAL_TSS_MAXSTAGES], iVoW[D3DHAL_TSS_MAXSTAGES];
        };
    };


    union
    {
        struct
        {
            FLOAT fB, fG, fR, fA;
        };
        struct
        {
            INT32 iB, iG, iR, iA;
        };
        struct
        {
            UINT32 uB, uG, uR, uA;
        };
        struct
        {
            FLOAT fDIdx, fDIdxA;
        };
        struct
        {
            INT32 iDIdx, iDIdxA;
        };
        struct
        {
            UINT32 uDIdx, uDIdxA;
        };
    };

    union
    {
        struct
        {
            FLOAT fBS, fGS, fRS;
        };
        struct
        {
            INT32 iBS, iGS, iRS;
        };
        struct
        {
            UINT32 uBS, uGS, uRS;
        };
    };
    union
    {
        FLOAT fFog;
        INT32 iFog;
        UINT32 uFog;
    };
} ATTRSET, *PATTRSET;

// Parameters for doing int/carry arithmetic on a value.
typedef struct tagINTCARRYVAL
{
    INT iV;
    INT iFrac;
    INT iDFrac;
    INT iCY, iNC;
} INTCARRYVAL, *PINTCARRYVAL;

// Attribute handlers.
typedef struct tagSETUPCTX *PSETUPCTX;

typedef void (FASTCALL *PFN_ADDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta, PSETUPCTX pStpCtx);
typedef void (FASTCALL *PFN_ADDSCALEDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta,
     PSETUPCTX pStpCtx, int iScale);
typedef void (FASTCALL *PFN_FILLSPANATTRS)
    (PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
     PSETUPCTX pStpCtx, INT cPix);

extern PFN_ADDATTRS g_pfnAddFloatAttrsTable[];
extern PFN_ADDATTRS g_pfnRampAddFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnRampFillSpanFloatAttrsTable[];
#ifdef STEP_FIXED
extern PFN_ADDATTRS g_pfnAddFixedAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[];
#endif
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[];
extern PFN_ADDSCALEDATTRS g_pfnRampAddScaledFloatAttrsTable[];

// Triangle trapezoid walkers.
typedef HRESULT (FASTCALL *PFN_WALKTRAPSPANS)
    (UINT uSpans, PINTCARRYVAL pXOther,
     PSETUPCTX pStpCtx, BOOL bAdvanceLast);

extern PFN_WALKTRAPSPANS g_pfnWalkTrapFloatSpansNoClipTable[];
extern PFN_WALKTRAPSPANS g_pfnRampWalkTrapFloatSpansNoClipTable[];
#ifdef STEP_FIXED
extern PFN_WALKTRAPSPANS g_pfnWalkTrapFixedSpansNoClipTable[];
#endif

// Float-to-fixed attribute converters.
typedef void (FASTCALL *PFN_FLOATATTRSTOFIXED)
    (PATTRSET pfAttrs, PATTRSET piAttrs, PSETUPCTX pStpCtx);

#ifdef STEP_FIXED
extern PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[];
#endif

typedef void (FASTCALL *PFN_SETUPTRIATTR)
    (PSETUPCTX pStpCtx, LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
     LPD3DTLVERTEX pV2);

//
// Setup flags.
//

// Per primitive set.
#define PRIMSF_DIFF_USED                0x00000001
#define PRIMSF_SPEC_USED                0x00000002
#define PRIMSF_TEX1_USED                0x00000004
#define PRIMSF_TEX2_USED                0x00000008
#define PRIMSF_DIDX_USED                0x00000010
#define PRIMSF_LOCAL_FOG_USED           0x00000020
#define PRIMSF_GLOBAL_FOG_USED          0x00000040
#define PRIMSF_Z_USED                   0x00000080
#define PRIMSF_LOD_USED                 0x00000100
#define PRIMSF_PERSP_USED               0x00000200
#define PRIMSF_FLAT_SHADED              0x00000400

#define PRIMSF_COLORS_USED              (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED)
#define PRIMSF_TEX_USED                 (PRIMSF_TEX1_USED | PRIMSF_TEX2_USED)
#define PRIMSF_ALL_USED \
    (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED | \
     PRIMSF_TEX2_USED | PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_LOCAL_FOG_USED | PRIMSF_GLOBAL_FOG_USED | PRIMSF_PERSP_USED | \
     PRIMSF_DIDX_USED)

#define PRIMSF_SLOW_USED \
    (PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_LOCAL_FOG_USED | PRIMSF_GLOBAL_FOG_USED | PRIMSF_TEX2_USED)

#define PRIMSF_ALL \
    (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED | \
     PRIMSF_TEX2_USED | PRIMSF_DIDX_USED  | PRIMSF_LOCAL_FOG_USED |\
     PRIMSF_GLOBAL_FOG_USED | PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_PERSP_USED | PRIMSF_FLAT_SHADED)

// Per primitive.
#define PRIMF_FIXED_OVERFLOW            0x00001000
#define PRIMF_TRIVIAL_ACCEPT_Y          0x00002000
#define PRIMF_TRIVIAL_ACCEPT_X          0x00004000

#define PRIMF_ALL \
    (PRIMF_TRIVIAL_ACCEPT_Y | PRIMF_TRIVIAL_ACCEPT_X | PRIMF_FIXED_OVERFLOW)

// No point flags right now.
#define PTF_ALL 0

// Per line.
#define LNF_X_MAJOR                     0x00008000

#define LNF_ALL \
    (LNF_X_MAJOR)

// Per triangle.
#define TRIF_X_DEC                      0x00008000
#define TRIF_RASTPRIM_OVERFLOW          0x00010000

#define TRIF_ALL \
    (TRIF_X_DEC | TRIF_RASTPRIM_OVERFLOW)

// PWL support flags.
#define PWL_NEXT_LOD                    0x00000001

#ifdef PWL_FOG
#define PWL_NEXT_FOG                    0x00000002
// Suppress computation of next fog for lines.
// No equivalent flag for LOD since lines don't support LOD.
#define PWL_NO_NEXT_FOG                 0x00000004
#endif

// Setup information shared between C++ and assembly.
typedef struct tagSETUPCTX
{
    // Overall rasterization context.
    PD3DI_RASTCTX pCtx;

    // Current PrimProcessor for span allocator calls.
    PVOID PrimProcessor;

    // Current primitive.
    PD3DI_RASTPRIM pPrim;

    // Per-primitive flags.
    UINT uFlags;

    // Flat shading vertex pointer.
    LPD3DTLVERTEX pFlatVtx;

    // Maximum span length allowed.
    INT cMaxSpan;

    //
    // Piecewise-linear support for LOD and global fog.
    //
    UINT uPwlFlags;

    // LOD.
    FLOAT fNextW;
    FLOAT fNextOoW;
    FLOAT fNextUoW1, fNextVoW1;
    INT iNextLOD;

    // Local fog X delta.  Fog deltas are always sent through RASTSPAN
    // instead of RASTPRIM to make the local and global cases the same.
    // For the local fog case where the delta doesn't change convert
    // it once and keep it here.
    INT iDLocalFogDX;
#ifdef PWL_FOG
    // Global fog.
    FLOAT fNextZ;
    UINT uNextFog;
#endif

    // Attribute handling functions.
    PFN_ADDATTRS pfnAddAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrs;
    PFN_FILLSPANATTRS pfnFillSpanAttrs;

    // Edge walking function.
    PFN_WALKTRAPSPANS pfnWalkTrapSpans;

    // Triangle attribute setup beads.
    PFN_SETUPTRIATTR pfnTriSetupFirstAttr;
    PFN_SETUPTRIATTR pfnTriSetupZEnd;
    PFN_SETUPTRIATTR pfnTriSetupTexEnd;
    PFN_SETUPTRIATTR pfnTriSetupDiffEnd;
    PFN_SETUPTRIATTR pfnTriSetupSpecEnd;
    PFN_SETUPTRIATTR pfnTriSetupFogEnd;

    // Current X and Y values.
    INT iX, iY;

    union
    {
        // Edge fraction and delta for lines.
        struct
        {
            INT iLineFrac, iDLineFrac;
        };

        // Edge X walkers for triangles.
        struct
        {
            INTCARRYVAL X20, X10, X21;
        };
    };

    // Floating-point versions of X20 NC and CY values for setup.
    FLOAT fX20NC, fX20CY;

    // Long edge attribute values.
    ATTRSET Attr;

    union
    {
        // Attribute major axis deltas for lines.
        ATTRSET DAttrDMajor;

        // Attribute X deltas for triangles.
        ATTRSET DAttrDX;
    };

    // Attribute Y deltas.
    ATTRSET DAttrDY;

    // Span-to-span deltas when attribute edge carries a pixel.
    INT iDXCY, iDYCY;
    ATTRSET DAttrCY;

    // Span-to-span deltas when attribute edge doesn't carry a pixel.
    INT iDXNC, iDYNC;
    ATTRSET DAttrNC;

    union
    {
        // One over length for lines.
        FLOAT fOoLen;

        // One over determinant for triangles.
        FLOAT fOoDet;
    };

    // Edge deltas.
    FLOAT fDX10, fDY10;
    FLOAT fDX20, fDY20;

    // Normalized edge deltas.
    FLOAT fNX10, fNY10;
    FLOAT fNX20, fNY20;

    // Subpixel correction amounts.
    union
    {
        // Lines.
        FLOAT fDMajor;

        // Triangles.
        struct
        {
            FLOAT fDX, fDY;
        };
    };

    // Pixel length of line.
    INT cLinePix;
} SETUPCTX;

#endif // #ifndef _STP_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\spanpars.h ===
//----------------------------------------------------------------------------
//
// spanpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

#ifdef __cplusplus
  extern "C" {
#endif


HRESULT MMX_RenderSpansAny(PD3DI_RASTCTX pCtx);

#ifdef __cplusplus
  }
#endif


#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\spanutil.cpp ===
//----------------------------------------------------------------------------
//
// spanutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\spanutil.h ===
//----------------------------------------------------------------------------
//
// spanutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\iammx.inc ===
;/*
;*    INTEL CORPORATION PROPRIETARY INFORMATION 
;*
;*    This software is supplied under the terms of a license
;*    agreement or nondisclosure agreement with Intel Corporation 
;*    and may not be copied or disclosed except in accordance with 
;*    the terms of that agreement.
;*    Copyright (c) 1991,1992,1993  Intel Corporation. 
;*
;*/
;NOTE:NOTE:NOTE:
; IF YOU MODIFY ANY OF THE OPCODES HERE, MAKE SURE TO REFLECT THAT
; IN THE ValidMmxOpcode[] array in mm.c. 
;
;Please use MMWORD and not DWORD (QWORD does not work) for 64 bit data 
; in MMX instructions. After getting a real assembler you will just have to
; add the line " MMWORD	TEXTEQU	<QWORD>" to your code.
MMWORD	TEXTEQU	<DWORD>
opc_Rdpmc     = 033H
opc_Emms      = 077H
opc_Movd_ld   = 06EH
opc_Movd_st   = 07EH
opc_Movq_ld   = 06FH
opc_Movq_st   = 07FH
opc_Packssdw  = 06BH
opc_Packsswb  = 063H
opc_Packuswb  = 067H
opc_Paddb     = 0FCH
opc_Paddd     = 0FEH
opc_Paddsb    = 0ECH
opc_Paddsw    = 0EDH
opc_Paddusb   = 0DCH
opc_Paddusw   = 0DDH
opc_Paddw     = 0FDH
opc_Pand      = 0DBH
opc_Pandn     = 0DFH
opc_Pcmpeqb   = 074H
opc_Pcmpeqd   = 076H
opc_Pcmpeqw   = 075H
opc_Pcmpgtb   = 064H
opc_Pcmpgtd   = 066H
opc_Pcmpgtw   = 065H
opc_Pmaddwd   = 0F5H
opc_Pmulhw    = 0E5H
opc_Pmullw    = 0D5H
opc_Por       = 0EBH
opc_PSHimd    = 072H
opc_PSHimq    = 073H
opc_PSHimw    = 071H
opc_Pslld     = 0F2H
opc_Psllq     = 0F3H
opc_Psllw     = 0F1H
opc_Psrad     = 0E2H
opc_Psraw     = 0E1H
opc_Psrld     = 0D2H
opc_Psrlq     = 0D3H
opc_Psrlw     = 0D1H
opc_Psubb     = 0F8H
opc_Psubd     = 0FAH
opc_Psubsb    = 0E8H
opc_Psubsw    = 0E9H
opc_Psubusb   = 0D8H
opc_Psubusw   = 0D9H
opc_Psubw     = 0F9H
opc_Punpcklbw = 060H
opc_Punpckldq = 062H
opc_Punpcklwd = 061H
opc_Punpckhbw = 068H
opc_Punpckhdq = 06AH
opc_Punpckhwd = 069H
opc_Pxor      = 0EFH

.486P

; ALIAS R# to MM# registers

DefineMMxRegs Macro
IFDEF APP_16BIT
	MM0	TEXTEQU	<AX>
	MM1	TEXTEQU	<CX>
	MM2	TEXTEQU	<DX>
	MM3	TEXTEQU	<BX>
	MM4	TEXTEQU	<SP>
	MM5	TEXTEQU	<BP>
	MM6	TEXTEQU	<SI>
	MM7	TEXTEQU	<DI>

	mm0	TEXTEQU	<AX>
	mm1	TEXTEQU	<CX>
	mm2	TEXTEQU	<DX>
	mm3	TEXTEQU	<BX>
	mm4	TEXTEQU	<SP>
	mm5	TEXTEQU	<BP>
	mm6	TEXTEQU	<SI>
	mm7	TEXTEQU	<DI>

	Mm0	TEXTEQU	<AX>
	Mm1	TEXTEQU	<CX>
	Mm2	TEXTEQU	<DX>
	Mm3	TEXTEQU	<BX>
	Mm4	TEXTEQU	<SP>
	Mm5	TEXTEQU	<BP>
	Mm6	TEXTEQU	<SI>
	Mm7	TEXTEQU	<DI>

	mM0	TEXTEQU	<AX>
	mM1	TEXTEQU	<CX>
	mM2	TEXTEQU	<DX>
	mM3	TEXTEQU	<BX>
	mM4	TEXTEQU	<SP>
	mM5	TEXTEQU	<BP>
	mM6	TEXTEQU	<SI>
	mM7	TEXTEQU	<DI>

ELSE
	MM0	TEXTEQU	<EAX>
	MM1	TEXTEQU	<ECX>
	MM2	TEXTEQU	<EDX>
	MM3	TEXTEQU	<EBX>
	MM4	TEXTEQU	<ESP>
	MM5	TEXTEQU	<EBP>
	MM6	TEXTEQU	<ESI>
	MM7	TEXTEQU	<EDI>

	mm0	TEXTEQU	<EAX>
	mm1	TEXTEQU	<ECX>
	mm2	TEXTEQU	<EDX>
	mm3	TEXTEQU	<EBX>
	mm4	TEXTEQU	<ESP>
	mm5	TEXTEQU	<EBP>
	mm6	TEXTEQU	<ESI>
	mm7	TEXTEQU	<EDI>

	Mm0	TEXTEQU	<EAX>
	Mm1	TEXTEQU	<ECX>
	Mm2	TEXTEQU	<EDX>
	Mm3	TEXTEQU	<EBX>
	Mm4	TEXTEQU	<ESP>
	Mm5	TEXTEQU	<EBP>
	Mm6	TEXTEQU	<ESI>
	Mm7	TEXTEQU	<EDI>

	mM0	TEXTEQU	<EAX>
	mM1	TEXTEQU	<ECX>
	mM2	TEXTEQU	<EDX>
	mM3	TEXTEQU	<EBX>
	mM4	TEXTEQU	<ESP>
	mM5	TEXTEQU	<EBP>
	mM6	TEXTEQU	<ESI>
	mM7	TEXTEQU	<EDI>
ENDIF
EndM

; ALIAS R# to MM# registers
DefineMMxNUM Macro
	MM0	TEXTEQU	<0>
	MM1	TEXTEQU	<0>
	MM2	TEXTEQU	<0>
	MM3	TEXTEQU	<0>
	MM4	TEXTEQU	<0>
	MM5	TEXTEQU	<0>
	MM6	TEXTEQU	<0>
	MM7	TEXTEQU	<0>

	mm0	TEXTEQU	<0>
	mm1	TEXTEQU	<0>
	mm2	TEXTEQU	<0>
	mm3	TEXTEQU	<0>
	mm4	TEXTEQU	<0>
	mm5	TEXTEQU	<0>
	mm6	TEXTEQU	<0>
	mm7	TEXTEQU	<0>

	Mm0	TEXTEQU	<0>
	Mm1	TEXTEQU	<0>
	Mm2	TEXTEQU	<0>
	Mm3	TEXTEQU	<0>
	Mm4	TEXTEQU	<0>
	Mm5	TEXTEQU	<0>
	Mm6	TEXTEQU	<0>
	Mm7	TEXTEQU	<0>

	mM0	TEXTEQU	<0>
	mM1	TEXTEQU	<0>
	mM2	TEXTEQU	<0>
	mM3	TEXTEQU	<0>
	mM4	TEXTEQU	<0>
	mM5	TEXTEQU	<0>
	mM6	TEXTEQU	<0>
	mM7	TEXTEQU	<0>
EndM



UnDefineMMxRegs Macro
	MM0	TEXTEQU	<MM0>
	MM1	TEXTEQU	<MM1>
	MM2	TEXTEQU	<MM2>
	MM3	TEXTEQU	<MM3>
	MM4	TEXTEQU	<MM4>
	MM5	TEXTEQU	<MM5>
	MM6	TEXTEQU	<MM6>
	MM7	TEXTEQU	<MM7>

	mm0	TEXTEQU	<mm0>
	mm1	TEXTEQU	<mm1>
	mm2	TEXTEQU	<mm2>
	mm3	TEXTEQU	<mm3>
	mm4	TEXTEQU	<mm4>
	mm5	TEXTEQU	<mm5>
	mm6	TEXTEQU	<mm6>
	mm7	TEXTEQU	<mm7>

	Mm0	TEXTEQU	<Mm0>
	Mm1	TEXTEQU	<Mm1>
	Mm2	TEXTEQU	<Mm2>
	Mm3	TEXTEQU	<Mm3>
	Mm4	TEXTEQU	<Mm4>
	Mm5	TEXTEQU	<Mm5>
	Mm6	TEXTEQU	<Mm6>
	Mm7	TEXTEQU	<Mm7>

	mM0	TEXTEQU	<mM0>
	mM1	TEXTEQU	<mM1>
	mM2	TEXTEQU	<mM2>
	mM3	TEXTEQU	<mM3>
	mM4	TEXTEQU	<mM4>
	mM5	TEXTEQU	<mM5>
	mM6	TEXTEQU	<mM6>
	mM7	TEXTEQU	<mM7>
EndM


rdpmc     macro
	db	0fh, opc_Rdpmc
endm

emms     macro
	db	0fh, opc_Emms
endm



movd   macro   dst:req, src:req
        local   x, y

		DefineMMxNUM

IF (OPATTR(dst)) AND 00010000y ; register
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
		UnDefineMMxRegs
ELSE
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
ENDIF
		UnDefineMMxRegs
ENDIF
        endm

movdt    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
		UnDefineMMxRegs
        endm

movdf   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st
        org     y
		UnDefineMMxRegs
        endm

movq   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movq_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movq_st 
        org     y
ENDIF
		UnDefineMMxRegs
        endm


packssdw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packssdw
        org     y
		UnDefineMMxRegs
        endm

packsswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packsswb
        org     y
		UnDefineMMxRegs
        endm

packuswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packuswb
        org     y
		UnDefineMMxRegs
        endm

paddd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddd   
        org     y
		UnDefineMMxRegs
        endm

paddsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsb  
        org     y
		UnDefineMMxRegs
        endm

paddsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsw  
        org     y
		UnDefineMMxRegs
        endm

paddusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusb 
        org     y
		UnDefineMMxRegs
        endm

paddusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusw 
        org     y
		UnDefineMMxRegs
        endm

paddb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddb   
        org     y
		UnDefineMMxRegs
        endm

paddw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddw   
        org     y
		UnDefineMMxRegs
        endm

pand    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pand    
        org     y
		UnDefineMMxRegs
        endm

pandn    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pandn   
        org     y
		UnDefineMMxRegs
        endm

pcmpeqb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqb 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqd 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqw 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtb 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtd 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtw 
        org     y
		UnDefineMMxRegs
        endm

pmaddwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmaddwd 
        org     y
		UnDefineMMxRegs
        endm

pmulhw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmulhw  
        org     y
		UnDefineMMxRegs
        endm

pmullw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmullw  
        org     y
		UnDefineMMxRegs
        endm

por    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Por     
        org     y
		UnDefineMMxRegs
        endm


pslld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pslld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psllw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrad    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrad   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psraw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psraw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrlq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psllq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psrlw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psubsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsb  
        org     y
		UnDefineMMxRegs
        endm

psubsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsw  
        org     y
		UnDefineMMxRegs
        endm

psubusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusb 
        org     y
		UnDefineMMxRegs
        endm

psubusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusw 
        org     y
		UnDefineMMxRegs
        endm

psubb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubb   
        org     y
		UnDefineMMxRegs
        endm

psubw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubw   
        org     y
		UnDefineMMxRegs
        endm

punpcklbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklbw
        org     y
		UnDefineMMxRegs
        endm

punpckhdq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhdq
        org     y
		UnDefineMMxRegs
        endm

punpcklwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklwd
        org     y
		UnDefineMMxRegs
        endm

punpckhbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhbw
        org     y
		UnDefineMMxRegs
        endm

punpckldq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckldq
        org     y
		UnDefineMMxRegs
        endm

punpckhwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhwd
        org     y
		UnDefineMMxRegs
        endm

pxor    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pxor    
        org     y
		UnDefineMMxRegs
        endm

psubd   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubd   
        org     y
		UnDefineMMxRegs
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\makefile.inc ===
$(GENTGT)\clrbd_mh.h: ..\clrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\clrgn_mh.h: ..\clrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\test_mh.h: ..\test_mh.mh $(RAST_STD_M4)

$(GENTGT)\texa_mh.h: ..\texa_mh.mh ..\texaddra.mh $(RAST_STD_M4)

$(GENTGT)\texbd_mh.h: ..\texbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\texrd_mh.h: ..\texrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\tstf_mh.h: ..\tstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\atest_mh.h: ..\atest_mh.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): ..\offs_acp.acp \
        ..\..\..\inc\span.h ..\..\inc\stp_base.h ..\..\..\..\ref\inc\refrast.hpp

$(GENTGT)\beadtbl.cpp: ..\beadtbl.mcp $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\atest.asm: ..\atest.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\bldfuncs.asm: ..\bldfuncs.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\bufread.asm: ..\bufread.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\bufwrite.asm: ..\bufwrite.mas ..\bufwrite.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\colorbld.asm: ..\colorbld.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\colorgen.asm: ..\colorgen.mas ..\colorgen.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\test.asm: ..\test.mas ..\test.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\texaddr.asm: ..\texaddr.mas ..\cvars.mh ..\texaddra.mh $(RAST_STD_M4)

$(GENTGT)\texblend.asm: ..\texblend.mas ..\texblend.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\texread.asm: ..\texread.mas ..\texread.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\tstfail.asm: ..\tstfail.mas ..\tstfail.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\spanpars.asm: ..\spanpars.mas ..\cvars.mh $(RAST_STD_M4)

$(GENGT)\ml1.asm: ..\ml1.mas $(RAST_STD_M4)
$(GENGT)\ml2.asm: ..\ml2.mas $(RAST_STD_M4)
$(GENGT)\ml3.asm: ..\ml3.mas $(RAST_STD_M4)
$(GENGT)\ml4.asm: ..\ml4.mas $(RAST_STD_M4)
$(GENGT)\ml5.asm: ..\ml5.mas $(RAST_STD_M4)
$(GENGT)\ml6.asm: ..\ml6.mas $(RAST_STD_M4)
$(GENGT)\ml7.asm: ..\ml7.mas $(RAST_STD_M4)
$(GENGT)\ml8.asm: ..\ml8.mas $(RAST_STD_M4)
$(GENGT)\ml9.asm: ..\ml9.mas $(RAST_STD_M4)
$(GENGT)\ml10.asm: ..\ml10.mas $(RAST_STD_M4)
$(GENGT)\ml11.asm: ..\ml11.mas $(RAST_STD_M4)
$(GENGT)\ml12.asm: ..\ml12.mas $(RAST_STD_M4)
$(GENGT)\ml13.asm: ..\ml13.mas $(RAST_STD_M4)
$(GENGT)\ml14.asm: ..\ml14.mas $(RAST_STD_M4)
$(GENGT)\ml15.asm: ..\ml15.mas $(RAST_STD_M4)
$(GENGT)\ml16.asm: ..\ml16.mas $(RAST_STD_M4)
$(GENGT)\ml17.asm: ..\ml17.mas $(RAST_STD_M4)
$(GENGT)\ml18.asm: ..\ml18.mas $(RAST_STD_M4)
$(GENGT)\ml19.asm: ..\ml19.mas $(RAST_STD_M4)
$(GENGT)\ml20.asm: ..\ml20.mas $(RAST_STD_M4)
$(GENGT)\ml21.asm: ..\ml21.mas $(RAST_STD_M4)
$(GENGT)\ml22.asm: ..\ml22.mas $(RAST_STD_M4)
$(GENGT)\ml23.asm: ..\ml23.mas $(RAST_STD_M4)
$(GENGT)\ml24.asm: ..\ml24.mas $(RAST_STD_M4)
$(GENGT)\ml25.asm: ..\ml25.mas $(RAST_STD_M4)
$(GENGT)\ml26.asm: ..\ml26.mas $(RAST_STD_M4)
$(GENGT)\ml27.asm: ..\ml27.mas $(RAST_STD_M4)
$(GENGT)\ml28.asm: ..\ml28.mas $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\nommxsrc.inc ===
NTTARGETFILE0 = $(NTTARGETFILE0) \
        $O\clrbd_mh.h\
        $O\clrgn_mh.h\
        $O\test_mh.h\
        $O\texa_mh.h\
        $O\texbd_mh.h\
        $O\texrd_mh.h\
        $O\atest_mh.h\
        $O\tstf_mh.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\cppsrc.inc ===
O_FILES = $O\attrscpp.cpp $O\tstpcpp.cpp
$(TARGET_DIRECTORY)_SOURCES = $(O_FILES) ..\walkcpp.cpp
NTTARGETFILE0 = $(NTTARGETFILE0) $(O_FILES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\i386src.inc ===
i386_SOURCES = \
        $O\atest.asm\
        $O\bldfuncs.asm\
        $O\bufread.asm\
        $O\bufwrite.asm\
        $O\colorbld.asm\
        $O\colorgen.asm\
        $O\spanpars.asm\
        ..\spanutil.cpp\
        $O\test.asm\
        $O\texaddr.asm\
        $O\texblend.asm\
        $O\texread.asm\
        $O\tstfail.asm\
        $O\ml1.asm\
        $O\ml2.asm\
        $O\ml3.asm\
        $O\ml4.asm\
        $O\ml5.asm\
        $O\ml6.asm\
        $O\ml7.asm\
        $O\ml8.asm\
        $O\ml9.asm\
        $O\ml10.asm\
        $O\ml11.asm\
        $O\ml12.asm\
        $O\ml13.asm\
        $O\ml14.asm\
        $O\ml15.asm\
        $O\ml16.asm\
        $O\ml17.asm\
        $O\ml18.asm\
        $O\ml19.asm\
        $O\ml20.asm\
        $O\ml21.asm\
        $O\ml22.asm\
        $O\ml23.asm\
        $O\ml24.asm\
        $O\ml25.asm\
        $O\ml26.asm\
        $O\ml27.asm\
        $O\ml28.asm

NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES) \
        $O\clrbd_mh.h\
        $O\clrgn_mh.h\
        $O\test_mh.h\
        $O\texa_mh.h\
        $O\texbd_mh.h\
        $O\texrd_mh.h\
        $O\tstf_mh.h\
        $O\atest_mh.h\
        $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\line.cpp ===
//----------------------------------------------------------------------------
//
// line.cpp
//
// Line processing.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// LinePatternStateMachine
//
// Runs the line pattern state machine and returns TRUE if the pixel is to be
// drawn, false otherwise.
//
//----------------------------------------------------------------------------

static inline BOOL LinePatternStateMachine(WORD wRepeatFactor, WORD wLinePattern, WORD& wRepeati, WORD& wPatterni)
{
    if (wRepeatFactor == 0)
    {
        return TRUE;
    }
    WORD wBit = (wLinePattern >> wPatterni) & 1;
    if (++wRepeati >= wRepeatFactor)
    {
        wRepeati = 0;
        wPatterni = (wPatterni+1) & 0xf;
    }
    return (BOOL)wBit;
}

#define CLAMP_COLOR(fVal, uVal) \
    if (FLOAT_LTZ(fVal))        \
    {                           \
        uVal = 0;               \
    }                           \
    else                        \
    {                           \
        if (uVal > 0xffff)      \
        {                       \
            uVal = 0xffff;      \
        }                       \
    }                           \

#define CLAMP_Z(fVal, uVal)     \
    if (FLOAT_LTZ(fVal))        \
    {                           \
        uVal = 0;               \
    }                           \

//----------------------------------------------------------------------------
//
// ClampPixel
//
// Clamp color, specular and z(if any) of a pixel. Right now, it's done for 
// first and last pixel of a line only.
//
//----------------------------------------------------------------------------
inline void
ClampPixel(PATTRSET pAttrs, PD3DI_RASTSPAN pSpan)
{
    CLAMP_COLOR(pAttrs->fB, pSpan->uB);
    CLAMP_COLOR(pAttrs->fG, pSpan->uG);
    CLAMP_COLOR(pAttrs->fR, pSpan->uR);
    CLAMP_COLOR(pAttrs->fA, pSpan->uA);
    CLAMP_COLOR(pAttrs->fBS, pSpan->uBS);
    CLAMP_COLOR(pAttrs->fGS, pSpan->uGS);
    CLAMP_COLOR(pAttrs->fRS, pSpan->uRS);
    CLAMP_Z(pAttrs->fZ, pSpan->uZ);
}

//----------------------------------------------------------------------------
//
// WalkLinePattern
//
// Walks a line and generates the pixels touched according to the pattern.
// If wRepeatFactor >= 1, we are patterning, otherwise, we are not
//
//----------------------------------------------------------------------------

HRESULT
WalkLinePattern(PSETUPCTX pStpCtx, WORD wRepeatFactor, WORD wLinePattern)
{
    HRESULT hr;
    UINT uSpansAvail;
    PD3DI_RASTSPAN pSpan;
    WORD wRepeati = 0;
    WORD wPatterni = 0;
    BOOL bFirst = TRUE;

    RSASSERT(pStpCtx->cLinePix > 0);

    hr = D3D_OK;
    uSpansAvail = 0;

    RSASSERT((pStpCtx->uFlags & PRIMSF_LOD_USED) == 0);
#ifdef PWL_FOG
    pStpCtx->uPwlFlags = PWL_NO_NEXT_FOG;
#endif

    for (;;)
    {
        if (pStpCtx->iX >= pStpCtx->pCtx->Clip.left &&
            pStpCtx->iX < pStpCtx->pCtx->Clip.right &&
            pStpCtx->iY >= pStpCtx->pCtx->Clip.top &&
            pStpCtx->iY < pStpCtx->pCtx->Clip.bottom)
        {
            if (LinePatternStateMachine(wRepeatFactor, wLinePattern, wRepeati, wPatterni))
            {
                if (uSpansAvail == 0)
                {
                    uSpansAvail = pStpCtx->cLinePix;
                    hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                    if (hr != D3D_OK)
                    {
                        // uSpansAvail is set to zero on failure.
                        goto EH_Exit;
                    }
                }
                else
                {
                    pSpan++;
                }
                uSpansAvail--;
                pStpCtx->pPrim->uSpans++;

                pSpan->uPix = 1;
                pSpan->uX = (UINT16)pStpCtx->iX;
                pSpan->uY = (UINT16)pStpCtx->iY;

                pStpCtx->pfnFillSpanAttrs(&pStpCtx->Attr, pSpan, pStpCtx, 1);
                // Clamp first/last pixel
                if (bFirst || pStpCtx->cLinePix == 1)
                {
                    bFirst = FALSE;
                    ClampPixel(&pStpCtx->Attr, pSpan);
                }
            }
        }

        if (--pStpCtx->cLinePix == 0)
        {
            break;
        }

#ifdef VERBOSE_LINES
        RSDPF(("  %4d,%4d: %10d %11d => ",
               pStpCtx->iX, pStpCtx->iY,
               pStpCtx->iLineFrac, pStpCtx->iLineFrac + pStpCtx->iDLineFrac));
#endif

        pStpCtx->iLineFrac += pStpCtx->iDLineFrac;
        if (pStpCtx->iLineFrac < 0)
        {
            pStpCtx->iLineFrac &= 0x7fffffff;

            pStpCtx->iX += pStpCtx->iDXCY;
            pStpCtx->iY += pStpCtx->iDYCY;

            pStpCtx->DAttrDMajor.ipSurface = pStpCtx->DAttrCY.ipSurface;
            pStpCtx->DAttrDMajor.ipZ = pStpCtx->DAttrCY.ipZ;
        }
        else
        {
            pStpCtx->iX += pStpCtx->iDXNC;
            pStpCtx->iY += pStpCtx->iDYNC;

            pStpCtx->DAttrDMajor.ipSurface = pStpCtx->DAttrNC.ipSurface;
            pStpCtx->DAttrDMajor.ipZ = pStpCtx->DAttrNC.ipZ;
        }

#ifdef VERBOSE_LINES
        RSDPFM((DBG_MASK_FORCE | DBG_MASK_NO_PREFIX, "%4d,%4d: %10d\n",
               pStpCtx->iX, pStpCtx->iY,
               pStpCtx->iLineFrac));
#endif

        pStpCtx->pfnAddAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDMajor, pStpCtx);
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Line
//
// Provides a line for processing.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Line(LPD3DTLVERTEX pV0,
                    LPD3DTLVERTEX pV1,
                    LPD3DTLVERTEX pFlatVtx)
{
    HRESULT hr;

    hr = D3D_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != D3D_OK)
    {
        return hr;
    }
    hr = ValidateVertex(pV1);
    if (hr != D3D_OK)
    {
        return hr;
    }
#endif

    // Clear per-line flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | LNF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X\n",
            m_uPpFlags, m_StpCtx.uFlags));

    RSDPFM((RSM_LINES, "Line\n"));
    RSDPFM((RSM_LINES, "  V0 (%f,%f,%f)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ));
    RSDPFM((RSM_LINES, "  V1 (%f,%f,%f)\n",
            pV1->dvSX, pV1->dvSY, pV1->dvSZ));

    // Remember flat color controlling vertex for setup.
    m_StpCtx.pFlatVtx = pFlatVtx;

    if (LineSetup(pV0, pV1))
    {
        // Compute initial buffer pointers for the scanline.
        m_StpCtx.Attr.pSurface = m_StpCtx.pCtx->pSurfaceBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;
        if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            m_StpCtx.Attr.pZ = m_StpCtx.pCtx->pZBits +
                m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
                m_StpCtx.iY * m_StpCtx.pCtx->iZStride;
        }

        // Line walking only generates single-pixel spans so
        // the prim deltas are unused.  Therefore, line spans
        // are simply added to whatever primitive happens to
        // be sitting in the buffer.

        hr = AppendPrim();
        if (hr != D3D_OK)
        {
            return hr;
        }

        union
        {
            D3DLINEPATTERN LPat;
            DWORD dwLPat;
        } LinePat;
        LinePat.dwLPat = m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_LINEPATTERN];
        hr = WalkLinePattern(&m_StpCtx, LinePat.LPat.wRepeatFactor, LinePat.LPat.wLinePattern);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\i386src.inc ===
i386_SOURCES = $O\attrsx86.asm $O\tstpx86.asm $O\walkx86.asm
NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES) \
        $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\makefile.inc ===
$(GENTGT)\attrs_mh.h: ..\attrs_mh.mh $(RAST_STD_M4)

$(GENTGT)\tstp_mh.h: ..\tstp_mh.mh $(RAST_STD_M4)

$(GENTGT)\walk_mh.h: ..\walk_mh.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): ..\offs_acp.acp \
        ..\..\..\inc\span.h ..\..\inc\stp_base.h

$(GENTGT)\attrsx86.asm: ..\attrsx86.mas ..\attrsx86.mh $(RAST_STD_M4)

$(GENTGT)\attrscpp.cpp: ..\attrscpp.mcp $(RAST_STD_M4)

$(GENTGT)\tstpx86.asm: ..\tstpx86.mas $(RAST_STD_M4)

$(GENTGT)\tstpcpp.cpp: ..\tstpcpp.mcp $(RAST_STD_M4)

$(GENTGT)\walkx86.asm: ..\walkx86.mas ..\attrsx86.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\stp_base.h ===
//----------------------------------------------------------------------------
//
// stp_base.h
//
// Basic types shared between C++ and assembly.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _STP_BASE_H_
#define _STP_BASE_H_

// Generic set of attribute values.  Used for holding current values
// and deltas.
// ATTENTION - It may be better to use RASTSPAN.  RASTSPAN has some extra
// space that'd go unused but then it'd be possible to memcpy ATTRSETs
// to RASTSPANs during fixed-point edge walking.
typedef struct tagATTRSET
{
    union
    {
        FLOAT fZ;
        INT32 iZ;
        UINT32 uZ;
    };
    union
    {
        FLOAT fOoW;
        INT32 iOoW;
    };
    union
    {
        struct
        {
            FLOAT fUoW[D3DHAL_TSS_MAXSTAGES], fVoW[D3DHAL_TSS_MAXSTAGES];
        };
        struct
        {
            INT32 iUoW[D3DHAL_TSS_MAXSTAGES], iVoW[D3DHAL_TSS_MAXSTAGES];
        };
    };
    union
    {
        struct
        {
            FLOAT fB, fG, fR, fA;
        };
        struct
        {
            INT32 iB, iG, iR, iA;
        };
        struct
        {
            UINT32 uB, uG, uR, uA;
        };
    };
    union
    {
        struct
        {
            FLOAT fBS, fGS, fRS, fFog;
        };
        struct
        {
            INT32 iBS, iGS, iRS, iFog;
        };
        struct
        {
            UINT32 uBS, uGS, uRS, uFog;
        };
    };
    union
    {
        struct
        {  
            PUINT8 pSurface, pZ;
        };
        struct
        {  
            INT32 ipSurface, ipZ;
        };
    };
} ATTRSET, *PATTRSET;

// Parameters for doing int/carry arithmetic on a value.
typedef struct tagINTCARRYVAL
{
    INT iV;
    INT iFrac;
    INT iDFrac;
    INT iCY, iNC;
} INTCARRYVAL, *PINTCARRYVAL;

// Attribute handlers.
typedef void (FASTCALL *PFN_ADDATTRS)(PATTRSET pAttrs, PATTRSET pDelta);
typedef void (FASTCALL *PFN_ADDSCALEDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta, int iScale, FLOAT fNextOoW);
typedef void (FASTCALL *PFN_FILLSPANATTRS)
    (PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
     struct tagSETUPCTX *pStpCtx, INT cPix);

extern PFN_ADDATTRS g_pfnAddFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[];
#ifdef STEP_FIXED
extern PFN_ADDATTRS g_pfnAddFixedAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[];
#endif
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[];
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsPwlTable[];

// Edge walkers.
typedef HRESULT (FASTCALL *PFN_WALKSPANS)
    (UINT uSpans, PINTCARRYVAL pXOther,
     struct tagSETUPCTX *pStpCtx, BOOL bAdvanceLast);

extern PFN_WALKSPANS g_pfnWalkFloatSpansClipTable[];
extern PFN_WALKSPANS g_pfnWalkFloatSpansNoClipTable[];
#ifdef STEP_FIXED
extern PFN_WALKSPANS g_pfnWalkFixedSpansNoClipTable[];
#endif

// Float-to-fixed attribute converters.
typedef void (FASTCALL *PFN_FLOATATTRSTOFIXED)
    (PATTRSET pfAttrs, PATTRSET piAttrs);

#ifdef STEP_FIXED
extern PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[];
#endif

// Setup flags.
#define TRIP_DIFF_USED                  0x00000001
#define TRIP_SPEC_USED                  0x00000002
#define TRIP_TEX1_USED                  0x00000004
#define TRIP_TEX2_USED                  0x00000008
#define TRIP_Z_USED                     0x00000010
#define TRIP_LOD_USED                   0x00000020
#define TRIP_FOG_USED                   0x00000040
#define TRIP_TRIVIAL_ACCEPT_Y           0x00000080
#define TRIP_TRIVIAL_ACCEPT_X           0x00000100
#define TRIP_X_DEC                      0x00000200
#define TRIP_RASTPRIM_OVERFLOW          0x00000400
#define TRIP_FIXED_OVERFLOW             0x00000800
#define TRIP_IN_BEGIN                   0x00001000

#define TRIP_COLORS_USED                (TRIP_DIFF_USED | TRIP_SPEC_USED)
#define TRIP_TEX_USED                   (TRIP_TEX1_USED | TRIP_TEX2_USED)

// These flags are set and reset per-triangle, while the other flags are
// set per triangle set.
#define TRIP_PER_TRIANGLE_FLAGS \
    (TRIP_TRIVIAL_ACCEPT_Y | TRIP_TRIVIAL_ACCEPT_X | TRIP_X_DEC | \
     TRIP_RASTPRIM_OVERFLOW | TRIP_FIXED_OVERFLOW)
#define TRIP_PER_TRIANGLE_SET_FLAGS \
    (TRIP_DIFF_USED | TRIP_SPEC_USED | TRIP_TEX1_USED | TRIP_TEX2_USED | \
     TRIP_Z_USED | TRIP_LOD_USED | TRIP_FOG_USED)
    
// Setup information shared between C++ and assembly.
typedef struct tagSETUPCTX
{
    // Overall rasterization context.
    PD3DI_RASTCTX pCtx;

    // Current TriProcessor for span allocator calls.
    PVOID TriProcessor;
    
    // Current primitive.
    PD3DI_RASTPRIM pPrim;
    
    // Per-triangle flags.
    UINT uFlags;

    // Maximum span length allowed.
    INT cMaxSpan;
    
    // Piecewise-linear support for LOD.
    BOOL bNextValid;
    FLOAT fNextW;
    FLOAT fNextOoW;
    INT iNextLOD;

    // Attribute handling functions.
    PFN_ADDATTRS pfnAddAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrsPwl;
    PFN_FILLSPANATTRS pfnFillSpanAttrs;

    // Edge walking function.
    PFN_WALKSPANS pfnWalkSpans;
    
    // Current Y value.
    INT iY;
    
    // Edge X walkers.
    INTCARRYVAL X20, X10, X21;
    
    // Floating-point versions of X20 NC and CY values for setup.
    FLOAT fX20NC, fX20CY;
    
    // Long edge attribute values.
    ATTRSET Attr;
    
    // Attribute X deltas.
    ATTRSET DAttrDX;
    
    // Attribute Y deltas.
    ATTRSET DAttrDY;
    
    // Attribute span-to-span deltas when X carries a pixel.
    ATTRSET DAttrCY;

    // Attribute span-to-span deltas when X doesn't carry a pixel.
    ATTRSET DAttrNC;

    // One over determinant.
    FLOAT fOoDet;
    
    // Edge deltas.
    FLOAT fDX10, fDY10;
    FLOAT fDX20, fDY20;
    
    // Normalized edge deltas.
    FLOAT fNX10, fNY10;
    FLOAT fNX20, fNY20;
    
    // Subpixel correction amounts.
    FLOAT fDX, fDY;
} SETUPCTX, *PSETUPCTX;

#endif // #ifndef _STP_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\mmxspan\sources.inc ===
TARGETNAME = rmmxspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        $O\beadtbl.cpp

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

NTTARGETFILE0 = \
        $O\beadtbl.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\rsdbg.cpp ===
//----------------------------------------------------------------------------
//
// rsdbg.cpp
//
// Setup debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

static DebugModuleFlags g_RastSetupOutputFlags[] =
{
    DBG_DECLARE_MODFLAG(RSM, TRIS),
    DBG_DECLARE_MODFLAG(RSM, LINES),
    DBG_DECLARE_MODFLAG(RSM, POINTS),
    DBG_DECLARE_MODFLAG(RSM, Z),
    DBG_DECLARE_MODFLAG(RSM, DIFF),
    DBG_DECLARE_MODFLAG(RSM, SPEC),
    DBG_DECLARE_MODFLAG(RSM, OOW),
    DBG_DECLARE_MODFLAG(RSM, LOD),
    DBG_DECLARE_MODFLAG(RSM, TEX1),
    DBG_DECLARE_MODFLAG(RSM, TEX2),
    DBG_DECLARE_MODFLAG(RSM, XCLIP),
    DBG_DECLARE_MODFLAG(RSM, YCLIP),
    DBG_DECLARE_MODFLAG(RSM, BUFFER),
    DBG_DECLARE_MODFLAG(RSM, BUFPRIM),
    DBG_DECLARE_MODFLAG(RSM, BUFSPAN),
    DBG_DECLARE_MODFLAG(RSM, FLAGS),
    DBG_DECLARE_MODFLAG(RSM, WALK),
    DBG_DECLARE_MODFLAG(RSM, DIDX),
    0, NULL,
};
static DebugModuleFlags g_RastSetupUserFlags[] =
{
    DBG_DECLARE_MODFLAG(RSU, BREAK_ON_RENDER_SPANS),
    DBG_DECLARE_MODFLAG(RSU, MARK_SPAN_EDGES),
    DBG_DECLARE_MODFLAG(RSU, CHECK_SPAN_EDGES),
    DBG_DECLARE_MODFLAG(RSU, NO_RENDER_SPANS),
    DBG_DECLARE_MODFLAG(RSU, FORCE_GENERAL_WALK),
    DBG_DECLARE_MODFLAG(RSU, FORCE_PIXEL_SPANS),
    0, NULL,
};
DBG_DECLARE_ONCE(RastSetup, RS,
                 g_RastSetupOutputFlags, 0,
                 g_RastSetupUserFlags, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\rsdbg.hpp ===
//----------------------------------------------------------------------------
//
// rsdbg.hpp
//
// Setup debug definitions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RSDBG_HPP_
#define _RSDBG_HPP_

#include <cppdbg.hpp>

DBG_DECLARE_HEADER(RS);

#define RSDPF(Args)             DBG_DECLARE_DPF(RS, Args)
#define RSDPFM(Args)            DBG_DECLARE_DPFM(RS, Args)
#define RSASSERT(Exp)           DBG_DECLARE_ASSERT(RS, Exp)
#define RSASSERTMSG(Exp, Args)  DBG_DECLARE_ASSERTMSG(RS, Exp, Args)
#define RSVERIFY(Exp)           DBG_DECLARE_VERIFY(RS, Exp)
#define RSVERIFYMSG(Exp)        DBG_DECLARE_VERIFYMSG(RS, Exp, Args)
#define RSPROMPT(Args)          DBG_DECLARE_PROMPT(RS, Args)
#define RSGETFLAGS(Idx)         DBG_DECLARE_GETFLAGS(RS, Idx)
#define RSSETFLAGS(Idx, Value)  DBG_DECLARE_SETFLAGS(RS, Idx, Value)
#define RSHRCHK(Exp)            DBG_DECLARE_HRCHK(RS, Exp)
#define RSHRGO(Exp, Label)      DBG_DECLARE_HRGO(RS, Exp, Label)
#define RSHRERR(Exp)            DBG_DECLARE_HRERR(RS, Exp)
#define RSHRRET(Exp)            DBG_DECLARE_HRRET(RS, Exp)

#define RSM_TRIS                0x00000001
#define RSM_LINES               0x00000002
#define RSM_POINTS              0x00000004
#define RSM_Z                   0x00000008
#define RSM_DIFF                0x00000010
#define RSM_SPEC                0x00000020
#define RSM_OOW                 0x00000040
#define RSM_LOD                 0x00000080
#define RSM_TEX1                0x00000100
#define RSM_TEX2                0x00000200
#define RSM_FOG                 0x00000400
#define RSM_XCLIP               0x00000800
#define RSM_YCLIP               0x00001000
#define RSM_BUFFER              0x00002000
#define RSM_BUFPRIM             0x00004000
#define RSM_BUFSPAN             0x00008000
#define RSM_FLAGS               0x00010000
#define RSM_WALK                0x00020000
#define RSM_DIDX                0x00040000

#define RSU_BREAK_ON_RENDER_SPANS       0x00000001
#define RSU_MARK_SPAN_EDGES             0x00000002
#define RSU_CHECK_SPAN_EDGES            0x00000004
#define RSU_NO_RENDER_SPANS             0x00000008
#define RSU_FORCE_GENERAL_WALK          0x00000010
#define RSU_FORCE_PIXEL_SPANS           0x00000020
#define RSU_FLUSH_AFTER_PRIM            0x00000040

#endif // #ifndef _RSDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\attrs.cpp ===
//----------------------------------------------------------------------------
//
// attrs.cpp
//
// Cross-platform attribute handling functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// AddFloatAttrs_Any
//
// Adds a set of attribute deltas to an ATTRSET.
// Handles any set of attributes via USED flags.
//
//----------------------------------------------------------------------------

void FASTCALL
AddFloatAttrs_Any(PATTRSET pAttr, PATTRSET pDelta, PSETUPCTX pStpCtx)
{
    pAttr->pSurface += pDelta->ipSurface;
    pAttr->pZ += pDelta->ipZ;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        pAttr->fZ += pDelta->fZ;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        pAttr->fOoW += pDelta->fOoW;
    
        pAttr->fUoW[0] += pDelta->fUoW[0];
        pAttr->fVoW[0] += pDelta->fVoW[0];
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            pAttr->fUoW[i] += pDelta->fUoW[i];
            pAttr->fVoW[i] += pDelta->fVoW[i];
        }
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pAttr->fB += pDelta->fB;
        pAttr->fG += pDelta->fG;
        pAttr->fR += pDelta->fR;
        pAttr->fA += pDelta->fA;
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pAttr->fDIdx += pDelta->fDIdx;
        pAttr->fDIdxA += pDelta->fDIdxA;
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pAttr->fBS += pDelta->fBS;
        pAttr->fGS += pDelta->fGS;
        pAttr->fRS += pDelta->fRS;
    }
    
    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pAttr->fFog += pDelta->fFog;
    }
}

//----------------------------------------------------------------------------
//
// AddScaledFloatAttrs_Any_Either
//
// Scales and adds a set of attribute deltas to an ATTRSET.
// Handles any set of attributes via USED flags.
// Uses PWL support.
//
//----------------------------------------------------------------------------

void FASTCALL
AddScaledFloatAttrs_Any_Either(PATTRSET pAttr, PATTRSET pDelta,
                               PSETUPCTX pStpCtx, INT iScale)
{
    FLOAT fScale = (FLOAT)iScale;

    pAttr->pSurface += pDelta->ipSurface * iScale;
    pAttr->pZ += pDelta->ipZ * iScale;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
#ifdef PWL_FOG
        if (pStpCtx->uPwlFlags & PWL_NEXT_FOG)
        {
            pAttr->fZ = pStpCtx->fNextZ;
        }
        else
#endif
        {
            pAttr->fZ += pDelta->fZ * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
        {
            pAttr->fOoW = pStpCtx->fNextOoW;
            pAttr->fUoW[0] = pStpCtx->fNextUoW1;
            pAttr->fVoW[0] = pStpCtx->fNextVoW1;
        }
        else
        {
            pAttr->fOoW += pDelta->fOoW * fScale;
            pAttr->fUoW[0] += pDelta->fUoW[0] * fScale;
            pAttr->fVoW[0] += pDelta->fVoW[0] * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            pAttr->fUoW[i] += pDelta->fUoW[i] * fScale;
            pAttr->fVoW[i] += pDelta->fVoW[i] * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pAttr->fB += pDelta->fB * fScale;
        pAttr->fG += pDelta->fG * fScale;
        pAttr->fR += pDelta->fR * fScale;
        pAttr->fA += pDelta->fA * fScale;
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pAttr->fDIdx += pDelta->fDIdx * fScale;
        pAttr->fDIdxA += pDelta->fDIdxA * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pAttr->fBS += pDelta->fBS * fScale;
        pAttr->fGS += pDelta->fGS * fScale;
        pAttr->fRS += pDelta->fRS * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pAttr->fFog += pDelta->fFog * fScale;
    }
}

//----------------------------------------------------------------------------
//
// FillSpanFloatAttrs_Any_Either
//
// Fills in a span structure with the given attributes.
// Handles any set of attributes via USED flags.
// Uses and updates PWL support.
//
//----------------------------------------------------------------------------

void FASTCALL
FillSpanFloatAttrs_Any_Either(PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
                              PSETUPCTX pStpCtx, INT cPix)
{
    FLOAT fPix = (FLOAT)cPix;
    pSpan->pSurface = pAttr->pSurface;
    pSpan->pZ = pAttr->pZ;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        pSpan->uZ = FTOI(pAttr->fZ);
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fW;
    
        if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
        {
            fW = pStpCtx->fNextW;
        }
        else if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            if (FLOAT_EQZ(pAttr->fOoW))
            {
                fW = g_fZero;
            }
            else
            {
                fW = OOW_SCALE / pAttr->fOoW;
            }
        }
        else
        {
            fW = g_fOne;
        }
        
        pSpan->iW = FTOI(fW * W_SCALE);

        if (pStpCtx->uFlags & PRIMSF_LOD_USED)
        {
            // Mipmapping is enabled so compute texture LOD.
            // The span code can do linear LOD interpolation
            // so that we can do piecewise-linear approximations
            // instead of true per-pixel LOD.  In order to make this
            // work we need to compute the next LOD and a delta
            // value.  All of these values can be reused if this
            // loop goes around so keep them available for the next
            // iteration and set a flag to indicate that they've
            // been computed.

            if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
            {
                pSpan->iLOD = (INT16)pStpCtx->iNextLOD;
            }
            else
            {
                pSpan->iLOD =
                    (INT16)ComputeLOD(pStpCtx->pCtx,
                               (pAttr->fUoW[0] * OO_TEX_SCALE) * fW,
                               (pAttr->fVoW[0] * OO_TEX_SCALE) * fW,
                               fW,
                               (pStpCtx->DAttrDX.fUoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDX.fVoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDX.fOoW * OO_OOW_SCALE),
                               (pStpCtx->DAttrDY.fUoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDY.fVoW[0] * OO_TEX_SCALE),
                               (pStpCtx->DAttrDY.fOoW * OO_OOW_SCALE));
            }
        
            if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
            {
                pStpCtx->fNextOoW = pAttr->fOoW + pStpCtx->DAttrDX.fOoW * fPix;
            
                if (FLOAT_EQZ(pStpCtx->fNextOoW))
                {
                    fW = g_fZero;
                }
                else
                {
                    fW = OOW_SCALE / pStpCtx->fNextOoW;
                }
            }
            else
            {
                pStpCtx->fNextOoW = OOW_SCALE;
                fW = g_fOne;
            }
                
            pStpCtx->fNextW = fW;
            pStpCtx->fNextUoW1 = pAttr->fUoW[0] + pStpCtx->DAttrDX.fUoW[0] * fPix;
            pStpCtx->fNextVoW1 = pAttr->fVoW[0] + pStpCtx->DAttrDX.fVoW[0] * fPix;
            pStpCtx->iNextLOD =
                ComputeLOD(pStpCtx->pCtx,
                           (pStpCtx->fNextUoW1 * OO_TEX_SCALE) * fW,
                           (pStpCtx->fNextVoW1 * OO_TEX_SCALE) * fW,
                           fW,
                           (pStpCtx->DAttrDX.fUoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDX.fVoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDX.fOoW * OO_OOW_SCALE),
                           (pStpCtx->DAttrDY.fUoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDY.fVoW[0] * OO_TEX_SCALE),
                           (pStpCtx->DAttrDY.fOoW * OO_OOW_SCALE));
            pStpCtx->uPwlFlags |= PWL_NEXT_LOD;
                
            pSpan->iDLOD =
                (INT16)(FTOI((FLOAT)(pStpCtx->iNextLOD - pSpan->iLOD) / fPix));
        }
        else
        {
            pSpan->iLOD = 0;
            pSpan->iDLOD = 0;
        }
            
        pSpan->iOoW = FTOI(pAttr->fOoW);
    
        pSpan->UVoW[0].iUoW = FTOI(pAttr->fUoW[0]);
        pSpan->UVoW[0].iVoW = FTOI(pAttr->fVoW[0]);
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            pSpan->UVoW[i].iUoW = FTOI(pAttr->fUoW[i]);
            pSpan->UVoW[i].iVoW = FTOI(pAttr->fVoW[i]);
        }
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pSpan->uB = (UINT16)(FTOI(pAttr->fB));
        pSpan->uG = (UINT16)(FTOI(pAttr->fG));
        pSpan->uR = (UINT16)(FTOI(pAttr->fR));
        pSpan->uA = (UINT16)(FTOI(pAttr->fA));
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pSpan->iIdx = FTOI(pAttr->fDIdx);
        pSpan->iIdxA = FTOI(pAttr->fDIdxA);
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pSpan->uBS = (UINT16)(FTOI(pAttr->fBS));
        pSpan->uGS = (UINT16)(FTOI(pAttr->fGS));
        pSpan->uRS = (UINT16)(FTOI(pAttr->fRS));
    }
    
    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pSpan->uFog = (UINT16)(FTOI(pAttr->fFog));
        pSpan->iDFog = (INT16)(pStpCtx->iDLocalFogDX);
    }
#ifdef PWL_FOG
    else if (pStpCtx->uFlags & PRIMSF_GLOBAL_FOG_USED)
    {
        FLOAT fOoZScale;
        
        // The span code doesn't have direct global fog support.
        // It's faked by setup doing PWL approximations here
        // similarly to how LOD is handled.
        
        if (pStpCtx->pCtx->iZBitCount == 16)
        {
            fOoZScale = OO_Z16_SCALE;
        }
        else
        {
            fOoZScale = OO_Z32_SCALE;
        }
        
        if (pStpCtx->uPwlFlags & PWL_NEXT_FOG)
        {
            pSpan->uFog = pStpCtx->uNextFog;
        }
        else
        {
            pSpan->uFog = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                          pAttr->fZ * fOoZScale);
        }

        if ((pStpCtx->uPwlFlags & PWL_NO_NEXT_FOG) == 0)
        {
            pStpCtx->fNextZ = pAttr->fZ + pStpCtx->DAttrDX.fZ * fPix;
            pStpCtx->uNextFog = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                                pStpCtx->fNextZ * fOoZScale);
            pStpCtx->uPwlFlags |= PWL_NEXT_FOG;
                
            pSpan->iDFog =
                FTOI((FLOAT)((INT)pStpCtx->uNextFog -
                             (INT)pSpan->uFog) / fPix);
        }
        else
        {
            pSpan->iDFog = 0;
        }
    }
#endif
}

//
// Tables of attribute handlers.
// Indexing is with the low four PRIMSF_*_USED bits.
//

// Attribute adders.
PFN_ADDATTRS g_pfnAddFloatAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -2 -1 -S -D */
    AddFloatAttrs_Z_Diff,                               /* 1: -2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 2: -2 -1 +S -D */
    AddFloatAttrs_Z_Diff_Spec,                          /* 3: -2 -1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 4: -2 +1 -S -D */
    AddFloatAttrs_Z_Diff_Tex,                          /* 5: -2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 6: -2 +1 +S -D */
    AddFloatAttrs_Z_Diff_Spec_Tex,                     /* 7: -2 +1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 8: +2 -1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 9: +2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* A: +2 -1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* B: +2 -1 +S +D */
    AddFloatAttrs_Z_Tex,                          /* C: +2 +1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* D: +2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* E: +2 +1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_ADDATTRS g_pfnAddFixedAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -2 -1 -S -D */
    AddFixedAttrs_Z_Diff,                               /* 1: -2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 2: -2 -1 +S -D */
    AddFixedAttrs_Z_Diff_Spec,                          /* 3: -2 -1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 4: -2 +1 -S -D */
    AddFixedAttrs_Z_Diff_Tex,                          /* 5: -2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 6: -2 +1 +S -D */
    AddFixedAttrs_Z_Diff_Spec_Tex,                     /* 7: -2 +1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 8: +2 -1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 9: +2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* A: +2 -1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* B: +2 -1 +S +D */
    AddFixedAttrs_Z_Tex,                          /* C: +2 +1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* D: +2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* E: +2 +1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* F: +2 +1 +S +D */
};
#endif

// Scaled attribute adders without PWL support.
PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[] =
{
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 0: -2 -1 -S -D */
    AddScaledFloatAttrs_Z_Diff,                         /* 1: -2 -1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 2: -2 -1 +S -D */
    AddScaledFloatAttrs_Z_Diff_Spec,                    /* 3: -2 -1 +S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 4: -2 +1 -S -D */
    AddScaledFloatAttrs_Z_Diff_Tex,                    /* 5: -2 +1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 6: -2 +1 +S -D */
    AddScaledFloatAttrs_Z_Diff_Spec_Tex,               /* 7: -2 +1 +S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 8: +2 -1 -S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 9: +2 -1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* A: +2 -1 +S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* B: +2 -1 +S +D */
    AddScaledFloatAttrs_Z_Tex,                    /* C: +2 +1 -S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* D: +2 +1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* E: +2 +1 +S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* F: +2 +1 +S +D */
};

// RASTSPAN filling functions.
PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    FillSpanFloatAttrs_Z_Diff,                          /* 1: -2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    FillSpanFloatAttrs_Z_Diff_Spec,                     /* 3: -2 -1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    FillSpanFloatAttrs_Z_Diff_Tex,                     /* 5: -2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    FillSpanFloatAttrs_Z_Diff_Spec_Tex,                /* 7: -2 +1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    FillSpanFloatAttrs_Z_Tex,                     /* C: +2 +1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    FillSpanFixedAttrs_Z_Diff,                          /* 1: -2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    FillSpanFixedAttrs_Z_Diff_Spec,                     /* 3: -2 -1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    FillSpanFixedAttrs_Z_Diff_Tex,                     /* 5: -2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    FillSpanFixedAttrs_Z_Diff_Spec_Tex,                /* 7: -2 +1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    FillSpanFixedAttrs_Z_Tex,                     /* C: +2 +1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#endif

// Float-to-fixed attribute converters.
#ifdef STEP_FIXED
PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[] =
{
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 0: -2 -1 -S -D */
    FloatAttrsToFixed_Z_Diff,                           /* 1: -2 -1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 2: -2 -1 +S -D */
    FloatAttrsToFixed_Z_Diff_Spec,                      /* 3: -2 -1 +S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 4: -2 +1 -S -D */
    FloatAttrsToFixed_Z_Diff_Tex,                      /* 5: -2 +1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 6: -2 +1 +S -D */
    FloatAttrsToFixed_Z_Diff_Spec_Tex,                 /* 7: -2 +1 +S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 8: +2 -1 -S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 9: +2 -1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* A: +2 -1 +S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* B: +2 -1 +S +D */
    FloatAttrsToFixed_Z_Tex,                      /* C: +2 +1 -S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* D: +2 +1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* E: +2 +1 +S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* F: +2 +1 +S +D */
};
#endif

//
// Tables of ramp mode attribute handlers.
// Indexing is with PRIMSF_TEX1_USED and PRIMSF_DIDX_USED.
//

// Attribute adders.
PFN_ADDATTRS g_pfnRampAddFloatAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -I -1 */
    AddFloatAttrs_Z_Tex,                               /* 1: -I +1 */
    AddFloatAttrs_Z_DIdx,                               /* 2: +I -1 */
    AddFloatAttrs_Z_DIdx_Tex,                          /* 3: +I +1 */
};

// Scaled attribute adders without PWL support.
PFN_ADDSCALEDATTRS g_pfnRampAddScaledFloatAttrsTable[] =
{
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 0: -I -1 */
    AddScaledFloatAttrs_Z_Tex,                         /* 1: -I +1 */
    AddScaledFloatAttrs_Z_DIdx,                         /* 2: +I -1 */
    AddScaledFloatAttrs_Z_DIdx_Tex,                    /* 3: +I +1 */
};

// RASTSPAN filling functions.
PFN_FILLSPANATTRS g_pfnRampFillSpanFloatAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -I -1 */
    FillSpanFloatAttrs_Z_Tex,                          /* 1: -I +1 */
    FillSpanFloatAttrs_Z_DIdx,                          /* 2: +I -1 */
    FillSpanFloatAttrs_Z_DIdx_Tex,                     /* 3: +I +1 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//   
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>

#include <d3dp.h>
#include <d3dhal.h>

#include <rast.h>
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\buffer.cpp ===
//----------------------------------------------------------------------------
//
// buffer.cpp
//
// PrimProcessor buffering methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

// Define to use new/delete instead of VirtualAlloc/VirtualFree.
#if 0
#define USE_CPP_HEAP
#endif

// Define to show FP exceptions.
#if 0
#define UNMASK_EXCEPTIONS
#endif

//----------------------------------------------------------------------------
//
// PrimProcessor::PrimProcessor
//
// Initializes a triangle processor to an invalid state.
//
//----------------------------------------------------------------------------

PrimProcessor::PrimProcessor(void)
{
    // Zero everything to NULL initial pointers and eliminate FP garbage.
    memset(this, 0, sizeof(PrimProcessor));

    m_StpCtx.PrimProcessor = (PVOID)this;

    // Initialize to values that will force a validation.
    // ATTENTION - Default to normalizing RHW.  This is a performance hit
    // and should be removed if possible.
    m_uPpFlags = PPF_STATE_CHANGED | PPF_NORMALIZE_RHW;
    m_PrimType = D3DPT_FORCE_DWORD;
    m_VertType = RAST_FORCE_DWORD;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Initialize
//
// Initializes the triangle processor to an active state.
//
//----------------------------------------------------------------------------

#define CACHE_LINE 32
#define BUFFER_SIZE 4096
// Uncomment to force a flush every span for debug purposes
//#define BUFFER_SIZE ((8 * sizeof(D3DI_RASTSPAN)) + sizeof(D3DI_RASTPRIM))

HRESULT
PrimProcessor::Initialize(void)
{
    HRESULT hr;

    INT32 uSize = sizeof(D3DI_RASTPRIM);

    // Assert that both RASTPRIM and RASTSPAN are multiples of the cache
    // line size so that everything in the buffer stays cache aligned.
    RSASSERT((uSize & (CACHE_LINE - 1)) == 0);

#ifdef USE_CPP_HEAP
    m_pBuffer = new UINT8[BUFFER_SIZE];
#else
    // Get a page-aligned buffer.
    m_pBuffer = (PUINT8)
        VirtualAlloc(NULL, BUFFER_SIZE,
                     MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
#endif
    if (m_pBuffer == NULL)
    {
        return RSHRCHK(E_OUTOFMEMORY);
    }

    m_pBufferEnd = m_pBuffer+BUFFER_SIZE;

#ifdef USE_CPP_HEAP
    // Compute cache-line aligned start in the buffer.  Formulated
    // somewhat oddly to avoid casting a complete pointer to a DWORD and
    // back.
    m_pBufferStart = m_pBuffer +
        ((CACHE_LINE - ((UINT)m_pBuffer & (CACHE_LINE - 1))) &
         (CACHE_LINE - 1));
#else
    // Page aligned memory should be cache aligned.
    RSASSERT(((UINT_PTR)m_pBuffer & (CACHE_LINE - 1)) == 0);
    m_pBufferStart = m_pBuffer;
#endif

    m_pCur = m_pBufferStart;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::~PrimProcessor
//
//----------------------------------------------------------------------------

PrimProcessor::~PrimProcessor(void)
{
#ifdef USE_CPP_HEAP
    delete m_pBuffer;
#else
    if (m_pBuffer != NULL)
    {
        VirtualFree(m_pBuffer, 0, MEM_RELEASE);
    }
#endif
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ResetBuffer
//
// Initialize buffer pointers to an empty state.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::ResetBuffer(void)
{
    m_pCur = m_pBufferStart;
    m_StpCtx.pPrim = NULL;
    m_pOldPrim = NULL;
}

//----------------------------------------------------------------------------
//
// DumpPrims
//
// Debugging function to dump primitives sent to the span renderer.
//
//----------------------------------------------------------------------------

#if DBG
void
DumpPrims(PSETUPCTX pStpCtx)
{
    PD3DI_RASTPRIM pPrim;
    UINT uOldFlags;

    uOldFlags = RSGETFLAGS(DBG_OUTPUT_FLAGS);
    RSSETFLAGS(DBG_OUTPUT_FLAGS, uOldFlags | DBG_OUTPUT_ALL_MATCH);

    for (pPrim = pStpCtx->pCtx->pPrim; pPrim != NULL; pPrim = pPrim->pNext)
    {
        RSDPFM((RSM_BUFPRIM, "Prim at %p, %d spans at %p\n",
                pPrim, pPrim->uSpans, pPrim+1));
        RSDPFM((RSM_BUFPRIM | RSM_OOW, "  DOoWDX %X (%f)\n",
                pPrim->iDOoWDX, (FLOAT)pPrim->iDOoWDX / OOW_SCALE));

        if ((RSGETFLAGS(DBG_OUTPUT_MASK) & RSM_BUFSPAN) ||
            (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                           RSU_CHECK_SPAN_EDGES)))
        {
            PD3DI_RASTSPAN pSpan;
            UINT16 i;

            pSpan = (PD3DI_RASTSPAN)(pPrim+1);
            for (i = 0; i < pPrim->uSpans; i++)
            {
                RSDPFM((RSM_BUFSPAN,
                        "  Span at (%d,%d), pix %c%d, S %p Z %p\n",
                        pSpan->uX, pSpan->uY,
                        (pPrim->uFlags & D3DI_RASTPRIM_X_DEC) ? '-' : '+',
                        pSpan->uPix, pSpan->pSurface, pSpan->pZ));

                if (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                                  RSU_CHECK_SPAN_EDGES))
                {
                    PUINT16 pPix;

                    pPix = (PUINT16)pSpan->pSurface;
                    if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_CHECK_SPAN_EDGES)
                    {
                        if (*pPix != 0)
                        {
                            RSDPF(("  Overwrite at %p: %X\n", pPix, *pPix));
                        }
                    }
                    if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_MARK_SPAN_EDGES)
                    {
                        *pPix = 0xffff;
                    }

                    if (pSpan->uPix > 1)
                    {
                        if (pPrim->uFlags & D3DI_RASTPRIM_X_DEC)
                        {
                            pPix = (PUINT16)pSpan->pSurface -
                                (pSpan->uPix - 1);
                        }
                        else
                        {
                            pPix = (PUINT16)pSpan->pSurface +
                                (pSpan->uPix - 1);
                        }

                        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_CHECK_SPAN_EDGES)
                        {
                            if (*pPix != 0)
                            {
                                RSDPF(("  Overwrite at %p: %X\n",
                                       pPix, *pPix));
                            }
                        }
                        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_MARK_SPAN_EDGES)
                        {
                            *pPix = 0xffff;
                        }
                    }
                }

                FLOAT fZScale;
                if (pStpCtx->pCtx->iZBitCount == 16)
                {
                    fZScale = Z16_SCALE;
                }
                else
                {
                    fZScale = Z32_SCALE;
                }
                RSDPFM((RSM_BUFSPAN | RSM_Z,
                        "    Z %X (%f)\n",
                        pSpan->uZ, (FLOAT)pSpan->uZ / fZScale));

                RSDPFM((RSM_BUFSPAN | RSM_DIFF,
                        "    D %X,%X,%X,%X (%f,%f,%f,%f)\n",
                        pSpan->uB, pSpan->uG, pSpan->uR, pSpan->uA,
                        (FLOAT)pSpan->uB / COLOR_SCALE,
                        (FLOAT)pSpan->uG / COLOR_SCALE,
                        (FLOAT)pSpan->uR / COLOR_SCALE,
                        (FLOAT)pSpan->uA / COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_SPEC,
                        "    S %X,%X,%X (%f,%f,%f)\n",
                        pSpan->uBS, pSpan->uGS, pSpan->uRS,
                        (FLOAT)pSpan->uBS / COLOR_SCALE,
                        (FLOAT)pSpan->uGS / COLOR_SCALE,
                        (FLOAT)pSpan->uRS / COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_DIDX,
                        "    I %X,%X (%f,%f)\n",
                        pSpan->iIdx, pSpan->iIdxA,
                        (FLOAT)pSpan->iIdx / INDEX_COLOR_SCALE,
                        (FLOAT)pSpan->iIdxA / INDEX_COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_OOW,
                        "    OoW %X (%f), W %X (%f)\n",
                        pSpan->iOoW, (FLOAT)pSpan->iOoW / OOW_SCALE,
                        pSpan->iW, (FLOAT)pSpan->iW / W_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_LOD,
                        "    LOD %X (%f), DLOD %X (%f)\n",
                        pSpan->iLOD, (FLOAT)pSpan->iLOD / LOD_SCALE,
                        pSpan->iDLOD, (FLOAT)pSpan->iDLOD / LOD_SCALE));

                if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
                {
                    RSDPFM((RSM_BUFSPAN | RSM_TEX1,
                            "    PTex1 %X,%X (%f,%f) (%f,%f)\n",
                            pSpan->UVoW[0].iUoW, pSpan->UVoW[0].iVoW,
                            (FLOAT)pSpan->UVoW[0].iUoW / TEX_SCALE,
                            (FLOAT)pSpan->UVoW[0].iVoW / TEX_SCALE,
                            ((FLOAT)pSpan->UVoW[0].iUoW * OOW_SCALE) /
                            (TEX_SCALE * (FLOAT)pSpan->iOoW),
                            ((FLOAT)pSpan->UVoW[0].iVoW * OOW_SCALE) /
                            (TEX_SCALE * (FLOAT)pSpan->iOoW)));
                }
                else
                {
                    RSDPFM((RSM_BUFSPAN | RSM_TEX1,
                            "    ATex1 %X,%X (%f,%f)\n",
                            pSpan->UVoW[0].iUoW, pSpan->UVoW[0].iVoW,
                            (FLOAT)pSpan->UVoW[0].iUoW / TEX_SCALE,
                            (FLOAT)pSpan->UVoW[0].iVoW / TEX_SCALE));
                }

                RSDPFM((RSM_BUFSPAN | RSM_FOG,
                        "    Fog %X (%f), DFog %X (%f)\n",
                        pSpan->uFog, (FLOAT)pSpan->uFog / FOG_SCALE,
                        pSpan->iDFog, (FLOAT)pSpan->iDFog / FOG_SCALE));

                pSpan++;
            }
        }
    }

    RSSETFLAGS(DBG_OUTPUT_FLAGS, uOldFlags);
}
#endif // DBG

//----------------------------------------------------------------------------
//
// PrimProcessor::Flush
//
// Flushes any remaining data from the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Flush(void)
{
    HRESULT hr;

    if (m_pCur - m_pBufferStart > sizeof(D3DI_RASTPRIM))
    {
        // Process data.
        m_StpCtx.pCtx->pPrim = (PD3DI_RASTPRIM)m_pBufferStart;
        m_StpCtx.pCtx->pNext = NULL;

#if DBG
        if ((RSGETFLAGS(DBG_OUTPUT_MASK) & (RSM_BUFPRIM | RSM_BUFSPAN)) ||
            (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                           RSU_CHECK_SPAN_EDGES)))
        {
            DumpPrims(&m_StpCtx);
        }

        if ((RSGETFLAGS(DBG_USER_FLAGS) & RSU_NO_RENDER_SPANS) == 0)
        {
            if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_BREAK_ON_RENDER_SPANS)
            {
                DebugBreak();
            }

            RSHRCHK(m_StpCtx.pCtx->pfnRenderSpans(m_StpCtx.pCtx));
        }
        else
        {
            hr = D3D_OK;
        }
#else
        hr = m_StpCtx.pCtx->pfnRenderSpans(m_StpCtx.pCtx);
#endif

        ResetBuffer();
    }
    else
    {
        hr = D3D_OK;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::FlushPartial
//
// Flushes the buffer in the middle of a primitive.  Preserves last
// partial primitive and replaces it in the buffer after the flush.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::FlushPartial(void)
{
    D3DI_RASTPRIM SavedPrim;
    HRESULT hr;

    RSDPFM((RSM_BUFFER, "FlushPartial, saving prim at %p, Y %d\n",
            m_StpCtx.pPrim, m_StpCtx.iY));

    // Not enough space.  Flush current buffer.  We need to
    // save the current prim and put it back in the buffer after the
    // flush since it's being extended.
    SavedPrim = *m_StpCtx.pPrim;

    RSHRRET(Flush());

    GET_PRIM();

    *m_StpCtx.pPrim = SavedPrim;
    COMMIT_PRIM(FALSE);

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::AppendPrim
//
// Ensures that some primitive is active in the buffer for spans to
// be added to.  If no valid primitive is available to append to,
// a zeroed primitive is committed into the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::AppendPrim(void)
{
    // If there's no primitive or the current primitive has not
    // been committed, commit a clean primitive into the buffer.
    if (m_StpCtx.pPrim == NULL ||
        (PUINT8)m_StpCtx.pPrim == m_pCur)
    {
        GET_PRIM();
        COMMIT_PRIM(TRUE);
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Begin
//
// Resets the buffer to an empty state in preparation for incoming
// triangles.
//
//----------------------------------------------------------------------------

void
PrimProcessor::Begin(void)
{
    UINT16 uFpCtrl;
    FPU_GET_MODE(uFpCtrl);
    m_uFpCtrl = uFpCtrl;
    uFpCtrl =
        FPU_MODE_CHOP_ROUND(
                FPU_MODE_LOW_PRECISION(
                        FPU_MODE_MASK_EXCEPTIONS(m_uFpCtrl)));
#if defined(_X86_) && defined(UNMASK_EXCEPTIONS)
    // Unmask some exceptions so that we can eliminate them.
    // This requires a safe set to clear any exceptions that
    // are currently asserted.
    //
    // Exceptions left masked:
    //   Precision, denormal.
    // Exceptions unmasked:
    //   Underflow, overflow, divzero, invalid op.
    uFpCtrl &= ~0x1d;
    FPU_SAFE_SET_MODE(uFpCtrl);
#else
    FPU_SET_MODE(uFpCtrl);
#endif

    m_uPpFlags |= PPF_IN_BEGIN;
    ResetBuffer();
}

//----------------------------------------------------------------------------
//
// PrimProcessor::End
//
// Flushes if necessary and cleans up.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::End(void)
{
    HRESULT hr;

    if (m_pCur - m_pBufferStart > sizeof(D3DI_RASTPRIM))
    {
        RSHRCHK(Flush());
    }
    else
    {
        hr = D3D_OK;
    }

    UINT16 uFpCtrl = m_uFpCtrl;
    FPU_SAFE_SET_MODE(uFpCtrl);

    m_uPpFlags &= ~PPF_IN_BEGIN;

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::SetCtx
//
// Sets the rasterization context to operate in.
//
//----------------------------------------------------------------------------

void
PrimProcessor::SetCtx(PD3DI_RASTCTX pCtx)
{
    // This function can't be called inside a Begin/End pair.  This
    // is enforced so that we don't have to worry about the span
    // rendering function changing in the middle of a batch.
    RSASSERT((m_uPpFlags & PPF_IN_BEGIN) == 0);

    m_StpCtx.pCtx = pCtx;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::AllocSpans
//
// Checks to see if there's room in the buffer for the requested number
// of spans.  If so the buffer pointer is updated and a pointer is returned.
// If the requested number is not available but some reasonable number is,
// return that many.  Otherwise the buffer is flushed and the process starts
// over.  The "reasonable" number must therefore be no more than what
// can fit in the buffer at once.
//
//----------------------------------------------------------------------------

// Space for enough spans to avoid a flush.
#define AVOID_FLUSH_SPACE (8 * sizeof(D3DI_RASTSPAN))

HRESULT
PrimProcessor::AllocSpans(PUINT pcSpans, PD3DI_RASTSPAN *ppSpan)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    UINT uSpanSize;

    RSASSERT(AVOID_FLUSH_SPACE <= (BUFFER_SIZE - sizeof(D3DI_RASTPRIM)));
    // The multiplies and divides here will be really bad unless
    // RASTPRIM is a nice power-of-two in size.
    RSASSERT((sizeof(D3DI_RASTSPAN) & (sizeof(D3DI_RASTSPAN) - 1)) == 0);

    uSpanSize = *pcSpans * sizeof(D3DI_RASTSPAN);

    for (;;)
    {
        // First check for space for all requested spans.
        if (m_pCur + uSpanSize > m_pBufferEnd)
        {
            // Not enough space for everything, so see if we have
            // enough space to avoid a flush.
            if (m_pCur + AVOID_FLUSH_SPACE > m_pBufferEnd)
            {
                // Not enough space, so flush.
                RSHRCHK(FlushPartial());
                if (hr != D3D_OK)
                {
                    *pcSpans = 0;
                    return hr;
                }

                // Loop around.  Flush is guaranteed to at least produce
                // AVOID_FLUSH_SPACE so the loop will always exit.
            }
            else
            {
                // Not enough space for everything but enough space
                // to return some.  Set new span count.
                *pcSpans = (UINT)((m_pBufferEnd - m_pCur) / sizeof(D3DI_RASTSPAN));
                uSpanSize = *pcSpans * sizeof(D3DI_RASTSPAN);
                break;
            }
        }
        else
        {
            break;
        }
    }

    pSpan = (PD3DI_RASTSPAN)m_pCur;
    m_pCur += uSpanSize;
    *ppSpan = pSpan;

    RSDPFM((RSM_BUFFER, "Alloc %d spans at %p, cur %p\n",
            *pcSpans, pSpan, m_pCur));

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::FreeSpans and FreeSpans
//
// Returns space given out by AllocSpans.
//
//----------------------------------------------------------------------------

void
PrimProcessor::FreeSpans(UINT cSpans)
{
    m_pCur -= cSpans * sizeof(D3DI_RASTSPAN);

    RSDPFM((RSM_BUFFER, "Free  %d spans at %p, cur %p\n", cSpans,
            m_pCur + cSpans * sizeof(D3DI_RASTSPAN), m_pCur));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx7\rast\setup\lstp.cpp ===
//----------------------------------------------------------------------------
//
// lstp.cpp
//
// Line setup methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// LineSetup_Start
//
// Starts setup of line attributes.
//
//----------------------------------------------------------------------------

void FASTCALL
LineSetup_Start(PSETUPCTX pStpCtx,
                LPD3DTLVERTEX pV0,
                LPD3DTLVERTEX pV1)
{
    FLOAT fZ0;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        FLOAT fZScale;

        if (pStpCtx->pCtx->iZBitCount == 16)
        {
            fZScale = Z16_SCALE;
        }
        else
        {
            fZScale = Z32_SCALE;
        }

        pStpCtx->DAttrDMajor.fZ =
            (pV1->dvSZ - pV0->dvSZ) * fZScale * pStpCtx->fOoLen;

        // fZ0 may be used later so set if from the vertex Z.
        fZ0 = pV0->dvSZ;
        pStpCtx->Attr.fZ = fZ0 * fZScale +
            pStpCtx->DAttrDMajor.fZ * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fUoW, fVoW;

        if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            pStpCtx->DAttrDMajor.fOoW =
                (pV1->dvRHW - pV0->dvRHW) * OOW_SCALE * pStpCtx->fOoLen;
            pStpCtx->Attr.fOoW = pV0->dvRHW * OOW_SCALE +
                pStpCtx->DAttrDMajor.fOoW * pStpCtx->fDMajor;

            fUoW = pV0->dvTU * pV0->dvRHW;
            fVoW = pV0->dvTV * pV0->dvRHW;

            pStpCtx->DAttrDMajor.fUoW[0] =
                PERSP_TEXTURE_DELTA(pV1->dvTU, pV1->dvRHW, pV0->dvTU, fUoW,
                                    pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_U) *
                                    TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW[0] =
                PERSP_TEXTURE_DELTA(pV1->dvTV, pV1->dvRHW, pV0->dvTV, fVoW,
                                    pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_V) *
                                    TEX_SCALE * pStpCtx->fOoLen;
        }
        else
        {
            pStpCtx->DAttrDMajor.fOoW = g_fZero;
            pStpCtx->Attr.fOoW = OOW_SCALE;

            fUoW = pV0->dvTU;
            fVoW = pV0->dvTV;

            pStpCtx->DAttrDMajor.fUoW[0] =
                TextureDiff(pV1->dvTU, fUoW,
                            pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_U) *
                            TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW[0] =
                TextureDiff(pV1->dvTV, fVoW,
                            pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_V) *
                            TEX_SCALE * pStpCtx->fOoLen;
        }

        pStpCtx->Attr.fUoW[0] = TEX_SCALE * fUoW +
            pStpCtx->DAttrDMajor.fUoW[0] * pStpCtx->fDMajor;
        pStpCtx->Attr.fVoW[0] = TEX_SCALE * fVoW +
            pStpCtx->DAttrDMajor.fVoW[0] * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        PRAST_GENERIC_VERTEX pVM0 = (PRAST_GENERIC_VERTEX)pV0;
        PRAST_GENERIC_VERTEX pVM1 = (PRAST_GENERIC_VERTEX)pV1;
        FLOAT fUoW, fVoW;

        for (INT32 i = 1; i < (INT32)pStpCtx->pCtx->cActTex; i++)
        {
            if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
            {
                fUoW = pVM0->texCoord[i].dvTU * pVM0->dvRHW;
                fVoW = pVM0->texCoord[i].dvTV * pVM0->dvRHW;

                pStpCtx->DAttrDMajor.fUoW[i] =
                    PERSP_TEXTURE_DELTA(pVM1->texCoord[i].dvTU, pVM1->dvRHW,
                                        pVM0->texCoord[i].dvTU, fUoW,
                                        pStpCtx->pCtx->pdwWrap[i] & D3DWRAP_U) *
                                        TEX_SCALE * pStpCtx->fOoLen;
                pStpCtx->DAttrDMajor.fVoW[i] =
                    PERSP_TEXTURE_DELTA(pVM1->texCoord[i].dvTV, pVM1->dvRHW,
                                        pVM0->texCoord[i].dvTV, fVoW,
                                        pStpCtx->pCtx->pdwWrap[i] & D3DWRAP_V) *
                                        TEX_SCALE * pStpCtx->fOoLen;
            }
            else
            {
                fUoW = pVM0->texCoord[i].dvTU;
                fVoW = pVM0->texCoord[i].dvTV;

                pStpCtx->DAttrDMajor.fUoW[i] =
                    TextureDiff(pVM1->texCoord[i].dvTU, fUoW,
                                pStpCtx->pCtx->pdwWrap[i] & D3DWRAP_U) *
                                TEX_SCALE * pStpCtx->fOoLen;
                pStpCtx->DAttrDMajor.fVoW[i] =
                    TextureDiff(pVM1->texCoord[i].dvTV, fVoW,
                                pStpCtx->pCtx->pdwWrap[i] & D3DWRAP_V) *
                                TEX_SCALE * pStpCtx->fOoLen;
            }

            pStpCtx->Attr.fUoW[i] = TEX_SCALE * fUoW +
                pStpCtx->DAttrDMajor.fUoW[i] * pStpCtx->fDMajor;
            pStpCtx->Attr.fVoW[i] = TEX_SCALE * fVoW +
                pStpCtx->DAttrDMajor.fVoW[i] * pStpCtx->fDMajor;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_FLAT_SHADED)
    {
        if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
        {
            UINT uB, uG, uR, uA;

            SPLIT_COLOR(pStpCtx->pFlatVtx->dcColor, uB, uG, uR, uA);

            pStpCtx->DAttrDMajor.fB = g_fZero;
            pStpCtx->DAttrDMajor.fG = g_fZero;
            pStpCtx->DAttrDMajor.fR = g_fZero;
            pStpCtx->DAttrDMajor.fA = g_fZero;

            pStpCtx->Attr.fB = (FLOAT)(uB << COLOR_SHIFT);
            pStpCtx->Attr.fG = (FLOAT)(uG << COLOR_SHIFT);
            pStpCtx->Attr.fR = (FLOAT)(uR << COLOR_SHIFT);
            pStpCtx->Attr.fA = (FLOAT)(uA << COLOR_SHIFT);
        }
        else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
        {
            pStpCtx->DAttrDMajor.fDIdx = g_fZero;
            pStpCtx->DAttrDMajor.fDIdxA = g_fZero;

            pStpCtx->Attr.fDIdx =
                (FLOAT)(CI_MASKALPHA(pStpCtx->pFlatVtx->dcColor) <<
                        INDEX_COLOR_FIXED_SHIFT);
            pStpCtx->Attr.fDIdxA =
                (FLOAT)(CI_GETALPHA(pStpCtx->pFlatVtx->dcColor) <<
                        INDEX_COLOR_SHIFT);
        }

        if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
        {
            UINT uB, uG, uR, uA;

            SPLIT_COLOR(pStpCtx->pFlatVtx->dcSpecular, uB, uG, uR, uA);

            pStpCtx->DAttrDMajor.fBS = g_fZero;
            pStpCtx->DAttrDMajor.fGS = g_fZero;
            pStpCtx->DAttrDMajor.fRS = g_fZero;

            pStpCtx->Attr.fBS = (FLOAT)(uB << COLOR_SHIFT);
            pStpCtx->Attr.fGS = (FLOAT)(uG << COLOR_SHIFT);
            pStpCtx->Attr.fRS = (FLOAT)(uR << COLOR_SHIFT);
        }
    }
    else
    {
        if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
        {
            UINT uB, uG, uR, uA;
            FLOAT fDB, fDG, fDR, fDA;

            SPLIT_COLOR(pV0->dcColor, uB, uG, uR, uA);
            COLOR_DELTA(pV1->dcColor, uB, uG, uR, uA, fDB, fDG, fDR, fDA);

            pStpCtx->DAttrDMajor.fB = fDB * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fG = fDG * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fR = fDR * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fA = fDA * pStpCtx->fOoLen;

            pStpCtx->Attr.fB = (FLOAT)(uB << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fB * pStpCtx->fDMajor;
            pStpCtx->Attr.fG = (FLOAT)(uG << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fG * pStpCtx->fDMajor;
            pStpCtx->Attr.fR = (FLOAT)(uR << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fR * pStpCtx->fDMajor;
            pStpCtx->Attr.fA = (FLOAT)(uA << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fA * pStpCtx->fDMajor;
        }
        else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
        {
            INT32 iIdx, iA;
            FLOAT fDIdx, fDA;

            SPLIT_IDX_COLOR(pV0->dcColor, iIdx, iA);
            IDX_COLOR_DELTA(pV1->dcColor, iIdx, iA, fDIdx, fDA);

            pStpCtx->DAttrDMajor.fDIdx = fDIdx * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fDIdxA = fDA * pStpCtx->fOoLen;

            pStpCtx->Attr.fDIdx = (FLOAT)(iIdx << INDEX_COLOR_FIXED_SHIFT) +
                pStpCtx->DAttrDMajor.fDIdx * pStpCtx->fDMajor;
            pStpCtx->Attr.fDIdxA = (FLOAT)(iA << INDEX_COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fDIdxA * pStpCtx->fDMajor;
        }

        if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
        {
            UINT uB, uG, uR, uA;
            FLOAT fDB, fDG, fDR, fDA;

            SPLIT_COLOR(pV0->dcSpecular, uB, uG, uR, uA);
            COLOR_DELTA(pV1->dcSpecular, uB, uG, uR, uA, fDB, fDG, fDR, fDA);

            pStpCtx->DAttrDMajor.fBS = fDB * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fGS = fDG * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fRS = fDR * pStpCtx->fOoLen;

            pStpCtx->Attr.fBS = (FLOAT)(uB << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fBS * pStpCtx->fDMajor;
            pStpCtx->Attr.fGS = (FLOAT)(uG << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fGS * pStpCtx->fDMajor;
            pStpCtx->Attr.fRS = (FLOAT)(uR << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fRS * pStpCtx->fDMajor;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        UINT uFog0, uFog1;

#ifndef PWL_FOG
        // Check for global-into-local fog.  If global fog is on,
        // compute the local fog values from table fog rather than
        // from the vertex.
        if (pStpCtx->uFlags & PRIMSF_GLOBAL_FOG_USED)
        {
            // Make sure Z information is valid.
            RSASSERT(pStpCtx->uFlags & PRIMSF_Z_USED);

            uFog0 = ComputeTableFog(pStpCtx->pCtx->pdwRenderState, fZ0);
            uFog1 = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                    pV1->dvSZ);
        }
        else
#endif
        {
            uFog0 = (UINT)RGBA_GETALPHA(pV0->dcSpecular) << FOG_SHIFT;
            uFog1 = (UINT)RGBA_GETALPHA(pV1->dcSpecular) << FOG_SHIFT;
        }

        pStpCtx->DAttrDMajor.fFog =
            (FLOAT)((INT)uFog1 - (INT)uFog0) * pStpCtx->fOoLen;
        pStpCtx->Attr.fFog = (FLOAT)uFog0 +
            pStpCtx->DAttrDMajor.fFog * pStpCtx->fDMajor;
    }
}

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
#define NEEDS_NORMALIZE2(fV0, fV1) \
    ((ASUINT32(fV0) | ASUINT32(fV1)) > INT32_FLOAT_ONE)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizeLineRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function ensures that
// the RHWs are in the proper range by finding the largest one and
// scaling all of them down by it.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizeLineRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1)
{
    // Save original values.
    m_dvV0RHW = pV0->dvRHW;
    m_dvV1RHW = pV1->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW) || FLOAT_LTZ(pV1->dvRHW))
    {
        RSDPF(("Line RHW out of range %f,%f\n",
               pV0->dvRHW, pV1->dvRHW));
    }
#endif

    // Find bounds and compute scale.
    FLOAT fMax;

    if (pV0->dvRHW < pV1->dvRHW)
    {
        fMax = pV1->dvRHW;
    }
    else
    {
        fMax = pV0->dvRHW;
    }

    FLOAT fRHWScale = NORMALIZED_RHW_MAX / fMax;

    // Scale all values by scaling factor.
    pV0->dvRHW = pV0->dvRHW * fRHWScale;
    pV1->dvRHW = pV1->dvRHW * fRHWScale;
}

//-----------------------------------------------------------------------------
//
// PrimProcessor::PointDiamondCheck
//
// Tests if vertex is within diamond of nearest candidate
// position.  The +.5 (lower-right) tests are used because this is
// pixel-relative test - this corresponds to an upper-left test for
// a vertex-relative position.
//
//-----------------------------------------------------------------------------

BOOL
PrimProcessor::PointDiamondCheck(INT32 iXFrac, INT32 iYFrac,
                                 BOOL bSlopeIsOne, BOOL bSlopeIsPosOne)
{
    const INT32 iPosHalf =  0x8;
    const INT32 iNegHalf = -0x8;

    INT32 iFracAbsSum = labs( iXFrac ) + labs( iYFrac );

    // return TRUE if point is in fully-exclusive diamond
    if ( iFracAbsSum < iPosHalf )
    {
        return TRUE;
    }

    // else return TRUE if diamond is on left or top extreme of point
    if ( ( iXFrac == ( bSlopeIsPosOne ? iNegHalf : iPosHalf ) ) &&
         ( iYFrac == 0 ) )
    {
        return TRUE;
    }

    if ( ( iYFrac == iPosHalf ) &&
         ( iXFrac == 0 ) )
    {
        return TRUE;
    }

    // return true if slope is one, vertex is on edge,
    // and (other conditions...)
    if ( bSlopeIsOne && ( iFracAbsSum == iPosHalf ) )
    {
        if (  bSlopeIsPosOne && ( iXFrac < 0 ) && ( iYFrac > 0 ) )
        {
            return TRUE;
        }

        if ( !bSlopeIsPosOne && ( iXFrac > 0 ) && ( iYFrac > 0 ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::LineSetup
//
// Does attribute setup computations.
//
//----------------------------------------------------------------------------

// Line computations are done in n.4 fixed-point to reduce vertex jitter,
// move more computation to integer and to more easily match the GDI
// line computations.
#define LINE_FIX 4
#define LINE_SNAP FLOAT_TWOPOW4
#define OO_LINE_SNAP (1.0f / FLOAT_TWOPOW4)
#define LINE_FIX_HALF (1 << (LINE_FIX - 1))
#define LINE_FIX_NEAR_HALF (LINE_FIX_HALF - 1)

BOOL
PrimProcessor::LineSetup(LPD3DTLVERTEX pV0,
                         LPD3DTLVERTEX pV1)
{
    // compute fixed point vertex values, with cheap
    // rounding for better accuracy
    INT32 iX0 = FTOI(pV0->dvSX * LINE_SNAP + .5F);
    INT32 iX1 = FTOI(pV1->dvSX * LINE_SNAP + .5F);
    INT32 iY0 = FTOI(pV0->dvSY * LINE_SNAP + .5F);
    INT32 iY1 = FTOI(pV1->dvSY * LINE_SNAP + .5F);

    // compute x,y extents of the line (fixed point)
    INT32 iXSize = iX1 - iX0;
    INT32 iYSize = iY1 - iY0;

    // ignore zero length lines
    if ( iXSize == 0 && iYSize == 0 )
    {
        return FALSE;
    }

    INT32 iAbsXSize;
    INT32 iAbsYSize;

    if ( iXSize < 0 )
    {
        m_StpCtx.iDXCY = -1;
        iAbsXSize = -iXSize;
    }
    else
    {
        m_StpCtx.iDXCY = 1;
        iAbsXSize = iXSize;
    }

    if ( iYSize < 0 )
    {
        m_StpCtx.iDYCY = -1;
        iAbsYSize = -iYSize;
    }
 