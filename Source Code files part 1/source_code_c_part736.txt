zeof(SPOOL_FILE_INFO_1)) {
           SetLastError(ERROR_INSUFFICIENT_BUFFER);
           *pcbNeeded = sizeof(SPOOL_FILE_INFO_1);
           goto CleanUp;
       }

       pSpoolFileInfo1 = (PSPOOL_FILE_INFO_1)pSpoolFileInfo;
       break;

    default:
       SetLastError(ERROR_INVALID_LEVEL);
       goto CleanUp;
    }

    // Initialize spoolfileinfo1 struct
    pSpoolFileInfo1->dwVersion = 1;
    pSpoolFileInfo1->hSpoolFile = INVALID_HANDLE_VALUE;
    pSpoolFileInfo1->dwAttributes = SPOOL_FILE_PERSISTENT;

    if (pPrintHandle->pProvidor == pLocalProvidor) {

        bReturn  = (pLocalProvidor->PrintProvidor.fpCommitSpoolData)(pPrintHandle->hPrinter,
                                                                     cbCommit);
        return bReturn;
    }

    // For remote printing send the temp file across the wire using WritePrinter
    if (pPrintHandle->hFileSpooler == INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return bReturn;
    }

    hFile = pPrintHandle->hFileSpooler;

    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xffffffff) {
        goto CleanUp;
    }

    //
    // Use a Buffer to send Data over RPC.
    //
    Buffer = AllocSplMem(BUFFER_SIZE);
    
    if ( !Buffer ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto CleanUp;
    }
    
    while ((cbToRead = min(cbCommit, BUFFER_SIZE)) &&
           ReadFile(hFile, Buffer, cbToRead, &cbRead, NULL)) {

         cbCommit -= cbRead;

         for (cbTotalWritten = 0;
              cbTotalWritten < cbRead;
              cbTotalWritten += cbWritten) {

            if (!(*pPrintHandle->pProvidor->PrintProvidor.fpWritePrinter)
                                                            (pPrintHandle->hPrinter,
                                                             (LPBYTE)Buffer + cbTotalWritten,
                                                             cbRead - cbTotalWritten,
                                                             &cbWritten)) {
                goto CleanUp;
            }
         }
    }

    if (Buffer) {
        FreeSplMem(Buffer);
        Buffer = NULL;
    }
    
    if ((cbToRead != 0) ||
        (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xffffffff)) {

        goto CleanUp;
    }

    if ((hSpoolerProcess = GetCurrentProcess()) &&
        DuplicateHandle(hSpoolerProcess,
                        pPrintHandle->hFileSpooler,
                        hAppProcess,
                        &hFileApp,
                        0,
                        TRUE,
                        DUPLICATE_SAME_ACCESS)) {

        pSpoolFileInfo1->dwVersion = 1;
        pSpoolFileInfo1->hSpoolFile = hFileApp;
        pSpoolFileInfo1->dwAttributes = SPOOL_FILE_TEMPORARY;

        bReturn = TRUE;
    }

CleanUp:

    if (Buffer) {
        FreeSplMem(Buffer);
    }
    if (hSpoolerProcess) {
        CloseHandle(hSpoolerProcess);
    }
    return bReturn;
}

BOOL
SplCloseSpoolFileHandle(
    HANDLE  hPrinter
)

/*++
Function Description: Closes the remote spool file handle for remote printing.

Parameters: hPrinter - printer handle

Return Values: TRUE if sucessful;
               FALSE otherwise
--*/

{
    LPPRINTHANDLE  pPrintHandle = (LPPRINTHANDLE)hPrinter;

    // Check Handle validity
    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (pPrintHandle->pProvidor == pLocalProvidor) {

        return (pLocalProvidor->PrintProvidor.fpCloseSpoolFileHandle)(pPrintHandle->hPrinter);

    } else if ((pPrintHandle->hFileSpooler != INVALID_HANDLE_VALUE)) {

        // close temp files for remote printing
        CloseHandle(pPrintHandle->hFileSpooler);
        pPrintHandle->hFileSpooler = INVALID_HANDLE_VALUE;

        if (pPrintHandle->szTempSpoolFile) {

            HANDLE hToken = RevertToPrinterSelf();

            if (!DeleteFile(pPrintHandle->szTempSpoolFile)) {

                MoveFileEx(pPrintHandle->szTempSpoolFile, NULL,
                           MOVEFILE_DELAY_UNTIL_REBOOT);
            }

            if (hToken)
            {
                ImpersonatePrinterClient(hToken);
            }

            FreeSplMem(pPrintHandle->szTempSpoolFile);
            pPrintHandle->szTempSpoolFile = NULL;
        }
    }

    return TRUE;
}


BOOL
SplGetSpoolFileInfo(
    HANDLE  hPrinter,
    HANDLE  hAppProcess,
    DWORD   dwLevel,
    LPBYTE  pSpoolFileInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)

/*++
Function Description: Get spool file info for the job in hPrinter. For local jobs
                      localspl returns the hFile. For remote jobs a temp file is created
                      by the router. The file handle is dupped into the application.

Parameters: hPrinter       - printer handle
            hAppProcess    - application process handle
            dwLevel        - spool file info level
            pSpoolFileInfo - pointer to buffer
            cbBuf          - buffer size
            pcbNeeded      - pointer to return required buffer size

Return Values: TRUE if sucessful;
               FALSE otherwise
--*/

{
    HANDLE   hFileSpooler = NULL, hFileApp = NULL;
    HANDLE   hSpoolerProcess = NULL;
    BOOL     bReturn = FALSE;
    DWORD    dwSpoolerProcessID;
    LPWSTR   pSpoolDir = NULL;

    PSPOOL_FILE_INFO_1  pSpoolFileInfo1;
    LPPRINTHANDLE       pPrintHandle = (LPPRINTHANDLE)hPrinter;

    // Check Handle validity
    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        goto CleanUp;
    }

    // Check for valid level and sufficient buffer
    switch (dwLevel) {
    case 1:
       if (cbBuf < sizeof(SPOOL_FILE_INFO_1)) {
           SetLastError(ERROR_INSUFFICIENT_BUFFER);
           *pcbNeeded = sizeof(SPOOL_FILE_INFO_1);
           goto CleanUp;
       }

       pSpoolFileInfo1 = (PSPOOL_FILE_INFO_1)pSpoolFileInfo;
       break;

    default:
       SetLastError(ERROR_INVALID_LEVEL);
       goto CleanUp;
    }

    if (!(hSpoolerProcess = GetCurrentProcess())) {
        // Cant get a pseudo handle to the spooler
        goto CleanUp;
    }

    if ((pPrintHandle->pProvidor != pLocalProvidor) &&
        (pPrintHandle->hFileSpooler != INVALID_HANDLE_VALUE)) {

        // Return cached temp file handle.
        bReturn = DuplicateHandle(hSpoolerProcess,
                                  pPrintHandle->hFileSpooler,
                                  hAppProcess,
                                  &hFileApp,
                                  0,
                                  TRUE,
                                  DUPLICATE_SAME_ACCESS);
        if (bReturn) {
            pSpoolFileInfo1->dwVersion = 1;
            pSpoolFileInfo1->hSpoolFile = hFileApp;
            pSpoolFileInfo1->dwAttributes = SPOOL_FILE_TEMPORARY;
        }

        goto CleanUp;
    }

    if (pPrintHandle->pProvidor == pLocalProvidor) {

        bReturn  = (pLocalProvidor->PrintProvidor.fpGetSpoolFileInfo)(pPrintHandle->hPrinter,
                                                                      NULL,
                                                                      &hFileApp,
                                                                      hSpoolerProcess,
                                                                      hAppProcess);

        if (bReturn) {
            pSpoolFileInfo1->dwVersion = 1;
            pSpoolFileInfo1->hSpoolFile = hFileApp;
            pSpoolFileInfo1->dwAttributes = SPOOL_FILE_PERSISTENT;
        }

        goto CleanUp;

    } else {

        bReturn  = (pLocalProvidor->PrintProvidor.fpGetSpoolFileInfo)(NULL, &pSpoolDir,
                                                                      NULL, NULL, NULL);
    }

    // Remote Printing, create a temp file in the spool directory
    if (bReturn) {

        HANDLE hToken;

        //
        // Revert to system context to ensure that we can open the file.
        //
        hToken = RevertToPrinterSelf();

        if ((pPrintHandle->szTempSpoolFile = AllocSplMem(MAX_PATH * sizeof(WCHAR))) &&

            GetTempFileName(pSpoolDir, L"SPL", 0, pPrintHandle->szTempSpoolFile)    &&

            ((pPrintHandle->hFileSpooler = CreateFile(pPrintHandle->szTempSpoolFile,
                                                      GENERIC_READ | GENERIC_WRITE,
                                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                      NULL,
                                                      CREATE_ALWAYS,
                                                      0, NULL)) != INVALID_HANDLE_VALUE) &&
            DuplicateHandle(hSpoolerProcess,
                            pPrintHandle->hFileSpooler,
                            hAppProcess,
                            &hFileApp,
                            0,
                            TRUE,
                            DUPLICATE_SAME_ACCESS)) {

            pSpoolFileInfo1->dwVersion = 1;
            pSpoolFileInfo1->hSpoolFile = hFileApp;
            pSpoolFileInfo1->dwAttributes = SPOOL_FILE_TEMPORARY;

        } else {

            bReturn = FALSE;
        }

        if (hToken)
        {
            ImpersonatePrinterClient(hToken);
        }
    }

CleanUp:

    if (hSpoolerProcess) {
        CloseHandle(hSpoolerProcess);
    }
    if (pSpoolDir) {
        FreeSplMem(pSpoolDir);
    }

    return bReturn;
}

BOOL
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle ||
        (pPrintHandle->signature != PRINTHANDLE_SIGNATURE) ||
        (pPrintHandle->hFileSpooler != INVALID_HANDLE_VALUE)) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpWritePrinter) (pPrintHandle->hPrinter,
                                                    pBuf, cbBuf, pcWritten);
}

BOOL
SeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWritePrinter
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;
    LARGE_INTEGER   liNewPointer;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Allow a NULL pliNewPointer to be passed in.
    //
    if( !pliNewPointer ){
        pliNewPointer = &liNewPointer;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpSeekPrinter) (
               pPrintHandle->hPrinter,
               liDistanceToMove,
               pliNewPointer,
               dwMoveMethod,
               bWritePrinter );
}

BOOL
FlushPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
)

/*++
Function Description: FlushPrinter is typically used by the driver to send a burst of zeros
                      to the printer and introduce a delay in the i/o line to the printer.
                      The spooler does not schedule any job for cSleep milliseconds.

Parameters:  hPrinter  - printer handle
             pBuf      - buffer to be sent to the printer
             cbBuf     - size of the buffer
             pcWritten - pointer to return the number of bytes written
             cSleep    - sleep time in milliseconds.

Return Values: TRUE if successful;
               FALSE otherwise
--*/

{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    //
    // Check for valid printer handle
    //
    if (!pPrintHandle ||
        (pPrintHandle->signature != PRINTHANDLE_SIGNATURE) ||
        (pPrintHandle->hFileSpooler != INVALID_HANDLE_VALUE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpFlushPrinter) (pPrintHandle->hPrinter,
                                                                     pBuf,
                                                                     cbBuf,
                                                                     pcWritten,
                                                                     cSleep);
}

BOOL
EndPagePrinter(
    HANDLE  hPrinter
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEndPagePrinter) (pPrintHandle->hPrinter);
}

BOOL
AbortPrinter(
    HANDLE  hPrinter
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpAbortPrinter) (pPrintHandle->hPrinter);
}

BOOL
ReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pRead
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpReadPrinter)
                          (pPrintHandle->hPrinter, pBuf, cbBuf, pRead);
}

BOOL
SplReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    DWORD   cbBuf
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpSplReadPrinter)
                          (pPrintHandle->hPrinter, pBuf, cbBuf);
}

BOOL
EndDocPrinter(
    HANDLE  hPrinter
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEndDocPrinter) (pPrintHandle->hPrinter);
}

HANDLE
CreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODEW   pDevMode
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;
    HANDLE  ReturnValue;
    PGDIHANDLE  pGdiHandle;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    pGdiHandle = AllocSplMem(sizeof(GDIHANDLE));

    if (!pGdiHandle) {

        DBGMSG(DBG_WARN, ("Failed to alloc GDI handle."));
        return FALSE;
    }

    ReturnValue = (HANDLE)(*pPrintHandle->pProvidor->PrintProvidor.fpCreatePrinterIC)
                                              (pPrintHandle->hPrinter,
                                               pDevMode);

    if (ReturnValue) {

        pGdiHandle->signature = GDIHANDLE_SIGNATURE;
        pGdiHandle->pProvidor = pPrintHandle->pProvidor;
        pGdiHandle->hGdi = ReturnValue;

        return pGdiHandle;
    }

    FreeSplMem(pGdiHandle);

    return FALSE;
}

BOOL
PlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE pIn,
    DWORD   cIn,
    LPBYTE pOut,
    DWORD   cOut,
    DWORD   ul
)
{
    PGDIHANDLE   pGdiHandle=(PGDIHANDLE)hPrinterIC;

    if (!pGdiHandle || pGdiHandle->signature != GDIHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pGdiHandle->pProvidor->PrintProvidor.fpPlayGdiScriptOnPrinterIC)
                            (pGdiHandle->hGdi, pIn, cIn, pOut, cOut, ul);
}

BOOL
DeletePrinterIC(
    HANDLE hPrinterIC
)
{
    LPGDIHANDLE   pGdiHandle=(LPGDIHANDLE)hPrinterIC;

    if (!pGdiHandle || pGdiHandle->signature != GDIHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((*pGdiHandle->pProvidor->PrintProvidor.fpDeletePrinterIC) (pGdiHandle->hGdi)) {

        FreeSplMem(pGdiHandle);
        return TRUE;
    }

    return FALSE;
}

DWORD
PrinterMessageBox(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpPrinterMessageBox)
                    (hPrinter, Error, hWnd, pText, pCaption, dwType);

}

DWORD 
SendRecvBidiData(
    IN  HANDLE                    hPrinter,
    IN  LPCTSTR                   pAction,
    IN  PBIDI_REQUEST_CONTAINER   pReqData,
    OUT PBIDI_RESPONSE_CONTAINER* ppResData
)
{
    DWORD         dwRet = ERROR_SUCCESS;
    LPPRINTHANDLE pPrintHandle = (LPPRINTHANDLE)hPrinter;
    //
    // Check for valid printer handle
    //
    if (!pPrintHandle ||
        (pPrintHandle->signature != PRINTHANDLE_SIGNATURE) ||
        (pPrintHandle->hFileSpooler != INVALID_HANDLE_VALUE))
    {
        dwRet = ERROR_INVALID_HANDLE;
    }
    else
    {
        dwRet = (*pPrintHandle->pProvidor->PrintProvidor.fpSendRecvBidiData)(pPrintHandle->hPrinter,
                                                                             pAction,
                                                                             pReqData,
                                                                             ppResData);
    }
    return (dwRet);
}


/*++


Routine Name: 

    SplPromptUIInUsersSession 

Routine Description: 

    Pops message boxes in the user's session.
    For Whistler this function shows only message boxes in Spoolsv.exe.
    
Arguments:

    hPrinter  -- printer handle
    JobId     -- job ID
    pUIParams -- UI parameters
    pResponse -- user's response

Return Value:

    TRUE if succeeded 

Last Error:
 
    Win32 error

--*/
BOOL
SplPromptUIInUsersSession(
    IN  HANDLE          hPrinter,
    IN  DWORD           JobId,
    IN  PSHOWUIPARAMS   pUIParams,
    OUT DWORD           *pResponse
)
{
    typedef BOOL (*FPPROMPT_UI)(HANDLE, DWORD, PSHOWUIPARAMS, DWORD*);

    FPPROMPT_UI     fpPromptUIPerSessionUser;
    BOOL            bRetValue = FALSE;
    PPRINTHANDLE    pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (pPrintHandle && pPrintHandle->signature == PRINTHANDLE_SIGNATURE) 
    {
        if (pPrintHandle->pProvidor == pLocalProvidor &&
            (fpPromptUIPerSessionUser = (FPPROMPT_UI)GetProcAddress(pLocalProvidor->hModule, 
                                                                   "LclPromptUIPerSessionUser"))) 
        {                
            bRetValue = (*fpPromptUIPerSessionUser)(pPrintHandle->hPrinter, JobId, pUIParams, pResponse);
        }            
        else 
        {
            SetLastError(ERROR_NOT_SUPPORTED);
        }        
    }
    else 
    {
        SetLastError(ERROR_INVALID_HANDLE);
    }

    return bRetValue;
}


/*++


Routine Name: 

    SplIsSessionZero 

Routine Description: 

    Determine is user that submitted a certain job runs in Session 0. 
    It is used by Canon monitor to determine when to show 
    resource template base UI versus calling SplPromptUIInUsersSession.

Arguments:

    hPrinter       -- printer handle
    JobId          -- job ID
    pIsSessionZero -- TRUE if user runs in Session 0

Return Value:

    Win32 last error

Last Error:

--*/
DWORD
SplIsSessionZero(
    IN  HANDLE  hPrinter,
    IN  DWORD   JobId,
    OUT BOOL    *pIsSessionZero
)
{
    typedef DWORD (*FPISSESSIONZERO)(HANDLE, DWORD, BOOL*);

    FPISSESSIONZERO fpIsSessionZero;
    DWORD           dwRetValue = ERROR_SUCCESS;
    PPRINTHANDLE    pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (pPrintHandle && pPrintHandle->signature == PRINTHANDLE_SIGNATURE) 
    {
        if (pPrintHandle->pProvidor == pLocalProvidor && 
            (fpIsSessionZero = (FPISSESSIONZERO)GetProcAddress(pLocalProvidor->hModule, 
                                                              "LclIsSessionZero"))) 
        {                
            dwRetValue = (*fpIsSessionZero)(pPrintHandle->hPrinter, JobId, pIsSessionZero);
        }            
        else 
        {
            dwRetValue = ERROR_NOT_SUPPORTED;
        }        
    }
    else 
    {
        dwRetValue = ERROR_INVALID_HANDLE;
    }

    return dwRetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\winproc.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    winproc.c

Abstract:

    Spooler window processing code

Author:

    Muhunthan Sivapragasam (MuhuntS) 5-Nov-96 port of win95 code

Environment:

    User Mode - Win32

Notes:

Revision History:

    BabakJ: Jan 1999, Added thread sync code to allow only one thread doing enumeration, and only
            one thread waiting. This helps performance specially when Dynamon has many Hydra ports.

--*/

#include "precomp.h"
#include "local.h"
#pragma hdrstop

#include <cfgmgr32.h>

static  const   GUID USB_PRINTER_GUID      =
    { 0x28d78fad, 0x5a12, 0x11d1,
        { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2 } };
static  const   GUID GUID_DEVCLASS_INFRARED =
    { 0x6bdd1fc5L, 0x810f, 0x11d0,
        { 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f } };

typedef struct _DEVICE_REGISTER_INFO {

    struct _DEVICE_REGISTER_INFO   *pNext;
    HANDLE                          hDevice;
    LPVOID                          pData;
    PFN_QUERYREMOVE_CALLBACK        pfnQueryRemove;
    HDEVNOTIFY                      hNotify;

} DEVICE_REGISTER_INFO, *PDEVICE_REGISTER_INFO;

PDEVICE_REGISTER_INFO   gpDevRegnInfo = NULL;

HDEVNOTIFY              ghPNPNotify_USB = NULL;
HDEVNOTIFY              ghPNPNotify_IR  = NULL;

VOID
ConfigChangeThread(
    )
{
    HINSTANCE   hLib;
    VOID        (*pfnSplConfigChange)();

    WaitForSpoolerInitialization();

    if ( hLib = LoadLibrary(L"localspl.dll") ) {

        if ( pfnSplConfigChange = GetProcAddress(hLib, "SplConfigChange") ) {

            pfnSplConfigChange();
        }

        FreeLibrary(hLib);
    }
}


VOID
ReenumeratePortsThreadWorker(
    )
{
    HINSTANCE   hLib;
    VOID        (*pfnSplReenumeratePorts)();

    WaitForSpoolerInitialization();

    if ( hLib = LoadLibrary(L"localspl.dll") ) {

        if ( pfnSplReenumeratePorts = GetProcAddress(hLib, "SplReenumeratePorts") ) {

            pfnSplReenumeratePorts();
        }

        FreeLibrary(hLib);
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
/////
///// To improve performance, and prevent too many unnecessary port enumerations, specially for Hydra/Dynamon:
/////
/////  - We want to allow only one Device Arrival thread to be doing port enumeration.
/////  - If above is happneing, we allow only one more Device Arrival thread be waiting to go in. 
/////  - All other threads will be turned away, as there is no need for them to do port enumeration.   
/////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

CRITICAL_SECTION DeviceArrivalCS;   // Used to synchronize threads bringing device arrival messages.
HANDLE           ThdOutEvent;       // Signalled after a thread is done doing the EnumPort work; not signaled when created.


VOID
ReenumeratePortsThread(
    )
{  
    static BOOL fThdIn;          // TRUE if a thread is doing enum work at the moment
    static BOOL fThdWaiting;     // TRUE if a 2nd thread is waiting behind the thread that is inside.

    EnterCriticalSection( &DeviceArrivalCS );    // Enter the crit section initialized for this at localspl init code
    if( fThdWaiting ) {
        LeaveCriticalSection( &DeviceArrivalCS ); 
        return;                 // A 2nd thread is already waiting to go in. No need for holding more threads.
    }
    else {

       if( fThdIn ) {

            fThdWaiting = TRUE;       // There is a thread inside doing Enum work. Have the current thread wait for it to finish.
            
            LeaveCriticalSection( &DeviceArrivalCS );             
            WaitForSingleObject( ThdOutEvent, INFINITE );
            EnterCriticalSection( &DeviceArrivalCS );

            fThdWaiting = FALSE;
        }

        fThdIn = TRUE;              // The current thread is now going in to do Enum work.
        
        LeaveCriticalSection( &DeviceArrivalCS );                     
        ReenumeratePortsThreadWorker();
        EnterCriticalSection( &DeviceArrivalCS );        
        
        fThdIn = FALSE;
        
        if( fThdWaiting )
            SetEvent( ThdOutEvent );

        LeaveCriticalSection( &DeviceArrivalCS );        
        return;
    }
}
    

DWORD
QueryRemove(
    HANDLE  hDevice
    )
{
    LPVOID                      pData = NULL;
    PFN_QUERYREMOVE_CALLBACK    pfnQueryRemove = NULL;
    PDEVICE_REGISTER_INFO       pDevRegnInfo;

    EnterRouterSem();
    for ( pDevRegnInfo = gpDevRegnInfo ;
          pDevRegnInfo ;
          pDevRegnInfo = pDevRegnInfo->pNext ) {

        if ( pDevRegnInfo->hDevice == hDevice ) {

            pfnQueryRemove  = pDevRegnInfo->pfnQueryRemove;
            pData           = pDevRegnInfo->pData;
            break;
        }
    }
    LeaveRouterSem();

    return pfnQueryRemove ? pfnQueryRemove(pData) : NO_ERROR;
}


DWORD
SplProcessPnPEvent(
    DWORD       dwEventType,
    LPVOID      lpEventData,
    PVOID       pVoid
    )
{
    HANDLE                  hThread;
    DWORD                   dwThread, dwReturn = NO_ERROR;
    PDEV_BROADCAST_HANDLE   pBroadcast;

    DBGMSG(DBG_INFO,
           ("SplProcessPnPEvent: dwEventType: %d\n", dwEventType));

    switch (dwEventType) {

        case DBT_CONFIGCHANGED:
            hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ConfigChangeThread,
                                   NULL,
                                   0,
                                   &dwThread);

            if ( hThread )
                CloseHandle(hThread);

            break;

        case DBT_DEVICEARRIVAL:
        case DBT_DEVICEREMOVECOMPLETE:
            //
            // In case of device arrival we need to see if there are new ports
            // and in case of device removal monitors might want to mark ports
            // as removed so next reboot they do not have to enumerate them
            // ex. USB does this.
            //
            // We use the default process stack size for this thread. Currently 16KB.
            //
            hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ReenumeratePortsThread,
                                   NULL,
                                   0,
                                   &dwThread);

            if ( hThread )
                CloseHandle(hThread);

            break;

        case DBT_DEVICEQUERYREMOVE:
            pBroadcast = (PDEV_BROADCAST_HANDLE)lpEventData;

            //
            // These checks are to see if we really care about this
            //
            if ( !pBroadcast    ||
                  pBroadcast->dbch_devicetype != DBT_DEVTYP_HANDLE )
                break;

            dwReturn = QueryRemove(pBroadcast->dbch_handle);
            break;

        case DBT_SHELLLOGGEDON:
        default:
            break;
    }

    return dwReturn;
}


VOID
RegisterForPnPEvents(
    VOID
    )
{
    DEV_BROADCAST_DEVICEINTERFACE  Filter;

    // Init the sync objects needed for device arrival thread management
    ThdOutEvent = CreateEvent(NULL, FALSE, FALSE, NULL);   // Manual reset, non-signaled state

    
    ZeroMemory(&Filter, sizeof(Filter));

    Filter.dbcc_size        = sizeof(Filter);
    Filter.dbcc_devicetype  = DBT_DEVTYP_DEVICEINTERFACE;
    CopyMemory(&Filter.dbcc_classguid,
               (LPGUID)&USB_PRINTER_GUID,
               sizeof(Filter.dbcc_classguid));
    

    if ( !(ghPNPNotify_USB = RegisterDeviceNotification(ghSplHandle,
                                                        &Filter,
                                                        DEVICE_NOTIFY_SERVICE_HANDLE) )) {

        DBGMSG(DBG_INFO,
               ("RegisterForPnPEvents: RegisterDeviceNotification failed for USB. Error %d\n",
                GetLastError()));
    } else {

        DBGMSG(DBG_WARNING,
               ("RegisterForPnPEvents: RegisterDeviceNotification succesful for USB\n"));
    }

    CopyMemory(&Filter.dbcc_classguid,
               (LPGUID)&GUID_DEVCLASS_INFRARED,
               sizeof(Filter.dbcc_classguid));
    

    if ( !(ghPNPNotify_IR = RegisterDeviceNotification(ghSplHandle,
                                                       &Filter,
                                                       DEVICE_NOTIFY_SERVICE_HANDLE) )) {

        DBGMSG(DBG_INFO,
               ("RegisterForPnPEvents: RegisterDeviceNotification failed for IRDA. Error %d\n",
                GetLastError()));
    } else {

        DBGMSG(DBG_WARNING,

               ("RegisterForPnPEvents: RegisterDeviceNotification succesful for IRDA\n"));
    }

}


BOOL
SplUnregisterForDeviceEvents(
    HANDLE  hNotify
    )
{
    PDEVICE_REGISTER_INFO   pDevRegnInfo, pPrev;

    EnterRouterSem();
    //
    // Find the registration in our list, remove it and then leave CS to
    // call unregister on it
    //
    for ( pDevRegnInfo = gpDevRegnInfo, pPrev = NULL ;
          pDevRegnInfo ;
          pPrev = pDevRegnInfo, pDevRegnInfo = pDevRegnInfo->pNext ) {

        if ( pDevRegnInfo->hNotify == hNotify ) {

            if ( pPrev )
                pPrev->pNext = pDevRegnInfo->pNext;
            else
                gpDevRegnInfo = pDevRegnInfo->pNext;

            break;
        }
    }
    LeaveRouterSem();

    if ( pDevRegnInfo ) {

        UnregisterDeviceNotification(pDevRegnInfo->hNotify);
        FreeSplMem(pDevRegnInfo);
        return TRUE;
    }

    return FALSE;
}


HANDLE
SplRegisterForDeviceEvents(
    HANDLE                      hDevice,
    LPVOID                      pData,
    PFN_QUERYREMOVE_CALLBACK    pfnQueryRemove
    )
{
    DEV_BROADCAST_HANDLE    Filter;
    PDEVICE_REGISTER_INFO   pDevRegnInfo;

    ZeroMemory(&Filter, sizeof(Filter));

    Filter.dbch_size        = sizeof(Filter);
    Filter.dbch_devicetype  = DBT_DEVTYP_HANDLE;
    Filter.dbch_handle      = hDevice;
    
    pDevRegnInfo = (PDEVICE_REGISTER_INFO)
                        AllocSplMem(sizeof(DEVICE_REGISTER_INFO));

    if ( !pDevRegnInfo )
        goto Fail;

    pDevRegnInfo->hDevice           = hDevice;
    pDevRegnInfo->pData             = pData;
    pDevRegnInfo->pfnQueryRemove    = pfnQueryRemove;
    pDevRegnInfo->hNotify           = RegisterDeviceNotification(
                                                ghSplHandle,
                                                &Filter,
                                                DEVICE_NOTIFY_SERVICE_HANDLE);

    if ( pDevRegnInfo->hNotify ) {

        EnterRouterSem();
        pDevRegnInfo->pNext = gpDevRegnInfo;
        gpDevRegnInfo = pDevRegnInfo;
        LeaveRouterSem();

        return pDevRegnInfo->hNotify;
    }

    FreeSplMem(pDevRegnInfo);

Fail:
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\threadm.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    ThreadM.h

Abstract:

    Generic thread manager header.

Author:

    Albert Ting (AlbertT) 13-Feb-1994

Environment:

    User Mode -Win32

Revision History:

--*/

//
// Forward typedefs
//
typedef struct _TMSTATEVAR *PTMSTATEVAR;
typedef enum _TMSTATUS {
    TMSTATUS_NULL = 0,
    TMSTATUS_DESTROY_REQ = 1,
    TMSTATUS_DESTROYED   = 2,
} TMSTATUS, *PTMSTATUS;

/* ----------

Valid TMSTATUS states:

NULL                     --  Normal processing
DESTROY_REQ              --  No new jobs, jobs possibly running
DESTROY_REQ, DESTROYED   --  No new jobs, all jobs completed

  ----------- */


typedef PVOID PJOB;

//
// pfnNextJob must synchronize access on its own
//
typedef PJOB (*PFNNEXTJOB)(PTMSTATEVAR pTMStateVar);
typedef VOID (*PFNPROCESSJOB)(PTMSTATEVAR pTMStateVar, PJOB pJob);
typedef VOID (*PFNNEWSTATE)(PTMSTATEVAR pTMStateVar);
typedef VOID (*PFNCLOSESTATE)(PTMSTATEVAR pTMStateVar);

typedef struct _TMSTATESTATIC {
    UINT   uMaxThreads;
    UINT   uIdleLife;
    PFNPROCESSJOB pfnProcessJob;
    PFNNEXTJOB    pfnNextJob;
    PFNNEWSTATE   pfnNewState;
    PFNCLOSESTATE pfnCloseState;
    PCRITICAL_SECTION pCritSec;
} TMSTATESTATIC, *PTMSTATESTATIC;

typedef struct _TMSTATEVAR {

//  --- Internal --
    PTMSTATESTATIC pTMStateStatic;
    TMSTATUS Status;
    UINT uActiveThreads;
    UINT uIdleThreads;
    HANDLE hTrigger;

//  --- Initialized by user --
    PVOID  pUser;                        // User space

} TMSTATEVAR;


//
// Prototypes
//
BOOL
TMCreateStatic(
    PTMSTATESTATIC pTMStateStatic
    );

VOID
TMDestroyStatic(
    PTMSTATESTATIC pTMStateStatic
    );

BOOL
TMCreate(
    PTMSTATESTATIC pTMStateStatic,
    PTMSTATEVAR pTMStateVar
    );

BOOL
TMDestroy(
    PTMSTATEVAR pTMStateVar
    );

BOOL
TMAddJob(
    PTMSTATEVAR pTMStateVar
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\dll\winspool.c ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation

Module Name:

    winspool.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Print Providor Routing layer

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

[Notes:]

    optional-notes

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#include "local.h"

//
// Globals
//

LPPROVIDOR  pLocalProvidor;
MODULE_DEBUG_INIT( DBG_ERROR, DBG_ERROR );

LPWSTR szRegistryProvidors = L"System\\CurrentControlSet\\Control\\Print\\Providers";
LPWSTR szPrintKey          = L"System\\CurrentControlSet\\Control\\Print";
LPWSTR szLocalSplDll       = L"localspl.dll";
LPWSTR szOrder             = L"Order";
LPWSTR szEnvironment       = LOCAL_ENVIRONMENT;


//
// Strings for handling the AddPrinterDrivers policy
//
LPWSTR szLanManProvider    = L"LanMan Print Services";
LPWSTR szAPDRelPath        = L"LanMan Print Services\\Servers";
LPWSTR szAPDValueName      = L"AddPrinterDrivers";

BOOL
AddPrinterDriverW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpAddPrinterDriver) (pName, Level, pDriverInfo)) {

            return TRUE;

        } else if (GetLastError() != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
AddPrinterDriverExW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpAddPrinterDriverEx) (pName,
                                                              Level,
                                                              pDriverInfo,
                                                              dwFileCopyFlags)) {

            return TRUE;

        } else if (GetLastError() != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
AddDriverCatalog(
    HANDLE     hPrinter,
    DWORD      dwLevel,
    VOID       *pvDriverInfCatInfo,
    DWORD      dwCatalogCopyFlags
)
{
    HRESULT hRetval = E_FAIL;
    LPPRINTHANDLE   pPrintHandle = (LPPRINTHANDLE)hPrinter;

    hRetval = pPrintHandle && (PRINTHANDLE_SIGNATURE == pPrintHandle->signature) ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = (*pPrintHandle->pProvidor->PrintProvidor.fpAddDriverCatalog) (pPrintHandle->hPrinter,
                                                                                dwLevel, pvDriverInfCatInfo, dwCatalogCopyFlags);
    }

    if (FAILED(hRetval))
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return hRetval;
}

BOOL
EnumPrinterDriversW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDrivers,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PROVIDOR *pProvidor;

    if ((pDrivers == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (!(*pProvidor->PrintProvidor.fpEnumPrinterDrivers) (pName, pEnvironment, Level,
                                                 pDrivers, cbBuf,
                                                 pcbNeeded, pcReturned)) {

            if (GetLastError() != ERROR_INVALID_NAME)
                return FALSE;

        } else

            return TRUE;

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
GetPrinterDriverDirectoryW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    LPPROVIDOR  pProvidor;
    DWORD   Error;

    if ((pDriverInfo == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpGetPrinterDriverDirectory)
                                (pName, pEnvironment, Level, pDriverInfo,
                                 cbBuf, pcbNeeded)) {

            return TRUE;

        } else if ((Error=GetLastError()) != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

BOOL
DeletePrinterDriverW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pDriverName
)
{
    LPPROVIDOR  pProvidor;
    DWORD   Error;

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpDeletePrinterDriver)
                                (pName, pEnvironment, pDriverName)) {

            return TRUE;

        } else if ((Error=GetLastError()) != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

BOOL
DeletePrinterDriverExW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pDriverName,
    DWORD   dwDeleteFlag,
    DWORD   dwVersionNum
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;
    while (pProvidor) {
       if ((*pProvidor->PrintProvidor.fpDeletePrinterDriverEx)
                (pName, pEnvironment, pDriverName, dwDeleteFlag, dwVersionNum)) {
          return TRUE;
       }
       if (GetLastError() != ERROR_INVALID_NAME) {
          return FALSE;
       }
       pProvidor = pProvidor->pNext;
    }
    return FALSE;
}

BOOL
AddPrintProcessorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPathName,
    LPWSTR  pPrintProcessorName
)
{
    LPPROVIDOR  pProvidor;

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpAddPrintProcessor) (pName, pEnvironment,
                                               pPathName,
                                               pPrintProcessorName)) {

            return TRUE;

        } else if (GetLastError() != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
EnumPrintProcessorsW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    LPPROVIDOR  pProvidor;

    if ((pPrintProcessors == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (!(*pProvidor->PrintProvidor.fpEnumPrintProcessors) (pName, pEnvironment, Level,
                                                  pPrintProcessors, cbBuf,
                                                  pcbNeeded, pcReturned)) {

            if (GetLastError() != ERROR_INVALID_NAME)
                return FALSE;

        } else

            return TRUE;

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
GetPrintProcessorDirectoryW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    LPPROVIDOR  pProvidor;
    DWORD   Error;

    if ((pPrintProcessorInfo == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpGetPrintProcessorDirectory)
                                (pName, pEnvironment, Level,
                                 pPrintProcessorInfo,
                                 cbBuf, pcbNeeded)) {

            return TRUE;

        } else if ((Error=GetLastError()) != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);

    return FALSE;
}

BOOL
EnumPrintProcessorDatatypesW(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    LPPROVIDOR  pProvidor;

    if ((pDatatypes == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    WaitForSpoolerInitialization();

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if (!(*pProvidor->PrintProvidor.fpEnumPrintProcessorDatatypes)
                                                 (pName, pPrintProcessorName,
                                                  Level, pDatatypes, cbBuf,
                                                  pcbNeeded, pcReturned)) {

            if (GetLastError() != ERROR_INVALID_NAME)
                return FALSE;

        } else

            return TRUE;

        pProvidor = pProvidor->pNext;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}


BOOL
AddFormW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpAddForm) (pPrintHandle->hPrinter,
                                                  Level, pForm);
}

BOOL
DeleteFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpDeleteForm) (pPrintHandle->hPrinter,
                                                     pFormName);
}

BOOL
GetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD Level,
    LPBYTE pForm,
    DWORD cbBuf,
    LPDWORD pcbNeeded
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pForm == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpGetForm) (pPrintHandle->hPrinter,
                                               pFormName, Level, pForm,
                                               cbBuf, pcbNeeded);
}

BOOL
SetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpSetForm) (pPrintHandle->hPrinter,
                                                  pFormName, Level, pForm);
}

BOOL
EnumFormsW(
   HANDLE hPrinter,
   DWORD    Level,
   LPBYTE   pForm,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pForm == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpEnumForms) (pPrintHandle->hPrinter,
                                                 Level, pForm, cbBuf,
                                                 pcbNeeded, pcReturned);
}


BOOL
DeletePrintProcessorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName
)
{
    LPPROVIDOR  pProvidor;
    DWORD   Error;

    WaitForSpoolerInitialization();

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    pProvidor = pLocalProvidor;

    while (pProvidor) {

        if ((*pProvidor->PrintProvidor.fpDeletePrintProcessor)
                                (pName, pEnvironment, pPrintProcessorName)) {

            return TRUE;

        } else if ((Error=GetLastError()) != ERROR_INVALID_NAME) {

            return FALSE;
        }

        pProvidor = pProvidor->pNext;
    }

    return FALSE;
}

LPPROVIDOR FindProvidor(
    HKEY    hProvidors,
    LPWSTR  pName
)

/*++
Function Description: Retrieves providor struct for a providor name.

Parameters: hProvidors     - handle to the Providors key
            pName          - name of the providor

Return Values: pProvidor if one is found; NULL otherwise
--*/

{
    LPPROVIDOR   pProvidor;
    WCHAR        szDllName[MAX_PATH];
    DWORD        dwError;
    DWORD        cbDllName;
    HKEY         hProvidor = NULL;

    szDllName[0] = L'\0';
    cbDllName = COUNTOF(szDllName);

    // Search the registry for the DLL Name to compare with lpName
    if ((dwError = RegOpenKeyEx(hProvidors, pName, 0, KEY_READ, &hProvidor)) ||

        (dwError = RegQueryValueEx(hProvidor, L"Name", NULL, NULL,
                                   (LPBYTE)szDllName, &cbDllName)))
    {
        SetLastError(dwError);
        if (hProvidor)
        {
            RegCloseKey(hProvidor);
        }
        return NULL;
    }

    RegCloseKey(hProvidor);

    // Loop thru the list of providors for the name of the dll
    for (pProvidor = pLocalProvidor;
         pProvidor;
         pProvidor = pProvidor->pNext)
    {
        if (!_wcsicmp(pProvidor->lpName, szDllName))
        {
            break;
        }
    }

    return pProvidor;
}

// Struct to maintain the new order of the providors
typedef struct _ProvidorList {
   struct _ProvidorList *pNext;
   LPPROVIDOR  pProvidor;
} ProvidorList;

BOOL AddNodeToProvidorList(
     LPPROVIDOR  pProvidor,
     ProvidorList **pStart
)

/*++
Function Description: Adds a node to the list of providors. Avoids duplicate entries in
                      the list

Parameters: pProvidor    -  providor to be added
            pStart       -  pointer to the pointer to the start of the list

Return Values: TRUE if successful; FALSE otherwise
--*/

{
     BOOL  bReturn = FALSE;
     ProvidorList **pTemp, *pNew;

     // No providor found
     if (!pProvidor) {
         goto CleanUp;
     }

     for (pTemp = pStart; *pTemp; pTemp = &((*pTemp)->pNext))
     {
         if ((*pTemp)->pProvidor == pProvidor)
         {
             // Duplicates in the order string is an error
             goto CleanUp;
         }
     }

     // Add new node
     if (pNew = AllocSplMem(sizeof(ProvidorList)))
     {
         pNew->pNext = NULL;
         pNew->pProvidor = pProvidor;
         *pTemp = pNew;
         bReturn = TRUE;
     }

CleanUp:

     return bReturn;
}


BOOL UpdateProvidorOrder(
    HKEY    hProvidors,
    LPWSTR  pOrder
)

/*++
Function Description: Updates the order of the providors in spooler and the registry.

Parameters:  hProvidors    -   handle to Providors registry key
             pOrder        -   multisz order of providors

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    BOOL       bReturn = FALSE, bRegChange = FALSE;
    DWORD      dwError, dwRequired, dwBytes, dwOldCount, dwNewCount;
    LPWSTR     pOldOrder = NULL, pStr;
    LPPROVIDOR pProvidor;

    // Maintain a list of the new order, so that error recovery is quick
    ProvidorList *pStart = NULL, *pTemp;

    // Loop thru the providor names in the new order
    for (pStr = pOrder, dwBytes = 0;
         pStr && *pStr;
         pStr += (wcslen(pStr) + 1))
    {
        pProvidor = FindProvidor(hProvidors, pStr);

        if (!AddNodeToProvidorList(pProvidor, &pStart)) {
            goto CleanUp;
        }

        dwBytes += (wcslen(pStr) + 1) * sizeof(WCHAR);
    }
    // Add the sizeof the last NULL char
    dwBytes += sizeof(WCHAR);

    // Make sure that all the providors are present in the list
    for (dwOldCount = 0, pProvidor = pLocalProvidor;
         pProvidor;
         ++dwOldCount, pProvidor = pProvidor->pNext) ;

    // Add 1 for the local providor which does not appear on the list
    for (dwNewCount = 1, pTemp = pStart;
         pTemp;
         ++dwNewCount, pTemp = pTemp->pNext) ;

    if (dwNewCount == dwOldCount) {

        // Update the registry
        if (dwError = RegSetValueEx(hProvidors, szOrder, 0,
                                    REG_MULTI_SZ, (LPBYTE)pOrder, dwBytes))
        {
            SetLastError(dwError);
            goto CleanUp;
        }

        // Change the order in the spooler structure
        for (pTemp = pStart, pProvidor = pLocalProvidor;
             pTemp;
             pTemp = pTemp->pNext, pProvidor = pProvidor->pNext)
        {
            pProvidor->pNext = pTemp->pProvidor;
        }

        pProvidor->pNext = NULL;

        bReturn = TRUE;

    } else {

        // All the providors are not listed in the order
        SetLastError(ERROR_INVALID_PARAMETER);
    }

CleanUp:
    // Free the temp list
    while (pTemp = pStart) {
       pStart = pTemp->pNext;
       FreeSplMem(pTemp);
    }

    return bReturn;
}

BOOL AddNewProvidor(
    HKEY    hProvidors,
    PPROVIDOR_INFO_1W pProvidorInfo
)

/*++
Function Description: This function updates the registry with the new providor info and the
                      new providor order. The new providor is appended to the current order.
                      This order can be changed by calling AddPrintProvidor with
                      Providor_info_2. The providor is immediately used for routing.

Parameters:     hProvidors      -  providors registry key
                pProvidorInfo   -  ProvidorInfo1 struct

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    BOOL    bReturn = FALSE, bOrderUpdated = FALSE, bPresent = FALSE;
    DWORD   dwError, dwRequired, dwReturned, dwOldSize, dwDisposition = 0;
    DWORD   cchProvidorNameLen =  MAX_PATH+COUNTOF(szRegistryProvidors);
    WCHAR   szProvidorName[MAX_PATH+COUNTOF(szRegistryProvidors)];
    LPWSTR  pOldOrder = NULL, pNewOrder = NULL;
    HKEY    hNewProvidor = NULL;

    LPPROVIDOR pNewProvidor, pProvidor, pLastProvidor;

    if (!pProvidorInfo->pName || !pProvidorInfo->pDLLName || 
        !(*pProvidorInfo->pName) || !(*pProvidorInfo->pDLLName)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto CleanUp;
    }
        
    for (pProvidor = pLocalProvidor; // Local Providor is always present
         pProvidor;
         pProvidor = pProvidor->pNext) 
    {
        pLastProvidor = pProvidor;
        if (!lstrcmpi(pProvidor->lpName, pProvidorInfo->pDLLName))
        {
            //
            // This should return error, but it breaks some programs that
            // assume they can always add a provider
            //
            //SetLastError(ERROR_ALREADY_EXISTS);
            bReturn = TRUE;
            goto CleanUp;
        }
     }

    // Update the registry with new providor key
    if ((dwError = RegCreateKeyEx(hProvidors, pProvidorInfo->pName, 0, NULL, 0,
                                  KEY_ALL_ACCESS, NULL, &hNewProvidor, &dwDisposition)) ||

        (dwError = RegSetValueEx(hNewProvidor, L"Name", 0, REG_SZ,
                                 (LPBYTE)pProvidorInfo->pDLLName,
                                 (wcslen(pProvidorInfo->pDLLName)+1) * sizeof(WCHAR))))
    {
        SetLastError(dwError);
        goto CleanUp;
    }

    // Close the handle
    RegCloseKey(hNewProvidor);
    hNewProvidor = NULL;

    // Append to the order value
    dwRequired = 0;
    dwError = RegQueryValueEx(hProvidors, szOrder, NULL, NULL, NULL, &dwRequired);

    switch (dwError) {

    case ERROR_SUCCESS:
        if ((dwOldSize = dwRequired) &&
            (pOldOrder = AllocSplMem(dwRequired)) &&
            !(dwError = RegQueryValueEx(hProvidors, szOrder, NULL, NULL,
                                        (LPBYTE) pOldOrder, &dwRequired)))
        {
            break;
        }
        else
        {
            if (dwError) {
                SetLastError(dwError);
            }
            goto CleanUp;
        }

    case ERROR_FILE_NOT_FOUND:
        break;

    default:

        SetLastError(dwError);
        goto CleanUp;
    }

    // Append the new providor to the current order
    pNewOrder = (LPWSTR)AppendOrderEntry(pOldOrder, dwRequired,
                                         pProvidorInfo->pName, &dwReturned);
    if (!pNewOrder ||
        (dwError = RegSetValueEx(hProvidors, szOrder, 0,
                                 REG_MULTI_SZ, (LPBYTE)pNewOrder, dwReturned)))
    {
        if (dwError) {
            SetLastError(dwError);
        }
        goto CleanUp;
    }

    bOrderUpdated = TRUE;

    // Initialize the providor and update the spooler structure
    StringCchPrintf(szProvidorName,
                    cchProvidorNameLen,
                    L"%ws\\%ws", 
                    szRegistryProvidors, 
                    pProvidorInfo->pName);

    pNewProvidor = InitializeProvidor(pProvidorInfo->pDLLName, szProvidorName);

    if (pNewProvidor)
    {
        pNewProvidor->pNext = NULL;
        pLastProvidor->pNext = pNewProvidor;
        bReturn = TRUE;
    }

CleanUp:

    // Roll back if anything fails
    if (!bReturn)
    {
        // Remove the new providor key if it was created
        if (dwDisposition == REG_CREATED_NEW_KEY) 
        {
            DeleteSubKeyTree(hProvidors, pProvidorInfo->pName);
            RegDeleteKey(hProvidors, pProvidorInfo->pName);
        }

        // Restore the old order if it has been changed
        if (bOrderUpdated) {
            if (pOldOrder)
            {
                RegSetValueEx(hProvidors, szOrder, 0,
                              REG_MULTI_SZ, (LPBYTE)pOldOrder, dwOldSize);
            }
            else
            {
                RegDeleteValue(hProvidors, szOrder);
            }
        }
    }

    // Free allocated memory
    if (pOldOrder) {
        FreeSplMem(pOldOrder);
    }
    if (pNewOrder) {
        FreeSplMem(pNewOrder);
    }
    if (hNewProvidor) {
        RegCloseKey(hNewProvidor);
    }

    return bReturn;
}

BOOL AddPrintProvidorW(
    LPWSTR  pName,
    DWORD   dwLevel,
    LPBYTE  pProvidorInfo
)

/*++
Function Description: This function adds and initializes a print providor. It also updates the
                      registry and the order of print providors.

Parameters:  pName         -   server name for routing (currently ignored)
             dwLevel       -   providor info level
             pProvidorInfo -   providor info buffer

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    BOOL    bReturn = FALSE;
    DWORD   dwError = ERROR_SUCCESS;
    HANDLE  hToken;
    HKEY    hProvidors = NULL;

    WaitForSpoolerInitialization();

    EnterRouterSem();

    // Revert to spooler security context before accessing the registry
    //
    // This is a really bad idea, as it enables any user to get system 
    // priveleges without even trying.
    //
    // hToken = RevertToPrinterSelf();

    // Check for invalid parameters
    if (!pProvidorInfo)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto CleanUp;
    }

    if (dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryProvidors, 0,
                                 NULL, 0, KEY_ALL_ACCESS, NULL, &hProvidors, NULL))
    {
        SetLastError(dwError);
        goto CleanUp;
    }

    switch (dwLevel) {
    case 1:
        bReturn = AddNewProvidor(hProvidors,
                                 (PPROVIDOR_INFO_1W) pProvidorInfo);
        break;

    case 2:
        bReturn = UpdateProvidorOrder(hProvidors,
                                      ((PPROVIDOR_INFO_2W) pProvidorInfo)->pOrder);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        break;
    }

CleanUp:

    if (hProvidors) {
        RegCloseKey(hProvidors);
    }

    if (!bReturn && !GetLastError()) {
        // Last error should be set by individual functions. In the event that something
        // is not already set, return a placeholder error code
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    LeaveRouterSem();

    // ImpersonatePrinterClient(hToken);

    return bReturn;
}

BOOL DeletePrintProvidorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pProvidorName
)

/*++
Function Description: Deletes a print providor by updating the registry and the
                      removing it from the list of routing providors.

Parameters: pName          -   server name for routing (currently ignored)
            pEnvironment   -   environment name (currently ignored)
            pProvidorName  -   providor name

Return Values: TRUE if successful; FALSE otherwise
--*/

{
    BOOL    bReturn = FALSE;
    DWORD   dwError = ERROR_SUCCESS, dwRequired, dwReturned;
    LPWSTR  pOldOrder = NULL, pNewOrder = NULL;
    HANDLE  hToken;
    HKEY    hProvidors = NULL;
    BOOL    bSaveAPDPolicy = FALSE;
    DWORD   APDValue;

    LPPROVIDOR   pProvidor, pTemp;

    WaitForSpoolerInitialization();

    EnterRouterSem();

    // Revert to spooler security context before accessing the registry
    //
    // Or rather, Don't.
    //
    //hToken = RevertToPrinterSelf();

    // Check for invalid parameters
    if (!pProvidorName || !*pProvidorName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto CleanUp;
    }

    if (dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegistryProvidors, 0,
                                 NULL, 0, KEY_ALL_ACCESS, NULL, &hProvidors, NULL))
    {
        SetLastError(dwError);
        goto CleanUp;
    }

    // Save the pProvidor before deleting the registry entry
    if (!(pProvidor = FindProvidor(hProvidors, pProvidorName)))
    {
        goto CleanUp;
    }

    // Update the order
    dwRequired = 0;
    if (dwError = RegQueryValueEx(hProvidors, szOrder, NULL, NULL, NULL, &dwRequired))
    {
        SetLastError(dwError);
        goto CleanUp;
    }

    if (!dwRequired ||
        !(pOldOrder = AllocSplMem(dwRequired)) ||
        (dwError = RegQueryValueEx(hProvidors, szOrder, NULL, NULL,
                                   (LPBYTE) pOldOrder, &dwRequired)))
    {
        if (dwError) {
           SetLastError(dwError);
        }
        goto CleanUp;
    }

    // Remove the providor from the current order
    pNewOrder = (LPWSTR)RemoveOrderEntry(pOldOrder, dwRequired,
                                         pProvidorName, &dwReturned);
    if (!pNewOrder ||
        (dwError = RegSetValueEx(hProvidors, szOrder, 0,
                                 REG_MULTI_SZ, (LPBYTE)pNewOrder, dwReturned)))
    {
        if (dwError) {
            SetLastError(dwError);
        }
        goto CleanUp;
    }

    //
    // The AddPrinterDrivers policy has the registry value in the wrong place
    // under the lanman print services key. The lanman provider is deleted
    // during upgrade from Windows 2000 to XP. We save the AddPrinterDrivers
    // value and restore it after we delete the registry tree for the provider.
    //
    if (!_wcsicmp(szLanManProvider, pProvidorName)) 
    {
        bSaveAPDPolicy = GetAPDPolicy(hProvidors,
                                      szAPDRelPath,
                                      szAPDValueName,
                                      &APDValue) == ERROR_SUCCESS;
    }

    //
    // Delete the registry key
    //
    DeleteSubKeyTree(hProvidors, pProvidorName);

    //
    // Restore the AddPrinterDrivers policy if needed.
    //
    if (bSaveAPDPolicy) 
    {
        SetAPDPolicy(hProvidors,
                     szAPDRelPath,
                     szAPDValueName,
                     APDValue);
    }

    // Remove from the linked list of providors for routing
    for (pTemp = pLocalProvidor;
         pTemp->pNext; // Local Providor is always present and cant be deleted
         pTemp = pTemp->pNext)
    {
        if (pTemp->pNext == pProvidor) {
            // dont release the library and the struct since they may be used in
            // other threads
            pTemp->pNext = pProvidor->pNext;
            break;
        }
    }

    bReturn = TRUE;

CleanUp:

    if (!bReturn && !GetLastError()) {
        // Last error should be set by individual functions. In the event that something
        // is not already set, return a placeholder error code
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Free allocated memory
    if (pOldOrder) {
        FreeSplMem(pOldOrder);
    }
    if (pNewOrder) {
        FreeSplMem(pNewOrder);
    }
    if (hProvidors) {
        RegCloseKey(hProvidors);
    }

    LeaveRouterSem();

    // ImpersonatePrinterClient(hToken);

    return bReturn;
}

BOOL
OldGetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pDriverInfo == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    return (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinterDriver)
                       (pPrintHandle->hPrinter, pEnvironment,
                        Level, pDriverInfo, cbBuf, pcbNeeded);
}




BOOL
GetPrinterDriverExW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVersion,
    DWORD   dwClientMinorVersion,
    PDWORD  pdwServerMajorVersion,
    PDWORD  pdwServerMinorVersion
)
{
    LPPRINTHANDLE  pPrintHandle=(LPPRINTHANDLE)hPrinter;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if ((pDriverInfo == NULL) && (cbBuf != 0)) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    if (!pEnvironment || !*pEnvironment)
        pEnvironment = szEnvironment;

    if (pPrintHandle->pProvidor->PrintProvidor.fpGetPrinterDriverEx) {

        DBGMSG(DBG_TRACE, ("Calling the fpGetPrinterDriverEx function\n"));

        return (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinterDriverEx)
                       (pPrintHandle->hPrinter, pEnvironment,
                        Level, pDriverInfo, cbBuf, pcbNeeded,
                        dwClientMajorVersion, dwClientMinorVersion,
                        pdwServerMajorVersion, pdwServerMinorVersion);
    } else {

        //
        // The print providor does not support versioning of drivers
        //
        DBGMSG(DBG_TRACE, ("Calling the fpGetPrinterDriver function\n"));
        *pdwServerMajorVersion = 0;
        *pdwServerMinorVersion = 0;
        return (*pPrintHandle->pProvidor->PrintProvidor.fpGetPrinterDriver)
                    (pPrintHandle->hPrinter, pEnvironment,
                     Level, pDriverInfo, cbBuf, pcbNeeded);
    }
}



BOOL
GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD dwServerMajorVersion;
    DWORD dwServerMinorVersion;

    return  GetPrinterDriverExW( hPrinter,
                                 pEnvironment,
                                 Level,
                                 pDriverInfo,
                                 cbBuf,
                                 pcbNeeded,
                                 (DWORD)-1,
                                 (DWORD)-1,
                                 &dwServerMajorVersion,
                                 &dwServerMinorVersion );
}




BOOL
XcvDataW(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus
)
{
    LPPRINTHANDLE   pPrintHandle=(LPPRINTHANDLE)hXcv;

    if (!pPrintHandle || pPrintHandle->signature != PRINTHANDLE_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    return (*pPrintHandle->pProvidor->PrintProvidor.fpXcvData)( pPrintHandle->hPrinter,
                                                                pszDataName,
                                                                pInputData,
                                                                cbInputData,
                                                                pOutputData,
                                                                cbOutputData,
                                                                pcbOutputNeeded,
                                                                pdwStatus);
}



/*++

Routine Name:

    GetJobAttributes 
        
Routine Description:

    GetJobAttributes gets information about the job. 
    This includes nup and reverse printing options.

Arguments:

    pPrinterName      -- name of the printer.
    pDevmode          -- Devmode to be passed to the driver
    pAttributeInfo    -- buffer to place information about the job 

Return Value:

    TRUE if successful, FALSE otherwise.

--*/

BOOL
GetJobAttributes(
    LPWSTR            pPrinterName,
    LPDEVMODEW        pDevmode,
    PATTRIBUTE_INFO_3 pAttributeInfo
    )
{
    HANDLE           hDrvPrinter = NULL;
    BOOL             bReturn = FALSE, bDefault = FALSE;
    FARPROC          pfnDrvQueryJobAttributes;
    HINSTANCE        hDrvLib = NULL;
    fnWinSpoolDrv    fnList;

    // Get the pointer to the client side functions from the router
    if (!SplInitializeWinSpoolDrv(&fnList)) {
        return FALSE;
    }

    // Get a client side printer handle to pass to the driver
    if (!(* (fnList.pfnOpenPrinter))(pPrinterName, &hDrvPrinter, NULL)) {
        //ODS(("Open printer failed\nPrinter %ws\n",pPrinterName));
        goto CleanUp;
    }

    // Load the driver config file
    if (!(hDrvLib = (* (fnList.pfnLoadPrinterDriver))(hDrvPrinter))) {
        //ODS(("DriverDLL could not be loaded\n"));
        goto CleanUp;
    }

    // Call the DrvQueryJobAtributes function in the driver
    if (pfnDrvQueryJobAttributes = GetProcAddress(hDrvLib, "DrvQueryJobAttributes")) {

        if (!(* pfnDrvQueryJobAttributes) (hDrvPrinter,
                                           pDevmode,
                                           3,
                                           (LPBYTE) pAttributeInfo)) {

            if (!(* pfnDrvQueryJobAttributes) (hDrvPrinter,
                                               pDevmode,
                                               2,
                                               (LPBYTE) pAttributeInfo)) {

                if (!(* pfnDrvQueryJobAttributes) (hDrvPrinter,
                                                   pDevmode,
                                                   1,
                                                   (LPBYTE) pAttributeInfo)) {

                    bDefault = TRUE;

                } else {

                    pAttributeInfo->dwColorOptimization = 0;
                }

            } else {
               
                pAttributeInfo->dmPrintQuality = pDevmode->dmPrintQuality;
                pAttributeInfo->dmYResolution = pDevmode->dmYResolution;
            }
        }

    } else {
        
        bDefault = TRUE;
    }

    if (bDefault) {
        // Set default values for old drivers that don't export the function
        pAttributeInfo->dwJobNumberOfPagesPerSide = 1;
        pAttributeInfo->dwDrvNumberOfPagesPerSide = 1;
        pAttributeInfo->dwNupBorderFlags = 0;
        pAttributeInfo->dwJobPageOrderFlags = 0;
        pAttributeInfo->dwDrvPageOrderFlags = 0;
        pAttributeInfo->dwJobNumberOfCopies = pDevmode->dmCopies;
        pAttributeInfo->dwDrvNumberOfCopies = pDevmode->dmCopies;
        pAttributeInfo->dwColorOptimization = 0;       
    }

    bReturn = TRUE;

CleanUp:

    if (hDrvPrinter) {
        (* (fnList.pfnClosePrinter))(hDrvPrinter);
    }
    if (hDrvLib) {
        (* (fnList.pfnRefCntUnloadDriver))(hDrvLib, TRUE);
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\idl\import.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:

    Adina Trufinescu (adinatru) 12-Dec-1999
    Define LPDEVMODEW and PSECURITY_DESCRIPTOR as pointers in order to
    let RPC do the conversion from a 32bit to a 64bit quantity. Make sure 
    these pointers are set on NULL all over the place where use PRINTER_CONTAINER,
    otherwise RPC will get confused when try to marshall.
--*/

#ifdef MIDL_PASS
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPDEVMODEW   ULONG_PTR
#define PSECURITY_DESCRIPTOR ULONG_PTR
#define HANDLE      ULONG_PTR
#define BOOL        DWORD
#endif

#include <winspool.h>
#include <winsplp.h>
#include <..\..\..\..\public\internal\printscan\inc\splapip.h>
#include <..\..\..\..\public\internal\windows\inc\winsprlp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\perf\lsplctr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    LsplCtr.h.hxx

Abstract:

    Specifies the indicies of the local spooler counters.

Author:

    Albert Ting (AlbertT)  19-Dec-1996

Revision History:

--*/

#ifndef LSPLCTR_HXX
#define LSPLCTR_HXX

#define LSPL_COUNTER_OBJECT                 0

//
// Counters must be incremented by 2 each time.
//

#define LSPL_TOTAL_JOBS                     2   // LI
#define LSPL_TOTAL_BYTES                    4   // LI
#define LSPL_TOTAL_PAGES_PRINTED            6   // LI
#define LSPL_JOBS                           8   // DW
#define LSPL_REF                            10  // DW
#define LSPL_MAX_REF                        12  // DW
#define LSPL_SPOOLING                       14  // DW
#define LSPL_MAX_SPOOLING                   16  // DW
#define LSPL_ERROR_OUT_OF_PAPER             18  // DW
#define LSPL_ERROR_NOT_READY                20  // DW
#define LSPL_JOB_ERROR                      22  // DW
#define LSPL_ENUMERATE_NETWORK_PRINTERS     24  // DW
#define LSPL_ADD_NET_PRINTERS               26  // DW

#endif // ifdef LSPLCTR_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\perf\lspldata.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    LsplData.cxx

Abstract:

    Specifies the indicies of the local spooler counters.

Author:

    Albert Ting (AlbertT)  19-Dec-1996
    Based on Gopher perf counter dll.

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lsplctr.h"
#include "lspldata.hxx"

#ifdef OFFSETOF
#undef OFFSETOF
#endif

#define OFFSETOF(type, id) ((DWORD)(ULONG_PTR)(&(((type*)0)->id)))

LSPL_DATA_DEFINITION LsplDataDefinition =
{
    {
        sizeof( LSPL_DATA_DEFINITION ) + sizeof( LSPL_COUNTER_DATA ),
        sizeof( LSPL_DATA_DEFINITION ),

        sizeof( PERF_OBJECT_TYPE ),
        LSPL_COUNTER_OBJECT,
        0,
        LSPL_COUNTER_OBJECT,
        0,
        PERF_DETAIL_NOVICE,
        NUMBER_OF_LSPL_COUNTERS,
        3,                          // Default is # jobs in queue.
        0,                          // Place holder for number of instances.
        0,
        { 0, 0 },
        { 0, 0 }
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_TOTAL_JOBS,
        0,
        LSPL_TOTAL_JOBS,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof( LARGE_INTEGER ),
        OFFSETOF( LSPL_COUNTER_DATA, liTotalJobs ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_TOTAL_BYTES,
        0,
        LSPL_TOTAL_BYTES,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof( LARGE_INTEGER ),
        OFFSETOF( LSPL_COUNTER_DATA, liTotalBytes ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_TOTAL_PAGES_PRINTED,
        0,
        LSPL_TOTAL_PAGES_PRINTED,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof( LARGE_INTEGER ),
        OFFSETOF( LSPL_COUNTER_DATA, liTotalPagesPrinted ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_JOBS,
        0,
        LSPL_JOBS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwJobs ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_REF,
        0,
        LSPL_REF,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwRef ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_MAX_REF,
        0,
        LSPL_MAX_REF,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwMaxRef ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_SPOOLING,
        0,
        LSPL_SPOOLING,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwSpooling ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_MAX_SPOOLING,
        0,
        LSPL_MAX_SPOOLING,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwMaxSpooling ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_ERROR_OUT_OF_PAPER,
        0,
        LSPL_ERROR_OUT_OF_PAPER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwErrorOutOfPaper ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_ERROR_NOT_READY,
        0,
        LSPL_ERROR_NOT_READY,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwErrorNotReady ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_JOB_ERROR,
        0,
        LSPL_JOB_ERROR,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwJobError ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_ENUMERATE_NETWORK_PRINTERS,
        0,
        LSPL_ENUMERATE_NETWORK_PRINTERS,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwEnumerateNetworkPrinters ),
    },
    {
        sizeof( PERF_COUNTER_DEFINITION ),
        LSPL_ADD_NET_PRINTERS,
        0,
        LSPL_ADD_NET_PRINTERS,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof( DWORD ),
        OFFSETOF( LSPL_COUNTER_DATA, dwAddNetPrinters ),
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\perf\localspl.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    localspl.cxx

Abstract:

    Localspl specific support routines for performance.

Author:

    Albert Ting (AlbertT)  19-Dec-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "perf.hxx"
#include "lspldata.hxx"
#include "splapip.h"
#include "winsprlp.h"
#include "ntprfctr.h"

/********************************************************************

    Globals

********************************************************************/

LPCTSTR gszAppName = TEXT( "SpoolerCtrs" );

BOOL gbInitialized = FALSE;
LPCWSTR gszTotal = L"_Total";

UINT gcbBufferHint = 0x800;
const UINT kBufferHintPad = 0x200;

DWORD
Pfp_dwBuildPrinterInstanceFromInfo(
    PPRINTER_INFO_STRESS pInfo,
    PBYTE* ppData,
    PDWORD pcbDataLeft,
    PLSPL_COUNTER_DATA *pplcd OPTIONAL
    );

DWORD
Pfp_dwBuildPrinterInstanceFromLCD(
    LPCWSTR pszName,
    PLSPL_COUNTER_DATA plcdSource,
    PBYTE* ppData,
    PDWORD pcbDataLeft
    );

/********************************************************************

    Required support routines

********************************************************************/


DWORD
Pf_dwClientOpen(
    LPCWSTR pszDeviceNames,
    PPERF_DATA_DEFINITION *pppdd
    )

/*++

Routine Description:

    Localspl specific intialization of the client data.

Arguments:

    pszDeviceNames - Passed in from performance apis.

Return Value:

    Status code.

--*/

{
    DWORD Status = ERROR_SUCCESS;
    *pppdd = reinterpret_cast<PPERF_DATA_DEFINITION>( &LsplDataDefinition );

    //
    // If not initialized before,
    //
    if( !gbInitialized )
    {
        //
        // Fix up the indicies in our ObjectType and CounterDefinitions.
        //

        Pf_vFixIndiciesFromIndex( LSPL_FIRST_COUNTER_INDEX,
                                  LSPL_FIRST_HELP_INDEX,
                                  *pppdd );
        
        gbInitialized = TRUE;        
    }


    return Status;
}


DWORD
Pf_dwClientCollect(
    PBYTE *ppData,
    PDWORD pcbDataLeft,
    PDWORD pcNumInstances
    )

/*++

Routine Description:

    Localspl specific collection of data.

Arguments:

Return Value:

    Status code.

--*/

{
    PPRINTER_INFO_STRESS pInfoBase;
    DWORD cbNeeded;
    DWORD cReturned;
    DWORD Error = ERROR_SUCCESS;
    BOOL bStatus;
    PBYTE pData = *ppData;
    DWORD cbDataLeft = *pcbDataLeft;

    pInfoBase = static_cast<PPRINTER_INFO_STRESS>(
                    LocalAlloc( LMEM_FIXED, gcbBufferHint ));

    if( !pInfoBase )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    //
    // Read the data via EnumPrinters(). We enumerate all the local printers and
    // any cluster printers hosted by the local machine.
    //
    bStatus = EnumPrinters( PRINTER_ENUM_LOCAL | PRINTER_ENUM_NAME | PRINTER_ENUM_CLUSTER,
                            NULL,
                            STRESSINFOLEVEL,
                            reinterpret_cast<PBYTE>( pInfoBase ),
                            gcbBufferHint,
                            &cbNeeded,
                            &cReturned );

    if( !bStatus && GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {
        //
        // Reallocate the buffer and update the hint.
        //
        gcbBufferHint = cbNeeded + kBufferHintPad;
        LocalFree( static_cast<HLOCAL>( pInfoBase ));

        pInfoBase = reinterpret_cast<PPRINTER_INFO_STRESS>(
                        LocalAlloc( LMEM_FIXED, gcbBufferHint ));

        if( !pInfoBase )
        {
            Error = GetLastError();
            goto Cleanup;
        }

        bStatus =  EnumPrinters( PRINTER_ENUM_LOCAL | PRINTER_ENUM_NAME | PRINTER_ENUM_CLUSTER,
                                 NULL,
                                 STRESSINFOLEVEL,
                                 reinterpret_cast<PBYTE>( pInfoBase ),
                                 gcbBufferHint,
                                 &cbNeeded,
                                 &cReturned );
    }

    if( !bStatus )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    //
    // Update the hint.
    //
    gcbBufferHint = cbNeeded + kBufferHintPad;

    UINT i;
    PPRINTER_INFO_STRESS pInfo;
    LSPL_COUNTER_DATA lcdTotal;
    PLSPL_COUNTER_DATA plcd;

    ZeroMemory( &lcdTotal, sizeof( lcdTotal ));

    for( i=0, pInfo = pInfoBase; i< cReturned; ++i, ++pInfo )
    {
        Error = Pfp_dwBuildPrinterInstanceFromInfo( pInfo,
                                                    &pData,
                                                    &cbDataLeft,
                                                    &plcd );

        if( Error != ERROR_SUCCESS ){
            goto Cleanup;
        }

        //
        // Add up the total.
        //
        lcdTotal.liTotalJobs.QuadPart        += plcd->liTotalJobs.QuadPart;
        lcdTotal.liTotalBytes.QuadPart       += plcd->liTotalBytes.QuadPart;
        lcdTotal.liTotalPagesPrinted.QuadPart+= plcd->liTotalPagesPrinted.QuadPart;
        lcdTotal.dwJobs                      += plcd->dwJobs;
        lcdTotal.dwMaxRef                    += plcd->dwMaxRef;
        lcdTotal.dwSpooling                  += plcd->dwSpooling;
        lcdTotal.dwMaxSpooling               += plcd->dwMaxSpooling;
        lcdTotal.dwRef                       += plcd->dwRef;
        lcdTotal.dwErrorOutOfPaper           += plcd->dwErrorOutOfPaper;
        lcdTotal.dwErrorNotReady             += plcd->dwErrorNotReady;
        lcdTotal.dwJobError                  += plcd->dwJobError;

        //
        // Only include EnumerateNetworkPrinters and dwAddNetPrinters
        // once,d since they are really globals (per-server not per-printer).
        //
        if( i == 0 )
        {
            lcdTotal.dwEnumerateNetworkPrinters = plcd->dwEnumerateNetworkPrinters;
            lcdTotal.dwAddNetPrinters           = plcd->dwAddNetPrinters;
        }
    }

    //
    // Add the last one.
    //
    Error = Pfp_dwBuildPrinterInstanceFromLCD( gszTotal,
                                               &lcdTotal,
                                               &pData,
                                               &cbDataLeft );

Cleanup:

    if( pInfoBase )
    {
        LocalFree( static_cast<HLOCAL>( pInfoBase ));
    }

    if( Error == ERROR_SUCCESS )
    {
        //
        // Update the pointers.  We will return cReturned+1 instances since
        // we built an artifical "_Total" instance.
        //
        *ppData = pData;
        *pcbDataLeft = cbDataLeft;
        *pcNumInstances = cReturned + 1;

        return ERROR_SUCCESS;
    }

    return Error;
}

VOID
Pf_vClientClose(
    VOID
    )

/*++

Routine Description:

    Localspl specific closure of data.

Arguments:

Return Value:

--*/

{
    //
    // Nothing to do since it is name based.
    //
}


/********************************************************************

    Helper functions.

********************************************************************/

DWORD
Pfp_dwBuildPrinterInstanceFromInfo(
    IN     PPRINTER_INFO_STRESS pInfo,
    IN OUT PBYTE* ppData,
    IN OUT PDWORD pcbDataLeft,
       OUT PLSPL_COUNTER_DATA *pplcd OPTIONAL
    )

/*++

Routine Description:

    Add a single pInfo structure to the performance data block.

Arguments:

    pInfo - Input data.

    ppData - On entry, pointer to buffer.  On exit, holds the next
        available space in buffer.  If an error is returned, this
        value is random.

    pcbDataLeft - On entry, size of buffer.  On exit, remaining size
        of buffer.  If an error is returned, this value is random.

    pplcd - Optional; on success returns pointer to lcd.

Return Value:

    ERROR_SUCCESS - Success, else failure code.

--*/

{
    DWORD Error;

    //
    // Add the instance definitions
    //
    Error = Pf_dwBuildInstance( 0,
                                0,
                                static_cast<DWORD>( PERF_NO_UNIQUE_ID ),
                                pInfo->pPrinterName,
                                ppData,
                                pcbDataLeft );

    if( Error != ERROR_SUCCESS )
    {
        goto Fail;
    }

    //
    // Check if there's enough space for our counter data.
    //
    if( *pcbDataLeft < sizeof( LSPL_COUNTER_DATA ))
    {
        Error = ERROR_MORE_DATA;
        goto Fail;
    }

    //
    // Convert ppData to a LSPL_COUNTER_DATA and copy everything over.
    //

    PLSPL_COUNTER_DATA plcd;

    plcd = reinterpret_cast<PLSPL_COUNTER_DATA>( *ppData );
    plcd->CounterBlock.ByteLength = sizeof( LSPL_COUNTER_DATA );

    plcd->liTotalJobs.HighPart = 0;
    plcd->liTotalBytes.HighPart = pInfo->dwHighPartTotalBytes;
    plcd->liTotalPagesPrinted.HighPart = 0;

    plcd->liTotalJobs.LowPart         = pInfo->cTotalJobs;
    plcd->liTotalBytes.LowPart        = pInfo->cTotalBytes;
    plcd->liTotalPagesPrinted.LowPart = pInfo->cTotalPagesPrinted;
    plcd->dwJobs                      = pInfo->cJobs;
    plcd->dwMaxRef                    = pInfo->MaxcRef;
    plcd->dwSpooling                  = pInfo->cSpooling;
    plcd->dwMaxSpooling               = pInfo->cMaxSpooling;
    plcd->dwRef                       = pInfo->cRef;
    plcd->dwErrorOutOfPaper           = pInfo->cErrorOutOfPaper;
    plcd->dwErrorNotReady             = pInfo->cErrorNotReady;
    plcd->dwJobError                  = pInfo->cJobError;
    plcd->dwEnumerateNetworkPrinters  = pInfo->cEnumerateNetworkPrinters;
    plcd->dwAddNetPrinters            = pInfo->cAddNetPrinters;

    //
    // Update the counters.
    //
    *ppData += sizeof( LSPL_COUNTER_DATA );
    *pcbDataLeft -= sizeof( LSPL_COUNTER_DATA );

    if( pplcd )
    {
        *pplcd = plcd;
    }

Fail:

    return Error;
}


DWORD
Pfp_dwBuildPrinterInstanceFromLCD(
    IN     LPCWSTR pszName,
    IN     PLSPL_COUNTER_DATA plcdSource,
    IN OUT PBYTE* ppData,
    IN OUT PDWORD pcbDataLeft
    )

/*++

Routine Description:

    Add a single LCD structure to the performance data block.

Arguments:

    pszName - Name of the block.

    plcd - Pointer to the LCD block to copy.

    ppData - On entry, pointer to buffer.  On exit, holds the next
        available space in buffer.  If an error is returned, this
        value is random.

    pcbDataLeft - On entry, size of buffer.  On exit, remaining size
        of buffer.  If an error is returned, this value is random.

Return Value:

    ERROR_SUCCESS - Success, else failure code.

--*/

{
    DWORD Error;

    //
    // Add the instance definitions
    //
    Error = Pf_dwBuildInstance( 0,
                                0,
                                static_cast<DWORD>( PERF_NO_UNIQUE_ID ),
                                pszName,
                                ppData,
                                pcbDataLeft );

    if( Error != ERROR_SUCCESS )
    {
        goto Fail;
    }

    //
    // Check if there's enough space for our counter data.
    //
    if( *pcbDataLeft < sizeof( LSPL_COUNTER_DATA ))
    {
        Error = ERROR_MORE_DATA;
        goto Fail;
    }

    //
    // Convert ppData to a LSPL_COUNTER_DATA and copy everything over.
    //

    PLSPL_COUNTER_DATA plcd;

    plcd = reinterpret_cast<PLSPL_COUNTER_DATA>( *ppData );

    CopyMemory( plcd, plcdSource, sizeof( LSPL_COUNTER_DATA ));
    plcd->CounterBlock.ByteLength = sizeof( LSPL_COUNTER_DATA );

    //
    // Update the counters.
    //
    *ppData += sizeof( LSPL_COUNTER_DATA );
    *pcbDataLeft -= sizeof( LSPL_COUNTER_DATA );

Fail:

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\perf\perf.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    perf.cxx

Abstract:

    Performance counter implementation

    // PerfDataBlock            // Not created here, but this block
                                //     exists before the real one that
                                //     we create.

    _PERF_OBJECT_TYPE           // There is one object type in this counter.
      00 Total size             // Size of entire returned structure
      04 Definition length      // Instance offset

+   _PERF_INSTANCE_DEFINITION
|     00 Total size             // Offset
|     04
|     08
|     0c Unique ID (-1)
|     10 Offset to Name
|     14 Name Length
|   _PERF_COUNTER_BLOCK
|     00 Total size             // Offset to next instance definition
|        <data> variable        // Holds struct of perf data
|                               //     (e.g., LSPL_COUNTER_DATA).
|
+----This entire block repeats, one per printer

Author:

    Albert Ting (AlbertT)  17-Dec-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "perf.hxx"
#include "perfp.hxx"
#include "messages.h"

/********************************************************************

    Forward prototypes

********************************************************************/

PM_OPEN_PROC PerfOpen;
PM_COLLECT_PROC PerfCollect;
PM_CLOSE_PROC PerfClose;

GLOBAL_PERF_DATA gpd;

LPCWSTR gszGlobal  = TEXT( "Global" );
LPCWSTR gszForeign = TEXT( "Foreign" );
LPCWSTR gszCostly  = TEXT( "Costly" );
LPCWSTR gszNULL    = TEXT( "" );

LPCTSTR gszLogLevelKeyName = TEXT( "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib" );
LPCTSTR gszLogLevelValueName = TEXT( "EventLogLevel" );


#define FOREIGN_LENGTH 7

/********************************************************************

    Performance interface functions:

        PerOpen, PerfCollect, PerfClose

********************************************************************/


DWORD
APIENTRY
PerfOpen(
    LPCWSTR pszDeviceNames
    )
{
    DWORD Status = ERROR_SUCCESS;

    if( !gpd.cOpens )
    {
        Status = Pf_dwClientOpen( pszDeviceNames, &gpd.ppdd );

        HKEY        hAppKey;
        DWORD   dwValueType;
        DWORD   dwValueSize;
        UINT    uLogLevel;

        LONG        lStatus;

        gpd.uLogLevel = kUser << kLevelShift;

        lStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                gszLogLevelKeyName,
                                0,
                                KEY_READ,
                                &hAppKey );

        dwValueSize = sizeof(uLogLevel);

        if (lStatus == ERROR_SUCCESS)
        {
            lStatus = RegQueryValueEx( hAppKey,
                                       gszLogLevelValueName,
                                       (LPDWORD)NULL,
                                       &dwValueType,
                                       (LPBYTE)&uLogLevel,
                                       &dwValueSize );

            if (lStatus == ERROR_SUCCESS)
            {
                gpd.uLogLevel = uLogLevel;
            }

            RegCloseKey(hAppKey);
        }
    }

    if( Status == ERROR_SUCCESS )
    {
        ++gpd.cOpens;
    }

    Pf_vReportEvent( kInformation | kDebug,
                     MSG_PERF_OPEN_CALLED,
                     sizeof( Status ),
                     &Status,
                     NULL );

    return Status;
}

DWORD
APIENTRY
PerfCollect(
    LPCWSTR pszValue,
    PBYTE *ppData,
    PDWORD pcbData,
    PDWORD pcObjectTypes
    )
{
    DWORD Status = ERROR_SUCCESS;
    DWORD cbObjectType;
    DWORD cbDataLeft;
    PBYTE pData = *ppData;
    DWORD cNumInstances;
    DWORD cbTotalSize;
    PPERF_OBJECT_TYPE ppot;

    //
    // pszValue can be NULL, in this case we consider it gszNULL.
    //
    pszValue = pszValue == NULL ? gszNULL : pszValue;

    //
    // We need to punt if we're:
    //
    //     Not initialized
    //     Foreign
    //     Costly
    //
    if( !gpd.cOpens ||
        !wcsncmp( pszValue, gszForeign, FOREIGN_LENGTH ) ||
        !wcscmp( pszValue, gszCostly ))
    {
        goto Fail;
    }

    //
    // If we're not global, then see if our title index is requested.
    //
    if( wcscmp( pszValue, gszGlobal ))
    {
        if( !Pfp_bNumberInUnicodeList(
                 gpd.ppdd->ObjectType.ObjectNameTitleIndex,
                 pszValue ))
        {
            goto Fail;
        }
    }

    //
    // Add the header information to the buffer if there is space.
    // First check if we have space.
    //
    cbObjectType = gpd.ppdd->ObjectType.DefinitionLength;
    if( *pcbData < cbObjectType )
    {
        //
        // Out of space; fail.
        //
        Status = ERROR_MORE_DATA;
        goto Fail;
    }

    //
    // Copy the data then update the space used.
    //
    CopyMemory( pData, &gpd.ppdd->ObjectType, cbObjectType );

    pData += cbObjectType;
    cbDataLeft = *pcbData - cbObjectType;

    //
    // Call back to the client to collect instance information.
    //
    Status = Pf_dwClientCollect( &pData,
                                 &cbDataLeft,
                                 &cNumInstances );

    if( Status != ERROR_SUCCESS )
    {
        goto Fail;
    }

    //
    // Update header information then return.
    //
    cbTotalSize = *pcbData - cbDataLeft;
    ppot = reinterpret_cast<PPERF_OBJECT_TYPE>(*ppData);
    ppot->NumInstances = cNumInstances;
    ppot->TotalByteLength = cbTotalSize;

    *ppData += cbTotalSize;
    *pcbData = cbTotalSize;
    *pcObjectTypes = 1;

    return ERROR_SUCCESS;

Fail:

    *pcbData = 0;
    *pcObjectTypes = 0;

    return Status;

}

DWORD
PerfClose(
    VOID
    )
{
    --gpd.cOpens;

    if( !gpd.cOpens )
    {
        //
        // Close everything.
        //
        Pf_vClientClose();

        Pf_vReportEvent( kInformation | kDebug,
                         MSG_PERF_CLOSE_CALLED,
                         0,
                         NULL,
                         NULL );

        //
        // If event log was opened, close it.
        //
        Pfp_vCloseEventLog();
    }

    return 0;
}


/********************************************************************

    Utility functions

********************************************************************/


LPCTSTR gszFirstCounter = TEXT( "First Counter" );
LPCTSTR gszFirstHelp = TEXT( "First Help" );

VOID
Pf_vFixIndiciesFromIndex(
    DWORD dwFirstCounter,
    DWORD dwFirstHelp,
    PPERF_DATA_DEFINITION ppdd
    )

/*++

Routine Description:

    Fix the offsets to the localized strings based on indicies.

Arguments:

    dwFirstCounter - Offset for counter text.

    dwFirstHelp - Offset for help text.

Return Value:

--*/

{
    //
    // Update object indicies.
    //
    ppdd->ObjectType.ObjectNameTitleIndex += dwFirstCounter;
    ppdd->ObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    //
    // Update all counter definitions.
    //
    UINT i;
    UINT cCounters = ppdd->ObjectType.NumCounters;
    PPERF_COUNTER_DEFINITION ppcd;

    for( i = 0, ppcd = ppdd->aCounterDefinitions;
         i < cCounters;
         ++i, ++ppcd )
    {
        ppcd->CounterNameTitleIndex += dwFirstCounter;
        ppcd->CounterHelpTitleIndex += dwFirstHelp;
    }
}


DWORD
Pf_dwFixIndiciesFromKey(
    LPCTSTR szPerformanceKey,
    PPERF_DATA_DEFINITION ppdd
    )

/*++

Routine Description:

    Open the performance key so that we can fix up the offsets
    of the localized strings.

Arguments:

    szPerformanceKey - Performance registry key.

Return Value:

    TRUE - Success
    FALSE - Failure

--*/

{
    HKEY    hkey = NULL;
    DWORD   dwFirstCounter;
    DWORD   dwFirstHelp;
    DWORD   cbSize = 0;
    DWORD   dwType;
    DWORD   Error;

    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szPerformanceKey,
                          0,
                          KEY_READ,
                          &hkey );

    if( Error == ERROR_SUCCESS )
    {
        //
        //  Read the first counter DWORD.
        //

        cbSize = sizeof(DWORD);

        Error = RegQueryValueEx( hkey,
                                 gszFirstCounter,
                                 NULL,
                                 &dwType,
                                 reinterpret_cast<LPBYTE>( &dwFirstCounter ),
                                 &cbSize );
    }

    if( Error == ERROR_SUCCESS )
    {
       //
       //  Read the first counter DWORD.
       //

       cbSize = sizeof(DWORD);

       Error = RegQueryValueEx( hkey,
                                gszFirstHelp,
                                NULL,
                                &dwType,
                                reinterpret_cast<LPBYTE>( &dwFirstHelp ),
                                &cbSize );
    }

    if( Error == ERROR_SUCCESS )
    {
        Pf_vFixIndiciesFromIndex( dwFirstCounter, dwFirstHelp, ppdd );
    }

    if ( hkey != NULL)
    {
        RegCloseKey( hkey );
    }

    return Error;
}


DWORD
Pf_dwBuildInstance(
    IN     DWORD dwParentObjectTitleIndex,
    IN     DWORD dwParentObjectInstance,
    IN     DWORD dwUniqueID,
    IN     LPCWSTR pszName,
    IN OUT PBYTE* ppData,
    IN OUT PDWORD pcbDataLeft
    )

/*++

Routine Description:

    Builds and initializes the variable structre PERF_INSTANCE_DEFINITION.

Arguments:

    dwParentObjectTitleIndex - Index of the parent object in the database.

    dwParentObjectInstance - Instance of the parent object (0 or greater).

    dwUniqueID - Id of the object.  May be PERF_NO_UNIQUE_ID.

    pszName - Name of the instance.

    ppData - On entry, holds the pointer to the buffer.  Should be QUADWORD
        aligned.  On exit, holds the next free QUADWORD aligned point in the
        buffer.  If this function fails, this is not modified.

   pcbDataLeft - On entry, holds the size of the buffer.  On exit, holds
        the space remaining (unused) in the buffer.  If this function
        fails, this is not modified.

Return Value:

    ERROR_SUCCESS - Success, else error code.

--*/

{
    //
    // First calculate if we have enough space.  (Assumes that the
    // PERF_INSTANCE_DEFINITION size is WORD aligned.)
    //
    UINT cbName = ( wcslen( pszName ) + 1 ) * sizeof( pszName[0] );
    UINT cbInstanceDefinition = sizeof( PERF_INSTANCE_DEFINITION ) + cbName;

    cbInstanceDefinition = QuadAlignUp( cbInstanceDefinition );

    if( *pcbDataLeft < cbInstanceDefinition )
    {
        return ERROR_MORE_DATA;
    }

    //
    // Build the structure.
    //
    PERF_INSTANCE_DEFINITION *pped;

    pped = reinterpret_cast<PPERF_INSTANCE_DEFINITION>( *ppData );

    pped->ByteLength = cbInstanceDefinition;
    pped->ParentObjectTitleIndex = dwParentObjectTitleIndex;
    pped->ParentObjectInstance = dwParentObjectInstance;
    pped->UniqueID = dwUniqueID;
    pped->NameOffset = sizeof( PERF_INSTANCE_DEFINITION );
    pped->NameLength = cbName;

    //
    // Move the pointer past this structure.
    //
    ++pped;

    //
    // Copy the name right after this structure. We change all / to , because
    // perfmon uses / to denote parent and child instances ( parent/child).
    //

    LPCWSTR pszSrc = pszName;
    for (LPWSTR pszDest = reinterpret_cast<LPWSTR>(pped) ; *pszSrc ; pszSrc++, pszDest++)
    {
        *pszDest = (*pszSrc == '/') ? ',' : *pszSrc ;
    }
    *pszDest = L'\0';

    //
    // Update the pointers.
    //
    *ppData += cbInstanceDefinition;
    *pcbDataLeft -= cbInstanceDefinition;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\perf\perfutil.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    perfutil.cxx

Abstract:

    Utility routines copied from sockets\internet\svcs\lib\perfutil.c
    (which were in-turn copied from perfmon interface common code).
    Code reuse from copy & paste instead of fixing the interface.

Author:

    Albert Ting (AlbertT)  17-Dec-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "perf.hxx"
#include "perfp.hxx"
#include "messages.h"

/********************************************************************

    Globals

********************************************************************/

//
// Translation table from kEventLogLevel to EVENTLOG_*_TYPE
//
UINT
gauEventLogTable[] = {
    EVENTLOG_INFORMATION_TYPE,  // kSuccess
    EVENTLOG_INFORMATION_TYPE,  // kInformation,
    EVENTLOG_WARNING_TYPE,      // kWarning,
    EVENTLOG_ERROR_TYPE         // kError
};


//
// Test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine.
//
enum CHAR_TYPE {
    kDigit = 1,
    kDelimiter = 2,
    kInvalid = 3
};

inline
CHAR_TYPE
EvalThisChar(
    WCHAR c,
    WCHAR d
    )
{
    if( c == d || c == 0 )
    {
        return kDelimiter;
    }

    if( c < L'0' || c > L'9' )
    {
        return kInvalid;
    }

    return kDigit;
}

BOOL
Pfp_bNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPCWSTR lpwszUnicodeList
    )

/*++

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.
--*/

{
    DWORD   dwThisNumber;
    LPCWSTR pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wckDelimiter;    // could be an argument to be more flexible

    if( !lpwszUnicodeList )
    {
        //
        // NULL pointer, # not found.
        //
        return FALSE;
    }

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wckDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wckDelimiter)) {
            case kDigit:
                // if this is the first kDigit after a kDelimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - L'0');
                }
                break;

            case kDelimiter:
                // a delimter is either the kDelimiter character or the
                // end of the string ('\0') if when the kDelimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case kInvalid:
                // if an kInvalid character was encountered, ignore all
                // characters up to the next kDelimiter and then start fresh.
                // the kInvalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList



VOID
Pfp_vOpenEventLog (
    VOID
    )

/*++

Routine Description:

   Reads the level of event logging from the registry and opens the channel
   to the event logger for subsequent event log entries.

Arguments:

Return Value:

Revision History:

--*/

{
    if (gpd.hEventLog == NULL)
    {
        gpd.hEventLog = RegisterEventSource( NULL, gszAppName );

        if (gpd.hEventLog != NULL)
        {
            Pf_vReportEvent( kInformation | kDebug,
                             MSG_PERF_LOG_OPEN,
                             0,
                             NULL,
                             NULL );
        }
    }
}


VOID
Pfp_vCloseEventLog(
    VOID
    )

/*++

Routine Description:

    Closes the global event log connection.

Arguments:

Return Value:

--*/

{
    if( gpd.hEventLog )
    {
        Pf_vReportEvent( kInformation | kDebug,
                         MSG_PERF_LOG_CLOSE,
                         0,
                         NULL,
                         NULL );

        DeregisterEventSource( gpd.hEventLog );

        gpd.hEventLog = NULL;
    }
}

VOID
Pf_vReportEvent(
    IN UINT uLevel,
    IN DWORD dwMessage,
    IN DWORD cbData, OPTIONAL
    IN PVOID pvData, OPTIONAL
    IN LPCWSTR pszFirst, OPTIONAL
    ...
    )

/*++

Routine Description:

    Log an event.

Arguments:

    uLevel - Combination of level (e.g., kSuccess, kError) and
        type (e.g., kUser, kVerbose).

    dwMessage - Message number.

    cbData - Size of optional data.

    pvData - Optional data.

    pszFirst - String inserts begin here, optional.

Return Value:

--*/

{
    LPCWSTR apszMergeStrings[kMaxMergeStrings];
    UINT cMergeStrings = 0;
    va_list     vargs;

    //
    // Skip the message if the log level is not high enough.
    //
    if(( uLevel >> kLevelShift ) > gpd.uLogLevel )
    {
        return;
    }

    if( !gpd.hEventLog )
    {
        Pfp_vOpenEventLog();
    }

    if( !gpd.hEventLog )
    {
        return;
    }

    if( pszFirst )
    {
        apszMergeStrings[cMergeStrings++] = pszFirst;

        va_start( vargs, pszFirst );

        while(( cMergeStrings < kMaxMergeStrings ) &&
              ( apszMergeStrings[cMergeStrings] = va_arg( vargs, LPCWSTR )))
        {
            cMergeStrings++;
        }

        va_end( vargs );
    }

    ReportEvent( gpd.hEventLog,
                 (WORD)gauEventLogTable[uLevel & kTypeMask],
                 0,
                 dwMessage,
                 NULL,
                 (WORD)cMergeStrings,
                 cbData,
                 apszMergeStrings,
                 pvData );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\change.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Change.c

Abstract:

    Handles new WaitForPrinterChange implementation and:

    FindFirstPrinterChangeNotification (client and remote)
    FindNextPrinterChangeNotification
    FindClosePrinterChangeNotification

    ReplyOpenPrinter
    ReplyClosePrinter

    RouterReplyPrinter{Ex}

    RefreshPrinterChangeNotification

Author:

    Albert Ting (AlbertT) 18-Jan-94

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#include "server.h"
#include "winspl.h"

BOOL
RouterFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    DWORD dwPID,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PHANDLE phEvent);

BOOL
RemoteFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    LPWSTR pszLocalMachine,
    DWORD dwPrinterRemote,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions);

BOOL
RouterFindNextPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    LPDWORD pfdwChange,
    PVOID pPrinterNotifyRefresh,
    PVOID* ppPrinterNotifyInfo);

BOOL
RouterReplyPrinter(
    HANDLE hNotify,
    DWORD dwColor,
    DWORD fdwFlags,
    PDWORD pdwResult,
    DWORD dwType,
    PVOID pBuffer);

BOOL
RouterRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PVOID pPrinterNotifyRefresh,
    PPRINTER_NOTIFY_INFO* ppInfo);


BOOL
ReplyOpenPrinter(
    DWORD dwPrinterRemote,
    PHANDLE phNotify,
    DWORD dwType,
    DWORD cbBuffer,
    LPBYTE pBuffer);

BOOL
ReplyClosePrinter(
    HANDLE hNotify);


DWORD
RpcRouterFindFirstPrinterChangeNotificationOld(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    LPWSTR pszLocalMachine,
    DWORD dwPrinterLocal)

/*++

Routine Description:

    This call is only used by beta2 daytona, but we can't remove it
    since this will allow beta2 to crash daytona.  (Someday, when
    beta2 is long gone, we can reuse this slot for something else.)

Arguments:

Return Value:

--*/

{
    return ERROR_INVALID_FUNCTION;
}


//
// Old version for Daytona.
//
DWORD
RpcRemoteFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    LPWSTR pszLocalMachine,
    DWORD dwPrinterLocal,
    DWORD cbBuffer,
    LPBYTE pBuffer)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    

    bRet = RemoteFindFirstPrinterChangeNotification(hPrinter,
                                                    fdwFlags,
                                                    fdwOptions,
                                                    pszLocalMachine,
                                                    dwPrinterLocal,
                                                    NULL);
    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}

DWORD
RpcRemoteFindFirstPrinterChangeNotificationEx(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    LPWSTR pszLocalMachine,
    DWORD dwPrinterLocal,
    PRPC_V2_NOTIFY_OPTIONS pRpcV2NotifyOptions)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = RemoteFindFirstPrinterChangeNotification(
               hPrinter,
               fdwFlags,
               fdwOptions,
               pszLocalMachine,
               dwPrinterLocal,
               (PPRINTER_NOTIFY_OPTIONS)pRpcV2NotifyOptions);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}


DWORD
RpcClientFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    DWORD dwPID,
    PRPC_V2_NOTIFY_OPTIONS pRpcV2NotifyOptions,
    LPDWORD pdwEvent)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;
    HANDLE hEvent = NULL;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = RouterFindFirstPrinterChangeNotification(
               hPrinter,
               fdwFlags,
               fdwOptions,
               dwPID,
               (PPRINTER_NOTIFY_OPTIONS)pRpcV2NotifyOptions,
               &hEvent);

    if (pdwEvent && hEvent)
    {
        *pdwEvent = HandleToLong (hEvent);
    }
    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}



DWORD
RpcFindNextPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    LPDWORD pfdwChange,
    PRPC_V2_NOTIFY_OPTIONS pRpcV2NotifyOptions,
    PRPC_V2_NOTIFY_INFO* ppInfo)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = RouterFindNextPrinterChangeNotification(
               hPrinter,
               fdwFlags,
               pfdwChange,
               pRpcV2NotifyOptions,
               ppInfo);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}


DWORD
RpcFindClosePrinterChangeNotification(
    HANDLE hPrinter)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = FindClosePrinterChangeNotification(hPrinter);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}




DWORD
RpcReplyOpenPrinter(
    LPWSTR pszLocalMachine,
    PHANDLE phNotify,
    DWORD dwPrinterRemote,
    DWORD dwType,
    DWORD cbBuffer,
    LPBYTE pBuffer)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = ReplyOpenPrinter(dwPrinterRemote,
                            phNotify,
                            dwType,
                            cbBuffer,
                            pBuffer);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}


DWORD
RpcReplyClosePrinter(
    PHANDLE phNotify)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = ReplyClosePrinter(*phNotify);

    RpcRevertToSelf();

    if (bRet) {
        *phNotify = NULL;
        return ERROR_SUCCESS;
    }
    else
        return GetLastError();
}


DWORD
RpcRouterReplyPrinter(
    HANDLE hNotify,
    DWORD fdwFlags,
    DWORD cbBuffer,
    LPBYTE pBuffer)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = RouterReplyPrinter(hNotify,
                              0,
                              fdwFlags,
                              NULL,
                              0,
                              NULL);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}


DWORD
RpcRouterReplyPrinterEx(
    HANDLE hNotify,
    DWORD dwColor,
    DWORD fdwFlags,
    PDWORD pdwResult,
    DWORD dwReplyType,
    RPC_V2_UREPLY_PRINTER Reply)

/*++

Routine Description:


Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = RouterReplyPrinter(hNotify,
                              dwColor,
                              fdwFlags,
                              pdwResult,
                              dwReplyType,
                              Reply.pInfo);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}



DWORD
RpcRouterRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PRPC_V2_NOTIFY_OPTIONS pRpcV2NotifyOptions,
    PRPC_V2_NOTIFY_INFO* ppInfo)

/*++

Routine Description:

    Updates info.

Arguments:

Return Value:

--*/

{
    BOOL bRet;
    RPC_STATUS Status;

    if ((Status = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        SetLastError(Status);
        return FALSE;
    }

    bRet = RouterRefreshPrinterChangeNotification(
               hPrinter,
               dwColor,
               (PPRINTER_NOTIFY_OPTIONS)pRpcV2NotifyOptions,
               (PPRINTER_NOTIFY_INFO*)ppInfo);

    RpcRevertToSelf();

    if (bRet)
        return FALSE;
    else
        return GetLastError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\data.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    data.c

Abstract:


Author:

Environment:



Revision History:

--*/

#include "precomp.h"

#define PRINTER_STRINGS
#define PRINTER_OFFSETS

#define JOB_STRINGS
#define JOB_OFFSETS

#define DRIVER_STRINGS
#define DRIVER_OFFSETS

#define ADDJOB_STRINGS
#define ADDJOB_OFFSETS

#define FORM_STRINGS
#define FORM_OFFSETS

#define PORT_STRINGS
#define PORT_OFFSETS

#define PRINTPROCESSOR_STRINGS
#define PRINTPROCESSOR_OFFSETS

#define MONITOR_STRINGS
#define MONITOR_OFFSETS

#define DOCINFO_STRINGS
#define DOCINFO_OFFSETS

#define DATATYPE_OFFSETS
#define DATATYPE_STRINGS

#define PROVIDOR_STRINGS

#define PRINTER_ENUM_VALUES_OFFSETS

#include <data.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\client.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Client.h

Abstract:

    Holds Client Spooler types and prototypes

Author:


Environment:

    User Mode -Win32

Revision History:

    Steve Wilson (NT) (swilson) 1-Jun-95    Ported from spoolss\client\client.h

--*/

#ifndef _SPOOLER_SERVER_CLIENT_H_
#define _SPOOLER_SERVER_CLIENT_H_

typedef int (FAR WINAPI *INT_FARPROC)();

typedef struct _GENERIC_CONTAINER {
    DWORD       Level;
    LPBYTE      pData;
} GENERIC_CONTAINER, *PGENERIC_CONTAINER, *LPGENERIC_CONTAINER ;


typedef struct _SPOOL *PSPOOL;
typedef struct _NOTIFY *PNOTIFY;

typedef struct _NOTIFY {
    PNOTIFY  pNext;
    HANDLE   hEvent;      // event to trigger on notification
    DWORD    fdwFlags;    // flags to watch for
    DWORD    fdwOptions;  // PRINTER_NOTIFY_*
    DWORD    dwReturn;    // used by WPC when simulating FFPCN
    PSPOOL   pSpool;
} NOTIFY;

typedef struct _SPOOL {
    DWORD       signature;
    HANDLE      hPrinter;
    DWORD       Status;
    LONG            cThreads;   // InterlockedDecrement/Increment variable for thread synch
    HANDLE      hModule;        // Driver UM DLL Module Handle
    DWORD       (*pfnWrite)();
    HANDLE      (*pfnStartDoc)();
    VOID        (*pfnEndDoc)();
    VOID        (*pfnClose)();
    BOOL        (*pfnStartPage)();
    BOOL        (*pfnEndPage)();
    VOID        (*pfnAbort)();
    HANDLE      hDriver;        // supplied to us by driver UI dll
    DWORD       JobId;
} SPOOL;

//
// Change the RPC buffer size to 64K
//
#define BUFFER_SIZE 0x10000
#define SP_SIGNATURE    0x6767

#define SPOOL_STATUS_STARTDOC   0x00000001
#define SPOOL_STATUS_ADDJOB     0x00000002
#define SPOOL_STATUS_ANSI       0x00000004


#define SPOOL_FLAG_FFPCN_FAILED     0x1
#define SPOOL_FLAG_LAZY_CLOSE       0x2


DWORD
TranslateExceptionCode(
    DWORD   ExceptionCode
);


PNOTIFY
WPCWaitFind(
    HANDLE hFind);

BOOL
ValidatePrinterHandle(
    HANDLE hPrinter
    );

VOID
FreeSpool(
    PSPOOL pSpool);

LPVOID
DllAllocSplMem(
    DWORD cb
);


BOOL
DllFreeSplMem(
   LPVOID pMem
);

BOOL
FlushBuffer(
    PSPOOL  pSpool
);

PSECURITY_DESCRIPTOR
BuildInputSD(
    PSECURITY_DESCRIPTOR pPrinterSD,
    PDWORD pSizeSD
);


typedef struct _KEYDATA {
    DWORD   cb;
    DWORD   cTokens;
    LPWSTR  pTokens[1];
} KEYDATA, *PKEYDATA;


PKEYDATA
CreateTokenList(
   LPWSTR   pKeyData
);


LPWSTR
GetPrinterPortList(
    HANDLE hPrinter
    );

LPWSTR
FreeUnicodeString(
    LPWSTR  pUnicodeString
);

LPWSTR
AllocateUnicodeString(
    LPSTR  pPrinterName
);

LPWSTR
StartDocDlgW(
        HANDLE hPrinter,
        DOCINFO *pDocInfo
        );

LPSTR
StartDocDlgA(
        HANDLE hPrinter,
        DOCINFOA *pDocInfo
        );

#endif // _SPOOLER_SERVER_CLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\dload.h ===
#ifndef _SPLDLOAD_H_
#define _SPLDLOAD_H_

EXTERN_C
FARPROC
WINAPI
DelayLoadFailureHook(
    IN UINT            unReason,
    IN PDelayLoadInfo  pDelayInfo
    );

FARPROC
LookupHandler(
    IN PDelayLoadInfo  pDelayInfo
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\kmspool.h ===
BOOL KMOpenPrinterW(LPWSTR   pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTS pDefault);

BOOL
KMGetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

DWORD
KMGetPrinterDataW(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
);


DWORD
KMSetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);


BOOL
KMWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);
DWORD
KMStartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);


BOOL
KMGetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
KMEnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
KMGetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);


BOOL
KMEndDocPrinter(
    HANDLE  hPrinter
);

BOOL
KMStartPagePrinter(
    HANDLE hPrinter
);

BOOL
KMEndPagePrinter(
    HANDLE  hPrinter
);

BOOL
KMClosePrinter(
    HANDLE  hPrinter);

BOOL
KMAbortPrinter(
    HANDLE  hPrinter);

VOID
FreeSpool(
    PSPOOL pSpool);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\kmspool.c ===
/*++

Copyright (c) 1990-1996 Microsoft Corporation
All rights reserved

Module Name:

    kmspool.c

Abstract:

    Spooler API entry points for Kernel Clients.

Author:
    Steve Wilson (NT) (swilson) 1-Jun-95  (Ported from client\winspool.c)

Environment:

    User Mode -Win32

Revision History:
    Matthew Felton (mattfe) May-96  Driver Hooks

--*/

#include "precomp.h"
#include "server.h"
#include "client.h"
#include "yspool.h"
#include "kmspool.h"

//
// Globals
//

#define ENTER_WAIT_LIST() EnterCriticalSection(&ThreadCriticalSection)
#define EXIT_WAIT_LIST()  LeaveCriticalSection(&ThreadCriticalSection)

LPWSTR szEnvironment = LOCAL_ENVIRONMENT;

//
//  Printer Attributes
//

#define     SPLPRINTER_USER_MODE_PRINTER_DRIVER       TEXT("SPLUserModePrinterDriver")


BOOL
ValidatePrinterHandle(
    HANDLE hPrinter
);

BOOL
DriverEndPageHook(
    PSPOOL  pSpool
);


BOOL
DriverStartPageHook(
    PSPOOL  pSpool
);

BOOL
DriverWritePrinterHook(
    PSPOOL pSpool,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);

VOID
DriverEndDocHook(
    PSPOOL pSpool
);

DWORD
DriverStartDocHook(
    PSPOOL  pSpool,
    DWORD   JobId
);

VOID
DriverClosePrinterHook(
    PSPOOL pSpool
);

VOID
DriverAbortPrinterHook(
    PSPOOL  pSpool
);



// Simple for Now !!!

DWORD
TranslateExceptionCode(
    DWORD   ExceptionCode
)
{
    switch (ExceptionCode) {

    case EXCEPTION_ACCESS_VIOLATION:
    case EXCEPTION_DATATYPE_MISALIGNMENT:
    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
    case EXCEPTION_FLT_DENORMAL_OPERAND:
    case EXCEPTION_FLT_DIVIDE_BY_ZERO:
    case EXCEPTION_FLT_INEXACT_RESULT:
    case EXCEPTION_FLT_INVALID_OPERATION:
    case EXCEPTION_FLT_OVERFLOW:
    case EXCEPTION_FLT_STACK_CHECK:
    case EXCEPTION_FLT_UNDERFLOW:
    case EXCEPTION_INT_DIVIDE_BY_ZERO:
    case EXCEPTION_INT_OVERFLOW:
    case EXCEPTION_PRIV_INSTRUCTION:
    case ERROR_NOACCESS:
    case RPC_S_INVALID_BOUND:

        return ERROR_INVALID_PARAMETER;
        break;
    default:
        return ExceptionCode;
    }
}


BOOL
KMOpenPrinterW(
   LPWSTR   pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTS pDefault
)
{
    BOOL  ReturnValue;
    DEVMODE_CONTAINER    DevModeContainer;
    HANDLE  hPrinter;
    PSPOOL  pSpool;
    DWORD   dwSize = 0;

    if (pDefault && pDefault->pDevMode)
    {

        dwSize = pDefault->pDevMode->dmSize + pDefault->pDevMode->dmDriverExtra;
        if (dwSize) {
            DevModeContainer.cbBuf = pDefault->pDevMode->dmSize +
                                 pDefault->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pDefault->pDevMode;
        } else {
            DevModeContainer.cbBuf = 0;
            DevModeContainer.pDevMode = NULL;
        }
    }
    else
    {
        DevModeContainer.cbBuf = 0;
        DevModeContainer.pDevMode = NULL;
    }

    try {

        if (ReturnValue = YOpenPrinter(pPrinterName, &hPrinter,
                                         pDefault ? pDefault->pDatatype : NULL,
                                         &DevModeContainer,
                                         pDefault ? pDefault->DesiredAccess : 0,
                                         NATIVE_CALL )) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    if (ReturnValue) {

        pSpool = AllocSplMem(sizeof(SPOOL));

        if (pSpool) {

            memset(pSpool, 0, sizeof(SPOOL));
            pSpool->signature = SP_SIGNATURE;
            pSpool->hPrinter = hPrinter;
            pSpool->cThreads = -1;

            //
            // This is to fix passing a bad pHandle to OpenPrinter!!
            //
            try {
                *phPrinter = pSpool;
            } except(1) {
                YClosePrinter(&hPrinter, NATIVE_CALL);
                FreeSplMem(pSpool);
                SetLastError(TranslateExceptionCode(GetExceptionCode()));
                return FALSE;
            }

        } else {

            YClosePrinter(&hPrinter, NATIVE_CALL);
            ReturnValue = FALSE;
        }
    }

    return ReturnValue;
}


BOOL
KMGetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL      ReturnValue;
    DWORD   *pOffsets;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }
    switch (Level) {

    case 1:
        pOffsets = FormInfo1Offsets;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    try {

        if (pForm)
            memset(pForm, 0, cbBuf);

        if (ReturnValue = YGetForm(pSpool->hPrinter, pFormName, Level, pForm,
                                     cbBuf, pcbNeeded, NATIVE_CALL)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}




BOOL
KMEnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    PSPOOL  pSpool = (PSPOOL)hPrinter;


    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    switch (Level) {

    case 1:
        pOffsets = FormInfo1Offsets;
        cbStruct = sizeof(FORM_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    try {

        if (pForm)
            memset(pForm, 0, cbBuf);

        if (ReturnValue = YEnumForms(pSpool->hPrinter, Level, pForm, cbBuf,
                                     pcbNeeded, pcReturned, NATIVE_CALL)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}


BOOL
KMGetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;
    DWORD   *pOffsets;
    PSPOOL  pSpool = (PSPOOL)hPrinter;


    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    switch (Level) {

    case 1:
        pOffsets = PrinterInfo1Offsets;
        break;

    case 2:
        pOffsets = PrinterInfo2Offsets;
        break;

    case 3:
        pOffsets = PrinterInfo3Offsets;
        break;

    case 4:
        pOffsets = PrinterInfo4Offsets;
        break;

    case 5:
        pOffsets = PrinterInfo5Offsets;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    try {

        if (pPrinter)
            memset(pPrinter, 0, cbBuf);

        if (ReturnValue = YGetPrinter(pSpool->hPrinter, Level, pPrinter, cbBuf, pcbNeeded, NATIVE_CALL)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}




BOOL
KMGetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD dwServerMajorVersion;
    DWORD dwServerMinorVersion;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    if (Level < 1 || Level > 3) {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    try {

        if (pDriverInfo)
            memset(pDriverInfo, 0, cbBuf);

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = YGetPrinterDriver2(pSpool->hPrinter, pEnvironment,
                                              Level, pDriverInfo, cbBuf,
                                              pcbNeeded,
                                              (DWORD)-1, (DWORD)-1,
                                              &dwServerMajorVersion,
                                              &dwServerMinorVersion,
                                              NATIVE_CALL
                                              )) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}


DWORD
KMGetPrinterDataW(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // ReturnValue (this is just a dummy pointer).
    //
    if( !pData && !nSize ){

        pData = (PBYTE)&ReturnValue;
    }

    try {

        ReturnValue =  YGetPrinterData(pSpool->hPrinter, pValueName, pType,
                                         pData, nSize, pcbNeeded, NATIVE_CALL);

    } except(1) {

        ReturnValue = TranslateExceptionCode(GetExceptionCode());

    }

    return ReturnValue;
}


DWORD
KMSetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return ERROR_INVALID_HANDLE;
    }

    try {

        ReturnValue = YSetPrinterData(pSpool->hPrinter, pValueName, Type,
                                        pData, cbData, NATIVE_CALL);

    } except(1) {

        ReturnValue = TranslateExceptionCode(GetExceptionCode());

    }

    return ReturnValue;
}



DWORD
KMStartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    BOOL ReturnValue;
    DWORD JobId;
    GENERIC_CONTAINER DocInfoContainer;
    PSPOOL  pSpool = (PSPOOL)hPrinter;


    try {

        if (!ValidatePrinterHandle(hPrinter)) {
            return(FALSE);
        }

        DBGMSG(DBG_TRACE,("Entered KMStartDocPrinterW side  hPrinter = %x\n", hPrinter));

        if (Level != 1) {
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        DocInfoContainer.Level = Level;
        DocInfoContainer.pData = pDocInfo;

        try {

            if (ReturnValue = YStartDocPrinter(pSpool->hPrinter,
                                       (LPDOC_INFO_CONTAINER)&DocInfoContainer,
                                       &JobId, NATIVE_CALL)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = JobId;

        } except(1) {

            SetLastError(TranslateExceptionCode(GetExceptionCode()));
            ReturnValue = FALSE;
        }


        if (ReturnValue) {

            ReturnValue = DriverStartDocHook( pSpool, JobId );

            if ( ReturnValue )
                pSpool->Status |= SPOOL_STATUS_STARTDOC;

        }

        return ReturnValue;

    } except (1) {
        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        return(FALSE);
    }
}

BOOL
KMEndDocPrinter(
    HANDLE  hPrinter
)
{
    BOOL    ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    try {

        if (!ValidatePrinterHandle(hPrinter)) {
            return(FALSE);
        }

        pSpool->Status &= ~SPOOL_STATUS_STARTDOC;

        DriverEndDocHook( pSpool );

        try {

            if (ReturnValue = YEndDocPrinter(pSpool->hPrinter, NATIVE_CALL)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } except(1) {

            SetLastError(TranslateExceptionCode(GetExceptionCode()));
            ReturnValue = FALSE;

        }

        DBGMSG(DBG_TRACE, ("Exit EndDocPrinter - client side hPrinter %x\n", hPrinter));

        return ReturnValue;
   } except (1) {
       SetLastError(ERROR_INVALID_HANDLE);
       return(FALSE);
   }
}




BOOL
KMWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    BOOL ReturnValue = TRUE;
    PSPOOL  pSpool   = (PSPOOL)hPrinter;

    DBGMSG(DBG_TRACE, ("WritePrinter - hPrinter %x pBuf %x cbBuf %d pcWritten %x\n",
                        hPrinter, pBuf, cbBuf, pcWritten));

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    *pcWritten = 0;

    if ( !(pSpool->Status & SPOOL_STATUS_STARTDOC) ) {

        SetLastError(ERROR_SPL_NO_STARTDOC);
        return FALSE;
    }


    //
    //  Call Printer Drivers User Mode WritePrinter Hook
    //


    if ( pSpool->hDriver ) {

        return DriverWritePrinterHook( pSpool, pBuf, cbBuf, pcWritten );
    }



    try {

        if (ReturnValue = YWritePrinter(pSpool->hPrinter, (LPBYTE) pBuf, cbBuf, pcWritten, NATIVE_CALL)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;
            DBGMSG(DBG_WARNING, ("KMWritePrinter - YWritePrinter Failed Error %d\n",GetLastError() ));

        } else {
            ReturnValue = TRUE;
            DBGMSG(DBG_TRACE, ("KMWritePrinter - YWritePrinter Success hPrinter %x pBuffer %x cbBuffer %x cbWritten %x\n",
                                pSpool->hPrinter, (LPBYTE) pBuf, cbBuf, *pcWritten));

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;
        DBGMSG(DBG_WARNING, ("YWritePrinter Exception Error %d\n",GetLastError()));

    }

    // Return the number of bytes written.

    DBGMSG(DBG_TRACE, ("KMWritePrinter cbWritten %d ReturnValue %d\n",*pcWritten, ReturnValue));

    return ReturnValue;
}


BOOL
KMStartPagePrinter(
    HANDLE hPrinter
)
{
    BOOL ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    try {

        ReturnValue = DriverStartPageHook( pSpool );

        if ( ReturnValue ) {

            if (ReturnValue = YStartPagePrinter(pSpool->hPrinter, NATIVE_CALL)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}

BOOL
KMEndPagePrinter(
    HANDLE  hPrinter
)
{
    BOOL ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    try {

        ReturnValue = DriverEndPageHook( pSpool );

        if ( ReturnValue ) {

            if (ReturnValue = YEndPagePrinter(pSpool->hPrinter, NATIVE_CALL)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;
        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}


BOOL
KMAbortPrinter(
    HANDLE  hPrinter
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   dwNumWritten = 0;
    DWORD   dwPointer = 0;

    if (!ValidatePrinterHandle(hPrinter)){
        return(FALSE);
    }

    pSpool->Status &= ~SPOOL_STATUS_STARTDOC;


    try {

        DriverAbortPrinterHook( pSpool );

        if (ReturnValue = YAbortPrinter(pSpool->hPrinter, NATIVE_CALL)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}


BOOL
KMClosePrinter(
    HANDLE  hPrinter)
{
    BOOL    ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    HANDLE  hPrinterKM;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    try {

        DriverClosePrinterHook( pSpool );

    } except(1) {
        DBGMSG(DBG_WARNING, ("DrvClosePrinter Exception Error %d\n",TranslateExceptionCode(GetExceptionCode())));
    }

    ENTER_WAIT_LIST();

    hPrinterKM = pSpool->hPrinter;

    FreeSplMem(pSpool);

    EXIT_WAIT_LIST();


    try {

        if (ReturnValue = YClosePrinter(&hPrinterKM, NATIVE_CALL)) {

            SetLastError(ReturnValue);

            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}



BOOL
ValidatePrinterHandle(
    HANDLE hPrinter
    )
{
    PSPOOL pSpool = hPrinter;
    BOOL bReturnValue = FALSE;

    try {
        if ( pSpool && (pSpool->signature == SP_SIGNATURE)) {
            bReturnValue = TRUE;
        }
    } except (1) {
    }

    if ( !bReturnValue ) {
        SetLastError( ERROR_INVALID_HANDLE );
    }

    return bReturnValue;
}



BOOL
DriverWritePrinterHook(
    PSPOOL  pSpool,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{

    BOOL    ReturnValue;

    //  Some Printer Drivers want to push functionality out of kernel mode
    //  to achieve that we allow them to hook the calls to writeprinter from
    //  their Kernel Mode DLL to their User Mode Dll


    SPLASSERT( pSpool->hModule &&
               pSpool->pfnWrite &&
               pSpool->hDriver &&
               pSpool->hPrinter );


    try {

        ReturnValue = (*pSpool->pfnWrite)( pSpool->hDriver,
                                           pBuf,
                                           cbBuf,
                                           pcWritten );

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;
        DBGMSG(DBG_ERROR, ("DrvWritePrinter Exception Error %d pSpool %x\n",GetLastError(), pSpool));
    }

    if ( !ReturnValue ) {
        SPLASSERT( GetLastError() );
    }

    return ReturnValue;
}



HANDLE
LoadPrinterDriver(
    PSPOOL  pSpool,
    PWCHAR  pUserModeDriverName
)
{
    PDRIVER_INFO_2  pDriverInfo;
    DWORD           cbNeeded;
    HANDLE          hModule = NULL;
    PWCHAR          pFileName;
    fnWinSpoolDrv   fnList; 

    if (!GetPrinterDriver(pSpool->hPrinter, NULL, 2, NULL, 0, &cbNeeded)) {

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            // Allow for the size of the string passed in.

            cbNeeded += ( wcslen( pUserModeDriverName ) + 1 )* sizeof(WCHAR);

            if (pDriverInfo = (PDRIVER_INFO_2)AllocSplMem( cbNeeded )) {

                if (GetPrinterDriver(pSpool->hPrinter, NULL, 2, (LPBYTE)pDriverInfo, cbNeeded, &cbNeeded)) {

                    HRESULT hRes;


                    //
                    //  Driver Info 2 doesn't have the fully Qualified Path
                    //  to the UserModePrinterDriver.
                    //  So form it by taking replacing the UI DLL name with the
                    //  UseModePrinterDriverName

                    pFileName = wcsrchr( pDriverInfo->pConfigFile, L'\\');
                    pFileName++;

                    //
                    // the line cbNeeded += ( wcslen( pUserModeDriverName ) + 1 )* sizeof(WCHAR);
                    // makes sure that we have enough buffer to copy pUserModeDriverName
                    //
                    hRes = StringCchCopyW(pFileName, 1 + wcslen(pUserModeDriverName), pUserModeDriverName);

                    if (SUCCEEDED(hRes)) {
                    
                        pFileName = pDriverInfo->pConfigFile;

                        DBGMSG( DBG_WARNING, ("UserModeDriverPath %ws\n", pFileName ));

                        if (SplInitializeWinSpoolDrv(&fnList)) {
    
                            hModule = (* (fnList.pfnRefCntLoadDriver))(pFileName,
                                                                       LOAD_WITH_ALTERED_SEARCH_PATH,
                                                                       0, FALSE);
                        }
    
                        if ( !hModule ) {
                            DBGMSG( DBG_WARNING, ("Failed to load %ws error %d\n", pFileName, GetLastError() ));
                        }
                    }
                    else {

                         SetLastError(SCODE_CODE(hRes));
                    }

                }
                FreeSplMem(pDriverInfo);
            }
        }
    }

    return hModule;
}



VOID
UnloadPrinterDriver(
    PSPOOL pSpool
)
{
    fnWinSpoolDrv  fnList;

    if ( pSpool->hModule ) {

        SPLASSERT( pSpool->hDriver == NULL );

        if (SplInitializeWinSpoolDrv(&fnList)) {
            (* (fnList.pfnRefCntUnloadDriver))(pSpool->hModule, TRUE);
        }

        pSpool->hModule = NULL;
        pSpool->pfnWrite = NULL;
        pSpool->pfnStartDoc = NULL;
        pSpool->pfnEndDoc = NULL;
        pSpool->pfnClose = NULL;
        pSpool->pfnStartPage = NULL;
        pSpool->pfnEndPage = NULL;
    }
}



DWORD
DriverStartDocHook(
    PSPOOL  pSpool,
    DWORD   JobId
)
{
    DWORD   dwReturn;
    WCHAR   UserModeDriverName[MAX_PATH];
    DWORD   dwNeeded;
    INT     cDriverName;
    BOOL    ReturnValue = FALSE;
    DWORD   Type = 0;


    //
    //  Determine if there is a UserMode Printer Driver
    //

    dwReturn = GetPrinterDataW( pSpool->hPrinter,
                                SPLPRINTER_USER_MODE_PRINTER_DRIVER,
                                &Type,
                                (LPBYTE)&UserModeDriverName,
                                MAX_PATH,
                                &dwNeeded );

    if ( dwReturn != ERROR_SUCCESS ) {

        SPLASSERT( dwReturn != ERROR_INSUFFICIENT_BUFFER );
        ReturnValue = TRUE;
        goto Complete;
    }

    if ( Type != REG_SZ ) {
        SPLASSERT( Type == REG_SZ );
        goto Complete;
    }

    //  No String treat as success

    cDriverName = wcslen( UserModeDriverName );
    if ( !cDriverName ) {
        ReturnValue = TRUE;
        goto Complete;
    }


    //
    //  Load the UM Driver DLL
    //

    if ( pSpool->hModule == NULL ) {

        pSpool->hModule = LoadPrinterDriver( pSpool, UserModeDriverName );

        if ( pSpool->hModule == NULL ) goto Complete;
    }


    //
    //  Get Function Pointers
    //


    //  Required
    //
    pSpool->pfnWrite = (DWORD (*)()) GetProcAddress( pSpool->hModule, "DrvSplWritePrinter" );
    pSpool->pfnStartDoc = (HANDLE (*)()) GetProcAddress( pSpool->hModule, "DrvSplStartDoc" );
    pSpool->pfnClose = (VOID (*)()) GetProcAddress( pSpool->hModule, "DrvSplClose" );
    pSpool->pfnEndDoc = (VOID (*)()) GetProcAddress( pSpool->hModule, "DrvSplEndDoc" );

    //  Optional
    //
    pSpool->pfnEndPage = (BOOL (*)()) GetProcAddress( pSpool->hModule, "DrvSplEndPage" );
    pSpool->pfnStartPage = (BOOL (*)()) GetProcAddress( pSpool->hModule, "DrvSplStartPage" );
    pSpool->pfnAbort = (VOID (*)()) GetProcAddress( pSpool->hModule, "DrvSplAbort" );

    if (!( pSpool->pfnWrite)    ||
        !( pSpool->pfnStartDoc) ||
        !( pSpool->pfnClose)    ||
        !( pSpool->pfnEndDoc)) {

        goto Complete;
    }


    //
    //  Ask the Driver for a Handle for this print job
    //

    SPLASSERT( pSpool->hDriver == NULL );
    SPLASSERT( pSpool->hPrinter );
    SPLASSERT( JobId );

    pSpool->hDriver = (HANDLE)(*pSpool->pfnStartDoc)( pSpool->hPrinter, JobId );

    if ( pSpool->hDriver != NULL ) {
        ReturnValue = TRUE;
    }


Complete:

    if (!ReturnValue) {

        UnloadPrinterDriver( pSpool );

        // Cancel the outstanding job
        //
        // In the direct case
        //    AbortPrinter doesn't work
        //    SetJob _CANCEL doesn't work
        //    EndDocPrinter does work

        EndDocPrinter( pSpool->hPrinter );
        JobId = 0;
    }

    pSpool->JobId = JobId;

    return  JobId;
}


VOID
DriverEndDocHook(
    PSPOOL pSpool
)
{
    if ( pSpool->hDriver ) {

        (*pSpool->pfnEndDoc)( pSpool->hDriver );
        (*pSpool->pfnClose)(pSpool->hDriver );
        pSpool->hDriver = NULL;
    }
}


BOOL
DriverStartPageHook(
    PSPOOL  pSpool
)
{
    if ( pSpool->hDriver && pSpool->pfnStartPage ){

        return (*pSpool->pfnStartPage)( pSpool->hDriver );

    } else {

        return  TRUE;
    }
}


BOOL
DriverEndPageHook(
    PSPOOL  pSpool
)
{
    if ( pSpool->hDriver && pSpool->pfnEndPage ){

        return (*pSpool->pfnEndPage)( pSpool->hDriver );

    } else {

        return  TRUE;
    }
}


VOID
DriverAbortPrinterHook(
    PSPOOL  pSpool
)
{
    if ( pSpool->hDriver && pSpool->pfnAbort )
        (*pSpool->pfnAbort)( pSpool->hDriver );
}



VOID
DriverClosePrinterHook(
    PSPOOL pSpool
)
{
    if ( pSpool->hDriver ) {

        SPLASSERT( pSpool->pfnClose );

        (*pSpool->pfnClose)(pSpool->hDriver);
        pSpool->hDriver = NULL;
    }

    UnloadPrinterDriver( pSpool );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\midluser.c ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    25-Apr-1991 JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.

--*/

#include "precomp.h"

PVOID
MIDL_user_allocate (
    IN size_t NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    return MIDL_user_allocate1(NumBytes);
}



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
    MIDL_user_free1(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\dload.c ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    dload.c

Abstract:

    Handles delay load of the router, spoolss.dll

Author:

    Steve Kiraly (SteveKi) 26-Oct-2000

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#include "server.h"
#include "dload.h"

PfnDliHook __pfnDliFailureHook = DelayLoadFailureHook;

FARPROC
LookupHandler(
    IN PDelayLoadInfo  pDelayInfo
    )
/*++

Routine Description:

    This routine handle finding a delay load handler when a delay load library error
    occurrs.  Currently this routine only handles failures for delay loading the router.
    The router is delay loaded for boot performance issues.  When the router cannot be loaded
    it is fatal.  Currently we simply terminate the process, it would be better to log an
    event prior to terminating but this would require event logging code which we only have in
    localspl.dll In the future we should build event logging code for all components.  Server,
    router, and all print providers.

Arguments:

    pDelayInfo - pointer to delay load information, i.e. dll name
                 procedure name etc.

Return Value:

    NULL procedure address

Note:


--*/
{
    //
    // If the router cannot be loaded or a procedure address cannot be found then
    // terminate not much else can be done, the router is a critical comonent of the
    // spooler process it must be available.
    //
    if (!_stricmp(pDelayInfo->szDll, "spoolss.dll"))
    {
        DBGMSG(DBG_WARN, ("Delay load module or address not found in spoolss.dll.\n"));

        ExitProcess(-1);
    }

    return NULL;
}

FARPROC
WINAPI
DelayLoadFailureHook(
    IN UINT            unReason,
    IN PDelayLoadInfo  pDelayInfo
    )
/*++

Routine Description:

    Called when a delay loaded library or procedure address fails.

Arguments:

    unReason - reason for delay load failure
    pDelayInfo - pointer to delay load failure information

Return Value:

    The procedure or module handle

Note:


--*/
{
    FARPROC ReturnValue = NULL;

    switch(unReason)
    {
    //
    // For a failed LoadLibrary, we will return the HINSTANCE of this module.
    // This will cause the loader to try a GetProcAddress in this module for the
    // function.  This will subsequently fail and then we will be called
    // for dliFailGetProc below.
    //
    case dliFailLoadLib:
        ReturnValue = (FARPROC)GetModuleHandle(NULL);
        break;

    //
    // Try to find an error handler for this DLL/procedure.
    //
    case dliFailGetProc:
        ReturnValue = LookupHandler(pDelayInfo);
        break;

    //
    // Unknown reason failure.
    //
    default:
        break;
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stddef.h>
#include <winsvc.h>
#include <rpc.h>
#include <offsets.h>
#include <delayimp.h>
#include <winspool.h>
#include <ntgdispl.h>              
#include <lmsname.h>              
#include <lmerr.h>
#include <offsets.h>
#include <strsafe.h>
#include <splapip.h>
#include <winsplp.h>
#include <winsprlp.h>
#include <winspl.h>
#include <Sddl.h>

#ifndef MODULE
#define MODULE "SPLSRV:"
#define MODULE_DEBUG SplsrvDebug
#endif

#include <splcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\server.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    server.h

Abstract:

    Header file for Spooler server

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

//#ifndef _SPOOLSV_SERVER_H_
//#define _SPOOLSV_SERVER_H_
                  


extern CRITICAL_SECTION ThreadCriticalSection;
extern SERVICE_STATUS_HANDLE SpoolerStatusHandle;
extern RPC_IF_HANDLE winspool_ServerIfHandle;
extern DWORD SpoolerState;
extern SERVICE_TABLE_ENTRY SpoolerServiceDispatchTable[];


//#endif // _SPOOLSV_SERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\rpcspool.c ===
/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:

    rpcspool.c

Abstract:

    Spooler API entry points for RPC Clients.

Author:

    Steve Wilson (NT) (swilson) 1-Jun-1995

[Notes:]

    optional-notes

Revision History:

--*/

#include "precomp.h"
#include "server.h"
#include "client.h"
#include "yspool.h"

VOID
PrinterHandleRundown(
    HANDLE hPrinter);

BOOL
GetPrinterDriverExW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVersion,
    DWORD   dwClientMinorVersion,
    PDWORD  pdwServerMajorVersion,
    PDWORD  pdwServerMinorVersion);

BOOL
SpoolerInit(
    VOID);



DWORD
RpcEnumPrinters(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded, 
    LPDWORD pcReturned
)
{
    return YEnumPrinters(   Flags,
                            Name,
                            Level,
                            pPrinterEnum,
                            cbBuf,
                            pcbNeeded,
                            pcReturned,
                            RPC_CALL);
}

DWORD
RpcOpenPrinter(
    LPWSTR  pPrinterName,
    HANDLE *phPrinter,
    LPWSTR  pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD   AccessRequired
)
{
    return YOpenPrinter(pPrinterName,
                        phPrinter,
                        pDatatype,
                        pDevModeContainer,
                        AccessRequired,
                        RPC_CALL);
}

DWORD
RpcOpenPrinterEx(
    LPWSTR                  pPrinterName,
    HANDLE                 *phPrinter,
    LPWSTR                  pDatatype,
    LPDEVMODE_CONTAINER     pDevModeContainer,
    DWORD                   AccessRequired,
    LPSPLCLIENT_CONTAINER   pSplClientContainer
)
{
    return YOpenPrinterEx(pPrinterName,
                          phPrinter,
                          pDatatype,
                          pDevModeContainer,
                          AccessRequired,
                          RPC_CALL,
                          pSplClientContainer);
}

//
// RpcSplOpenPrinter differs from RpcOpenPrinterEx in the SPLCLIENT_CONTAINER buffer type
// It is defined as [in, out] in RpcSplOpenPrinter and just [in] in the latter
//

DWORD
RpcSplOpenPrinter(
    LPWSTR                  pPrinterName,
    HANDLE                 *phPrinter,
    LPWSTR                  pDatatype,
    LPDEVMODE_CONTAINER     pDevModeContainer,
    DWORD                   AccessRequired,
    LPSPLCLIENT_CONTAINER   pSplClientContainer
)
{
    return YOpenPrinterEx(pPrinterName,
                          phPrinter,
                          pDatatype,
                          pDevModeContainer,
                          AccessRequired,
                          RPC_CALL,
                          pSplClientContainer);
}

DWORD
RpcResetPrinter(
    HANDLE  hPrinter,
    LPWSTR  pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer
)
{
    return YResetPrinter(   hPrinter,
                            pDatatype,
                            pDevModeContainer,
                            RPC_CALL);
}

DWORD
RpcSetJob(
    HANDLE hPrinter,
    DWORD   JobId,
    JOB_CONTAINER *pJobContainer,
    DWORD   Command
    )
{
    return YSetJob( hPrinter,
                    JobId,
                    pJobContainer,
                    Command,
                    RPC_CALL);
}


DWORD
RpcGetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
   )


{
    return YGetJob( hPrinter,
                    JobId,
                    Level,
                    pJob,
                    cbBuf,
                    pcbNeeded,
                    RPC_CALL);
}

DWORD
RpcEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    return YEnumJobs(   hPrinter,
                        FirstJob,
                        NoJobs,
                        Level,
                        pJob,
                        cbBuf,
                        pcbNeeded,
                        pcReturned,
                        RPC_CALL);
}

DWORD
RpcAddPrinter(
    LPWSTR  pName,
    PPRINTER_CONTAINER pPrinterContainer,
    PDEVMODE_CONTAINER pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    HANDLE *phPrinter
)
{
    return YAddPrinter( pName,
                        pPrinterContainer,
                        pDevModeContainer,
                        pSecurityContainer,
                        phPrinter,
                        RPC_CALL);
}

DWORD
RpcAddPrinterEx(
    LPWSTR  pName,
    PPRINTER_CONTAINER pPrinterContainer,
    PDEVMODE_CONTAINER pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    PSPLCLIENT_CONTAINER pClientContainer,
    HANDLE *phPrinter
)
{
    return YAddPrinterEx(pName,
                         pPrinterContainer,
                         pDevModeContainer,
                         pSecurityContainer,
                         phPrinter,
                         RPC_CALL,
                         pClientContainer);
}

DWORD
RpcDeletePrinter(
    HANDLE  hPrinter
)
{
    return YDeletePrinter(hPrinter, RPC_CALL);
}

DWORD
RpcAddPrinterConnection(
    LPWSTR  pName
)
{
    return YAddPrinterConnection(pName, RPC_CALL);
}

DWORD
RpcDeletePrinterConnection(
    LPWSTR  pName
)
{
    return YDeletePrinterConnection(pName, RPC_CALL);
}

DWORD
RpcSetPrinter(
    HANDLE  hPrinter,
    PPRINTER_CONTAINER pPrinterContainer,
    PDEVMODE_CONTAINER pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    DWORD   Command
)
{
    return YSetPrinter(
        hPrinter,
        pPrinterContainer,
        pDevModeContainer,
        pSecurityContainer,
        Command,
        RPC_CALL);
}

DWORD
RpcGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    return YGetPrinter( hPrinter,
                        Level,
                        pPrinter,
                        cbBuf,
                        pcbNeeded,
                        RPC_CALL);
}

DWORD
RpcAddPrinterDriver(
    LPWSTR  pName,
    LPDRIVER_CONTAINER pDriverContainer
)
{
    return YAddPrinterDriver(   pName,
                                pDriverContainer,
                                RPC_CALL);
}

DWORD
RpcAddPrinterDriverEx(
    LPWSTR  pName,
    LPDRIVER_CONTAINER pDriverContainer,
    DWORD   dwFileCopyFlags
)
{
    return YAddPrinterDriverEx( pName,
                                pDriverContainer,
                                dwFileCopyFlags,
                                RPC_CALL);
}

DWORD
RpcAddDriverCatalog(
    HANDLE  hPrinter,
    DRIVER_INFCAT_CONTAINER *pDriverInfCatContainer,
    DWORD   dwCatalogCopyFlags
)
{
    return YAddDriverCatalog(hPrinter,
                             pDriverInfCatContainer,
                             dwCatalogCopyFlags,
                             RPC_CALL);
}

DWORD
RpcEnumPrinterDrivers(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDrivers,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    return YEnumPrinterDrivers( pName,
                                pEnvironment,
                                Level,
                                pDrivers,
                                cbBuf,
                                pcbNeeded,
                                pcReturned,
                                RPC_CALL);
}

DWORD
RpcGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    return YGetPrinterDriver(   hPrinter,
                                pEnvironment,
                                Level,
                                pDriverInfo,
                                cbBuf,
                                pcbNeeded,
                                RPC_CALL);
}

DWORD
RpcGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    return YGetPrinterDriverDirectory(  pName,
                                        pEnvironment,
                                        Level,
                                        pDriverInfo,
                                        cbBuf,
                                        pcbNeeded,
                                        RPC_CALL);
}

DWORD
RpcDeletePrinterDriver(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pDriverName
)
{
    return YDeletePrinterDriver(pName,
                                pEnvironment,
                                pDriverName,
                                RPC_CALL);
}


DWORD
RpcDeletePrinterDriverEx(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pDriverName,
    DWORD   dwDeleteFlag,
    DWORD   dwVersionNum
)
{
    return YDeletePrinterDriverEx(pName,
                                 pEnvironment,
                                 pDriverName,
                                 dwDeleteFlag,
                                 dwVersionNum,
                                 RPC_CALL);
}

DWORD
RpcAddPerMachineConnection(
    LPWSTR  pServer,
    LPCWSTR  pPrinterName,
    LPCWSTR  pPrintServer,
    LPCWSTR  pProvider
)
{
    return YAddPerMachineConnection(pServer,
                                    pPrinterName,
                                    pPrintServer,
                                    pProvider,
                                    RPC_CALL);
}

DWORD
RpcDeletePerMachineConnection(
    LPWSTR  pServer,
    LPCWSTR  pPrinterName
)
{
    return YDeletePerMachineConnection(pServer,
                                       pPrinterName,
                                       RPC_CALL);
}

DWORD
RpcEnumPerMachineConnections(
    LPWSTR  pServer,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    return YEnumPerMachineConnections(pServer,
                                      pPrinterEnum,
                                      cbBuf,
                                      pcbNeeded,
                                      pcReturned,
                                      RPC_CALL);
}

DWORD
RpcAddPrintProcessor(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPathName,
    LPWSTR  pPrintProcessorName
)
{
    return YAddPrintProcessor(  pName,
                                pEnvironment,
                                pPathName,
                                pPrintProcessorName,
                                RPC_CALL);
}

DWORD
RpcEnumPrintProcessors(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    return YEnumPrintProcessors(pName,
                                pEnvironment,
                                Level,
                                pPrintProcessors,
                                cbBuf,
                                pcbNeeded,
                                pcReturned,
                                RPC_CALL);
}

DWORD
RpcGetPrintProcessorDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    return YGetPrintProcessorDirectory( pName,
                                        pEnvironment,
                                        Level,
                                        pPrintProcessorInfo,
                                        cbBuf,
                                        pcbNeeded,
                                        RPC_CALL);
}

DWORD
RpcEnumPrintProcessorDatatypes(
    LPWSTR  pName,
    LPWSTR  pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    return YEnumPrintProcessorDatatypes(pName,
                                        pPrintProcessorName,
                                        Level,
                                        pDatatypes,
                                        cbBuf,
                                        pcbNeeded,
                                        pcReturned,
                                        RPC_CALL);
}

DWORD
RpcStartDocPrinter(
    HANDLE  hPrinter,
    LPDOC_INFO_CONTAINER pDocInfoContainer,
    LPDWORD pJobId
)
{
    return YStartDocPrinter(hPrinter,
                            pDocInfoContainer,
                            pJobId,
                            RPC_CALL);
}

DWORD
RpcStartPagePrinter(
   HANDLE hPrinter
)
{
    return YStartPagePrinter(hPrinter, RPC_CALL);
}

DWORD
RpcWritePrinter(
    HANDLE  hPrinter,
    LPBYTE  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    return YWritePrinter(   hPrinter,
                            pBuf,
                            cbBuf,
                            pcWritten,
                            RPC_CALL);
}

DWORD
RpcSeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWritePrinter
)
{
    return YSeekPrinter( hPrinter,
                         liDistanceToMove,
                         pliNewPointer,
                         dwMoveMethod,
                         bWritePrinter,
                         RPC_CALL );
}


DWORD
RpcEndPagePrinter(
    HANDLE  hPrinter
)
{
    return YEndPagePrinter(hPrinter, RPC_CALL);
}

DWORD
RpcAbortPrinter(
    HANDLE  hPrinter
)
{
    return YAbortPrinter(hPrinter, RPC_CALL);
}

DWORD
RpcReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  pBuf,
    DWORD   cbBuf,
    LPDWORD pRead
)
{
    return YReadPrinter(hPrinter,
                        pBuf,
                        cbBuf,
                        pRead,
                        RPC_CALL);
}

DWORD
RpcEndDocPrinter(
    HANDLE  hPrinter
)
{
    return YEndDocPrinter(hPrinter, RPC_CALL);
}

DWORD
RpcAddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pAddJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    return YAddJob( hPrinter,
                    Level,
                    pAddJob,
                    cbBuf,
                    pcbNeeded,
                    RPC_CALL);
}

DWORD
RpcScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
)
{
    return YScheduleJob(hPrinter,
                        JobId,
                        RPC_CALL);
}

DWORD
RpcGetPrinterData(
   HANDLE   hPrinter,
   LPTSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    return YGetPrinterData(hPrinter,
                           pValueName,
                           pType,
                           pData,
                           nSize,
                           pcbNeeded,
                           RPC_CALL);
}

DWORD
RpcGetPrinterDataEx(
   HANDLE   hPrinter,
   LPCTSTR  pKeyName,
   LPCTSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    return YGetPrinterDataEx(hPrinter,
                           pKeyName,
                           pValueName,
                           pType,
                           pData,
                           nSize,
                           pcbNeeded,
                           RPC_CALL);
}


DWORD
RpcEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,     // address of buffer for value string
    DWORD   cbValueName,    // size of buffer for value string
    LPDWORD pcbValueName,   // address for size of value buffer
    LPDWORD pType,          // address of buffer for type code
    LPBYTE  pData,          // address of buffer for value data
    DWORD   cbData,         // size of buffer for value data
    LPDWORD pcbData         // address for size of data buffer
)
{
    return YEnumPrinterData(hPrinter,
                            dwIndex,
                            pValueName,
                            cbValueName,
                            pcbValueName,
                            pType,
                            pData,
                            cbData,
                            pcbData,
                            RPC_CALL);
}

DWORD
RpcEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
)
{
    return YEnumPrinterDataEx(  hPrinter,
                                pKeyName,
                                pEnumValues,
                                cbEnumValues,
                                pcbEnumValues,
                                pnEnumValues,
                                RPC_CALL);
}


DWORD
RpcEnumPrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,       // address of key name
    LPWSTR  pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of buffer for value string
    LPDWORD pcbSubkey       // address for size of value buffer
)
{
    return YEnumPrinterKey( hPrinter,
                            pKeyName,
                            pSubkey,
                            cbSubkey,
                            pcbSubkey,
                            RPC_CALL);
}


DWORD
RpcDeletePrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName
)
{
    return YDeletePrinterData(hPrinter, pValueName, RPC_CALL);
}


DWORD
RpcDeletePrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName
)
{
    return YDeletePrinterDataEx(hPrinter, pKeyName, pValueName, RPC_CALL);
}


DWORD
RpcDeletePrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName
)
{
    return YDeletePrinterKey(hPrinter, pKeyName, RPC_CALL);
}


DWORD
RpcSetPrinterData(
    HANDLE  hPrinter,
    LPTSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    return YSetPrinterData( hPrinter,
                            pValueName,
                            Type,
                            pData,
                            cbData,
                            RPC_CALL);
}

DWORD
RpcSetPrinterDataEx(
    HANDLE  hPrinter,
    LPCTSTR pKeyName,
    LPCTSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    return YSetPrinterDataEx( hPrinter,
                            pKeyName,
                            pValueName,
                            Type,
                            pData,
                            cbData,
                            RPC_CALL);
}

DWORD
RpcWaitForPrinterChange(
   HANDLE   hPrinter,
   DWORD    Flags,
   LPDWORD  pFlags
)
{
    return YWaitForPrinterChange(   hPrinter,
                                    Flags,
                                    pFlags,
                                    RPC_CALL);
}

DWORD
RpcClosePrinter(
   LPHANDLE phPrinter
)
{
    return YClosePrinter(phPrinter, RPC_CALL);
}



DWORD
RpcAddForm(
    HANDLE hPrinter,
    PFORM_CONTAINER pFormInfoContainer
)
{
    return YAddForm(    hPrinter,
                        pFormInfoContainer,
                        RPC_CALL);
}

DWORD
RpcDeleteForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName
)
{
    return YDeleteForm( hPrinter,
                        pFormName,
                        RPC_CALL);
}

DWORD
RpcGetForm(
    PRINTER_HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD Level,
    LPBYTE pForm,
    DWORD cbBuf,
    LPDWORD pcbNeeded
)
{
    return YGetForm(hPrinter,
                    pFormName,
                    Level,
                    pForm,
                    cbBuf,
                    pcbNeeded,
                    RPC_CALL);
}

DWORD
RpcSetForm(
    PRINTER_HANDLE hPrinter,
    LPWSTR  pFormName,
    PFORM_CONTAINER pFormInfoContainer
)
{
    return YSetForm(hPrinter,
                    pFormName,
                    pFormInfoContainer,
                    RPC_CALL);
}

DWORD
RpcEnumForms(
   PRINTER_HANDLE hPrinter,
   DWORD    Level,
   LPBYTE   pForm,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
)
{
    return YEnumForms( hPrinter,
                       Level,
                       pForm,
                       cbBuf,
                       pcbNeeded,
                       pcReturned,
                       RPC_CALL);
}

DWORD
RpcEnumPorts(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   pPort,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
)
{
    return YEnumPorts( pName,
                       Level,
                       pPort,
                       cbBuf,
                       pcbNeeded,
                       pcReturned,
                       RPC_CALL);
}

DWORD
RpcEnumMonitors(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   pMonitor,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned
)
{
    return YEnumMonitors(  pName,
                           Level,
                           pMonitor,
                           cbBuf,
                           pcbNeeded,
                           pcReturned,
                           RPC_CALL);
}

DWORD
RpcAddPort(
    LPWSTR      pName,
    ULONG_PTR   hWnd,
    LPWSTR      pMonitorName
)
{
    return YAddPort(  pName,
                      (HWND)hWnd,
                      pMonitorName,
                      RPC_CALL);
}

DWORD
RpcConfigurePort(
    LPWSTR      pName,
    ULONG_PTR   hWnd,
    LPWSTR      pPortName
)
{
    return YConfigurePort(  pName,
                            (HWND)hWnd,
                            pPortName,
                            RPC_CALL);
}

DWORD
RpcDeletePort(
    LPWSTR      pName,
    ULONG_PTR   hWnd,
    LPWSTR      pPortName
)
{
    return YDeletePort( pName,
                        (HWND)hWnd,
                        pPortName,
                        RPC_CALL);
}

DWORD
RpcXcvData(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus
)
{
    return YXcvData(hXcv,
                    pszDataName,
                    pInputData,
                    cbInputData,
                    pOutputData,
                    cbOutputData,
                    pcbOutputNeeded,
                    pdwStatus,
                    RPC_CALL);
}


DWORD
RpcCreatePrinterIC(
    HANDLE  hPrinter,
    HANDLE *pHandle,
    LPDEVMODE_CONTAINER pDevModeContainer
)
{
    return YCreatePrinterIC(hPrinter,
                            pHandle,
                            pDevModeContainer,
                            RPC_CALL);
}

DWORD
RpcPlayGdiScriptOnPrinterIC(
    GDI_HANDLE  hPrinterIC,
    LPBYTE pIn,
    DWORD   cIn,
    LPBYTE pOut,
    DWORD   cOut,
    DWORD   ul
)
{
    return YPlayGdiScriptOnPrinterIC(   hPrinterIC,
                                        pIn,
                                        cIn,
                                        pOut,
                                        cOut,
                                        ul,
                                        RPC_CALL);
}

DWORD
RpcDeletePrinterIC(
    GDI_HANDLE *phPrinterIC
)
{
    return YDeletePrinterIC(phPrinterIC, 1, RPC_CALL);
}


VOID
GDI_HANDLE_rundown(
    HANDLE     hPrinterIC
)
{
    YDeletePrinterIC(&hPrinterIC, 0, RPC_CALL);
}

DWORD
RpcPrinterMessageBox(
   PRINTER_HANDLE hPrinter,
   DWORD          Error,
   ULONG_PTR      hWnd,
   LPWSTR         pText,
   LPWSTR         pCaption,
   DWORD          dwType
)
{
    return YPrinterMessageBox(hPrinter, Error, (HWND)hWnd, pText, pCaption, dwType, RPC_CALL);
}

DWORD
RpcAddMonitor(
   LPWSTR   pName,
   PMONITOR_CONTAINER pMonitorContainer
)
{
    return YAddMonitor( pName,
                        pMonitorContainer,
                        RPC_CALL);
}

DWORD
RpcDeleteMonitor(
   LPWSTR   pName,
   LPWSTR   pEnvironment,
   LPWSTR   pMonitorName
)
{
    return YDeleteMonitor( pName,
                           pEnvironment,
                           pMonitorName,
                           RPC_CALL);
}

DWORD
RpcDeletePrintProcessor(
   LPWSTR   pName,
   LPWSTR   pEnvironment,
   LPWSTR   pPrintProcessorName
)
{
    return YDeletePrintProcessor(pName,
                                 pEnvironment,
                                 pPrintProcessorName,
                                 RPC_CALL);
}

DWORD
RpcAddPrintProvidor(
   LPWSTR   pName,
   PPROVIDOR_CONTAINER pProvidorContainer
)
{
    return YAddPrintProvidor(pName, pProvidorContainer, RPC_CALL);
}

DWORD
RpcDeletePrintProvidor(
   LPWSTR   pName,
   LPWSTR   pEnvironment,
   LPWSTR   pPrintProvidorName
)
{
    return YDeletePrintProvidor(pName,
                                pEnvironment,
                                pPrintProvidorName,
                                RPC_CALL);
}


DWORD
RpcGetPrinterDriver2(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVersion,
    DWORD   dwClientMinorVersion,
    PDWORD  pdwServerMajorVersion,
    PDWORD  pdwServerMinorVersion
)
{
    return YGetPrinterDriver2(hPrinter,
                              pEnvironment,
                              Level,
                              pDriverInfo,
                              cbBuf,
                              pcbNeeded,
                              dwClientMajorVersion,
                              dwClientMinorVersion,
                              pdwServerMajorVersion,
                              pdwServerMinorVersion,
                              RPC_CALL);
}

DWORD
RpcAddPortEx(
    LPWSTR pName,
    LPPORT_CONTAINER pPortContainer,
    LPPORT_VAR_CONTAINER pPortVarContainer,
    LPWSTR pMonitorName
    )
{
    return YAddPortEx(  pName,
                        pPortContainer,
                        pPortVarContainer,
                        pMonitorName,
                        RPC_CALL);
}


DWORD
RpcSpoolerInit(
    LPWSTR pName
)
{
    return YSpoolerInit(pName, RPC_CALL);
}



DWORD
RpcResetPrinterEx(
    HANDLE  hPrinter,
    LPWSTR  pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD   dwFlag

)
{
    return YResetPrinterEx( hPrinter,
                            pDatatype,
                            pDevModeContainer,
                            dwFlag,
                            RPC_CALL);
}

DWORD
RpcSetAllocFailCount(
    HANDLE  hPrinter,
    DWORD   dwFailCount,
    LPDWORD lpdwAllocCount,
    LPDWORD lpdwFreeCount,
    LPDWORD lpdwFailCountHit
)
{
    return YSetAllocFailCount(  hPrinter,
                                dwFailCount,
                                lpdwAllocCount,
                                lpdwFreeCount,
                                lpdwFailCountHit,
                                RPC_CALL);
}

DWORD
RpcSetPort(
    LPWSTR              pName,
    LPWSTR              pPortName,
    LPPORT_CONTAINER    pPortContainer
)
{
    return YSetPort(pName,
                    pPortName,
                    pPortContainer,
                    RPC_CALL);
}


DWORD
RpcClusterSplOpen(
    LPWSTR pszServer,
    LPWSTR pszResource,
    PHANDLE phSpooler,
    LPWSTR pszName,
    LPWSTR pszAddress
    )
{
    return YClusterSplOpen( pszServer,
                            pszResource,
                            phSpooler,
                            pszName,
                            pszAddress,
                            RPC_CALL );
}

DWORD
RpcClusterSplClose(
    PHANDLE phSpooler
    )
{
    return YClusterSplClose( phSpooler, RPC_CALL );
}

DWORD
RpcClusterSplIsAlive(
    HANDLE hSpooler
    )
{
    return YClusterSplIsAlive( hSpooler, RPC_CALL );
}

DWORD
RpcGetSpoolFileInfo(
    HANDLE  hPrinter,
    DWORD   dwAppProcessId,
    DWORD   dwLevel,
    LPBYTE  pSpoolFileInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    return YGetSpoolFileInfo(hPrinter, dwAppProcessId,
                             dwLevel, pSpoolFileInfo,
                             cbBuf, pcbNeeded, RPC_CALL);
}

DWORD
RpcGetSpoolFileInfo2(
    HANDLE  hPrinter,
    DWORD   dwAppProcessId,
    DWORD   dwLevel,
    LPFILE_INFO_CONTAINER  pSplFileInfoContainer
    )
{
    return YGetSpoolFileInfo2(hPrinter, dwAppProcessId,
                             dwLevel, pSplFileInfoContainer,
                             RPC_CALL);
}


DWORD
RpcCommitSpoolData(
    HANDLE  hPrinter,
    DWORD   dwAppProcessId,
    DWORD   cbCommit,
    DWORD   dwLevel,
    LPBYTE  pSpoolFileInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    return YCommitSpoolData(hPrinter, dwAppProcessId, cbCommit,
                            dwLevel, pSpoolFileInfo, cbBuf, pcbNeeded, RPC_CALL);
}

DWORD
RpcCommitSpoolData2(
    HANDLE  hPrinter,
    DWORD   dwAppProcessId,
    DWORD   cbCommit,
    DWORD   dwLevel,
    LPFILE_INFO_CONTAINER  pSplFileInfoContainer)
{
    return YCommitSpoolData2(hPrinter, dwAppProcessId, cbCommit,
                             dwLevel, pSplFileInfoContainer, RPC_CALL);
}



DWORD
RpcCloseSpoolFileHandle(
    HANDLE hPrinter)
{
    return YCloseSpoolFileHandle(hPrinter, RPC_CALL);
}

DWORD
RpcFlushPrinter(
    HANDLE  hPrinter,
    LPBYTE  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
)
{
    return YFlushPrinter( hPrinter,
                          pBuf,
                          cbBuf,
                          pcWritten,
                          cSleep,
                          RPC_CALL);
}

DWORD
RpcSendRecvBidiData(
    IN  HANDLE  hPrinter,
    IN  LPCWSTR pAction,
    IN  PRPC_BIDI_REQUEST_CONTAINER   pReqData,
    OUT PRPC_BIDI_RESPONSE_CONTAINER* ppRespData
)
{
    return ( YSendRecvBidiData(hPrinter,
                               pAction,
                               (PBIDI_REQUEST_CONTAINER)pReqData,
                               (PBIDI_RESPONSE_CONTAINER*)ppRespData,
                               RPC_CALL) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\splctrlh.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    splctrlh.c

Abstract:

    The Spooler Service Control Handling routine. This file contains
    the following functions.

        SpoolerCtrlHandler

Author:

    Krishna Ganugapati      12-Oct-1993

Environment:

    User Mode -Win32

Revision History:

     4-Jan-1999     Khaleds
     Added Code for optimiziting the load time of the spooler by decoupling
     the startup dependency between spoolsv and spoolss

    12-Oct-1993     krishnaG

--*/

//
// Includes
//

#include "precomp.h"
#include "server.h"
#include "client.h"
#include "splsvr.h"
#include "kmspool.h"

extern DWORD dwCallExitProcessOnShutdown;
DWORD
SpoolerCtrlHandler(
    IN  DWORD                   opcode,
    IN  DWORD                   dwEventType,
    IN  PVOID                   pEventData,
    IN  PVOID                   pData
    )

/*++

Routine Description:

    This function receives control requests that come in from the
    Service Controller

Arguments:

    opcode - This is the control code.

Return Value:



--*/

{
    DWORD  dwStatus = NO_ERROR;

    DBGMSG(DBG_TRACE,("Control Request Received\n"));

    switch (opcode) {
    case SERVICE_CONTROL_STOP:
            //
            //
            // When process dies the handle is automatically closed,
            // so no need to keep it.
            //
            (VOID) CreateEvent(NULL, TRUE, TRUE, szSpoolerExitingEvent);
    case SERVICE_CONTROL_SHUTDOWN:

        DBGMSG(DBG_TRACE, ("Control Request = STOP or SHUTDOWN\n"));

        //
        // Start the de-installation.  This call includes the sending of
        // the new status to the Service Controller.
        //

        //
        // Update the Service Status to the pending state.  And wake up
        // all threads so they will read it.
        //

        SpoolerShutdown();
        SetEvent(TerminateEvent);
        

        if ( dwCallExitProcessOnShutdown &&
             opcode == SERVICE_CONTROL_SHUTDOWN ) {

            ExitProcess(0);
        }
        break;


    case SERVICE_CONTROL_INTERROGATE:
        DBGMSG(DBG_TRACE, ("Control Request = INTERROGATE\n"));

        //
        // Send back an UPDATE_ONLY status.
        //

        SpoolerStatusUpdate(UPDATE_ONLY);
        break;

    case SERVICE_CONTROL_DEVICEEVENT:
        dwStatus = SplProcessPnPEvent(dwEventType, pEventData, pData);
        break;

    case SERVICE_CONTROL_POWEREVENT:

        //
        // If the spooler does not allow the system to be powered down, then
        // we can indicate that by returning any Win32 error.
        //
        dwStatus = SplPowerEvent(dwEventType) ? NO_ERROR : ERROR_INVALID_FUNCTION;
        break;

    default:

        DBGMSG(DBG_TRACE, ("Control Request = OTHER\n"));
        SpoolerStatusUpdate(UPDATE_ONLY);
        dwStatus = ERROR_CALL_NOT_IMPLEMENTED;
        break;
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\spldata.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    spldata.c

Abstract:

    Spooler Service Global Data.


Author:

    Krishna Ganugapati (KrishnaG) 17-Oct-1993

Environment:

    User Mode - Win32

Notes:

    optional-notes

Revision History:

    17-October-1993     KrishnaG
        created.


--*/

#include "precomp.h"
#include "server.h"
#include "splsvr.h"

CRITICAL_SECTION ThreadCriticalSection;
SERVICE_STATUS_HANDLE SpoolerStatusHandle;
DWORD SpoolerState;

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING, DBG_ERROR );

SERVICE_TABLE_ENTRY SpoolerServiceDispatchTable[] = {
    { SERVICE_SPOOLER,        SPOOLER_main      },
    { NULL,                   NULL              }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\splmain.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    splmain.c

Abstract:

    This is the main routine for the Windows NT Spooler Service.
    Functions in the file include:

        SPOOLER_main

Author:

    Krishna Ganugapati      (KrishnaG)  12-Oct-1993

Environment:

    User Mode - Win32

Revision History:

     4-Jan-1999     Khaleds
     Added Code for optimiziting the load time of the spooler by decoupling
     the startup dependency between spoolsv and spoolss

    12-Oct-1993     krishnaG
    Created

                                                                                          
--*/

#include "precomp.h"
#include "splsvr.h"
#include "server.h"

HANDLE TerminateEvent = NULL;                             

VOID
SPOOLER_main (
    IN DWORD    argc,
    IN LPTSTR   *argv
    )

/*++

Routine Description:

    This is the main routine for the Spooler Service

Arguments:


Return Value:

    None.

Note:


--*/
{
    if(TerminateEvent = CreateEvent (0, TRUE, FALSE,0))
    {

        SpoolerState = SpoolerInitializeSpooler(argc, argv);
    
        if (SpoolerState != RUNNING) {
    
            DBGMSG(DBG_WARN,("Spooler Shutdown during initialization\n"));
        }
    
    
        if (SpoolerState == STOPPING) {
            SpoolerShutdown();
        }
    
        DBGMSG(DBG_TRACE,("SPOOLER_main: Exiting Spooler Thread\n"));

        WaitForSingleObject(TerminateEvent,INFINITE);
        CloseHandle(TerminateEvent);

        if(hPhase2Init)
        {
            CloseHandle(hPhase2Init);
        }
        SpoolerStatusUpdate (STOPPED);
    }
    else
    {
        DBGMSG(DBG_WARN,("Spooler unable to create Terminate event"));
    }

    ExitThread(0);
    return;
}





VOID
SpoolerShutdown(VOID)

/*++

Routine Description:


Arguments:

    none

Return Value:

    none

--*/

{
    DBGMSG(DBG_TRACE,(" in SpoolerShutdown\n",0));

    // *** SHUTDOWN HINT ***

    SpoolerStatusUpdate (STOPPING);

    //
    // Shut down the router.
    //

    DBGMSG(DBG_TRACE,("SpoolerShutdown: Shut down router\n"));

    SplShutDownRouter();


    //
    // Shut down the RPC interface.
    //

    DBGMSG(DBG_TRACE,("SpoolerShutdown: Shut down RPC server\n"));

    //
    // If we've come here, then we've stopped accepting RPC calls
    //

    DBGMSG(DBG_TRACE, ("SpoolerShutdown: We've serviced all pending requests\n"));

    //
    // Shut down the Spooler


    DBGMSG(DBG_TRACE,("SpoolerShutdown: Done with shutdown\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\splinit.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    splinit.c

Abstract:

    Spooler Service Initialization Routines.
    The following is a list of functions in this file:

        SpoolerInitializeSpooler

Author:

    Krishna Ganugapati (KrishnaG) 17-Oct-1993

Environment:

    User Mode - Win32

Notes:

    optional-notes

Revision History:

     4-Jan-1999     Khaleds
     Added Code for optimiziting the load time of the spooler by decoupling
     the startup dependency between spoolsv and spoolss

    17-October-1993     KrishnaG
    Created.


--*/

#include "precomp.h"
#include "server.h"
#include "client.h"
#include "splsvr.h"
#include "kmspool.h"

DWORD MessageThreadId;     // message thread ID

extern DWORD GetSpoolMessages(VOID);

HANDLE hPhase2Init = NULL;

//
// Following is to make sure only one spooler process runs at a time.
// When spooler is asked to stop it will tell SCM SERVICE_STOPPED but it may
// be some more time before the spoolsv process dies.
// In the meantime if a SCM starts another spooler process it will not
// initialize. This is because GDI assumes one spooler process at a time.
//
// To fix when spooler is asked to stop it creates a named event Spooler_exiting
// The handle to which will be closed when the process dies.
//
// On spooler startup we will look for this event and wait for it to go away.
// A named event goes away when the last handle is closed.
//
//
WCHAR   szSpoolerExitingEvent[] = L"Spooler_exiting";

const PrintSpoolerServerExports gServerExports =
{
    ServerAllowRemoteCalls,
    ServerGetPolicy
};

#define WAITFOR_SPOOLEREXIT_TIMEOUT     3*1000

BOOL
PreInitializeRouter(
    SERVICE_STATUS_HANDLE SpoolerStatusHandle
);

DWORD
SpoolerInitializeSpooler(
    DWORD   argc,
    LPTSTR  *argv
    )

/*++

Routine Description:

    Registers the control handler with the dispatcher thread.  Then it
    performs all initialization including the starting of the RPC server.
    If any of the initialization fails, SpoolerStatusUpdate is called so that the
    status is updated and the thread is terminated.

Arguments:



Return Value:



--*/

{
    RPC_STATUS          rpcStatus;
    DWORD               Win32status;
    HANDLE              hThread, hEvent;
    DWORD               ThreadId;
    ULONG               HeapFragValue = 2;

    //
    // Initialize the ThreadCritical Section which serializes access to
    // the Status database.
    //
    if (!InitializeCriticalSectionAndSpinCount(&ThreadCriticalSection, 0x80000000))
    {
        return GetLastError();
    }

    //
    // Initialize the status structure
    //
    SpoolerStatusInit();

    //
    //  NTRAID#NTBUG9-751157-2002/12/13 : Disable HKCU to prevent driver HKCU leak which 
    //  cause roaming profile loading error.
    //
    RegDisablePredefinedCache();

    //
    // Activate LFH (low fragmentation) for the process heap. We ignore the return value.
    // LHF cannot be activated if certain gflags are set.
    //
    HeapSetInformation(GetProcessHeap(),
                       HeapCompatibilityInformation,
                       &HeapFragValue,
                       sizeof(HeapFragValue));

    //
    // Register this service with the ControlHandler.
    // Now we can accept control requests and be requested to UNINSTALL.
    //

    DBGMSG(DBG_TRACE, ("Calling RegisterServiceCtrlHandler\n"));
    if ((SpoolerStatusHandle = RegisterServiceCtrlHandlerEx(
                                SERVICE_SPOOLER,
                                SpoolerCtrlHandler,
                                NULL
                                )) == (SERVICE_STATUS_HANDLE)ERROR_SUCCESS) {

        Win32status = GetLastError();

        DBGMSG(DBG_ERROR,
            ("FAILURE: RegisterServiceCtrlHandler status = %d\n", Win32status));

        return( SpoolerBeginForcedShutdown (
                    IMMEDIATE,
                    Win32status,
                    (DWORD)0
                    ));
    }


    //
    // Notify that installation is pending
    //

    SpoolerState = SpoolerStatusUpdate(STARTING);

    if (SpoolerState != STARTING) {

        //
        // An UNINSTALL control request must have been received
        //
        return(SpoolerState);
    }

    //
    // If there is another spooler process exiting wait for it to die
    // Look at comments in splctrlh.c
    //
    for ( ; ; ) {

        hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, szSpoolerExitingEvent);
        if ( hEvent == NULL )
            break;

        DBGMSG(DBG_WARNING, ("Waiting for previous spooler to exit\n"));
        CloseHandle(hEvent);
        SpoolerState = SpoolerStatusUpdate(STARTING);

        if (SpoolerState != STARTING) {

            //
            // An UNINSTALL control request must have been received
            //
            return(SpoolerState);
        }

        Sleep(WAITFOR_SPOOLEREXIT_TIMEOUT);
    }

    hPhase2Init = CreateEvent( NULL, TRUE, FALSE, L"RouterPreInitEvent" );

    if (hPhase2Init == NULL)
    {
        //
        // Fail if the event is not created
        //
        DBGMSG(DBG_ERROR, ("Failed to create Phase2Init Event, error %d\n", GetLastError()));
        ExitProcess(0);
    }

    DBGMSG(DBG_TRACE,
        ("SpoolerInitializeSpooler:getting ready to start RPC server\n"));

    rpcStatus = SpoolerStartRpcServer();


    if (rpcStatus != RPC_S_OK) {
        DBGMSG(DBG_WARN, ("RPC Initialization Failed %d\n", rpcStatus));
        return (SpoolerBeginForcedShutdown(
                PENDING,
                rpcStatus,
                (DWORD)0
                ));
    }

    SpoolerStatusUpdate(STARTING);


    DBGMSG(DBG_TRACE,
          ("SpoolerInitializeSpooler:Getting ready to kick off the Router\n"));


    hThread = CreateThread(NULL,
                           LARGE_INITIAL_STACK_COMMIT,
                           (LPTHREAD_START_ROUTINE)PreInitializeRouter,
                           (LPVOID)SpoolerStatusHandle,
                           0,
                           &ThreadId);

    if( hThread ){

        CloseHandle(hThread);

        //
        // Create Kernel Spooler Message Thread
        //
        Win32status=GetSpoolMessages();

    } else {

        Win32status = GetLastError();
    }


    if (Win32status != ERROR_SUCCESS) {
        DBGMSG(DBG_WARNING, ("Kernel Spooler Messaging Initialization Failed %d\n", Win32status));
        return SpoolerBeginForcedShutdown(PENDING, Win32status, (DWORD) 0);
    }


    //
    //  Update the status to indicate that installation is complete.
    //  Get the current state back in case the ControlHandling thread has
    //  told us to shutdown.
    //

    DBGMSG(DBG_TRACE, ("Exiting SpoolerInitializeSpooler - Init Done!\n"));

    return (SpoolerStatusUpdate(RUNNING));
}

BOOL
PreInitializeRouter(
    SERVICE_STATUS_HANDLE SpoolerStatusHandle
)
{
    HANDLE                      hThread        = NULL;
    BOOL                        bRet           = FALSE;
    RouterInitializationParams  *pRouterParams = NULL;
    DWORD                       ThreadId;


    pRouterParams = AllocSplMem(sizeof(*pRouterParams));

    bRet = pRouterParams != NULL;

    if (bRet)
    {
        pRouterParams->SpoolerStatusHandle = SpoolerStatusHandle;
        pRouterParams->pExports = &gServerExports;

        //
        // Wait on hPhase2Init
        //
        WaitForSingleObject( hPhase2Init, SPOOLER_START_PHASE_TWO_INIT );

        hThread = CreateThread(NULL,
                                LARGE_INITIAL_STACK_COMMIT,
                                (LPTHREAD_START_ROUTINE) InitializeRouter,
                                (LPVOID)pRouterParams,
                                0,
                                &ThreadId);
        if (hThread)
        {
            CloseHandle(hThread);
        }
        else
        {
            bRet = FALSE;
            FreeSplMem(pRouterParams);
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\splrpc.c ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    splrpc.c

Abstract:

    This file contains routines for starting and stopping RPC servers.

        SpoolerStartRpcServer
        SpoolerStopRpcServer

Author:

    Krishna Ganugapati  krishnaG

Environment:

    User Mode - Win32

Revision History:


    14-Oct-1993 KrishnaG
        Created
    25-May-1999 khaleds
    Added:
    CreateNamedPipeSecurityDescriptor
    BuildNamedPipeProtection
--*/

#include "precomp.h"
#include "server.h"
#include "srvrmem.h"
#include "splsvr.h"

WCHAR szCallExitProcessOnShutdown []= L"CallExitProcessOnShutdown";
WCHAR szMaxRpcSize []= L"MaxRpcSize";
WCHAR szPrintKey[] = L"System\\CurrentControlSet\\Control\\Print";
CRITICAL_SECTION RpcNamedPipeCriticalSection;

//
// Default RPC buffer max size 50 MB
//
#define DEFAULT_MAX_RPC_SIZE    50 * 1024 * 1024
DWORD dwCallExitProcessOnShutdown = TRUE;

struct
{
    BOOL                        bRpcEndPointEnabled;
    ERemoteRPCEndPointPolicy    ePolicyValue;    
    RPC_STATUS                  RpcStatus;

} gNamedPipeState = {FALSE, RpcEndPointPolicyUnconfigured, RPC_S_OK};

PSECURITY_DESCRIPTOR gpSecurityDescriptor = NULL;


/*++

Routine Description:

    Determines the OS suite of the current system.

Arguments:

    pSuiteMask - pointer to word that is going to hold
                 the OS suite.

Return Value:

    S_OK if succeeded

--*/
HRESULT
GetOSSuite(
    WORD*    pSuiteMask
    )
{
    HRESULT hr = S_OK;

    if (!pSuiteMask)
    {
        hr = HResultFromWin32(ERROR_INVALID_PARAMETER);
    }

    if (SUCCEEDED(hr))
    {
        OSVERSIONINFOEX OSVersionInfoEx = {0};
        OSVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

        *pSuiteMask = 0;

        if (GetVersionEx((OSVERSIONINFO*)&OSVersionInfoEx))
        {
            *pSuiteMask |= OSVersionInfoEx.wSuiteMask;
        }
        else
        {
            hr = HResultFromWin32(GetLastError());
        }
    }    
    
    return hr;
}

RPC_STATUS
SpoolerStartRpcServer(
    VOID)
/*++

Routine Description:


Arguments:



Return Value:

    NERR_Success, or any RPC error codes that can be returned from
    RpcServerUnregisterIf.

--*/
{
    RPC_STATUS              status;
    PSECURITY_DESCRIPTOR    SecurityDescriptor = NULL;
    BOOL                    Bool;
    
    HKEY  hKey;
    DWORD cbData;
    DWORD dwType;
    DWORD dwMaxRpcSize = DEFAULT_MAX_RPC_SIZE;
    WORD  OSSuite;
    
    //
    // Craft up a security descriptor that will grant everyone
    // all access to the object (basically, no security)
    //
    // We do this by putting in a NULL Dacl.
    //
    // NOTE: rpc should copy the security descriptor,
    // Since it currently doesn't, simply allocate it for now and
    // leave it around forever.
    //


    gpSecurityDescriptor = CreateNamedPipeSecurityDescriptor();
    if (gpSecurityDescriptor == 0) {
        DBGMSG(DBG_ERROR, ("Spoolss: out of memory\n"));
        return FALSE;
    }

    
    if (FAILED(GetOSSuite(&OSSuite)))
    {
        DBGMSG(DBG_ERROR, ("Failed to get the OS suite.\n"));
        return FALSE;
    }
    
    if (OSSuite & (VER_SUITE_BLADE | VER_SUITE_EMBEDDED_RESTRICTED))
    {            
        gNamedPipeState.ePolicyValue = RpcEndPointPolicyDisabled;
    }
    else
    {

        gNamedPipeState.ePolicyValue = GetSpoolerNumericPolicyValidate(szRegisterSpoolerRemoteRpcEndPoint,
                                                                       RpcEndPointPolicyUnconfigured,
                                                                       RpcEndPointPolicyDisabled);
    }

    if (gNamedPipeState.ePolicyValue == RpcEndPointPolicyEnabled)
    {
        if (FAILED(RegisterNamedPipe()))
        {
            return FALSE;
        }
    }
    else if (gNamedPipeState.ePolicyValue == RpcEndPointPolicyUnconfigured)
    {
        if (!InitializeCriticalSectionAndSpinCount(&RpcNamedPipeCriticalSection, 0x80000000))
        {
            return FALSE;
        }        
    }

    //
    // For now, ignore the second argument.
    //    
    status = RpcServerUseProtseqEpA("ncalrpc", 10, "spoolss", gpSecurityDescriptor);

    if (status) {
        DBGMSG(DBG_WARN, ("RpcServerUseProtseqEpA 2 = %u\n",status));
        return FALSE;
    }

    
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      szPrintKey,
                      0,
                      KEY_READ,
                      &hKey)) {
        
        //
        // This value can be used to control if spooler controls ExitProcess
        // on shutdown
        //
        cbData = sizeof(dwCallExitProcessOnShutdown);
        RegQueryValueEx(hKey,
                        szCallExitProcessOnShutdown,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwCallExitProcessOnShutdown,
                        &cbData);


        //
        // dwMaxRpcSize specifies the maximum size in bytes of incoming RPC data blocks.
        // 
        cbData = sizeof(dwMaxRpcSize);
        if (RegQueryValueEx(hKey,
                        szMaxRpcSize,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwMaxRpcSize,
                        &cbData) != ERROR_SUCCESS) {
            dwMaxRpcSize = DEFAULT_MAX_RPC_SIZE;
        }

        RegCloseKey(hKey);
    }


    //
    // Now we need to add the interface.  We can just use the winspool_ServerIfHandle
    // specified by the MIDL compiler in the stubs (winspl_s.c).
    //
    status = RpcServerRegisterIf2(  winspool_ServerIfHandle, 
                                    0, 
                                    0,
                                    0,
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                    dwMaxRpcSize,
                                    NULL
                                    );

    if (status) {
        DBGMSG(DBG_WARN, ("RpcServerRegisterIf = %u\n",status));
        return FALSE;
    }

    status = RpcMgmtSetServerStackSize(INITIAL_STACK_COMMIT);

    if (status != RPC_S_OK) {
        DBGMSG(DBG_ERROR, ("Spoolss : RpcMgmtSetServerStackSize = %d\n", status));
    }

    if( (status = RpcServerRegisterAuthInfo(0,
                                            RPC_C_AUTHN_WINNT,
                                            0,
                                            0 )) == RPC_S_OK )
    {
        // The first argument specifies the minimum number of threads to
        // create to handle calls; the second argument specifies the maximum
        // concurrent calls to handle.  The third argument indicates that
        // the routine should not wait.

        status = RpcServerListen(1,SPL_MAX_RPC_CALLS,1); 

        if ( status != RPC_S_OK ) {
             DBGMSG(DBG_ERROR, ("Spoolss : RpcServerListen = %d\n", status));
        }
    }

    return (status);
}




/*++
    Routine Description:
        This routine adds prepares the required masks and flags required for the
        DACL on the named pipes used by RPC

    Arguments:
        None

    Return Value:
        An allocated Security Descriptor

--*/

/*++

Name:

    CreateNamedPipeSecurityDescriptor

Description:

    Creates the security descriptor for the named pipe used by RPC
    
Arguments:

    None.

Return Value:

    valid pointer to SECURITY_DESCRIPTOR structure if successful
    NULL, on error, use GetLastError

--*/
PSECURITY_DESCRIPTOR
CreateNamedPipeSecurityDescriptor(
    VOID
    )
{
    PSECURITY_DESCRIPTOR pServerSD = NULL;
    PCWSTR               pszStringSecDesc = L"D:(A;;0x100003;;;BU)"
                                              L"(A;;0x100003;;;PU)"
                                              L"(A;;0x1201fb;;;WD)"
                                              L"(A;;0x1201fb;;;AN)"
                                              L"(A;;FA;;;CO)"
                                              L"(A;;FA;;;SY)"
                                              L"(A;;FA;;;BA)";        

    //
    // Builtin Users  - FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE
    // Power Users    - FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE
    // Everyone       - FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE | READ_CONTROL | FILE_WRITE_ATTRIBUTES | FILE_READ_EA
    // Anonymous      - FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE | READ_CONTROL | FILE_WRITE_ATTRIBUTES | FILE_READ_EA
    // Creator Owner  - file all access
    // System         - file all access
    // Administrators - file all access
    //
    // Anonymous has more permission than BU and PU. The extra permission is needed by the back channel (pipe) used by the
    // print server to communicate to the client
    //

    if (!ConvertStringSecurityDescriptorToSecurityDescriptor(pszStringSecDesc, 
                                                             SDDL_REVISION_1,
                                                             &pServerSD,
                                                             NULL))
    {
        pServerSD = NULL;
    }

    return pServerSD;
}                  

/*++

Routine Name

    ServerAllowRemoteCalls

Routine Description:

    Enables the RPC pipe if policy permits.
    If the policy is disabled, then it will fail the call.
    If the policy is enbled, then it will succeeded the call without doing anything.
    If the policy is unconfigured, it will attempt to enable the pipe
    if disabled. It keep a retry count and fails directly after 5 times (hardcoded).

Arguments:

    None

Return Value:

    HRESULT

--*/
HRESULT
ServerAllowRemoteCalls(
    VOID
    )
{
    HRESULT hr = S_OK;
    
    if (gNamedPipeState.ePolicyValue == RpcEndPointPolicyUnconfigured)
    {
        EnterCriticalSection(&RpcNamedPipeCriticalSection);

        //
        // Allow retries. Keep RpcStatus for debugging purposes.
        //
        if (!gNamedPipeState.bRpcEndPointEnabled)
        {
            hr                                  = RegisterNamedPipe();
            gNamedPipeState.bRpcEndPointEnabled = SUCCEEDED(hr);
            gNamedPipeState.RpcStatus           = StatusFromHResult(hr);
        }

        LeaveCriticalSection(&RpcNamedPipeCriticalSection);
    }
    else if (gNamedPipeState.ePolicyValue == RpcEndPointPolicyDisabled)
    {
        hr = HResultFromWin32(ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED);        

        DBGMSG(DBG_WARN, ("Remote connections are not allowed.\n"));
    }

    return hr;
}

/*++

Routine Name

    RegisterNamedPipe

Routine Description:

    Registers the named pipe protocol.

Arguments:

    None

Return Value:

    An HRESULT

--*/
HRESULT
RegisterNamedPipe(
    VOID
    )   
{
    RPC_STATUS RpcStatus;
    HRESULT    hr = S_OK;
    HANDLE     hToken;

    if (hToken = RevertToPrinterSelf())
    {
        RpcStatus = RpcServerUseProtseqEpA("ncacn_np", 10, "\\pipe\\spoolss", gpSecurityDescriptor);

        hr = (RpcStatus == RPC_S_OK) ? 
                 S_OK : 
                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_RPC, RpcStatus);

        if (FAILED(hr))
        {
            DBGMSG(DBG_WARN, ("RpcServerUseProtseqEpA (ncalrpc) = %u\n",RpcStatus));
        }

        if (!ImpersonatePrinterClient(hToken) && SUCCEEDED(hr))
        {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, GetLastError());
        }
    }

    return hr;
}



/*++

Routine Name

    ServerGetPolicy

Routine Description:

    Gets a numeric policy value that was read from the server.
    
    This can be called by providers(localspl).
    The policy must be by the server read before initializing providers.    

Arguments:

    pszPolicyName - policy name
    pulValue      - pointer to numeric value


Return Value:

    HRESULT

--*/
HRESULT
ServerGetPolicy(
    IN  PCWSTR  pszPolicyName,
    IN  ULONG*  pulValue
    )
{
    HRESULT hr;
    ULONG   PolicyValue;
    ULONG   Index;
    
    struct 
    {
        PCWSTR   pszName;
        ULONG    ulValue;

    } PolicyTable[] = 
    {
        {szRegisterSpoolerRemoteRpcEndPoint, gNamedPipeState.ePolicyValue},
        {NULL                              , 0}
    };

    hr = (pulValue && pszPolicyName) ? S_OK : E_POINTER;

    if (SUCCEEDED(hr))
    {
        hr = E_INVALIDARG;

        for (Index = 0;  PolicyTable[Index].pszName ; Index++)
        {
            if (_wcsicmp(pszPolicyName, szRegisterSpoolerRemoteRpcEndPoint) == 0)
            {
                PolicyValue = PolicyTable[Index].ulValue;
                hr = S_OK;
                break;
            }
        }
        
        if (SUCCEEDED(hr))
        {
            *pulValue = PolicyValue;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\splkernl.c ===
/*++
Copyright (c) 1990  Microsoft Corporation
All Rights Reserved

Module Name:

    splkernl.c

Abstract:

    This module contains the Spooler's Kernel mode message router and unmarshalling functions,
    which then call kmxxx().

Author:

    Steve Wilson (NT) (swilson) 1-Jun-1995

[Notes:]

    optional-notes

Revision History:


--*/

#include "precomp.h"
#include "server.h"
#include "client.h"
#include "srvrmem.h"
#include "kmspool.h"
#include "yspool.h"
#include "splsvr.h"
#include "wingdip.h"

#define IN_BUF_SIZE     8192    // must be at least 4096
#define OUT_BUF_SIZE    1024 

#define DECREMENT       0
#define INCREMENT       1

#define MAX_GRE_STRUCT_SIZE 100     // At least the size of the largest GRExxx struct in ntgdispl.h
#define WAITFOR_SYSTEM_TO_RECOVER   500 

DWORD cGetSpoolMessage(PSPOOLESC psesc, DWORD cjMsg, PDWORD pulOut, DWORD cjOut);
BOOL SpoolerGetSpoolMessage();

BOOL DoOpenPrinter(PSPOOLESC psesc, HANDLE*, DWORD*);
BOOL DoGetPrinter(PSPOOLESC psesc, GREGETPRINTER *pGetPrinterReturn, DWORD *pcjOut);
BOOL DoGetPrinterDriver( PSPOOLESC, GREGETPRINTERDRIVER*, DWORD* );
BOOL DoStartDocPrinter( PSPOOLESC psesc );
BOOL DoWritePrinter(PSPOOLESC psesc, DWORD *pWritten );
BOOL DoGetForm(PSPOOLESC psesc, GREGETFORM *pGetFormReturn, DWORD *pcjOut);
BOOL DoEnumForms(PSPOOLESC psesc, GREENUMFORMS *pEnumFormsReturn, DWORD *pcjOut);
BOOL DoGetPrinterData(PSPOOLESC psesc, GREGETPRINTERDATA *pXReturn, DWORD *pcjOut);
BOOL DoSetPrinterData(PSPOOLESC psesc, GRESETPRINTERDATA *pXReturn, DWORD *pcjOut);
BOOL DoGetPathName( WCHAR  *pwcSrc, WCHAR  *pwcDst, DWORD cbDst, DWORD  *pcjWritten );
BOOL DoDriverUnloadComplete( WCHAR *pDriverFile );

DWORD GetSpoolMessages();
DWORD AddThread();

LONG nIdleThreads = 0;          // Number of idle threads
LONG nThreads = 0;
SYSTEMTIME LastMessageTime;     // Time at which last message was received


// GetSpoolMessages - Manages creation & deletion of spooler message threads
DWORD GetSpoolMessages()
{

    if (!GdiInitSpool()) {
        DBGMSG(DBG_TRACE, ("Error calling GdiInitSpool()\n"));
        return GetLastError();
    }

    return AddThread();
}

DWORD AddThread()
{
    HANDLE  hThread;
    DWORD   MessageThreadId;
    BOOL    dwError;

    try {
        if(hThread = CreateThread(  NULL,
                                    LARGE_INITIAL_STACK_COMMIT,
                                    (LPTHREAD_START_ROUTINE) SpoolerGetSpoolMessage,
                                    0,
                                    0,
                                    &MessageThreadId)) {
            CloseHandle(hThread);
            dwError = ERROR_SUCCESS;
        } else {
            dwError = GetLastError();
        }
    } except(1) {
        dwError = TranslateExceptionCode(GetExceptionCode());
    }

    return dwError;
}


BOOL SpoolerGetSpoolMessage()
{
    DWORD   dwResult;
    PSPOOLESC pInput;                   // Input buffer that receives messages from Kernel
    BYTE    *pOutput;                   // Output buffer that receives data from KMxxx() spooler calls
    BYTE    *pMem;
    DWORD   cbOut = 0;                  // Size of pOutput
    DWORD   cbIn = IN_BUF_SIZE;         // Size of pInput buffer in bytes
    DWORD   cbOutSize;
    DWORD   dwFailureCount = 0;
    

    if(!(pInput = (PSPOOLESC) SrvrAllocSplMem(cbIn))) {
        DBGMSG(DBG_WARNING, ("Error allocating pInput in SpoolerGetSpoolMessage\n"));
        return FALSE;
    }

    if(!(pOutput = SrvrAllocSplMem(OUT_BUF_SIZE))) {
        SrvrFreeSplMem(pInput);
        DBGMSG(DBG_WARNING, ("Error allocating pInput in SpoolerGetSpoolMessage\n"));
        return FALSE;
    }

    cbOutSize = OUT_BUF_SIZE;

    EnterCriticalSection(&ThreadCriticalSection);

    ++nThreads;

    LeaveCriticalSection(&ThreadCriticalSection);

    while(1) {

        EnterCriticalSection(&ThreadCriticalSection);
        ++nIdleThreads;
        LeaveCriticalSection(&ThreadCriticalSection);

        dwResult = GdiGetSpoolMessage(pInput,cbIn,(PDWORD)pOutput,cbOutSize);

        EnterCriticalSection(&ThreadCriticalSection);
        --nIdleThreads;
        LeaveCriticalSection(&ThreadCriticalSection);


        if(dwResult == 0) {

            dwFailureCount++;
            //
            // We can get into this situation where the machine is out of memory
            // and GdiGetSpoolMessage fails because it cannot probe the memory for the message.
            // Because this thread is to aggressive, it won't give the chance to other threads in the 
            // system to get executed. Put it to sleep for a couple of seconds when that happens.(bug 192434)
            //
            if (dwFailureCount > 1) {

                Sleep(WAITFOR_SYSTEM_TO_RECOVER * dwFailureCount);

                //
                // Note: 4 and WAITFOR_SYSTEM_TO_RECOVER has no significance. 
                // They were arbitrary chosen.
                //
                dwFailureCount %= 4;
            }

        } else {

            dwFailureCount = 0;

            if( (pInput->iMsg != GDISPOOL_TERMINATETHREAD) &&
                (pInput->iMsg != GDISPOOL_INPUT2SMALL)) {

                EnterCriticalSection(&ThreadCriticalSection);

                if(nIdleThreads == 0) {
                    AddThread();
                    DBGMSG(DBG_TRACE, ("Thread Added: nIdle = %d  nThreads = %d\n", nIdleThreads, nThreads));
                }

                LeaveCriticalSection(&ThreadCriticalSection);
            }

            // check if the out buffer needs to be grown or shrunk.

            if ((pInput->cjOut + MAX_GRE_STRUCT_SIZE) > cbOutSize) {

                SrvrFreeSplMem(pOutput);

                pOutput = SrvrAllocSplMem(cbOutSize = pInput->cjOut + MAX_GRE_STRUCT_SIZE);

                if (!pOutput) {

                    DBGMSG(DBG_WARNING, ("Error allocating pInput in SpoolerGetSpoolMessage\n"));
                    pInput->ulRet = 0;
                    cbOut = 0;
                    cbOutSize = 0;
                    continue;
                }
            }
            else if ((pInput->cjOut < OUT_BUF_SIZE) &&
                     (cbOutSize > OUT_BUF_SIZE)) {

                // we want to shrink the buffer

                PBYTE pbTmp = SrvrAllocSplMem(OUT_BUF_SIZE);

                if (pbTmp) {

                    SrvrFreeSplMem(pOutput);

                    pOutput = pbTmp;
                    cbOutSize = OUT_BUF_SIZE;
                }
            }


            if (pInput->iMsg & GDISPOOL_API) {

                SPLASSERT(pInput->hSpool || pInput->iMsg == GDISPOOL_OPENPRINTER);

                if (pInput->iMsg != GDISPOOL_OPENPRINTER || pInput->hSpool) {
                    if (InterlockedIncrement(&((PSPOOL)pInput->hSpool)->cThreads) > 0) {

                        // We are already processing a message & have now gotten a ClosePrinter
                        // We should not get here on any other API
                        SPLASSERT(pInput->iMsg == GDISPOOL_CLOSEPRINTER);

                        pInput->ulRet = TRUE;       // Let Client terminate
                        continue;
                    }
                }
            }


            switch (pInput->iMsg) {
                case GDISPOOL_INPUT2SMALL:
                    DBGMSG(DBG_TRACE,(" - buffer not big enough\n"));

                    pMem = SrvrReallocSplMem(pInput, cbIn, pInput->cjOut);

                    if (!pMem) {

                        DBGMSG(DBG_WARNING, ("Error reallocating pInput in SpoolerGetSpoolMessage\n"));
                        pInput->ulRet = 0;
                    }
                    else {
                        pInput = (PSPOOLESC) pMem;
                        cbIn   = pInput->cjOut;
                        pInput->ulRet = 1;
                    }

                    break;

                case GDISPOOL_TERMINATETHREAD:
                    EnterCriticalSection(&ThreadCriticalSection);

                    // There is 1 way to get here: from a 10 minute Kernel Event timeout

                    if(nIdleThreads > 1) {
                        --nThreads;
                        if (nThreads == 0) {
                            DBGMSG(DBG_WARNING, ("SpoolerGetSpoolMessage nThreads is now ZERO\n"));
                        }

                        DBGMSG(DBG_TRACE, ("Thread Deleted: nIdle = %d  nThreads = %d\n", nIdleThreads, nThreads));

                        LeaveCriticalSection(&ThreadCriticalSection);

                        SrvrFreeSplMem(pInput);
                        SrvrFreeSplMem(pOutput);

                        return TRUE;
                    }

                    LeaveCriticalSection(&ThreadCriticalSection);
                    break;

                case GDISPOOL_WRITE:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_WRITE\n"));
                    pInput->ulRet = DoWritePrinter( pInput, (DWORD*) pOutput );
                    cbOut = sizeof(DWORD);
                    break;

                case GDISPOOL_OPENPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_OPENPRINTER\n"));
                    DoOpenPrinter(pInput,(HANDLE*)pOutput,&cbOut);
                    break;

                case GDISPOOL_STARTDOCPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_STARTDOCPRINTER\n"));
                    DoStartDocPrinter(pInput);
                    break;

                case GDISPOOL_STARTPAGEPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_STARTPAGEPRINTER\n"));
                    pInput->ulRet = KMStartPagePrinter( pInput->hSpool );
                    break;

                case GDISPOOL_ENDPAGEPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_ENDPAGEPRINTER\n"));
                    pInput->ulRet = KMEndPagePrinter( pInput->hSpool );
                    break;

                case GDISPOOL_ENDDOCPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_ENDDOCPRINTER\n"));
                    pInput->ulRet = KMEndDocPrinter( pInput->hSpool );
                    break;

                case GDISPOOL_ENUMFORMS:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_ENUMFORMS\n"));
                    DoEnumForms(pInput, (GREENUMFORMS *) pOutput, &cbOut);
                    break;

                case GDISPOOL_GETPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETPRINTER\n"));
                    DoGetPrinter(pInput, (GREGETPRINTER *) pOutput, &cbOut);
                    break;

                case GDISPOOL_GETFORM:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETFORM\n"));
                    DoGetForm(pInput, (GREGETFORM *) pOutput, &cbOut);
                    break;

                case GDISPOOL_GETPRINTERDRIVER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETPRINTERDRIVER\n"));
                    DoGetPrinterDriver(pInput,(GREGETPRINTERDRIVER*)pOutput,&cbOut);
                    break;

                case GDISPOOL_GETPRINTERDATA:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETPRINTERDATA\n"));
                    DoGetPrinterData(pInput,(GREGETPRINTERDATA *) pOutput,&cbOut);
                    break;

                case GDISPOOL_SETPRINTERDATA:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_SETPRINTERDATA\n"));
                    DoSetPrinterData(pInput,(GRESETPRINTERDATA *) pOutput,&cbOut);
                    break;

                case GDISPOOL_ABORTPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_ABORTPRINTER\n"));
                    pInput->ulRet = KMAbortPrinter( pInput->hSpool );
                    break;

                case GDISPOOL_CLOSEPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_CLOSEPRINTER\n"));
                    pInput->ulRet = KMClosePrinter( pInput->hSpool );
                    break;

                case GDISPOOL_GETPATHNAME:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETPATHNAME\n"));
                    pInput->ulRet = DoGetPathName((WCHAR*)pInput->ajData,
                                                  (WCHAR*)pOutput,
                                                  cbOutSize,
                                                  &cbOut);
                    break;
                
                case GDISPOOL_UNLOADDRIVER_COMPLETE:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_UNLOADDRIVER_COMPLETE\n"));
                    pInput->ulRet = DoDriverUnloadComplete((LPWSTR)pInput->ajData);
                    break;

                default:
                    DBGMSG(DBG_ERROR,(" - invalid message\n"));
                    break;
            }

            if ((pInput->iMsg & GDISPOOL_API) &&
                 pInput->iMsg != GDISPOOL_CLOSEPRINTER &&
                 pInput->iMsg != GDISPOOL_OPENPRINTER &&
                 pInput->hSpool) {

                if (InterlockedDecrement(&((PSPOOL)pInput->hSpool)->cThreads) == 0) {

                    DBGMSG(DBG_TRACE,(" - GDISPOOL_CLOSEPRINTER\n"));
                    pInput->ulRet = KMClosePrinter( pInput->hSpool );
                }
            }
        }
    }
}

BOOL DoOpenPrinter(PSPOOLESC psesc, HANDLE* phPrinter, DWORD* pcjOut)
{
    LPWSTR pPrinterName = NULL;
    PRINTER_DEFAULTSW pDefault;
    GREOPENPRINTER *pOpenPrinter;
    PLONG plData;
    ULONG cbSize;  

    //
    // Make a copy of psesc->ajData if unaligned. The size of duplicated buffer
    // is the first LONG in psesc->ajData ( GREOPENPRINTER.cj ).
    //
    cbSize = *(PLONG)psesc->ajData;

    pOpenPrinter = (GREOPENPRINTER *)AlignKMPtr(psesc->ajData, cbSize);

    if (pOpenPrinter)
    {
        plData      = pOpenPrinter->alData;
        pDefault    = pOpenPrinter->pd;

        // see if there is a printer name?

        if (pOpenPrinter->cjName)
        {
            pPrinterName = (PWCHAR)plData;
            plData += pOpenPrinter->cjName/4;
        }

        // now setup the printer defaults

        if (pOpenPrinter->cjDatatype)
        {
            pDefault.pDatatype = (PWCHAR)plData;
            plData += pOpenPrinter->cjDatatype/4;
        }

        if (pOpenPrinter->cjDevMode)
        {
            pDefault.pDevMode = (PDEVMODEW)plData;
        }

        DBGMSG(DBG_TRACE,
                    ("OpenPrinter(%ls,%ls,%lx,%d)\n",
                    pPrinterName,
                    pDefault.pDatatype,
                    pDefault.pDevMode,
                    pDefault.DesiredAccess) );

        psesc->ulRet = KMOpenPrinterW(pPrinterName,phPrinter,&pDefault);

        DBGMSG( DBG_TRACE,("OpenPrinter returned = %lx\n",psesc->ulRet));

        *pcjOut = sizeof(ULONG_PTR);

        UndoAlignKMPtr( (LPBYTE)pOpenPrinter, psesc->ajData );
    } 
    else 
    {
        psesc->ulRet = FALSE;
    }

    if(psesc->ulRet)
        return TRUE;
    else
        return FALSE;
}

BOOL DoStartDocPrinter( PSPOOLESC psesc )
{
    DOC_INFO_1W di;
    GRESTARTDOCPRINTER *pStartDocPrinter = (GRESTARTDOCPRINTER *)psesc->ajData;
    PLONG plData;

    plData = pStartDocPrinter->alData;

    // see if there is a printer name?

    if (pStartDocPrinter->cjDocName)
    {
        di.pDocName = (PWCHAR)plData;
        plData += pStartDocPrinter->cjDocName/4;
    }
    else
    {
        di.pDocName = NULL;
    }

    if (pStartDocPrinter->cjOutputFile)
    {
        di.pOutputFile = (PWCHAR)plData;
        plData += pStartDocPrinter->cjOutputFile/4;
    }
    else
    {
        di.pOutputFile = NULL;
    }

    if (pStartDocPrinter->cjDatatype)
    {
        di.pDatatype = (PWCHAR)plData;
        plData += pStartDocPrinter->cjDatatype/4;
    }
    else
    {
        di.pDatatype = NULL;
    }

    psesc->ulRet = KMStartDocPrinterW(psesc->hSpool, 1, (LPBYTE) &di);

    if(psesc->ulRet)
        return TRUE;
    else
        return FALSE;
}

BOOL DoEnumForms(
    PSPOOLESC psesc,
    GREENUMFORMS *pEnumFormsReturn,
    DWORD *pcjOut
)
{
    GREENUMFORMS *pEnumForms = (GREENUMFORMS *) psesc->ajData;
    DWORD dwNeeded = 0;
    DWORD dwnForms;

    psesc->ulRet = KMEnumFormsW (   psesc->hSpool,
                                    pEnumForms->dwLevel,
                                    (BYTE *) pEnumFormsReturn->alData,
                                    pEnumForms->cjData,
                                    &dwNeeded,
                                    &pEnumFormsReturn->nForms
                                );

    if (psesc->ulRet) {

        // Set return data size to incoming buffer size since strings are packed at end of in buffer
        pEnumFormsReturn->cjData = pEnumForms->cjData;
        *pcjOut = pEnumForms->cjData + sizeof(GREENUMFORMS);
    }
    else {
        pEnumFormsReturn->cjData = dwNeeded; // This makes client alloc more than needed
        *pcjOut = sizeof(GREENUMFORMS);
    }

    return psesc->ulRet;
}

BOOL DoGetPrinter(
    PSPOOLESC psesc,
    GREGETPRINTER *pGetPrinterReturn,
    DWORD *pcjOut
)
{
    GREGETPRINTER *pGetPrinter = (GREGETPRINTER *) psesc->ajData;
    DWORD dwNeeded = 0;

    psesc->ulRet = KMGetPrinterW (  psesc->hSpool,
                                    pGetPrinter->dwLevel,
                                    (BYTE *) pGetPrinterReturn->alData,
                                    pGetPrinter->cjData,
                                    &dwNeeded
                                  );

    if (psesc->ulRet) {

        // Set return data size to incoming buffer size since strings are packed at end of in buffer
        pGetPrinterReturn->cjData = pGetPrinter->cjData;
        *pcjOut = pGetPrinter->cjData + sizeof(GREGETPRINTER);
    }
    else {
        pGetPrinterReturn->cjData = dwNeeded; // This makes client alloc more than needed
        *pcjOut = sizeof(GREGETPRINTER);
    }

    return psesc->ulRet;
}

BOOL DoGetForm(
    PSPOOLESC psesc,
    GREGETFORM *pGetFormReturn,
    DWORD *pcjOut
)
{
    GREGETFORM *pGetForm = (GREGETFORM *) psesc->ajData;
    DWORD dwNeeded = 0;

    psesc->ulRet = KMGetFormW (   psesc->hSpool,
                                  pGetForm->cjFormName ? (PWCHAR) pGetForm->alData : NULL,
                                  pGetForm->dwLevel,
                                  (BYTE *) pGetFormReturn->alData,
                                  pGetForm->cjData,
                                  &dwNeeded
                              );

    if (psesc->ulRet) {

        // Set return data size to incoming buffer size since strings are packed at end of in buffer
        pGetFormReturn->cjData = pGetForm->cjData;
        *pcjOut = pGetForm->cjData + sizeof(GREGETFORM);
    }
    else {
        pGetFormReturn->cjData = dwNeeded; // This makes client alloc more than needed
        *pcjOut = sizeof(GREGETFORM);
    }

    return psesc->ulRet;
}


BOOL DoGetPrinterDriver(
    PSPOOLESC psesc,
    GREGETPRINTERDRIVER *pGetPrinterDriverReturn,
    DWORD *pcjOut
    )
{
    GREGETPRINTERDRIVER *pGetPrinterDriver = (GREGETPRINTERDRIVER *)psesc->ajData;
    DWORD dwNeeded = 0;

    psesc->ulRet = KMGetPrinterDriverW(psesc->hSpool,
                                      pGetPrinterDriver->cjEnv ? (PWCHAR)pGetPrinterDriver->alData : NULL,
                                      pGetPrinterDriver->dwLevel,
                                      (BYTE*)pGetPrinterDriverReturn->alData,
                                      pGetPrinterDriver->cjData,
                                      &dwNeeded );

    if (psesc->ulRet)
    {
        pGetPrinterDriverReturn->cjData = pGetPrinterDriver->cjData;  // fix for ValidateStrings in spool.cxx
        *pcjOut = pGetPrinterDriver->cjData + sizeof(GREGETPRINTERDRIVER);
    }
    else
    {
        // we failed so just return the size

        pGetPrinterDriverReturn->cjData = dwNeeded;
        *pcjOut = sizeof(GREGETPRINTERDRIVER);
    }


    if(psesc->ulRet)
        return TRUE;

    return FALSE;
}

BOOL DoGetPrinterData(
    PSPOOLESC psesc,
    GREGETPRINTERDATA *pXReturn,
    DWORD *pcjOut
    )
{
    GREGETPRINTERDATA *pX = (GREGETPRINTERDATA *) psesc->ajData;

    DWORD dwNeeded = 0;        // return values
    DWORD dwType;


    psesc->ulRet = KMGetPrinterDataW( psesc->hSpool,
                                      pX->cjValueName ? (PWCHAR) pX->alData : NULL,
                                      &dwType,
                                      (BYTE *) pXReturn->alData,
                                      pX->cjData,
                                      &dwNeeded );

    pXReturn->dwNeeded = dwNeeded;
    pXReturn->cjData = pX->cjData;
    *pcjOut = pX->cjData + sizeof *pX;
    pXReturn->dwType = dwType;

    SetLastError(psesc->ulRet);

    return psesc->ulRet = !psesc->ulRet;
}


BOOL DoSetPrinterData(
    PSPOOLESC psesc,
    GRESETPRINTERDATA *pXReturn,
    DWORD *pcjOut
    )
{
    GRESETPRINTERDATA *pX = (GRESETPRINTERDATA *) psesc->ajData;


    psesc->ulRet = KMSetPrinterDataW( psesc->hSpool,
                                      pX->cjType ? (PWCHAR) pX->alData : NULL,
                                      pX->dwType,
                                      pX->cjPrinterData ? (BYTE *) pX->alData + pX->cjType : NULL,
                                      pX->cjPrinterData );

    *pcjOut = sizeof *pX;

    SetLastError(psesc->ulRet);

    return psesc->ulRet = !psesc->ulRet;
}

BOOL DoWritePrinter(PSPOOLESC psesc, DWORD *pWritten )
{
    GREWRITEPRINTER *pWritePrinter;
    BOOL bReturn;
    ULONG  cbSize;  
    
    //
    // Make a copy of psesc->ajData if unaligned. The size of duplicated buffer
    // is the first LONG in psesc->ajData ( GREWRITEPRINTER.cj ).
    //
    cbSize = *(PLONG)psesc->ajData;

    pWritePrinter = (GREWRITEPRINTER *)AlignKMPtr(psesc->ajData, cbSize);

    if ( !pWritePrinter ) {

        return FALSE;
    }

    if (pWritePrinter->pUserModeData) {

        DBGMSG(DBG_TRACE,("WritePrinter UserMode data %0x\n", pWritePrinter->pUserModeData));
        bReturn = KMWritePrinter(   psesc->hSpool,
                                    (PVOID) pWritePrinter->pUserModeData,
                                    pWritePrinter->cjUserModeData,
                                    pWritten);

    } else {

        DBGMSG(DBG_TRACE,("WritePrinter KernelMode data %0x\n", pWritePrinter->alData));
        bReturn = KMWritePrinter( psesc->hSpool,
                                  (PVOID) pWritePrinter->alData,
                                  pWritePrinter->cjData,
                                  pWritten);
    }

    UndoAlignKMPtr((LPBYTE)pWritePrinter, psesc->ajData );

    return bReturn;
}

BOOL 
DoDriverUnloadComplete(
    WCHAR *pDriverFile 
    )
{
    HRESULT  hRet = S_OK;
    WCHAR    szSystemRoot[] = L"\\SystemRoot\\System32";
    DWORD    dwLength;
    
    dwLength = wcslen(szSystemRoot);

    //
    // Check the validity of the driver file name
    //
    if (pDriverFile && wcslen(pDriverFile) >= dwLength) 
    {
        WCHAR szFullFileName[MAX_PATH + 1];
    
        //
        // Convert kernel mode system relative path to x:\....\system32\spool\...
        //
        if (GetSystemDirectory(szFullFileName, MAX_PATH)) 
        {
            if (!_wcsnicmp(pDriverFile, szSystemRoot, dwLength)) 
            {
                hRet = StringCchCatW(szFullFileName, COUNTOF(szFullFileName), pDriverFile + dwLength);
            } 
            else 
            {
                hRet = StringCchCopyW(szFullFileName, COUNTOF(szFullFileName), pDriverFile);
            }
        
            YDriverUnloadComplete(szFullFileName);
        }
    }

    return SUCCEEDED(hRet);
}


BOOL DoGetPathName( WCHAR  *pwcSrc, WCHAR  *pwcDst, DWORD cbDst, DWORD  *pcjWritten )
{
    BOOL    bRet;
    WCHAR   awcFontsDir[MAX_PATH + sizeof(L"\\DOSDEVICES\\")/sizeof(WCHAR)] = {L"\\DOSDEVICES\\"};

    bRet = bMakePathNameW (
            &awcFontsDir[sizeof(L"\\DOSDEVICES\\")/sizeof(WCHAR) - 1],
            pwcSrc,
            NULL,
            NULL
            );


    if (bRet)
    {
        bRet = SUCCEEDED(StringCbCopyW(pwcDst, cbDst, awcFontsDir));
        *pcjWritten = sizeof(WCHAR) * (wcslen(awcFontsDir) + 1);
    }

    //
    // Buffer large enough and search successfull?
    //
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\splstat.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    splstat.c

Abstract:

    Routines for managing access to the status information and reporting:

        SpoolerStatusInit
        SpoolerBeginForcedShutdown
        SpoolerStatusUpdate
        GetSpoolerState

Author:

    Krishna Ganugapati (KrishnaG)     17-Oct-1993

Environment:

    User Mode -Win32

Notes:


Revision History:

    17-Oct-1993     KrishnaG
        created

--*/

#include "precomp.h"
#include "server.h"
#include "splsvr.h"

// Static Data
//

    static DWORD            Next;
    static DWORD            InstallState;
    static SERVICE_STATUS   SpoolerStatus;
    static DWORD            HintCount;
    static DWORD            SpoolerUninstallCode;  // reason for uninstalling


VOID
SpoolerStatusInit(VOID)

/*++

Routine Description:

    Initializes the status database.

Arguments:

    none.

Return Value:

    none.

Note:


--*/
{
    EnterCriticalSection(&ThreadCriticalSection);

    SpoolerState=STARTING;

    HintCount = 1;
    SpoolerUninstallCode = 0;

    SpoolerStatus.dwServiceType        = SERVICE_WIN32;
    SpoolerStatus.dwCurrentState       = SERVICE_START_PENDING;
    SpoolerStatus.dwControlsAccepted   = 0;
    SpoolerStatus.dwCheckPoint         = HintCount;
    SpoolerStatus.dwWaitHint           = 20000;  // 20 seconds
    SpoolerStatus.dwWin32ExitCode      = NO_ERROR;
    SpoolerStatus.dwServiceSpecificExitCode = NO_ERROR;

    LeaveCriticalSection(&ThreadCriticalSection);
    return;
}

DWORD
SpoolerBeginForcedShutdown(
    IN BOOL     PendingCode,
    IN DWORD    Win32ExitCode,
    IN DWORD    ServiceSpecificExitCode
    )

/*++

Routine Description:

    This function is called to set the appropriate status when a shutdown
    is to occur due to an error in the Spooler.  NOTE:  if a shutdown is
    based on a request from the Service Controller, SpoolerStatusUpdate is
    called instead.


Arguments:

    PendingCode - Indicates if the Shutdown is immediate or pending.  If
        PENDING, the shutdown will take some time, so a pending status is
        sent to the ServiceController.

    ExitCode - Indicates the reason for the shutdown.

Return Value:

    CurrentState - Contains the current state that the spooler is in
        upon exit from this routine.  In this case it will be STOPPED
        if the PendingCode is PENDING, or STOPPING if the PendingCode
        is IMMEDIATE.

Note:

    We need to clean this code up!


--*/
{
    DWORD status;

    EnterCriticalSection(&ThreadCriticalSection);

    //
    // See if the Spooler is already stopping for some reason.
    // It could be that the ControlHandler thread received a control to
    // stop the Spooler just as we decided to stop ourselves.
    //

    if ((SpoolerState != STOPPING) && (SpoolerState != STOPPED)) {

        if (PendingCode == PENDING) {
            SpoolerStatus.dwCurrentState = SERVICE_STOP_PENDING;
            SpoolerState = STOPPING;
        }
        else {
            //
            // The shutdown is to take immediate effect.
            //
            SpoolerStatus.dwCurrentState = SERVICE_STOPPED;
            SpoolerStatus.dwControlsAccepted = 0;
            SpoolerStatus.dwCheckPoint = 0;
            SpoolerStatus.dwWaitHint = 0;
            SpoolerState = STOPPED;
        }

        SpoolerUninstallCode = Win32ExitCode;
        SpoolerStatus.dwWin32ExitCode = Win32ExitCode;
        SpoolerStatus.dwServiceSpecificExitCode = ServiceSpecificExitCode;

    }

    //
    // Send the new status to the service controller.
    //
    if (!SpoolerStatusHandle) {
        DBGMSG(DBG_ERROR,
            ("SpoolerBeginForcedShutdown, no handle to call SetServiceStatus\n"));

    }
    else if (! SetServiceStatus( SpoolerStatusHandle, &SpoolerStatus )) {

        status = GetLastError();

        if (status != NERR_Success) {
            DBGMSG(ERROR,
                ("SpoolerBeginForcedShutdown,SetServiceStatus Failed %X\n",
                status));
        }
    }

    status = SpoolerState;
    LeaveCriticalSection(&ThreadCriticalSection);
    return(status);


}


DWORD
SpoolerStatusUpdate(
    IN DWORD    NewState
    )

/*++

Routine Description:

    Sends a status to the Service Controller via SetServiceStatus.

    The contents of the status message is controlled by this routine.
    The caller simply passes in the desired state, and this routine does
    the rest.  For instance, if the Spooler passes in a STARTING state,
    This routine will update the hint count that it maintains, and send
    the appropriate information in the SetServiceStatus call.

    This routine uses transitions in state to send determine which status
    to send.  For instance if the status was STARTING, and has changed
    to RUNNING, this routine sends out an INSTALLED to the Service
    Controller.

Arguments:

    NewState - Can be any of the state flags:
                UPDATE_ONLY - Simply send out the current status
                STARTING - The Spooler is in the process of initializing
                RUNNING - The Spooler has finished with initialization
                STOPPING - The Spooler is in the process of shutting down
                STOPPED - The Spooler has completed the shutdown.

Return Value:

    CurrentState - This may not be the same as the NewState that was
        passed in.  It could be that the main thread is sending in a new
        install state just after the Control Handler set the state to
        STOPPING.  In this case, the STOPPING state will be returned so as
        to inform the main thread that a shut-down is in process.

Note:


--*/

{
    DWORD       status;
    BOOL        inhibit = FALSE;    // Used to inhibit sending the status
                                    // to the service controller.

    EnterCriticalSection(&ThreadCriticalSection);


    if (NewState == STOPPED) {
        if (SpoolerState == STOPPED) {
            //
            // It was already stopped, don't send another SetServiceStatus.
            //
            inhibit = TRUE;
        }
        else {
            //
            // The shut down is complete, indicate that the spooler
            // has stopped.
            //
            SpoolerStatus.dwCurrentState =  SERVICE_STOPPED;
            SpoolerStatus.dwControlsAccepted = 0;
            SpoolerStatus.dwCheckPoint = 0;
            SpoolerStatus.dwWaitHint = 0;
            SpoolerStatus.dwWin32ExitCode = NO_ERROR;
            SpoolerStatus.dwServiceSpecificExitCode = NO_ERROR;
        }
        SpoolerState = NewState;
    }
    else {
        //
        // We are not being asked to change to the STOPPED state.
        //
        switch(SpoolerState) {

        case STARTING:
            if (NewState == STOPPING) {

                SpoolerStatus.dwCurrentState =  SERVICE_STOP_PENDING;
                SpoolerStatus.dwControlsAccepted = 0;
                SpoolerStatus.dwCheckPoint = HintCount++;
                SpoolerStatus.dwWaitHint = 20000;  // 20 seconds
                SpoolerState = NewState;
            }

            else if (NewState == RUNNING) {

                //
                // The Spooler Service has completed installation.
                //
                SpoolerStatus.dwCurrentState =  SERVICE_RUNNING;
                //
                // The Spooler Service cannot be stopped once started
                //
                SpoolerStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                                   SERVICE_ACCEPT_SHUTDOWN |
                                                   SERVICE_ACCEPT_POWEREVENT;
                SpoolerStatus.dwCheckPoint = 0;
                SpoolerStatus.dwWaitHint = 0;

                SpoolerState = NewState;
            }

            else {
                //
                // The NewState must be STARTING.  So update the pending
                // count
                //

                SpoolerStatus.dwCurrentState =  SERVICE_START_PENDING;
                SpoolerStatus.dwControlsAccepted = 0;
                SpoolerStatus.dwCheckPoint = HintCount++;
                SpoolerStatus.dwWaitHint = 20000;  // 20 seconds
            }
            break;

        case RUNNING:
            if (NewState == STOPPING) {

                SpoolerStatus.dwCurrentState =  SERVICE_STOP_PENDING;
                SpoolerStatus.dwControlsAccepted = 0;
                SpoolerStatus.dwCheckPoint = HintCount++;
                SpoolerStatus.dwWaitHint = 20000;  // 20 seconds

                SpoolerState = NewState;
            }
            
            break;

        case STOPPING:
            //
            // No matter what else was passed in, force the status to
            // indicate that a shutdown is pending.
            //
            SpoolerStatus.dwCurrentState =  SERVICE_STOPPED;
            SpoolerStatus.dwControlsAccepted = 0;
            SpoolerStatus.dwCheckPoint = 0;
            SpoolerStatus.dwWaitHint = 0;  // 20 seconds

            break;

        case STOPPED:
            //
            // We're already stopped.  Therefore, an uninstalled status
            // as already been sent.  Do nothing.
            //
            inhibit = TRUE;
            break;
        }
    }

    if (!inhibit) {
        if (!SpoolerStatusHandle) {
            DBGMSG(DBG_ERROR,("SpoolerStatusUpdate, no handle to call SetServiceStatus\n"));

        }
        else if (! SetServiceStatus( SpoolerStatusHandle, &SpoolerStatus )) {

            status = GetLastError();

            if (status != NERR_Success) {
                DBGMSG(DBG_WARN, ("SpoolerStatusUpdate, SetServiceStatus Failed %d\n",status));
            }
        }
    }

    status = SpoolerState;
    LeaveCriticalSection(&ThreadCriticalSection);
    return(status);
}

DWORD
GetSpoolerState (
    VOID
    )

/*++

Routine Description:

    Obtains the state of the Spooler Service.  This state information
    is protected as a critical section such that only one thread can
    modify or read it at a time.

Arguments:

    none

Return Value:

    The Spooler State is returned as the return value.

--*/
{
    DWORD   status;

    EnterCriticalSection(&ThreadCriticalSection);
    status = SpoolerState;
    LeaveCriticalSection(&ThreadCriticalSection);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\spoolss.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    splsvc.c

Abstract:

    This is the main routine for the Spooler Service.

Author:

    Krishna Ganugapati (KrishnaG)    17-October-1992

Environment:

    User Mode - Win32

Revision History:

    17-Oct-1993         KrishnaG
        created

--*/

#include "precomp.h"
#include "splsvr.h"
#include "server.h"

void __cdecl
main (
    int argc,
    unsigned char * argv[]
    )

/*++

Routine Description:

    This is a main routine for the Windows NT Spooler Services.

    It basically sets up the ControlDispatcher and, on return, exits from
    this main thread. The call to NetServiceStartCtrlDispatcher does
    not return until all services have terminated, and this process can
    go away.

    It will be up to the ControlDispatcher thread to start/stop/pause/continue
    any services. If a service is to be started, it will create a thread
    and then call the main routine of that service.


Arguments:

    Anything passed in from the "command line". Currently, NOTHING.

Return Value:

    NONE

Note:


--*/
{
#if DBG
    //
    // Debugging: if started with "ns" then don't start as service.
    //

    if (argc == 2 && !lstrcmpiA("ns", argv[1])) {

        SpoolerStartRpcServer();
        InitializeRouter((SERVICE_STATUS_HANDLE)0);

        return;
    }
#endif


    //
    // Call NetServiceStartCtrlDispatcher to set up the control interface.
    // The API won't return until all services have been terminated. At that
    // point, we just exit.
    //

    if (! StartServiceCtrlDispatcher (SpoolerServiceDispatchTable)) {

        //
        // It would be good to also log an Event here.
        //
        DBGMSG(DBG_ERROR, ("Fail to start control dispatcher %lu\n",GetLastError()));
    }


    ExitProcess(0);

    DBG_UNREFERENCED_PARAMETER( argc );
    DBG_UNREFERENCED_PARAMETER( argv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\splsvr.h ===
/*++

Copyright (c) 1106990  Microsoft Corporation

Module Name:

    splsvr.h

Abstract:

    Header file for Spooler Service.
    Contains all function prototypes

Author:

    Krishna Ganugapati (KrishnaG) 18-Oct-1993

Notes:

Revision History:
     4-Jan-1999     Khaleds
     Added Code for optimiziting the load time of the spooler by decoupling
     the startup dependency between spoolsv and spoolss
--*/
//
// Spooler Service  States (used as return codes)
//

#define UPDATE_ONLY         0   // no change in state - just send current status.
#define STARTING            1   // the messenger is initializing.
#define RUNNING             2   // initialization completed normally - now running
#define STOPPING            3   // uninstall pending
#define STOPPED             4   // uninstalled

//
// Forced Shutdown PendingCodes
//
#define PENDING     TRUE
#define IMMEDIATE   FALSE

#define SPOOLER_START_PHASE_TWO_INIT 2*60*1000

//
// Based on the data fed back to us from perf devs,
// the maximum number of threads encountered in their
// tests was 2385 threads at the rate of ~12000
// jobs/min. This is at 72% CPU capacity and so the
// following number is suggested as a threshold to
// be on the safe side with serving i/p concurrent
// RPC client requests
//
#define SPL_MAX_RPC_CALLS 6000

extern HANDLE TerminateEvent;
extern HANDLE hPhase2Init;
extern WCHAR  szSpoolerExitingEvent[];


//
// Function Prototypes
//


DWORD
GetSpoolerState (
    VOID
    );

DWORD
SpoolerBeginForcedShutdown(
    IN BOOL     PendingCode,
    IN DWORD    Win32ExitCode,
    IN DWORD    ServiceSpecificExitCode
    );


DWORD
SpoolerInitializeSpooler(
    DWORD   argc,
    LPTSTR  *argv
    );


VOID
SpoolerShutdown(VOID);


VOID
SpoolerStatusInit(VOID);

DWORD
SpoolerStatusUpdate(
    IN DWORD    NewState
    );


DWORD
SpoolerCtrlHandler(
    IN  DWORD                   opcode,
    IN  DWORD                   dwEventType,
    IN  PVOID                   pEventData,
    IN  PVOID                   pData
    );

DWORD
SplProcessPnPEvent(
    IN  DWORD                   dwEventType,
    IN  PVOID                   pEventData,
    IN  PVOID                   pData
    );

VOID
SplStartPhase2Init(
    VOID);

BOOL
SplPowerEvent(
    DWORD
    );

RPC_STATUS
SpoolerStartRpcServer(
    VOID
    );



RPC_STATUS
SpoolerStopRpcServer(
    VOID
    );

VOID
SPOOLER_main (
    IN DWORD    argc,
    IN LPTSTR   argv[]
    );

PSECURITY_DESCRIPTOR
CreateNamedPipeSecurityDescriptor(
    VOID
    );

BOOL
BuildNamedPipeProtection(
    IN PUCHAR AceType,
    IN DWORD AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN BYTE *InheritFlags,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMap,
    OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    );

HRESULT
ServerAllowRemoteCalls(
    VOID
    );

HRESULT
RegisterNamedPipe(
    VOID
    );

HRESULT
ServerGetPolicy(
    IN  PCWSTR  pszPolicyName,
    IN  ULONG*  pulValue
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\winspls.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    winsplc.c

Abstract:

    Stub file to allow winspl_c.c to work with precompiled headers.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#include "winspl_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\srvrmem.h ===
/*++

Copyright (c) 1999  Microsoft Corporation
All rights reserved.

Module Name:

    srvrmem.h

Abstract:

    Prototypes for Memory Allocation routines for spoolsv.exe.

Author:

    Khaled Sedky (Khaleds)  13-Jan-1999

Revision History:

--*/


#ifndef _SRVRMEM_H_
#define _SRVRMEM_H_

#define DWORD_ALIGN_UP(size) (((size)+3)&~3)

LPVOID
SrvrAllocSplMem(
    DWORD cb
);

BOOL
SrvrFreeSplMem(
   LPVOID pMem
);

LPVOID
SrvrReallocSplMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\srvrmem.c ===
/*++

Copyright (c) 1999  Microsoft Corporation
All rights reserved.

Module Name:

    srvrmem.c

Abstract:

    Memory Allocation Routines for spoolsv.exe.

Author:

    Khaled Sedky (khaleds)  13-Jan-1999

Revision History:

--*/

#include "precomp.h"
#include "server.h"
#include "srvrmem.h"

LPVOID
SrvrAllocSplMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
    LPDWORD  pMem;
    DWORD    cbNew;

    cb = DWORD_ALIGN_UP(cb);

    cbNew = cb+sizeof(DWORD_PTR)+sizeof(DWORD);

    pMem=(LPDWORD)LocalAlloc(LPTR, cbNew);

    if (!pMem) {

        DBGMSG( DBG_WARNING, ("Memory Allocation failed for %d bytes\n", cbNew ));
        return 0;
    }

    *pMem=cb;

    *(LPDWORD)((LPBYTE)pMem+cbNew-sizeof(DWORD))=0xdeadbeef;

    return (LPVOID)(pMem+sizeof(DWORD_PTR)/sizeof(DWORD));
}

BOOL
SrvrFreeSplMem(
   LPVOID pMem
)
{
    DWORD   cbNew;
    LPDWORD pNewMem;

    if( !pMem ){
        return TRUE;
    }
    pNewMem = pMem;
    pNewMem -= sizeof(DWORD_PTR) / sizeof(DWORD);

    cbNew = *pNewMem;

    if (*(LPDWORD)((LPBYTE)pMem + cbNew) != 0xdeadbeef) {
        DBGMSG(DBG_ERROR, ("DllFreeSplMem Corrupt Memory in winspool : %0lx\n", pNewMem));
        return FALSE;
    }

    memset(pNewMem, 0x65, cbNew);

    LocalFree((LPVOID)pNewMem);

    return TRUE;
}

LPVOID
SrvrReallocSplMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=SrvrAllocSplMem(cbNew);

    if (!pNewMem)
    {

        DBGMSG( DBG_WARNING, ("Memory ReAllocation failed for %d bytes\n", cbNew ));
    }
    else
    {
        if (pOldMem)
        {
            if (cbOld)
            {
                memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
            }
            SrvrFreeSplMem(pOldMem);
       }
    }
    return pNewMem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\idl\idlstub.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/
#ifndef __IMPORT_H__
#define __IMPORT_H__

#ifdef MIDL_PASS
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPDEVMODEW   DWORD
#define PSECURITY_DESCRIPTOR DWORD
#define BOOL        DWORD
#endif

#include <winspool.h>
#include <winsplp.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\yspool.h ===
/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:

    yspool.h

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Print Providor Routing layer

Author:

   AdinaTru 02/25/2000 

[Notes:]

    optional-notes

Revision History:

    
--*/

#include "mtype.h"

DWORD
YEnumPrinters(
    DWORD Flags,
    LPWSTR Name,
    DWORD Level,
    LPBYTE pPrinterEnum,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
    );

DWORD
YOpenPrinter(
    LPWSTR pPrinterName,
    HANDLE *phPrinter,
    LPWSTR pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD AccessRequired,
    CALL_ROUTE   Route
    );

DWORD
YOpenPrinterEx(
    LPWSTR pPrinterName,
    HANDLE *phPrinter,
    LPWSTR pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD AccessRequired,
    CALL_ROUTE   Route,
    PSPLCLIENT_CONTAINER pSplClientContainer
    );

DWORD
YResetPrinter(
    HANDLE hPrinter,
    LPWSTR pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    CALL_ROUTE   Route
    );

DWORD
YSetJob(
    HANDLE hPrinter,
    DWORD JobId,
    JOB_CONTAINER *pJobContainer,
    DWORD Command,
    CALL_ROUTE   Route
    );

DWORD
YGetJob(
    HANDLE hPrinter,
    DWORD JobId,
    DWORD Level,
    LPBYTE pJob,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YEnumJobs(
    HANDLE hPrinter,
    DWORD FirstJob,
    DWORD NoJobs,
    DWORD Level,
    LPBYTE pJob,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
    );

DWORD
YAddPrinter(
    LPWSTR pName,
    PPRINTER_CONTAINER pPrinterContainer,
    PDEVMODE_CONTAINER pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    HANDLE *phPrinter,
    CALL_ROUTE   Route
    );

DWORD
YAddPrinterEx(
    LPWSTR                  pName,
    PPRINTER_CONTAINER      pPrinterContainer,
    PDEVMODE_CONTAINER      pDevModeContainer,
    PSECURITY_CONTAINER     pSecurityContainer,
    HANDLE                 *phPrinter,
    CALL_ROUTE              Route,
    PSPLCLIENT_CONTAINER    pSplClientContainer
    );

DWORD
YDeletePrinter(
    HANDLE hPrinter,
    CALL_ROUTE   Route
    );

DWORD
YAddPrinterConnection(
    LPWSTR pName,
    CALL_ROUTE   Route
    );

DWORD
YDeletePrinterConnection(
    LPWSTR pName,
    CALL_ROUTE   Route
    );

DWORD
YSetPrinter(
    HANDLE hPrinter,
    PPRINTER_CONTAINER pPrinterContainer,
    PDEVMODE_CONTAINER pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    DWORD Command,
    CALL_ROUTE   Route
    );

DWORD
YGetPrinter(
    HANDLE hPrinter,
    DWORD Level,
    LPBYTE pPrinter,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YAddPrinterDriver(
    LPWSTR pName,
    LPDRIVER_CONTAINER pDriverContainer,
    CALL_ROUTE   Route
    );

DWORD
YAddPrinterDriverEx(
    LPWSTR  pName,
    LPDRIVER_CONTAINER pDriverContainer,
    DWORD   dwFileCopyFlags,
    CALL_ROUTE   Route
);

DWORD
YAddDriverCatalog(
    HANDLE  hPrinter,
    DRIVER_INFCAT_CONTAINER *pDriverInfCatContainer,
    DWORD   dwCatalogCopyFlags,
    CALL_ROUTE   Route
);

DWORD
YEnumPrinterDrivers(
    LPWSTR pName,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pDrivers,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
    );

DWORD
YGetPrinterDriver(
    HANDLE hPrinter,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pDriverInfo,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YGetPrinterDriverDirectory(
    LPWSTR pName,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pDriverInfo,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YDeletePrinterDriver(
    LPWSTR pName,
    LPWSTR pEnvironment,
    LPWSTR pDriverName,
    CALL_ROUTE   Route
    );


DWORD
YDeletePrinterDriverEx(
    LPWSTR pName,
    LPWSTR pEnvironment,
    LPWSTR pDriverName,
    DWORD  dwDeleteFlag,
    DWORD  dwVersionNum,
    CALL_ROUTE   Route
    );


DWORD
YAddPerMachineConnection(
    LPWSTR pServer,
    LPCWSTR pPrinterName,
    LPCWSTR pPrintServer,
    LPCWSTR pProvider,
    CALL_ROUTE   Route
    );

DWORD
YDeletePerMachineConnection(
    LPWSTR pServer,
    LPCWSTR pPrinterName,
    CALL_ROUTE   Route
    );

DWORD
YEnumPerMachineConnections(
    LPWSTR pServer,
    LPBYTE pPrinterEnum,
    DWORD  cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
    );

DWORD
YAddPrintProcessor(
    LPWSTR pName,
    LPWSTR pEnvironment,
    LPWSTR pPathName,
    LPWSTR pPrintProcessorName,
    CALL_ROUTE   Route
    );

DWORD
YEnumPrintProcessors(
    LPWSTR pName,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pPrintProcessors,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
    );

DWORD
YGetPrintProcessorDirectory(
    LPWSTR pName,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pPrintProcessorInfo,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YEnumPrintProcessorDatatypes(
    LPWSTR pName,
    LPWSTR pPrintProcessorName,
    DWORD Level,
    LPBYTE pDatatypes,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
    );

DWORD
YStartDocPrinter(
    HANDLE hPrinter,
    LPDOC_INFO_CONTAINER pDocInfoContainer,
    LPDWORD pJobId,
    CALL_ROUTE   Route
    );

DWORD
YStartPagePrinter(
    HANDLE hPrinter,
    CALL_ROUTE   Route
    );

DWORD
YWritePrinter(
    HANDLE hPrinter,
    LPBYTE pBuf,
    DWORD cbBuf,
    LPDWORD pcWritten,
    CALL_ROUTE   Route
    );

DWORD
YSeekPrinter(
    HANDLE hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL    bWritePrinter,
    CALL_ROUTE   Route
    );

DWORD
YFlushPrinter(
    HANDLE  hPrinter,
    LPBYTE  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep,
    CALL_ROUTE   Route
    );

DWORD
YEndPagePrinter(
    HANDLE hPrinter,
    CALL_ROUTE   Route
    );

DWORD
YAbortPrinter(
    HANDLE hPrinter,
    CALL_ROUTE   Route
    );

DWORD
YReadPrinter(
    HANDLE hPrinter,
    LPBYTE pBuf,
    DWORD cbBuf,
    LPDWORD pRead,
    CALL_ROUTE   Route
    );

DWORD
YSplReadPrinter(
    HANDLE hPrinter,
    LPBYTE *pBuf,
    DWORD cbBuf,
    CALL_ROUTE   Route
    );

DWORD
YEndDocPrinter(
    HANDLE hPrinter,
    CALL_ROUTE   Route
    );

DWORD
YAddJob(
    HANDLE hPrinter,
    DWORD Level,
    LPBYTE pAddJob,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YScheduleJob(
    HANDLE hPrinter,
    DWORD JobId,
    CALL_ROUTE   Route
    );

DWORD
YGetPrinterData(
    HANDLE hPrinter,
    LPTSTR pValueName,
    LPDWORD pType,
    LPBYTE pData,
    DWORD nSize,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YGetPrinterDataEx(
    HANDLE hPrinter,
    LPCTSTR pKeyName,
    LPCTSTR pValueName,
    LPDWORD pType,
    LPBYTE pData,
    DWORD nSize,
    LPDWORD pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,        // index of value to query
    LPWSTR  pValueName,     // address of buffer for value string
    DWORD   cbValueName,    // size of buffer for value string
    LPDWORD pcbValueName,   // address for size of value buffer
    LPDWORD pType,          // address of buffer for type code
    LPBYTE  pData,          // address of buffer for value data
    DWORD   cbData,         // size of buffer for value data
    LPDWORD pcbData,        // address for size of data buffer
    CALL_ROUTE   Route
);

DWORD
YEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues,
    CALL_ROUTE   Route
);

DWORD
YEnumPrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPWSTR  pSubkey,        // address of buffer for value string
    DWORD   cbSubkey,       // size of buffer for value string
    LPDWORD pcbSubkey,      // address for size of value buffer
    CALL_ROUTE   Route
);

DWORD
YDeletePrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    CALL_ROUTE   Route
);

DWORD
YDeletePrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    CALL_ROUTE   Route
);

DWORD
YDeletePrinterKey(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    CALL_ROUTE   Route
);

DWORD
YSetPrinterData(
    HANDLE hPrinter, 
    LPTSTR pValueName, 
    DWORD Type, 
    LPBYTE pData, 
    DWORD cbData,
    CALL_ROUTE   Route
    );

DWORD
YSetPrinterDataEx(
    HANDLE hPrinter, 
    LPCTSTR pKeyName, 
    LPCTSTR pValueName, 
    DWORD Type, 
    LPBYTE pData, 
    DWORD cbData, 
    CALL_ROUTE   Route
    );

DWORD
YWaitForPrinterChange(
    HANDLE hPrinter, 
    DWORD Flags, 
    LPDWORD pFlags, 
    CALL_ROUTE   Route
    );

DWORD
YClosePrinter(
    LPHANDLE phPrinter, 
    CALL_ROUTE   Route
    );
    
VOID
PRINTER_HANDLE_rundown(
    HANDLE hPrinter
    );

DWORD
YAddForm(
    HANDLE hPrinter, 
    PFORM_CONTAINER pFormInfoContainer, 
    CALL_ROUTE   Route
    );

DWORD
YDeleteForm(
    HANDLE hPrinter, 
    LPWSTR pFormName, 
    CALL_ROUTE   Route
    );

DWORD
YGetForm(   
    PRINTER_HANDLE hPrinter, 
    LPWSTR pFormName, 
    DWORD Level, 
    LPBYTE pForm, 
    DWORD cbBuf, 
    LPDWORD pcbNeeded, 
    CALL_ROUTE   Route
    );

DWORD
YSetForm(
    PRINTER_HANDLE hPrinter, 
    LPWSTR pFormName, 
    PFORM_CONTAINER pFormInfoContainer, 
    CALL_ROUTE   Route
    );

DWORD
YEnumForms(
    PRINTER_HANDLE hPrinter, 
    DWORD Level, 
    LPBYTE pForm, 
    DWORD cbBuf, 
    LPDWORD pcbNeeded, 
    LPDWORD pcReturned, 
    CALL_ROUTE   Route
    );

DWORD
YEnumPorts(
    LPWSTR pName, 
    DWORD Level, 
    LPBYTE pPort, 
    DWORD cbBuf, 
    LPDWORD pcbNeeded, 
    LPDWORD pcReturned, 
    CALL_ROUTE   Route
    );

DWORD
YEnumMonitors(
    LPWSTR pName, 
    DWORD Level, 
    LPBYTE pMonitor, 
    DWORD cbBuf, 
    LPDWORD pcbNeeded, 
    LPDWORD pcReturned, 
    CALL_ROUTE   Route
    );
    
DWORD
YAddPort(
    LPWSTR pName, 
    HWND   hWnd, 
    LPWSTR pMonitorName, 
    CALL_ROUTE   Route
    );

DWORD
YConfigurePort(
    LPWSTR pName, 
    HWND   hWnd, 
    LPWSTR pPortName, 
    CALL_ROUTE   Route
    );

DWORD
YDeletePort(
    LPWSTR pName, 
    HWND   hWnd, 
    LPWSTR 
    pPortName, 
    CALL_ROUTE   Route
    );

DWORD
YXcvData(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus,
    CALL_ROUTE   Route
);



DWORD
YCreatePrinterIC(
    HANDLE hPrinter, 
    HANDLE *pHandle, 
    LPDEVMODE_CONTAINER pDevModeContainer, 
    CALL_ROUTE   Route
    );

DWORD
YPlayGdiScriptOnPrinterIC(
    GDI_HANDLE hPrinterIC, 
    LPBYTE pIn, 
    DWORD cIn, 
    LPBYTE pOut, 
    DWORD cOut, 
    DWORD ul, 
    CALL_ROUTE   Route
    );

DWORD
YDeletePrinterIC(
    GDI_HANDLE *phPrinterIC, 
    BOOL bImpersonate, 
    CALL_ROUTE   Route
    );

DWORD
YPrinterMessageBox(
    PRINTER_HANDLE hPrinter, 
    DWORD Error, 
    HWND hWnd, 
    LPWSTR pText, 
    LPWSTR pCaption, 
    DWORD dwType, 
    CALL_ROUTE   Route
    );

DWORD
YAddMonitor(
    LPWSTR pName, 
    PMONITOR_CONTAINER pMonitorContainer, 
    CALL_ROUTE   Route
    );

DWORD
YDeleteMonitor(
    LPWSTR pName, 
    LPWSTR pEnvironment, 
    LPWSTR pMonitorName, 
    CALL_ROUTE   Route
    );

DWORD
YDeletePrintProcessor(
    LPWSTR pName, 
    LPWSTR pEnvironment, 
    LPWSTR pPrintProcessorName, 
    CALL_ROUTE   Route
    );

DWORD
YAddPrintProvidor(
    LPWSTR pName, 
    PPROVIDOR_CONTAINER pProvidorContainer, 
    CALL_ROUTE   Route
    );

DWORD
YDeletePrintProvidor(
    LPWSTR pName, 
    LPWSTR pEnvironment, 
    LPWSTR pPrintProvidorName, 
    CALL_ROUTE   Route
    );

DWORD
YGetPrinterDriver2( 
    HANDLE hPrinter,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pDriverInfo,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    DWORD dwClientMajorVersion,
    DWORD dwClientMinorVersion,
    PDWORD pdwServerMajorVersion,
    PDWORD pdwServerMinorVersion,
    CALL_ROUTE   Route
    );

DWORD
YAddPortEx(
    LPWSTR pName, 
    LPPORT_CONTAINER pPortContainer, 
    LPPORT_VAR_CONTAINER pPortVarContainer, 
    LPWSTR pMonitorName, 
    CALL_ROUTE   Route
    );

DWORD
YSpoolerInit(
    LPWSTR pName, 
    CALL_ROUTE   Route
    );

DWORD
YResetPrinterEx(
    HANDLE hPrinter, 
    LPWSTR pDatatype, 
    LPDEVMODE_CONTAINER pDevModeContainer, 
    DWORD dwFlag, 
    CALL_ROUTE   Route
    );

DWORD
YSetAllocFailCount(
    HANDLE hPrinter, 
    DWORD dwFailCount, 
    LPDWORD lpdwAllocCount, 
    LPDWORD lpdwFreeCount, 
    LPDWORD lpdwFailCountHit, 
    CALL_ROUTE   Route
    );

DWORD
YSetPort(
    LPWSTR              pName,
    LPWSTR              pPortName,
    LPPORT_CONTAINER    pPortContainer,
    CALL_ROUTE          Route
    );

DWORD
YClusterSplOpen(
    LPCTSTR     pszServer,
    LPCTSTR     pszResource,
    PHANDLE     phSpooler,
    LPCTSTR     pszName,
    LPCTSTR     pszAddress,
    CALL_ROUTE   Route        
    );

DWORD
YClusterSplClose(
    PHANDLE     phSpooler,
    CALL_ROUTE   Route
    );

DWORD
YClusterSplIsAlive(
    HANDLE      hSpooler,
    CALL_ROUTE   Route
    );

VOID
YDriverUnloadComplete(
    LPWSTR  pDriverFile
    );

DWORD
YGetSpoolFileInfo(
    HANDLE      hPrinter,
    DWORD       dwAppProcessId,
    DWORD       dwLevel,
    LPBYTE      pSpoolFileInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE   Route
    );

DWORD
YGetSpoolFileInfo2(
    HANDLE                  hPrinter,
    DWORD                   dwAppProcessId,
    DWORD                   dwLevel,
    LPFILE_INFO_CONTAINER   pSplFileInfoContainer,
    CALL_ROUTE              Route
    );


DWORD
YCommitSpoolData(
    HANDLE      hPrinter,
    DWORD       dwAppProcessId,
    DWORD       cbCommit,
    DWORD       dwLevel,
    LPBYTE      pSpoolFileInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
    );

DWORD
YCommitSpoolData2(
    HANDLE                  hPrinter,
    DWORD                   dwAppProcessId,
    DWORD                   cbCommit,
    DWORD                   dwLevel,
    LPFILE_INFO_CONTAINER   pSplFileInfoContainer,
    CALL_ROUTE              Route
    );

DWORD
YCloseSpoolFileHandle(
    HANDLE      hPrinter,
    CALL_ROUTE   Route
    );

DWORD
YSendRecvBidiData(
    IN          HANDLE  hPrinter,
    IN          LPCWSTR pAction,
    IN          PBIDI_REQUEST_CONTAINER   pReqData,
    OUT         PBIDI_RESPONSE_CONTAINER* ppRespData,
    CALL_ROUTE  Route
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\basecls.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     basecls.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the implementation of the base classes
     used out by most of the loader and interfaces of the 
     surrogate process. Although these base classes don't contain
     pure virtual functions , they should not be instantiated on
     their own. Their usage is utilized through inheritance mainly.
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __BASECLS_HPP__
#include "basecls.hpp"
#endif

/* ------------------------------------ */
/* Implemetation of class TPrinterDriver */
/* ------------------------------------ */

/*++
    Function Name:
        TPrinterDriver :: TPrinterDriver
     
    Description:
        Constructor of base printer driver object. 
             
     Parameters:
        None
        
     Return Value:
        None
--*/
TPrinterDriver ::
TPrinterDriver(
    VOID
    )
{}

/*++
    Function Name:
        TPrinterDriver :: ~TPrinterDriver
     
    Description:
        Destructor of base printer driver object. 
             
     Parameters:
        None
        
     Return Value:
        None
--*/
TPrinterDriver ::
~TPrinterDriver(
    VOID
    )
{}

/*++
    Function Name:
        TPrinterDriver :: LoadPritnerDriver
     
    Description:
        Queries the Printer for the suitable driver and loads
        it
             
    Parameters:
        HANLDE hPrinter  : Handle of Printer to laod driver for
             
     Return Value:
        HMODULE hDriver  : In case of success Handle to driver dll 
                           In case of failure NULL
--*/
HMODULE
TPrinterDriver ::
LoadPrinterDriver(
    IN HANDLE hPrinter
    )
{
     PDRIVER_INFO_5  pDriverInfo;                                              
     DWORD           DriverInfoSize, DriverVersion;                                              
     HANDLE          hDriver = NULL;                                                    
     BYTE            Buffer[MAX_STATIC_ALLOC];                                       
     BOOL            bAllocBuffer = FALSE, bReturn;                                    
                                                                               
     pDriverInfo = reinterpret_cast<PDRIVER_INFO_5>(Buffer);                                  
                                                                               
     bReturn = GetPrinterDriverW(hPrinter,
                                 NULL,
                                 5,
                                 (LPBYTE)pDriverInfo,       
                                 MAX_STATIC_ALLOC,
                                 &DriverInfoSize);                 
                                                                               
     if (!bReturn &&                                                           
         (GetLastError() == ERROR_INSUFFICIENT_BUFFER) &&                      
         (pDriverInfo = (PDRIVER_INFO_5)new byte[DriverInfoSize]))
     {   
          bAllocBuffer = TRUE;                                                 
          bReturn = GetPrinterDriverW(hPrinter,
                                      NULL,
                                      5,
                                      (LPBYTE)pDriverInfo,  
                                      DriverInfoSize,
                                      &DriverInfoSize);                    
     }                                                                         
                                                                               
     if (bReturn)
     {                                                            
         hDriver = LoadLibraryEx(pDriverInfo->pConfigFile,
                                 NULL,
                                 LOAD_WITH_ALTERED_SEARCH_PATH);
     }                                                                         
                                                                               
     if (bAllocBuffer)
     {                                                       
         delete [] pDriverInfo;                                               
     }                                                                         
                                                                               
     return hDriver;                                                           
}


/* ----------------------------- */
/* Implemetation of class RefCnt */
/* ----------------------------- */

/*++
    Function Name:
        TRefCntMgr :: TRefCntMgr
     
    Description:
        Constructor of base refrence count object. This 
        object keeps track of the number of clients using
        the object;
             
     Parameters:
        None
        
     Return Value:
        None
--*/
TRefCntMgr ::
TRefCntMgr(
    VOID
    ) : 
   m_cRefCnt(0)
{}

/*++
    Function Name:
        TRefCntMgr :: ~TRefCntMgr
     
    Description:
        Destructor of base refrence count object. 
                     
     Parameters:
        None
        
     Return Value:
        None
--*/
TRefCntMgr ::
~TRefCntMgr(
    VOID
    )
{}


/*++
    Function Name:
        TRefCntMgr :: AddRef
     
    Description:
        Increments the ref count on the object
                     
     Parameters:
        None
        
     Return Value:
        DWORD : New Ref Count
--*/
DWORD
TRefCntMgr ::
AddRef(
    VOID
    )
{
    return InterlockedIncrement(&m_cRefCnt);
}

/*++
    Function Name:
        TRefCntMgr :: Release
     
    Description:
        Decrements the ref count on the object 
        and deletes the object , if this is the
        last attached client
                     
     Parameters:
        None
        
     Return Value:
        DWORD : New Ref Count
                0 if object deleted
--*/
DWORD 
TRefCntMgr ::
Release(
    VOID
    )
{
    LONG cRef = InterlockedDecrement(&m_cRefCnt);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\basecls.hpp ===
#ifndef __BASECLS_HPP__
#define __BASECLS_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldmgr.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the declararion of some base 
     classes that are utilized by other classes(objects)
     in the surrogate process
     So far we have 2 of these
     o Printer Driver class
     o Ref Count Class
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
--*/


class TRefCntMgr
{
     public:

     TRefCntMgr(
         VOID
         );

     virtual ~TRefCntMgr(
         VOID
         );

     virtual DWORD
     AddRef(
         VOID
         );

     virtual DWORD
     Release(
         VOID
         );

     private:

     LONG    m_cRefCnt;
};


class TClassID
{
    public:
    
    char szClassID[32];

    inline TClassID(char *pszCallerID)
    {
        ZeroMemory(szClassID,32);
        StringCchCopyA(szClassID, 
                       32,
                       pszCallerID);
    }
};


class TPrinterDriver
{
    public:

    TPrinterDriver(
        VOID
        );

    virtual ~TPrinterDriver(
        VOID
        );

    protected:

    HMODULE
    LoadPrinterDriver(
         IN HANDLE hPrinter
        );
};

#endif //__BASECLS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\server\yspool.c ===
/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:

    yspool.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Print Providor Routing layer

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

[Notes:]

    optional-notes

Revision History:

    swilson    1-Jun-95     Converted winspool.c to yspool: the merging point of KM & RPC paths

--*/

#include "precomp.h"
#include "server.h"
#include "client.h"
#include "yspool.h"
#include "clusrout.h"

LPWSTR szNull = L"";

BOOL
OldGetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);



#define YRevertToSelf(rpc)      (rpc != NATIVE_CALL ? RpcRevertToSelf() : 0)

DWORD   ServerHandleCount = 0;

BOOL
YImpersonateClient(CALL_ROUTE Route);

VOID
PrinterHandleRundown(
    HANDLE hPrinter);

BOOL
GetPrinterDriverExW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVersion,
    DWORD   dwClientMinorVersion,
    PDWORD  pdwServerMajorVersion,
    PDWORD  pdwServerMinorVersion);

BOOL
OpenPrinterExW(
    LPWSTR                 pPrinterName,
    HANDLE                *pHandle,
    LPPRINTER_DEFAULTS     pDefault,
    PSPLCLIENT_CONTAINER   pSplClientContainer
    );

HANDLE
AddPrinterExW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPrinter,
    LPBYTE  pClientInfo,
    DWORD   dwLevel
    );

BOOL
SpoolerInit(
    VOID);

/*++

Name:

    IsValidMultiSz

Description:

    This function accepts strings of length 0 or 1 as valid multi sz. The code in yspool
    that calls this function uses szNull instead of pszString subsequently, if cch is 0 or 1.
    Theoretically, a string with one character is not a valid multi sz.

Arguments:

    pszString - array of WCHARs
    cch       - count of WCHARs in the array

Return Value:

    TRUE  - the multi sz is valid
    FALSE - the string does not represent a valid multi sz

--*/
BOOL
IsValidMultiSz(
    IN PWSTR pszString,
    IN DWORD cch
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (cch == 0 || cch == 1)
    {
        Error = ERROR_SUCCESS;
    }
    else
    {
        if (pszString[cch - 1] == L'\0' && pszString[cch - 2] == L'\0')
        {
            Error = ERROR_SUCCESS;
        }
    }

    return Error == ERROR_SUCCESS;
}


BOOL
InvalidDevModeContainer(
    LPDEVMODE_CONTAINER pDevModeContainer
    )
{
    BOOL    bRetValue = TRUE;

    if(pDevModeContainer)
    {
        bRetValue = FALSE;

        if (pDevModeContainer->pDevMode)
        {
            bRetValue = !BoolFromHResult(SplIsValidDevmodeW((PDEVMODE) pDevModeContainer->pDevMode,
                                                            pDevModeContainer->cbBuf));
        }
    }

    return bRetValue;
}

BOOL
InvalidSecurityContainer(
    PSECURITY_CONTAINER pSecurityContainer
)
{
    SECURITY_DESCRIPTOR_CONTROL SecurityDescriptorControl;
    DWORD                       dwRevision;

    if(!pSecurityContainer                                                                  ||
       (pSecurityContainer->pSecurity                                                       &&
       !RtlValidRelativeSecurityDescriptor((SECURITY_DESCRIPTOR *)pSecurityContainer->pSecurity,
                                           pSecurityContainer->cbBuf,
                                           0)))
    {
        return TRUE;
    }
    return FALSE;
}

BOOL
ValidatePortVarContainer(
    PPORT_VAR_CONTAINER pPortVarContainer
    )
{
    return !!pPortVarContainer;
}

BOOL
ValidatePortContainer(
    LPPORT_CONTAINER pPortContainer
    )
{
    return pPortContainer && pPortContainer->PortInfo.pPortInfo1;
}

BOOL
ValidatePrinterContainer(
    PPRINTER_CONTAINER  pPrinterContainer
    )
{
    return pPrinterContainer && pPrinterContainer->PrinterInfo.pPrinterInfo1;
}

BOOL
ValidateMonitorContainer(
    LPMONITOR_CONTAINER pMonitorContainer
    )
{
    return pMonitorContainer && pMonitorContainer->MonitorInfo.pMonitorInfo2;
}


DWORD
YEnumPrinters(
    DWORD   Flags,
    LPWSTR  Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    CALL_ROUTE   Route
)
{   FieldInfo* pFieldInfo;
    DWORD   cReturned, cbStruct;
    DWORD   Error=ERROR_INVALID_NAME;
    DWORD   BufferSize=cbBuf;
    BOOL    bRet;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case STRESSINFOLEVEL:
        pFieldInfo = PrinterInfoStressFields;
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 1:
        pFieldInfo = PrinterInfo1Fields;
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        pFieldInfo = PrinterInfo2Fields;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 4:
        pFieldInfo = PrinterInfo4Fields;
        cbStruct = sizeof(PRINTER_INFO_4);
        break;

    case 5:
        pFieldInfo = PrinterInfo5Fields;
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pPrinterEnum, &cbBuf);

    if ( pPrinterEnum && !pAlignedBuff ){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = EnumPrinters(Flags, Name, Level, pAlignedBuff,
                        cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pPrinterEnum, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();

}

DWORD
YOpenPrinter(
    LPWSTR              pPrinterName,
    HANDLE             *phPrinter,
    LPWSTR              pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD               AccessRequired,
    CALL_ROUTE          Route
)
{
    PRINTER_DEFAULTS  Defaults;
    BOOL              bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    if ( InvalidDevModeContainer(pDevModeContainer) ) {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    Defaults.pDatatype = pDatatype;

    Defaults.pDevMode = (LPDEVMODE)pDevModeContainer->pDevMode;

    Defaults.DesiredAccess = AccessRequired;

    bRet = OpenPrinterW(pPrinterName, phPrinter, &Defaults);

    YRevertToSelf(Route);

    if (bRet) {
        InterlockedIncrement ( &ServerHandleCount );
        return ERROR_SUCCESS;
    } else {
        *phPrinter = NULL;
        return GetLastError();
    }
}

DWORD
YOpenPrinterEx(
    LPWSTR                  pPrinterName,
    HANDLE                 *phPrinter,
    LPWSTR                  pDatatype,
    LPDEVMODE_CONTAINER     pDevModeContainer,
    DWORD                   AccessRequired,
    CALL_ROUTE              Route,
    PSPLCLIENT_CONTAINER    pSplClientContainer
)
{
    PRINTER_DEFAULTS  Defaults;
    BOOL              bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    if ( InvalidDevModeContainer(pDevModeContainer) ) {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    Defaults.pDatatype = pDatatype;

    Defaults.pDevMode = (LPDEVMODE)pDevModeContainer->pDevMode;

    Defaults.DesiredAccess = AccessRequired;

    bRet = OpenPrinterExW(pPrinterName,
                          phPrinter,
                          &Defaults,
                          pSplClientContainer);

    YRevertToSelf(Route);

    if (bRet) {
        InterlockedIncrement ( &ServerHandleCount );
        return ERROR_SUCCESS;
    } else {
        *phPrinter = NULL;
        return GetLastError();
    }
}


DWORD
YResetPrinter(
    HANDLE              hPrinter,
    LPWSTR              pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    CALL_ROUTE          Route
)
{
    PRINTER_DEFAULTS  Defaults;
    BOOL              bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    if ( InvalidDevModeContainer(pDevModeContainer) ) {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    Defaults.pDatatype = pDatatype;

    Defaults.pDevMode = (LPDEVMODE)pDevModeContainer->pDevMode;

    //
    // You cannot change the Access Mask on a Printer Spool Object
    // We will always ignore this parameter and set it to zero
    // We get some random garbage otherwise.
    //

    Defaults.DesiredAccess = 0;

    bRet = ResetPrinter(hPrinter, &Defaults);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YSetJob(
    HANDLE      hPrinter,
    DWORD       JobId,
    JOB_CONTAINER *pJobContainer,
    DWORD       Command,
    CALL_ROUTE  Route
    )

/*++

Routine Description:

    This function will modify the settings of the specified Print Job.

Arguments:

    lpJob - Points to a valid JOB structure containing at least a valid
        lpPrinter, and JobId.

    Command - Specifies the operation to perform on the specified Job. A value
        of FALSE indicates that only the elements of the JOB structure are to
        be examined and set.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = SetJob(hPrinter, JobId, pJobContainer ? pJobContainer->Level : 0,
                  pJobContainer ? (LPBYTE)pJobContainer->JobInfo.Level1 : NULL,
                  Command);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YGetJob(
    HANDLE      hPrinter,
    DWORD       JobId,
    DWORD       Level,
    LPBYTE      pJob,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
   )

/*++

Routine Description:

    This function will retrieve the settings of the specified Print Job.

Arguments:

    lpJob - Points to a valid JOB structure containing at least a valid
        lpPrinter, and JobId.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    BOOL   bRet;
    SIZE_T cbStruct;
    FieldInfo *pFieldInfo;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = JobInfo1Fields;
        cbStruct = sizeof(JOB_INFO_1);
        break;

    case 2:
        pFieldInfo = JobInfo2Fields;
        cbStruct = sizeof(JOB_INFO_2);
        break;

    case 3:
        pFieldInfo = JobInfo3Fields;
        cbStruct = sizeof(JOB_INFO_3);
        break;


    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pJob, &cbBuf);

    if (pJob && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = GetJob(hPrinter, JobId, Level, pAlignedBuff, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

    if (bRet) {

        if (Route) {

            bRet = MarshallDownStructure(pAlignedBuff, pFieldInfo, cbStruct, Route);
        }
    }

    UndoAlignRpcPtr(pJob, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YEnumJobs(
    HANDLE      hPrinter,
    DWORD       FirstJob,
    DWORD       NoJobs,
    DWORD       Level,
    LPBYTE      pJob,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned,
    CALL_ROUTE  Route
)
{
    FieldInfo *pFieldInfo;
    DWORD   cReturned, cbStruct;
    BOOL    bRet;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = JobInfo1Fields;
        cbStruct = sizeof(JOB_INFO_1);
        break;

    case 2:
        pFieldInfo = JobInfo2Fields;
        cbStruct = sizeof(JOB_INFO_2);
        break;

    case 3:
        pFieldInfo = JobInfo3Fields;
        cbStruct = sizeof(JOB_INFO_3);
        break;


    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pJob, &cbBuf);

    if (pJob && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = EnumJobs(hPrinter, FirstJob, NoJobs, Level, pAlignedBuff,
                    cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pJob, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YAddPrinter(
    LPWSTR              pName,
    PPRINTER_CONTAINER  pPrinterContainer,
    PDEVMODE_CONTAINER  pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    HANDLE              *phPrinter,
    CALL_ROUTE           Route
)
{
    if (!YImpersonateClient(Route))
        return GetLastError();

    if(!ValidatePrinterContainer(pPrinterContainer) ||
       InvalidDevModeContainer(pDevModeContainer))
    {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    if (pPrinterContainer->Level == 2)
    {
        if(!pPrinterContainer->PrinterInfo.pPrinterInfo2 ||
           (pSecurityContainer->pSecurity                &&
            InvalidSecurityContainer(pSecurityContainer)))
        {
           return ERROR_INVALID_PARAMETER;
        }
        pPrinterContainer->PrinterInfo.pPrinterInfo2->pDevMode =
                           (LPDEVMODE)pDevModeContainer->pDevMode;
        pPrinterContainer->PrinterInfo.pPrinterInfo2->pSecurityDescriptor =
                           (PSECURITY_DESCRIPTOR)pSecurityContainer->pSecurity;
    }

    *phPrinter = AddPrinter(pName, pPrinterContainer->Level,
                     (LPBYTE)pPrinterContainer->PrinterInfo.pPrinterInfo1);

    YRevertToSelf(Route);

    if (*phPrinter) {
        InterlockedIncrement( &ServerHandleCount );
        return ERROR_SUCCESS;
    } else
        return GetLastError();
}

DWORD
YAddPrinterEx(
    LPWSTR                  pName,
    PPRINTER_CONTAINER      pPrinterContainer,
    PDEVMODE_CONTAINER      pDevModeContainer,
    PSECURITY_CONTAINER     pSecurityContainer,
    HANDLE                 *phPrinter,
    CALL_ROUTE              Route,
    PSPLCLIENT_CONTAINER    pSplClientContainer
    )
{
    if (!YImpersonateClient(Route))
        return GetLastError();

    if(!ValidatePrinterContainer(pPrinterContainer) ||
       InvalidDevModeContainer(pDevModeContainer))
    {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    if (pPrinterContainer->Level == 2)
    {
       if(!pPrinterContainer->PrinterInfo.pPrinterInfo2 ||
          (pSecurityContainer->pSecurity                &&
           InvalidSecurityContainer(pSecurityContainer)))
       {
          return ERROR_INVALID_PARAMETER;
       }
       pPrinterContainer->PrinterInfo.pPrinterInfo2->pDevMode =
                             (LPDEVMODE)pDevModeContainer->pDevMode;
       pPrinterContainer->PrinterInfo.pPrinterInfo2->pSecurityDescriptor =
                          (PSECURITY_DESCRIPTOR)pSecurityContainer->pSecurity;
    }

    *phPrinter = AddPrinterExW(pName,
                               pPrinterContainer->Level,
                               (LPBYTE)pPrinterContainer->PrinterInfo.pPrinterInfo1,
                               (LPBYTE)pSplClientContainer->ClientInfo.pClientInfo1,
                               pSplClientContainer->Level);

    YRevertToSelf(Route);

    if (*phPrinter) {
        InterlockedIncrement( &ServerHandleCount );
        return ERROR_SUCCESS;
    } else
        return GetLastError();
}

DWORD
YDeletePrinter(
    HANDLE      hPrinter,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePrinter(hPrinter);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YAddPrinterConnection(
    LPWSTR      pName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AddPrinterConnection(pName);

    YRevertToSelf(Route);

    if (bRet)

        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YDeletePrinterConnection(
    LPWSTR      pName,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePrinterConnection(pName);

    YRevertToSelf(Route);

    if (bRet)

        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YSetPrinter(
    HANDLE              hPrinter,
    PPRINTER_CONTAINER  pPrinterContainer,
    PDEVMODE_CONTAINER  pDevModeContainer,
    PSECURITY_CONTAINER pSecurityContainer,
    DWORD               Command,
    CALL_ROUTE          Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    if(!pPrinterContainer ||
       (pPrinterContainer->Level && !ValidatePrinterContainer(pPrinterContainer)) ||
       InvalidDevModeContainer(pDevModeContainer))
    {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    if (InvalidSecurityContainer(pSecurityContainer)) {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    switch (pPrinterContainer->Level) {

    case 2:

        pPrinterContainer->PrinterInfo.pPrinterInfo2->pDevMode =
                             (LPDEVMODE)pDevModeContainer->pDevMode;

        pPrinterContainer->PrinterInfo.pPrinterInfo2->pSecurityDescriptor =
                          (PSECURITY_DESCRIPTOR)pSecurityContainer->pSecurity;

        break;

    case 3:

        pPrinterContainer->PrinterInfo.pPrinterInfo3->pSecurityDescriptor =
                          (PSECURITY_DESCRIPTOR)pSecurityContainer->pSecurity;
        break;

    case 8:

        pPrinterContainer->PrinterInfo.pPrinterInfo8->pDevMode =
                             (LPDEVMODE)pDevModeContainer->pDevMode;
        break;

    case 9:

        pPrinterContainer->PrinterInfo.pPrinterInfo9->pDevMode =
                             (LPDEVMODE)pDevModeContainer->pDevMode;
        break;

    default:
        break;
    }

    bRet = SetPrinter(hPrinter, pPrinterContainer->Level,
                      (LPBYTE)pPrinterContainer->PrinterInfo.pPrinterInfo1,
                      Command);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YGetPrinter(
    HANDLE      hPrinter,
    DWORD       Level,
    LPBYTE      pPrinter,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
)
{
    FieldInfo *pFieldInfo;
    BOOL  ReturnValue;
    DWORD   *pOffsets;
    SIZE_T  cbStruct;
    LPBYTE  pAlignedBuff;

    *pcbNeeded = 0;
    switch (Level) {

    case STRESSINFOLEVEL:
        pFieldInfo = PrinterInfoStressFields;
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 1:
        pFieldInfo = PrinterInfo1Fields;
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        pFieldInfo = PrinterInfo2Fields;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 3:
        pFieldInfo = PrinterInfo3Fields;
        cbStruct = sizeof(PRINTER_INFO_3);
        break;

    case 4:
        pFieldInfo = PrinterInfo4Fields;
        cbStruct = sizeof(PRINTER_INFO_4);
        break;

    case 5:
        pFieldInfo = PrinterInfo5Fields;
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    case 6:
        pFieldInfo = PrinterInfo6Fields;
        cbStruct = sizeof(PRINTER_INFO_6);
        break;

    case 7:
        pFieldInfo = PrinterInfo7Fields;
        cbStruct = sizeof(PRINTER_INFO_7);
        break;

    case 8:
        pFieldInfo = PrinterInfo8Fields;
        cbStruct = sizeof(PRINTER_INFO_8);
        break;

    case 9:
        pFieldInfo = PrinterInfo9Fields;
        cbStruct = sizeof(PRINTER_INFO_9);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pPrinter, &cbBuf);

    if (pPrinter && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    ReturnValue = GetPrinter(hPrinter, Level, pAlignedBuff, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

    if (ReturnValue) {

         ReturnValue = MarshallDownStructure(pAlignedBuff, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pPrinter, pAlignedBuff, cbBuf, pcbNeeded);

    return ReturnValue ? ERROR_SUCCESS : GetLastError();
}


DWORD
YAddPrinterDriver(
    LPWSTR              pName,
    LPDRIVER_CONTAINER  pDriverContainer,
    CALL_ROUTE          Route
)
{
    PDRIVER_INFO_4 pDriverInfo4 = NULL;
    BOOL           bRet         = FALSE;
    LPRPC_DRIVER_INFO_4W    pRpcDriverInfo4;

    if(!pDriverContainer)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    switch (pDriverContainer->Level) {

        case 2:
            bRet = AddPrinterDriver(pName,
                                   pDriverContainer->Level,
                                   (LPBYTE)pDriverContainer->DriverInfo.Level2);
            break;

        case 3:
        case 4:

            if (!pDriverContainer->DriverInfo.Level4)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Error;
            }

            pDriverInfo4 = (PDRIVER_INFO_4) AllocSplMem(sizeof(DRIVER_INFO_4));

            if ( !pDriverInfo4 ) {

                goto Error;
            }

            pRpcDriverInfo4 = (LPRPC_DRIVER_INFO_4W) pDriverContainer->DriverInfo.Level4;

            if (!pRpcDriverInfo4 ||
                !IsValidMultiSz(pRpcDriverInfo4->pDependentFiles,   pRpcDriverInfo4->cchDependentFiles) ||
                pDriverContainer->Level != 3 && !IsValidMultiSz(pRpcDriverInfo4->pszzPreviousNames, pRpcDriverInfo4->cchPreviousNames))
            {
                FreeSplMem(pDriverInfo4);
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Error;
            }

            pDriverInfo4->cVersion          = pRpcDriverInfo4->cVersion;
            pDriverInfo4->pName             = pRpcDriverInfo4->pName;
            pDriverInfo4->pEnvironment      = pRpcDriverInfo4->pEnvironment;
            pDriverInfo4->pDriverPath       = pRpcDriverInfo4->pDriverPath;
            pDriverInfo4->pDataFile         = pRpcDriverInfo4->pDataFile;
            pDriverInfo4->pConfigFile       = pRpcDriverInfo4->pConfigFile;
            pDriverInfo4->pHelpFile         = pRpcDriverInfo4->pHelpFile;
            pDriverInfo4->pMonitorName      = pRpcDriverInfo4->pMonitorName;
            pDriverInfo4->pDefaultDataType  = pRpcDriverInfo4->pDefaultDataType;

            //
            // Use szNULL if the DependentFiles string contains nothing
            //
            if ((pRpcDriverInfo4->cchDependentFiles == 0) ||
                (pRpcDriverInfo4->cchDependentFiles == 1))  {

                pDriverInfo4->pDependentFiles = szNull;
            } else {
                pDriverInfo4->pDependentFiles = pRpcDriverInfo4->pDependentFiles
;
            }

            if ( pDriverContainer->Level == 4 ) {

                if ( pRpcDriverInfo4->cchPreviousNames == 0 ||
                     pRpcDriverInfo4->cchPreviousNames  == 1 )
                    pDriverInfo4->pszzPreviousNames = szNull;
                else
                    pDriverInfo4->pszzPreviousNames
                                        = pRpcDriverInfo4->pszzPreviousNames;
            }


            bRet = AddPrinterDriver(pName,
                                    pDriverContainer->Level,
                                    (LPBYTE) pDriverInfo4);

            FreeSplMem(pDriverInfo4);
            break;

        default:
            YRevertToSelf(Route);
            return ERROR_INVALID_LEVEL;
    }

Error:
    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YAddPrinterDriverEx(
    LPWSTR              pName,
    LPDRIVER_CONTAINER  pDriverContainer,
    DWORD               dwFileCopyFlags,
    CALL_ROUTE          Route
)
{
    BOOL                 bRet = FALSE;
    PDRIVER_INFO_6       pDriverInfo6 = NULL;
    LPRPC_DRIVER_INFO_6W pRpcDriverInfo6;

    if(!pDriverContainer)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    switch (pDriverContainer->Level) {

        case 2:
            bRet = AddPrinterDriverEx(pName,
                                      pDriverContainer->Level,
                                      (LPBYTE)pDriverContainer->DriverInfo.Level2,
                                      dwFileCopyFlags);
            break;

        case 3:
        case 4:
        case 6:

            if (!pDriverContainer->DriverInfo.Level6)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Error;
            }
            pDriverInfo6 = (PDRIVER_INFO_6) AllocSplMem(sizeof(DRIVER_INFO_6));

            if ( !pDriverInfo6 ) {

                bRet = FALSE;
                goto Error;
            }

            pRpcDriverInfo6 = (LPRPC_DRIVER_INFO_6W) pDriverContainer->DriverInfo.Level6;

            if (!pRpcDriverInfo6 ||
                !IsValidMultiSz(pRpcDriverInfo6->pDependentFiles,   pRpcDriverInfo6->cchDependentFiles) ||
                pDriverContainer->Level != 3 && !IsValidMultiSz(pRpcDriverInfo6->pszzPreviousNames, pRpcDriverInfo6->cchPreviousNames))
            {
                FreeSplMem(pRpcDriverInfo6);
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Error;
            }

            pDriverInfo6->cVersion          = pRpcDriverInfo6->cVersion;
            pDriverInfo6->pName             = pRpcDriverInfo6->pName;
            pDriverInfo6->pEnvironment      = pRpcDriverInfo6->pEnvironment;
            pDriverInfo6->pDriverPath       = pRpcDriverInfo6->pDriverPath;
            pDriverInfo6->pDataFile         = pRpcDriverInfo6->pDataFile;
            pDriverInfo6->pConfigFile       = pRpcDriverInfo6->pConfigFile;
            pDriverInfo6->pHelpFile         = pRpcDriverInfo6->pHelpFile;
            pDriverInfo6->pMonitorName      = pRpcDriverInfo6->pMonitorName;
            pDriverInfo6->pDefaultDataType  = pRpcDriverInfo6->pDefaultDataType;

            //
            // Use szNULL if the DependentFiles string contains nothing
            //
            if ((pRpcDriverInfo6->cchDependentFiles == 0) ||
                (pRpcDriverInfo6->cchDependentFiles == 1))  {

                pDriverInfo6->pDependentFiles = szNull;
            } else {
                pDriverInfo6->pDependentFiles = pRpcDriverInfo6->pDependentFiles;
            }

            if ( pDriverContainer->Level == 4 || pDriverContainer->Level == 6 ) {

                if ( pRpcDriverInfo6->cchPreviousNames == 0 ||
                     pRpcDriverInfo6->cchPreviousNames  == 1 )
                    pDriverInfo6->pszzPreviousNames = szNull;
                else
                    pDriverInfo6->pszzPreviousNames
                                        = pRpcDriverInfo6->pszzPreviousNames;
            }

            if ( pDriverContainer->Level == 6 ) {
                pDriverInfo6->ftDriverDate      = pRpcDriverInfo6->ftDriverDate;
                pDriverInfo6->dwlDriverVersion  = pRpcDriverInfo6->dwlDriverVersion;
                pDriverInfo6->pszMfgName        = pRpcDriverInfo6->pMfgName;
                pDriverInfo6->pszOEMUrl         = pRpcDriverInfo6->pOEMUrl;
                pDriverInfo6->pszHardwareID     = pRpcDriverInfo6->pHardwareID;
                pDriverInfo6->pszProvider       = pRpcDriverInfo6->pProvider;
            }

            bRet = AddPrinterDriverEx(pName,
                                      pDriverContainer->Level,
                                      (LPBYTE) pDriverInfo6,
                                      dwFileCopyFlags);

            FreeSplMem(pDriverInfo6);
            break;

        default:
            YRevertToSelf(Route);
            return ERROR_INVALID_LEVEL;
    }

Error:
    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YAddDriverCatalog(
    HANDLE                   hPrinter,
    DRIVER_INFCAT_CONTAINER  *pDriverInfCatContainer,
    DWORD                    dwCatalogCopyFlags,
    CALL_ROUTE               Route
)
{
    BOOL bRet = FALSE;

    if (!pDriverInfCatContainer)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    if (!YImpersonateClient(Route))
    {
        goto Cleanup;
    }

    switch (pDriverInfCatContainer->dwLevel)
    {

        case 1:
            bRet = AddDriverCatalog(hPrinter,
                                    pDriverInfCatContainer->dwLevel,
                                    pDriverInfCatContainer->DriverInfCatInfo.pDriverInfCatInfo1,
                                    dwCatalogCopyFlags);
            break;

        case 2:
            bRet = AddDriverCatalog(hPrinter,
                                    pDriverInfCatContainer->dwLevel,
                                    pDriverInfCatContainer->DriverInfCatInfo.pDriverInfCatInfo2,
                                    dwCatalogCopyFlags);
            break;

        default:

            SetLastError(ERROR_INVALID_LEVEL);
            break;
    }

    YRevertToSelf(Route);

Cleanup:

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YEnumPrinterDrivers(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    DWORD       Level,
    LPBYTE      pDrivers,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned,
    CALL_ROUTE  Route
)
{
    DWORD   cReturned, cbStruct;
    BOOL    bRet;
    FieldInfo *pFieldInfo;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = DriverInfo1Fields;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pFieldInfo = DriverInfo2Fields;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pFieldInfo = DriverInfo3Fields;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pFieldInfo = DriverInfo4Fields;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        pFieldInfo = DriverInfo5Fields;
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        pFieldInfo = DriverInfo6Fields;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pDrivers, &cbBuf);

    if (pDrivers && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = EnumPrinterDrivers(pName, pEnvironment, Level, pAlignedBuff,
                              cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pDrivers, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YGetPrinterDriver(
    HANDLE      hPrinter,
    LPWSTR      pEnvironment,
    DWORD       Level,
    LPBYTE      pDriverInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
)
{
    FieldInfo *pFieldInfo;
    BOOL   bRet;
    DWORD  dwServerMajorVersion;
    DWORD  dwServerMinorVersion;
    SIZE_T cbStruct;
    LPBYTE pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = DriverInfo1Fields;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pFieldInfo = DriverInfo2Fields;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pFieldInfo = DriverInfo3Fields;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pFieldInfo = DriverInfo4Fields;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 6:
        pFieldInfo = DriverInfo6Fields;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pDriverInfo, &cbBuf);

    if (pDriverInfo && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    if ( Route ) {

        //
        //  If they are Remote using the old api the don't want versioning
        //

        bRet = OldGetPrinterDriverW(hPrinter, pEnvironment, Level, pAlignedBuff,
                                    cbBuf, pcbNeeded);
    } else {

        bRet = GetPrinterDriverExW(hPrinter, pEnvironment, Level, pAlignedBuff,
                                   cbBuf, pcbNeeded, (DWORD)-1, (DWORD)-1,
                                   &dwServerMajorVersion, &dwServerMinorVersion);
    }

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructure(pAlignedBuff, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pDriverInfo, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YGetPrinterDriverDirectory(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    DWORD       Level,
    LPBYTE      pDriverInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = GetPrinterDriverDirectory(pName, pEnvironment, Level,
                                     pDriverInfo, cbBuf, pcbNeeded);
    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YDeletePrinterDriver(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    LPWSTR      pDriverName,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePrinterDriverW(pName, pEnvironment, pDriverName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}


DWORD
YDeletePrinterDriverEx(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    LPWSTR      pDriverName,
    DWORD       dwDeleteFlag,
    DWORD       dwVersionNum,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePrinterDriverExW(pName, pEnvironment, pDriverName,
                                dwDeleteFlag, dwVersionNum);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YAddPerMachineConnection(
    LPWSTR      pServer,
    LPCWSTR     pPrinterName,
    LPCWSTR     pPrintServer,
    LPCWSTR     pProvider,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AddPerMachineConnection(pServer, pPrinterName, pPrintServer, pProvider);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YDeletePerMachineConnection(
    LPWSTR      pServer,
    LPCWSTR     pPrinterName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePerMachineConnection(pServer, pPrinterName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YEnumPerMachineConnections(
    LPWSTR      pServer,
    LPBYTE      pPrinterEnum,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned,
    CALL_ROUTE  Route
)
{
    DWORD   cReturned, cbStruct;
    FieldInfo *pFieldInfo;
    BOOL    bRet;
    LPBYTE  pAlignedBuff;

    pFieldInfo = PrinterInfo4Fields;

    cbStruct = sizeof(PRINTER_INFO_4);

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pPrinterEnum, &cbBuf);

    if (pPrinterEnum && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = EnumPerMachineConnections(pServer,
                                     pAlignedBuff,
                                     cbBuf,
                                     pcbNeeded,
                                     pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route );
    }

    UndoAlignRpcPtr(pPrinterEnum, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();

}

DWORD
YAddPrintProcessor(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    LPWSTR      pPathName,
    LPWSTR      pPrintProcessorName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AddPrintProcessor(pName, pEnvironment, pPathName,
                             pPrintProcessorName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else {

        return GetLastError();
    }
}

DWORD
YEnumPrintProcessors(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    DWORD       Level,
    LPBYTE      pPrintProcessors,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned,
    CALL_ROUTE  Route
)
{
    DWORD   cReturned, cbStruct;
    FieldInfo *pFieldInfo;
    BOOL    bRet;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = PrintProcessorInfo1Fields;
        cbStruct = sizeof(PRINTPROCESSOR_INFO_1);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pPrintProcessors, &cbBuf);

    if (pPrintProcessors && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = EnumPrintProcessors(pName, pEnvironment, Level,
                               pAlignedBuff, cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct ,Route );
    }

    UndoAlignRpcPtr(pPrintProcessors, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YGetPrintProcessorDirectory(
    LPWSTR      pName,
    LPWSTR      pEnvironment,
    DWORD       Level,
    LPBYTE      pPrintProcessorInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = GetPrintProcessorDirectory(pName, pEnvironment, Level,
                                      pPrintProcessorInfo, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YEnumPrintProcessorDatatypes(
    LPWSTR      pName,
    LPWSTR      pPrintProcessorName,
    DWORD       Level,
    LPBYTE      pDatatypes,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    LPDWORD     pcReturned,
    CALL_ROUTE   Route
)
{
    DWORD   cReturned,cbStruct;
    FieldInfo *pFieldInfo;
    BOOL    bRet;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = DatatypeInfo1Fields;
        cbStruct = sizeof(DATATYPES_INFO_1);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pDatatypes, &cbBuf);

    if (pDatatypes && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = EnumPrintProcessorDatatypes(pName, pPrintProcessorName,
                                       Level, pAlignedBuff, cbBuf,
                                       pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pDatatypes, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YStartDocPrinter(
    HANDLE                  hPrinter,
    LPDOC_INFO_CONTAINER    pDocInfoContainer,
    LPDWORD                 pJobId,
    CALL_ROUTE              Route
)
{
    LPWSTR pChar;

    if( !pDocInfoContainer || pDocInfoContainer->Level != 1 ){
        RaiseException( ERROR_INVALID_USER_BUFFER,
                        EXCEPTION_NONCONTINUABLE,
                        0,
                        NULL );
    }

    try
    {
        if(pDocInfoContainer->DocInfo.pDocInfo1)
        {
            if( pDocInfoContainer->DocInfo.pDocInfo1->pDocName )
            {
               for( pChar = pDocInfoContainer->DocInfo.pDocInfo1->pDocName;
                    *pChar;
                    ++pChar )
                    ;
            }

            if( pDocInfoContainer->DocInfo.pDocInfo1->pOutputFile )
            {

               for( pChar = pDocInfoContainer->DocInfo.pDocInfo1->pOutputFile;
                    *pChar;
                    ++pChar )
                   ;
            }

            if( pDocInfoContainer->DocInfo.pDocInfo1->pDatatype )
            {

               for( pChar = pDocInfoContainer->DocInfo.pDocInfo1->pDatatype;
                    *pChar;
                    ++pChar )
                   ;
            }
         }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {

        RaiseException( ERROR_INVALID_USER_BUFFER,
                        EXCEPTION_NONCONTINUABLE,
                        0,
                        NULL );
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    *pJobId = StartDocPrinter(hPrinter, pDocInfoContainer->Level,
                              (LPBYTE)pDocInfoContainer->DocInfo.pDocInfo1);

    YRevertToSelf(Route);

    if (*pJobId)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YStartPagePrinter(
   HANDLE       hPrinter,
   CALL_ROUTE    Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = StartPagePrinter(hPrinter);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YWritePrinter(
    HANDLE      hPrinter,
    LPBYTE      pBuf,
    DWORD       cbBuf,
    LPDWORD     pcWritten,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = WritePrinter(hPrinter, pBuf, cbBuf, pcWritten);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}


DWORD
YSeekPrinter(
    HANDLE          hPrinter,
    LARGE_INTEGER   liDistanceToMove,
    PLARGE_INTEGER  pliNewPointer,
    DWORD           dwMoveMethod,
    BOOL            bWritePrinter,
    CALL_ROUTE       Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = SeekPrinter( hPrinter,
                        liDistanceToMove,
                        pliNewPointer,
                        dwMoveMethod,
                        bWritePrinter );

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}


DWORD
YFlushPrinter(
    HANDLE      hPrinter,
    LPBYTE      pBuf,
    DWORD       cbBuf,
    LPDWORD     pcWritten,
    DWORD       cSleep,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = FlushPrinter(hPrinter, pBuf, cbBuf, pcWritten, cSleep);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YEndPagePrinter(
    HANDLE      hPrinter,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = EndPagePrinter(hPrinter);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YAbortPrinter(
    HANDLE      hPrinter,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AbortPrinter(hPrinter);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YReadPrinter(
    HANDLE      hPrinter,
    LPBYTE      pBuf,
    DWORD       cbBuf,
    LPDWORD     pRead,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ReadPrinter(hPrinter, pBuf, cbBuf, pRead);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YSplReadPrinter(
    HANDLE      hPrinter,
    LPBYTE      *pBuf,
    DWORD       cbBuf,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    // Currently SplReadPrinter is internal and does not come thru RPC.

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = SplReadPrinter(hPrinter, pBuf, cbBuf);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

VOID StartDriverUnload( LPVOID pDriverFile )
{

    SplDriverUnloadComplete((LPWSTR) pDriverFile);

    if (pDriverFile) {
       FreeSplMem(pDriverFile);
    }

    return;
}

VOID
YDriverUnloadComplete(
    LPWSTR  pDriverFile
)
{
    HANDLE  hThread;
    DWORD   dwThreadId;
    LPWSTR  pDriverFileCopy = NULL;

    // Copy the string for passing it to another thread
    if (pDriverFile && *pDriverFile) {
        pDriverFileCopy = AllocSplStr(pDriverFile);
    }

    if (!pDriverFileCopy) {
        return;
    }

    // Create a thread to process driver unload and return ASAP
    hThread = CreateThread(NULL,
                           LARGE_INITIAL_STACK_COMMIT,
                           (LPTHREAD_START_ROUTINE) StartDriverUnload,
                           (LPVOID) pDriverFileCopy,
                           0,
                           &dwThreadId);
    if (hThread) {
        CloseHandle(hThread);
    } else {
        // thread did not spawn, free resources
        FreeSplStr(pDriverFileCopy);
    }

    return;
}

DWORD
YEndDocPrinter(
    HANDLE      hPrinter,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = EndDocPrinter(hPrinter);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YAddJob(
    HANDLE      hPrinter,
    DWORD       Level,
    LPBYTE      pAddJob,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE   Route
)
{
    BOOL        bRet;
    LPBYTE      pAlignedBuff;
    DWORD       cbStruct;
    FieldInfo   *pFieldInfo;

    switch (Level) {

    case 1:
        pFieldInfo = AddJobFields;
        cbStruct = sizeof(ADDJOB_INFO_1W);
        break;
    case 2:
    case 3:
        pFieldInfo = AddJob2Fields;
        cbStruct = sizeof(ADDJOB_INFO_2W);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pAddJob, &cbBuf);

    if (pAddJob && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = AddJob(hPrinter, Level, pAlignedBuff, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

    if (bRet) {

        if (Route) {

            bRet = MarshallDownStructure(pAlignedBuff, pFieldInfo, sizeof(cbStruct), Route);
        }
    }

    UndoAlignRpcPtr(pAddJob, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YScheduleJob(
    HANDLE      hPrinter,
    DWORD       JobId,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ScheduleJob(hPrinter, JobId);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YGetPrinterData(
   HANDLE       hPrinter,
   LPTSTR       pValueName,
   LPDWORD      pType,
   LPBYTE       pData,
   DWORD        nSize,
   LPDWORD      pcbNeeded,
   CALL_ROUTE    Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = GetPrinterData(hPrinter, pValueName, pType,
                           pData, nSize, pcbNeeded);

    YRevertToSelf(Route);

    return dwRet;
}

DWORD
YGetPrinterDataEx(
   HANDLE       hPrinter,
   LPCTSTR      pKeyName,
   LPCTSTR      pValueName,
   LPDWORD      pType,
   LPBYTE       pData,
   DWORD        nSize,
   LPDWORD      pcbNeeded,
   CALL_ROUTE   Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = GetPrinterDataEx(hPrinter, pKeyName,pValueName, pType,
                                           pData, nSize, pcbNeeded);

    YRevertToSelf(Route);

    return dwRet;
}


DWORD
YEnumPrinterData(
    HANDLE      hPrinter,
    DWORD       dwIndex,        // index of value to query
    LPWSTR      pValueName,     // address of buffer for value string
    DWORD       cbValueName,    // size of value buffer
    LPDWORD     pcbValueName,   // address for size of value buffer
    LPDWORD     pType,          // address of buffer for type code
    LPBYTE      pData,          // address of buffer for value data
    DWORD       cbData,         // size of data buffer
    LPDWORD     pcbData,        // address for size of data buffer
    CALL_ROUTE   Route        // where this call comes from
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = EnumPrinterData(hPrinter,
                            dwIndex,
                            pValueName,
                            cbValueName,
                            pcbValueName,
                            pType,
                            pData,
                            cbData,
                            pcbData);

    YRevertToSelf(Route);

    return dwRet;
}

DWORD
YEnumPrinterDataEx(
    HANDLE      hPrinter,
    LPCWSTR     pKeyName,       // address of key name
    LPBYTE      pEnumValues,
    DWORD       cbEnumValues,
    LPDWORD     pcbEnumValues,
    LPDWORD     pnEnumValues,
    CALL_ROUTE  Route
)
{
    DWORD dwRet;
    DWORD cReturned;
    PPRINTER_ENUM_VALUES pEnumValue = (PPRINTER_ENUM_VALUES) pEnumValues;
    LPBYTE  pAlignedBuff;

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pEnumValues, &cbEnumValues);

    if (pEnumValues && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    dwRet = EnumPrinterDataEx(  hPrinter,
                                pKeyName,
                                pAlignedBuff,
                                cbEnumValues,
                                pcbEnumValues,
                                pnEnumValues);

    YRevertToSelf(Route);

    if (dwRet == ERROR_SUCCESS) {

        if (!MarshallDownStructuresArray((LPBYTE) pAlignedBuff,
                                         *pnEnumValues,
                                          PrinterEnumValuesFields,
                                          sizeof(PRINTER_ENUM_VALUES),
                                          Route) ) {
            dwRet = GetLastError();
        }

    }

    UndoAlignRpcPtr(pEnumValues, pAlignedBuff, cbEnumValues, pcbEnumValues);

    return dwRet;

}

DWORD
YEnumPrinterKey(
    HANDLE      hPrinter,
    LPCWSTR     pKeyName,       // address of key name
    LPWSTR      pSubkey,        // address of buffer for value string
    DWORD       cbSubkey,       // size of value buffer
    LPDWORD     pcbSubkey,      // address for size of value buffer
    CALL_ROUTE   Route        // where this call comes from
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = EnumPrinterKey( hPrinter,
                            pKeyName,
                            pSubkey,
                            cbSubkey,
                            pcbSubkey);

    YRevertToSelf(Route);

    return dwRet;
}

DWORD
YDeletePrinterData(
    HANDLE      hPrinter,
    LPWSTR      pValueName,
    CALL_ROUTE  Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = DeletePrinterData(hPrinter, pValueName);

    YRevertToSelf(Route);

    return dwRet;
}

DWORD
YDeletePrinterDataEx(
    HANDLE      hPrinter,
    LPCWSTR     pKeyName,
    LPCWSTR     pValueName,
    CALL_ROUTE   Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = DeletePrinterDataEx(hPrinter, pKeyName, pValueName);

    YRevertToSelf(Route);

    return dwRet;
}

DWORD
YDeletePrinterKey(
    HANDLE      hPrinter,
    LPCWSTR     pKeyName,
    CALL_ROUTE   Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = DeletePrinterKey(hPrinter, pKeyName);

    YRevertToSelf(Route);

    return dwRet;
}


DWORD
YSetPrinterData(
    HANDLE      hPrinter,
    LPTSTR      pValueName,
    DWORD       Type,
    LPBYTE      pData,
    DWORD       cbData,
    CALL_ROUTE  Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = SetPrinterData(hPrinter, pValueName, Type, pData, cbData);

    YRevertToSelf(Route);

    return dwRet;
}

DWORD
YSetPrinterDataEx(
    HANDLE      hPrinter,
    LPCTSTR     pKeyName,
    LPCTSTR     pValueName,
    DWORD       Type,
    LPBYTE      pData,
    DWORD       cbData,
    CALL_ROUTE   Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    dwRet = SetPrinterDataEx(hPrinter, pKeyName, pValueName, Type, pData, cbData);

    YRevertToSelf(Route);

    return dwRet;
}


DWORD
YWaitForPrinterChange(
   HANDLE       hPrinter,
   DWORD        Flags,
   LPDWORD      pFlags,
   CALL_ROUTE   Route
)
{
    if (!YImpersonateClient(Route))
        return GetLastError();

    *pFlags = WaitForPrinterChange(hPrinter, Flags);

    YRevertToSelf(Route);

    if (*pFlags) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YClosePrinter(
   LPHANDLE     phPrinter,
   CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ClosePrinter(*phPrinter);

    YRevertToSelf(Route);

    *phPrinter = NULL;  // NULL out handle so Route knows to close it down.

    if (bRet) {

        InterlockedDecrement( &ServerHandleCount );
        return ERROR_SUCCESS;

    } else

        return GetLastError();
}



VOID
PRINTER_HANDLE_rundown(
    HANDLE     hPrinter
    )
{
    DBGMSG(DBG_INFO, ("Printer Handle rundown called\n"));

    PrinterHandleRundown(hPrinter);
}

DWORD
YAddForm(
    HANDLE          hPrinter,
    PFORM_CONTAINER pFormInfoContainer,
    CALL_ROUTE      Route
)
{
    BOOL bRet;

    if(!pFormInfoContainer)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AddForm(hPrinter, pFormInfoContainer->Level,
                   (LPBYTE)pFormInfoContainer->FormInfo.pFormInfo1);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YDeleteForm(
    HANDLE      hPrinter,
    LPWSTR      pFormName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeleteForm(hPrinter, pFormName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YGetForm(
    PRINTER_HANDLE  hPrinter,
    LPWSTR          pFormName,
    DWORD           Level,
    LPBYTE          pForm,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded,
    CALL_ROUTE      Route
)
{
    BOOL    bRet;
    LPBYTE  pAlignedBuff;

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pForm, &cbBuf);

    if (pForm && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = GetForm(hPrinter, pFormName, Level, pAlignedBuff, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructure(pAlignedBuff, FormInfo1Fields, sizeof(FORM_INFO_1), Route);
    }

    UndoAlignRpcPtr(pForm, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YSetForm(
    PRINTER_HANDLE  hPrinter,
    LPWSTR          pFormName,
    PFORM_CONTAINER pFormInfoContainer,
    CALL_ROUTE       Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = SetForm(hPrinter, pFormName, pFormInfoContainer->Level,
                   (LPBYTE)pFormInfoContainer->FormInfo.pFormInfo1);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YEnumForms(
   PRINTER_HANDLE   hPrinter,
   DWORD            Level,
   LPBYTE           pForm,
   DWORD            cbBuf,
   LPDWORD          pcbNeeded,
   LPDWORD          pcReturned,
   CALL_ROUTE        Route
)
{
    BOOL  bRet;
    DWORD cReturned, cbStruct;
    FieldInfo *pFieldInfo;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = FormInfo1Fields;
        cbStruct = sizeof(FORM_INFO_1);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pForm, &cbBuf);

    if (pForm && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = EnumForms(hPrinter, Level, pAlignedBuff, cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pForm, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YEnumPorts(
   LPWSTR       pName,
   DWORD        Level,
   LPBYTE       pPort,
   DWORD        cbBuf,
   LPDWORD      pcbNeeded,
   LPDWORD      pcReturned,
   CALL_ROUTE   Route
)
{
    BOOL    bRet;
    DWORD   cReturned, cbStruct;
    FieldInfo *pFieldInfo;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = PortInfo1Fields;
        cbStruct = sizeof(PORT_INFO_1);
        break;

    case 2:
        pFieldInfo = PortInfo2Fields;
        cbStruct = sizeof(PORT_INFO_2);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pPort, &cbBuf);

    if (pPort && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = EnumPorts(pName, Level, pAlignedBuff, cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pPort, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YEnumMonitors(
   LPWSTR       pName,
   DWORD        Level,
   LPBYTE       pMonitor,
   DWORD        cbBuf,
   LPDWORD      pcbNeeded,
   LPDWORD      pcReturned,
   CALL_ROUTE   Route
)
{
    BOOL    bRet;
    DWORD   cReturned, cbStruct;
    FieldInfo *pFieldInfo;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = MonitorInfo1Fields;
        cbStruct = sizeof(MONITOR_INFO_1);
        break;

    case 2:
        pFieldInfo = MonitorInfo2Fields;
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pMonitor, &cbBuf);

    if (pMonitor && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = EnumMonitors(pName, Level, pAlignedBuff, cbBuf, pcbNeeded, pcReturned);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructuresArray(pAlignedBuff, *pcReturned, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pMonitor, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();

}

DWORD
YAddPort(
    LPWSTR      pName,
    HWND        hWnd,
    LPWSTR      pMonitorName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AddPort(pName, hWnd, pMonitorName);

    YRevertToSelf(Route);

    if (bRet)

        return ERROR_SUCCESS;

    else

        return GetLastError();
}

DWORD
YConfigurePort(
    LPWSTR      pName,
    HWND        hWnd,
    LPWSTR      pPortName,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ConfigurePort(pName, hWnd, pPortName);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YDeletePort(
    LPWSTR      pName,
    HWND        hWnd,
    LPWSTR      pPortName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePort(pName, hWnd, pPortName);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YXcvData(
    HANDLE      hXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = XcvData( hXcv,
                    pszDataName,
                    pInputData,
                    cbInputData,
                    pOutputData,
                    cbOutputData,
                    pcbOutputNeeded,
                    pdwStatus);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}


DWORD
YCreatePrinterIC(
    HANDLE              hPrinter,
    HANDLE              *pHandle,
    LPDEVMODE_CONTAINER pDevModeContainer,
    CALL_ROUTE           Route
)
{
    if (!YImpersonateClient(Route))
        return GetLastError();

    if ( InvalidDevModeContainer(pDevModeContainer) ) {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    *pHandle = CreatePrinterIC(hPrinter,
                               (LPDEVMODEW)pDevModeContainer->pDevMode);

    YRevertToSelf(Route);

    if (*pHandle)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YPlayGdiScriptOnPrinterIC(
    GDI_HANDLE  hPrinterIC,
    LPBYTE      pIn,
    DWORD       cIn,
    LPBYTE      pOut,
    DWORD       cOut,
    DWORD       ul,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = PlayGdiScriptOnPrinterIC(hPrinterIC, pIn, cIn, pOut, cOut, ul);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YDeletePrinterIC(
    GDI_HANDLE *phPrinterIC,
    BOOL        bImpersonate,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (bImpersonate && !YImpersonateClient(Route))
       return GetLastError();

    bRet = DeletePrinterIC(*phPrinterIC);

    if (bImpersonate)
        YRevertToSelf(Route);

    if (bRet) {

        *phPrinterIC = NULL;  // NULL out handle so Route knows to close it down.

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}


DWORD
YPrinterMessageBox(
   PRINTER_HANDLE   hPrinter,
   DWORD            Error,
   HWND             hWnd,
   LPWSTR           pText,
   LPWSTR           pCaption,
   DWORD            dwType,
   CALL_ROUTE       Route
)
{
    return PrinterMessageBox(hPrinter, Error, hWnd, pText, pCaption, dwType);
}

DWORD
YAddMonitor(
   LPWSTR               pName,
   PMONITOR_CONTAINER   pMonitorContainer,
   CALL_ROUTE            Route
)
{
    BOOL bRet;

    if(!ValidateMonitorContainer(pMonitorContainer))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = AddMonitor(pName, pMonitorContainer->Level,
                      (LPBYTE)pMonitorContainer->MonitorInfo.pMonitorInfo1);

    YRevertToSelf(Route);

    if (bRet)

        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YDeleteMonitor(
   LPWSTR      pName,
   LPWSTR      pEnvironment,
   LPWSTR      pMonitorName,
   CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeleteMonitor(pName, pEnvironment, pMonitorName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YDeletePrintProcessor(
   LPWSTR       pName,
   LPWSTR       pEnvironment,
   LPWSTR       pPrintProcessorName,
   CALL_ROUTE    Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePrintProcessor(pName, pEnvironment, pPrintProcessorName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YAddPrintProvidor(
    LPWSTR              pName,
    PPROVIDOR_CONTAINER pProvidorContainer,
    CALL_ROUTE          Route
)
{
    BOOL     bRet;
    DWORD    cchOrder;
    LPBYTE   pProvidorInfo;

    PROVIDOR_INFO_2W  ProvidorInfo2;
    LPRPC_PROVIDOR_INFO_2W pRpcProvidorInfo;

    if(!pProvidorContainer)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!YImpersonateClient(Route))
        return GetLastError();

    switch (pProvidorContainer->Level) {
    case 1:
        pProvidorInfo = (LPBYTE) pProvidorContainer->ProvidorInfo.pProvidorInfo1;
        break;

    case 2:
        pRpcProvidorInfo = (LPRPC_PROVIDOR_INFO_2W)pProvidorContainer->ProvidorInfo.pRpcProvidorInfo2;
        cchOrder         = pRpcProvidorInfo->cchOrder;

        if (!IsValidMultiSz(pRpcProvidorInfo->pOrder, cchOrder))
        {
            YRevertToSelf(Route);
            return ERROR_INVALID_PARAMETER;
        }

        ProvidorInfo2.pOrder = (cchOrder == 0 || cchOrder == 1)
                                 ? szNull
                                 : pRpcProvidorInfo->pOrder;

        pProvidorInfo = (LPBYTE) &ProvidorInfo2;
        break;

    default:
        YRevertToSelf(Route);
        return ERROR_INVALID_LEVEL;
    }

    bRet = AddPrintProvidor(pName, pProvidorContainer->Level,
                            pProvidorInfo);

    YRevertToSelf(Route);

    if (bRet)

        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YDeletePrintProvidor(
   LPWSTR       pName,
   LPWSTR       pEnvironment,
   LPWSTR       pPrintProvidorName,
   CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = DeletePrintProvidor(pName, pEnvironment, pPrintProvidorName);

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}


DWORD
YGetPrinterDriver2(
    HANDLE      hPrinter,
    LPWSTR      pEnvironment,
    DWORD       Level,
    LPBYTE      pDriverInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    DWORD       dwClientMajorVersion,
    DWORD       dwClientMinorVersion,
    PDWORD      pdwServerMajorVersion,
    PDWORD      pdwServerMinorVersion,
    CALL_ROUTE  Route
)
{
    FieldInfo *pFieldInfo;
    BOOL   bRet;
    SIZE_T cbStruct;
    LPBYTE  pAlignedBuff;

    switch (Level) {

    case 1:
        pFieldInfo = DriverInfo1Fields;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pFieldInfo = DriverInfo2Fields;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pFieldInfo = DriverInfo3Fields;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pFieldInfo = DriverInfo4Fields;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        pFieldInfo = DriverInfo5Fields;
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        pFieldInfo = DriverInfo6Fields;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    case DRIVER_INFO_VERSION_LEVEL:
        pFieldInfo = DriverInfoVersionFields;
        cbStruct = sizeof(DRIVER_INFO_VERSION);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    //
    // Determine if we want the most recent driver
    //
    if (!YImpersonateClient(Route))
        return GetLastError();

    pAlignedBuff = AlignRpcPtr(pDriverInfo, &cbBuf);

    if (pDriverInfo && !pAlignedBuff){
        YRevertToSelf(Route);
        return GetLastError();
    }

    bRet = GetPrinterDriverExW(hPrinter, pEnvironment, Level, pAlignedBuff,
                               cbBuf, pcbNeeded, dwClientMajorVersion,
                               dwClientMinorVersion, pdwServerMajorVersion,
                               pdwServerMinorVersion);

    YRevertToSelf(Route);

    if (bRet) {

        bRet = MarshallDownStructure(pAlignedBuff, pFieldInfo, cbStruct, Route);
    }

    UndoAlignRpcPtr(pDriverInfo, pAlignedBuff, cbBuf, pcbNeeded);

    return bRet ? ERROR_SUCCESS : GetLastError();
}

DWORD
YAddPortEx(
    LPWSTR pName,
    LPPORT_CONTAINER        pPortContainer,
    LPPORT_VAR_CONTAINER    pPortVarContainer,
    LPWSTR                  pMonitorName,
    CALL_ROUTE               Route
    )
{
    BOOL bRet;
    DWORD Level;
    PPORT_INFO_FF pPortInfoFF;
    PPORT_INFO_1 pPortInfo1;

    if(!ValidatePortContainer(pPortContainer))
    {
        return ERROR_INVALID_PARAMETER;
    }

    Level = pPortContainer->Level;

    switch (Level){
    case 1:
        pPortInfo1 = pPortContainer->PortInfo.pPortInfo1;

        if (!YImpersonateClient(Route))
            return GetLastError();
        bRet = AddPortEx(pName, Level, (LPBYTE)pPortInfo1, pMonitorName);
        YRevertToSelf(Route);
        break;

    case (DWORD)-1:

        pPortInfoFF = pPortContainer->PortInfo.pPortInfoFF;
        if(!ValidatePortVarContainer(pPortVarContainer))
        {
            return(ERROR_INVALID_PARAMETER);
        }
        pPortInfoFF->cbMonitorData = pPortVarContainer->cbMonitorData;
        pPortInfoFF->pMonitorData = pPortVarContainer->pMonitorData;

        if (!YImpersonateClient(Route))
            return GetLastError();
        bRet = AddPortEx(pName, Level, (LPBYTE)pPortInfoFF, pMonitorName);
        YRevertToSelf(Route);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return ERROR_INVALID_PARAMETER;

    }
    if (bRet) {
        return ERROR_SUCCESS;
    } else
        return GetLastError();
}


DWORD
YSpoolerInit(
    LPWSTR      pName,
    CALL_ROUTE   Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = SpoolerInit();

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}



DWORD
YResetPrinterEx(
    HANDLE              hPrinter,
    LPWSTR              pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD               dwFlag,
    CALL_ROUTE          Route

)
{
    PRINTER_DEFAULTS  Defaults;
    BOOL              bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    if ( InvalidDevModeContainer(pDevModeContainer) ) {
        YRevertToSelf(Route);
        return ERROR_INVALID_PARAMETER;
    }

    if (pDatatype) {
        Defaults.pDatatype = pDatatype;
    }else {
        if (dwFlag & RESET_PRINTER_DATATYPE) {
            Defaults.pDatatype = (LPWSTR)-1;
        }else {
            Defaults.pDatatype = NULL;
        }
    }

    if ((LPDEVMODE)pDevModeContainer->pDevMode) {
        Defaults.pDevMode = (LPDEVMODE)pDevModeContainer->pDevMode;
    }else {
        if (dwFlag & RESET_PRINTER_DEVMODE) {
            Defaults.pDevMode = (LPDEVMODE)-1;
        }else{
            Defaults.pDevMode = NULL;
        }
    }

    //
    // You cannot change the Access Mask on a Printer Spool Object
    // We will always ignore this parameter and set it to zero
    // We get some random garbage otherwise.
    //

    Defaults.DesiredAccess = 0;

    bRet = ResetPrinter(hPrinter, &Defaults);

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}

DWORD
YSetAllocFailCount(
    HANDLE      hPrinter,
    DWORD       dwFailCount,
    LPDWORD     lpdwAllocCount,
    LPDWORD     lpdwFreeCount,
    LPDWORD     lpdwFailCountHit,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = SetAllocFailCount( hPrinter, dwFailCount, lpdwAllocCount, lpdwFreeCount, lpdwFailCountHit );

    YRevertToSelf(Route);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();
}


BOOL
YImpersonateClient(
    CALL_ROUTE   Route
)
{
    DWORD   Status;

    if (Route != NATIVE_CALL) {

        Status = RpcImpersonateClient(NULL);
        SPLASSERT( Status == RPC_S_OK || Status == RPC_S_NO_CONTEXT_AVAILABLE );

        if ( Status != RPC_S_OK ) {
            SetLastError( Status );
            return FALSE;
        }
    }

    return TRUE;    // If not RPC, then we should continue w/out doing anything
}

DWORD
YSetPort(
    LPWSTR              pName,
    LPWSTR              pPortName,
    LPPORT_CONTAINER    pPortContainer,
    CALL_ROUTE          Route
)
{
    BOOL bRet;

    if(!ValidatePortContainer(pPortContainer))
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch (pPortContainer->Level) {

        case 3:
            if ( !YImpersonateClient(Route) )
                return GetLastError();

            bRet = SetPort(pName,
                           pPortName,
                           pPortContainer->Level,
                           (LPBYTE)pPortContainer->PortInfo.pPortInfo1);
            YRevertToSelf(Route);
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return ERROR_INVALID_PARAMETER;
    }

    return bRet ? ERROR_SUCCESS : GetLastError();
}


DWORD
YClusterSplOpen(
    LPCTSTR     pszServer,
    LPCTSTR     pszResource,
    PHANDLE     phSpooler,
    LPCTSTR     pszName,
    LPCTSTR     pszAddress,
    CALL_ROUTE   Route
    )
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ClusterSplOpen( pszServer,
                           pszResource,
                           phSpooler,
                           pszName,
                           pszAddress );

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YClusterSplClose(
    PHANDLE     phPrinter,
    CALL_ROUTE  Route
)
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ClusterSplClose( *phPrinter );

    YRevertToSelf(Route);

    *phPrinter = NULL;  // NULL out handle so Route knows to close it down.

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YClusterSplIsAlive(
    HANDLE      hSpooler,
    CALL_ROUTE   Route
    )
{
    BOOL bRet;

    if (!YImpersonateClient(Route))
        return GetLastError();

    bRet = ClusterSplIsAlive( hSpooler );

    YRevertToSelf(Route);

    if (bRet) {

        return ERROR_SUCCESS;

    } else

        return GetLastError();
}

DWORD
YGetSpoolFileInfo(
    HANDLE      hPrinter,
    DWORD       dwAppProcessId,
    DWORD       dwLevel,
    LPBYTE      pSpoolFileInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
)
{
    HANDLE  hAppProcess;
    BOOL    bReturn = FALSE;

    // Open the application before impersonating the user
    hAppProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwAppProcessId);

    if (!YImpersonateClient(Route)) {
        goto CleanUp;
    }

    bReturn = SplGetSpoolFileInfo(hPrinter, hAppProcess, dwLevel,
                                  pSpoolFileInfo, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

CleanUp:

    if (hAppProcess) {
        CloseHandle(hAppProcess);
    }

    if (bReturn) {
        return ERROR_SUCCESS;
    } else {
        return GetLastError();
    }
}

DWORD
YGetSpoolFileInfo2(
    HANDLE      hPrinter,
    DWORD       dwAppProcessId,
    DWORD       dwLevel,
    LPFILE_INFO_CONTAINER pSplFileInfoContainer,
    CALL_ROUTE   Route
    )
{
    HANDLE  hAppProcess;
    BOOL    bReturn = FALSE;
    DWORD   cbNeeded = 0;
    LPBYTE  pSpoolFileInfo;
    DWORD   cbSize;
    DWORD   dwLastError = ERROR_SUCCESS;

    switch (dwLevel){
    case 1:

        if(!pSplFileInfoContainer || !pSplFileInfoContainer->FileInfo.Level1)
        {
            return ERROR_INVALID_HANDLE;
        }
        pSpoolFileInfo = (LPBYTE)pSplFileInfoContainer->FileInfo.Level1;
        cbSize = sizeof(SPOOL_FILE_INFO_1);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    // Open the application before impersonating the user
    if ( hAppProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwAppProcessId) ) {

        if (YImpersonateClient(Route)) {

            bReturn = SplGetSpoolFileInfo(hPrinter, hAppProcess, dwLevel,
                                          pSpoolFileInfo,
                                          cbSize, &cbNeeded);

            YRevertToSelf(Route);
        }
    }

    if ( !bReturn ) {

        dwLastError = GetLastError();

        //
        // Ensure that if someone didn't set a last error, but failed the call,
        // we still return an error.
        //
        if (dwLastError == ERROR_SUCCESS) {

            dwLastError = ERROR_INVALID_HANDLE;
        }
    }

    if (hAppProcess) {
        CloseHandle(hAppProcess);
    }

    return dwLastError;
}

DWORD
YCommitSpoolData(
    HANDLE      hPrinter,
    DWORD       dwAppProcessId,
    DWORD       cbCommit,
    DWORD       dwLevel,
    LPBYTE      pSpoolFileInfo,
    DWORD       cbBuf,
    LPDWORD     pcbNeeded,
    CALL_ROUTE  Route
)
{
    HANDLE  hAppProcess;
    BOOL    bReturn = FALSE;

    // Open the application before impersonating the user
    hAppProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwAppProcessId);

    if (!YImpersonateClient(Route)) {
        goto CleanUp;
    }

    bReturn = SplCommitSpoolData(hPrinter, hAppProcess, cbCommit,
                                 dwLevel, pSpoolFileInfo, cbBuf, pcbNeeded);

    YRevertToSelf(Route);

CleanUp:

    if (hAppProcess) {
        CloseHandle(hAppProcess);
    }

    if (bReturn) {
        return ERROR_SUCCESS;
    } else {
        return GetLastError();
    }
}

DWORD
YCommitSpoolData2(
    HANDLE      hPrinter,
    DWORD       dwAppProcessId,
    DWORD       cbCommit,
    DWORD       dwLevel,
    LPFILE_INFO_CONTAINER pSplFileInfoContainer,
    CALL_ROUTE  Route
)
{
    HANDLE  hAppProcess;
    BOOL    bReturn = FALSE;
    DWORD   cbNeeded = 0;
    LPBYTE  pSpoolFileInfo;
    DWORD   cbSize;
    DWORD   dwLastError = ERROR_SUCCESS;

    switch (dwLevel){
    case 1:

        if(!pSplFileInfoContainer || !pSplFileInfoContainer->FileInfo.Level1)
        {
            return ERROR_INVALID_HANDLE;
        }
        pSpoolFileInfo = (LPBYTE)pSplFileInfoContainer->FileInfo.Level1;
        cbSize = sizeof(SPOOL_FILE_INFO_1);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    // Open the application before impersonating the user
    if ( hAppProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwAppProcessId) ) {

        if (YImpersonateClient(Route)) {

            bReturn = SplCommitSpoolData(hPrinter, hAppProcess, cbCommit,
                                         dwLevel, pSpoolFileInfo,
                                         cbSize, &cbNeeded);

            YRevertToSelf(Route);
        }
    }

    if ( !bReturn ) {

        dwLastError = GetLastError();

        //
        // Make sure that there is a failure return if there is no last error.
        //
        if (dwLastError == ERROR_SUCCESS) {

            dwLastError = ERROR_INVALID_HANDLE;
        }
    }

    if (hAppProcess) {
        CloseHandle(hAppProcess);
    }

    return dwLastError;
}



DWORD
YCloseSpoolFileHandle(
    HANDLE      hPrinter,
    CALL_ROUTE  Route
)
{
    BOOL    bReturn = FALSE;

    if (!YImpersonateClient(Route)) {
        goto CleanUp;
    }

    bReturn = SplCloseSpoolFileHandle(hPrinter);

    YRevertToSelf(Route);

CleanUp:

    if (bReturn) {
        return ERROR_SUCCESS;
    } else {
        return GetLastError();
    }
}


DWORD
YSendRecvBidiData(
    IN          HANDLE  hPrinter,
    IN          LPCWSTR pAction,
    IN          PBIDI_REQUEST_CONTAINER   pReqData,
    OUT         PBIDI_RESPONSE_CONTAINER* ppResData,
    CALL_ROUTE  Route
)
{
    DWORD dwRet;

    if (!YImpersonateClient(Route))
    {
        dwRet = GetLastError();
    }
    else
    {
        //
        // Do we need to verify the Data in pReqData ???
        //
        dwRet = SendRecvBidiData(hPrinter,
                                 pAction,
                                 pReqData,
                                 ppResData);
        YRevertToSelf(Route);
    }

    return (dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\drvevnt.hpp ===
#ifndef __DRVENVT_HPP__
#define __DRVEVNT_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldmgr.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the declararion of the class
     dealing with various Driver Events namely
     o DrvDocumentEvent
     o DrvPrinterEvent
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 18 January 2000                                        
     
                                                                             
  Revision History:                                                           
--*/
#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

#ifndef __BASECLS_HPP__
#include "basecls.hpp"
#endif

//
// Forward declarations
//
class TLoad64BitDllsMgr;

class TPrinterEventMgr : public TClassID,
                         public TLd64BitDllsErrorHndlr,
                         public TRefCntMgr,
                         public TPrinterDriver
{
     public:

     TPrinterEventMgr(
         IN TLoad64BitDllsMgr *pIpLdrObj
         );

     ~TPrinterEventMgr(
         VOID
         );

     BOOL 
     SpoolerPrinterEvent(
         IN  LPWSTR pszPrinterName,
         IN  int    PrinterEvent,
         IN  DWORD  Flags,
         IN  LPARAM lParam,
         OUT PDWORD pErrorCode
         );

     int
     DocumentEvent(
         IN  LPWSTR      pszPrinterName,
         IN  ULONG_PTR   InDC,
         IN  int         EscapeCode,
         IN  DWORD       InSize,
         IN  LPBYTE      pInBuf,
         OUT PDWORD      pOutSize,
         OUT LPBYTE      *ppOutBuf,
         OUT PDWORD      pErrorCode
         );


     private:
     TLoad64BitDllsMgr   *m_pLdrObj;
};

#endif //__DRVENVT_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\gdithnk.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     gdithnk.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the startup code for the
     surrogate rpc server used to load 64 bit dlls
     in 32 bit apps
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 19-Jun-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#include "sddl.h"

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif

#ifndef __GDITHNK_HPP__
#include "gdithnk.hpp"
#endif


/*++
    Function Name:
        LPCConnMsgsServingThread
     
    Description:
        This funciton is the main loop for processing LPC requests
        by dispatching them to the LPC handler which takes the proper
        action according to the request.
        This function runs in a Thread of its own.
     
     Parameters:
        pThredData  : The Thread specific data which encapsulates the 
                      pointer to the LPC handler.
        
     Return Value
        Always returns 1
--*/
EXTERN_C
DWORD
LPCConnMsgsServingThread(
    PVOID pThrdData
    )
{
    //
    // Communication Port Handles are unique , i.e. one per 
    // Client Server conversation
    //
    HANDLE       ConnectionPortHandle;
    NTSTATUS     Status                    = STATUS_SUCCESS;
    DWORD        ErrorCode                 = ERROR_SUCCESS;
    PVOID        pCommunicationPortContext = NULL;

    SPROXY_MSG   RequestMsg;
    PSPROXY_MSG  pReplyMsg;

    //
    // reconstruct the Data passed in for the Thread
    //
    TLPCMgr*   pMgrInst  = reinterpret_cast<TLPCMgr*>((reinterpret_cast<PSLPCMSGSTHRDDATA>(pThrdData))->pData);

    SPLASSERT(pMgrInst);

    ConnectionPortHandle  = pMgrInst->GetUMPDLpcConnPortHandle();

    for(pReplyMsg=NULL,memset(&RequestMsg,0,sizeof(SPROXY_MSG));
        pMgrInst;)
    {
        //
        // Data sent back to client and then call blocked until another message
        // comes in
        //
        Status = NtReplyWaitReceivePort( ConnectionPortHandle,
                                         reinterpret_cast<PVOID*>(&pCommunicationPortContext),
                                         reinterpret_cast<PPORT_MESSAGE>(pReplyMsg),
                                         reinterpret_cast<PPORT_MESSAGE>(&RequestMsg)
	                                   );
        
        DBGMSG(DBG_WARN,
               ("LPCConnMsgsServingThread Active \n"));

        ConnectionPortHandle = pMgrInst->GetUMPDLpcConnPortHandle();
		pReplyMsg            = NULL;
        

        if(NT_SUCCESS(Status))
        {
            switch(RequestMsg.Msg.u2.s2.Type)
            {

                //
                // For a Connection Request coming from the Client
                //
                case LPC_CONNECTION_REQUEST:
                {
                    pMgrInst->ProcessConnectionRequest((PPORT_MESSAGE)&RequestMsg);
                    break;
                }
  
                //
                // For a Data Request coming in from the client
                //
                case LPC_REQUEST:
                {

                    if((ErrorCode = pMgrInst->ProcessRequest(&RequestMsg)) == ERROR_SUCCESS)
                    {
                         pReplyMsg = &RequestMsg;
                    }
                    //
                    // We retrieve the coomunication handle from LPC becauce this is how we send data
                    // back to the client. We can't used a connection port
                    //
                    ConnectionPortHandle = (reinterpret_cast<TLPCMgr::TClientInfo*>(pCommunicationPortContext))->GetPort();
                    break;
                }
  
                //
                // When the client close the port.
                //
                case LPC_PORT_CLOSED:
                {
					if(pCommunicationPortContext)
					{
                        HANDLE hPortID = 
                               (reinterpret_cast<TLPCMgr::TClientInfo*>(pCommunicationPortContext))->GetPort();

                        pMgrInst->ProcessPortClosure(&RequestMsg,hPortID);
					}
                    break;
                }
  
                //
                // When the client terminates (Normally or Abnormally)
                //
                case LPC_CLIENT_DIED:
                {
					if(pCommunicationPortContext)
					{
                        pMgrInst->ProcessClientDeath(&RequestMsg);
					}
                    break;
                }
  
                default:
                {
                    //
                    // Basically here we do nothing, we just retrun.
                    //
                    break;
                }
            }
        }
    }
    //
    // Cleaning up the memory allocated before leaving the Thread
    //
    delete pThrdData;
    return 1;
}

EXTERN_C
DWORD
GDIThunkingVIALPCThread(
    PVOID pThrdData
    )
{
    OBJECT_ATTRIBUTES       ObjectAttrib;
    UNICODE_STRING          UString;
    PFNGDIPRINTERTHUNKPROC  pfnThnkFn;
    NTSTATUS                Status                = STATUS_SUCCESS;
    HINSTANCE               hGDI                  = NULL;
    WCHAR                   pszPortName[MAX_PATH] = {0};
    WCHAR                   szFullSD[MAX_PATH]    = {0};

    //
    // reconstruct the Data passed in for the Thread
    //
    DWORD   *pErrorCode = &(reinterpret_cast<PSGDIThunkThrdData>(pThrdData))->ErrorCode;
    HANDLE  hSyncEvent  = (reinterpret_cast<PSGDIThunkThrdData>(pThrdData))->hEvent;
    TLPCMgr *pMgrInst   = reinterpret_cast<TLPCMgr*>((reinterpret_cast<PSGDIThunkThrdData>(pThrdData))->pData);

    if(hGDI = LoadLibrary(L"GDI32.DLL"))
    {
        if(pfnThnkFn = reinterpret_cast<PFNGDIPRINTERTHUNKPROC>(GetProcAddress(hGDI,
                                                                               "GdiPrinterThunk")))
        {
            PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
            LPWSTR               pszUserSID          = NULL;
            HRESULT              hRes                = E_FAIL;

            //
            // Give System SID a full access ACE
            // Give Creator Owner SID a full access ACE
            // Give the current user a full access ACE
            //
            WCHAR* szSD = L"D:"
                          L"(A;OICI;GA;;;SY)"
                          L"(A;OICI;GA;;;CO)"
                          L"(A;;GA;;;";

            StringCchPrintfW(pszPortName,
                             MAX_PATH,
                             L"%s_%x",
                             GDI_LPC_PORT_NAME,
                             pMgrInst->GetCurrSessionId());

            RtlInitUnicodeString(&UString,
                                 pszPortName);

            if(SUCCEEDED (hRes = GetCurrentUserSID(&pszUserSID,
                                                   pErrorCode)))
            {
                //
                // Concatenate everything representing
                // the required ACEs for the pipe DACL
                //
                StringCchPrintf(szFullSD,MAX_PATH,
                                L"%ws%ws%ws",szSD,pszUserSID,L")");

                LocalFree(pszUserSID);

                if( ConvertStringSecurityDescriptorToSecurityDescriptor(szFullSD,
                                                                        SDDL_REVISION_1,
                                                                        &pSecurityDescriptor,
                                                                        NULL))
                {
                    InitializeObjectAttributes(&ObjectAttrib,
                                               &UString,
                                               OBJ_CASE_INSENSITIVE,
                                               NULL,
                                               pSecurityDescriptor);

                    Status = NtCreatePort(pMgrInst->GetUMPDLPCConnPortHandlePtr(),
                                          &ObjectAttrib,
                                          PORT_MAXIMUM_MESSAGE_LENGTH,
                                          PORT_MAXIMUM_MESSAGE_LENGTH, 
                                          PORT_MAXIMUM_MESSAGE_LENGTH*32
                                         );

                    if(NT_SUCCESS(Status))
                    {
                        //
                        // Start processing the LPC messages either in one Thread
                        // or multiple Threads
                        //
                        HANDLE hMsgThrd;
                        DWORD  MsgThrdId;

                        if(PSLPCMSGSTHRDDATA pLPCMsgData = new SLPCMSGSTHRDDATA)
                        {
                            pLPCMsgData->pData = reinterpret_cast<void*>(pMgrInst);

                            pMgrInst->SetPFN(pfnThnkFn);

                            if(hMsgThrd  =  CreateThread(NULL,
                                                         0,
                                                         LPCConnMsgsServingThread,
                                                         (VOID *)pLPCMsgData,
                                                         0,
                                                         &MsgThrdId))
                            {
                                CloseHandle(hMsgThrd);
                            }
                            else
                            {
                                delete pLPCMsgData;
                                *pErrorCode = GetLastError();
                                DBGMSG(DBG_WARN,
                                       ("GDIThunkVIALPCThread: Failed to create the messaging thread - %u\n",*pErrorCode));
                            }
                        }
                        else
                        {
                            *pErrorCode = GetLastError();
                            DBGMSG(DBG_WARN,
                                   ("GDIThunkVIALPCThread: Failed to allocate memory - %u\n",*pErrorCode));
                        }
                    }
                    else
                    {
                        *pErrorCode = pMgrInst->MapNtStatusToWin32Error(Status);
                        DBGMSG(DBG_WARN,
                               ("GDIThunkVIALPCThread: Failed to create the LPC port - %u\n",Status));
                    }
                    LocalFree(pSecurityDescriptor);
                }
                else
                {
                    *pErrorCode = GetLastError();
                    DBGMSG(DBG_WARN,
                           ("GDIThunkVIALPCThread: Failed to create the Security Descriptor - %u\n",*pErrorCode));

                }
            }
        }
        else
        {
            *pErrorCode = GetLastError();
            DBGMSG(DBG_WARN,
                   ("GDIThunkVIALPCThread: Failed to get the entry point GdiPrinterThunk - %u\n",*pErrorCode));
        }
    }
    else
    {
        *pErrorCode = GetLastError();
        DBGMSG(DBG_WARN,
               ("GDIThunkVIALPCThread: Failed to load GDI32 - %u\n",*pErrorCode));
    }

    SetEvent(hSyncEvent);

    return 1;
}
            

/*++
    Function Name:
        GetCurrentUserSID
     
    Description:
        This funciton returns the SID of the current logged on user
     
     Parameters:
        ppszUserSID : This is the out string to be filled by
                      the current user SID
        pErrorCode  : Return the WIN32 error code to the caller                      
        
        
     Return Value
        HRSEUSLT    : S_OK    = success
                      E_FAIL  = failure
--*/
HRESULT
GetCurrentUserSID(
    PWSTR* ppszUserSID,
    PDWORD pErrorCode
    )
{
    HANDLE      hToken       = NULL;
    PTOKEN_USER pTokenUser   = NULL;
    DWORD       TokenUserLen = 0;
    HRESULT     hRes         = E_FAIL;

    if(OpenThreadToken(GetCurrentThread(),
                        TOKEN_QUERY,
                        TRUE,
                        &hToken))
    {
        hRes = S_OK;
    }
    else if((*pErrorCode = GetLastError()) == ERROR_NO_TOKEN)
    {
        if(OpenProcessToken(GetCurrentProcess(),
                            TOKEN_QUERY,
                            &hToken))
        {
            hRes = S_OK;
        }
        else
        {
            *pErrorCode = GetLastError();

            DBGMSG(DBG_WARN,
                   ("GetCurrentUserSID: Failed to open the Process Token - %u\n",*pErrorCode));
        }
    }
    else
    {
        DBGMSG(DBG_WARN,
               ("GetCurrentUserSID: Failed to open the Thread Token - %u\n",*pErrorCode));
    }

    if(SUCCEEDED(hRes))
    {
        *pErrorCode = ERROR_SUCCESS;

        if(!GetTokenInformation(hToken, 
                                TokenUser, 
                                NULL, 
                                0, 
                                &TokenUserLen) &&
            ((*pErrorCode = GetLastError()) == ERROR_INSUFFICIENT_BUFFER))
        {
            if(pTokenUser = reinterpret_cast<PTOKEN_USER>(new BYTE[TokenUserLen]))
            {
                if(GetTokenInformation(hToken,
                                       TokenUser,
                                       pTokenUser,
                                       TokenUserLen,
                                       &TokenUserLen))
                {
                    *pErrorCode = ERROR_SUCCESS;

                    //
                    // The required SID is at pTokenUser->User.Sid
                    //
                    if(!ConvertSidToStringSid(pTokenUser->User.Sid,
                                              ppszUserSID))
                    {
                        *pErrorCode = GetLastError();
                    }
                }

                delete [] reinterpret_cast<BYTE*>(pTokenUser);
            }
            else
            {
                *pErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            DBGMSG(DBG_WARN,
                   ("GetCurrentUserSID: Failed to get Thread Information - %u\n",*pErrorCode));
        }

        hRes = *pErrorCode == ERROR_SUCCESS ? S_OK : E_FAIL;

        CloseHandle(hToken);
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\gdithnk.hpp ===
#ifndef __GDITHNK_HPP__
#define __GDITHNK_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     gdithnk.hpp                                                             
                                                                              
  Abstract:                                                                   
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 19-Jun-2000                                        
     
                                                                             
  Revision History:                                                           
--*/

typedef struct PROXYMSG {
    PORT_MESSAGE    h;
    ULONG           cjIn;
} SPROXYMSG, *PSPROXYMSG;

struct PROXYMSGEXTENSION
{
    ULONG  cjIn;
    PVOID  pvIn;
    ULONG  cjOut;
    PVOID  pvOut;
};
typedef struct PROXYMSGEXTENSION SPROXYMSGEXTENSION , *PSPROXYMSGEXTENSION;

struct PROXY_MSG
{
    PORT_MESSAGE Msg;
    CCHAR        MsgData[ sizeof(SPROXYMSGEXTENSION) ];
};
typedef struct PROXY_MSG SPROXY_MSG , *PSPROXY_MSG;

struct  LPCMSGSTHRDDATA
{
    PVOID  pData;
};
typedef LPCMSGSTHRDDATA SLPCMSGSTHRDDATA,*PSLPCMSGSTHRDDATA;

struct REQUESTTHRDDATA
{
    PVOID    p;
    HANDLE   PortHandle;
};
typedef REQUESTTHRDDATA SREQUESTTHRDDATA,*PSREQUESTTHRDDATA;

HRESULT
GetCurrentUserSID(
       OUT PWSTR*  ppszUserSID,
    IN OUT PDWORD  pErrorCode
    );

EXTERN_C
DWORD
LPCRequestsServingThread(
    PVOID pThrdData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\lddevcap.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation
  All rights reserved.

  Module Name:
     lddevcap.cxx

  Abstract:
     The file contains an array of expected size calculations
     for various DeviceCaps returned by DeviceCapabilites

  Author:
     Khaled Sedky (khaleds) 27 January 2000


  Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>
#include "winddiui.h"

#include <splwow64.h>

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif

//
// This array has a length of DC_NUP. If new capabilites
// are introduced , the array has to be appended by these
// values and functions picking up data from this array
// have to be modified. Something important to note, that
// although this array is 0 based , the capabilites are 1
// based and so whenever indexing in this array subtract 1
//
DWORD DeviceCapsReqSize[MAX_CAPVAL] =
{
     0,                         //DC_FIELDS            1
     sizeof(WORD),              //DC_PAPERS            2
     sizeof(POINT),             //DC_PAPERSIZE         3
     0,                         //DC_MINEXTENT         4
     0,                         //DC_MAXEXTENT         5
     sizeof(WORD),              //DC_BINS              6
     0,                         //DC_DUPLEX            7
     0,                         //DC_SIZE              8
     0,                         //DC_EXTRA             9
     0,                         //DC_VERSION           10
     0,                         //DC_DRIVER            11
     24*sizeof(WCHAR),          //DC_BINNAMES          12
     2*sizeof(LONG),            //DC_ENUMRESOLUTIONS   13
     64*sizeof(WCHAR),          //DC_FILEDEPENDENCIES  14
     0,                         //DC_TRUETYPE          15
     64*sizeof(WCHAR),          //DC_PAPERNAMES        16
     0,                         //DC_ORIENTATION       17
     0,                         //DC_COPIES            18
     0,                         //DC_BINADJUST         19
     0,                         //DC_EMF_COMPLIANT     20
     0,                         //DC_DATATYPE_PRODUCED 21
     0,                         //DC_COLLATE           22
     0,                         //DC_MANUFACTURER      23
     0,                         //DC_MODEL             24
     32*sizeof(WCHAR),          //DC_PERSONALITY       25
     0,                         //DC_PRINTRATE         26
     0,                         //DC_PRINTRATEUNIT     27
     0,                         //DC_PRINTERMEM        28
     64*sizeof(WCHAR),          //DC_MEDIAREADY        29
     0,                         //DC_STAPLE            30
     0,                         //DC_PRINTRATEPPM      31
     0,                         //DC_COLORDEVICE       32
     sizeof(DWORD),             //DC_NUP               33
     64*sizeof(WCHAR),          //DC_MEDIATYPENAMES    34
     sizeof(DWORD),             //DC_MEDIATYPES        35
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\drvevnt.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation
  All rights reserved.

  Module Name:
     drvevnt.cxx

  Abstract:
     This file contains the implementation for the Driver
     Event class

  Author:
     Khaled Sedky (khaleds) 18 January 2000


  Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __DRVEVNT_HPP__
#include "drvevnt.hpp"
#endif

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif


#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif


/* -------------------------------------- */
/* Implemetation of class PrinterEvnetMgr */
/* -------------------------------------- */


/*++
    Function Name:
        TPrinterEventMgr :: TPrinterEventMgr

    Description:
        Constructor of the Printer(Driver) Event object

    Parameters:
        TLoad64BitDllsMgr* : Pointer to the main loader object
                             which manage the process

    Return Value:
        None
--*/
TPrinterEventMgr::
TPrinterEventMgr(
    IN TLoad64BitDllsMgr *pIpLdrObj
    ) :
    m_pLdrObj(pIpLdrObj),
    TClassID("TPrinterEventMgr")
{
    m_pLdrObj->AddRef();
}


/*++
    Function Name:
        TPrinterEventMgr :: ~TPrinterEventMgr

    Description:
        Destructor of the Printer(Driver) Event object

    Parameters:
        None

    Return Value:
        None
--*/
TPrinterEventMgr::
~TPrinterEventMgr(
    VOID
    )
{
    m_pLdrObj->Release();
}


/*++
    Function Name:
        TPrinterEventMgr :: SpoolerPrinterEvent

    Description:
        Calls into the driver DrvPrinterEvent entry point

    Parameters:
        PrinterName  : The name of the printer involved
        PrinterEvent : What happened
        Flags        : Misc. flag bits
       lParam        : Event specific parameters

    Return Value:
        BOOL         : TRUE  in case of success
                     : FALSE in case of failure
--*/
BOOL
TPrinterEventMgr ::
SpoolerPrinterEvent(
    IN  LPWSTR pszPrinterName,
    IN  int    PrinterEvent,
    IN  DWORD  Flags,
    IN  LPARAM lParam,
    OUT PDWORD pErrorCode
    )
{
     HANDLE             hPrinter, hDriver;
     BOOL               ReturnValue=FALSE;
     PFNDRVPRINTEREVENT pfn;
     RPC_STATUS         RpcStatus;

     SPLASSERT(m_pLdrObj);

     if((RpcStatus = RpcImpersonateClient(0)) == RPC_S_OK)
     {
         m_pLdrObj->IncUIRefCnt();
         {
             if (OpenPrinter((LPWSTR)pszPrinterName, &hPrinter, NULL))
             {
                  if(hDriver = LoadPrinterDriver(hPrinter))
                  {
                       if (pfn = (PFNDRVPRINTEREVENT)GetProcAddress(hDriver,
                                                                    "DrvPrinterEvent"))
                       {
                           __try
                           {
                                ReturnValue = (*pfn)( pszPrinterName, PrinterEvent, Flags, lParam );
                           }
                           __except(1)
                           {
                               *pErrorCode = GetExceptionCode();
                           }
                       }
                       else
                       {
                            *pErrorCode = GetLastError();
                       }
                       FreeLibrary(hDriver);
                  }
                  else
                  {
                       *pErrorCode = GetLastError();
                  }
                  ClosePrinter(hPrinter);
             }
             else
             {
                  *pErrorCode = GetLastError();
             }
         }
         m_pLdrObj->DecUIRefCnt();

         RpcStatus = RpcRevertToSelf();
     }
     else
     {
         *pErrorCode = RpcStatus;
     }

     return  ReturnValue;
}


/*++
    Function Name:
        TPrinterEventMgr :: DocumentEvent

    Description:
        Calls into the driver DrvDocumentEvent entry point

    Parameters:
        PrinterName  : The name of the printer involved
        InDC         : The printer DC.
        EscapeCode   : Why this function is called
        InSize,      : Size of the input buffer
        InBuf,       : Pointer to the input buffer
        OutSize,     : Size of the output buffer
        OutBuf,      : Pointer to the output buffer
        ErrorCode    : output Last Error from operation


    Return Value:
        DOCUMENTEVENT_SUCCESS     : success
        DOCUMENTEVENT_UNSUPPORTED : EscapeCode is not supported
        DOCUMENTEVENT_FAILURE     : an error occured
--*/
int
TPrinterEventMgr ::
DocumentEvent(
    IN  LPWSTR      pszPrinterName,
    IN  ULONG_PTR   InDC,
    IN  int         EscapeCode,
    IN  DWORD       InSize,
    IN  LPBYTE      pInBuf,
    OUT PDWORD      pOutSize,
    OUT LPBYTE      *ppOutBuf,
    OUT PDWORD      pErrorCode
    )
{
     HANDLE              hPrinter, hDriver;
     int                 ReturnValue=0;
     PFNDRVDOCUMENTEVENT pfn;
     HDC                 hDC = reinterpret_cast<HDC>(InDC);
     RPC_STATUS          RpcStatus              ;

     SPLASSERT(m_pLdrObj);

     if((RpcStatus = RpcImpersonateClient(0)) == RPC_S_OK)
     {
         m_pLdrObj->IncUIRefCnt();
         {
             if (OpenPrinter((LPWSTR)pszPrinterName, &hPrinter, NULL))
             {
                  if(hDriver = LoadPrinterDriver(hPrinter))
                  {
                       if (pfn = (PFNDRVDOCUMENTEVENT)GetProcAddress(hDriver,
                                                                     "DrvDocumentEvent"))
                       {
                           __try
                           {
                               ULONG cbOut = sizeof(ULONG);
                               PDEVMODEW pOut = NULL;
                               ReturnValue = (*pfn)( hPrinter,
                                                     (HDC)InDC,
                                                     EscapeCode,
                                                     (ULONG)InSize,
                                                     (PVOID)pInBuf,
                                                     cbOut,
                                                     (PVOID)&pOut);
                               if(ReturnValue != -1 &&
                                  pOut)
                               {
                                   *pOutSize = pOut->dmSize + pOut->dmDriverExtra;
                                   if(*ppOutBuf  = new BYTE[*pOutSize])
                                   {
                                        memcpy(*ppOutBuf,pOut,*pOutSize);
                                   }
                                   else
                                   {
                                        *pErrorCode = ERROR_OUTOFMEMORY;
                                   }
                                   //
                                   // Now what should I do about the memory allocated
                                   // for pOut ????
                                   //
                               }
                            }
                            __except(1)
                            {
                                SetLastError(GetExceptionCode());
                            }

                       }

                       FreeLibrary(hDriver);

                  }
                  else
                  {
                      *pErrorCode = GetLastError();
                  }

                  ClosePrinter(hPrinter);
             }
             else
             {
                 *pErrorCode = GetLastError();
             }
         }
         m_pLdrObj->DecUIRefCnt();

         RpcStatus = RpcRevertToSelf();
     }
     else
     {
         *pErrorCode = RpcStatus;
     }

     return  ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\collmgr.hpp ===
#ifndef __COLLMGR_HPP__
#define __COLLMGR_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     collmgr.hpp                                                             
                                                                              
  Abstract:                                                                   
    This file contains the declaration of a generic
    linked list which could encapsulate any data type
    even if complex ones. The list is defined as a 
    manager and a node. The manager manages the given
    nodes of that type.
                                                                                       
  Author:                                                                     
     Khaled Sedky (khaleds) 21-Jun-2000                                        
     
                                                                             
  Revision History:            
--*/

#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif


//
// Forward Declarations
//
template <class E,class C> class TLstNd;
template <class E,class C> class TLstMgr;

//
//  E here is the element and C is a major content in this element.
//  or in other words the index of the element . It could be described
//  as the component by which the element is created or by which it
//  is compared against.C is the type used as a key for comparisons.
//

template <class E,class C> class TLstNd
{
    //
    // Public methods of the class
    //
    public:

    friend class TLstMgr<E,C>;

    TLstNd<E,C>(
        VOID
        );

    //
    // Copy Constructor
    //
    TLstNd<E,C>(
        IN CONST TLstNd<E,C>&
        );

    //
    // Copy constructor based on the Element saved 
    // in the list
    //
    TLstNd<E,C>(
        IN const E&
        );

    TLstNd<E,C>(
        IN E*
        );

    //
    // A Copy constructor based on the 
    // component
    //
	TLstNd<E,C>(
		IN const C&
		);

    ~TLstNd<E,C>(
        VOID 
        );

    const E& 
    operator=(
        IN const E&
        );

    BOOL 
    operator==(
        IN const E&
        ) const; 

    BOOL 
    operator==(
        IN const C&
        ) const; 
    
    E&
    operator*(
        VOID
        );

	E*
	SetNodeData(
		IN E*
		);

    //
    // Private members and helper functions (if any)
    //
    private:
    E*            m_pD;
    TLstNd<E,C>   *m_pNext;
    TLstNd<E,C>   *m_pPrev;
};


template <class E,class C> class TLstMgr :  public TClassID,
                                            public TLd64BitDllsErrorHndlr
{
    //
    // Public methods of the class
    //
    public:

    friend TLstNd<E,C>;

    //
    // To optimize the overhead of allocating
    // and Freeing memroy , the user of this
    // class might resort to using the FreeList
    // support which enable him to recycle nodes 
    // when they are not longer required.
    //
    enum EListType
    {
        KFreeListSupport,
        KNoFreeListSupport,
    };

    //
    // Based on the index of the collection, Entries,
    // maybe or may not be unique. Based on this Flag
    // being set in the constructor, the List search
    // criteria is decided and so is the Appending 
    // algorithm
    //
    enum EEntriesType
    {
        KUniqueEntries    = 0,
        KNonUniqueEntries
    };

    TLstMgr<E,C>(
        IN      typename TLstMgr<E,C>::EEntriesType ThisListEntriesType = TLstMgr<E,C>::KNonUniqueEntries,
        IN      typename TLstMgr<E,C>::EListType    ThisListType        = TLstMgr<E,C>::KNoFreeListSupport,
        IN OUT  HRESULT*                   hRes                = NULL
        );
    
    ~TLstMgr<E,C>(
        VOID
        );

    TLstNd<E,C>* 
    AppendListByElem(
        IN const E&
        );

    TLstNd<E,C>* 
    AppendListByElem(
        IN E*
        );

    TLstNd<E,C>* 
    AppendListByElem(
	    IN const C &
        );

    HRESULT
    RmvElemFromList(
        IN const E&
        );
	
	HRESULT
	RmvElemFromList(
		IN const C&
		);


	HRESULT 
	RmvElemAtPosFromList(
		IN DWORD 
		);


    HRESULT
    RmvTail(
        VOID
        );

    HRESULT
    RmvHead(
        VOID
        );

    HRESULT
    DestructList(
        VOID
        );

    E&
    GetElementAtPos(
        IN DWORD 
        ) const;

    E*
    GetElementAtPosByRef(
        IN DWORD 
        ) const;

    E&
    operator[](
        IN DWORD
        ) const;

	TLstNd<E,C>*
    ElementInList(
        IN const C&
        ) const;

    BOOL 
    HaveElements(
        VOID
        ) const;

    DWORD
    GetNumOfListNodes(
        VOID
        ) const;

    
    //
    // Private members and helper functions (if any)
    //
    private:

    TLstNd<E,C>      *m_pHead;
    TLstNd<E,C>      *m_pTail;
    DWORD            m_cNumOfNodes;
    BOOL             m_bUnique;
    //
    // To protect the linked list data members
    // in a multithread environment.
    //
    CRITICAL_SECTION *m_pLockSem;
};


template <class E,class C> class TLstItrtr : public TClassID
{
    public:

    TLstItrtr<E,C>(
        IN const TLstMgr<E,C>&
        );

    ~TLstItrtr<E,C>();

    TLstNd<E,C>&
    operator*(
        VOID             
        );

    TLstNd<E,C>&
    operator++(
        VOID             
        );

    const
    TLstNd<E,C>
    operator++(
        int
        );

    TLstNd<E,C>&
    operator--(
        VOID             
        );

    const
    TLstNd<E,C>
    operator--(
        int
        );
    
    private:
    TLstMgr<E,C>    *m_pItrtdMgrPrxy;
    TLstNd<E,C>     *m_pCrntNode;
};


//
// This is an abstract class which never 
// get instantiated. Any Element other than
// primitive Data types , has to inherit from
// this class . There are some mandatory
// methods that need to be implemented
//

class TGenericElement : public TRefCntMgr
{
	public:
    //
    // A BOOL variable indicating Validity
    // of the object should be defined here.
    // This should be set by SetValidity and
    // queried by Validate.
    //
	TGenericElement()
    {};

    //
    // We internally create the elements in
    // the list to be independent of the client
    // and that is when we call the equal operator
    //
/*    virtual const TGenericElement&
    operator=(
        IN const TGenericElement&
	   );

    //
    // Since many of the interfaces supplied by the
    // List Manager rely on comparisons between the
    // internally maintained elements , so we need 
    // an == opoperator and a ! operator.
    //
    virtual BOOL 
    operator==(
        IN const TGenericElement&
	   ) const;

    virtual BOOL
    operator!(
        VOID
        ) const;*/

    //
    // Some times we might return a dummy invalid 
    // element to invalidate the result of a list
    // manager method
    //
    virtual VOID 
    SetValidity(
        IN DWORD
        ) = 0;

    virtual BOOL
    Validate(
        VOID
        ) const = 0;
};

//
// Since our iimplementation of C++ does not have a #pragma implementation , 
// so I am including the implementation file directly in the header file
//
#include "collmgr.cxx"

#endif //__COLLMGR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\collmgr.cxx ===
#ifdef __COLLMGR_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     collmgr.cxx                                                             
                                                                              
  Abstract:                                                                   
    This file contains the declaration of a generic
    linked list which could encapsulate any data type
    even if complex ones. The list is defined as a 
    manager and a node. The manager manages the given
    nodes of that type.
                                                                                       
  Author:                                                                     
     Khaled Sedky (khaleds) 21-Jun-2000                                       
     
                                                                             
  Revision History:            
--*/


/**********************************/
/*  List Manager Implementation   */
/**********************************/


template <class E,class C>
TLstMgr<E,C> ::
TLstMgr(
    IN     EEntriesType ThisListEntriesType,
    IN     EListType    ThisListType,
    IN OUT HRESULT                    *hRes
    ) : 
    m_pHead(NULL),
    m_pTail(NULL),
    m_cNumOfNodes(0),
    m_bUnique(ThisListEntriesType==TLstMgr<E,C>::KUniqueEntries ? TRUE : FALSE),
    TClassID("TLstMgr")
{

    HRESULT  hLocalRes = S_OK;

    __try
    {
        if(m_pLockSem = new CRITICAL_SECTION)
        {
            //
            // Do we need an exception handler here
            //
            ::InitializeCriticalSection(m_pLockSem);
            ::SetLastError(ERROR_SUCCESS);
        }
        else 
        {
            hLocalRes = GetLastErrorAsHRESULT();
        }
    }
    __except(1)
    {

              hLocalRes = GetLastErrorAsHRESULT(TranslateExceptionCode(::GetExceptionCode()));
    }

    if(hRes)
    {
         *hRes = hLocalRes;
    }
}


template <class E,class C>
TLstMgr<E,C> ::
~TLstMgr(
    VOID
    )
{
    EnterCriticalSection(m_pLockSem);
    {
        DestructList();
        m_cNumOfNodes = 0;
        m_pHead = m_pTail = NULL;
        LeaveCriticalSection(m_pLockSem);
    }
    DeleteCriticalSection(m_pLockSem);

    delete m_pLockSem;
}


template <class E,class C>
HRESULT
TLstMgr<E,C> ::
DestructList(
    VOID
    )
{
	TLstNd<E,C> *pNode;

    for(pNode=m_pHead;
        pNode;
        pNode = m_pHead)
    {
        SPLASSERT(pNode);
        m_pHead = pNode->m_pNext;
        delete pNode;
    }

	return S_OK;
}


template <class E,class C>
E&
TLstMgr<E,C> ::
operator[](
    IN DWORD Index
    ) const
{
	TLstNd<E,C> *pNode;
	E           *ClonedElement;

    //
    // In case the element is not found
    //
    ClonedElement = NULL;

    EnterCriticalSection(m_pLockSem);
    {
        if(m_cNumOfNodes && 
           Index >= 0    && 
           Index <= (m_cNumOfNodes-1))
        {
            DWORD InternalIndex = 0;

            for(pNode = m_pHead;
                (pNode &&
                (InternalIndex <= Index));
                pNode = pNode->m_pNext,
                InternalIndex ++)
            {
                ClonedElement = *pNode;
            }
        }
    }
    LeaveCriticalSection(m_pLockSem);

	return *ClonedElement;
}


template <class E,class C>
TLstNd<E,C> *
TLstMgr<E,C> ::
ElementInList(
    const C &ToCompare
    ) const
{
    TLstNd<E,C> *pNode = NULL;

    EnterCriticalSection(m_pLockSem);
    {
        if(m_cNumOfNodes)
        {
            for(pNode = m_pHead;
                (pNode && !(*(*(pNode)) == ToCompare)); 
                pNode = pNode->m_pNext)
            {
                //
                // There is really nothing to do, just
                // return the Node
                //
            }
        }
    }
    LeaveCriticalSection(m_pLockSem);

    return pNode;
}


template <class E,class C>
TLstNd<E,C>* 
TLstMgr<E,C> ::
AppendListByElem(
	IN const E &Element
    )
{
    TLstNd<E,C> *pNode = new TLstNd<E,C>(Element);

	EnterCriticalSection(m_pLockSem);
    {
        if(pNode)
        {
            if(!m_cNumOfNodes)
            {
                //
                // The list is empty
                //
                m_pHead = m_pTail = pNode;
                m_pHead->m_pNext  = NULL;
                m_pTail->m_pPrev  = NULL;
            }
            else
            {
                //
                // The list has one or more Elements
                //
                m_pTail->m_pNext = pNode;
                pNode->m_pPrev   = m_pTail;
                m_pTail	         = pNode;
            }
            m_cNumOfNodes ++;
        }
    }
	LeaveCriticalSection(m_pLockSem);

	return pNode;
}

template <class E,class C>
TLstNd<E,C>* 
TLstMgr<E,C> ::
AppendListByElem(
	IN E *Element
    )
{
    TLstNd<E,C> *pNode = new TLstNd<E,C>(Element);
	
    EnterCriticalSection(m_pLockSem);
    {
        if(pNode)
        {
            if(!m_cNumOfNodes)
            {
                //
                // The list is empty
                //
                m_pHead = m_pTail = pNode;
                m_pHead->m_pNext  = NULL;
                m_pTail->m_pPrev  = NULL;
            }
            else
            {
                //
                // The list has one or more Elements
                //
                m_pTail->m_pNext = pNode;
                pNode->m_pPrev   = m_pTail;
                m_pTail	         = pNode;
            }
            m_cNumOfNodes ++;
        }
        if(pNode)
            (*(*(pNode))).AddRef();
    }
    LeaveCriticalSection(m_pLockSem);

	return pNode;
}



template <class E,class C>
TLstNd<E,C>*
TLstMgr<E,C> ::
AppendListByElem(
	IN const C &ElementMember
    )
{
	TLstNd<E,C> *pNode;

	SetLastError(ERROR_SUCCESS);

	EnterCriticalSection(m_pLockSem);
    {
        if(!m_bUnique ||
           !(pNode = ElementInList(ElementMember)))
        {
            pNode = new TLstNd<E,C>(ElementMember);

            if(pNode)
            {
                if(!m_cNumOfNodes)
                {
                    //
                    // The list is empty
                    //
                    m_pHead = m_pTail = pNode;
                    m_pHead->m_pNext  = NULL;
                    m_pTail->m_pPrev  = NULL;
                }
                else
                {
                    //
                    // The list has one or more Elements
                    //
                    m_pTail->m_pNext = pNode;
                    pNode->m_pPrev   = m_pTail;
                    m_pTail	         = pNode;
                }
                m_cNumOfNodes ++;
            }
        }

        if(pNode)
            (*(*(pNode))).AddRef();
    }
	LeaveCriticalSection(m_pLockSem);

	return pNode;
}


template<class E,class C>
HRESULT
TLstMgr<E,C> ::
RmvElemFromList(
	IN const E &Element
    )
{
    HRESULT     hRes;
	TLstNd<E,C> *pNode = NULL;

    EnterCriticalSection(m_pLockSem);
    {
        if(m_cNumOfNodes)
        {
            //
            // Is this the last element in the List
            //
            if(m_pTail && *m_pTail == Element)
            {
                pNode   = m_pTail;
                m_pTail = m_pTail->m_pPrev;
                if(m_pTail)
                {
                    m_pTail->m_pNext = NULL;
                }
            }
            else if(m_pHead && *m_pHead == Element)
            {
                pNode   = m_pHead;
                m_pHead = m_pHead->m_pNext;
                if(m_pHead)
                {
                    m_pHead->m_pPrev = NULL;
                }
            }
            else
            {
                for(pNode = m_pHead->m_pNext;
                    (pNode &&
                    !(*pNode == Element));
                    pNode = pNode->m_pNext)
                {
                    //
                    // Nothing , we just want to find the 
                    // target node.
                    //
                }
                if(pNode)
                {
                    pNode->m_pPrev->m_pNext = pNode->m_pNext;
                    pNode->m_pNext->m_pPrev = pNode->m_pPrev;
                }
            }
        }
        if(pNode)
        {
            if(!--m_cNumOfNodes)
            {
                m_pHead = m_pTail = NULL;
            }

            delete pNode;
            hRes = S_OK;
        }
        else
        {
            //
            // If we reach this stage then the element 
            // in the list { May be a better error code
            // should be returned TBD}
            //
            hRes = E_INVALIDARG; 
        }
    }
    LeaveCriticalSection(m_pLockSem);

	return hRes;
}


template<class E,class C>
HRESULT
TLstMgr<E,C> ::
RmvElemFromList(
	IN const C &ElementMember
    )
{
	HRESULT hRes;
	if(!m_bUnique)
	{
        //
        // In case of nonunique entries, we cann't really
        // perform the operation.
        // Are we going to DecRef only... I guess the way
        // it is now is better.
        //
		hRes = E_NOINTERFACE;
	}
	else
	{
		TLstNd<E,C> *pNode = NULL;

		EnterCriticalSection(m_pLockSem);
        {
            if(m_cNumOfNodes)
            {
                //
                // Is this the last element in the List
                //
                if(m_pTail && *m_pTail == ElementMember)
                {
                    pNode = m_pTail;
                }
                else if(m_pHead && *m_pHead == ElementMember)
                {
                    pNode = m_pHead;
                }
                else
                {
                    for(pNode = m_pHead->m_pNext;
                        (pNode &&
                        !(*pNode == ElementMember));
                        pNode = pNode->m_pNext)
                    {
                        // 
                        // Nothing except detecting the
                        // required node
                        //
                    }
                }
            }
            if(pNode)
            {
                if(!(*(*pNode)).Release())
                {
                    //
                    // We have to do this in order to prevent deleting the
                    // data if it was already deleted in the release;
                    //
                    pNode->SetNodeData(static_cast<E*>(NULL));
                    if(pNode == m_pTail)
                    {
                        m_pTail = m_pTail->m_pPrev;

                        if(m_pTail)
                        {
                            m_pTail->m_pNext = NULL;
                        }
                    }
                    else if(m_pHead == pNode)
                    {
                        m_pHead = m_pHead->m_pNext;

                        if(m_pHead)
                        {
                            m_pHead->m_pPrev = NULL;
                        }
                    }
                    else
                    {
                        pNode->m_pPrev->m_pNext = pNode->m_pNext;
                        pNode->m_pNext->m_pPrev = pNode->m_pPrev;
                    }
                    delete pNode;
                    if(!--m_cNumOfNodes)
                    {
                        m_pHead = m_pTail = NULL;
                    }
                    hRes = S_OK;
                }
            }
            else
            {
                //
                // If we reach this stage then the element 
                // in the list { May be a better error code
                // should be returned TBD}
                //
                hRes = E_INVALIDARG; 
            }
        }
		LeaveCriticalSection(m_pLockSem);
	}
	return hRes;
}


template <class E,class C>
HRESULT 
TLstMgr<E,C> ::
RmvElemAtPosFromList(
    IN DWORD Index
	)
{
	TLstNd<E,C> *pNode = NULL;
    HRESULT     hRes;    

    EnterCriticalSection(m_pLockSem);
    {
        if(m_cNumOfNodes && 
           Index >= 0    && 
           Index <= (m_cNumOfNodes-1))
        {
            //
            // Is this the last element in the List
            //
            if(Index == 0)
            {
                pNode   = m_pTail;
                m_pTail = m_pTail->m_pPrev;
                if(m_pTail)
                {
                    m_pTail->m_pNext = NULL;
                }
            }
            else if(Index == (m_cNumOfNodes-1))
            {
                pNode   = m_pHead;
                m_pHead = m_pHead->m_pNext;
                if(m_pHead)
                {
                    m_pHead->m_pPrev = NULL;
                }
            }
            else
            {
                DWORD InternalIndex = 1;

                for(pNode = m_pHead->m_pNext;
                    (pNode &&
                    (InternalIndex < Index));
                    pNode = pNode->m_pNext,
                    InternalIndex ++)
                {
                    //
                    // Nothing but detect the node
                    //
                }
                if(pNode)
                {
                    Temp->m_pPrev->m_pNext = pNode->m_pNext;
                    Temp->m_pNext->m_pPrev = pNode->m_pPrev;
                }
            }
        }
        if(pNode)
        {
            if(!--m_cNumOfNodes)
            {
                m_pHead = m_pTail = NULL;
            }

            delete pNode;
            hRes = S_OK;
        }
        else
        {
            //
            // If we reach this stage then the element 
            // is not in the list { May be a better 
            // error code should be returned TBD}
            //
            hRes = E_INVALIDARG; 
        }
    }
    LeaveCriticalSection(m_pLockSem);
	return hRes;
}


template <class E,class C>
HRESULT
TLstMgr<E,C> ::
RmvHead(
    VOID
    )
{
    return RmvElemAtPosFromList(0);
}


template <class E,class C>
HRESULT
TLstMgr<E,C> ::
RmvTail(
    VOID
    )
{
    return RmvElemAtPosFromList((m_cNumOfNodes-1));
}


template <class E,class C>
BOOL
TLstMgr<E,C> ::
HaveElements(
    VOID
    ) const
{
    return !!m_cNumOfNodes;
}


template <class E,class C>
DWORD
TLstMgr<E,C> ::
GetNumOfListNodes(
    VOID
    ) const
{
    return m_cNumOfNodes;
}


/********************************/
/*   List Node Implementation   */
/********************************/


template <class E,class C>
TLstNd<E,C> ::
TLstNd() :
	m_pPrev(NULL) ,
	m_pNext(NULL) 
{
    m_pD = new E;
}


template <class E,class C>
TLstNd<E,C> ::
TLstNd(
    IN const TLstNd<E,C> &N
    ) :
    m_pPrev(N.m_pPrev),
    m_pNext(N.m_pNext)
{
    m_pD = new E(N.D);
}


template <class E,class C>
TLstNd<E,C> ::
TLstNd(
	IN const E &Element
    ) :
	m_pPrev(NULL),
	m_pNext(NULL)
{
    m_pD = new E(Element);
}

template <class E,class C>
TLstNd<E,C> ::
TLstNd(
	IN E *Element
    ) :
	m_pPrev(NULL),
	m_pNext(NULL)
{
    m_pD = Element;
}



template <class E,class C>
TLstNd<E,C> ::
TLstNd(
	IN const C &ElementMember
    ) :
	m_pPrev(NULL),
	m_pNext(NULL)
{
    m_pD = new E(ElementMember);
}


template <class E,class C>
TLstNd<E,C> ::
~TLstNd()
{
    //
    // Implicitly the destructor for 
    // the maintained element would be 
    // called
    //
	if(m_pD)
    {
		delete m_pD;
    }
}


template <class E,class C>
const E&
TLstNd<E,C> ::
operator=(
    IN const E &Element
    )
{
    if(this->m_pD != &Element)
    {
        *m_pD = Element;
    }

    return *(this->m_pD);
}


template <class E,class C>
BOOL 
TLstNd<E,C> ::
operator==(
    IN const E &Element
    ) const
{
    return *m_pD == Element;
}


template <class E,class C>
BOOL
TLstNd<E,C> ::
operator==(
    const C &ToCompare
    ) const
{
    return *m_pD == ToCompare;
}


template <class E,class C>
E&
TLstNd<E,C> ::
operator*()
{
    return *m_pD;
}


template <class E,class C>
E*
TLstNd<E,C> ::
SetNodeData(
	IN E *pNewD
	)
{
	//
	// In some cases where the data is ref counted
	// it might be a good idea to Nullify this pointer
	// once the data ref reaches 0 (as this implies)
	// that it was deleted. No need to delete it once
	// more. We also return a pointer to the old node
	// data
	//
	E *pOldD = m_pD;

	m_pD = pNewD;

	return pOldD;
}

#endif //__COLLMGR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\lderror.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     lderror.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the methods and class implementation 
     necessary for the RPC surrogate used to load 64 bit dlls from
     within 32 bit apps.
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

LONG ErrorMap[] = {
                    STATUS_INVALID_PARAMETER,             ERROR_INVALID_PARAMETER,
                    STATUS_INVALID_PORT_ATTRIBUTES,       ERROR_INVALID_PARAMETER,
                    STATUS_OBJECT_PATH_INVALID,           ERROR_BAD_PATHNAME,
                    STATUS_OBJECT_PATH_NOT_FOUND,         ERROR_PATH_NOT_FOUND,
                    STATUS_OBJECT_PATH_SYNTAX_BAD,        ERROR_BAD_PATHNAME,
                    STATUS_OBJECT_NAME_INVALID,           ERROR_INVALID_NAME,
                    STATUS_OBJECT_NAME_COLLISION,         ERROR_ALREADY_EXISTS,
                    STATUS_NO_MEMORY,                     ERROR_NOT_ENOUGH_MEMORY
                  };


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: TLd64BitDllsErrorHndlr
     
    Description:
        Constructor of Error Handler object. 
             
     Parameters:
        None
        
     Return Value:
        None
--*/

TLd64BitDllsErrorHndlr ::
TLd64BitDllsErrorHndlr(
    VOID
    )
{
}


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: ~TLd64BitDllsErrorHndlr
     
    Description:
        Destructor of Error Handler object. 
             
     Parameters:
        None
        
     Return Value:
        None
--*/
TLd64BitDllsErrorHndlr ::
~TLd64BitDllsErrorHndlr(
    VOID
    )
{
}


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: GetLastErrorAsHRESULT
     
    Description:
        Converts GetLastError to HRESULT. 
             
     Parameters:
        None
        
     Return Value:
        HRESULT : LastError as HRESULT
--*/
HRESULT
TLd64BitDllsErrorHndlr ::
GetLastErrorAsHRESULT(
    VOID
    ) const
{
    DWORD Error = GetLastError();

    return HRESULT_FROM_WIN32(Error);
}


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: GetLastErrorAsHRESULT
     
    Description:
        Converts Input Win32 Error Code to HRESULT. 
             
     Parameters:
        DWORD : Win32 ErrorCode
        
     Return Value:
        HRESULT : Win32 ErrorCode as HRESULT
--*/
HRESULT 
TLd64BitDllsErrorHndlr ::
GetLastErrorAsHRESULT(
    IN DWORD Error
    ) const
{
    return HRESULT_FROM_WIN32(Error);
}


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: GetLastErrorFromHRESULT
     
    Description:
        Converts HRESULT to Win32 Error Code. 
             
     Parameters:
        HRESULT : hResult Code
        
     Return Value:
        DWORD : hResult converted to Win32 ErrorCode
--*/
DWORD 
TLd64BitDllsErrorHndlr ::
GetLastErrorFromHRESULT(
    IN HRESULT hRes
    ) const
{
    return HRESULTTOWIN32(hRes);
}


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: TranslateExceptionCode
     
    Description:
        Filters Exception Codes 
        
     Parameters:
        None
        
     Return Value:
        DWORD: Filtered Exception Code.
--*/
DWORD
TLd64BitDllsErrorHndlr ::
TranslateExceptionCode(
    IN DWORD ExceptionCode
    ) const
{
    DWORD TranslatedException;

    switch (ExceptionCode)
    {
        case EXCEPTION_ACCESS_VIOLATION:
        case EXCEPTION_DATATYPE_MISALIGNMENT:
        case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
        case EXCEPTION_FLT_DENORMAL_OPERAND:
        case EXCEPTION_FLT_DIVIDE_BY_ZERO:
        case EXCEPTION_FLT_INEXACT_RESULT:
        case EXCEPTION_FLT_INVALID_OPERATION:
        case EXCEPTION_FLT_OVERFLOW:
        case EXCEPTION_FLT_STACK_CHECK:
        case EXCEPTION_FLT_UNDERFLOW:
        case EXCEPTION_INT_DIVIDE_BY_ZERO:
        case EXCEPTION_INT_OVERFLOW:
        case EXCEPTION_PRIV_INSTRUCTION:
        case ERROR_NOACCESS:
        case RPC_S_INVALID_BOUND:
        {
            TranslatedException = ERROR_INVALID_PARAMETER;
            break;
        }

        default:
        {
            TranslatedException = ExceptionCode;
            break;
        }
    }

    return TranslatedException;
}


/*++
    Function Name:
        TLd64BitDllsErrorHndlr :: MapNtStatusToWin32Error
     
    Description:
        Converts NtStatus results to Win32 Error Codes 
        
     Parameters:
        NTSTATUS: NtStatus result
        
     Return Value:
        DWORD: Win32 Error Code.
--*/
DWORD
TLd64BitDllsErrorHndlr ::
MapNtStatusToWin32Error(
    IN NTSTATUS Status
    ) const
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;

    for (int cNumOfMapEntries = 0;
         cNumOfMapEntries < sizeof(ErrorMap) / sizeof(ErrorMap[0]); 
         cNumOfMapEntries += 2)
    {
        if (ErrorMap[cNumOfMapEntries] == Status)
        {
            ErrorCode = ErrorMap[cNumOfMapEntries+1];
        }
    }

    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\lderror.hpp ===
#ifndef __LDERROR_HPP__
#define __LDERROR_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     lderror.hpp                                                             
                                                                              
  Abstract:                                                                   
     This is a common class declaration which could be used by 
     all classes for translating between differnet Error codes , 
     as those genarated from Win32 , vs those genarated from 
     RPC vesrus those genarated from COM Interfaces
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
--*/

#define HRESULTTOWIN32(hres)                         \
        ((HRESULT_FACILITY(hres) == FACILITY_WIN32)  \
        ? HRESULT_CODE(hres)                         \
        : (hres))



class TLd64BitDllsErrorHndlr
{
     public:

     TLd64BitDllsErrorHndlr(
         VOID
         );

     ~TLd64BitDllsErrorHndlr(
         VOID
         );
 
     HRESULT
     GetLastErrorAsHRESULT(
         VOID
         ) const;
 
     HRESULT
     GetLastErrorAsHRESULT(
         DWORD Error
         ) const;

     DWORD 
     GetLastErrorFromHRESULT(
         IN HRESULT hRes
         ) const;
 
     DWORD
     TranslateExceptionCode(
         IN DWORD ExceptionCode
         ) const;

     DWORD
     MapNtStatusToWin32Error(
         IN NTSTATUS Status
         ) const;
};
      
                 
#endif //__LDERROR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\ldfuncs.hpp ===
#ifndef __LDFUNCS_HPP__
#define __LDFUNCS_HPP__

#include <wingdip.h>

typedef 
BOOL 
(WINAPI *PFNMONITORFNS)(
    PCWSTR,
    HWND,
    PCWSTR
    );

typedef 
BOOL 
(WINAPI *PFNMONITORADD)(
    PCWSTR,
    HWND,
    PCWSTR,
    PWSTR*
    );

typedef 
int 
(FAR WINAPI *INT_FARPROC)(
    HANDLE,
    PWSTR,
    WORD,
    PVOID,
    PDEVMODE
    );

typedef 
ULONG 
(*PFNGDIPRINTERTHUNKPROC)(
    UMTHDR*,
    PVOID,
    ULONG
    );

typedef 
VOID 
(FAR WINAPI *PFNPRINTUIMETHOD)(
    HWND,
    LPCWSTR,
    INT,
    LPARAM
    );

typedef 
BOOL 
(FAR WINAPI *PFNDRVPRINTEREVENT)(
    LPWSTR,
    int,
    DWORD,
    LPARAM
    );

typedef 
INT 
(FAR WINAPI *PFNDRVDOCUMENTEVENT)(
    HANDLE,
    HDC,
    INT,
    ULONG,
    PVOID,
    ULONG,
    PVOID
    );

typedef 
LONG 
(FAR WINAPI *PFNDOCPROPSHEETS)(
    PPROPSHEETUI_INFO  pCPSUIInfo,
    LPARAM             lParam
    );

typedef 
LONG 
(FAR WINAPI *PFNDEVICEPROPSHEETS)(
    PPROPSHEETUI_INFO  pCPSUIInfo,
    LPARAM             lParam
    );

typedef 
LONG 
(FAR WINAPI *PFNCALLCOMMONPROPSHEETUI)(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );

typedef 
LONG 
(FAR WINAPI *PFNPRINTUIDOCUMENTPROPERTIES)(
    HWND,
    HANDLE,
    LPWSTR,
    PDEVMODE,
    PDEVMODE,
    DWORD,
    DWORD
    );

typedef
BOOL
(FAR WINAPI *PFNPRINTUIPRINTERSETUP)(
    HWND,    
    UINT,    
    UINT,    
    LPWSTR,  
    UINT*,   
    LPCWSTR
    );

LONG
DocumentPropertySheets(
    IN PPROPSHEETUI_INFO   pCPSUIInfo,
    IN LPARAM              lParam
    );

EXTERN_C
DWORD
GDIThunkingVIALPCThread(
    IN PVOID pData
    );

enum EPortOp
{
    KConfigurePortOp = 0,
    KDeletePortOp,
    KAddPortOp
};

struct SGDITHNKTHRDDATA
{
    ULONG_PTR*  pData;
    HANDLE      hEvent;
    DWORD       ErrorCode;
};
typedef struct SGDITHNKTHRDDATA SGDIThnkThrdData,*PSGDIThunkThrdData;

#endif //__LDFUNCS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\ldintrfcs.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldintrfcs.cpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the GUIDs of all interfaces supported
     by the main DLL loader
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 10-Feb-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

// {59A523A7-8C39-4d5c-B519-62F820E66992}
GUID IID_PRINTEREVENT = {0x59a523a7, 
                         0x8c39,
                         0x4d5c,
                         0xb5,
                         0x19,
                         0x62,
                         0xf8,
                         0x20,
                         0xe6,
                         0x69,
                         0x92};

// {D85AE507-5A73-4de9-AA5E-745946BB9509}
GUID IID_PRINTERCONFIGURATION = {0xd85ae507, 
                                 0x5a73,
                                 0x4de9,
                                 0xaa,
                                 0x5e,
                                 0x74,
                                 0x59,
                                 0x46,
                                 0xbb,
                                 0x95,  
                                 0x9};

// {AE96B291-33AD-48bb-8E24-B5902521E34D}
GUID IID_DEVICECAPABILTIES = {0xae96b291,
                              0x33ad,
                              0x48bb,
                              0x8e,
                              0x24,
                              0xb5,
                              0x90,
                              0x25,
                              0x21,
                              0xe3,
                              0x4d};

// {AC8F3E18-FF99-4019-8403-402D83E23B70}
GUID IID_PORTOPERATIONS = {0xac8f3e18,
                           0xff99,
                           0x4019,
                           0x84,
                           0x3,
                           0x40,
                           0x2d,
                           0x83,
                           0xe2,
                           0x3b,
                           0x70};

// {D027CC13-04DE-4379-B072-EB4F8E59AB7A}
GUID IID_DRIVEREVENT={0xd027cc13,
                      0x4de,
                      0x4379,
                      0xb0,
                      0x72,
                      0xeb,
                      0x4f,
                      0x8e,
                      0x59,
                      0xab,
                      0x7a};

// {DDDE8870-322F-405c-B672-67B55F50377B}
GUID IID_PRINTUIOPERATIONS = {0xddde8870,
                              0x322f,
                              0x405c,
                              0xb6,  
                              0x72,  
                              0x67,  
                              0xb5,  
                              0x5f,  
                              0x50,  
                              0x37,  
                              0x7b}; 

// {A5DF592C-C7B0-4793-82CE-BE96B743B33E}
GUID IID_LPCMGR = {0xa5df592c, 
                   0xc7b0, 
                   0x4793, 
                   0x82, 
                   0xce, 
                   0xbe, 
                   0x96, 
                   0xb7, 
                   0x43, 
                   0xb3,
                   0x3e};

// {91F04F3A-C3F8-4f1b-91E2-6D6411914A2E}
GUID IID_PRINTUIPRINTERSETUP = {0x91f04f3a,
                                0xc3f8,
                                0x4f1b,
                                0x91, 
                                0xe2,
                                0x6d,
                                0x64,
                                0x11,
                                0x91,
                                0x4a,
                                0x2e};

// {91F04F3A-C3F8-4f1b-91E2-6D6411914A2E}
GUID IID_PRINTUISERVERPROPPAGES = {0x91f04f3a,
                                   0xc3f8, 
                                   0x4f1b, 
                                   0x91, 
                                   0xe2, 
                                   0x6d, 
                                   0x64, 
                                   0x11, 
                                   0x91, 
                                   0x4a, 
                                   0x2e};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\ldintrfcs.hpp ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldintrfcs.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the GUIDs of all the Interfaces supported
     by the surrogate process
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 10-Feb-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/


#ifndef __LDINTERFACES_HPP__
#define __LDINTERFACES_HPP__

                             
extern GUID IID_PRINTEREVENT;
extern GUID IID_PRINTERCONFIGURATION;                             
extern GUID IID_DEVICECAPABILTIES;
extern GUID IID_PORTOPERATIONS;
extern GUID IID_DRIVEREVENT;
extern GUID IID_PRINTUIOPERATIONS;
extern GUID IID_LPCMGR;
extern GUID IID_PRINTUIPRINTERSETUP;
extern GUID IID_PRINTUISERVERPROPPAGES;

#endif //__LDINTERFACES_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\ldfuncs.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldfuncs.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the implementation of all the RPC methods 
     supported by the surrogate process and that can be called from a client app.
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif

#ifndef __LDINTERFACES_HPP__
#include "ldintrfcs.hpp"
#endif 

extern TLoad64BitDllsMgr *pGLdrObj;

/*++
    Function Name:
        RPCSplWOW64RefreshLifeSpan
     
    Description:
        Closing down the window between a client connecting and the server
        dieing 
        
     
     Parameters:
        None
        
     Return Value
        Always 0
--*/
DWORD
RPCSplWOW64RefreshLifeSpan(
    )
{

    pGLdrObj->RefreshLifeSpan();

    return 0;
}

DWORD
RPCSplWOW64GetProcessID(
    )
{
    return GetCurrentProcessId();
}



/*++
    Function Name:
        RPCSplWOW64GetProcessHndl
     
    Description:
        This function returns the process handle of the surrogate
        process to winspool.drv (client in this case). The handle
        is important for the client to monitor the server process
        and know when it dies
     
     Parameters:
        ProcessId  : The process id of the client
        ErrorCode  : contains the error code in case of failure
        
     Return Value
       return the Server Process Handle relative to the client
       process        
--*/
ULONG_PTR
RPCSplWOW64GetProcessHndl(
    IN  DWORD  ProcessId,
    OUT PDWORD pErrorCode
    )
{
    HANDLE hTargetProcess;
    HANDLE hDup = NULL;

    *pErrorCode = ERROR_SUCCESS;

    pGLdrObj->RefreshLifeSpan();

    if(hTargetProcess = OpenProcess(PROCESS_DUP_HANDLE,
                                    TRUE,
                                    (DWORD)ProcessId))
    {
         if(!DuplicateHandle(GetCurrentProcess(),
                             GetCurrentProcess(),
                             hTargetProcess,
                             &hDup,
                             0,
                             FALSE,
                             DUPLICATE_SAME_ACCESS))
         {
             *pErrorCode = GetLastError();
         }
         CloseHandle(hTargetProcess);
    }
    else
    {
         *pErrorCode = GetLastError();
    }
       
    return (ULONG_PTR)hDup;
}


/*++
    Function Name:
        RPCSplWOW64AddPort
     
    Description:
     
    Parameters:
        
     Return Value
--*/
BOOL 
RPCSplWOW64AddPort(
    IN  ULONG_PTR  hWnd,
    IN  LPWSTR     pszServerName,
    IN  LPWSTR     pszUIDllName,
    IN  LPWSTR     pszMonitorName,
    OUT PDWORD     pErrorCode
    )
{
    return(pGLdrObj->ExecuteMonitorOperation(hWnd,
                                             pszServerName,
                                             pszUIDllName,
                                             pszMonitorName,
                                             KAddPortOp,
                                             pErrorCode));
}


/*++
    Function Name:
        RPCSplWOW64ConfigurePort
     
    Description:
     
    Parameters:
        
     Return Value
--*/
BOOL 
RPCSplWOW64ConfigurePort(
    IN  ULONG_PTR  hWnd,
    IN  LPWSTR     pszServerName,
    IN  LPWSTR     pszUIDllName,
    IN  LPWSTR     pszPortName,
    OUT PDWORD     pErrorCode
    )
{
    return(pGLdrObj->ExecuteMonitorOperation(hWnd,
                                             pszServerName,
                                             pszUIDllName,
                                             pszPortName,
                                             KConfigurePortOp,
                                             pErrorCode));
}


/*++
    Function Name:
        RPCSplWOW64DeletePort
     
    Description:
     
    Parameters:
        
     Return Value
--*/
BOOL 
RPCSplWOW64DeletePort(
    IN  ULONG_PTR hWnd,      
    IN  LPWSTR    pszServerName,
    IN  LPWSTR    pszUIDllName, 
    IN  LPWSTR    pszPortName,  
    OUT PDWORD    pErrorCode  
    )
{
    return(pGLdrObj->ExecuteMonitorOperation(hWnd,
                                             pszServerName,
                                             pszUIDllName,
                                             pszPortName,
                                             KDeletePortOp,
                                             pErrorCode));
}


/*++
    Function Name:
        RPCSplWOW64DeviceCapabilities
     
    Description:
     
    Parameters:
        
     Return Value
--*/
int
RPCSplWOW64DeviceCapabilities(
    IN  LPWSTR  pszDeviceName,
    IN  LPWSTR  pszPortName,
    IN  WORD    Capabilites,
    IN  DWORD   DevModeSize,
    IN  LPBYTE  pDevMode,
    IN  BOOL    bClonedOutputFill,
    OUT PDWORD  pClonedOutputSize,
    OUT LPBYTE  *ppClonedOutput,
    OUT PDWORD  pErrorCode
    )
{

    return(pGLdrObj->DeviceCapabilities(pszDeviceName,
                                        pszPortName,
                                        Capabilites,
                                        DevModeSize,
                                        pDevMode,
                                        bClonedOutputFill,
                                        pClonedOutputSize,
                                        ppClonedOutput,
                                        pErrorCode));
}


/*++
    Function Name:
        RPCSplWOW64DocumentProperties
     
    Description:
     
    Parameters:
        
     Return Value
--*/
LONG
RPCSplWOW64DocumentProperties(
    IN  ULONG_PTR   hWnd,                   
    IN  LPWSTR      pszPrinterName,            
    OUT PDWORD      pTouchedDevModeSize,     
    OUT PDWORD      pClonedDevModeOutSize,   
    OUT LPBYTE      *ppClonedDevModeOut,       
    IN  DWORD       DevModeSize,            
    IN  LPBYTE      pDevMode,                
    IN  BOOL        bClonedDevModeOutFill,   
    IN  DWORD       fMode,                  
    IN  PDWORD      pErrorCode               
    )
{
    return(pGLdrObj->DocumentProperties(hWnd,
                                        pszPrinterName,
                                        pTouchedDevModeSize,
                                        pClonedDevModeOutSize,
                                        ppClonedDevModeOut,
                                        DevModeSize,
                                        pDevMode,
                                        bClonedDevModeOutFill,
                                        fMode,
                                        pErrorCode));
}

/*++
    Function Name:
        RPCSplWOW64DocumentProperties
     
    Description:
     
    Parameters:
        
     Return Value
--*/
LONG
RPCSplWOW64PrintUIDocumentProperties(
    IN  ULONG_PTR   hWnd,                   
    IN  LPWSTR      pszPrinterName,            
    OUT PDWORD      pTouchedDevModeSize,     
    OUT PDWORD      pClonedDevModeOutSize,   
    OUT LPBYTE      *ppClonedDevModeOut,       
    IN  DWORD       DevModeSize,            
    IN  LPBYTE      pDevMode,                
    IN  BOOL        bClonedDevModeOutFill,   
    IN  DWORD       fMode,                  
    IN  DWORD       fExclusionFlags,
    IN  PDWORD      pErrorCode               
    )
{
    return(pGLdrObj->PrintUIDocumentProperties(hWnd,
                                               pszPrinterName,
                                               pTouchedDevModeSize,
                                               pClonedDevModeOutSize,
                                               ppClonedDevModeOut,
                                               DevModeSize,
                                               pDevMode,
                                               bClonedDevModeOutFill,
                                               fMode,
                                               fExclusionFlags,
                                               pErrorCode));
}

/*++
    Function Name:
        RPCSplWOW64SPrinterProperties
     
    Description:
        Wrapper for TPrinterCfgMgr :: PrinterProperties
     
    Parameters:
        hWnd        : Parent Window
        Printername : Printer Name
        Flag        : Access permissions
        ErrorCode   : Win32 error in case of failure
        
    Return Value:
        BOOL        : FALSE for failure
                      TRUE  for success
--*/
BOOL
RPCSplWOW64PrinterProperties(
    IN  ULONG_PTR   hWnd,
    IN  LPCWSTR     pszPrinterName,
    IN  DWORD       Flag,
    OUT PDWORD      pErrorCode
    )
{
    TPrinterCfgMgr *pPrntrCfgMgrObj = NULL;
    BOOL           RetVal           = FALSE;
    HRESULT        hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTERCONFIGURATION,
                                        reinterpret_cast<VOID **>(&pPrntrCfgMgrObj))) == S_OK)
    {
        SPLASSERT(pPrntrCfgMgrObj);

        if(pPrntrCfgMgrObj)
        {
            RetVal = pPrntrCfgMgrObj->PrinterProperties(hWnd,
                                                        pszPrinterName,
                                                        Flag,
                                                        pErrorCode);
            if(!RetVal)
            {
                 DBGMSG(DBG_WARN, ("TPrinterEventMgr::SpoolerPrinterEvent failed with %u\n",*pErrorCode));
            }
            pPrntrCfgMgrObj->Release();
        }
        else
        {
            *pErrorCode = pGLdrObj->GetLastErrorFromHRESULT(E_NOINTERFACE);
        }
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64PrinterProperties failed in Instantiating a Print Event Object with %u\n",hRes));
        *pErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return RetVal;
}



/*++
    Function Name:
        RPCSplWOW64SpoolerPrinterEvent
     
    Description:
        Wrapper for TPrinterEventMgr::SpoolerPrinterEvent
     
    Parameters:
        PrinterName  : The name of the printer involved
        PrinterEvent : What happened
        Flags        : Misc. flag bits
        lParam        : Event specific parameters        
       
    Return Value:
        BOOL         : TRUE  in case of success
                     : FALSE in case of failure
--*/
BOOL
RPCSplWOW64SpoolerPrinterEvent(
    IN  LPWSTR pszPrinterName,
    IN  int    PrinterEvent,
    IN  DWORD  Flags,
    IN  LPARAM lParam,
    OUT PDWORD pErrorCode
    )
{
    TPrinterEventMgr *pPrntrEvntMgrObj = NULL;
    BOOL            RetVal            = FALSE;
    HRESULT         hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTEREVENT,
                                        reinterpret_cast<VOID **>(&pPrntrEvntMgrObj))) == S_OK)
    {
        SPLASSERT(pPrntrEvntMgrObj);

        RetVal = pPrntrEvntMgrObj->SpoolerPrinterEvent(pszPrinterName,
                                                       PrinterEvent,
                                                       Flags,
                                                       lParam,
                                                       pErrorCode);
        if (!RetVal)
        {
            DBGMSG(DBG_WARN, ("TPrinterEventgMgr :: PrinterProperties failed with %u\n",*pErrorCode));
        }
        pPrntrEvntMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64SpoolerPrinterEvent failed in Instantiating a Print Event Object with %u\n",hRes));
        *pErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return RetVal;
}


/*++
    Function Name:
        RPCSplWOW64DocumentEvent
        
    Description:
        Wrapper for TPrinterEventMgr::DocumentEvent    
     
    Parameters:
        PrinterName  : The name of the printer involved
        InDC         : The printer DC. 
        EscapeCode   : Why this function is called 
        InSize,      : Size of the input buffer
        InBuf,       : Pointer to the input buffer
        OutSize,     : Size of the output buffer
        OutBuf,      : Pointer to the output buffer
        ErrorCode    : output Last Error from operation
                    
       
    Return Value:
        DOCUMENTEVENT_SUCCESS     : success
        DOCUMENTEVENT_UNSUPPORTED : EscapeCode is not supported
        DOCUMENTEVENT_FAILURE     : an error occured
--*/
int
RPCSplWOW64DocumentEvent(
    IN  LPWSTR      pszPrinterName,
    IN  ULONG_PTR   InDC,
    IN  int         EscapeCode,
    IN  DWORD       InSize,
    IN  LPBYTE      pInBuf,
    OUT PDWORD      pOutSize,
    OUT LPBYTE*     ppOutBuf,
    OUT PDWORD      pErrorCode
    )
{
    TPrinterEventMgr* pPrntrEvntMgrObj = NULL;
    int              RetVal          = -1;
    HRESULT          hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTEREVENT,
                                       reinterpret_cast<VOID **>(&pPrntrEvntMgrObj))) == S_OK)
    {
        SPLASSERT(pPrntrEvntMgrObj);

        RetVal = pPrntrEvntMgrObj->DocumentEvent(pszPrinterName,
                                                 InDC,
                                                 EscapeCode,
                                                 InSize,
                                                 pInBuf,
                                                 pOutSize,
                                                 ppOutBuf,
                                                 pErrorCode);
        if (RetVal == -1)
        {
            DBGMSG(DBG_WARN, ("TPrinterEventMgr::DocumentEvent failed with %u\n",*pErrorCode));
        }
        pPrntrEvntMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64DocumentEvent failed in Instantiating a Print Event Object with %u\n",hRes));
        *pErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return RetVal;
}

/*++
    Function Name:
        RPCSplWOW64PrintUIQueueCreate
     
    Description:
        Wrapper for TPrintUIMgr::QueueCreate
     
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD
RPCSplWOW64PrintUIQueueCreate(
    IN ULONG_PTR   hWnd,
    IN LPCWSTR     pszPrinterName,
    IN INT         CmdShow,
    IN LPARAM      lParam
    )
{
    TPrintUIMgr* pPrintUIMgrObj = NULL;
    DWORD       ErrorCode = ERROR_SUCCESS;
    HRESULT     hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTUIOPERATIONS,
                                        reinterpret_cast<VOID **>(&pPrintUIMgrObj))) == S_OK)
    {
        SPLASSERT(pPrintUIMgrObj);

        ErrorCode = pPrintUIMgrObj->QueueCreate(reinterpret_cast<HWND>(hWnd),
                                                pszPrinterName,
                                                CmdShow,
                                                static_cast<LPARAM>(lParam)
                                              );
        if (ErrorCode != ERROR_SUCCESS)
        {
            DBGMSG(DBG_WARN, ("TPrintUIMgr::QueueCreate failed with %u\n",ErrorCode));
        }

        pPrintUIMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64PrintUIQueueCreate failed in Instantiating a Print UI object with %u\n",hRes));
        ErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return ErrorCode;
}

/*++
    Function Name:
        RPCSplWOW64PrintUIPrinterPropPages
     
    Description:
        Wrapper for TPrintUIMgr::PrinterPropPages
     
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD
RPCSplWOW64PrintUIPrinterPropPages(
    IN ULONG_PTR   hWnd,
    IN LPCWSTR     pszPrinterName,
    IN INT         CmdShow,
    IN LPARAM      lParam
    )
{
    TPrintUIMgr* pPrintUIMgrObj = NULL;
    DWORD       ErrorCode = ERROR_SUCCESS;
    HRESULT     hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTUIOPERATIONS,
                                        reinterpret_cast<VOID **>(&pPrintUIMgrObj))) == S_OK)
    {
        SPLASSERT(pPrintUIMgrObj);

        ErrorCode = pPrintUIMgrObj->PrinterPropPages(reinterpret_cast<HWND>(hWnd),
                                                     pszPrinterName,
                                                     CmdShow,
                                                     static_cast<LPARAM>(lParam)
                                                    );
        if (ErrorCode != ERROR_SUCCESS)
        {
            DBGMSG(DBG_WARN, ("TPrintUIMgr::PrinterPropPages failed with %u\n",ErrorCode));
        }

        pPrintUIMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64PrintUIPrinterPropPages failed in Instantiating a Print UI object with %u\n",hRes));
        ErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return ErrorCode;
}


/*++
    Function Name:
        RPCSplWOW64PrintUIDocumentDefaults
     
    Description:
        Wrapper for TPrintUIMgr::DocumentDefaults
     
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD
RPCSplWOW64PrintUIDocumentDefaults(
    IN ULONG_PTR    hWnd,
    IN LPCWSTR      pszPrinterName,
    IN INT          CmdShow,
    IN LPARAM       lParam
    )
{
    TPrintUIMgr* pPrintUIMgrObj = NULL;
    DWORD       ErrorCode = ERROR_SUCCESS;
    HRESULT     hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTUIOPERATIONS,
                                        reinterpret_cast<VOID **>(&pPrintUIMgrObj))) == S_OK)
    {
        SPLASSERT(pPrintUIMgrObj);

        ErrorCode = pPrintUIMgrObj->DocumentDefaults(reinterpret_cast<HWND>(hWnd),
                                                     pszPrinterName,
                                                     CmdShow,
                                                     static_cast<LPARAM>(lParam)
                                                    );

        if (ErrorCode != ERROR_SUCCESS)
        {
            DBGMSG(DBG_WARN, ("TPrintUIMgr::DocumentDefaults failed with %u\n",ErrorCode));
        }

        pPrintUIMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64PrintUIDocumentDefaults failed in Instantiating a Print UI object with %u\n",hRes));
        ErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return ErrorCode;
}

/*++

    Function Name:
        RPCSplWOW64PrintUIPrinterSetup
     
    Description:
        Wrapper for TPrintUIMgr::PrinterSetup.
     
    Parameters:
        hwnd            - Parent window.
        uAction         - Action requested (defined in windows\inc16\msprintx.h)
        cchPrinterName  - Length of pszPrinterName buffer.
        pszPrinterName  - Input setup printer name, Output pointer to new printer name
        pcchPrinterName - New length of pszPrinterName on return.
        pszServerName   - Name of server that printer is on.

    Return Value:

        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD
RPCSplWOW64PrintUIPrinterSetup(
    IN     ULONG_PTR   hWnd,
    IN     UINT        uAction,
    IN     UINT        cchPrinterName,
    IN     DWORD       PrinterNameSize,
    IN OUT byte*       pszPrinterName,
       OUT UINT*       pcchPrinterName,
    IN     LPCWSTR     pszServerName
    )
{
    TPrintUIMgr* pPrintUIMgrObj = NULL;
    DWORD        ErrorCode      = ERROR_SUCCESS;
    HRESULT      hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTUIOPERATIONS,
                                        reinterpret_cast<VOID **>(&pPrintUIMgrObj))) == S_OK)
    {
        SPLASSERT(pPrintUIMgrObj);

        ErrorCode = pPrintUIMgrObj->PrinterSetup(reinterpret_cast<HWND>(hWnd),
                                                 uAction,
                                                 cchPrinterName,
                                                 reinterpret_cast<LPWSTR>(pszPrinterName),
                                                 pcchPrinterName,
                                                 pszServerName
                                                );
        if (ErrorCode != ERROR_SUCCESS)
        {
            DBGMSG(DBG_WARN, ("TPrintUIMgr::PritnerSetup failed with %u\n",ErrorCode));
        }

        pPrintUIMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64PrintUIPrinterSetup failed in Instantiating a Print UI object with %u\n",hRes));
        ErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return ErrorCode;
}


/*++
    Function Name:
        RPCSplWOW64PrintUIServerPropPages
     
    Description:
        Wrapper for TPrintUIMgr::ServerPropPages
     
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Server name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD
RPCSplWOW64PrintUIServerPropPages(
    IN ULONG_PTR   hWnd,
    IN LPCWSTR     pszServerName,
    IN INT         CmdShow,
    IN LPARAM      lParam
    )
{
    TPrintUIMgr* pPrintUIMgrObj = NULL;
    DWORD        ErrorCode      = ERROR_SUCCESS;
    HRESULT      hRes;

    if((hRes = pGLdrObj->QueryInterface(IID_PRINTUIOPERATIONS,
                                        reinterpret_cast<VOID **>(&pPrintUIMgrObj))) == S_OK)
    {
        SPLASSERT(pPrintUIMgrObj);

        ErrorCode = pPrintUIMgrObj->ServerPropPages(reinterpret_cast<HWND>(hWnd),
                                                    pszServerName,
                                                    CmdShow,
                                                    static_cast<LPARAM>(lParam)
                                                   );
        if (ErrorCode != ERROR_SUCCESS)
        {
            DBGMSG(DBG_WARN, ("TPrintUIMgr::ServerPropPages failed with %u\n",ErrorCode));
        }

        pPrintUIMgrObj->Release();
    }
    else
    {
        DBGMSG(DBG_WARN, ("RPCSplWOW64PrintUIServerPropPages failed in Instantiating a Print UI object with %u\n",hRes));
        ErrorCode = pGLdrObj->GetLastErrorFromHRESULT(hRes);
    }
    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\ldmain.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldmain.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the startup code for the
     surrogate rpc server used to load 64 bit dlls
     in 32 bit apps
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 18 January 2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif

#ifndef __LDINTERFACES_HPP__
#include "ldintrfcs.hpp"
#endif 


//
// The global loader pointer used by Threads and RPC functions
// 
TLoad64BitDllsMgr *pGLdrObj;

//
// Initialize Debug spewing
//
MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING, DBG_ERROR );

BOOL WINAPI 
LogOffHandler(
    DWORD CtrlType
    )
{
    BOOL bAction;

    if((CtrlType == CTRL_LOGOFF_EVENT) ||
       (CtrlType == CTRL_SHUTDOWN_EVENT))

    {
        //
        //  Proceed with the proper termination routine
        //
        bAction = TRUE;
    }
    else
    {
        bAction = FALSE;
    }
    return(bAction);
}



/*++
    Function Name:
        main
     
    Description:
        This function instantiates the main loader object.
     
     Parameters:
        None
        
     Return Value
        None
--*/
void __cdecl main()
{
     HRESULT           hRes = S_FALSE;
     DWORD             RetVal = ERROR_SUCCESS;
     TLoad64BitDllsMgr *NewLdrObj = NULL;

     //
     // Adding our defined HandlerRoutine to deal with 
     // LOGOFF requests. This is inactive at this time. If required
     // remove the comment below.
     //
     /* BOOL bCtrlHndlr = SetConsoleCtrlHandler(LogOffHandler,TRUE);*/

     if((NewLdrObj = new TLoad64BitDllsMgr(&hRes)) && 
        (hRes == S_OK))
     {    
          pGLdrObj = NewLdrObj;

          TLPCMgr*   LPCMgrObj = NULL;

          if((hRes = NewLdrObj->QueryInterface(IID_LPCMGR,
                                               reinterpret_cast<VOID **>(&LPCMgrObj))) == S_OK)
          {
              SPLASSERT(LPCMgrObj);

              LPCMgrObj->SetCurrSessionId(NewLdrObj->GetCurrSessionId());

              if((RetVal = LPCMgrObj->InitUMPDLPCServer()) != ERROR_SUCCESS) 
              {
                  DBGMSG(DBG_WARN, ("InitUMPDLPCServer failed with %u\n",RetVal));
              }
              else
              {
                  if((RetVal = NewLdrObj->Run()) != ERROR_SUCCESS)
                  {
                      DBGMSG(DBG_WARN, ("Failed to run the RPC server with  %u\n",RetVal));
                  }
                  LPCMgrObj->Release();
                  NewLdrObj->Release();
              }
          }
          else
          {
              DBGMSG(DBG_WARN, ("main failed in Instantiating an TLPCMgr object %u\n",hRes));
              RetVal = NewLdrObj->GetLastErrorFromHRESULT(hRes);
          }
     }
     else
     {
          DBGMSG(DBG_WARN, ("SplWOW64 main() failed with %u\n",(hRes == S_OK) ? E_OUTOFMEMORY : hRes));
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\ldmemmgr.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldmemmgr.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the memory management functions for both
     RPC and all objects instantiated within the application
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 18 January 2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <rpc.h>
#include <splcom.h>
#include <time.h>
#include "winddiui.h"

#include <splwow64.h>

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t len)
{
     return(new(unsigned char[len]));
}

void __RPC_USER MIDL_user_free(void __RPC_FAR *p)
{
     delete(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\ldmgr.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldmgr.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the methods and class implementation 
     necessary for the RPC surrogate used to load 64 bit dlls from
     within 32 bit apps.
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop


#ifndef __LDINTERFACES_HPP__
#include "ldintrfcs.hpp"
#endif  __LDINTERFACES_HPP__

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif

extern TLoad64BitDllsMgr* pGLdrObj;
extern DWORD              DeviceCapsReqSize[MAX_CAPVAL];

/*++
    Function Name:
        TLoad64BitDllsMgr :: TLoad64BitDllsMgr
     
    Description:
        Constructor of the main Loader Object. Mainly initializes
        the private data of the class and creates whatever resources
        are required
     
     Parameters:
        HRESULT *hRes: Returns result of constructing the object
        
     Return Value:
        None
--*/
TLoad64BitDllsMgr ::
TLoad64BitDllsMgr(
    OUT HRESULT *phRes
    ) :
    m_UIRefCnt(0),
    TClassID("TLoad64BitDllsMgr")
{
    HRESULT hLocalRes   = S_OK;
    HKEY    hPrintKey   = NULL;
    DWORD   ValueSize   = sizeof(DWORD);
    
    //
    // Initializing the time structure before any time
    // calculations
    //
    ZeroMemory(&m_LastTransactionTime,sizeof(SYSTEMTIME));

    //
    // Read the expiration time from the registry
    //
    if((ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                                    L"System\\CurrentControlSet\\Control\\Print",
                                    &hPrintKey))                                     ||
       (ERROR_SUCCESS != RegQueryValueEx(hPrintKey,
                                         L"SplWOW64TimeOut",
                                         NULL,
                                         NULL,
                                         (LPBYTE) &m_ExpirationTime,
                                         &ValueSize)))
    {
         m_ExpirationTime = KTwoMinutes;
    }
    else
    {
         m_ExpirationTime = m_ExpirationTime * KOneMinute;
    }

    if(hPrintKey)
    {
        RegCloseKey(hPrintKey);
    }

    __try
    {
         DWORD  CurrProcessId = GetCurrentProcessId();
         //
         // Initializing the Critical Section
         //
         InitializeCriticalSection(&m_LdMgrLock);
         //
         // Setting the initial time to that of the process 
         // first instantiation
         //
         GetSystemTime(&m_LastTransactionTime);
         //
         // The Session ID uniquely identifies each process for 
         // both the RPC end point and the LPC port name
         //
         ProcessIdToSessionId(CurrProcessId,&m_CurrSessionId);

         AddRef();
    }
    __except(1)
    {
              hLocalRes = GetLastErrorAsHRESULT(TranslateExceptionCode(GetExceptionCode()));
    }

    if(phRes)
    {
         *phRes = hLocalRes;
    }
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: ~TLoad64BitDllsMgr
     
    Description:
        Destructor of the main Loader Object. Mainly fress up any
        allocated resources
     
     Parameters:
        None
        
     Return Value:
        None
--*/
TLoad64BitDllsMgr ::
~TLoad64BitDllsMgr()
{
     DeleteCriticalSection(&m_LdMgrLock);
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: QueryInterface
     
    Description:
        Returned the correct object for each set of simillar functions
     
    Parameters:
        None
        
    Return Value:
        HRESULT hREs = S_OK in case of a suitable Interface
                       E_NOINTERFACE in case of none
--*/
HRESULT 
TLoad64BitDllsMgr ::
QueryInterface(
    IN  REFIID InterfaceID,
    OUT PVOID  *ppInterface
    )
{
    HRESULT hRes = S_OK;

    if(!ppInterface)
    {
         hRes = E_INVALIDARG;
    }
    else
    {
         *ppInterface = NULL;
         if(InterfaceID == IID_PRINTEREVENT)
         {
             *ppInterface = reinterpret_cast<TPrinterEventMgr *>(new TPrinterEventMgr(this));
         }
         else if(InterfaceID == IID_PRINTUIOPERATIONS)
         {
             *ppInterface = reinterpret_cast<TPrintUIMgr *>(new TPrintUIMgr(this));
         }
         else if(InterfaceID == IID_PRINTERCONFIGURATION)
         {
              *ppInterface = reinterpret_cast<TPrinterCfgMgr *>(new TPrinterCfgMgr(this));
         }
         else if(InterfaceID == IID_LPCMGR)
         {
             *ppInterface = reinterpret_cast<TLPCMgr *>(new TLPCMgr(this));
         }
         else
         {
              hRes = E_NOINTERFACE;
         }

         if(*ppInterface)
         {
             (reinterpret_cast<TRefCntMgr *>(*ppInterface))->AddRef();
         }
         else
         {
             hRes = E_OUTOFMEMORY;
         }
    }
    return hRes;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: Run
     
    Description:
        Creates the object expiration monitoring Thread and starts the 
        RPC server listening process
     
     Parameters:
        None
        
     Return Value:
        DWORD RetVal : ERROR_SUCCESS in case of success
                       ErrorCode     in case of failure
--*/
DWORD
TLoad64BitDllsMgr ::
Run(
    VOID
)
{
    DWORD   RetVal        = ERROR_SUCCESS;
    HANDLE  hMonSrvrThrd  = NULL;
    DWORD   MonSrvrThrdId = 0; 
    //
    // Create a Thread which monitors the expiration of this
    // process. Expiration means that more than a given amount
    // of time , no one requested a service from this surrogate.
    //
    if(hMonSrvrThrd = CreateThread(NULL,
                                   0,
                                   MonitorSrvrLifeExpiration,
                                   (PVOID)this,             
                                   0,
                                   &MonSrvrThrdId))
    {
         //
         // SetUp the RPC server and start listening
         //
         if((RetVal = StartLdrRPCServer()) == RPC_S_OK)
         {
              WaitForSingleObject(hMonSrvrThrd,INFINITE);
         }
         CloseHandle(hMonSrvrThrd);
    }
    else
    {
         RetVal = GetLastError();
    }
    return RetVal;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: StartldrRPCServer
     
    Description:
        This function encapsulates specifying the EndPoints,
        the RPC protocol and the Bindings. It also has the 
        main listening loop for the RPC server.
     
     Parameters:
        None
        
     Return Value
        DWORD RetVal : ERROR_SUCCESS in case of success
                       ErrorCode     in case of failure
--*/
DWORD
TLoad64BitDllsMgr ::
StartLdrRPCServer(
    VOID
    )
{
     RPC_BINDING_VECTOR  *pBindingVector;
     RPC_STATUS          RpcStatus;
     WCHAR               szSessionEndPoint[50];
     DWORD               CurrProcessId = GetCurrentProcessId();

     //
     // The EndPointName would be the concatenation of
     // both the app name and the session ID. Session 
     // ID is a dword and hence needs max. 10 wchars , 
     // App name is "splwow64" which is 8 wchars. So 
     // the max we might need is 18 whcars. I might
     // adjust the buffer size later. This is done 
     // specially for terminal server because a Window
     // handle is not shared between differnet sessions, 
     // hence we need a process/session
     //
     StringCchPrintfW(szSessionEndPoint,
                      50,
                      L"%s_%x",
                      APPNAME,m_CurrSessionId);


     if(!(((RpcStatus = RpcServerUseProtseqEp((WCHAR *)L"ncalrpc",
                                              RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                              (WCHAR *)szSessionEndPoint,
                                              NULL)) == RPC_S_OK)                         &&
          ((RpcStatus = RpcServerRegisterIf2(Lding64BitDlls_ServerIfHandle,
                                             NULL,
                                             NULL,
                                             0,
                                             RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                             kMaxRPCPacketSize,
                                             NULL)) == RPC_S_OK)                          &&
          ((RpcStatus = RpcServerInqBindings(&pBindingVector)) == RPC_S_OK)               &&
          ((RpcStatus = RpcBindingVectorFree(&pBindingVector)) == RPC_S_OK)               &&
          ((RpcStatus = RpcServerRegisterAuthInfo(0,RPC_C_AUTHN_WINNT,0,0 )) == RPC_S_OK) &&
          ((RpcStatus = RpcServerListen(1,
                                        RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                        FALSE)) == RPC_S_OK)))           
     {
          DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: StartLdrRPCServer failed with %u\n",RpcStatus));
     }
     return (DWORD)RpcStatus;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: LockSelf
     
    Description:
        Locks the object from other threads for 
        internal data update.
     
     Parameters:
        None
        
     Return Value:
        None
--*/
VOID 
TLoad64BitDllsMgr ::
LockSelf(
    VOID
    ) 
{
    EnterCriticalSection(&m_LdMgrLock);
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: ReleaseSelf
     
    Description:
        Release the object for use by other Threads
     
     Parameters:
        None
        
     Return Value
        None
--*/
VOID 
TLoad64BitDllsMgr ::
ReleaseSelf(
    VOID
    )
{
    LeaveCriticalSection(&m_LdMgrLock);
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: RefreshLifeSpan
     
    Description:
        Updates the last time @ which the object 
        was accessed
     
     Parameters:
        None
        
     Return Value:
        None
--*/
VOID
TLoad64BitDllsMgr ::
RefreshLifeSpan(
    VOID
    )
{
    LockSelf();
    {
        GetSystemTime(&m_LastTransactionTime);
    }
    ReleaseSelf();
}
/*++
    Function Name:
        TLoad64BitDllsMgr :: StillAlive
     
    Description:
        This function calculates the difference of
        time  between the last time the object was
        accessed by any connected client and the 
        current system time
     
     Parameters:
        None
        
     Return Value:
        BOOL RetVal : TRUE if  time delta is <= server expiration time
                      FALSE if time delta is >  server expiration time
--*/
BOOL
TLoad64BitDllsMgr ::
StillAlive(
    VOID
    )
{
    FILETIME   FileTime;
    FILETIME   LocalFileTime;
    SYSTEMTIME LocalSystemTime;
    BOOL       bRetVal = TRUE;

     LockSelf();
     {
          GetSystemTime(&LocalSystemTime);
          SystemTimeToFileTime(&LocalSystemTime,&LocalFileTime);
          SystemTimeToFileTime(&m_LastTransactionTime,&FileTime);
          ULONGLONG TimeDiff = ((ULARGE_INTEGER *)&LocalFileTime)->QuadPart -
                               ((ULARGE_INTEGER *)&FileTime)->QuadPart;
          //
          // Since FileTime is calculated as a 100 nanosecond interval
          // we have to divide by 10**4 to get the value in meli seconds
          //
          if((TimeDiff/10000) > m_ExpirationTime)
          {
               if(GetUIRefCnt())
               {
                    GetSystemTime(&m_LastTransactionTime);
               }
               else
               {
                    bRetVal = FALSE;
                    //
                    // Here we should terminate the Listen loop and kill the 
                    // process, by releasing the listen loop.
                    //
                    RpcMgmtStopServerListening(NULL);
               }
          }
     }
     ReleaseSelf();
     return bRetVal;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: StillAlive
     
    Description:
        Monitors the expiration of the server and in case of 
        expiration terminations the RPC server listening loop.
             
     Parameters:
        PVOID pData : Pointer to the Loader Object
        
     Return Value:
        Always returns 0
--*/
DWORD 
TLoad64BitDllsMgr ::
MonitorSrvrLifeExpiration(
    IN PVOID pData
    )
{
     TLoad64BitDllsMgr *pMgrInstance = reinterpret_cast<TLoad64BitDllsMgr *>(pData);

     while(pMgrInstance->StillAlive())
     {
          Sleep(pMgrInstance->m_ExpirationTime);
     }
     return 0;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: IncUIRefCnt
     
    Description:
        While poping other components UI , the server process
        should never expire and that's why we incerement ref cnt
        on UI objects.
             
     Parameters:
        None
        
     Return Value:
        None
--*/
VOID 
TLoad64BitDllsMgr ::
IncUIRefCnt(
    VOID
    )
{
     LockSelf();
     {
          //
          // Since I am already in the critical section,
          // I don't need to use InterLocked operations
          //
          m_UIRefCnt++;
     }
     ReleaseSelf();
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: DecUIRefCnt
     
    Description:
        We have to dec the ref cnt once the UI returns, in order
        to be able to release the process once time expires
             
     Parameters:
        None
        
     Return Value:
        None
--*/
VOID
TLoad64BitDllsMgr ::
DecUIRefCnt(
    VOID
    )
{
    LockSelf();
    {
         SPLASSERT(m_UIRefCnt);
         //
         // Since I am already in the critical section,
         // I don't need to use InterLocked operations
         //
         m_UIRefCnt--;
    }
    ReleaseSelf();
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: GetUIRefCnt
     
    Description:
        Returns the current number of poped UIs
             
     Parameters:
        None
        
     Return Value:
        Number of poped UIs
--*/
DWORD
TLoad64BitDllsMgr ::
GetUIRefCnt(
    VOID
    ) const
{
    return m_UIRefCnt;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: ExecuteMonitorOperation
     
    Description:
        Loads the monitor UI Dll , Initializes the monitor UI , 
        determines the required Monitor Operation , and start 
        the function whcih spins off this operation in a 
        separate Thread
             
     Parameters:
        DWORD  hWnd       : Windows Handle for parent windows
        LPWSTR ServerName : Server Name 
        LPWSTR UIDllName  : The Monitor UI Dll name
        LPWSTR Name       : Port Name or Monitor Name
        PortOp Index      : Required Operation
        
     Return Value:
        DWORD  RetVal     : ERROR_SUCCESS in case of success
                            ErrorCode     in case of failure
--*/
BOOL
TLoad64BitDllsMgr ::
ExecuteMonitorOperation(
    IN  ULONG_PTR  hWnd,
    IN  LPWSTR     pszServerName,
    IN  LPWSTR     pszUIDllName,
    IN  LPWSTR     pszName,
    IN  EPortOp    Index,
    OUT PDWORD     pErrorCode
    )
{   
     PMONITORUI (*pfnInitializePrintMonitorUI)(VOID) = NULL;
     RPC_STATUS RpcStatus;
     HMODULE    hLib       = NULL;
     HANDLE     hActCtx    = NULL;
     ULONG_PTR  lActCtx    = 0;
     BOOL       bActivated = FALSE;

     *pErrorCode = ERROR_SUCCESS;

     if((RpcStatus = RpcImpersonateClient(0)) == RPC_S_OK)
     {
         RefreshLifeSpan();

         //
         // For Fusion, we run the code the gets us the 
         // monitor UI activation context
         //
         if((*pErrorCode = this->GetMonitorUIActivationContext(pszUIDllName,&hActCtx,&lActCtx,&bActivated)) == ERROR_SUCCESS)
         {
             if(hLib = LoadLibrary(pszUIDllName))
             {
                  if(pfnInitializePrintMonitorUI = (PMONITORUI (*)(VOID))
                                                   GetProcAddress(hLib, "InitializePrintMonitorUI"))
                  {
                       PMONITORUI pMonitorUI;

                       if(pMonitorUI = (pfnInitializePrintMonitorUI)())
                       {
                           LPTHREAD_START_ROUTINE pThrdFn = NULL;
                           switch (Index)
                           {
                               case KAddPortOp:
                               {
                                    pThrdFn = AddPortUI;
                                    break;
                               }

                               case KConfigurePortOp:
                               case KDeletePortOp:
                               {
                                    pThrdFn = (Index == KConfigurePortOp) ? ConfigurePortUI : DeletePortUI;
                                    break;
                               }
                           }

                           SPLASSERT(pThrdFn);
                           *pErrorCode = SpinPortOperationThread((HWND)hWnd,
                                                                 pszServerName,
                                                                 pszName,
                                                                 pMonitorUI,
                                                                 Index,
                                                                 pThrdFn,
                                                                 hLib,
                                                                 hActCtx,
                                                                 lActCtx,
                                                                 bActivated
                                                                 );
                       }
                       else
                       {
                           *pErrorCode = GetLastError();
                       }
                  }
                  else
                  {
                       *pErrorCode = GetLastError();
                       DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: ExecuteMonitorOperation failed to Load Monitor Initializaiton fn. with  %u\n",
                                         *pErrorCode));
                  }
             }
             else
             {
                  *pErrorCode = GetLastError();
                  DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: ExecuteMonitorOperation failed to load Monitor UI Dll with  %u\n",
                                    *pErrorCode));
             }
         }
         if(*pErrorCode != ERROR_SUCCESS)
         {
             ReleaseMonitorActivationContext(hLib,hActCtx,lActCtx,bActivated);
         }
         RpcStatus = RpcRevertToSelf();
     }
     else
     {
         *pErrorCode = static_cast<DWORD>(RpcStatus);
     }

     return *pErrorCode == ERROR_SUCCESS;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: SpinPortOperationThread
     
    Description:
        Spins the appropriate monitor operation in a separate thread
             
     Parameters:
        HWND                   hWnd       : Windows Handle for parent windows
        LPWSTR                 ServerName : Server Name 
        LPWSTR                 UIDllName  : The Monitor UI Dll name
        LPWSTR                 Name       : Port Name or Monitor Name
        PortOp                 Index      : Required Operation
        PMONITORUI             pMonitorUI : Port Monitor Functions
        LPTHREAD_START_ROUTINE pThrdFn    : Internal Thread to be executed
        
     Return Value:
        DWORD  RetVal  : ERROR_SUCCESS in case of success
                         ErrorCode     in case of failure
--*/
DWORD 
TLoad64BitDllsMgr ::
SpinPortOperationThread(
    IN HWND                   hWnd,
    IN LPWSTR                 pszServerName,
    IN LPWSTR                 pszName,
    IN PMONITORUI             pMonitorUI,
    IN EPortOp                Index,
    IN LPTHREAD_START_ROUTINE pThrdFn,
    IN HMODULE                hLib,
    IN HANDLE                 hActCtx,
    IN ULONG_PTR              lActCtx,
    IN BOOL                   bActivated
    ) const
{
    DWORD               UIThrdId        = 0;
    HANDLE              hUIThrd         = NULL; 
    DWORD               RetVal          = ERROR_SUCCESS;
    SPortAddThreadData  *pNewThreadData = NULL;

    if(pNewThreadData = new SPortAddThreadData)
    {
         switch (Index)
         {
             case KAddPortOp:
             {
                 pNewThreadData->pMonFnAdd       = pMonitorUI->pfnAddPortUI;
                 pNewThreadData->pMonFns         = NULL;
                 pNewThreadData->pszMonitorName  = pszName;
                 pNewThreadData->pszPortName     = NULL;
                 break;
             }

             case KConfigurePortOp:
             case KDeletePortOp:
             {
                 PFNMONITORFNS pfnMonitorsFns[2];

                 pfnMonitorsFns[0] = pMonitorUI->pfnConfigurePortUI;
                 pfnMonitorsFns[1] = pMonitorUI->pfnDeletePortUI;

                 pNewThreadData->pMonFnAdd        = NULL;
                 pNewThreadData->pMonFns          = pfnMonitorsFns[Index];
                 pNewThreadData->pszMonitorName   = NULL;
                 pNewThreadData->pszPortName      = pszName;
                 break;
             }
         }
         pNewThreadData->hWnd              = hWnd;
         pNewThreadData->pszServerName     = pszServerName;
         pNewThreadData->ppszRetPortName   = NULL;
         pNewThreadData->hLib              = hLib;
         pNewThreadData->hActCtx           = hActCtx;
         pNewThreadData->lActCtx           = lActCtx;
         pNewThreadData->bActivated        = bActivated;

         if(!(hUIThrd = CreateThread(NULL,
                                     0,
                                     pThrdFn,
                                     (PVOID)pNewThreadData,             
                                     0,
                                     &UIThrdId)))
         {
              RetVal = GetLastError();
              delete pNewThreadData;
              DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: SpinPortOperationThread failed to create Port Operation fn. with  %u\n",
                                RetVal));
         }
         else
         {
              CloseHandle(hUIThrd);
         }
    }
    else
    {
         RetVal = ERROR_OUTOFMEMORY;
         DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: SpinPortOperationThread failed to allocate required memory with %u\n",
                           RetVal));
    }
    return RetVal;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: AddPortUI
     
    Description:
        Calls the monitor AddPort
             
     Parameters:
        PVOID  InThrdData : Thread Data for Adding a Port
             
     Return Value:
        Always 0
--*/
DWORD
TLoad64BitDllsMgr ::
AddPortUI(
    IN PVOID pInThrdData
    )
{
     DWORD   RetVal = ERROR_SUCCESS;
     HANDLE  hMsgThrd;
     DWORD   MsgThrdId;

     SPortAddThreadData *pNewThreadData = reinterpret_cast<SPortAddThreadData *>(pInThrdData);

     pGLdrObj->IncUIRefCnt();
     {
         RetVal =  (DWORD) pNewThreadData->pMonFnAdd(pNewThreadData->pszServerName,
                                                     pNewThreadData->hWnd,
                                                     pNewThreadData->pszMonitorName,
                                                     NULL);
     }
     pGLdrObj->DecUIRefCnt();
     //
     // Here we should post a message to the caller client window to inform 
     // it that the operation was completed and also whether it was succesful 
     // or not
     //
     PostMessage(pNewThreadData->hWnd,WM_ENDADDPORT,
                 (WPARAM)RetVal,
                 (RetVal != ERROR_SUCCESS) ? ERROR_SUCCESS : (DWORD)GetLastError());

     pGLdrObj->ReleaseMonitorActivationContext(pNewThreadData->hLib,
                                               pNewThreadData->hActCtx,
                                               pNewThreadData->lActCtx,
                                               pNewThreadData->bActivated);

     delete pInThrdData;

     return 0;
}

/*++
    Function Name:
        TLoad64BitDllsMgr :: DeletePortUI
     
    Description:
        Calls the monitor DeletePort
             
     Parameters:
        PVOID  InThrdData : Thread Data for Adding a Port
             
     Return Value:
        Always 0
--*/
DWORD
TLoad64BitDllsMgr ::
DeletePortUI(
    IN PVOID pInThrdData
    )
{
     DWORD  RetVal = ERROR_SUCCESS;

     SPortAddThreadData *pNewThreadData = reinterpret_cast<SPortAddThreadData *>(pInThrdData);

     pGLdrObj->IncUIRefCnt();
     {
         RetVal =  (DWORD) pNewThreadData->pMonFns(pNewThreadData->pszServerName,
                                                   pNewThreadData->hWnd,
                                                   pNewThreadData->pszPortName);
     }
     pGLdrObj->DecUIRefCnt();
     //
     // Here we should post a message to the caller window to inform them
     // the operation was completed and also whether it was succesful or 
     // not
     //
     PostMessage(pNewThreadData->hWnd,WM_ENDDELPORT,
                 (WPARAM)RetVal,
                 (RetVal != ERROR_SUCCESS) ? ERROR_SUCCESS : (DWORD)GetLastError());

     pGLdrObj->ReleaseMonitorActivationContext(pNewThreadData->hLib,
                                               pNewThreadData->hActCtx,
                                               pNewThreadData->lActCtx,
                                               pNewThreadData->bActivated);

     delete pInThrdData;

     return 0;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: ConfigurePortUI
     
    Description:
        Calls the monitor ConfigurePort
             
     Parameters:
        PVOID  InThrdData : Thread Data for Adding a Port
             
     Return Value:
        Always 0
--*/
DWORD
TLoad64BitDllsMgr ::
ConfigurePortUI(
    IN PVOID pInThrdData
    )
{
     DWORD  RetVal = ERROR_SUCCESS;

     SPortAddThreadData *pNewThreadData = reinterpret_cast<SPortAddThreadData *>(pInThrdData);

     pGLdrObj->IncUIRefCnt();
     {
         RetVal =  (DWORD) pNewThreadData->pMonFns(pNewThreadData->pszServerName,
                                                   pNewThreadData->hWnd,
                                                   pNewThreadData->pszPortName);
     }
     pGLdrObj->DecUIRefCnt();
     //
     // Here we should post a message to the caller window to inform them
     // the operation was completed and also whether it was succesful or 
     // not
     //
     PostMessage(pNewThreadData->hWnd,WM_ENDCFGPORT,
                 (WPARAM)RetVal,
                 (RetVal != ERROR_SUCCESS) ? ERROR_SUCCESS : (DWORD)GetLastError());

     pGLdrObj->ReleaseMonitorActivationContext(pNewThreadData->hLib,
                                               pNewThreadData->hActCtx,
                                               pNewThreadData->lActCtx,
                                               pNewThreadData->bActivated);

     delete pInThrdData;

     return 0;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: DeviceCapabilities
     
    Description:
        Queries the Device capabilities , by calling into
        the driver
             
    Parameters:
        LPWSTR  DeviceName       : Device Name
        LPWSTR  PortName         : Port Name
        WORD    Capabilities     : Required Capabilites to Query for
        DWORD   DevModeSize      : Input DevMode Size
        LPBYTE  DevMode          : Input DevMode
        BOOL    ClonedOutputFill : Required To fill output DevMode
        PDWORD  ClonedOutputSize : Output DevMode size
        LPBYTE* ClonedOutput     : Output DevMode
             
     Return Value:
        int RetVal : -1 in case of Failure
                   : Some value depending on Capabilities flag in case 
                     of Success
--*/
int 
TLoad64BitDllsMgr ::
DeviceCapabilities(
    IN  LPWSTR  pszDeviceName,
    IN  LPWSTR  pszPortName,
    IN  WORD    Capabilities,
    IN  DWORD   DevModeSize,
    IN  LPBYTE  pDevMode,
    IN  BOOL    bClonedOutputFill,
    OUT PDWORD  pClonedOutputSize,
    OUT LPBYTE  *ppClonedOutput,
    OUT PDWORD  pErrorCode
    )
{
     HANDLE      hPrinter    = NULL;
     HANDLE      hDriver     = NULL;
     INT         ReturnValue = -1;
     INT_FARPROC pfn;
     LPWSTR      pszDriverFileName;
     RPC_STATUS  RpcStatus;

     pGLdrObj->IncUIRefCnt();
     {
         if((RpcStatus = RpcImpersonateClient(0)) == RPC_S_OK)
         {
             if (OpenPrinter((LPWSTR)pszDeviceName, &hPrinter, NULL))
             {
                  if(hDriver = LoadPrinterDriver(hPrinter))
                  {
                       if (pfn = (INT_FARPROC)GetProcAddress(hDriver,
                                                             "DrvDeviceCapabilities"))
                       {
                           __try
                           {
                               *ppClonedOutput = NULL;

                               ReturnValue = (*pfn)(hPrinter,
                                                    pszDeviceName,
                                                    Capabilities,
                                                    (PVOID)*ppClonedOutput,
                                                    (PDEVMODE)pDevMode);
                               if(ReturnValue != -1 &&
                                  ReturnValue != 0  &&
                                  bClonedOutputFill &&
                                  DevCapFillsOutput(Capabilities))
                               {
                                   if(*ppClonedOutput = new BYTE[*pClonedOutputSize = CalcReqSizeForDevCaps(ReturnValue,
                                                                                                            Capabilities)])
                                   {
                                       ZeroMemory(*ppClonedOutput,*pClonedOutputSize);
                                       if((ReturnValue = (*pfn)(hPrinter, 
                                                                pszDeviceName, 
                                                                Capabilities,
                                                                (PVOID)*ppClonedOutput, 
                                                                (PDEVMODE)pDevMode)) == -1)
                                       {
                                           *pErrorCode = GetLastError();
                                       }
                                   }
                                   else
                                   {
                                       ReturnValue = -1;
                                       *pErrorCode = ERROR_OUTOFMEMORY;
                                   }
                               }
                               if(!ReturnValue)
                               {
                                   *pErrorCode = GetLastError();
                               }
                           }
                           __except(1)
                           {
                               SetLastError(GetExceptionCode());
                               ReturnValue = -1;
                               DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: DeviceCapabilities failed to allocate memory"));
                           }
                       }
                       FreeLibrary(hDriver);
                  }
                  else
                  {   *pErrorCode = GetLastError();
                      DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: DeviceCapabilities failed to load driver with %u\n",
                             *pErrorCode));
                  }
                  ClosePrinter(hPrinter);
             }
             else
             {
                 *pErrorCode = GetLastError();
                 DBGMSG(DBG_WARN, ("TLoad64BitDllsMgr :: DeviceCapabilities failed to open printer with %u\n",
                        *pErrorCode));
             }
             RpcStatus = RpcRevertToSelf();
         }
         else
         {
            *pErrorCode = RpcStatus;
         }
     }
     pGLdrObj->DecUIRefCnt();

     return  ReturnValue;
}

/*++
    Function Name:
        TLoad64BitDllsMgr :: DevCapFillsOutput
     
    Description:
        Does the capability fill out an out buffer or not
             
    Parameters:
        DWORD Capabilites : The required Capability
        
             
     Return Value:
        BOOL  : 1 OR 0
--*/
BOOL
TLoad64BitDllsMgr ::
DevCapFillsOutput(
    IN DWORD Capabilities
    ) const
{
     SPLASSERT(Capabilities>0 && Capabilities<= DC_NUP);

     return(!!DeviceCapsReqSize[Capabilities-1]);
}



/*++
    Function Name:
        TLoad64BitDllsMgr :: CalcReqSizeForDevCaps
     
    Description:
        Given the required capability returns the size required
        for all enumerated values of it
             
    Parameters:
        DWORD CapNum      : Num Of Items for given Capability
        DWORD Capabilites : The required Capability
        
             
     Return Value:
        DWORD  : Required size to store all items of capability
--*/
DWORD
TLoad64BitDllsMgr ::
CalcReqSizeForDevCaps(
    IN DWORD CapNum,
    IN DWORD Capabilities
    ) const
{
     SPLASSERT(Capabilities>0 && Capabilities<= DC_NUP);

     return((Capabilities && DeviceCapsReqSize[Capabilities-1]) ?
            (CapNum * DeviceCapsReqSize[Capabilities-1])        :
            CapNum);

}

/*++
    Function Name:
        TLoad64BitDllsMgr :: DocumentProperties
     
    Description:
        Displays the driver specific properties
                     
    Parameters:
        HWND    hWnd                 : Parent Window Handle
        LPWSTR  PrinterName          : Printer Name
        PDWORD  ClonedDevModeOutSize : Output DevMode size
        LPBYTE* ClonedDevModeOut     : Output DevMode
        DWORD   DevModeSize          : Input DevMode Size
        LPBYTE  DevMode              : Input DevMode
        WORD    Capabilities         : Required Capabilites to Query for
        BOOL    ClonedDevModeOutFill : Required To fill output DevMode
        DWORD   fMode                : Mode Options
             
     Return Value:
        int RetVal : -1 in case of Failure
                   : Some value depending on fMode flag  and DevModes
                     and this might be posted to the client window in
                     case of running asynchronously
--*/
LONG                                            
TLoad64BitDllsMgr ::
DocumentProperties(                     
    IN  ULONG_PTR  hWnd,                               
    IN  LPWSTR     pszPrinterName, 
    OUT PDWORD     pTouchedDevModeSize,
    OUT PDWORD     pClonedDevModeOutSize,               
    OUT LPBYTE     *ppClonedDevModeOut,
    IN  DWORD      DevModeSize,                        
    IN  LPBYTE     pDevMode,                            
    IN  BOOL       bClonedDevModeOutFill,               
    IN  DWORD      fMode,
    OUT PDWORD     pErrorCode
    )
{

    LONG                RetVal        = -1;
    SDocPropsThreadData *pNewThrdData = NULL;
    RPC_STATUS          RpcStatus;

    if((RpcStatus = RpcImpersonateClient(0)) == RPC_S_OK)
    {
        RefreshLifeSpan();
        
        if(pNewThrdData = new SDocPropsThreadData)
        {
             pNewThrdData->hWnd                    = (HWND)hWnd;                   
             pNewThrdData->pszPrinterName          = pszPrinterName;            
             pNewThrdData->pClonedDevModeOutSize   = pClonedDevModeOutSize;   
             pNewThrdData->pTouchedDevModeSize     = pTouchedDevModeSize;
             pNewThrdData->ppClonedDevModeOut      = ppClonedDevModeOut;
             pNewThrdData->DevModeSize             = DevModeSize;            
             pNewThrdData->pDevMode                = pDevMode;                
             pNewThrdData->bClonedDevModeOutFill   = bClonedDevModeOutFill;   
             pNewThrdData->fMode                   = fMode;         
             pNewThrdData->fExclusionFlags         = 0;         
             pNewThrdData->ErrorCode               = ERROR_SUCCESS;
             pNewThrdData->RetVal                  = -1;
             InternalDocumentProperties((PVOID)pNewThrdData);
    
             RetVal      = pNewThrdData->RetVal;
             *pErrorCode = pNewThrdData->ErrorCode;
    
             delete pNewThrdData;
        }
        RpcStatus = RpcRevertToSelf();
    }
    else
    {
        *pErrorCode = RpcStatus;
    }
    return RetVal;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: AsyncDocumentProperties
             
    Description:
        Displays the driver specific UI in a separate sheet
                     
    Parameters:
        PVOID : Thread Data
                     
     Return Value:
        Always returns 0
--*/
DWORD 
TLoad64BitDllsMgr ::
InternalDocumentProperties(
    PVOID pInThrdData
    )
{
                         
     DOCUMENTPROPERTYHEADER     DPHdr;
     HANDLE                     hPrinter              = NULL;
     SDocPropsThreadData        *pNewThreadData       = reinterpret_cast<SDocPropsThreadData *>(pInThrdData);    
     TLoad64BitDllsMgr          *pMgrInstance         = pNewThreadData->pMgrInstance;                       
     HWND                       hWnd                  = pNewThreadData->hWnd;                              
     LPWSTR                     pszPrinterName        = pNewThreadData->pszPrinterName;                       
     PDWORD                     pClonedDevModeOutSize = pNewThreadData->pClonedDevModeOutSize;              
     PDWORD                     pTouchedDevModeSize   = pNewThreadData->pTouchedDevModeSize;
     LPBYTE*                    ppClonedDevModeOut    = pNewThreadData->ppClonedDevModeOut;                  
     DWORD                      DevModeSize           = pNewThreadData->DevModeSize;                       
     LPBYTE                     pDevMode              = pNewThreadData->pDevMode;                           
     BOOL                       bClonedDevModeOutFill = pNewThreadData->bClonedDevModeOutFill;              
     DWORD                      fMode                 = pNewThreadData->fMode;                             
     HMODULE                    hWinSpool             = NULL;
     PFNDOCPROPSHEETS           pfnDocPropSheets      = NULL;
     LONG                       Result                = -1;
     LONG                       cbOut                 = 0;

     pGLdrObj->IncUIRefCnt();
     {
         if(hWinSpool = LoadLibrary(L"winspool.drv"))
         {
              if(pfnDocPropSheets = reinterpret_cast<PFNDOCPROPSHEETS>(GetProcAddress(hWinSpool,
                                                                                      "DocumentPropertySheets")))
              {
                   if(OpenPrinter(pszPrinterName,&hPrinter,NULL))
                   {
                        //
                        // Do I need to protect the printer handle ?????
                        //
                        DPHdr.cbSize         = sizeof(DPHdr);
                        DPHdr.Reserved       = 0;
                        DPHdr.hPrinter       = hPrinter;
                        DPHdr.pszPrinterName = pszPrinterName;

                        if(bClonedDevModeOutFill)
                        {
                            DPHdr.pdmIn  = NULL;
                            DPHdr.pdmOut = NULL;
                            DPHdr.fMode  = 0;

                            cbOut = pfnDocPropSheets(NULL, (LPARAM)&DPHdr);

                            //
                            // The function returns zero or a negative number when it fails.
                            // 
                            if (cbOut > 0)
                            {
                                DPHdr.cbOut = cbOut;
                                if(*ppClonedDevModeOut = new BYTE[DPHdr.cbOut])
                                {
                                    ZeroMemory(*ppClonedDevModeOut, DPHdr.cbOut);
                                }
                            }
                            else
                            {
                                DPHdr.cbOut           = 0;
                                *ppClonedDevModeOut   = NULL;
                            }
                        }
                        else
                        {
                            DPHdr.cbOut           = 0;
                            *ppClonedDevModeOut     = NULL;
                        }

                        *pClonedDevModeOutSize = DPHdr.cbOut;

                        DPHdr.pdmIn  = (PDEVMODE)pDevMode;
                        DPHdr.pdmOut = (PDEVMODE)*ppClonedDevModeOut;
                        DPHdr.fMode  = fMode;

                        if (fMode & DM_PROMPT)
                        {
                            PFNCALLCOMMONPROPSHEETUI  pfnCallCommonPropSheeUI = NULL;
                            Result = CPSUI_CANCEL;

                            if(pfnCallCommonPropSheeUI= reinterpret_cast<PFNCALLCOMMONPROPSHEETUI>(GetProcAddress(hWinSpool,
                                                                                                                 (LPCSTR) MAKELPARAM(218, 0))))
                            {
                                pGLdrObj->IncUIRefCnt();
                                if(pfnCallCommonPropSheeUI(hWnd,
                                                           pfnDocPropSheets,
                                                           (LPARAM)&DPHdr,
                                                           (LPDWORD)&Result) < 0)
                                {
                                     Result = -1;
                                     pNewThreadData->ErrorCode = GetLastError();
                                }
                                else
                                {
                                     Result = (Result == CPSUI_OK) ? IDOK : IDCANCEL;
                                }
                                pGLdrObj->DecUIRefCnt();
                            }
                            else
                            {
                                 Result = -1;
                                 pNewThreadData->ErrorCode = GetLastError();
                            }

                        }
                        else 
                        {
                            Result = pfnDocPropSheets(NULL, (LPARAM)&DPHdr);
                            if(Result<0)
                            {
                                pNewThreadData->ErrorCode = GetLastError();
                            }
                        }

                        //
                        // Here we try to adjust the required memory . Sometimes it is less
                        //
                        if((PDEVMODE)*ppClonedDevModeOut)
                        {
                             if((DWORD)(((PDEVMODE)*ppClonedDevModeOut)->dmSize + 
                                        ((PDEVMODE)*ppClonedDevModeOut)->dmDriverExtra) < 
                                *pClonedDevModeOutSize)
                             {
                                  *pTouchedDevModeSize = (((PDEVMODE)*ppClonedDevModeOut)->dmSize +
                                                         ((PDEVMODE)*ppClonedDevModeOut)->dmDriverExtra);
                             }
                             else
                             {
                                  *pTouchedDevModeSize = *pClonedDevModeOutSize;
                             }
                        }

                        if(hPrinter)
                        {
                             ClosePrinter(hPrinter);
                        }
                   }
                   else
                   {
                        pNewThreadData->ErrorCode = GetLastError();
                   }
              }
              else
              {
                   pNewThreadData->ErrorCode = GetLastError();
              }
              FreeLibrary(hWinSpool);
         }
         else
         {
              pNewThreadData->ErrorCode = GetLastError();
         }
         if(hWnd && (fMode & DM_PROMPT))
         {
              PostMessage(pNewThreadData->hWnd,WM_ENDDOCUMENTPROPERTIES,
                          (WPARAM)Result,
                          (LPARAM)pNewThreadData->ErrorCode);
         }
         pNewThreadData->RetVal = Result;
     }
     pGLdrObj->DecUIRefCnt();

     return 0;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: PrinUIDocumentProperties
     
    Description:
        Displays the driver specific properties
                     
    Parameters:
        HWND    hWnd                 : Parent Window Handle
        LPWSTR  PrinterName          : Printer Name
        PDWORD  ClonedDevModeOutSize : Output DevMode size
        LPBYTE* ClonedDevModeOut     : Output DevMode
        DWORD   DevModeSize          : Input DevMode Size
        LPBYTE  DevMode              : Input DevMode
        WORD    Capabilities         : Required Capabilites to Query for
        BOOL    ClonedDevModeOutFill : Required To fill output DevMode
        DWORD   fMode                : Mode Options
             
     Return Value:
        int RetVal : -1 in case of Failure
                   : Some value depending on fMode flag  and DevModes
                     and this might be posted to the client window in
                     case of running asynchronously
--*/
LONG                                            
TLoad64BitDllsMgr ::
PrintUIDocumentProperties(                     
    IN  ULONG_PTR  hWnd,                               
    IN  LPWSTR     pszPrinterName, 
    OUT PDWORD     pTouchedDevModeSize,
    OUT PDWORD     pClonedDevModeOutSize,               
    OUT LPBYTE     *ppClonedDevModeOut,
    IN  DWORD      DevModeSize,                        
    IN  LPBYTE     pDevMode,                            
    IN  BOOL       bClonedDevModeOutFill,               
    IN  DWORD      fMode,
    IN  DWORD      fExclusionFlags,
    OUT PDWORD     pErrorCode
    )
{

    LONG                RetVal        = -1;
    SDocPropsThreadData *pNewThrdData = NULL;
    RPC_STATUS          RpcStatus;

    
    if((RpcStatus = RpcImpersonateClient(0)) == RPC_S_OK)
    {
        RefreshLifeSpan();

        if(pNewThrdData = new SDocPropsThreadData)
        {
             pNewThrdData->hWnd                    = (HWND)hWnd;                   
             pNewThrdData->pszPrinterName          = pszPrinterName;            
             pNewThrdData->pClonedDevModeOutSize   = pClonedDevModeOutSize;   
             pNewThrdData->pTouchedDevModeSize     = pTouchedDevModeSize;
             pNewThrdData->ppClonedDevModeOut      = ppClonedDevModeOut;
             pNewThrdData->DevModeSize             = DevModeSize;            
             pNewThrdData->pDevMode                = pDevMode;                
             pNewThrdData->bClonedDevModeOutFill   = bClonedDevModeOutFill;   
             pNewThrdData->fMode                   = fMode;        
             pNewThrdData->fExclusionFlags         = fExclusionFlags;
             pNewThrdData->ErrorCode               = ERROR_SUCCESS;
             pNewThrdData->RetVal                  = -1;
             InternalPrintUIDocumentProperties((PVOID)pNewThrdData);

             RetVal      = pNewThrdData->RetVal;
             *pErrorCode = pNewThrdData->ErrorCode;

             delete pNewThrdData;
        }

        RpcStatus = RpcRevertToSelf();
    }
    else
    {
        *pErrorCode = RpcStatus;
    }

    return RetVal;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: AsyncDocumentProperties
             
    Description:
        Displays the driver specific UI in a separate sheet
                     
    Parameters:
        PVOID : Thread Data
                     
     Return Value:
        Always returns 0
--*/
DWORD 
TLoad64BitDllsMgr ::
InternalPrintUIDocumentProperties(
    PVOID pInThrdData
    )
{
                         
     DOCUMENTPROPERTYHEADER     DPHdr;
     HANDLE                     hPrinter              = NULL;
     SDocPropsThreadData        *pNewThreadData       = reinterpret_cast<SDocPropsThreadData *>(pInThrdData);    
     TLoad64BitDllsMgr          *pMgrInstance         = pNewThreadData->pMgrInstance;                       
     HWND                       hWnd                  = pNewThreadData->hWnd;                              
     LPWSTR                     pszPrinterName        = pNewThreadData->pszPrinterName;                       
     PDWORD                     pClonedDevModeOutSize = pNewThreadData->pClonedDevModeOutSize;              
     PDWORD                     pTouchedDevModeSize   = pNewThreadData->pTouchedDevModeSize;
     LPBYTE*                    ppClonedDevModeOut    = pNewThreadData->ppClonedDevModeOut;                  
     DWORD                      DevModeSize           = pNewThreadData->DevModeSize;                       
     LPBYTE                     pDevMode              = pNewThreadData->pDevMode;                           
     BOOL                       bClonedDevModeOutFill = pNewThreadData->bClonedDevModeOutFill;              
     DWORD                      fMode                 = pNewThreadData->fMode;                             
     DWORD                      fExclusionFlags       = pNewThreadData->fExclusionFlags;
     HMODULE                    hWinSpool             = NULL;
     PFNDOCPROPSHEETS           pfnDocPropSheets      = NULL;
     LONG                       Result                = -1;

     pGLdrObj->IncUIRefCnt();
     {
         if(hWinSpool = LoadLibrary(L"winspool.drv"))
         {
              if(pfnDocPropSheets = reinterpret_cast<PFNDOCPROPSHEETS>(GetProcAddress(hWinSpool,
                                                                                      "DocumentPropertySheets")))
              {
                   if(OpenPrinter(pszPrinterName,&hPrinter,NULL))
                   {
                        DPHdr.cbSize         = sizeof(DPHdr);
                        DPHdr.Reserved       = 0;
                        DPHdr.hPrinter       = hPrinter;
                        DPHdr.pszPrinterName = pszPrinterName;

                        if(bClonedDevModeOutFill)
                        {
                            DPHdr.pdmIn  = NULL;
                            DPHdr.pdmOut = NULL;
                            DPHdr.fMode  = 0;

                            DPHdr.cbOut = pfnDocPropSheets(NULL,
                                                           (LPARAM)&DPHdr);

                            *ppClonedDevModeOut = new BYTE[DPHdr.cbOut];
                        }
                        else
                        {
                            DPHdr.cbOut           = 0;
                            *ppClonedDevModeOut   = NULL;
                        }

                        *pClonedDevModeOutSize = DPHdr.cbOut;

                        PFNPRINTUIDOCUMENTPROPERTIES     pfnPrintUIDocumentProperties = NULL;
                        HMODULE                          hPrintUI                     = NULL;

                        if(hPrintUI = LoadLibrary(L"printui.dll"))
                        {
                            if(pfnPrintUIDocumentProperties = reinterpret_cast<PFNPRINTUIDOCUMENTPROPERTIES>(GetProcAddress(hPrintUI,
                                                                                                                            "DocumentPropertiesWrap")))
                            {
                                pGLdrObj->IncUIRefCnt();
                                Result = pfnPrintUIDocumentProperties(hWnd,
                                                                      hPrinter,
                                                                      pszPrinterName,
                                                                      (PDEVMODE)*ppClonedDevModeOut,
                                                                      (PDEVMODE)pDevMode,
                                                                      fMode,
                                                                      fExclusionFlags
                                                                     );

                                pNewThreadData->ErrorCode = GetLastError();

                                pGLdrObj->DecUIRefCnt();
                                //
                                // Here we try to adjust the required memory . Sometimes it is less
                                //
                                if((PDEVMODE)*ppClonedDevModeOut)
                                {
                                     if((DWORD)(((PDEVMODE)*ppClonedDevModeOut)->dmSize + 
                                                ((PDEVMODE)*ppClonedDevModeOut)->dmDriverExtra) < 
                                        *pClonedDevModeOutSize)
                                     {
                                          *pTouchedDevModeSize = (((PDEVMODE)*ppClonedDevModeOut)->dmSize +
                                                                 ((PDEVMODE)*ppClonedDevModeOut)->dmDriverExtra);
                                     }
                                     else
                                     {
                                          *pTouchedDevModeSize = *pClonedDevModeOutSize;
                                     }
                                }
                            }
                            FreeLibrary(hPrintUI);
                        }

                        if(hPrinter)
                        {
                             ClosePrinter(hPrinter);
                        }
                   }
                   else
                   {
                        pNewThreadData->ErrorCode = GetLastError();
                   }
              }
              else
              {
                   pNewThreadData->ErrorCode = GetLastError();
              }
              FreeLibrary(hWinSpool);
         }
         else
         {
              pNewThreadData->ErrorCode = GetLastError();
         }
         if(hWnd)
         {
              PostMessage(pNewThreadData->hWnd,WM_ENDPRINTUIDOCUMENTPROPERTIES,
                          (WPARAM)Result,
                          (LPARAM)pNewThreadData->ErrorCode);
         }
         pNewThreadData->RetVal = Result;
     }
     pGLdrObj->DecUIRefCnt();

     return 0;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: GetCurrSeesionId
             
    Description:
        returns the Current Session ID for terminal server 
        sessions
                     
    Parameters:
        None
                             
     Return Value:
        DWORD: Session ID     
--*/
DWORD
TLoad64BitDllsMgr ::
GetCurrSessionId() const
{   
    return m_CurrSessionId;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: GetMonitorUIActivationContext
             
    Description:
        This routine gets the monitor UI activation context and then
        activates the context.  If the monitor does not have an activation
        context in it's resource file it will activate the empty context
        for compatiblity with previous version of common control.
                     
    Parameters:
        pszUIDllName  - The name of the monitor ui DLL.
        phActCtx      - Pointer to the activation context handle
                             
     Return Value:
        DWORD: Error Code if any else ERROR_SUCCESS     

--*/

DWORD
TLoad64BitDllsMgr :: 
GetMonitorUIActivationContext(
    IN     LPWSTR    pszUIDllName,
    IN OUT HANDLE    *phActCtx,
    IN OUT ULONG_PTR *plActCtx,
    IN OUT BOOL      *pbActivated
    ) const
{
    DWORD  ErrorCode    = ERROR_SUCCESS;
    LPWSTR pszFullPath = NULL;

    if(!pszUIDllName)
    {
        ErrorCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        if(pszFullPath = new WCHAR[MAX_PATH])
        {
            ZeroMemory(pszFullPath,MAX_PATH*sizeof(WCHAR));
            if((ErrorCode = this->GetMonitorUIFullPath(pszUIDllName,pszFullPath)) == ERROR_SUCCESS)
            {
                ACTCTX  ActCtx;
        
                ZeroMemory(&ActCtx, sizeof(ActCtx));
        
                ActCtx.cbSize          = sizeof(ActCtx);
                ActCtx.dwFlags         = ACTCTX_FLAG_RESOURCE_NAME_VALID;
                ActCtx.lpSource        = pszFullPath;
                ActCtx.lpResourceName  = MAKEINTRESOURCE(ACTIVATION_CONTEXT_RESOURCE_ID);
        
                if((*phActCtx = CreateActCtx(&ActCtx)) == INVALID_HANDLE_VALUE)
                {
                    *phActCtx = ACTCTX_EMPTY;
                    if(!ActivateActCtx(*phActCtx,plActCtx))
                    {
                        ErrorCode = GetLastError();
                    }
                    else
                    {
                        *pbActivated = TRUE;
                    }
                }
            }
            delete [] pszFullPath;
        }
        else
        {
            ErrorCode = ERROR_OUTOFMEMORY;
        }
    }
    return ErrorCode;
}


/*++
    Function Name:
        TLoad64BitDllsMgr :: GetMonitorUIFullPath
             
    Description:
        Functioning returning the full path to create an activation context.  
        We have at this stage the monitor name not the full path.
                     
    Parameters:
        pszUIDllName  - The name of the monitor ui DLL.
        pszFullPath   - The FullPath 
                             
     Return Value:
        DWORD: Error Code if any else ERROR_SUCCESS     

--*/
DWORD
TLoad64BitDllsMgr :: 
GetMonitorUIFullPath(
    IN     LPWSTR pszUIDllName,
    IN OUT LPWSTR pszFullPath
    ) const
{
    DWORD ErrorCode   = ERROR_SUCCESS;
    PWSTR pszFileName = NULL; 
    DWORD CchCount;                   

    
    if( !pszFullPath && !pszUIDllName)
    {
        ErrorCode = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Get the monitor full path and the monitor name.
        // pszFullPath is already allocated of MAX_PATH size.
        //
        if (!GetFullPathName(pszUIDllName, MAX_PATH, pszFullPath, &pszFileName))                     
        {
            ErrorCode = GetLastError();
        }
        else
        {
            ErrorCode = ERROR_INVALID_NAME;
            //
            // Check to see if the monitor name came as a fully qualified path.
            //
            if (_wcsicmp(pszFullPath, pszUIDllName) == 0) 
            {
                //
                // We got a full path. Use it as it is.
                //
                ErrorCode = ERROR_SUCCESS;
            }
            else if (_wcsicmp(pszFileName, pszUIDllName) == 0) 
            {
                //
                // Xcv can return the monitor name. We want to build the full path 
                // out of the name and system directory.
                //    
                if (!(CchCount = GetSystemDirectory(pszFullPath, MAX_PATH)))                     
                {
                    ErrorCode = GetLastError();
                }
                else
                {
                    //
                    // Append the monitor name to the system directory.
                    //    
                    ErrorCode = StatusFromHResult(StringCchPrintf(pszFullPath + CchCount, 
                                                                  MAX_PATH - CchCount, 
                                                                  L"\\%s", 
                                                                  pszUIDllName));
                }

            }     
            
            //
            // Check if the file actually exists.
            //
            if (ErrorCode == ERROR_SUCCESS)
            {
                if (GetFileAttributes(pszFullPath) == INVALID_FILE_ATTRIBUTES)
                {
                    ErrorCode = GetLastError();
                }
            }
        }
    }

    return ErrorCode;
}

/*++
    Function Name:
        TLoad64BitDllsMgr :: ReleaseMonitorActivationContext
             
    Description:
        This function releases data relative to activating the monitor UI 
        context. It is responsible of releasing the monitor library as well 
        the monitor fusion activation context.  Note this function is called 
        in error cases when GetMonitorUI fails so all the parameters must be 
        checked for validity before use.
                     
    Parameters:
        hLib      - The handle of the monitor ui DLL.
        hActCtx   - The Activation context
        lActCtx   = The Activation Cookie 
                             
    Return Value:
        VOID     

--*/
VOID
TLoad64BitDllsMgr :: 
ReleaseMonitorActivationContext(
    IN HINSTANCE hLib    ,
    IN HANDLE    hActCtx ,
    IN ULONG_PTR lActCtx ,
    IN BOOL      bActivated
    ) const
{
    //
    // Release the monitor library.
    //
    if (hLib)
    {
        FreeLibrary(hLib);
    }

    //
    // If we have an activation cookie then deactivate this context
    //
    if (bActivated)
    {
        DeactivateActCtx(0 , lActCtx);
    }

    //
    // If we have created an activation context then release it.
    //
    if (hActCtx != INVALID_HANDLE_VALUE && hActCtx != ACTCTX_EMPTY)
    {
        ReleaseActCtx(hActCtx);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\ldmgr.hpp ===
#ifndef __LDMGR_HPP__
#define __LDMGR_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     ldmgr.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the declararion of classes necessary to 
     encapsulate the declarations and defintions and prototypes 
     required for the RPC surrogate used to load 64 bit dlls from
     within 32 bit apps.
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Jan-2000                                        
     
                                                                             
  Revision History:
--*/

#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

#ifndef __BASECLS_HPP__
#include "basecls.hpp"
#endif

#ifndef __PRTCFG_HPP__
#include "prtcfg.hpp"
#endif

#ifndef __DRVEVNT_HPP__
#include "drvevnt.hpp"
#endif

#ifndef __PRNTUIFN_HPP__
#include "prntuifn.hpp"
#endif

#ifndef __LPCMGR_HPP__
#include "lpcmgr.hpp"
#endif


#define MAX_CAPVAL         DC_MEDIATYPES

#define APPNAME            L"splwow64"
#define GDI_LPC_PORT_NAME  L"\\RPC Control\\UmpdProxy"

#define ACTIVATION_CONTEXT_RESOURCE_ID  123

class TLoad64BitDllsMgr : public TClassID, 
                          public TRefCntMgr , 
                          public TLd64BitDllsErrorHndlr,
                          public TPrinterDriver
{
    public:

    enum ELdMgrConstants
    {
        kMaxRPCPacketSize = 1024*1000
    };
    
    friend DWORD 
    TLoad64BitDllsMgr::
    MonitorSrvrLifeExpiration(
        IN PVOID pData
        );

    TLoad64BitDllsMgr(
        OUT HRESULT *phRes = NULL
        );

    ~TLoad64BitDllsMgr(
        VOID
        );

    HRESULT 
    QueryInterface(
        IN  REFIID InterfaceID,
        OUT PVOID  *ppInterface
        );

    DWORD
    Run();

    VOID
    RefreshLifeSpan(
        VOID
        );
    

    BOOL
    ExecuteMonitorOperation(
        IN  ULONG_PTR  hWnd,
        IN  LPWSTR     pszServerName,
        IN  LPWSTR     pszUIDllName,
        IN  LPWSTR     pszPortName,
        IN  EPortOp    Index,
        OUT PDWORD     pErrorCode
        );

    int 
    DeviceCapabilities(
        IN  LPWSTR  pszDeviceName,
        IN  LPWSTR  pszPortName,
        IN  WORD    Capabilites,
        IN  DWORD   DevModeSize,
        IN  LPBYTE  pDevMode,
        IN  BOOL    bClonedOutputFill,
        OUT PDWORD  pClonedOutputSize,
        OUT LPBYTE  *ppClonedOutput,
        OUT PDWORD  pErrorCode
        );

    LONG
    DocumentProperties(
        IN  ULONG_PTR   hWnd,                     
        IN  LPWSTR      pszPrinterName,               
        OUT PDWORD      pTouchedDevModeSize,
        OUT PDWORD      pClonedDevModeOutSize,      
        OUT LPBYTE      *ppClonedDevModeOut,          
        IN  DWORD       DevModeSize,               
        IN  LPBYTE      pDevMode,                   
        IN  BOOL        bClonedDevModeOutFill,      
        IN  DWORD       fMode,                      
        OUT PDWORD      pErrorCode
        );

    LONG
    PrintUIDocumentProperties(
        IN  ULONG_PTR   hWnd,                     
        IN  LPWSTR      pszPrinterName,               
        OUT PDWORD      pTouchedDevModeSize,
        OUT PDWORD      pClonedDevModeOutSize,      
        OUT LPBYTE      *ppClonedDevModeOut,          
        IN  DWORD       DevModeSize,               
        IN  LPBYTE      pDevMode,                   
        IN  BOOL        bClonedDevModeOutFill,      
        IN  DWORD       fMode,                      
        IN  DWORD       fExclusionFlags,
        OUT PDWORD      pErrorCode
        );

    VOID 
    IncUIRefCnt(
        VOID
        );

    VOID 
    DecUIRefCnt(
        VOID
        );

    DWORD 
    GetUIRefCnt(
        VOID
        )const;

    DWORD
    GetCurrSessionId(
        VOID
        ) const;
    
    struct SPORTADDTHREADDATA
    {
        PFNMONITORADD    pMonFnAdd;
        PFNMONITORFNS    pMonFns;
        HWND             hWnd;
        PCWSTR           pszServerName;
        PCWSTR           pszMonitorName;
        PCWSTR           pszPortName;
        PWSTR            *ppszRetPortName;
        HMODULE          hLib;
        HANDLE           hActCtx;
        ULONG_PTR        lActCtx;
        BOOL             bActivated;
    };
    typedef struct SPORTADDTHREADDATA SPortAddThreadData;

    struct SDOCPROPSTHREADDATA
    {
        HWND              hWnd;                               
        LPWSTR            pszPrinterName;         
        PDWORD            pTouchedDevModeSize;
        PDWORD            pClonedDevModeOutSize;
        LPBYTE            *ppClonedDevModeOut;          
        DWORD             DevModeSize;               
        LPBYTE            pDevMode;                   
        TLoad64BitDllsMgr *pMgrInstance;
        DWORD             fMode;                               
        DWORD             fExclusionFlags;
        DWORD             ErrorCode;
        LONG              RetVal;
        BOOL              bClonedDevModeOutFill;
    };
    typedef struct SDOCPROPSTHREADDATA SDocPropsThreadData;

    enum ETime
    {
        KOneMinute  = 60000,
        KTwoMinutes = 120000
    };

    protected:

    DWORD
    StartLdrRPCServer(
        VOID
        );
    
    DWORD
    StopLdrRPCServer(
        VOID
        );

    static DWORD 
    MonitorSrvrLifeExpiration(
        IN PVOID pData
        );

    static DWORD
    AddPortUI(
        IN PVOID pInThrdData
        );

    static DWORD
    DeletePortUI(
        IN PVOID pInThrdData
        );
    
    static DWORD
    ConfigurePortUI(
        IN PVOID pInThrdData
        );

    DWORD
    InternalDocumentProperties(
        IN PVOID pInThrdData
        );

    DWORD
    InternalPrintUIDocumentProperties(
        IN PVOID pInThrdData
        );

    BOOL
    DevCapFillsOutput(
        IN DWORD Capabilities
        ) const;

    DWORD
    CalcReqSizeForDevCaps(
        IN DWORD CapNum,
        IN DWORD Capabilites
        ) const;

    DWORD 
    SpinPortOperationThread(
        IN HWND                   hWnd,
        IN LPWSTR                 pszServerName,
        IN LPWSTR                 pszName,
        IN PMONITORUI             pMonitorUI,
        IN EPortOp                Index,
        IN LPTHREAD_START_ROUTINE pThrdFn,
        IN HMODULE                hLib,
        IN HANDLE                 hActCtx,
        IN ULONG_PTR              lActCtx,
        IN BOOL                   bActivated
        ) const;

    DWORD
    GetMonitorUIActivationContext(
        IN     LPWSTR    pszUIDllName,
        IN OUT HANDLE    *phActCtx,
        IN OUT ULONG_PTR *plActCtx,
        IN OUT BOOL      *pActivated
        ) const;

    DWORD
    GetMonitorUIFullPath(
        IN     LPWSTR pszUIDllName,
        IN OUT LPWSTR pszFullPath
        ) const;


    VOID
    ReleaseMonitorActivationContext(
        IN HINSTANCE hLib    ,
        IN HANDLE    hActCtx ,
        IN ULONG_PTR lActCtx,
        IN BOOL      bActivated
        ) const;


    private:

    //
    // Some helper functions internal to the class
    //
    VOID 
    LockSelf(
        VOID
        );

    VOID 
    ReleaseSelf(
        VOID
        );

    BOOL
    StillAlive(
        VOID
        );

    //
    // The data encapsulated by the control.
    // This control has no data pertinent to itself. It only
    // encapsulates data pertinent to the synchronization of
    // of the requesting clients and timing out the whole 
    // control . It also has a session ID which identifies its
    // instantion across different sessions for Terminal Server.
    // Added to it also is a Port connection handle for GDI UMPD
    // thunking
    //
    DWORD                m_CurrSessionId;
    DWORD                m_UIRefCnt;
    DWORD                m_ExpirationTime;
    SYSTEMTIME           m_LastTransactionTime;
    CRITICAL_SECTION     m_LdMgrLock;
};

#endif //__LDMGR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\precomp.h ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     precomp.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the startup code for the
     surrogate rpc server used to load 64 bit dlls
     in 32 bit apps
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 18 January 2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#define MAX_STATIC_ALLOC     1024

#ifndef MODULE
#define MODULE "LD32IN64:"
#define MODULE_DEBUG Ld64In32Debug
#endif

#ifdef __cplusplus
extern "C"
{
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#ifdef __cplusplus
}
#endif
#include <windef.h>
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <winddi.h>
#include <rpc.h>
#include <strsafe.h>
#include <splcom.h>
#include <time.h>
#include "winddiui.h"


#include <splwow64.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\lpcmgr.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     TLPCMgr.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file inlcuded the implementation of the class
     that processes both Connection and Communication Requests
     for the LPC port managing the Thunking between 32-bit and
     64-bit processes.        
  
  Author:                                                                     
     Khaled Sedky (khaleds) 19-Jun-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif
                
                
#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif

/* ------------------------------------ */
/* Implemetation of class TLPCMgr        */
/* ------------------------------------ */


/*++
    Function Name:
        TLPCMgr :: TLPCMgr
     
    Description:
        Constructor of the LPC Thunking management object
     
    Parameters:
        TLoad64BitDllsMgr* : Pointer to the main loader object
                             which manage the process
        
    Return Value:
        None
--*/
TLPCMgr ::
TLPCMgr(
    IN TLoad64BitDllsMgr* pIpLdrObj
    ) :
    m_pLdrObj(pIpLdrObj),
    m_UMPDLPCConnPortHandle(NULL),
    TClassID("TLPCMgr")

{
    //
    // If we cann't create the list here. It would be a better idea
    // if we just continue for this session with leaks other than
    // failing the wow64 printing for this session
    //
    m_pCnctdClients = NULL;

    if(!(m_pCnctdClients = 
         new TLstMgr<TConnectedClientsInfo,ULONG_PTR>(TLstMgr<TConnectedClientsInfo,ULONG_PTR>::KUniqueEntries)))
    {
        DBGMSG(DBG_WARN, ("TLPCMgr ctor failer to create the list of connected Clients\n",GetLastError()));
    }
    m_pLdrObj->AddRef();
}


/*++
    Function Name:
        TLPCMgr :: ~TLPCMgr
     
    Description:
        Destructor of the Printer(Driver) Event object    
     
    Parameters:
        None        
        
    Return Value:
        None
--*/
TLPCMgr ::
~TLPCMgr(
    VOID
    )
{
    if(m_pCnctdClients)
    {
        delete m_pCnctdClients;
    }

    m_pLdrObj->Release();
}


DWORD
TLPCMgr ::
GetCurrSessionId(
    VOID
    ) const
{
    return m_CurrSessionId;
}


VOID
TLPCMgr ::
SetCurrSessionId(
    DWORD InID
    )
{
    m_CurrSessionId = InID;
}


VOID
TLPCMgr ::
SetPFN(
    PFNGDIPRINTERTHUNKPROC InPFN
    )
{
    m_pfn = InPFN;
}

PFNGDIPRINTERTHUNKPROC
TLPCMgr ::
GetPFN(
    VOID
    )const
{
    return m_pfn;
}

    
/*++
    Function Name:
        TLPCMgr :: GetUMPDLPCConnPortHandlePtr
             
    Description:
        returns the address of the LPC port
                     
    Parameters:
        None
                             
     Return Value:
        Handle* : LPC Port Handle     
--*/
HANDLE*
TLPCMgr ::
GetUMPDLPCConnPortHandlePtr() 
{   
    return reinterpret_cast<HANDLE*>(&m_UMPDLPCConnPortHandle);
}


TLoad64BitDllsMgr* 
TLPCMgr ::
GetLdrObj(
    VOID
    ) const
{
    return m_pLdrObj;
}


HANDLE
TLPCMgr ::
GetUMPDLpcConnPortHandle(
    VOID
    )const
{
    return m_UMPDLPCConnPortHandle;
}


/*++
    Function Name:
        TLPCMgr :: InitUMPDLPCServer
             
    Description:
        Creates the Thread handling LPC operations for 
        GDI thunking 
                     
    Parameters:
        None
                             
     Return Value:
        DWORD ErrorCode : ERROR_SUCCESS in case of success
                          LastError in case of failure     
--*/
DWORD
TLPCMgr ::
InitUMPDLPCServer(
    VOID
    )
{
    DWORD             ThnkThreadId   = 0;
    HANDLE            hThnkThrd      = NULL;
    SGDIThnkThrdData  SThrdData      = {0};
    HANDLE            hThnkSyncEvent = NULL;
    DWORD             ErrorCode      = ERROR_SUCCESS;

    if(hThnkSyncEvent = CreateEvent(NULL,FALSE,FALSE,NULL))
    {
        SThrdData.hEvent    = hThnkSyncEvent;
        SThrdData.pData     = reinterpret_cast<ULONG_PTR*>(this);
        SThrdData.ErrorCode = ERROR_SUCCESS;

        //
        // At this stage we spin a new Thread which creates the LPC
        // port and starts waiting on both connection and communication
        // requests
        // 
        if(hThnkThrd  =  CreateThread(NULL,0,
                                      GDIThunkingVIALPCThread,
                                      &SThrdData,
                                      0,
                                      &ThnkThreadId))
        {
            CloseHandle(hThnkThrd);
            WaitForSingleObject(hThnkSyncEvent,INFINITE);

            if(!*(GetUMPDLPCConnPortHandlePtr()))
            {
                //
                // If here then we failed to create the LPC port
                //
                ErrorCode = SThrdData.ErrorCode;
                DBGMSG(DBG_WARN, ("Failed to create the LPC port with error %u\n",ErrorCode));
            }
        }
        else
        {
            ErrorCode = GetLastError();
            DBGMSG(DBG_WARN, ("Failed to spin the GDI Thunking thread with Error %u\n",ErrorCode));
        }
        CloseHandle(hThnkSyncEvent);
    }
    else
    {
        ErrorCode = GetLastError();
        DBGMSG(DBG_WARN, ("Failed to create the synchronization event with Error %u\n",ErrorCode));
    }

    return ErrorCode;
}

DWORD
TLPCMgr ::
ProcessConnectionRequest(
    IN PPORT_MESSAGE pMsg
    )
{
    NTSTATUS Status;
    HANDLE   CommunicationPortHandle = NULL;

    DBGMSG(DBG_WARN,
           ("Processing Connection Request\n"));

    //
    // Since this is a new connection then we carry out 2 work items
    // 1. Add the Client to the list of connected clients
    // 2. Allocate a Port Context to be used by LPC for consecutive 
    // operations on this port.
    //
    if(TClientInfo *pClientInfoInstant = new TClientInfo(pMsg->ClientId.UniqueThread))
    {
        //
        // While Accepting the connection we also set in the communication Port
        // context used for communication with this particular client, the refrence
        // to the clients info which saves the communication port handle and other
        // data
        //
        Status = NtAcceptConnectPort(&CommunicationPortHandle,
                                     (PVOID)pClientInfoInstant,
                                     pMsg,
                                     1,
                                     NULL,
                                     NULL);
        if(NT_SUCCESS(Status))
        {
            pClientInfoInstant->SetPort(CommunicationPortHandle);

            Status = NtCompleteConnectPort(CommunicationPortHandle);

            if(!NT_SUCCESS(Status))
            {
                DBGMSG(DBG_WARN,
                       ("TLPCMgr::ProcessConnectionRequest failed to complete port connection - %u \n",Status));

            }
            else
            {
                if(m_pCnctdClients)
                {
                    //
                    // We maintain an internal list of all connected clients based on their Thread and 
                    // Process ID . So things look like
                    //
                    //
                    //                                    -----            -----            -----
                    //     List of Processes (Apps)----> |    | ----------|    | ----------|    |
                    //                                   |    |           |    |           |    |
                    //                                    -----            -----            ----- 
                    //                                     |
                    //                                     |
                    //                                     |
                    //                                 ---------
                    //                                |        |
                    //                                 ---------
                    //                                    |
                    //                                    |
                    //                                    |
                    //                                ---------
                    //             Thread/App -----> |        |
                    //                                ---------
                    //
                    TLstNd<TConnectedClientsInfo,ULONG_PTR> *pNode = NULL;

                    if((pNode = m_pCnctdClients->ElementInList((ULONG_PTR)pMsg->ClientId.UniqueProcess)) ||
                       (pNode = m_pCnctdClients->AppendListByElem((ULONG_PTR)pMsg->ClientId.UniqueProcess)))
                    {
                        ((*(*pNode)).GetPerClientPorts())->AppendListByElem(pClientInfoInstant);
                    }
                    else
                    {
                        Status = STATUS_NO_MEMORY;
                    }
                }
                m_pLdrObj->IncUIRefCnt();
            }
        }
        else
        {
            DBGMSG(DBG_WARN,
                   ("TLPCMgr :: ProcessConnectionRequest failed to accept port connection - %u \n",Status));
            delete pClientInfoInstant;
        }
    }
    else
    {
        Status = STATUS_NO_MEMORY;
        DBGMSG(DBG_WARN,
               ("TLPCMgr :: ProcessConnectionRequest failed to create the CleintInfo for Port Context - %u \n",Status));

    }

    return !!Status;
}

DWORD
TLPCMgr ::
ProcessRequest(
    IN PSPROXY_MSG pMsg
    ) const
{
    ULONG DataSize;
    DWORD ErrorCode = ERROR_SUCCESS;

    DBGMSG(DBG_WARN,
           ("Processing Request\n"));


    if (((DataSize = pMsg->Msg.u1.s1.DataLength) == (sizeof(*pMsg) - sizeof(pMsg->Msg))) &&
         m_pfn)
    {
        UMTHDR*  pUmHdr = reinterpret_cast<UMTHDR*>(reinterpret_cast<PSPROXYMSGEXTENSION>(pMsg->MsgData)->pvIn);
        PVOID    pvOut  = reinterpret_cast<PSPROXYMSGEXTENSION>(pMsg->MsgData)->pvOut;
        ULONG    cjOut  = reinterpret_cast<PSPROXYMSGEXTENSION>(pMsg->MsgData)->cjOut;

        DBGMSG(DBG_WARN,("ProcessRequest handling thunk %d \n",pUmHdr->ulType));

        m_pfn(pUmHdr,
              pvOut, 
              cjOut);
    }
    else
    {
        ErrorCode = ERROR_INVALID_PARAMETER;
        DBGMSG(DBG_WARN,
               ("Failed to process the client request %u\n",ErrorCode));
    }

    return ErrorCode;
}

DWORD
TLPCMgr ::
ProcessClientDeath(
    IN PSPROXY_MSG pMsg
    )
{
    DWORD                                    ErrorCode = ERROR_SUCCESS;
    TLstNd<TConnectedClientsInfo,ULONG_PTR>  *pNode     = NULL;

    DBGMSG(DBG_WARN,
           ("Processing Client Death \n"));


    if(pNode = 
       (GetConnectedClients())->ElementInList((ULONG_PTR)pMsg->Msg.ClientId.UniqueProcess))
    {
        if(((*(*pNode)).GetCurrentState()) == TConnectedClientsInfo::KClientAlive)
        {
            ((*(*pNode)).SetCurrentState(TConnectedClientsInfo::KClientDead));
        }
    }
    else
    {
        ErrorCode = ERROR_INVALID_PARAMETER;
        DBGMSG(DBG_WARN,
               ("Failed to Process Client Death \n",ErrorCode));
    }

    return(ErrorCode);
}


DWORD
TLPCMgr ::
ProcessPortClosure(
    IN PSPROXY_MSG pMsg,
    IN HANDLE      hPort
    )
{
    DWORD                                    ErrorCode = ERROR_SUCCESS;
    TLstNd<TConnectedClientsInfo,ULONG_PTR>  *pNode      = NULL;

    DBGMSG(DBG_WARN,
           ("Processing Port Closure \n"));


    if(pNode = 
       (GetConnectedClients())->ElementInList((ULONG_PTR)pMsg->Msg.ClientId.UniqueProcess))
    {
        ((*(*pNode)).GetPerClientPorts())->RmvElemFromList((HANDLE)hPort);

        if(!((*(*pNode)).GetPerClientPorts())->GetNumOfListNodes() &&
           (((*(*pNode)).GetCurrentState()) == TConnectedClientsInfo::KClientDead))
        {
            m_pCnctdClients->RmvElemFromList((ULONG_PTR)pMsg->Msg.ClientId.UniqueProcess);
        }
        m_pLdrObj->DecUIRefCnt();
    }
    else
    {
        ErrorCode = ERROR_INVALID_PARAMETER;
        {
            DBGMSG(DBG_WARN,
                   ("Failed to Process Port Closure \n",ErrorCode));

        }
    }

    return(ErrorCode);
}


TLstMgr<TLPCMgr::TConnectedClientsInfo,ULONG_PTR>* 
TLPCMgr::
GetConnectedClients(
    VOID
    ) const
{
    return m_pCnctdClients;
}



TLPCMgr::
TClientInfo::
TClientInfo() :
    m_UniqueThreadID(NULL),    
    m_hPort(NULL),         
    m_SanityChkMagic(UMPD_SIGNATURE)
{
}


TLPCMgr::
TClientInfo::
TClientInfo(
    IN const HANDLE& InPort
    ) :
    m_UniqueThreadID(NULL),
    m_hPort(InPort),
    m_SanityChkMagic(UMPD_SIGNATURE)
{

}


TLPCMgr::
TClientInfo::
TClientInfo(
    IN const ULONG_PTR& InThreadID
    ) :
    m_UniqueThreadID(InThreadID),
    m_hPort(NULL),
    m_SanityChkMagic(UMPD_SIGNATURE)
{

}


TLPCMgr::
TClientInfo::
TClientInfo(
     IN const TClientInfo& InInfo
     ) :
    m_UniqueThreadID(InInfo.m_UniqueThreadID),
    m_hPort(InInfo.m_hPort),
    m_SanityChkMagic(InInfo.m_SanityChkMagic)
{

}


TLPCMgr::
TClientInfo::
~TClientInfo(
    VOID
    )
{

}


const TLPCMgr::TClientInfo&
TLPCMgr::
TClientInfo::
operator=(
    IN const TClientInfo& InInfo
    )
{
    if(&InInfo != this)
    {
        m_UniqueThreadID   = InInfo.m_UniqueThreadID;
        m_hPort            = InInfo.m_hPort;
        m_SanityChkMagic   = InInfo.m_SanityChkMagic;
    }

    return *this;
}


BOOL
TLPCMgr::
TClientInfo::
operator==(
    IN const TClientInfo& InInfo
    ) const
{
    return m_hPort == InInfo.m_hPort;
}


BOOL
TLPCMgr::
TClientInfo::
operator==(
    IN const HANDLE& InPort
    ) const
{
    return m_hPort == InPort;
}


BOOL
TLPCMgr::
TClientInfo::
operator!(
    VOID
    ) const
{
    return (m_hPort && m_SanityChkMagic == UMPD_SIGNATURE);        
}


VOID
TLPCMgr::
TClientInfo::
SetValidity(
    DWORD 
    )
{

}

BOOL
TLPCMgr::
TClientInfo::
Validate(
    VOID
    ) const
{
    return (m_hPort && m_SanityChkMagic == UMPD_SIGNATURE);
}

VOID
TLPCMgr::
TClientInfo::
SetPort(
    IN HANDLE InPort
    )
{
    m_hPort = InPort;
}

HANDLE
TLPCMgr::
TClientInfo::
GetPort(
    VOID
    ) const
{
    return m_hPort;
}



TLPCMgr::
TConnectedClientsInfo::
TConnectedClientsInfo() :
    m_UniqueProcessID(NULL),
    m_CurrentState(KClientAlive)
{
    m_pPerClientPorts = new TLstMgr<TClientInfo,HANDLE>(TLstMgr<TClientInfo,HANDLE>::KUniqueEntries);
}


TLPCMgr::
TConnectedClientsInfo::
TConnectedClientsInfo(
    IN const ULONG_PTR& InProcess
    ) :
    m_UniqueProcessID(InProcess),
    m_CurrentState(KClientAlive)
{
    m_pPerClientPorts = new TLstMgr<TClientInfo,HANDLE>(TLstMgr<TClientInfo,HANDLE>::KUniqueEntries);
}


TLPCMgr::
TConnectedClientsInfo::
TConnectedClientsInfo(
     IN const TClientInfo& InInfo
     )
{
    //
    // I am not sure if I want this at this stage or not
    // especially with the required deep copy for the list
    // of ports.
    //
}


TLPCMgr::
TConnectedClientsInfo::
~TConnectedClientsInfo()
{
    if(m_pPerClientPorts)
    {
        delete m_pPerClientPorts;
    }
}


const TLPCMgr::TConnectedClientsInfo&
TLPCMgr::
TConnectedClientsInfo::
operator=(
    IN const TConnectedClientsInfo& InInfo
    )
{
    if(&InInfo != this)
    {
        //
        // Also here I am not sure whether I want to implement a deep copy for the
        // list or not
        // (TO BE IMPLEMENTED LATER)
        //
    }
    return *this;
}


BOOL
TLPCMgr::
TConnectedClientsInfo::
operator==(
    IN const TConnectedClientsInfo& InInfo
    ) const
{
    return (m_UniqueProcessID == InInfo.m_UniqueProcessID);
}


BOOL
TLPCMgr::
TConnectedClientsInfo::
operator==(
    IN const ULONG_PTR& InProcess
    ) const
{
    return m_UniqueProcessID == InProcess;
}


BOOL
TLPCMgr::
TConnectedClientsInfo::
operator!(
    VOID
    ) const
{
    return !!m_UniqueProcessID;        
}


VOID
TLPCMgr::
TConnectedClientsInfo::
SetValidity(
    DWORD 
    )
{

}

BOOL
TLPCMgr::
TConnectedClientsInfo::
Validate(
    VOID
    ) const
{
    //
    // Still (TO BE IMPLEMENTED)
    // never being called
    //
    return FALSE;
}


TLstMgr<TLPCMgr::TClientInfo,HANDLE>*
TLPCMgr::
TConnectedClientsInfo::
GetPerClientPorts(
    VOID
    ) const
{
    return m_pPerClientPorts;
}

ULONG_PTR
TLPCMgr::
TConnectedClientsInfo::
GetUniqueProcessID(
    VOID
    ) const
{
    return m_UniqueProcessID;
}

VOID
TLPCMgr::
TConnectedClientsInfo::
SetCurrentState(
    TLPCMgr::TConnectedClientsInfo::EClientState InState
    )
{
    m_CurrentState = InState;
}

TLPCMgr::
TConnectedClientsInfo::
EClientState
TLPCMgr::
TConnectedClientsInfo::
GetCurrentState(
    VOID
    ) const
{
    return m_CurrentState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\prntuifn.hpp ===
#ifndef __PRNTUIFN_HPP__
#define __PRNTUIFN_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     prntuifn.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the declararion of the class
     dealing printui functionality and it currently contains
     the following interfaces
     o QueueCreate
     o PrinterPropPages
     o DocumentDefaults
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 31-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
--*/
#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

#ifndef __BASECLS_HPP__
#include "basecls.hpp"
#endif

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

//
// Forward declarations
//
class TLoad64BitDllsMgr;

class TPrintUIMgr : public TClassID,
                    public TLd64BitDllsErrorHndlr,
                    public TRefCntMgr
{
    public:

    TPrintUIMgr(
        IN TLoad64BitDllsMgr *pIpLdrObj
        );

    ~TPrintUIMgr(
        VOID
        );

    DWORD 
    QueueCreate(
        IN HWND    hWnd,
        IN LPCWSTR pszPrinterName,
        IN INT     CmdShow,
        IN LPARAM  lParam
        );

    DWORD 
    PrinterPropPages(
        IN HWND    hWnd,
        IN LPCWSTR pszPrinterName,
        IN INT     CmdShow,
        IN LPARAM  lParam
        );

    DWORD 
    DocumentDefaults(
        IN HWND    hWnd,
        IN LPCWSTR pszPrinterName,
        IN INT     CmdShow,
        IN LPARAM  lParam
        );

    DWORD 
    PrinterSetup(
        IN     HWND    hWnd,
        IN     UINT    uAction,
        IN     UINT    cchPrinterName,
        IN OUT LPWSTR  pszPrinterName,
           OUT UINT*   pcchPrinterName,
        IN     LPCWSTR pszServerName
        );

    DWORD 
    ServerPropPages(
        IN HWND    hWnd,
        IN LPCWSTR pszPrinterName,
        IN INT     CmdShow,
        IN LPARAM  lParam
        );

    static DWORD
    AsyncPrintUIMethod(
        IN PVOID InThrdData
        );

    enum EPrintUIOp
    {
        KQueueCreateOp = 0,
        KPrinterPropPagesOp,
        KDocumentDefaultsOp,
        KServerPropPagesOp
    };

    struct SPRINTUITHREADDATA
    {
        HWND                    hWnd;
        LPCWSTR                 pszName;
        LPARAM                  lParam;
        HANDLE                  hLib;
        TLoad64BitDllsMgr       *pLdrObj;
        PFNPRINTUIMETHOD        pfn;  
        TPrintUIMgr::EPrintUIOp Op;
        int                     CmdShow;
    };
    typedef struct SPRINTUITHREADDATA SPrintUIThreadData;

    struct SPRINTERSETUPTHRDDATA
    {
        HWND                    hWnd;
        LPWSTR                  pszPrinterName;
        LPCWSTR                 pszServerName;
        HANDLE                  hLib;
        TLoad64BitDllsMgr       *pLdrObj;
        UINT*                   pcchPrinterName;
        PFNPRINTUIPRINTERSETUP  pfn;  
        UINT                    uAction;
        UINT                    cchPrinterName;
    };
    typedef struct SPRINTERSETUPTHRDDATA SPrinterSetupThrdData;

    protected:
    DWORD 
    PrintUIMethod(
        IN LPCSTR                  Method,
        IN HWND                    hWnd,
        IN LPCWSTR                 pszName,
        IN INT                     CmdShow,
        IN LPARAM                  lParam,
        IN LPTHREAD_START_ROUTINE  pThrdFn,
        IN TPrintUIMgr::EPrintUIOp Op
        );

    private:
    
    HWND
    GetForeGroundWindow(
        VOID
        );

    TLoad64BitDllsMgr   *m_pLdrObj;
};

#endif //__PRNTUIFN_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\lpcmgr.hpp ===
#ifndef __LPCMGR_HPP__
#define __LPCMGR_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     TLPCMgr.hpp                                                             
                                                                              
  Abstract:                                                                   
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 19-Jun-2000                                        
     
                                                                             
  Revision History:                                                           
--*/
#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

#ifndef __BASECLS_HPP__
#include "basecls.hpp"
#endif

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif

#ifndef __GDITHNK_HPP__
#include "gdithnk.hpp"
#endif

#ifndef __GOLLMGR_HPP__
#include "collmgr.hpp"
#endif

//
// "UMPD"
//
#define UMPD_SIGNATURE 0X554D5044

//
// Forward declarations
//
class TLoad64BitDllsMgr;

class TLPCMgr : public TClassID,
                public TLd64BitDllsErrorHndlr,
                public TRefCntMgr
{
    public:

    //
    // Forward declaration of embedded classes
    //
    class TClientInfo;
    class TConnectedClientsInfo;

    TLPCMgr(
        IN TLoad64BitDllsMgr* pIpLdrObj
        );

    ~TLPCMgr(
        VOID
        );

    HANDLE*
    GetUMPDLPCConnPortHandlePtr(
        VOID
        );

    HANDLE
    GetUMPDLpcConnPortHandle(
        VOID
        )const;

    VOID
    SetCurrSessionId(
        DWORD InID
        );

    DWORD
    GetCurrSessionId(
        VOID
        ) const;

    DWORD
    InitUMPDLPCServer(
        VOID
        );

    VOID
    SetPFN(
        PFNGDIPRINTERTHUNKPROC pFN
        );

    PFNGDIPRINTERTHUNKPROC
    GetPFN(
        VOID
        ) const;

    TLoad64BitDllsMgr* 
    GetLdrObj(
        VOID
        ) const;

    DWORD
    ProcessConnectionRequest(
        IN PPORT_MESSAGE pMsg
        );

    DWORD
    ProcessRequest(
        IN PSPROXY_MSG pMsg
        ) const;

    DWORD
    ProcessClientDeath(
        IN PSPROXY_MSG pMsg
        );

    DWORD
    ProcessPortClosure(
        IN PSPROXY_MSG pMsg,
        IN HANDLE     hPort
        );
    
    TLstMgr<TLPCMgr::TConnectedClientsInfo,ULONG_PTR>* 
    GetConnectedClients(
        VOID
        ) const;



    //
    // We define here 2 classes which encapsulate the connection
    // information for all Clients and those specific/client
    //
    class TClientInfo : public TGenericElement
    {
        //
        // Public methods
        //
        public:

        TClientInfo(
            VOID
            );

        TClientInfo(
            IN const HANDLE&
            );

        TClientInfo(
            IN const ULONG_PTR&
            );

        TClientInfo(
            IN const TLPCMgr::TClientInfo&
            );
        
        ~TClientInfo(
            VOID
            );

        const TClientInfo&
        operator=(
            IN const TLPCMgr::TClientInfo&
            );

        BOOL
        operator==(
            IN const TLPCMgr::TClientInfo&
            ) const;

        BOOL
        operator==(
            IN const HANDLE&
            ) const;

        BOOL
        operator!(
            VOID
            ) const;

        VOID
        SetValidity(
            DWORD 
            );

        BOOL
        Validate(
            VOID
            ) const;

        VOID
        SetPort(
            IN HANDLE InPort
            );

        HANDLE
        GetPort(
            VOID
            ) const;

        //
        // Private members and helper functions (if any)
        //
        private:

        ULONG_PTR  m_UniqueThreadID;
        HANDLE     m_hPort;
        DWORD      m_SanityChkMagic;
    };

    
    class TConnectedClientsInfo : public TGenericElement  
    {
        //
        // Public methods
        //
        public:

        enum EClientState
        {
            KClientDead  = 0,
            KClientAlive = 1
        };

        TConnectedClientsInfo(
            VOID
            );

        TConnectedClientsInfo(
            IN const ULONG_PTR&
            );

        TConnectedClientsInfo(
            IN const TClientInfo&
            );

        ~TConnectedClientsInfo(
            VOID
            );

        const TConnectedClientsInfo&
        operator=(
            IN const TConnectedClientsInfo&
            );

        BOOL
        operator==(
            IN const TConnectedClientsInfo&
            ) const;

        BOOL
        operator==(
            IN const ULONG_PTR&
            ) const;

        BOOL
        operator!(
            VOID
            ) const;

        VOID
        SetValidity(
            DWORD 
            );

        BOOL
        Validate(
            VOID
            ) const;

        TLstMgr<TLPCMgr::TClientInfo,HANDLE>*
        GetPerClientPorts(
            VOID
            ) const;

        ULONG_PTR
        GetUniqueProcessID(
            VOID
            ) const;

        VOID
        SetCurrentState(
            TConnectedClientsInfo::EClientState
            );

        TConnectedClientsInfo::EClientState 
        GetCurrentState(
            VOID
            ) const;

        //
        // Private members and helper functions (if any)
        //
        private:

        TConnectedClientsInfo::EClientState m_CurrentState;
        ULONG_PTR                           m_UniqueProcessID;
        TLstMgr<TClientInfo,HANDLE>         *m_pPerClientPorts;
    };


    private:
    TLoad64BitDllsMgr                        *m_pLdrObj;
    DWORD                                    m_CurrSessionId;
    HANDLE                                   m_UMPDLPCConnPortHandle;
    PFNGDIPRINTERTHUNKPROC                   m_pfn;
    TLstMgr<TConnectedClientsInfo,ULONG_PTR> *m_pCnctdClients;
};

#endif //__LPCMGR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\prntuifn.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     prntuifn.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the implementation for the Print UI
     class                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 31-Jan-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop

#ifndef __PRNTUIFN_HPP__
#include "prntuifn.hpp"
#endif

#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif
                
                
#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif


/* --------------------------------- */
/* Implemetation of class TPrintUIMgr */
/* --------------------------------- */


/*++
    Function Name:
        TPrintUIMgr :: TPrintUIMgr
     
    Description:
        Contructor of Print UI functions intstatiation 
        object
     
    Parameters:
        None
        
    Return Value:
        None
--*/
TPrintUIMgr ::
TPrintUIMgr(
    IN TLoad64BitDllsMgr* pIpLdrObj
    ) :
    m_pLdrObj(pIpLdrObj),
    TClassID("TPrintUIMgr")
{
    m_pLdrObj->AddRef();
}


/*++
    Function Name:
        TPrintUIMgr :: ~TPrintUIMgr
     
    Description:
        Destructor of Print UI functions intstatiation 
        object
     
    Parameters:
        None
        
    Return Value:
        None
--*/
TPrintUIMgr ::
~TPrintUIMgr()
{
    m_pLdrObj->Release();
}


/*++
    Function Name:
        TPrintUIMgr :: QueueCreate
     
    Description:
        Creates a printer queue
            
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD 
TPrintUIMgr ::
QueueCreate(
    IN HWND    hWnd,
    IN LPCWSTR pszPrinterName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
    return PrintUIMethod("vQueueCreate",
                         hWnd,
                         pszPrinterName,
                         CmdShow,
                         lParam,
                         AsyncPrintUIMethod,
                         TPrintUIMgr::KQueueCreateOp);

}


/*++
    Function Name:
        TPrintUIMgr :: PrinterPropPages
     
    Description:
        This function opens the property sheet of specified printer.            
        
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD 
TPrintUIMgr ::
PrinterPropPages(
    IN HWND    hWnd,
    IN LPCWSTR pszPrinterName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
    return PrintUIMethod("vPrinterPropPages",
                         hWnd,
                         pszPrinterName,
                         CmdShow,
                         lParam,
                         AsyncPrintUIMethod,
                         TPrintUIMgr::KPrinterPropPagesOp);

}


/*++
    Function Name:
        TPrintUIMgr :: DocumentDefaults
     
    Description:
        Bring up document defaults
        
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD 
TPrintUIMgr ::
DocumentDefaults(
    IN HWND    hWnd,
    IN LPCWSTR pszPrinterName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
    return PrintUIMethod("vDocumentDefaults",
                         hWnd,
                         pszPrinterName,
                         CmdShow,
                         lParam,
                         AsyncPrintUIMethod,
                         TPrintUIMgr::KDocumentDefaultsOp);
}


/*++
    Function Name:
        TPrintUIMgr :: PrintUIMethod
     
    Description:
        Disptach the appropriate print UI method in
        a separate thread
            
    Parameters:
        Method      : Name of Method to be instantiated
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        pThrdFn     : Pointer to the Print UI method
        Op          : requested Print UI operation
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD 
TPrintUIMgr ::
PrintUIMethod(
    IN LPCSTR                  Method,
    IN HWND                    hWnd,
    IN LPCWSTR                 pszName,
    IN INT                     CmdShow,
    IN LPARAM                  lParam,
    IN LPTHREAD_START_ROUTINE  pThrdFn,
    IN TPrintUIMgr::EPrintUIOp Op
    )
{
    DWORD            ErrorCode = ERROR_SUCCESS;
    HANDLE           hPrintUI  = NULL;
    PFNPRINTUIMETHOD pfn;
    RPC_STATUS       RpcStatus;

    SPLASSERT(m_pLdrObj);

    if((RpcStatus = RpcImpersonateClient(0)) == RPC_S_OK)
    {
        m_pLdrObj->RefreshLifeSpan();

        if(hPrintUI = LoadLibrary(L"printui.dll"))
        {
            if(pfn = reinterpret_cast<PFNPRINTUIMETHOD>(GetProcAddress(hPrintUI,Method)))
            {
                SPrintUIThreadData* pNewThrdData = new SPrintUIThreadData;
                if(pNewThrdData)
                {
                    HANDLE hPrintUIMethodThrd;
                    DWORD  PrintUIThrdId;

                    pNewThrdData->hWnd           = hWnd;
                    pNewThrdData->pszName        = pszName;
                    pNewThrdData->CmdShow        = CmdShow;
                    pNewThrdData->lParam         = lParam;
                    pNewThrdData->hLib           = hPrintUI;
                    pNewThrdData->pLdrObj        = m_pLdrObj;
                    pNewThrdData->pfn            = pfn;
                    pNewThrdData->Op             = Op;

                    if(hPrintUIMethodThrd = CreateThread(NULL,
                                                         0,
                                                         pThrdFn,
                                                         (PVOID)pNewThrdData,             
                                                         0,
                                                         &PrintUIThrdId))
                    {
                        CloseHandle(hPrintUIMethodThrd);
                    }
                    else
                    {
                        ErrorCode = GetLastError();
                        delete pNewThrdData;
                    }

                }
                else
                {
                    ErrorCode = ERROR_OUTOFMEMORY;
                }
            }
            else
            {
                ErrorCode = GetLastError();
            }
        }
        else
        {
            ErrorCode = GetLastError();
        }

        RpcStatus = RpcRevertToSelf();
    }
    else
    {
        ErrorCode = RpcStatus;
    }

    return ErrorCode;
}


/*++
    Function Name:
        TPrintUIMgr :: AsyncPrintUIMethod
     
    Description:
        The PrintUI method running in a separate thread
        
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Printer name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        Always 0
--*/
DWORD
TPrintUIMgr ::
AsyncPrintUIMethod(
    IN PVOID pInThrdData
    )
{
     UINT msg;

     SPrintUIThreadData* pNewThreadData = reinterpret_cast<SPrintUIThreadData *>(pInThrdData);

     pNewThreadData->pLdrObj->IncUIRefCnt();
     {
         __try
         {
             pNewThreadData->pfn(pNewThreadData->hWnd,
                                 pNewThreadData->pszName,
                                 pNewThreadData->CmdShow,
                                 pNewThreadData->lParam);
         }
         __except(1)
         {
             DWORD ExcpVal = pNewThreadData->pLdrObj->TranslateExceptionCode(RpcExceptionCode());
             DBGMSG(DBG_WARN,
                    ("TPrintUIMgr::AsyncPrintUIMethod failed in calling printui with an exception %u",ExcpVal));
             SetLastError(ExcpVal);
         }
     }
     pNewThreadData->pLdrObj->DecUIRefCnt();

     //
     // Here we should post a message to the caller client window to inform 
     // it that the operation was completed and also whether it was succesful 
     // or not
     //
     switch(pNewThreadData->Op)
     {
         case TPrintUIMgr::KQueueCreateOp:
         {
             msg = WM_ENDQUEUECREATE;
             break;
         }
     
         case TPrintUIMgr::KPrinterPropPagesOp:
         {
             msg = WM_ENDPRINTERPROPPAGES;
             break;
         }
     
         case TPrintUIMgr::KDocumentDefaultsOp:
         {
             msg = WM_ENDDOCUMENTDEFAULTS;
             break;
         }

         case TPrintUIMgr::KServerPropPagesOp:
         {
             msg = WM_ENDSERVERPROPPAGES;
             break;
         }
     }
     PostMessage(pNewThreadData->hWnd,msg,
                 (WPARAM)0,
                 (LPARAM)0);

     //
     // Cleanup code
     //
     FreeLibrary(pNewThreadData->hLib);
     delete pInThrdData;

     return 0;
}

/*++
    Function Name:
        TPrintUIMgr :: PrinterSetup
     
    Description:
        Brings up the install printer wizard.
            
    Parameters:        
        hwnd            - Parent window.
        uAction         - Action requested (defined in windows\inc16\msprintx.h)
        cchPrinterName  - Length of pszPrinterName buffer.
        pszPrinterName  - Input setup printer name, Output pointer to new printer name
        pcchPrinterName - New length of pszPrinterName on return.
        pszServerName   - Name of server that printer is on.

    Return Value:

        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD 
TPrintUIMgr ::
PrinterSetup(
    IN     HWND    hWnd,
    IN     UINT    uAction,
    IN     UINT    cchPrinterName,
    IN OUT LPWSTR  pszPrinterName,
       OUT UINT*   pcchPrinterName,
    IN     LPCWSTR pszServerName
    )
{
    DWORD                   ErrorCode = ERROR_SUCCESS;
    HANDLE                  hPrintUI  = NULL;
    BOOL                    bRetVal   = FALSE;
    PFNPRINTUIPRINTERSETUP  pfn       = NULL;    
    UINT                    msg;

    SPLASSERT(m_pLdrObj);
    m_pLdrObj->RefreshLifeSpan();

    if(hPrintUI = LoadLibrary(L"printui.dll"))
    {
        if(pfn = reinterpret_cast<PFNPRINTUIPRINTERSETUP>(GetProcAddress(hPrintUI,"bPrinterSetup")))
        {
            m_pLdrObj->IncUIRefCnt();
            {
                __try
                {
                    bRetVal = pfn(hWnd,
                                  uAction,
                                  cchPrinterName,
                                  pszPrinterName,
                                  pcchPrinterName,
                                  pszServerName);
                    ErrorCode = GetLastError();
                }
                __except(1)
                {
                    DWORD ExcpVal = m_pLdrObj->TranslateExceptionCode(RpcExceptionCode());
                    DBGMSG(DBG_WARN,
                           ("TPrintUIMgr::PrinterSetup failed in calling printui with an exception %u",ExcpVal));
                    SetLastError(ExcpVal);
                    ErrorCode = ExcpVal;
                }
            }
            m_pLdrObj->DecUIRefCnt();
        }
        else
        {
            ErrorCode = GetLastError();
        }
        FreeLibrary(hPrintUI);
    }
    else
    {
        ErrorCode = GetLastError();
    }

    //
    // Here we should post a message to the caller client window to inform 
    // it that the operation was completed and also whether it was succesful 
    // or not
    //
    PostMessage(hWnd,WM_ENDPRINTERSETUP,
                (WPARAM)bRetVal,
                (LPARAM)ErrorCode);

    return ErrorCode;
}

/*++
    Function Name:
        TPrintUIMgr :: ServerPropPages
     
    Description:
        This function opens the property sheet of specified server.            
        
    Parameters:
        hWnd        : Parent hwnd.
        PrinterName : Server name.
        CmdShow     : Show command.
        lParam      : currently unused.
        
    Return Value:
        DWORD       : Error Code in case of Failure
                      ERROR_SUCCESS in case of success
--*/
DWORD 
TPrintUIMgr ::
ServerPropPages(
    IN HWND    hWnd,
    IN LPCWSTR pszServerName,
    IN INT     CmdShow,
    IN LPARAM  lParam
    )
{
    return PrintUIMethod("vServerPropPages",
                         hWnd,
                         pszServerName,
                         CmdShow,
                         lParam,
                         AsyncPrintUIMethod,
                         TPrintUIMgr::KServerPropPagesOp);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\prtcfg.cxx ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     prtcfg.cxx                                                             
                                                                              
  Abstract:                                                                   
     This file contains the implementation for the Printer
     and Document Property class                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Feb-2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "precomp.h"
#pragma hdrstop


#ifndef __LDFUNCS_HPP__
#include "ldfuncs.hpp"
#endif
                
                
#ifndef __LDMGR_HPP__
#include "ldmgr.hpp"
#endif


/* ------------------------------------ */
/* Implemetation of class TPrinterCfgMgr */
/* ------------------------------------ */


/*++
    Function Name:
        TPrintUIMgr :: TPrintUIMgr
     
    Description:
        Contructor of the Printer (Driver) configuration  
        manager 
     
    Parameters:
        None
        
    Return Value:
        None
--*/
TPrinterCfgMgr::
TPrinterCfgMgr(
    TLoad64BitDllsMgr *pIpLdrObj
    ) :
    m_pLdrObj(pIpLdrObj),
    TClassID("TPrinterCfgMgr")
{
    m_pLdrObj->AddRef();
}


/*++
    Function Name:
        TPrintUIMgr :: TPrintUIMgr
     
    Description:
        Destructor of the Printer (Driver) configuration  
        manager 
     
    Parameters:
        None
        
    Return Value:
        None
--*/
TPrinterCfgMgr::
~TPrinterCfgMgr(
    VOID
    )
{
    m_pLdrObj->Release();
}


/*++
    Function Name:
        TPrintUIMgr :: PrinterProperties
     
    Description:
        Displays a Printer-properties property sheet
        for the specific printer
     
    Parameters:
        hWnd        : Parent Window
        Printername : Printer Name
        Flag        : Access permissions
        ErrorCode   : Win32 error in case of failure
        
    Return Value:
        BOOL        : FALSE for failure
                      TRUE  for success
--*/
BOOL
TPrinterCfgMgr ::
PrinterProperties(
    IN  ULONG_PTR   hWnd,
    IN  LPCWSTR     pszPrinterName,
    IN  DWORD       Flag,
    OUT PDWORD      pErrorCode
    )
{
     DEVICEPROPERTYHEADER  DPHdr;
     DWORD                 Result;
     PFNDEVICEPROPSHEETS   pfnDevicePropSheets;
     HANDLE                hPrinter  = NULL;
     HMODULE               hWinSpool = NULL;
     BOOL                  RetVal    = FALSE;
     RPC_STATUS            RpcStatus;


     if((RpcStatus = RpcImpersonateClient(0)) == RPC_S_OK)
     {
         if(hWinSpool = LoadLibrary(L"winspool.drv"))
         {
              if(pfnDevicePropSheets = reinterpret_cast<PFNDEVICEPROPSHEETS>(GetProcAddress(hWinSpool,
                                                                                            "DevicePropertySheets")))
              {
                   if(OpenPrinter(const_cast<LPWSTR>(pszPrinterName),
                                  &hPrinter,NULL))
                   {
                        PFNCALLCOMMONPROPSHEETUI  pfnCallCommonPropSheeUI = NULL;

                        DPHdr.cbSize         = sizeof(DPHdr);
                        DPHdr.hPrinter       = hPrinter;
                        DPHdr.Flags          = (WORD)Flag;
                        DPHdr.pszPrinterName = const_cast<LPWSTR>(pszPrinterName);

                        if(pfnCallCommonPropSheeUI= reinterpret_cast<PFNCALLCOMMONPROPSHEETUI>(GetProcAddress(hWinSpool,
                                                                                                              (LPCSTR) MAKELPARAM(218, 0))))
                        {
                            m_pLdrObj->IncUIRefCnt();
                            {
                                 if(pfnCallCommonPropSheeUI(reinterpret_cast<HWND>(hWnd),
                                                            pfnDevicePropSheets,
                                                            (LPARAM)&DPHdr,
                                                            (LPDWORD)&Result) < 0)
                                 {
                                      RetVal = FALSE;
                                      *pErrorCode = GetLastError();
                                 }
                                 else
                                 {
                                      RetVal = TRUE;
                                 }
                                 PostMessage(reinterpret_cast<HWND>(hWnd),
                                             WM_ENDPRINTERPROPERTIES,
                                             (WPARAM)RetVal,
                                             (LPARAM)*pErrorCode);
                            }
                            m_pLdrObj->DecUIRefCnt();
                        }
                        else
                        {
                             *pErrorCode = GetLastError();
                        }
                        CloseHandle(hPrinter);
                   }
                   else
                   {
                        *pErrorCode = GetLastError();
                   }
              }
              else
              {
                   *pErrorCode = GetLastError();
              }
              FreeLibrary(hWinSpool);
         }
         else
         {
              *pErrorCode = GetLastError();
         }

         RpcStatus = RpcRevertToSelf();
     }
     else
     {
         *pErrorCode = RpcStatus;
     }

     return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\splwow64s.c ===
/*++
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     splwow64.cxx                                                             
                                                                              
  Abstract:                                                                   
    Stub file to allow splwow64_s.c to be included easily in 
    the sources directory from the idl directory
                                                                              
  Author:                                                                     
     Khaled Sedky (khaleds) 18 January 2000                                        
     
                                                                             
  Revision History:                                                           
                                                                              
--*/
#include "splwow64_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\splwow64\server\prtcfg.hpp ===
#ifndef __PRTDRV_HPP__
#define __PRTDRV_HPP__

/*++
                                                                              
  Copyright (C) 2000  Microsoft Corporation                                   
  All rights reserved.                                                        
                                                                              
  Module Name:                                                                
     prtdrv.hpp                                                             
                                                                              
  Abstract:                                                                   
     This file contains the declararion of the class
     dealing Printer and Documet properties
     o DocumentProperties
     o PrinterProperties
                                                                                   
  Author:                                                                     
     Khaled Sedky (khaleds) 18-Feb-2000                                        
     
                                                                             
  Revision History:                                                           
--*/
#ifndef __LDERROR_HPP__
#include "lderror.hpp"
#endif

#ifndef __BASECLS_HPP__
#include "basecls.hpp"
#endif

//
// Forward declarations
//
class TLoad64BitDllsMgr;

class TPrinterCfgMgr : public TClassID,
                       public TLd64BitDllsErrorHndlr,
                       public TRefCntMgr
{
     public:

     TPrinterCfgMgr(
         IN TLoad64BitDllsMgr *pIpLdrObj
         );

     ~TPrinterCfgMgr(
         VOID
         );

     BOOL 
     PrinterProperties(
         IN  ULONG_PTR   hWnd,
         IN  LPCWSTR     pszPrinterName,
         IN  DWORD       Flag,
         OUT PDWORD      pErrorCode
         );

     private:
     TLoad64BitDllsMgr *m_pLdrObj;
};

#endif //__PRTCFG_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\bind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Contains the RPC bind and un-bind routines

Author:

    Dave Snipp (davesn)     01-Jun-1991

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"

LPWSTR InterfaceAddress = L"\\pipe\\spoolss";

handle_t
STRING_HANDLE_bind (
    STRING_HANDLE  lpStr)

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the server service client stubs when
    it is necessary to bind to a server.

Arguments:

    lpStr - \\ServerName\PrinterName

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    RPC_STATUS RpcStatus;
    LPWSTR StringBinding;
    handle_t BindingHandle;
    WCHAR   ServerName[MAX_PATH + 2];
    DWORD   i;


    if (lpStr && lpStr[0] == L'\\' && lpStr[1] == L'\\') {

        // We have a servername
        for (i = 2 ; lpStr[i] && lpStr[i] != L'\\' ; ++i)
            ;

        if (i >= COUNTOF(ServerName))
            return FALSE;
        
        wcsncpy(ServerName, lpStr, i);
        ServerName[i] = L'\0';

    } else

        return FALSE;

    RpcStatus = RpcStringBindingComposeW(0, L"ncacn_np", ServerName,
                                         InterfaceAddress,
                                         L"Security=Impersonation Dynamic True",
                                         &StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return( 0 );
    }

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, &BindingHandle);

    RpcStringFreeW(&StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
       return(0);
    }

    return(BindingHandle);
}

void
STRING_HANDLE_unbind (
    STRING_HANDLE  lpStr,
    handle_t    BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the server service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS       RpcStatus;

    RpcStatus = RpcBindingFree(&BindingHandle);
    ASSERT(RpcStatus != RPC_S_INVALID_BINDING);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\data.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    data.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"

#define PRINTER_STRINGS
#define PRINTER_OFFSETS

#define JOB_STRINGS
#define JOB_OFFSETS

#define DRIVER_STRINGS
#define DRIVER_OFFSETS

#define ADDJOB_STRINGS
#define ADDJOB_OFFSETS

#define FORM_STRINGS
#define FORM_OFFSETS

#define PORT_STRINGS
#define PORT_OFFSETS

#define PRINTPROCESSOR_STRINGS
#define PRINTPROCESSOR_OFFSETS

#define MONITOR_STRINGS
#define MONITOR_OFFSETS

#define DOCINFO_STRINGS
#define DOCINFO_OFFSETS

#define DATATYPE_OFFSETS
#define DATATYPE_STRINGS

#define PROVIDOR_STRINGS

#define PRINTER_ENUM_VALUES_OFFSETS

#include <data.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\cachemon.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachemon.c

Abstract:

    This module contains the Cache Port handling for Win32Spl
    true connected printers.

Author:

    Matthew A Felton ( MattFe ) July 23 1994

Revision History:
    July 23 1994 - Created.

Notes:

    We shold collapse the LM Ports and the Win32 ports so they have use common
    ports.

--*/

#include "precomp.h"


PWINIPORT pW32FirstPort = NULL;


BOOL
OpenPort(
    LPWSTR   pName,
    PHANDLE pHandle
)
{
    DBGMSG(DBG_TRACE, ("OpenPort %ws %x\n", pName, pHandle));
    *pHandle = NULL;
    return  TRUE;
}

BOOL
StartDocPort(
    HANDLE  hPort,
    LPWSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    DBGMSG(DBG_TRACE, ("StartDocPort %x %ws %d %d %x\n", hPort, pPrinterName, JobId, Level, pDocInfo));
    return  TRUE;
}

BOOL
ReadPort(
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuf,
    LPDWORD pcbRead
)
{
    DBGMSG(DBG_TRACE, ("ReadPort %x %x %d %x\n", hPort, pBuffer, cbBuf, pcbRead));
    return  TRUE;
}


BOOL
WritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
)
{
    DBGMSG(DBG_TRACE, ("WritePort %x %x %d %x\n", hPort, pBuffer, cbBuf, pcbWritten));
    return  TRUE;
}

BOOL
EndDocPort(
   HANDLE   hPort
)
{
    DBGMSG(DBG_TRACE, ("EndDocPort %x\n", hPort ));
    return  TRUE;
}

BOOL
XcvOpenPort(
    PCWSTR  pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
)
{
    DBGMSG(DBG_TRACE, ("XcvOpenPort\n"));
    return TRUE;
}

DWORD
XcvDataPort(
    HANDLE  hXcv,
    PCWSTR  pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
)
{
    DBGMSG(DBG_TRACE, ("XcvDataPort\n"));
    return TRUE;
}


BOOL
XcvClosePort(
    HANDLE  hXcv
)
{
    DBGMSG(DBG_TRACE, ("XcvClosePort\n"));
    return TRUE;
}


BOOL
ClosePort(
    HANDLE  hPort
)
{
    DBGMSG(DBG_TRACE, ("ClosePort %x\n", hPort ));
    return  TRUE;
}

BOOL
DeletePortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
)
{
    DBGMSG(DBG_TRACE, ("DeletePortW %ws %x %ws\n", pName, hWnd, pPortName));
    return  TRUE;
}

BOOL
AddPortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
)
{
    BOOL    ReturnValue = FALSE;

    DBGMSG(DBG_TRACE, ("AddPortW %ws %x %ws\n", pName, hWnd, pMonitorName));

    if ( _wcsicmp( pMonitorName, pszMonitorName ) ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto    AddPortWErrorReturn;
    }

    SetLastError( ERROR_NOT_SUPPORTED );

AddPortWErrorReturn:
    return  ReturnValue;
}

BOOL
ConfigurePortW(
    LPWSTR   pName,
    HWND  hWnd,
    LPWSTR pPortName
)
{
    DBGMSG(DBG_TRACE, ("ConfigurePortW %ws %x %ws\n", pName, hWnd, pPortName));
    return  TRUE;
}




BOOL
AddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
)
{
    BOOL    ReturnValue = FALSE;
    DWORD   LastError = ERROR_SUCCESS;
    PPORT_INFO_1 pPortInfo = (PPORT_INFO_1)pBuffer;

    EnterSplSem();

    DBGMSG(DBG_TRACE, ("AddPortEx %x %d %x %ws %ws\n", pName, Level, pBuffer, pPortInfo->pName, pMonitorName));

    if ( _wcsicmp( pMonitorName, pszMonitorName ) ) {
        LastError = ERROR_INVALID_PARAMETER;
        goto    AddPortExErrorReturn;
    }

    //
    //  Make Sure Port doesn't already exist
    //


    if ( FindPort( pPortInfo->pName, pW32FirstPort ) ) {
        LastError = ERROR_INVALID_NAME;
        goto    AddPortExErrorReturn;

    }

    if ( CreatePortEntry( pPortInfo->pName, &pW32FirstPort ) )
        ReturnValue = TRUE;


AddPortExErrorReturn:
    LeaveSplSem();

    if  (LastError != ERROR_SUCCESS) {
        SetLastError( LastError );
        ReturnValue = FALSE;
    }

    return  ReturnValue;
}






BOOL
EnumPortsW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PWINIPORT pIniPort;
    DWORD   cb;
    LPBYTE  pEnd;
    DWORD   LastError=0;

    switch (Level) {

        case 1:
        case 2:
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

   EnterSplSem();

    DBGMSG(DBG_TRACE, ("EnumPortW %x %d %x %d %x %x\n", pName, Level, pPorts, cbBuf, pcbNeeded, pcReturned));

    cb=0;

    pIniPort = pW32FirstPort;

    while (pIniPort) {

        cb += GetPortSize(pIniPort, Level);
        pIniPort = pIniPort->pNext;
    }

    *pcbNeeded=cb;

    if (cb <= cbBuf) {

        pEnd=pPorts+cbBuf;
        *pcReturned=0;

        pIniPort = pW32FirstPort;

        while (pIniPort) {

            pEnd = CopyIniPortToPort(pIniPort, Level, pPorts, pEnd);

            switch (Level) {

                case 1:
                    pPorts+=sizeof(PORT_INFO_1);
                    break;

                case 2:
                    pPorts+=sizeof(PORT_INFO_2);
                    break;
            }

            pIniPort=pIniPort->pNext;
            (*pcReturned)++;
        }

    } else {
        *pcReturned = 0;
        LastError = ERROR_INSUFFICIENT_BUFFER;

    }

   LeaveSplSem();

    if (LastError) {

        SetLastError(LastError);
        return FALSE;

    } else

        return TRUE;
}

MONITOREX MonitorEx = {
    sizeof(MONITOR),
    {
        EnumPortsW,
        OpenPort,
        NULL,           // OpenPortEx is not supported
        StartDocPort,
        WritePort,
        ReadPort,
        EndDocPort,
        ClosePort,
        AddPort,
        AddPortEx,
        ConfigurePortW,
        DeletePortW,
        NULL,           // GetPrinterDataFromPort not supported
        NULL,           // SetPortTimeouts not supported
        XcvOpenPort,
        XcvDataPort,
        XcvClosePort        
    }                                       
};


LPMONITOREX
InitializePrintMonitor(
    LPWSTR  pRegistryRoot
    )
{
    BOOL    bRet = TRUE;

    DBGMSG(DBG_TRACE, ("InitializeMonitor %ws\n", pRegistryRoot));

    EnterSplSem();

    if (!FindPort(L"NExx:", pW32FirstPort ) ) {
        if ( !CreatePortEntry( L"NExx:", &pW32FirstPort ) ) {

            DBGMSG( DBG_WARNING,("InitializeMonitor Failed to CreatePortEntry\n"));
            bRet = FALSE;
        }
    }
    LeaveSplSem();

    return  bRet ? &MonitorEx : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\change.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Change.c

Abstract:

    Handles implementation for WaitForPrinterChange and related apis.

    FindFirstPrinterChangeNotification
    FindClosePrinterChangeNotification

    RefreshPrinterChangeNotification

Author:

    Albert Ting (AlbertT) 24-Apr-94

Environment:

    User Mode -Win32

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop



BOOL
RemoteFindFirstPrinterChangeNotification(
   HANDLE hPrinter,
   DWORD fdwFlags,
   DWORD fdwOptions,
   HANDLE hNotify,
   PDWORD pfdwStatus,
   PVOID pvReserved0,
   PVOID pvReserved1);

BOOL
RemoteFindClosePrinterChangeNotification(
   HANDLE hPrinter);

BOOL
RemoteFindFirstPrinterChangeNotification(
   HANDLE hPrinter,
   DWORD fdwFlags,
   DWORD fdwOptions,
   HANDLE hNotify,
   PDWORD pfdwStatus,
   PVOID pvReserved0,
   PVOID pvReserved1)
{
    BOOL    bReturnValue = TRUE;
    PWSPOOL pSpool       = (PWSPOOL)hPrinter;    

    VALIDATEW32HANDLE( pSpool );

    SPLASSERT( !*pfdwStatus );

    if (bReturnValue = BoolFromHResult(AllowRemoteCalls()))
    {
        if( !(pSpool->Status & WSPOOL_STATUS_NOTIFY) ){
        
            if( pSpool->Type == SJ_WIN32HANDLE ){

                DWORD dwStatus;

                SYNCRPCHANDLE( pSpool );

                dwStatus = CallRouterFindFirstPrinterChangeNotification(
                               pSpool->RpcHandle,
                               fdwFlags,
                               fdwOptions,
                               hNotify,
                               pvReserved0);

                switch( dwStatus ){
                case RPC_S_SERVER_UNAVAILABLE:

                    //
                    // Drop into polling mode.  This can happen if the
                    // server service on the client is disabled.
                    //
                    *pfdwStatus = PRINTER_NOTIFY_STATUS_ENDPOINT |
                                  PRINTER_NOTIFY_STATUS_POLL;

                    pSpool->Status |= WSPOOL_STATUS_NOTIFY_POLL;

                    DBGMSG( DBG_WARNING, ( "RemoteFFPCN: Dropping into poll mode.\n" ));
                    break;

                case ERROR_SUCCESS:

                    //
                    // Using regular notification system; not polling.
                    //
                    pSpool->Status &= ~WSPOOL_STATUS_NOTIFY_POLL;
                    break;

                default:

                    SetLastError(dwStatus);
                    bReturnValue = FALSE;
                    break;
                }

            } else {

                bReturnValue = LMFindFirstPrinterChangeNotification(
                                   hPrinter,
                                   fdwFlags,
                                   fdwOptions,
                                   hNotify,
                                   pfdwStatus);
            }

            if( bReturnValue ){
                pSpool->Status |= WSPOOL_STATUS_NOTIFY;
            }
        }
        else
        {
            DBGMSG( DBG_WARNING, ( "RemoteFFPCN: Already waiting.\n" ));
            SetLastError( ERROR_ALREADY_WAITING );            
        
        }
    }

    return bReturnValue;
}


BOOL
RemoteFindClosePrinterChangeNotification(
   HANDLE hPrinter)
{
    DWORD  ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    pSpool->Status &= ~WSPOOL_STATUS_NOTIFY;

    if( pSpool->Status & WSPOOL_STATUS_NOTIFY_POLL ){

        //
        // In the polling case, there's no cleanup.
        //
        return TRUE;
    }

    if (pSpool->Type == SJ_WIN32HANDLE) {

        SYNCRPCHANDLE( pSpool );

        RpcTryExcept {

            if (ReturnValue = RpcFindClosePrinterChangeNotification(
                                  pSpool->RpcHandle)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else {

        EnterSplSem();
        ReturnValue = LMFindClosePrinterChangeNotification(hPrinter);
        LeaveSplSem();
    }

    return ReturnValue;
}

BOOL
RemoteRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PVOID pPrinterNotifyOptions,
    PVOID* ppPrinterNotifyInfo)
{
    DWORD  ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    if (ppPrinterNotifyInfo)
        *ppPrinterNotifyInfo = NULL;

    if (pSpool->Type != SJ_WIN32HANDLE) {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }

    SYNCRPCHANDLE( pSpool );

    RpcTryExcept {

        if (ReturnValue = RpcRouterRefreshPrinterChangeNotification(
                              pSpool->RpcHandle,
                              dwColor,
                              pPrinterNotifyOptions,
                              (PRPC_V2_NOTIFY_INFO*)ppPrinterNotifyInfo)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\files.c ===
/*++


Copyright (c) 1994 - 1996 Microsoft Corporation

Module Name:

    Files.c

Abstract:

    This module contains routines for copying files specified under the
    CopyFiles key of a print queue

Author:

    Muhunthan Sivapragasam (Muhunthan Sivapragasam)     Nov-27-96

Revision History:

--*/

#include <precomp.h>

WCHAR *szSpoolDirectory   = L"\\spool";

extern SPLCLIENT_INFO_1   gSplClientInfo1;

#define     PRINTER_ENUM_KEY_SIZE        400


BOOL
ProcessACopyFileKey(
    PWSPOOL             pSpool,
    LPWSTR              pszKey,
    LPWSTR              pszModule,
    LPWSTR              pszDir,
    LPWSTR              ppszFiles,
    LPWSTR              pszSourceDir,
    LPWSTR              pszTargetDir,
    PSPLCLIENT_INFO_1   pSplClientInfo1
    )
{
    BOOL        bRet = FALSE, bFilesUpdated;
    DWORD       dwLen, dwCount, dwTemp, dwSourceDirSize, dwTargetDirSize;
    LPWSTR      *ppszFileNames = NULL, pszBuf = NULL, p1, p2;
    HINSTANCE   hModule = NULL;
    DWORD       (*pfn)(LPWSTR       pszPrinterName,
                       LPCWSTR      pszDirectory,
                       LPBYTE       pSplClientInfo,
                       DWORD        dwLevel,
                       LPWSTR       pszSourceDir,
                       LPDWORD      pcchSourceDirSize,
                       LPWSTR       pszTargetDir,
                       LPDWORD      pcchTargetDirSize,
                       DWORD        dwFlags
                      );

    //
    // If a module is given we need to call into to "correct" the path
    // We will first try LoadLibrary on the module, if we can't find the module
    // we will look in the driver directory for it
    //
    if ( pszModule && *pszModule ) {

        if ( !(hModule = SplLoadLibraryTheCopyFileModule(pSpool, pszModule)) ||
             !((FARPROC)pfn = GetProcAddress(hModule, "GenerateCopyFilePaths")) )
        goto Cleanup;

        dwSourceDirSize = dwTargetDirSize = MAX_PATH;

#if DBG
#else
        try {
#endif

            //
            // On free builds we do not want spooler to crash
            //
            if ( ERROR_SUCCESS != pfn(pSpool->pName,
                                      pszDir,
                                      (LPVOID)pSplClientInfo1,
                                      1,
                                      pszSourceDir,
                                      &dwSourceDirSize,
                                      pszTargetDir,
                                      &dwTargetDirSize,
                                      COPYFILE_FLAG_CLIENT_SPOOLER) )
#if DBG
                goto Cleanup;
#else
                leave;
#endif

            bRet = TRUE;
#if DBG
#else
        } except(1) {
        }
#endif

        if ( !bRet )
            goto Cleanup;

    } else {

        bRet = TRUE;
    }

    dwSourceDirSize = wcslen(pszSourceDir);
    dwTargetDirSize = wcslen(pszTargetDir);

    pszSourceDir[dwSourceDirSize] = L'\\';

    pszSourceDir[++dwSourceDirSize] = L'\0';
    pszTargetDir[dwTargetDirSize]   = L'\0';


    //
    // First find out number of files and size of one long buffer to put
    // all filenames. We need to build fully qualified filenames in the source
    // directory
    //
    for ( dwCount = dwLen = 0, p1 = ppszFiles ; *p1 ; p1 += dwTemp, ++dwCount ) {

        dwTemp = wcslen(p1) + 1;
        dwLen += dwTemp + dwSourceDirSize;
    }

    pszBuf          = (LPWSTR) AllocSplMem(dwLen * sizeof(WCHAR));
    ppszFileNames   = (LPWSTR *) AllocSplMem(dwCount * sizeof(LPWSTR));

    if ( !pszBuf || !ppszFileNames )
        goto Cleanup;

    for ( p1 = ppszFiles, p2 = pszBuf, dwCount = dwTemp = 0 ;
         *p1 ; p1 += wcslen(p1) + 1, ++dwCount ) {

        StringCchCopyW(p2, dwLen, pszSourceDir);
        StringCchCopyW(p2 + dwSourceDirSize, dwLen - dwSourceDirSize, p1);

        ppszFileNames[dwCount]  = p2;

        dwTemp                 += dwSourceDirSize + wcslen(p1) + 1;
        p2                      = pszBuf + dwTemp;
    }

    SPLASSERT(dwTemp == dwLen);

    bRet = SplCopyNumberOfFiles(pSpool->pName,
                                ppszFileNames,
                                dwCount,
                                pszTargetDir,
                                &bFilesUpdated);

    if ( bFilesUpdated )
        (VOID) SplCopyFileEvent(pSpool->hSplPrinter,
                                pszKey,
                                COPYFILE_EVENT_FILES_CHANGED);
Cleanup:
    if ( hModule )
        FreeLibrary(hModule);

    FreeSplMem(pszBuf);
    FreeSplMem(ppszFileNames);

    return bRet;
}


BOOL
CopyFilesUnderAKey(
    PWSPOOL             pSpool,
    LPWSTR              pszSubKey,
    PSPLCLIENT_INFO_1   pSplClientInfo1
    )
{
    BOOL        bRet = FALSE;
    DWORD       dwSize, dwLen, dwType, dwNeeded;
    WCHAR       szSourceDir[MAX_PATH], szTargetDir[MAX_PATH];
    LPWSTR      pszDir, ppszFiles, pszModule;

    pszDir = ppszFiles = pszModule = NULL;

    dwSize = sizeof(szSourceDir);

    if ( SplGetPrinterDataEx(pSpool->hSplPrinter,
                             pszSubKey,
                             L"Directory",
                             &dwType,
                             (LPBYTE)szSourceDir,
                             dwSize,
                             &dwNeeded)                     ||
         dwType != REG_SZ                                   ||
         !(pszDir = AllocSplStr(szSourceDir))               ||
         SplGetPrinterDataEx(pSpool->hSplPrinter,
                             pszSubKey,
                             L"SourceDir",
                             &dwType,
                             (LPBYTE)szSourceDir,
                             dwSize,
                             &dwNeeded)                     ||
         dwType != REG_SZ                                   ||
         dwNeeded + sizeof(WCHAR) > dwSize                  ||
         SplGetPrinterDataEx(pSpool->hSplPrinter,
                             pszSubKey,
                             L"Files",
                             &dwType,
                             (LPBYTE)szTargetDir,       // Can't pass NULL
                             0,
                             &dwNeeded) != ERROR_MORE_DATA  ||
         !(ppszFiles = (LPWSTR) AllocSplMem(dwNeeded))      ||
         SplGetPrinterDataEx(pSpool->hSplPrinter,
                             pszSubKey,
                             L"Files",
                             &dwType,
                             (LPBYTE)ppszFiles,
                             dwNeeded,
                             &dwNeeded)                     ||
         dwType != REG_MULTI_SZ ) {

        goto Cleanup;
    }

    //
    // Module name is optional
    //
    dwLen = SplGetPrinterDataEx(pSpool->hSplPrinter,
                                pszSubKey,
                                L"Module",
                                &dwType,
                                (LPBYTE)szTargetDir,
                                dwSize,
                                &dwNeeded);

    if ( dwLen == ERROR_SUCCESS ) {

        if ( dwType != REG_SZ   ||
             !(pszModule = AllocSplStr(szTargetDir)) ) {

            goto Cleanup;
        }
    } else if ( dwLen != ERROR_FILE_NOT_FOUND ) {

        goto Cleanup;
    }

    dwLen = dwSize;
    //
    // Target directory we got from the server is relative to print$.
    // We need to convert it to a fully qualified path now
    //
    if ( !SplGetDriverDir(pSpool->hIniSpooler, szTargetDir, &dwLen) )
        goto Cleanup;

    szTargetDir[dwLen-1] = L'\\';

    dwSize -= dwLen * sizeof(WCHAR);
    if ( SplGetPrinterDataEx(pSpool->hSplPrinter,
                             pszSubKey,
                             L"TargetDir",
                             &dwType,
                             (LPBYTE)(szTargetDir + dwLen),
                             dwSize,
                             &dwNeeded)                     ||
         dwType != REG_SZ ) {

        goto Cleanup;
    }

    bRet = ProcessACopyFileKey(pSpool,
                               pszSubKey,
                               pszModule,
                               pszDir,
                               ppszFiles,
                               szSourceDir,
                               szTargetDir,
                               pSplClientInfo1);

Cleanup:
    FreeSplStr(pszDir);
    FreeSplStr(ppszFiles);
    FreeSplStr(pszModule);

    return bRet;
}


BOOL
RefreshPrinterCopyFiles(
    PWSPOOL     pSpool
    )
{
    DWORD                   dwNeeded, dwSize = 0, dwLastError;
    LPWSTR                  pszBuf = NULL, pszSubKey;
    WCHAR                   szUserName[MAX_PATH+1], szKey[MAX_PATH];
    SPLCLIENT_INFO_1        SplClientInfo;

    if ( pSpool->Type != SJ_WIN32HANDLE )
        return TRUE;

    SYNCRPCHANDLE(pSpool);

    SPLASSERT(pSpool->Status & WSPOOL_STATUS_USE_CACHE);

    //
    // If it is a 3x server it is not going to support the rpc calls we need
    // so there is nothing to copy
    //
    if ( pSpool->bNt3xServer )
        return TRUE;

Retry:

    dwLastError = SplEnumPrinterKey(pSpool->hSplPrinter,
                                    L"CopyFiles",
                                    pszBuf,
                                    dwSize,
                                    &dwNeeded);

    //
    // If first time size was not enough we will try once more with dwNeeded
    //
    if ( dwLastError == ERROR_MORE_DATA &&
         dwSize == 0                    &&
         dwNeeded != 0 ) {

        dwSize  = dwNeeded;
        pszBuf  = AllocSplMem(dwSize);

        if ( !pszBuf )
            goto Cleanup;

        goto Retry;
    }

    //
    // If the call failed, or there was no sub key we are done
    //
    if ( dwLastError != ERROR_SUCCESS )
        goto Cleanup;

    CopyMemory((LPBYTE)&SplClientInfo,
               (LPBYTE)&gSplClientInfo1,
               sizeof(SplClientInfo));

    SplClientInfo.pMachineName = SplClientInfo.pUserName = NULL;

    for ( pszSubKey = pszBuf ; *pszSubKey ; pszSubKey += wcslen(pszSubKey) + 1 ) {

        if ( sizeof(szKey)/sizeof(szKey[0])
                > wcslen(L"CopyFiles") + wcslen(pszSubKey) ) {

            StringCchPrintf(szKey, COUNTOF(szKey), L"%ws\\%ws", L"CopyFiles", pszSubKey);

            CopyFilesUnderAKey(pSpool, szKey, &SplClientInfo);
        } else {

            SPLASSERT(sizeof(szKey)/sizeof(szKey[0]) >
                        wcslen(L"CopyFiles") + wcslen(pszSubKey));
        }
    }

Cleanup:
    FreeSplMem(pszBuf);

    return dwLastError == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\midluser.c ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    25-Apr-1991 JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.

--*/

#include "precomp.h"

PVOID
MIDL_user_allocate (
    IN size_t NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    return MIDL_user_allocate1(NumBytes);
}



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
    MIDL_user_free1(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\lmjob.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    local.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    16-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.

--*/

#include "precomp.h"

BOOL
LMSetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
)

/*++

Routine Description:

    This function will modify the settings of the specified Print Job.

Arguments:

    lpJob - Points to a valid JOB structure containing at least a valid
        lpPrinter, and JobId.

    Command - Specifies the operation to perform on the specified Job. A value
        of FALSE indicates that only the elements of the JOB structure are to
        be examined and set.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;
    DWORD   uRetCode;
    LPWSTR  pszDocument;
    LPWSTR  pszDatatype;

    VALIDATEW32HANDLE( pSpool );

    switch (Command) {

    case 0:
        break;

    case JOB_CONTROL_PAUSE:
        if (uRetCode = RxPrintJobPause(pSpool->pServer, JobId)) {
            SetLastError(uRetCode);
            return(FALSE);
        }
        break;

    case JOB_CONTROL_RESUME:
        if (uRetCode = RxPrintJobContinue(pSpool->pServer, JobId)) {
            SetLastError(uRetCode);
            return(FALSE);
        }
        break;

    case JOB_CONTROL_CANCEL:
    case JOB_CONTROL_DELETE:
        if (uRetCode = RxPrintJobDel(pSpool->pServer, JobId)) {
            SetLastError(uRetCode);
            return(FALSE);
        }
        break;

    case JOB_CONTROL_RESTART:
        break;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // We only support setting of the document name on SetJob to OS/2.

    switch (Level) {

    case 0:
        break;
    case 1:
    case 2:
        switch (Level) {

        case 1:
            pszDatatype = ((JOB_INFO_1 *)pJob)->pDatatype;
            pszDocument = ((JOB_INFO_1 *)pJob)->pDocument;
            break;
        case 2:
            pszDatatype = ((JOB_INFO_2 *)pJob)->pDatatype;
            pszDocument = ((JOB_INFO_2 *)pJob)->pDocument;
            break;
        }

        //
        // If the datatype is non-NULL and anything other than
        // a RAW datatype, then fail.
        //
        if( pszDatatype && !ValidRawDatatype( pszDatatype )){
            SetLastError( ERROR_INVALID_DATATYPE );
            return FALSE;
        }

        //
        // Special handling for pszDocument == NULL
        // if pszDocument == NULL, set it to a pointer to ""
        //
        if (pszDocument == NULL)
            pszDocument = L"";
        else
        {
            if(wcslen(pszDocument) > (MAX_PATH-1))
            {
                SetLastError( ERROR_INVALID_PARAMETER );
                return (FALSE);
            }
        }


        if (uRetCode = RxPrintJobSetInfo(pSpool->pServer,
                                         JobId,
                                         3,
                                         (PBYTE)pszDocument,
                                         wcslen(pszDocument)*sizeof(WCHAR) +
                                            sizeof(WCHAR),
                                         PRJ_COMMENT_PARMNUM)) {
            SetLastError(uRetCode);
            return FALSE;
        }
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    //
    // We successfully performed a 'LMSetJob' - pulse the ChangeEvent
    // or send the notification.
    //

    LMSetSpoolChange(pSpool);

    return TRUE;
}

#define Nullstrlen(psz)  ((psz) ? wcslen(psz)*sizeof(WCHAR)+sizeof(WCHAR) : 0)

DWORD
GetPrjInfoSize(
    PWSPOOL  pSpool,
    DWORD   Level,
    PRJINFO *pPrjInfo
)
{
    DWORD   cb;

    switch (Level) {

    case 1:
        cb = sizeof(JOB_INFO_1) +
             wcslen(pSpool->pShare)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pPrjInfo->szUserName) +
             Nullstrlen(pPrjInfo->pszComment) +
             Nullstrlen(pPrjInfo->pszStatus);
        break;

    case 2:
        cb = sizeof(JOB_INFO_2) +
             wcslen(pSpool->pShare)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pPrjInfo->szUserName) +
             Nullstrlen(pPrjInfo->pszComment) +
             Nullstrlen(pPrjInfo->szNotifyName) +
             Nullstrlen(pPrjInfo->szDataType) +
             Nullstrlen(pPrjInfo->pszParms) +
             Nullstrlen(pPrjInfo->pszStatus);
        break;

    default:

        cb = 0;
        break;
    }

    return cb;
}

BOOL
ConvertDosTimeToSystemTime(
    ULONG Time,
    PSYSTEMTIME pst
    )
{
    LARGE_INTEGER li;
    FILETIME ft;

    li.QuadPart = Time;

    li.QuadPart += 11644473600;
    li.QuadPart *= 10000000;

    ft.dwLowDateTime = li.LowPart;
    ft.dwHighDateTime = li.HighPart;

    return FileTimeToSystemTime( &ft, pst );
}


LPBYTE
CopyPrjInfoToJob(
    PWSPOOL  pSpool,
    PRJINFO *pPrjInfo,
    DWORD   Level,
    LPBYTE  pJobInfo,
    LPBYTE  pEnd
)
{
    LPWSTR *pSourceStrings, *SourceStrings;
    LPJOB_INFO_2 pJob  = (PJOB_INFO_2)pJobInfo;
    LPJOB_INFO_2 pJob2 = (PJOB_INFO_2)pJobInfo;
    LPJOB_INFO_1 pJob1 = (PJOB_INFO_1)pJobInfo;
    DWORD   i, Status;
    DWORD   *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = JobInfo1Strings;
        break;

    case 2:
        pOffsets = JobInfo2Strings;
        break;

    default:
        return pEnd;
    }

    switch (pPrjInfo->fsStatus) {

    case PRJ_QS_PAUSED:
        Status = JOB_STATUS_PAUSED;
        break;

    case PRJ_QS_SPOOLING:
        Status = JOB_STATUS_SPOOLING;
        break;

    case PRJ_QS_PRINTING:
        Status = JOB_STATUS_PRINTING;
        break;

    default:
        Status = 0;
        break;
    }

    for (i=0; pOffsets[i] != -1; i++) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(i * sizeof(LPWSTR));

    if (!SourceStrings)
        return NULL;

    switch (Level) {

    case 1:
        *pSourceStrings++=pSpool->pShare;
        *pSourceStrings++=NULL;
        *pSourceStrings++=pPrjInfo->szUserName;
        *pSourceStrings++=pPrjInfo->pszComment;
        *pSourceStrings++=NULL;
        if (pPrjInfo->pszStatus && *pPrjInfo->pszStatus)
            *pSourceStrings++=pPrjInfo->pszStatus;
        else
            *pSourceStrings++=NULL;

        /* PRJINFO doesn't contain uPriority.
         * PRJINFO2 does, but doesn't contain some of the things
         * that PRJINFO has.
         * We'd need to pass a PRJINFO3 structure to get everything we need,
         * but DosPrintJobEnum doesn't support level 3.
         * For now, set it to 0.  Print Manager will display nothing for this.
         */
        pJob1->Priority=0;
        pJob1->Position=pPrjInfo->uPosition;
        pJob1->Status=Status;
        pJob1->JobId = pPrjInfo->uJobId;
        break;

    case 2:
        *pSourceStrings++=pSpool->pShare;
        *pSourceStrings++=NULL;
        *pSourceStrings++=pPrjInfo->szUserName;
        *pSourceStrings++=pPrjInfo->pszComment;
        *pSourceStrings++=pPrjInfo->szNotifyName;
        *pSourceStrings++=pPrjInfo->szDataType;
        *pSourceStrings++=NULL;
        *pSourceStrings++=pPrjInfo->pszParms;
        *pSourceStrings++=NULL;
        if (pPrjInfo->pszStatus && *pPrjInfo->pszStatus)
            *pSourceStrings++=pPrjInfo->pszStatus;
        else
            *pSourceStrings++=NULL;

        pJob2->pDevMode=0;
        pJob2->Priority=0;
        pJob2->Position=pPrjInfo->uPosition;
        pJob2->StartTime=0;
        pJob2->UntilTime=0;
        pJob2->TotalPages=0;
        pJob2->Size=pPrjInfo->ulSize;
        ConvertDosTimeToSystemTime(pPrjInfo->ulSubmitted, &pJob2->Submitted);
        memset((LPBYTE)&pJob2->Time, 0, sizeof(pJob2->Time));
        pJob2->Status=Status;
        pJob2->JobId = pPrjInfo->uJobId;
        break;

    default:
        return pEnd;
    }

    pEnd = PackStrings(SourceStrings, pJobInfo, pOffsets, pEnd);

    FreeSplMem(SourceStrings);

    return pEnd;
}

BOOL
LMGetJob(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
)

/*++

Routine Description:

    This function will retrieve the settings of the specified Print Job.

Arguments:

    lpJob - Points to a valid JOB structure containing at least a valid
        lpPrinter, and JobId.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PWSPOOL      pSpool = (PWSPOOL)hPrinter;
    PPRJINFO    pPrjInfo;
    PPRQINFO    pPrqInfo;
    DWORD       cbBuffer;
    DWORD       rc;
    DWORD       cbNeeded;
    DWORD       cb;
    DWORD       cJobs;

    VALIDATEW32HANDLE( pSpool );

    //
    // Fail if out of range.
    //
    if (JobId > (WORD)-1) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    cbBuffer = 100;

    if (!(pPrjInfo = AllocSplMem(cbBuffer)))
        return FALSE;

    rc = RxPrintJobGetInfo(pSpool->pServer,
                           (WORD)JobId,
                           1,
                           (PBYTE)pPrjInfo,
                           cbBuffer,
                           &cbNeeded);

    if (rc == ERROR_MORE_DATA || rc == NERR_BufTooSmall) {

        if (!(pPrjInfo=ReallocSplMem(pPrjInfo, 0, cbNeeded)))
            return FALSE;

        cbBuffer=cbNeeded;

        if (rc = RxPrintJobGetInfo(pSpool->pServer,
                                   (WORD)JobId,
                                   1,
                                   (PBYTE)pPrjInfo,
                                   cbBuffer,
                                   &cbNeeded)) {

            FreeSplMem(pPrjInfo);
            SetLastError(rc);
            return FALSE;
        }

    } else {

        //
        // Free the buffer.
        //
        FreeSplMem(pPrjInfo);

        if (rc == ERROR_NOT_SUPPORTED) {

            cbBuffer = 64*1024;

            if (!(pPrqInfo = AllocSplMem(cbBuffer)))
                return FALSE;

            if (!(rc = RxPrintQGetInfo(pSpool->pServer,
                                       pSpool->pShare,
                                       2,
                                       (PBYTE)pPrqInfo,
                                       cbBuffer,
                                       &cbNeeded))) {

                rc = ERROR_INVALID_PARAMETER;

                cJobs = (DWORD)pPrqInfo->cJobs;

                for (pPrjInfo = (PRJINFO *)(pPrqInfo+1);
                    cJobs;
                    cJobs--, pPrjInfo++) {

                    if (JobId == (DWORD)pPrjInfo->uJobId) {

                        cb = GetPrjInfoSize(pSpool, Level, pPrjInfo);

                        if (cb <= cbBuf) {

                            CopyPrjInfoToJob(pSpool,
                                             pPrjInfo,
                                             Level,
                                             pJob,
                                             pJob + cbBuf);

                            rc = ERROR_SUCCESS;

                        } else {

                            *pcbNeeded=cb;
                            rc = ERROR_INSUFFICIENT_BUFFER;
                        }
                    }
                }
            }

            FreeSplMem(pPrqInfo);
        }

        if (rc) {
            SetLastError(rc);
            return FALSE;
        }
        return TRUE;
    }

    cb=GetPrjInfoSize(pSpool, Level, pPrjInfo);

    *pcbNeeded=cb;

    if (cb > cbBuf) {
        FreeSplMem(pPrjInfo);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    if (CopyPrjInfoToJob(pSpool, pPrjInfo, Level, pJob, (LPBYTE)pJob+cbBuf)) {
        FreeSplMem(pPrjInfo);
        return TRUE;
    } else {
        FreeSplMem(pPrjInfo);
        return FALSE;
    }
}

/* Get all the Job Ids first, then get individual info on each */

BOOL
LMEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PPRJINFO    pPrjInfo;
    PPRQINFO    pPrqInfo;
    DWORD       rc=0;
    DWORD       cb=0;
    DWORD       cJobs;
    DWORD       cbNeeded;
    LPBYTE      pEnd;
    PWSPOOL      pSpool = (PWSPOOL)hPrinter;
    DWORD       cbBuffer = 100;

    VALIDATEW32HANDLE( pSpool );

    cbBuffer = 64*1024;

    pEnd = pJob + cbBuf;

    if (!(pPrqInfo = AllocSplMem(cbBuffer)))
        return FALSE;

    *pcReturned=0;

    if (!(rc = RxPrintQGetInfo(pSpool->pServer, pSpool->pShare, 2,
                               (PBYTE)pPrqInfo, cbBuffer, &cbNeeded))) {

        pPrjInfo = (PRJINFO *)(pPrqInfo+1);

        if (FirstJob > pPrqInfo->cJobs) {

            FreeSplMem(pPrqInfo);
            return TRUE;

        }

        cJobs = (DWORD)min(NoJobs, pPrqInfo->cJobs - FirstJob);

        for (pPrjInfo=pPrjInfo+FirstJob; cJobs; cJobs--, pPrjInfo++) {

            cb+=GetPrjInfoSize(pSpool, Level, pPrjInfo);

            if (cb <= cbBuf) {

                pEnd = CopyPrjInfoToJob(pSpool, pPrjInfo, Level, pJob, pEnd);

                (*pcReturned)++;
                switch (Level) {
                case 1:
                    pJob+=sizeof(JOB_INFO_1);
                    break;
                case 2:
                    pJob+=sizeof(JOB_INFO_2);
                    break;
                }

            } else

                rc=ERROR_INSUFFICIENT_BUFFER;
        }
    }

    FreeSplMem(pPrqInfo);

    *pcbNeeded=cb;

    if (rc) {
        SetLastError(rc);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\lmspl.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    local.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    16-Jun-1992 JohnRo net print vs. UNICODE.
    July 1994   MattFe Caching

--*/

#include "precomp.h"

#define NOTIFY_TIMEOUT 10000

DWORD
LMStartDocPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    PWSPOOL      pSpool=(PWSPOOL)hPrinter;
    WCHAR       szFileName[MAX_PATH];
    PDOC_INFO_1 pDocInfo1=(PDOC_INFO_1)pDocInfo;
    QUERY_PRINT_JOB_INFO JobInfo;
    IO_STATUS_BLOCK Iosb;

    VALIDATEW32HANDLE( pSpool );

    if (pSpool->Status) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pSpool->Status |= WSPOOL_STATUS_STARTDOC;

    if(StrNCatBuff(szFileName,
                   COUNTOF(szFileName),
                   pSpool->pServer,
                   L"\\",
                   pSpool->pShare,
                   NULL) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    pSpool->hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL |
                               FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (pSpool->hFile == INVALID_HANDLE_VALUE) {


        EnterSplSem();
        DeleteEntryfromLMCache(pSpool->pServer, pSpool->pShare);
        LeaveSplSem();

        DBGMSG( DBG_WARNING, ("Failed to open %ws\n", szFileName));
        pSpool->Status &= ~WSPOOL_STATUS_STARTDOC;
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;

    }

    if (pDocInfo1 && pDocInfo1->pDocName && (wcslen(pDocInfo1->pDocName) < MAX_PATH)) {

        if (NtFsControlFile(pSpool->hFile,
                            NULL,
                            NULL,
                            NULL,
                            &Iosb,
                            FSCTL_GET_PRINT_ID,
                            NULL, 0,
                            &JobInfo, sizeof(JobInfo)) == ERROR_SUCCESS){

            RxPrintJobSetInfo(pSpool->pServer,
                              JobInfo.JobId,
                              3,
                              (LPBYTE)pDocInfo1->pDocName,
                              wcslen(pDocInfo1->pDocName)*sizeof(WCHAR) + sizeof(WCHAR),
                              PRJ_COMMENT_PARMNUM);
        }
        else
        {
            DBGMSG( DBG_WARN, ("NtFsControlFile failed %ws\n", szFileName));
        }
    }

    return TRUE;
}

BOOL
LMStartPagePrinter(
    HANDLE  hPrinter
)
{
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    return FALSE;
}

BOOL
LMWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    PWSPOOL  pSpool=(PWSPOOL)hPrinter;
    DWORD   cWritten, cTotal;
    DWORD   rc;
    LPBYTE  pByte=pBuf;

    VALIDATEW32HANDLE( pSpool );

    if (!(pSpool->Status & WSPOOL_STATUS_STARTDOC)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (pSpool->hFile == INVALID_HANDLE_VALUE) {
        *pcWritten = 0;
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    cWritten = cTotal = 0;

    while (cbBuf) {

        rc = WriteFile(pSpool->hFile, pByte, cbBuf, &cWritten, NULL);

        if (!rc) {

            rc = GetLastError();

            DBGMSG(DBG_WARNING, ("Win32 Spooler: Error writing to server, Error %d\n", rc));
            cTotal+=cWritten;
            *pcWritten=cTotal;
            return FALSE;

        } else if (!cWritten) {
            DBGMSG(DBG_ERROR, ("Spooler: Amount written is zero !!!\n"));
        }

        cTotal+=cWritten;
        cbBuf-=cWritten;
        pByte+=cWritten;
    }

    *pcWritten = cTotal;
    return TRUE;
}

BOOL
LMEndPagePrinter(
    HANDLE  hPrinter
)
{
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    return FALSE;
}

BOOL
LMAbortPrinter(
   HANDLE hPrinter
)
{
    PWSPOOL pSpool=(PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    return TRUE;
}

BOOL
LMReadPrinter(
   HANDLE   hPrinter,
   LPVOID   pBuf,
   DWORD    cbBuf,
   LPDWORD  pNoBytesRead
)
{
    PWSPOOL pSpool=(PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    return 0;

    UNREFERENCED_PARAMETER(pBuf);
    UNREFERENCED_PARAMETER(pNoBytesRead);
}

BOOL
LMEndDocPrinter(
   HANDLE hPrinter
)
{
    PWSPOOL  pSpool=(PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    if (!(pSpool->Status & WSPOOL_STATUS_STARTDOC)) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    pSpool->Status &= ~WSPOOL_STATUS_STARTDOC;

    if (pSpool->hFile != INVALID_HANDLE_VALUE) {

        CloseHandle(pSpool->hFile);
        pSpool->hFile = INVALID_HANDLE_VALUE;
    }

    return TRUE;
}

BOOL
LMAddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PWSPOOL      pSpool=(PWSPOOL)hPrinter;
    DWORD       cb;
    WCHAR       szFileName[MAX_PATH];
    LPBYTE      pEnd;
    LPADDJOB_INFO_1 pAddJob=(LPADDJOB_INFO_1)pData;

    VALIDATEW32HANDLE( pSpool );
    if(StrNCatBuff(szFileName,
                   COUNTOF(szFileName),
                   pSpool->pServer,
                   L"\\",
                   pSpool->pShare,
                   NULL) != ERROR_SUCCESS)
    {
        return(FALSE);
    }


    cb = wcslen(szFileName)*sizeof(WCHAR) + sizeof(WCHAR) + sizeof(ADDJOB_INFO_1);

    if (cb > cbBuf) {
        *pcbNeeded=cb;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    }

    pEnd  = (LPBYTE)pAddJob+cbBuf;
    cb    = wcslen(szFileName)*sizeof(WCHAR)+sizeof(WCHAR);
    pEnd -= cb;

    StringCbCopy((LPWSTR)pEnd, cb, szFileName);

    pAddJob->Path = (LPWSTR)pEnd;
    pAddJob->JobId = (DWORD)-1;

    return TRUE;
}

BOOL
LMScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
)
{
    PWSPOOL      pSpool=(PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    JobId = JobId;

    return TRUE;
}

DWORD
LMGetPrinterData(
    HANDLE   hPrinter,
    LPTSTR   pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
)
{
    PWSPOOL pSpool=(PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    return FALSE;
}

DWORD
LMSetPrinterData(
    HANDLE  hPrinter,
    LPTSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    PWSPOOL pSpool=(PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    return FALSE;
}

BOOL
LMClosePrinter(
   HANDLE hPrinter
)
{
    PWSPOOL pSpool=(PWSPOOL)hPrinter;
    PLMNOTIFY pLMNotify = &pSpool->LMNotify;
    BOOL bReturnValue = FALSE;

    VALIDATEW32HANDLE( pSpool );

   EnterSplSem();

    if (pSpool->Status & WSPOOL_STATUS_STARTDOC)
        EndDocPrinter(hPrinter);

    if (pLMNotify->ChangeEvent) {

        if (pLMNotify->ChangeEvent != INVALID_HANDLE_VALUE) {

            CloseHandle(pLMNotify->ChangeEvent);

        } else {

            LMFindClosePrinterChangeNotification(hPrinter);
        }
    }

   bReturnValue = TRUE;

   LeaveSplSem();

    return bReturnValue;
}

DWORD
LMWaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
)
{
    PWSPOOL pSpool = (PWSPOOL)hPrinter;
    PLMNOTIFY pLMNotify = &pSpool->LMNotify;
    HANDLE  ChangeEvent;
    DWORD bReturnValue = FALSE;

    EnterSplSem();
    
    if (pLMNotify->ChangeEvent) {

        SetLastError(ERROR_ALREADY_WAITING);
        goto Error;
    }

    // Allocate memory for ChangeEvent for LanMan Printers
    // This event is pulsed by LMSetJob and any othe LM
    // function that modifies the printer/job status
    // LMWaitForPrinterChange waits on this event
    // being pulsed.

    ChangeEvent = CreateEvent(NULL,
                              FALSE,
                              FALSE,
                              NULL);

    if (!ChangeEvent) {
        DBGMSG(DBG_WARNING, ("CreateEvent( ChangeEvent ) failed: Error %d\n",
                            GetLastError()));

        goto Error;
    }

    pLMNotify->ChangeEvent = ChangeEvent;

   LeaveSplSem();

    WaitForSingleObject(pLMNotify->ChangeEvent, NOTIFY_TIMEOUT);

    CloseHandle(ChangeEvent);

    //
    // We shouldn't return that everything changed; we should
    // return what did.
    //
    return Flags;

Error:
   LeaveSplSem();
    return 0;
}


BOOL
LMFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PDWORD pfdwStatus)
{
    PWSPOOL pSpool = (PWSPOOL)hPrinter;
    PLMNOTIFY pLMNotify = &pSpool->LMNotify;

   EnterSplSem();

    pLMNotify->hNotify = hNotify;
    pLMNotify->fdwChangeFlags = fdwFlags;
    pLMNotify->ChangeEvent = INVALID_HANDLE_VALUE;

    *pfdwStatus = PRINTER_NOTIFY_STATUS_ENDPOINT | PRINTER_NOTIFY_STATUS_POLL;

   LeaveSplSem();

    return TRUE;
}

BOOL
LMFindClosePrinterChangeNotification(
    HANDLE hPrinter)
{
    PWSPOOL pSpool = (PWSPOOL)hPrinter;
    PLMNOTIFY pLMNotify = &pSpool->LMNotify;

    SplInSem();

    if (pLMNotify->ChangeEvent != INVALID_HANDLE_VALUE) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    pLMNotify->hNotify = NULL;
    pLMNotify->ChangeEvent = NULL;

    return TRUE;
}

VOID
LMSetSpoolChange(
    PWSPOOL pSpool)
{
    PLMNOTIFY pLMNotify;

    pLMNotify = &pSpool->LMNotify;

    EnterSplSem();
    if (pLMNotify->ChangeEvent) {

        if (pLMNotify->ChangeEvent == INVALID_HANDLE_VALUE) {

            //
            // FindFirstPrinterChangeNotification used.
            //
            ReplyPrinterChangeNotification(pLMNotify->hNotify,
                                           pLMNotify->fdwChangeFlags,
                                           NULL,
                                           NULL);
        } else {

            SetEvent(pLMNotify->ChangeEvent);
        }
    }
    LeaveSplSem();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\lmprn.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    local.c

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    16-Jun-1992 JohnRo net print vs. UNICODE.
    July 1994   MattFe Caching

--*/

#include "precomp.h"

char szPMRaw[]="PM_Q_RAW";

WCHAR *szAdmin  =   L"ADMIN$";

extern HANDLE  hNetApi;
extern NET_API_STATUS (*pfnNetServerGetInfo)();
extern NET_API_STATUS (*pfnNetApiBufferFree)();

HMODULE hSpoolssDll = NULL;
FARPROC pfnSpoolssEnumPorts = NULL;

DWORD
GetPortSize(
    PWINIPORT pIniPort,
    DWORD   Level
)
{
    DWORD   cb;
    WCHAR   szMonitor[MAX_PATH+1], szPort[MAX_PATH+1];

    switch (Level) {

    case 1:

        cb=sizeof(PORT_INFO_1) +
           wcslen(pIniPort->pName)*sizeof(WCHAR) + sizeof(WCHAR);
        break;

    case 2:
        LoadString(hInst, IDS_MONITOR_NAME, szMonitor, sizeof(szMonitor)/sizeof(szMonitor[0])-1);
        LoadString(hInst, IDS_PORT_NAME, szPort, sizeof(szPort)/sizeof(szPort[0])-1);
        cb = wcslen(pIniPort->pName) + 1 +
             wcslen(szMonitor) + 1 +
             wcslen(szPort) + 1;
        cb *= sizeof(WCHAR);
        cb += sizeof(PORT_INFO_2);
        break;

    default:
        cb = 0;
        break;
    }

    return cb;
}


LPBYTE
CopyIniPortToPort(
    PWINIPORT pIniPort,
    DWORD   Level,
    LPBYTE  pPortInfo,
    LPBYTE   pEnd
)
{
    LPWSTR         *SourceStrings, *pSourceStrings;
    DWORD          *pOffsets;
    WCHAR           szMonitor[MAX_PATH+1], szPort[MAX_PATH+1];
    DWORD           Count;
    LPPORT_INFO_2   pPort2 = (LPPORT_INFO_2) pPortInfo;

    switch (Level) {

    case 1:
        pOffsets = PortInfo1Strings;
        break;

    case 2:
        pOffsets = PortInfo2Strings;
        break;

    default:
        DBGMSG(DBG_ERROR, ("CopyIniPortToPort: invalid level %d", Level));
        return pEnd;
    }

    for ( Count = 0 ; pOffsets[Count] != -1 ; ++Count ) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(Count * sizeof(LPWSTR));

    if ( !SourceStrings ) {
        DBGMSG(DBG_WARNING,
               ("CopyIniPortToPort: Failed to alloc port source strings.\n"));
        return NULL;
    }

    switch (Level) {

    case 1:

        *pSourceStrings++=pIniPort->pName;
        break;

    case 2:
        *pSourceStrings++=pIniPort->pName;
        LoadString(hInst, IDS_MONITOR_NAME, szMonitor, sizeof(szMonitor)/sizeof(szMonitor[0])-1);
        LoadString(hInst, IDS_PORT_NAME, szPort, sizeof(szPort)/sizeof(szPort[0])-1);
        *pSourceStrings++   = szMonitor;
        *pSourceStrings++   = szPort;
        pPort2->fPortType   = PORT_TYPE_WRITE;
        pPort2->Reserved    = 0;
        break;

    default:
        return pEnd;
        DBGMSG(DBG_ERROR,
               ("CopyIniPortToPort: invalid level %d", Level));
    }

    pEnd = PackStrings(SourceStrings, pPortInfo, pOffsets, pEnd);
    FreeSplMem(SourceStrings);
    return pEnd;
}


/* PortExists
 *
 * Calls EnumPorts to check whether the port name already exists.
 * This asks every monitor, rather than just this one.
 * The function will return TRUE if the specified port is in the list.
 * If an error occurs, the return is FALSE and the variable pointed
 * to by pError contains the return from GetLastError().
 * The caller must therefore always check that *pError == NO_ERROR.
 */
BOOL
PortExists(
    LPWSTR pName,
    LPWSTR pPortName,
    PDWORD pError
)
{
    DWORD cbNeeded;
    DWORD cReturned;
    DWORD cbPorts;
    LPPORT_INFO_1 pPorts;
    DWORD i;
    BOOL  Found = TRUE;

    *pError = NO_ERROR;

    if (!hSpoolssDll) {

        hSpoolssDll = LoadLibrary(L"SPOOLSS.DLL");

        if (hSpoolssDll) {
            pfnSpoolssEnumPorts = GetProcAddress(hSpoolssDll,
                                                 "EnumPortsW");
            if (!pfnSpoolssEnumPorts) {

                *pError = GetLastError();
                FreeLibrary(hSpoolssDll);
                hSpoolssDll = NULL;
            }

        } else {

            *pError = GetLastError();
        }
    }

    if (!pfnSpoolssEnumPorts)
        return FALSE;


    if (!(*pfnSpoolssEnumPorts)(pName, 1, NULL, 0, &cbNeeded, &cReturned))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            cbPorts = cbNeeded;

            pPorts = AllocSplMem(cbPorts);

            if (pPorts)
            {
                if ((*pfnSpoolssEnumPorts)(pName, 1, (LPBYTE)pPorts, cbPorts,
                                           &cbNeeded, &cReturned))
                {
                    Found = FALSE;

                    for (i = 0; i < cReturned; i++)
                    {
                        if (!lstrcmpi(pPorts[i].pName, pPortName))
                            Found = TRUE;
                    }
                }
            }

            FreeSplMem(pPorts);
        }
    }

    else
        Found = FALSE;


    return Found;
}



BOOL
LMOpenPrinter(
    LPWSTR   pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTS pDefault
)
{
    PWINIPORT pIniPort;
    PWSPOOL  pSpool;
    DWORD   cb;
    PUSE_INFO_0 pUseInfo;
    LPWSTR  pShare;
    WCHAR   PrinterName[MAX_UNC_PRINTER_NAME];
    DWORD   cbNeeded;
    DWORD   rc;
    BYTE    Buffer[4];
    DWORD   Error = NO_ERROR;
    DWORD   dwEntry = 0xffffffff;
    PSERVER_INFO_101 pserver_info_101 = NULL;


    /* If we already have an INI port entry by this name, don't worry
     * about hitting the network.  This ensures that we don't try to
     * make a network call when we're not impersonating - like on
     * bootup.
     */
    if (!(pIniPort = FindPort(pPrinterName, pIniFirstPort))) {

        if (!NetUseGetInfo(NULL, pPrinterName, 0, (LPBYTE *)&pUseInfo))
            pPrinterName = AllocSplStr(pUseInfo->ui0_remote);

        NetApiBufferFree( (LPVOID) pUseInfo );
    }

    if ( !pPrinterName ||
         *pPrinterName != L'\\' ||
         *(pPrinterName+1) != L'\\' ||
         wcslen(pPrinterName) + 1 > MAX_UNC_PRINTER_NAME ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    StringCchCopy(PrinterName, COUNTOF(PrinterName), pPrinterName);
    pShare=wcschr(PrinterName+2, L'\\');

    if ( !pShare ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    *pShare++=0;


    if (!pIniPort) {

        /* Verify that this guy actually exists.
         * Call it with a zero-length buffer,
         * and see if the error is that the buffer isn't big enough.
         * If we make Buffer = NULL, it fails with
         * ERROR_INVALID_PARAMETER, which is pretty abysmal,
         * so we must pass a Buffer address.
         * (Actually, it seems to accept any non-NULL value,
         * regardless of whether it's a valid address.)
         */

        EnterSplSem();
        dwEntry = FindEntryinLMCache(PrinterName, pShare);
        LeaveSplSem();

        if (dwEntry == -1) {

            DBGMSG(DBG_TRACE, ("We haven't cached this entry so  we have to hit the net\n"));

            rc = RxPrintQGetInfo(PrinterName,   /* e.g. \\msprint07                 */
                                 pShare,        /* e.g. l07corpa                    */
                                 0,             /* Level 0                          */
                                 Buffer,        /* Dummy - won't get filled in      */
                                 0,             /* Length of buffer                 */
                                 &cbNeeded);    /* How much we need - we'll ignore  */

            DBGMSG(DBG_INFO, ("LMOpenPrinter!RxPrintQGetInfo returned %d\n", rc));

            if (rc == ERROR_ACCESS_DENIED) {

                /* The print share exists; we just don't have access to it.
                 */
                SetLastError(ERROR_ACCESS_DENIED);
                return FALSE;
            }

            if (!((rc == ERROR_MORE_DATA)
                ||(rc == NERR_BufTooSmall)
                ||(rc == ERROR_INSUFFICIENT_BUFFER))) {
                SetLastError(ERROR_INVALID_NAME);
                return FALSE;
            }

            //
            // Be sure that we are connecting to a downlevel server.
            // If the server is Windows NT Machine, then fail the call:
            // downlevel NT connections won't work properly because
            // "\\Server\Printer Name" will get past RxPrintQGetInfo, but
            // we can't do CreateFile on it (we need to user the share
            // name).  Downlevel connects also lose admin functionality.
            //
            if (pfnNetServerGetInfo) {

                rc = pfnNetServerGetInfo(PrinterName, 101, &pserver_info_101);

                //
                // Advanced Server for Unix (ASU) by AT&T reports that
                // they are TYPE_NT even though they don't support the
                // rpc interface.  They also set TYPE_XENIX_SERVER.
                // Since the need lm connections, allow them when
                // TYPE_XENIX_SERVER is specified.
                //
                // Also make this change for SERVER_VMS and SERVER_OSF.
                // These changes are for AT&T also.
                //
                // Note: this will also allow accidental downlevel
                // connections to any servers that set TYPE_XENIX_SERVER,
                // TYPE_SERVER_VMS, or TYPE_SERVER_OSF.
                //

                if (!rc &&
                    (pserver_info_101->sv101_type & SV_TYPE_NT) &&
                    !(pserver_info_101->sv101_type &
                          ( SV_TYPE_XENIX_SERVER |
                            SV_TYPE_SERVER_VMS   |
                            SV_TYPE_SERVER_OSF))) {

                    DBGMSG(DBG_WARNING, ("NetServerGetInfo indicates %ws is a WinNT\n", PrinterName));
                    pfnNetApiBufferFree((LPVOID)pserver_info_101);

                    SetLastError(ERROR_INVALID_NAME);
                    return FALSE;
                }

                //
                // Now free the buffer
                //
                if (pserver_info_101) {
                    pfnNetApiBufferFree((LPVOID)pserver_info_101);
                }
            }

            //
            // Add entry to the cache
            //
            EnterSplSem();
            AddEntrytoLMCache(PrinterName, pShare);
            LeaveSplSem();
        }
    }
   
    /* Make sure there's a port of this name so that
     * EnumPorts will return it:
     */
    if (!PortExists(NULL, pPrinterName, &Error) && (Error == NO_ERROR)) {
        if (CreatePortEntry(pPrinterName, &pIniFirstPort)) {
            Error = CreateRegistryEntry(pPrinterName);
        }
    }

    if (Error != NO_ERROR) {
        SetLastError(Error);
        return FALSE;
    }

    cb = sizeof(WSPOOL);

   EnterSplSem();
    pSpool = AllocWSpool();
   LeaveSplSem();

    if ( pSpool != NULL ) {

        pSpool->pServer = AllocSplStr(PrinterName);
        pSpool->pShare = AllocSplStr(pShare);
        pSpool->Status = 0;
        pSpool->Type = LM_HANDLE;

    } else {

        DBGMSG(DBG_TRACE,("Error: LMOpenPrinter to return ERROR_NOT_ENOUGH_MEMORY\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return FALSE;
    }

    *phPrinter = (HANDLE)pSpool;

    return TRUE;
}

BOOL
LMSetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
)
{
    PWSPOOL          pSpool = (PWSPOOL)hPrinter;

    API_RET_TYPE    uReturnCode;
    DWORD           dwParmError;
    USE_INFO_1      UseInfo1;
    PUSE_INFO_1     pUseInfo1 = &UseInfo1;
    WCHAR           szRemoteShare[MAX_PATH];
    DWORD           dwRet;


    if (!pSpool ||
        pSpool->signature != WSJ_SIGNATURE) {

        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if( (dwRet = StrNCatBuff(szRemoteShare, COUNTOF(szRemoteShare), pSpool->pServer, L"\\", szAdmin, NULL )) != ERROR_SUCCESS ) {

        SetLastError(dwRet);
        return FALSE;
    }

    pUseInfo1->ui1_local = NULL;
    pUseInfo1->ui1_remote =   szRemoteShare;
    pUseInfo1->ui1_password = NULL;
    pUseInfo1->ui1_asg_type = 0;
    dwParmError = 0;

    switch (Command) {

    case 0:
        break;

    case PRINTER_CONTROL_PURGE:
        uReturnCode = RxPrintQPurge(pSpool->pServer, pSpool->pShare);
        if (uReturnCode) {

            uReturnCode = NetUseAdd(NULL, 1,
                               (LPBYTE)pUseInfo1,
                               &dwParmError);
            if (uReturnCode == ERROR_ACCESS_DENIED) {
                SetLastError(ERROR_ACCESS_DENIED);
                return(FALSE);

            } else {

                uReturnCode = RxPrintQPurge(pSpool->pServer, pSpool->pShare);
                if (uReturnCode == ERROR_ACCESS_DENIED) {
                    NetUseDel(NULL,
                                pUseInfo1->ui1_remote, USE_FORCE);
                    SetLastError(ERROR_ACCESS_DENIED);
                    return(FALSE);
                }
                NetUseDel(NULL,
                                pUseInfo1->ui1_remote, USE_FORCE);
            }
        }
        break;

    case PRINTER_CONTROL_RESUME:
        uReturnCode = RxPrintQContinue(pSpool->pServer, pSpool->pShare);
        if (uReturnCode) {

            uReturnCode = NetUseAdd(NULL, 1,
                                    (LPBYTE)pUseInfo1,
                                    &dwParmError);
            if (uReturnCode == ERROR_ACCESS_DENIED) {
                SetLastError(ERROR_ACCESS_DENIED);
                return(FALSE);

            } else {
                uReturnCode = RxPrintQContinue(pSpool->pServer, pSpool->pShare);
                if (uReturnCode == ERROR_ACCESS_DENIED) {
                    NetUseDel(NULL,
                                    pUseInfo1->ui1_remote, USE_FORCE);
                    SetLastError(ERROR_ACCESS_DENIED);
                    return(FALSE);
                }
                NetUseDel(NULL,
                                    pUseInfo1->ui1_remote, USE_FORCE);
            }
        }
        break;

    case PRINTER_CONTROL_PAUSE:
        uReturnCode = RxPrintQPause(pSpool->pServer, pSpool->pShare);
        if (uReturnCode) {

            uReturnCode = NetUseAdd(NULL, 1,
                                    (LPBYTE)pUseInfo1,
                                    &dwParmError);
            if (uReturnCode == ERROR_ACCESS_DENIED) {
                SetLastError(ERROR_ACCESS_DENIED);
                return(FALSE);

            } else {
                uReturnCode = RxPrintQPause(pSpool->pServer, pSpool->pShare);
                if (uReturnCode) {
                    NetUseDel(NULL,
                                        pUseInfo1->ui1_remote, USE_FORCE);
                    SetLastError(ERROR_ACCESS_DENIED);
                    return(FALSE);
                }
                NetUseDel(NULL,
                                    pUseInfo1->ui1_remote, USE_FORCE);
            }

        }
        break;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        break;
    }

    //
    // SetPrinter successful - so pulse here if event set,
    // or reply to spooler.
    //
    LMSetSpoolChange(pSpool);

    return TRUE;
}

#define Nullstrlen(psz)  ((psz) ? wcslen(psz)*sizeof(WCHAR)+sizeof(WCHAR) : 0)

DWORD
GetPrqInfo3Size(
    PWSPOOL  pSpool,
    PRQINFO3 *pPrqInfo3,
    DWORD   Level
)
{
    DWORD   cb;

    switch (Level) {

    case 1:

        //
        // 3 extra chars
        // (2 NULL terminators, 1 for '\' (server/share separator)
        //
        cb=sizeof(PRINTER_INFO_1) +
           wcslen(pSpool->pServer)*sizeof(WCHAR)*2 +
           wcslen(pSpool->pShare)*sizeof(WCHAR) +
           sizeof(WCHAR)*3 +
           Nullstrlen(pPrqInfo3->pszComment);
        break;

    case 2:

        cb = sizeof(PRINTER_INFO_2) +
             wcslen(pSpool->pServer)*sizeof(WCHAR) + sizeof(WCHAR) +
             wcslen(pSpool->pShare)*sizeof(WCHAR) + sizeof(WCHAR) +
             wcslen(pSpool->pServer)*sizeof(WCHAR) +
             sizeof(WCHAR) +
             wcslen(pSpool->pShare)*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pPrqInfo3->pszPrinters) +
             Nullstrlen(pPrqInfo3->pszDriverName) +
             Nullstrlen(pPrqInfo3->pszComment) +
             Nullstrlen(pPrqInfo3->pszSepFile) +
             Nullstrlen(pPrqInfo3->pszPrProc) +
             wcslen(L"RAW")*sizeof(WCHAR) + sizeof(WCHAR) +
             Nullstrlen(pPrqInfo3->pszParms);
        break;

    default:
        cb = 0;
        break;
    }

    return cb;
}

// This can be radically tidied up
// We should probably use the stack for the
// array of string pointers rather than dynamically allocating it !

LPBYTE
CopyPrqInfo3ToPrinter(
    PWSPOOL  pSpool,
    PRQINFO3 *pPrqInfo3,
    DWORD   Level,
    LPBYTE  pPrinterInfo,
    LPBYTE  pEnd
)
{
    LPWSTR  *pSourceStrings, *SourceStrings;
    PPRINTER_INFO_2 pPrinter2 = (PPRINTER_INFO_2)pPrinterInfo;
    PPRINTER_INFO_1 pPrinter1 = (PPRINTER_INFO_1)pPrinterInfo;
    DWORD   i;
    DWORD   *pOffsets;
    DWORD   RetVal = ERROR_SUCCESS;
    WCHAR   szFileName[MAX_PATH];

    switch (Level) {

    case 1:
        pOffsets = PrinterInfo1Strings;
        break;

    case 2:
        pOffsets = PrinterInfo2Strings;
        break;

    default:
        return pEnd;
    }

    for (i=0; pOffsets[i] != -1; i++) {
    }

    SourceStrings = pSourceStrings = AllocSplMem(i * sizeof(LPWSTR));

    if (!SourceStrings)
        return NULL;

    switch (Level) {

    case 1:
        *pSourceStrings++=pSpool->pServer;

        RetVal = StrNCatBuff( szFileName, 
                              COUNTOF(szFileName),
                              pSpool->pServer,
                              L"\\",
                              pSpool->pShare,
                              NULL );
        if ( RetVal != ERROR_SUCCESS )
        {
          break;
        }

        *pSourceStrings++=szFileName;
        *pSourceStrings++=pPrqInfo3->pszComment;

        pEnd = PackStrings(SourceStrings, pPrinterInfo, pOffsets, pEnd);

        pPrinter1->Flags = PRINTER_ENUM_REMOTE | PRINTER_ENUM_NAME;
        break;

    case 2:

        RetVal = StrNCatBuff( szFileName, 
                              COUNTOF(szFileName),
                              pSpool->pServer,
                              L"\\",
                              pSpool->pShare,
                              NULL );
        if ( RetVal != ERROR_SUCCESS )
        {
          break;
        }


        *pSourceStrings++=pSpool->pServer;

        *pSourceStrings++=szFileName;

        *pSourceStrings++=pSpool->pShare;
        *pSourceStrings++=pPrqInfo3->pszPrinters;
        *pSourceStrings++=pPrqInfo3->pszDriverName ? pPrqInfo3->pszDriverName : L"";
        *pSourceStrings++=pPrqInfo3->pszComment;
        *pSourceStrings++=NULL;
        *pSourceStrings++=pPrqInfo3->pszSepFile;
        *pSourceStrings++=pPrqInfo3->pszPrProc;
        *pSourceStrings++=L"RAW";
        *pSourceStrings++=pPrqInfo3->pszParms;

        pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter2, pOffsets, pEnd);

        pPrinter2->pDevMode=0;
        pPrinter2->Attributes=PRINTER_ATTRIBUTE_QUEUED;
        pPrinter2->Priority=pPrqInfo3->uPriority;
        pPrinter2->DefaultPriority=pPrqInfo3->uPriority;
        pPrinter2->StartTime=pPrqInfo3->uStartTime;
        pPrinter2->UntilTime=pPrqInfo3->uUntilTime;

        pPrinter2->Status=0;

        if (pPrqInfo3->fsStatus & PRQ3_PAUSED)
            pPrinter2->Status|=PRINTER_STATUS_PAUSED;

        if (pPrqInfo3->fsStatus & PRQ3_PENDING)
            pPrinter2->Status|=PRINTER_STATUS_PENDING_DELETION;

        pPrinter2->cJobs=pPrqInfo3->cJobs;
        pPrinter2->AveragePPM=0;
        break;

    default:
        return pEnd;
    }

    FreeSplMem(SourceStrings);

    if ( RetVal == ERROR_SUCCESS )
    {
        return pEnd;
    }
    else
    {
        return NULL;
    }
}

BOOL
LMGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;
    PRQINFO3 *pPrqInfo3;
    PRQINFO3 PrqInfo3;
    PRQINFO *pPrqInfo=NULL;
    DWORD   cb = 0x400;
    DWORD   rc;
    DWORD   cbNeeded;
    LPBYTE  pInfo = NULL;
    BOOL    bWFW = FALSE;


    if (Level >= 7) {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (!pSpool ||
        pSpool->signature != WSJ_SIGNATURE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    pPrqInfo3 = AllocSplMem(cb);

    if ( !pPrqInfo3 )
        goto Cleanup;

    if ( rc = RxPrintQGetInfo(pSpool->pServer, pSpool->pShare, 3,
                              (PBYTE)pPrqInfo3, cb, &cbNeeded)) {

        if (rc == ERROR_MORE_DATA || rc == NERR_BufTooSmall) {

            pPrqInfo3=ReallocSplMem(pPrqInfo3, 0, cbNeeded);

            if ( !pPrqInfo3 )
                goto Cleanup;

            cb=cbNeeded;

            if (rc = RxPrintQGetInfo(pSpool->pServer, pSpool->pShare,
                                     3, (PBYTE)pPrqInfo3, cb, &cbNeeded)) {

                SetLastError(rc);
                goto Cleanup;
            }

        } else if (rc == ERROR_INVALID_LEVEL) {

            // Must be WFW

            if (rc = RxPrintQGetInfo(pSpool->pServer, pSpool->pShare, 1,
                                     (PBYTE)pPrqInfo3, cb, &cbNeeded)) {

                if (rc == ERROR_MORE_DATA || rc == NERR_BufTooSmall) {

                    pPrqInfo3 = ReallocSplMem(pPrqInfo3, 0, cbNeeded);

                    if ( !pPrqInfo3 )
                        goto Cleanup;

                    cb=cbNeeded;

                    if (rc = RxPrintQGetInfo(pSpool->pServer, pSpool->pShare, 1,
                                             (PBYTE)pPrqInfo3, cb, &cbNeeded)) {

                        SetLastError(rc);
                        goto Cleanup;
                    }

                } else {

                    SetLastError(rc);
                    goto Cleanup;
                }
            }

            pPrqInfo = (PRQINFO *)pPrqInfo3;

            PrqInfo3.pszName = pPrqInfo->szName;
            PrqInfo3.uPriority = pPrqInfo->uPriority;
            PrqInfo3.uStartTime = pPrqInfo->uStartTime;
            PrqInfo3.uUntilTime = pPrqInfo->uUntilTime;
            PrqInfo3.pad1 = 0;
            PrqInfo3.pszSepFile = pPrqInfo->pszSepFile;
            PrqInfo3.pszPrProc = pPrqInfo->pszPrProc;
            PrqInfo3.pszParms = pPrqInfo->pszDestinations;
            PrqInfo3.pszComment = pPrqInfo->pszComment;
            PrqInfo3.fsStatus = pPrqInfo->fsStatus;
            PrqInfo3.cJobs = pPrqInfo->cJobs;
            PrqInfo3.pszPrinters = pPrqInfo->pszDestinations;
            PrqInfo3.pszDriverName = L"";
            PrqInfo3.pDriverData = NULL;

            bWFW = TRUE;

        } else {

            SetLastError(rc);
            goto Cleanup;
        }
    }

    cbNeeded=GetPrqInfo3Size(pSpool,
                             bWFW ? &PrqInfo3 : pPrqInfo3,
                             Level);

    *pcbNeeded=cbNeeded;

    if (cbNeeded > cbBuf) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    pInfo = CopyPrqInfo3ToPrinter(pSpool,
                                  bWFW ? &PrqInfo3 : pPrqInfo3,
                                  Level,
                                  pPrinter,
                                  (LPBYTE)pPrinter+cbBuf);

Cleanup:
    if (pPrqInfo3)
        FreeSplMem(pPrqInfo3);

    return pInfo != NULL;
}

BOOL
LMEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    rc=TRUE;
    DWORD   cb;
    PWINIPORT pIniPort;
    LPBYTE  pEnd;


    switch (Level) {

    case 1:
        break;

    case 2:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

   EnterSplSem();

    cb=0;

    pIniPort = pIniFirstPort;

    while (pIniPort) {
        cb+=GetPortSize(pIniPort, Level);
        pIniPort=pIniPort->pNext;
    }

    *pcbNeeded=cb;


    if (cb <= cbBuf) {

        pEnd=pPorts+cbBuf;
        *pcReturned=0;

        pIniPort = pIniFirstPort;
        while (pIniPort) {
            pEnd = CopyIniPortToPort(pIniPort, Level, pPorts, pEnd);
            switch (Level) {
            case 1:
                pPorts+=sizeof(PORT_INFO_1);
                break;

            case 2:
                pPorts+=sizeof(PORT_INFO_2);
                break;
            }
            pIniPort=pIniPort->pNext;
            (*pcReturned)++;
        }

    } else {

        *pcReturned = 0;

        rc = FALSE;

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

   LeaveSplSem();

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\local.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    local.h

Abstract:

    Header file for Remote Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    16-Jun-1992 JohnRo net print vs. UNICODE.

    July 12 1994 Matthew Felton (MattFe) Caching

--*/

#ifndef _WIN32SPLLOCAL_H_
#define _WIN32SPLLOCAL_H_

// ID in the PRINTMAN.HLP file for the Browse Network dialog.
// This must not clash with IDs used in other places.

#ifdef __cplusplus
extern "C" {
#endif

#define CALL_LM_OPEN                        TRUE
#define DO_NOT_CALL_LM_OPEN                 FALSE
#define GET_SECURITY_DESCRIPTOR             3
#define DO_NOT_USE_SCRATCH_DIR              FALSE
#define STRINGS_ARE_EQUAL                   0

//
// These define the values we fake out for a GetPrinter level 5 and EnumPrinter
// level 5 for the port Timeouts.
//
enum
{
    kDefaultDnsTimeout = 15000,
    kDefaultTxTimeout  = 45000
};

typedef enum
{
    kCheckPnPPolicy,
    kDownloadDriver,
    kDontDownloadDriver

} EDriverDownload;

#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) < (b) ? (a) : (b))

extern HANDLE  hInst;
extern CRITICAL_SECTION    SpoolerSection;

extern WCHAR *szRegistryPath;
extern WCHAR *szRegistryPortNames;
extern PWCHAR pszRaw;

extern HANDLE  hNetApi;
extern NET_API_STATUS (*pfnNetServerEnum)();
extern NET_API_STATUS (*pfnNetWkstaUserGetInfo)();
extern NET_API_STATUS (*pfnNetApiBufferFree)();

extern WCHAR szPrintProvidorName[];
extern WCHAR szPrintProvidorDescription[];
extern WCHAR szPrintProvidorComment[];
extern WCHAR *szLoggedOnDomain;
extern WCHAR *szRegistryConnections;
extern WCHAR szRegistryWin32Root[];
extern WCHAR szOldLocationOfServersKey[];
extern const WCHAR gszRegistryPrinterPolicies[];
extern PWCHAR szWin32SplDirectory;

extern PWINIPORT pIniFirstPort;
extern PWSPOOL   pFirstWSpool;

extern WCHAR szMachineName[];
extern PWCHAR pszMonitorName;
extern PWCHAR gpSystemDir;
extern PWCHAR gpWin32SplDir;
extern const WCHAR gszOpenPrinterThreadLimit[];

extern const WCHAR pszCnvrtdmToken[];
extern const WCHAR pszDrvConvert[];

extern DWORD cThisMajorVersion;
extern DWORD cThisMinorVersion;
extern DWORD gdwThisGetVersion;
extern WCHAR *szVersion;
extern WCHAR *szName;
extern WCHAR *szConfigurationFile;
extern WCHAR *szDataFile;
extern WCHAR *szDriver;

extern WCHAR *szEnvironment;
extern DWORD dwSyncOpenPrinter;
extern UINT  cOpenPrinterThreads;

extern const WCHAR gszPointAndPrintPolicies[];
extern const WCHAR gszPointAndPrintRestricted[];
extern const WCHAR gszPointAndPrintInForest[];
extern const WCHAR gszPointAndPrintTrustedServers[];
extern const WCHAR gszPointAndPrintServerList[];

extern BOOL  gbMachineInDomain;

extern DWORD dwOpenPrinterThreadTimeOut;

#define IDS_LANMAN_PRINT_SHARE          100
#define IDS_NOTHING_TO_CONFIGURE        101
#define IDS_WINDOWS_NT_REMOTE_PRINTERS  102
#define IDS_MICROSOFT_WINDOWS_NETWORK   103
#define IDS_REMOTE_PRINTERS             104
#define IDS_MONITOR_NAME                105
#define IDS_PORT_NAME                   106

#define MAX_PRINTER_INFO0   2*MAX_PATH*sizeof(WCHAR) + sizeof( PRINTER_INFO_STRESSW)


BOOL
MyName(
    LPWSTR   pName
);

BOOL
MyUNCName(
    LPWSTR   pName
);

BOOL
Initialize(
   VOID
);

VOID
SplInSem(
   VOID
);

VOID
SplOutSem(
   VOID
);

VOID
EnterSplSem(
   VOID
);

VOID
LeaveSplSem(
   VOID
);

PWINIPORT
FindPort(
   LPWSTR pName,
   PWINIPORT pFirstPort
);

BOOL
LMSetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
);

BOOL
LMGetJob(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);

BOOL
LMEnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
LMOpenPrinter(
    LPWSTR   pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTS pDefault
);

BOOL
LMSetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
);

BOOL
LMGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
LMEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

DWORD
LMStartDocPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);

BOOL
LMStartPagePrinter(
    HANDLE  hPrinter
);

BOOL
LMWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);

BOOL
LMEndPagePrinter(
    HANDLE  hPrinter
);

BOOL
LMAbortPrinter(
   HANDLE hPrinter
);

BOOL
LMReadPrinter(
   HANDLE   hPrinter,
   LPVOID   pBuf,
   DWORD    cbBuf,
   LPDWORD  pNoBytesRead
);

BOOL
LMEndDocPrinter(
   HANDLE hPrinter
);

BOOL
LMAddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
LMScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
);

DWORD
LMGetPrinterData(
    HANDLE   hPrinter,
    LPTSTR   pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);

DWORD
LMSetPrinterData(
    HANDLE  hPrinter,
    LPTSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);

BOOL
LMClosePrinter(
   HANDLE hPrinter
);

DWORD
LMWaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
);

VOID
LMSetSpoolChange(
    PWSPOOL pSpool
);

BOOL
LMFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hPrinterLocal,
    PDWORD pfdwStatus);

BOOL
LMFindClosePrinterChangeNotification(
    HANDLE hPrinter);

VOID
LMSetSpoolerChange(
    PWSPOOL pSpool);

BOOL
LMDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);

BOOL
LMEnumMonitors(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

PWINIPORT
CreatePortEntry(
    LPWSTR   pPortName,
    PPWINIPORT  ppFirstPort
);

BOOL
DeletePortEntry(
    LPWSTR   pPortName,
    PPWINIPORT  ppFirstPort
);

DWORD
CreateRegistryEntry(
    LPWSTR pPortName
);

HKEY
GetClientUserHandle(
    IN REGSAM samDesired
);


DWORD
IsOlderThan(
    DWORD i,
    DWORD j
    );


DWORD
AddEntrytoLMCache(
    LPWSTR pServerName,
    LPWSTR pShareName
    );


DWORD
FindEntryinLMCache(
    LPWSTR pServerName,
    LPWSTR pShareName
    );


VOID
DeleteEntryfromLMCache(
    LPWSTR pServerName,
    LPWSTR pShareName
    );


DWORD
FindEntryinWin32LMCache(
    LPWSTR pServerName
    );


VOID
DeleteEntryfromWin32LMCache(
    LPWSTR pServerName
    );


DWORD
AddEntrytoWin32LMCache(
    LPWSTR pServerName
    );

HANDLE
AddPrinterConnectionToCache(
    LPWSTR   pName,
    HANDLE  hPrinter,
    LPDRIVER_INFO_2W pDriverInfo
);

VOID
RefreshFormsCache(
    PWSPOOL pSpool
);

VOID
RefreshDriverDataCache(
    PWSPOOL pSpool
);

VOID
RefreshPrinterDataCache(
    PWSPOOL pSpool
);


DWORD
EnumerateAndCopyKey(
    PWSPOOL pSpool,
    LPWSTR  pKeyName
);


BOOL
CacheGetForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
RemoteGetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);


BOOL
CacheEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
RemoteEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);


DWORD
CacheGetPrinterData(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
);


DWORD
CacheGetPrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
);

DWORD
RemoteGetPrinterData(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
);


DWORD
RemoteGetPrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
);

DWORD
RemoteEnumPrinterData(
    HANDLE   hPrinter,
    DWORD    dwIndex,
    LPWSTR   pValueName,
    DWORD    cbValueName,
    LPDWORD  pcbValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    cbData,
    LPDWORD  pcbData
);

DWORD
RemoteEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
);

DWORD
CacheEnumPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPBYTE  pEnumValues,
    DWORD   cbEnumValues,
    LPDWORD pcbEnumValues,
    LPDWORD pnEnumValues
);

DWORD
RemoteEnumPrinterKey(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName,
    LPWSTR   pSubkey,
    DWORD    cbSubkey,
    LPDWORD  pcbSubkey
);

DWORD
CacheEnumPrinterKey(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName,
    LPWSTR   pSubkey,
    DWORD    cbSubkey,
    LPDWORD  pcbSubkey
);

DWORD
RemoteDeletePrinterData(
    HANDLE   hPrinter,
    LPWSTR   pValueName
);

DWORD
RemoteDeletePrinterDataEx(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName,
    LPCWSTR  pValueName
);

DWORD
RemoteDeletePrinterKey(
    HANDLE   hPrinter,
    LPCWSTR  pKeyName
);

DWORD
RemoteSetPrinterDataEx(
    HANDLE  hPrinter,
    LPCTSTR pKeyName,
    LPCTSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);

BOOL
RemoteXcvData(
    HANDLE      hXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus
);

LPWSTR
RemoveBackslashesForRegistryKey(
    LPWSTR pSource,
    const LPWSTR pScratch
);

LPBYTE
CopyPrinterNameToPrinterInfo(
    LPWSTR pServerName,
    LPWSTR pPrinterName,
    DWORD   Level,
    LPBYTE  pPrinter,
    LPBYTE  pEnd
);

BOOL
GetPrintSystemVersion(
);

BOOL Win32IsGoingToFile(
    HANDLE hPrinter,
    LPWSTR pOutputFile
);

LPWSTR
FormatPrinterForRegistryKey(
    LPCWSTR pSource,      /* The string from which backslashes are to be removed. */
    LPWSTR  pScratch,     /* Scratch buffer for the function to write in;     */
    DWORD   cchScratchLen /* must be at least as long as pSource.             */
    );

LPWSTR
FormatRegistryKeyForPrinter(
    LPWSTR pSource,      /* The string from which backslashes are to be added. */
    LPWSTR pScratch,     /* Scratch buffer for the function to write in;     */
    DWORD  cchScratchLen /* must be at least as long as pSource.             */
    );

DWORD
InitializePortNames(
);

BOOL
WIN32FindFirstPrinterChangeNotification(
   HANDLE hPrinter,
   DWORD fdwFlags,
   DWORD fdwOptions,
   HANDLE hNotify,
   PDWORD pfdwStatus,
   PVOID  pvReserved0,
   PVOID  pvReserved1);

BOOL
WIN32FindClosePrinterChangeNotification(
   HANDLE hPrinter);


/* VALIDATE_NAME macro:
 *
 * pName is valid if:
 *
 *     pName is non-null
 *
 *     AND  first 2 characters of pName are "\\"
 *
 */
#define VALIDATE_NAME(pName) \
    ((pName) && *(pName) == L'\\' && *((pName)+1) == L'\\')




typedef struct _GENERIC_CONTAINER {
    DWORD       Level;
    LPBYTE      pData;
} GENERIC_CONTAINER, *PGENERIC_CONTAINER, *LPGENERIC_CONTAINER ;

BOOL
RemoteOpenPrinter(
   LPWSTR   pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSW pDefault,
   BOOL     CallLMOpenPrinter
);

BOOL
RemoteClosePrinter(
    HANDLE hPrinter
);

BOOL
RemoteGetPrinterDriverDirectory(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
RemoteGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
CacheGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
PrinterConnectionExists(
    LPWSTR pPrinterName
);

BOOL
AddPrinterConnectionPrivate(
    LPWSTR pName
);

BOOL
CacheOpenPrinter(
   LPWSTR   pName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTS pDefault
);

VOID
IncThreadCount(
    VOID
);

VOID
DecThreadCount(
    VOID
);

BOOL
GetSid(
    PHANDLE phToken
);

BOOL
SetCurrentSid(
    HANDLE  hToken
);

BOOL
DoAsyncRemoteOpenPrinter(
    PWSPOOL pSpool,
    LPPRINTER_DEFAULTS pDefault
);

DWORD
RemoteOpenPrinterThread(
    PWIN32THREAD    pThread
);

BOOL
CacheClosePrinter(
    HANDLE  hPrinter
);


VOID
FreepSpool(
    PWSPOOL  pSpool
);

BOOL
DoRemoteOpenPrinter(
   LPWSTR               pPrinterName,
   LPPRINTER_DEFAULTS   pDefault,
   PWSPOOL              pSpool   
);

PWSPOOL
AllocWSpool(
    VOID
);

BOOL
CacheSyncRpcHandle(
    PWSPOOL pSpool
);

BOOL
ValidateW32SpoolHandle(
    PWSPOOL pSpool
);

#define SYNCRPCHANDLE( pSpool )     if ( !CacheSyncRpcHandle( pSpool ) ) { SplOutSem();  return FALSE; }
#define VALIDATEW32HANDLE( pSpool ) if ( !ValidateW32SpoolHandle( pSpool ) ) return FALSE;


BOOL
CacheResetPrinter(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTS pDefault
);

BOOL
RemoteResetPrinter(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTS pDefault
);

BOOL
CopypDefaults(
    LPPRINTER_DEFAULTSW pSrc,
    LPPRINTER_DEFAULTSW pDest
);

BOOL
CopypDefaultTopSpool(
    PWSPOOL pSpool,
    LPPRINTER_DEFAULTSW pDefault
);

HANDLE
MySplCreateSpooler(
    LPWSTR  pMachineName
);

VOID
RefreshCompletePrinterCache(
    IN      PWSPOOL             pSpool,
    IN      EDriverDownload     eDriverDownload
    );

VOID
ConvertRemoteInfoToLocalInfo(
    PPRINTER_INFO_2 pRemoteInfo
);

VOID
RefreshPrinter(
    PWSPOOL pSpool
);

VOID
RefreshPrinterInfo7(
    PWSPOOL pSpool
);

BOOL
CacheWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);


BOOL
RemoteEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPort,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
RemoteAddPort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
);


BOOL
RemoteConfigurePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);

BOOL
RemoteDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);

BOOL
RemoteAddPortEx(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   lpBuffer,
   LPWSTR   lpMonitorName
);

LPBYTE
CopyIniPortToPort(
    PWINIPORT pIniPort,
    DWORD   Level,
    LPBYTE  pPortInfo,
    LPBYTE   pEnd
);


DWORD
GetPortSize(
    PWINIPORT pIniPort,
    DWORD   Level
);

BOOL
CacheWriteRegistryExtra(
    LPWSTR  pName,
    HKEY    hPrinterKey,
    PWCACHEINIPRINTEREXTRA pExtraData
);


PWCACHEINIPRINTEREXTRA
CacheReadRegistryExtra(
    HKEY    hPrinterKey
);

PWCACHEINIPRINTEREXTRA
AllocExtraData(
    PPRINTER_INFO_2W pPrinterInfo2,
    DWORD cbPrinterInfo2
);

VOID
CacheFreeExtraData(
    PWCACHEINIPRINTEREXTRA pExtraData
);


BOOL
RemoteGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
CacheGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

DWORD
GetCachePrinterInfoSize(
    PWCACHEINIPRINTEREXTRA pExtraData
);

VOID
DownAndMarshallUpStructure(
   LPBYTE       lpStructure,
   LPBYTE       lpSource,
   LPDWORD      lpOffsets
);

VOID
CacheCopyPrinterInfo(
    PPRINTER_INFO_2W    pDestination,
    PPRINTER_INFO_2W    pPrinterInfo2,
    DWORD   cbPrinterInfo2
);

HRESULT
ConsistencyCheckCache(
    IN      PWSPOOL             pSpool,
    IN      EDriverDownload     eDriverDownload
    );

BOOL
CopyFileWithoutImpersonation(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists,
    BOOL bImpersonateOnCreate
);

BOOL
InternalDeletePrinterConnection(
    LPWSTR  pName,
    BOOL    bNotifyDriver
);

BOOL
RefreshPrinterDriver(
    IN  PWSPOOL             pSpool,
    IN  LPWSTR              pszDriverName,
    IN  EDriverDownload     eDriverDownload
    );

BOOL
RefreshPrinterCopyFiles(
    PWSPOOL pSpool
    );

BOOL
OpenCachePrinterOnly(
   LPWSTR               pName,
   LPHANDLE             phSplPrinter,
   LPHANDLE             phIniSpooler,
   LPPRINTER_DEFAULTS   pDefault,
   BOOL                 bOpenOnly
);

BOOL
RemoteEndDocPrinter(
   HANDLE   hPrinter
);


BOOL
RemoteAddPrinterDriver(
    LPWSTR   pName,
    DWORD   Level,
    PBYTE   pDriverInfo
);


BOOL
DownloadDriverFiles(
    PWSPOOL pSpool,
    LPBYTE  pDriverInfo,
    DWORD   dwLevel
);

PWSTR
StripString(
        PWSTR pszString,
        PCWSTR pszStrip,
        PCWSTR pszTerminator
);

BOOL
BuildOtherNamesFromMachineName(
    LPWSTR **ppszOtherNames,
    DWORD   *cOtherNames
);

VOID
FreeOtherNames(
    LPWSTR **ppszMyOtherNames,
    DWORD *cOtherNames
);


BOOL
CopyDriversLocally(
    PWSPOOL  pSpool,
    LPWSTR  pEnvironment,
    LPBYTE  pDriverInfo,
    DWORD   dwLevel,
    DWORD   cbDriverInfo,
    LPDWORD pcbNeeded
    );

VOID
QueryTrustedDriverInformation(
    VOID
    );

BOOL
ValidRawDatatype(
    LPCWSTR pszDatatype
    );

BOOL
DoDevModeConversionAndBuildNewPrinterInfo2(
    IN     LPPRINTER_INFO_2 pInPrinter2,
    IN     DWORD            dwInSize,
    IN OUT LPBYTE           pOutBuf,
    IN     DWORD            dwOutSize,
    IN OUT LPDWORD          pcbNeeded,
    IN     PWSPOOL          pSpool
    );

HANDLE
LoadDriverFiletoConvertDevmodeFromPSpool(
    HANDLE  hSplPrinter
    );

DWORD
GetPolicy();

BOOL
AddDriverFromLocalCab(
    LPTSTR   pszDriverName,
    LPHANDLE pIniSpooler
    );

BOOL
IsTrustedPathConfigured(
    VOID
    );

BOOL
IsAdminAccess(
    IN  PRINTER_DEFAULTS    *pDefaults
    );

HRESULT
DoesPolicyAllowPrinterConnectionsToServer(
    IN      PCWSTR              pszQueue,
        OUT BOOL                *pbAllowPointAndPrint
    );

HRESULT
AreWeOnADomain(
        OUT BOOL                *pbDomain
    );

HRESULT
GetServerNameFromPrinterName(
    IN      PCWSTR              pszQueue,
        OUT PWSTR               *ppszServerName
    );

HRESULT
IsServerExplicitlyTrusted(
    IN      HKEY                hKeyPolicy,
    IN      PCWSTR              pszServerName,
        OUT BOOL                *pbServerTrusted
    );

HRESULT
IsServerInSameForest(
    IN      PCWSTR              pszServerName,
        OUT BOOL                *pbServerInSameForest
    );

HRESULT
GetDNSNameFromServerName(
    IN      PCWSTR              pszServerName,
        OUT PWSTR               *ppszFullyQualified
    );

HRESULT
UnicodeToAnsiString(
    IN      PCWSTR              pszUnicode,
        OUT PSTR                *ppszAnsi
    );

LPWSTR
AnsiToUnicodeStringWithAlloc(
    IN      LPSTR               pAnsi
    );

HRESULT
CheckSamePhysicalAddress(
    IN      PCWSTR              pszServer1,
    IN      PCWSTR              pszServer2,
        OUT BOOL                *pbSameAddress
    );

HRESULT
CheckUserPrintAdmin(
        OUT BOOL                *pbUserAdmin
    );

HRESULT
GetFullyQualifiedDomainName(
    IN      PCWSTR      pszServerName,
        OUT PWSTR       *ppszFullyQualified
    );

VOID
WaitAndAcquireRpcHandle(
    IN      PWSPOOL     pSpool
    );

//
// The defines are used for policy install of printer drivers
// for point and print.  Currently the policy is hardcoded to
// only be SERVER_INF_INSTALL
//
#define SERVER_INSTALL_ONLY 1
#define INF_INSTALL_ONLY    2
#define SERVER_INF_INSTALL  4
#define INF_SERVER_INSTALL  8


//
// Functions for Open Printer Thread Pool
//
HRESULT
BindThreadToHandle(
    IN      PWSPOOL             pSpool
    );

HRESULT 
ReturnThreadFromHandle(
    IN      PWSPOOL             pSpool
    );

HRESULT
BackgroundThreadFinished(
    IN  OUT PWIN32THREAD        *ppThread,
    IN  OUT PWSPOOL             pBackgroundHandle
    );

#ifdef __cplusplus
}
#endif

#endif // _WIN32SPLLOCAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\precomp.h ===
/*++


Copyright (c) 1994 - 1996 Microsoft Corporation

Abstract:

    Header file for the win32spl

Author:

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddrdr.h>
#include <windows.h>
#include <winspool.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <dsgetdc.h>
#include <lm.h>
#include <rpc.h>
#include <dsrole.h>
#include <rpcasync.h>
#include <offsets.h>
#include "winspl.h"
#include <offsets.h>
#include <w32types.h>
#include <winsplp.h>
#include <local.h>
#include <strsafe.h>
#include <splcom.h>
#include <winsprlp.h>
#include <winddiui.h>
#include <wininet.h>
#include <dosprint.h>
#include <messages.h>
#include <stddef.h>
#include <winsplp.h>
#include <splapip.h>

#include <ncshared.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\pool.cxx ===
/*++

Copyright (c) 1990-2002  Microsoft Corporation

Module Name:

    pool.cxx

Abstract:

    Implementation for class ThreadPool.

Author:

    Ali Naqvi (alinaqvi) 3-May-2002

Revision History:

--*/

#include <precomp.h>
#include "pool.hxx"

#pragma hdrstop


#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES
    

/*++

Name:

    TThreadPool::TThreadPool

Description:

    Constructor

Arguments:

    None

Return Value:

    None

--*/
TThreadPool::TThreadPool()
{
    pHead = NULL;
}
    
/*++

Name:

    TThreadPool::~ThreadPool

Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
TThreadPool::~TThreadPool()
{
    PWIN32THREAD pElem = NULL;

    while (pHead != NULL)
    {
        pElem = pHead;
        pHead = pHead->pNext;

        FreeThread(pHead);
    }
}

/*++

Name:

    TThreadPool::CreateThreadEntry

Description:

    Create and Initialize a WIN32THREAD object with provided printer name and printer defaults.

Arguments:

    pName       -   Printer Name
    pDefaults   -   Printer Defaults
    ppThread    -   Out parameter pointer to the created WIN32THREAD

Return Value:

    HRESULT

--*/
HRESULT
TThreadPool::CreateThreadEntry(
    LPWSTR                  pName, 
    PPRINTER_DEFAULTSW      pDefaults, 
    PWIN32THREAD            *ppThread
    )
{
    PWIN32THREAD pThread = NULL;
    HRESULT      hReturn = E_FAIL;
    
    SplInSem();

    hReturn = ppThread && pName ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hReturn))
    {
        //
        // Create the thread wrapper object.
        //
        pThread = reinterpret_cast<PWIN32THREAD>(AllocSplMem(sizeof(WIN32THREAD)));

        hReturn = pThread ? S_OK : E_OUTOFMEMORY;
    }

    if(SUCCEEDED(hReturn))
    {
        pThread->signature = TP_SIGNATURE;
        pThread->pName = AllocSplStr(pName);

        hReturn = pThread->pName ? S_OK : E_OUTOFMEMORY;
    }
        
    if (SUCCEEDED(hReturn))
    {
        hReturn = GetThreadSid(pThread);
    }

    if (SUCCEEDED(hReturn))
    {
        pThread->hRpcHandle = NULL;

        pThread->hWaitValidHandle = CreateEvent(NULL,
                                                EVENT_RESET_MANUAL,
                                                EVENT_INITIAL_STATE_NOT_SIGNALED,
                                                NULL);
        
        pThread->dwStatus = THREAD_STATUS_EXECUTING;
        pThread->dwRpcOpenPrinterError = 0;

        pThread->pDefaults = reinterpret_cast<PPRINTER_DEFAULTSW>(AllocSplMem(sizeof(PRINTER_DEFAULTSW)));

        hReturn = pThread->pDefaults ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hReturn))
    {
        pThread->pDefaults->pDatatype = NULL;
        pThread->pDefaults->pDevMode = NULL;
        pThread->pDefaults->DesiredAccess = 0;
        pThread->bForegroundClose = FALSE;

        hReturn = CopypDefaults(pDefaults, pThread->pDefaults) ? S_OK : E_OUTOFMEMORY;

        pThread->pNext = NULL;
    }
    
    if (SUCCEEDED(hReturn))
    {
        *ppThread = pThread;
    }
    else 
    {
        FreeThread(pThread);

        *ppThread = NULL;
    }

    return hReturn;
}

/*++

Name:

    TThreadPool::GetThreadSid

Description:

    Gets the SID from the thread token and makes a copy.

Arguments:

    pThread    -   Pointer to the WIN32THREAD from which we get our user SID.

Return Value:

    HRESULT

--*/
HRESULT
TThreadPool::GetThreadSid(
    PWIN32THREAD pThread
    )
{
    UCHAR        ThreadTokenInformation[SIZE_OF_TOKEN_INFORMATION];
    DWORD        dwSidLength;
    ULONG        ReturnLength;
    HRESULT      hReturn = E_FAIL;

    hReturn = pThread ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hReturn))
    {
        hReturn = OpenThreadToken(GetCurrentThread(),
                                  TOKEN_READ | TOKEN_IMPERSONATE,
                                  TRUE, 
                                  &(pThread->hToken)) ? S_OK : GetLastErrorAsHResultAndFail();
    }

    if (SUCCEEDED(hReturn))
    {
        hReturn = GetTokenInformation(pThread->hToken,
                                      TokenUser,
                                      ThreadTokenInformation,
                                      sizeof(ThreadTokenInformation),
                                      &ReturnLength) ? S_OK : GetLastErrorAsHResultAndFail();
    }

    if (SUCCEEDED(hReturn))
    {
        dwSidLength = RtlLengthSid((reinterpret_cast<PTOKEN_USER>(ThreadTokenInformation))->User.Sid);
        pThread->pSid = reinterpret_cast<PSID>(AllocSplMem(dwSidLength));

        hReturn = pThread->pSid ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hReturn))
    {
        RtlCopySid( dwSidLength, pThread->pSid, (reinterpret_cast<PTOKEN_USER>(ThreadTokenInformation))->User.Sid);
    }

    return hReturn;
}

/*++

Name:

    TThreadPool::DeleteThreadEntry

Description:

    Delink thread item from the threadpool and delete it.

Arguments:

    pThread    -   Pointer to the WIN322THREAD item to be deleted

Return Value:

    HRESULT

--*/
HRESULT
TThreadPool::DeleteThreadEntry(
    PWIN32THREAD pThread
    )
{
    PWIN32THREAD *ppElem  = &pHead;
    HRESULT      hReturn  = E_FAIL;

    SplInSem();

    hReturn = pThread ? S_OK : E_INVALIDARG;

    SPLASSERT(IsValid(pThread));
 
    if (SUCCEEDED(hReturn))
    {
         //
        // If the thread is in the pool, delink it.
        //
        while (*ppElem && (*ppElem) != pThread)
        {
            ppElem = &((*ppElem)->pNext);
        }

        if (*ppElem)
        {
            (*ppElem) = (*ppElem)->pNext;
        }
        
        FreeThread(pThread);
    }

    return hReturn;
}

/*++

Name:

    TThreadPool::UseThread

Description:

    If exists a thread item for the particular printer name in the pool, it delinks and returns
    a pointer to the thread item.

Arguments:

    pName       -   Printer Name to be looked for
    ppThread    -   Pointer to the thread item if found

Return Value:

    HRESULT
    
    S_OK    -   If thread item found
    S_FALSE -   If thread is not found

--*/
HRESULT
TThreadPool::UseThread(
    LPWSTR       pName, 
    PWIN32THREAD *ppThread,
    ACCESS_MASK  DesiredAccess
    )
{
    PWIN32THREAD *ppElem     = NULL;
    HRESULT      hReturn     = E_FAIL;
    PVOID        pUserTokenInformation = NULL;
    DWORD        dwInformationLength   = SIZE_OF_TOKEN_INFORMATION;
    
    SplInSem();

    hReturn = ppThread ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hReturn))
    {
        //
        // Get User information for current thread
        //
        pUserTokenInformation = reinterpret_cast<UCHAR*>(AllocSplMem(dwInformationLength));
        hReturn = GetUserTokenInformation(&pUserTokenInformation, dwInformationLength);
    }

    if (SUCCEEDED(hReturn))
    {
        *ppThread = NULL;
        
        //
        // If we dont find a thread we return S_FALSE
        //
        hReturn = S_FALSE;
        
        for (ppElem   = &pHead; *ppElem; ppElem = &((*ppElem)->pNext))
        {
            //
            // If we found the thread we return it and break.
            //
            if (wcscmp(pName, (*ppElem)->pName) == 0 && 
                IsValidUser(*ppElem, pUserTokenInformation) && 
                (*ppElem)->pDefaults->DesiredAccess == DesiredAccess &&
                (*ppElem)->dwStatus == THREAD_STATUS_EXECUTING)
            {
                *ppThread = *ppElem; 
                
                *ppElem = (*ppElem)->pNext;   
            
                hReturn = S_OK;

                (*ppThread)->pNext = NULL;

                break;
            }
        }
    }

    FreeSplMem(pUserTokenInformation);
    
    return hReturn;
}


/*++

Name:

    TThreadPool::GetUserTokenInformation

Description:

    Returns the current thread users Sid information in the out parameter.

Arguments:

    pUserTokenInformation   -   Is set to the current user's Sid information

Return Value:

    HRESULT

--*/
HRESULT
TThreadPool::GetUserTokenInformation(
    PVOID   *ppUserTokenInformation,
    DWORD   dwInformationLength
    )
{
    HANDLE  UserTokenHandle;
    ULONG   ReturnLength;
    HRESULT hResult = E_FAIL;

    hResult = ppUserTokenInformation ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hResult))
    {
        hResult = OpenThreadToken( GetCurrentThread(),
                                   TOKEN_READ,
                                   TRUE, 
                                   &UserTokenHandle) ? S_OK : E_HANDLE;
    }

    if (SUCCEEDED(hResult))
    {
        hResult = GetTokenInformation( UserTokenHandle,
                                       TokenUser,
                                       *ppUserTokenInformation,
                                       dwInformationLength,
                                       &ReturnLength) ? S_OK : E_ACCESSDENIED;
    }
    if (UserTokenHandle)
    {
        CloseHandle(UserTokenHandle);
    }

    return hResult;
}


/*++

Name:

    TThreadPool::IsValidUser

Description:

    Checks the Sid of the current user to that of the Sid token save in thread and determines if it is
    the same user. Other users cannot use the same RpcHandle therefore cannot use the same thread from
    the pool.

Arguments:

    pThread     -   The thread whichs Sid we want to check against current user

Return Value:

    BOOL        -   Returns true if it is the same user

--*/
BOOL
TThreadPool::IsValidUser(
    PWIN32THREAD pThread,
    PVOID        pCurrentTokenInformation
    )
{
    BOOL bReturn = FALSE;
    
    bReturn = RtlEqualSid((reinterpret_cast<PTOKEN_USER>(pCurrentTokenInformation))->User.Sid, 
                          pThread->pSid);

    return bReturn;
}


/*++

Name:

    TThreadPool::ReturnThread

Description:

    Return thread item to the pool, signal event that we are done using the thread.

Arguments:

    pThread     -   Thread item to be returned

Return Value:

    HRESULT

--*/
HRESULT
TThreadPool::ReturnThread(
    PWIN32THREAD pThread
    )
{
    HRESULT hReturn = E_FAIL;

    SplInSem();

    hReturn = pThread ? S_OK : E_INVALIDARG;
    
    SPLASSERT(IsValid(pThread));

    if (SUCCEEDED(hReturn))
    {
        //
        // We only return a thread from the foreground if it is actuall still 
        // executing and not terminated.
        //
        SPLASSERT(pThread->dwStatus == THREAD_STATUS_EXECUTING);

        pThread->pNext = pHead;
        pHead = pThread;
    }
    
    return hReturn;
}

/*++

Name:

    TThreadPool::IsValid

Description:

    Checks signature of the thread item to see if it is valid.

Arguments:

    pThread     -   The thread to check for validity

Return Value:

    BOOL        -   Returns true if it is the same user

--*/
BOOL
TThreadPool::IsValid(
    PWIN32THREAD pThread
    )
{
    return (pThread->signature == TP_SIGNATURE);
}

/*++

Name:

    TThreadPool::FreeThread

Description:

    Frees the data in the given thread.

Arguments:

    pThread     -   The thread to free

Return Value:

    Nothing

--*/
VOID
TThreadPool::FreeThread(
    IN      PWIN32THREAD    pThread
    )
{
    
    if (pThread)
    {
        //
        // Now delete the thread.
        //
        pThread->hRpcHandle = NULL;

        if (pThread->pDefaults)
        {
            FreeSplStr(pThread->pDefaults->pDatatype);
            FreeSplMem(pThread->pDefaults->pDevMode);
            FreeSplMem(pThread->pDefaults);
        }

        if (pThread->hWaitValidHandle)
        {
            CloseHandle(pThread->hWaitValidHandle);
        }

        if( pThread->hToken != INVALID_HANDLE_VALUE ) 
        {
            CloseHandle( pThread->hToken );
            pThread->hToken = INVALID_HANDLE_VALUE;
        }

        if (pThread->pName)
        {
            FreeSplStr(pThread->pName);
        }

        if (pThread->pSid)
        {
            FreeSplMem(pThread->pSid);
        }

        FreeSplMem(pThread);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\port.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This module contains the code for port handling

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include "precomp.h"
#include <lm.h>
#include <lmuse.h>
#include <lmapibuf.h>
#include <w32types.h>
#include <local.h>

LPWSTR  pMonitorName = L"LAN Manager Print Share";
PWINIPORT pIniFirstPort = NULL;

PWINIPORT
CreatePortEntry(
    LPWSTR      pPortName,
    PPWINIPORT  ppFirstPort
)
{
    DWORD       cb;
    PWINIPORT    pIniPort, pPort, pFirstPort;

    pFirstPort = *ppFirstPort;

    cb = sizeof(WINIPORT);

   EnterSplSem();

    if (pIniPort = AllocSplMem(cb)) {

        pIniPort->pName = AllocSplStr( pPortName );
        pIniPort->cb = cb;
        pIniPort->pNext = 0;
        pIniPort->signature = WIPO_SIGNATURE;

        if (pPort = pFirstPort) {

            while (pPort->pNext)
                pPort = pPort->pNext;

            pPort->pNext = pIniPort;

        } else

            *ppFirstPort = pIniPort;
    }

   LeaveSplSem();

    return pIniPort;
}


BOOL
DeletePortEntry(
    LPWSTR   pPortName,
    PPWINIPORT ppFirstPort
)
{
    DWORD       cb;
    BOOL        rc;
    PWINIPORT    pPort, pPrevPort, pFirstPort;

    pFirstPort = *ppFirstPort;

    cb = sizeof(WINIPORT) + wcslen(pPortName)*sizeof(WCHAR) + sizeof(WCHAR);

   EnterSplSem();

    pPort = pFirstPort;
    while (pPort && lstrcmpi(pPort->pName, pPortName)) {
        pPrevPort = pPort;
        pPort = pPort->pNext;
    }

    if (pPort) {
        if ( pPort == pFirstPort ) {
            *ppFirstPort = pPort->pNext;
        } else {
            pPrevPort->pNext = pPort->pNext;
        }
        FreeSplStr( pPort->pName );
        FreeSplMem(pPort);

        rc = TRUE;
    }
    else
        rc = FALSE;

   LeaveSplSem();

   return rc;
}


DWORD
CreateRegistryEntry(
    LPWSTR pPortName
)
{
    LONG   Status;
    HKEY   hkeyPath;
    HKEY   hkeyPortNames;
    HANDLE hToken;

    hToken = RevertToPrinterSelf();

    Status = hToken ? NO_ERROR : GetLastError();

    if ( Status == NO_ERROR ) {

        Status = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szRegistryPath, 0,
                                 NULL, 0, KEY_WRITE, NULL, &hkeyPath, NULL );
    }

    if( Status == NO_ERROR ) {

        Status = RegCreateKeyEx( hkeyPath, szRegistryPortNames, 0,
                                 NULL, 0, KEY_WRITE, NULL, &hkeyPortNames, NULL );

        if( Status == NO_ERROR ) {

            Status = RegSetValueEx( hkeyPortNames,
                                    pPortName,
                                    0,
                                    REG_SZ,
                                    (LPBYTE)L"",
                                    0 );

            RegCloseKey( hkeyPortNames );

        } else {

            DBGMSG( DBG_ERROR, ( "RegCreateKeyEx (%ws) failed: Error = %d\n",
                                 szRegistryPortNames, Status ) );
        }

        RegCloseKey( hkeyPath );

    } else {

        DBGMSG( DBG_ERROR, ( "RegCreateKeyEx (%ws) failed: Error = %d\n",
                             szRegistryPath, Status ) );
    }

    if ( hToken ) {
        
        if ( !ImpersonatePrinterClient(hToken) && Status == ERROR_SUCCESS ) {
            Status = GetLastError();
        }
    }

    return Status;
}


DWORD
DeleteRegistryEntry(
    LPWSTR pPortName
)
{
    LONG   Status;
    HKEY   hkeyPath;
    HKEY   hkeyPortNames;
    HANDLE hToken;

    hToken = RevertToPrinterSelf();

    Status = hToken ? NO_ERROR : GetLastError();

    if ( Status == NO_ERROR ) {

        Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szRegistryPath, 0,
                               KEY_WRITE, &hkeyPath );
    }

    if( Status == NO_ERROR ) {

        Status = RegOpenKeyEx( hkeyPath, szRegistryPortNames, 0,
                               KEY_WRITE, &hkeyPortNames );

        if( Status == NO_ERROR ) {

            RegDeleteValue( hkeyPortNames, pPortName );

            RegCloseKey( hkeyPortNames );

        } else {

            DBGMSG( DBG_WARNING, ( "RegOpenKeyEx (%ws) failed: Error = %d\n",
                                   szRegistryPortNames, Status ) );
        }

        RegCloseKey( hkeyPath );

    } else {

        DBGMSG( DBG_WARNING, ( "RegOpenKeyEx (%ws) failed: Error = %d\n",
                               szRegistryPath, Status ) );
    }

    if ( hToken ) {

        if ( !ImpersonatePrinterClient(hToken) && Status == ERROR_SUCCESS ) {
            Status = GetLastError();
        }
    }

    return Status;
}


BOOL
LMDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
)
{
    BOOL rc;

    if (!MyName(pName)) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    rc = DeletePortEntry( pPortName, &pIniFirstPort );

    if(rc) {

        rc = BoolFromStatus(DeleteRegistryEntry(pPortName));
    } else {

        SetLastError(ERROR_UNKNOWN_PORT);
    }

    return rc;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\cache.c ===
/*++

Copyright (c) 1994 - 2000  Microsoft Corporation

Module Name:

    cache.c

Abstract:

    This module contains all the Cache Printer Connection for
    true Connected Printers.

--*/

#include "precomp.h"
#pragma hdrstop

#include "TPmgr.hxx"


PWCHAR pszRaw                = L"RAW";
PWCHAR szWin32SplDirectory   = L"\\spool";
WCHAR  szRegistryWin32Root[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Providers\\LanMan Print Services\\Servers";
WCHAR  szOldLocationOfServersKey[] = L"System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Servers";
WCHAR  szPrinters[]          = L"\\Printers";
PWCHAR pszRegistryMonitors   = L"\\System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Monitors";
PWCHAR pszRegistryEnvironments = L"System\\CurrentControlSet\\Control\\Print\\Providers\\LanMan Print Services\\Environments";
PWCHAR pszRegistryEventLog   = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\Print";
PWCHAR pszRegistryProviders  = L"Providers";
PWCHAR pszEventLogMsgFile    = L"%SystemRoot%\\System32\\Win32Spl.dll";
PWCHAR pszDriversShareName   = L"wn32prt$";
WCHAR szForms[]              = L"\\Forms";
PWCHAR pszMyDllName          = L"win32spl.dll";
PWCHAR pszMonitorName        = L"LanMan Print Services Port";

const WCHAR gszRegistryPrinterPolicies[] = L"Software\\\\Microsoft\\Windows NT\\Current Version\\Print\\Providers\\LanMan Print Services";
const WCHAR gszPointAndPrintPolicies[] = L"Software\\Policies\\Microsoft\\Windows NT\\Printers\\PointAndPrint";
const WCHAR gszPointAndPrintRestricted[] = L"Restricted";
const WCHAR gszPointAndPrintInForest[] = L"InForest";
const WCHAR gszPointAndPrintTrustedServers[] = L"TrustedServers";
const WCHAR gszPointAndPrintServerList[] = L"ServerList";

UINT  cOpenPrinterThreads          = 0;

PWSPOOL pFirstWSpool = NULL;

WCHAR *szCachePrinterInfo2   = L"CachePrinterInfo2";
WCHAR *szCacheTimeLastChange = L"CacheChangeID";
WCHAR *szServerVersion       = L"ServerVersion";
WCHAR *szcRef                = L"CacheReferenceCount";

WCHAR CacheTimeoutString[]   = L"CacheTimeout";

DWORD CacheTimeout           = 0;

//
// If we have an rpc handle created recently don't hit the net
//
#define    REFRESH_TIMEOUT      15000        // 15 seconds
#define    CACHE_TIMEOUT        5000        // Default to 5 seconds.

VOID
RefreshDriverEvent(
    PWSPOOL pSpool
)
/*++

Routine Description:

    Call out to the Printer Driver UI DLL to allow it to do any caching it might want to do.
    For example there might be a large FONT metric file on the print server which is too large
    to be written to the registry using SetPrinterData().   This callout will allow the printer
    driver to copy this font file to the workstation when the cache is established and will
    allow it to periodically check that the file is still valid.

Arguments:

    pSpool - Handle to remote printer.

Return Value:

    None

--*/
{
    DWORD dwPrnEvntError = ERROR_SUCCESS;

    SplOutSem();

    SplDriverEvent( pSpool->pName, PRINTER_EVENT_CACHE_REFRESH, (LPARAM)NULL, &dwPrnEvntError );
}


/*++

 -- GetCacheTimeout --

Routine Description:

    Read the registry to see if anyone has changed the Timeout on the Cache. Default
    to CACHE_TIMEOUT if not.

Arguments:

    None

Return Value:

    Cache Timeout in Milliseconds.

--*/

DWORD GetCacheTimeout(
    VOID
)
{
    DWORD   Value = CACHE_TIMEOUT;
    DWORD   RegValue = 0;
    DWORD   RegValueSize = sizeof(RegValue);
    HKEY    RegKey = NULL;
    DWORD   dwReturn = ERROR_SUCCESS;

    //
    // This will only read the timeout from the registry once, after that, it will use
    // the stored value. This is not ideal and could be fixed to be per-server,
    // depending on the connection speed to the server.
    //

    if ( CacheTimeout )
    {
        Value = CacheTimeout;
    }
    else
    {
        dwReturn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 szRegistryWin32Root,
                                 0,
                                 KEY_READ,
                                 &RegKey );

        if (dwReturn == ERROR_SUCCESS)
        {
            dwReturn = RegQueryValueEx( RegKey,
                                        CacheTimeoutString,
                                        NULL,
                                        NULL,
                                        (LPBYTE) &RegValue,
                                        &RegValueSize );

            if ( dwReturn == ERROR_SUCCESS )
            {
                Value = RegValue;
            }

            dwReturn = RegCloseKey( RegKey );
        }

        CacheTimeout = Value;
    }

    return Value;
}

HANDLE
CacheCreateSpooler(
    LPWSTR  pMachineName,
    BOOL    bOpenOnly
)
{
    PWCHAR pScratch = NULL;
    PWCHAR pRegistryRoot = NULL;
    PWCHAR pRegistryPrinters = NULL;
    SPOOLER_INFO_1 SpoolInfo1;
    HANDLE  hIniSpooler = INVALID_HANDLE_VALUE;
    PWCHAR pMachineOneSlash;
    MONITOR_INFO_2 MonitorInfo;
    DWORD   dwNeeded, cchScratch;
    DWORD   Returned;

 try {

    //
    // get size of szRegistryWin32Root (incl NULL) + (pMachineName + 1)
    //
    cchScratch = COUNTOF(szRegistryWin32Root) + MAX(COUNTOF(szPrinters), COUNTOF(szForms)) + wcslen(pMachineName + 1);

    if (!(pScratch = AllocSplMem(cchScratch * sizeof(WCHAR))))
        leave;

    pMachineOneSlash = pMachineName;
    pMachineOneSlash++;

    //
    //  Create a "Machine" for this Printer
    //

    SpoolInfo1.pDir = gpWin32SplDir;            // %systemroot%\system32\win32spl
    SpoolInfo1.pDefaultSpoolDir = NULL;         // Default %systemroot%\system32\win32spl\PRINTERS

    StrNCatBuff(pScratch,
                cchScratch,
                szRegistryWin32Root,
                pMachineOneSlash,
                NULL);

    if (!(pRegistryRoot = AllocSplStr( pScratch )))
        leave;

    SpoolInfo1.pszRegistryRoot = pRegistryRoot;

    StringCchCat( pScratch, cchScratch, szPrinters );

    if (!(pRegistryPrinters = AllocSplStr( pScratch )))
        leave;

    SpoolInfo1.pszRegistryPrinters     = pRegistryPrinters;
    SpoolInfo1.pszRegistryMonitors     = pszRegistryMonitors;
    SpoolInfo1.pszRegistryEnvironments = pszRegistryEnvironments;
    SpoolInfo1.pszRegistryEventLog     = pszRegistryEventLog;
    SpoolInfo1.pszRegistryProviders    = pszRegistryProviders;
    SpoolInfo1.pszEventLogMsgFile      = pszEventLogMsgFile;
    SpoolInfo1.pszDriversShare         = pszDriversShareName;

    StrNCatBuff(pScratch,
                cchScratch,
                szRegistryWin32Root,
                pMachineOneSlash,
                szForms,
                NULL);

    SpoolInfo1.pszRegistryForms = pScratch;

    // The router graciously does the WIN.INI devices update so let have
    // Spl not also create a printer for us.

    //
    // CLS
    //
    SpoolInfo1.SpoolerFlags          = SPL_BROADCAST_CHANGE |
                                       SPL_TYPE_CACHE |
                                       (bOpenOnly ? SPL_OPEN_EXISTING_ONLY : 0);

    SpoolInfo1.pfnReadRegistryExtra  = (FARPROC) &CacheReadRegistryExtra;
    SpoolInfo1.pfnWriteRegistryExtra = (FARPROC) &CacheWriteRegistryExtra;
    SpoolInfo1.pfnFreePrinterExtra   = (FARPROC) &CacheFreeExtraData;

    SplOutSem();

    hIniSpooler = SplCreateSpooler( pMachineName,
                                    1,
                                    (PBYTE)&SpoolInfo1,
                                    NULL );

    //
    // CLS
    //
    if ( hIniSpooler == INVALID_HANDLE_VALUE ) {

        if (!bOpenOnly)
        {
            SetLastError( ERROR_INVALID_PRINTER_NAME );
        }

    } else {

        // Add WIN32SPL.DLL as the Monitor

        MonitorInfo.pName = pszMonitorName;
        MonitorInfo.pEnvironment = szEnvironment;
        MonitorInfo.pDLLName = pszMyDllName;

        if ( (!SplAddMonitor( NULL, 2, (LPBYTE)&MonitorInfo, hIniSpooler)) &&
             ( GetLastError() != ERROR_PRINT_MONITOR_ALREADY_INSTALLED ) ) {

            DBGMSG( DBG_WARNING, ("CacheCreateSpooler failed SplAddMonitor %d\n", GetLastError()));

            SplCloseSpooler( hIniSpooler );

            hIniSpooler = INVALID_HANDLE_VALUE;

        }
    }

 } finally {

    FreeSplStr ( pScratch );
    FreeSplStr ( pRegistryRoot );
    FreeSplStr ( pRegistryPrinters );

 }

    return hIniSpooler;

}

VOID
RefreshCompletePrinterCache(
    IN      PWSPOOL         pSpool,
    IN      EDriverDownload eDriverDownload
    )
    {

    DBGMSG( DBG_TRACE, ("RefreshCompletePrinterCache %x\n", pSpool));

    if (eDriverDownload == kCheckPnPPolicy)
    {
        BOOL        bAllowPointAndPrint = FALSE;

        if (BoolFromHResult(DoesPolicyAllowPrinterConnectionsToServer(pSpool->pName, &bAllowPointAndPrint)) &&
            bAllowPointAndPrint)
        {
             eDriverDownload = kDownloadDriver;
        }
        else
        {
             eDriverDownload = kDontDownloadDriver;
        }
    }

    //
    // Note the order is important.
    // Refreshing the printer might require that the new driver has
    // been installed on the system. If policy doesn't allow us to
    // fetch the driver, you are just out of luck.
    //
    RefreshPrinterDriver(pSpool, NULL, eDriverDownload);
    RefreshFormsCache( pSpool );
    RefreshPrinterDataCache(pSpool);
    RefreshPrinterCopyFiles(pSpool);
    RefreshDriverEvent( pSpool );
    SplBroadcastChange(pSpool->hSplPrinter, WM_DEVMODECHANGE, 0, (LPARAM) pSpool->pName);
}


PPRINTER_INFO_2
GetRemotePrinterInfo(
    PWSPOOL pSpool,
    LPDWORD pReturnCount
)
{
    PPRINTER_INFO_2 pRemoteInfo = NULL;
    HANDLE  hPrinter = (HANDLE) pSpool;
    DWORD   cbRemoteInfo = 0;
    DWORD   dwBytesNeeded = 0;
    DWORD   dwLastError = 0;
    BOOL    bReturnValue = FALSE;

    *pReturnCount = 0;

    do {

        if ( pRemoteInfo != NULL ) {

            FreeSplMem( pRemoteInfo );
            pRemoteInfo = NULL;
            cbRemoteInfo = 0;
        }

        if ( dwBytesNeeded != 0 ) {

            pRemoteInfo = AllocSplMem( dwBytesNeeded );

            if ( pRemoteInfo == NULL )
                break;
        }

        cbRemoteInfo = dwBytesNeeded;

        bReturnValue = RemoteGetPrinter( hPrinter,
                                         2,
                                         (LPBYTE)pRemoteInfo,
                                         cbRemoteInfo,
                                         &dwBytesNeeded );

        dwLastError = GetLastError();

    } while ( !bReturnValue && dwLastError == ERROR_INSUFFICIENT_BUFFER );

    if ( !bReturnValue && pRemoteInfo != NULL ) {

        FreeSplMem( pRemoteInfo );
        pRemoteInfo = NULL;
        cbRemoteInfo = 0;

    }

    *pReturnCount = cbRemoteInfo;

    return pRemoteInfo;
}



//
//  This routine Clones the Printer_Info_2 structure from the Remote machine
//
//


PWCACHEINIPRINTEREXTRA
AllocExtraData(
    PPRINTER_INFO_2W pPrinterInfo2,
    DWORD cbPrinterInfo2
)
{
    PWCACHEINIPRINTEREXTRA  pExtraData = NULL;
    DWORD    cbSize;

    SPLASSERT( cbPrinterInfo2 != 0);
    SPLASSERT( pPrinterInfo2 != NULL );

    cbSize = sizeof( WCACHEINIPRINTEREXTRA );

    pExtraData = AllocSplMem( cbSize );

    if ( pExtraData != NULL ) {

        pExtraData->signature = WCIP_SIGNATURE;
        pExtraData->cb = cbSize;
        pExtraData->cRef = 0;
        pExtraData->cbPI2 = cbPrinterInfo2;
        pExtraData->dwTickCount  = GetTickCount();
        pExtraData->pPI2 = AllocSplMem( cbPrinterInfo2 );

        if ( pExtraData->pPI2 != NULL ) {

            CacheCopyPrinterInfo( pExtraData->pPI2, pPrinterInfo2, cbPrinterInfo2 );

        } else {

            FreeSplMem( pExtraData );
            pExtraData = NULL;

        }

    }

    return pExtraData;

}


VOID
CacheFreeExtraData(
    PWCACHEINIPRINTEREXTRA pExtraData
)
{
    PWCACHEINIPRINTEREXTRA pPrev = NULL;
    PWCACHEINIPRINTEREXTRA pCur  = NULL;

    if ( pExtraData != NULL ) {

        SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

        if ( pExtraData->cRef != 0 ) {

            DBGMSG( DBG_TRACE, ("CacheFreeExtraData pExtraData %x cRef %d != 0 freeing anyway\n",
                                  pExtraData,
                                  pExtraData->cRef ));
        }

        if ( pExtraData->pPI2 != NULL ) {

            FreeSplMem( pExtraData->pPI2 );
        }

        FreeSplMem( pExtraData );

    }

}

VOID
DownAndMarshallUpStructure(
   LPBYTE       lpStructure,
   LPBYTE       lpSource,
   LPDWORD      lpOffsets
)
{
   register DWORD       i=0;

   while (lpOffsets[i] != -1) {

      if ((*(LPBYTE *)(lpStructure+lpOffsets[i]))) {
         (*(LPBYTE *)(lpStructure+lpOffsets[i]))-=(UINT_PTR)lpSource;
         (*(LPBYTE *)(lpStructure+lpOffsets[i]))+=(UINT_PTR)lpStructure;
      }

      i++;
   }
}


VOID
CacheCopyPrinterInfo(
    PPRINTER_INFO_2W    pDestination,
    PPRINTER_INFO_2W    pPrinterInfo2,
    DWORD   cbPrinterInfo2
)
{
    //
    //  Copy the lot then fix up the pointers
    //
    CopyMemory( pDestination, pPrinterInfo2, cbPrinterInfo2 );
    DownAndMarshallUpStructure( (LPBYTE)pDestination, (LPBYTE)pPrinterInfo2, PrinterInfo2Offsets );
}



VOID
ConvertRemoteInfoToLocalInfo(
    PPRINTER_INFO_2 pPrinterInfo2
)
{

    SPLASSERT( pPrinterInfo2 != NULL );

    DBGMSG(DBG_TRACE,("%ws %ws ShareName %x %ws pSecurityDesc %x Attributes %x StartTime %d UntilTime %d Status %x\n",
                       pPrinterInfo2->pServerName,
                       pPrinterInfo2->pPrinterName,
                       pPrinterInfo2->pShareName,
                       pPrinterInfo2->pPortName,
                       pPrinterInfo2->pSecurityDescriptor,
                       pPrinterInfo2->Attributes,
                       pPrinterInfo2->StartTime,
                       pPrinterInfo2->UntilTime,
                       pPrinterInfo2->Status));

    //
    //  GetPrinter returns the name \\server\printername we only want the printer name
    //

    pPrinterInfo2->pPrinterName = wcschr( pPrinterInfo2->pPrinterName + 2, L'\\' );
    if( !pPrinterInfo2->pPrinterName ){
        SPLASSERT( FALSE );
        pPrinterInfo2->pPrinterName = pPrinterInfo2->pPrinterName;

    } else {
        pPrinterInfo2->pPrinterName++;
    }

    //
    //  LATER this should be a Win32Spl Port
    //

    pPrinterInfo2->pPortName = L"NExx:";
    pPrinterInfo2->pSepFile = NULL;
    pPrinterInfo2->pSecurityDescriptor = NULL;
    pPrinterInfo2->pPrintProcessor = L"winprint";
    pPrinterInfo2->pDatatype = pszRaw;
    pPrinterInfo2->pParameters = NULL;

    pPrinterInfo2->Attributes &= ~( PRINTER_ATTRIBUTE_NETWORK | PRINTER_ATTRIBUTE_DIRECT | PRINTER_ATTRIBUTE_SHARED );

    pPrinterInfo2->StartTime = 0;
    pPrinterInfo2->UntilTime = 0;

    //
    // ConvertRemoteInfoToLocalInfo is called once before an SplAddPrinter
    // and once before an SplSetPrinter, both level 2. Neither SplAddPrinter, nor
    // SplSetPrinter look at the Status field in the printer info. So the
    // value below is artificial. We just give it an initial state.
    //
    pPrinterInfo2->Status = 0;
    pPrinterInfo2->cJobs = 0;
    pPrinterInfo2->AveragePPM = 0;

}



VOID
RefreshPrinter(
    PWSPOOL pSpool
)
{

    PPRINTER_INFO_2 pRemoteInfo = NULL;
    DWORD   cbRemoteInfo = 0;
    BOOL    ReturnValue                     = FALSE;
    PWCACHEINIPRINTEREXTRA pExtraData       = NULL;
    PWCACHEINIPRINTEREXTRA pNewExtraData    = NULL;
    PPRINTER_INFO_2 pTempPI2                = NULL;
    PPRINTER_INFO_2 pCopyExtraPI2ToFree     = NULL;
    DWORD   dwLastError;

    //
    //  Get the Remote Printer Info
    //
    pRemoteInfo = GetRemotePrinterInfo( pSpool, &cbRemoteInfo );

    if ( pRemoteInfo != NULL ) {

        //
        // Assume everything is OK for now. This is to keep the code behavior as it was.
        // 
        ReturnValue = TRUE;
        
        //  LATER
        //          Optimization could be to only update the cache if something
        //          actually changed.
        //          IE Compare every field.
        //
        EnterSplSem();
        
        if (!SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData)) {

            DBGMSG( DBG_ERROR, ("RefreshPrinter SplGetPrinterExtra pSpool %x error %d\n", pSpool, GetLastError() ));            
        }

        if ( pExtraData == NULL ) {

            pExtraData = AllocExtraData( pRemoteInfo, cbRemoteInfo );

            if ( pExtraData != NULL ) {

                pExtraData->cRef++;
            }

        } else {

            //
            // Only continue if the remote name and the local name are the same.
            // 
            ReturnValue = pExtraData->pPI2->pPrinterName && pRemoteInfo->pPrinterName && !_wcsicmp(pRemoteInfo->pPrinterName, pExtraData->pPI2->pPrinterName);            

            if (ReturnValue) {

                SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

                pTempPI2 = AllocSplMem( cbRemoteInfo );

                if ( pTempPI2 != NULL ) {

                    SplInSem();

                    CacheCopyPrinterInfo( pTempPI2, pRemoteInfo, cbRemoteInfo );

                    pCopyExtraPI2ToFree = pExtraData->pPI2;

                    pExtraData->pPI2  = pTempPI2;
                    pExtraData->cbPI2 = cbRemoteInfo;
                }
            }
            else {
                DBGMSG(DBG_TRACE, ("Printer Names are different (%s, %s)\n", pExtraData->pPI2->pPrinterName, pRemoteInfo->pPrinterName));
            }
        }

       LeaveSplSem();

        if ( pExtraData != NULL ) {
            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );
        }

        if (ReturnValue) {

            ConvertRemoteInfoToLocalInfo( pRemoteInfo );

            ReturnValue = SplSetPrinter( pSpool->hSplPrinter, 2, (LPBYTE)pRemoteInfo, 0 );

            if ( !ReturnValue ) {

                //
                // If the driver is blocked and the driver has changed, we want to log
                // an event.
                //
                dwLastError = GetLastError();

                if (ERROR_KM_DRIVER_BLOCKED == dwLastError &&
                    pCopyExtraPI2ToFree                       &&
                    pCopyExtraPI2ToFree->pDriverName          &&
                    pRemoteInfo->pDriverName                  &&
                    _wcsicmp(pCopyExtraPI2ToFree->pDriverName, pRemoteInfo->pDriverName)) {

                    //
                    // We have entered a mismatched case through someone admin'ing a
                    // remote server. Log an error message, we cannot throw UI at this
                    // point.
                    //
                    SplLogEventExternal(LOG_ERROR,
                                        MSG_DRIVER_MISMATCHED_WITH_SERVER,
                                        pSpool->pName,
                                        pRemoteInfo->pDriverName,
                                        NULL);
                }
                else if(dwLastError == ERROR_UNKNOWN_PRINTER_DRIVER)
                {
                    if (ReturnValue = AddDriverFromLocalCab( pRemoteInfo->pDriverName, pSpool->hIniSpooler))
                    {
                        ReturnValue = SplSetPrinter( pSpool->hSplPrinter, 2, (LPBYTE)pRemoteInfo, 0 );
                    }
                }

                DBGMSG( DBG_WARNING, ("RefreshPrinter Failed SplSetPrinter %d\n", GetLastError() ));
            }

            ReturnValue = SplSetPrinterExtra( pSpool->hSplPrinter, (LPBYTE)pExtraData );

            if (!ReturnValue) {

                DBGMSG(DBG_ERROR, ("RefreshPrinter SplSetPrinterExtra failed %x\n", GetLastError()));
            }
        }

    } else {

        DBGMSG( DBG_WARNING, ("RefreshPrinter failed GetRemotePrinterInfo %x\n", GetLastError() ));
    }

    if ( pRemoteInfo != NULL )
        FreeSplMem( pRemoteInfo );

    if (pCopyExtraPI2ToFree != NULL) {

        FreeSplMem(pCopyExtraPI2ToFree);
    }
}

VOID
RefreshPrinterInfo7(
    PWSPOOL pSpool
)
{
    PPRINTER_INFO_7 pInfo = NULL;
    DWORD   cbNeeded = 0;
    BOOL    bRet;


    bRet = RemoteGetPrinter((HANDLE) pSpool, 7, (PBYTE) pInfo, 0, &cbNeeded);

    if (bRet) {
        DBGMSG( DBG_ERROR, ("RefreshPrinterInfo7 Illegally succeeded RemoteGetPrinter %d\n"));
        goto done;
    } else if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        DBGMSG( DBG_WARNING, ("RefreshPrinterInfo7 Failed RemoteGetPrinter %d\n", GetLastError()));
        goto done;
    }

    if (!(pInfo = (PPRINTER_INFO_7) AllocSplMem(cbNeeded))) {
        DBGMSG( DBG_WARNING, ("RefreshPrinterInfo7 Failed RemoteGetPrinter %d\n", GetLastError()));
        goto done;
    }

    if (!RemoteGetPrinter((HANDLE) pSpool, 7, (PBYTE) pInfo, cbNeeded, &cbNeeded)) {
        DBGMSG( DBG_WARNING, ("RefreshPrinterInfo7 Failed RemoteGetPrinter %d\n", GetLastError()));
        goto done;
    }

    if (!SplSetPrinter( pSpool->hSplPrinter, 7, (PBYTE) pInfo, 0)) {
        DBGMSG( DBG_WARNING, ("RefreshPrinterInfo7 Failed RemoteSetPrinter %d\n", GetLastError()));
        goto done;
    }

done:

    FreeSplMem(pInfo);
}

PWSPOOL
InternalAddPrinterConnection(
    LPWSTR   pName
)

/*++

Function Description: InternalAddPrinterConnection creates a printer connection.

Parameters: pName - name of the printer connection

Return Values: pSpool if successful;
               NULL otherwise

--*/

{
    PWSPOOL pSpool = NULL;
    BOOL    bReturnValue = FALSE;
    HANDLE  hIniSpooler = INVALID_HANDLE_VALUE;
    PPRINTER_INFO_2 pPrinterInfo2 = NULL;
    DWORD   cbPrinterInfo2 = 0;
    HANDLE  hSplPrinter = INVALID_HANDLE_VALUE;
    PWCACHEINIPRINTEREXTRA pExtraData  = NULL;
    PWCACHEINIPRINTEREXTRA pExtraData2 = NULL;
    BOOL    bSuccess = FALSE;
    LPPRINTER_INFO_STRESSW pPrinter0 = NULL;
    DWORD   dwNeeded;
    DWORD   LastError = ERROR_SUCCESS;
    BOOL    bLoopDetected = FALSE;
    BOOL    bAllowPointAndPrint = FALSE;
    BOOL    bAllowDriverDownload  = FALSE;

 try {

    if (!VALIDATE_NAME(pName)) {
        SetLastError(ERROR_INVALID_NAME);
        leave;
    }

    if (!RemoteOpenPrinter(pName, &pSpool, NULL, DO_NOT_CALL_LM_OPEN)) {
        leave;
    }

    pPrinter0 = AllocSplMem( MAX_PRINTER_INFO0 );
    if ( pPrinter0 == NULL )
        leave;

    SPLASSERT( pSpool != NULL );
    SPLASSERT( pSpool->Type == SJ_WIN32HANDLE );

    DBGMSG( DBG_TRACE, ("AddPrinterConnection pName %ws pSpool %x\n",pName, pSpool ));

    //
    //  Get Remote ChangeID to be certain nothing changes on the Server
    //  whilst we are establishing our Cache.
    //

    bReturnValue = RemoteGetPrinter( pSpool, STRESSINFOLEVEL, (LPBYTE)pPrinter0, MAX_PRINTER_INFO0, &dwNeeded );

    if ( !bReturnValue ) {

        SPLASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
        DBGMSG(DBG_TRACE, ("AddPrinterConnection failed RemoteGetPrinter %d\n", GetLastError()));
        pPrinter0->cChangeID = 0;
    }

    DBGMSG( DBG_TRACE, ("AddPrinterConnection << Server cCacheID %x >>\n", pPrinter0->cChangeID ));

    //
    //  See If the Printer is already in the Cache
    //

APC_OpenCache:

    bReturnValue = OpenCachePrinterOnly( pName, &hSplPrinter, &hIniSpooler, NULL, FALSE);


    if ( hIniSpooler == INVALID_HANDLE_VALUE ) {

        DBGMSG( DBG_WARNING, ("AddPrinterConnection - CacheCreateSpooler Failed %x\n",GetLastError()));
        leave;
    }

    pSpool->hIniSpooler = hIniSpooler;

    if ( bReturnValue ) {

        //
        //  Printer Exists in Cache
        //

        SPLASSERT( ( hSplPrinter != INVALID_HANDLE_VALUE) &&
                   ( hSplPrinter != NULL ) );

        DBGMSG( DBG_TRACE,("AddPrinterConnection hIniSpooler %x hSplPrinter%x\n", hIniSpooler, hSplPrinter) );


        pSpool->hSplPrinter = hSplPrinter;
        pSpool->Status |= WSPOOL_STATUS_USE_CACHE;

        //
        //  Update Connection Reference Count
        //

       EnterSplSem();


        bReturnValue = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );

        if ( bReturnValue == FALSE ) {

            DBGMSG( DBG_WARNING, ("AddPrinterConnection SplGetPrinterExtra pSpool %x error %d\n", pSpool, GetLastError() ));
            SPLASSERT( bReturnValue );

        }

        if ( pExtraData != NULL ) {

            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );
            pExtraData->cRef++;

        }

       LeaveSplSem();

        // Make Sure Reference Count Gets Updated in Registry

        if ( !SplSetPrinterExtra( hSplPrinter, (LPBYTE)pExtraData ) ) {
            DBGMSG( DBG_ERROR, ("AddPrinterConnection SplSetPrinterExtra failed %x\n", GetLastError() ));
        }

        //  Refresh Cache
        //  It could be that the remote machine is old NT Daytona 3.5 or before
        //  which doesn't support the ChangeID, that would mean the only
        //  way for a user to force an update is to do a connection.

        if ( pPrinter0->cChangeID == 0 ) {

            // Old NT

            RefreshCompletePrinterCache(pSpool, kCheckPnPPolicy);

        } else {

            //
            // Since we have this in the cache anyway, we might as well sync
            // settings, we only sync settings if we are allowed to download
            // the driver.
            //
            ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
        }

        pExtraData = NULL;

        bSuccess = TRUE;
        leave;

    } else if ( GetLastError() != ERROR_INVALID_PRINTER_NAME &&
                GetLastError() != ERROR_INVALID_NAME ) {

        DBGMSG( DBG_WARNING, ("AddPrinterConnection failed OpenCachePrinterOnly %d\n", GetLastError() ));
        leave;

    }

    //
    //  There is NO Cache Entry for This Printer
    //
    DBGMSG( DBG_TRACE, ("AddPrinterConnection failed SplOpenPrinter %ws %d\n", pName, GetLastError() ));

    //
    //  Get PRINTER Info from Remote Machine
    //

    pPrinterInfo2 = GetRemotePrinterInfo( pSpool, &cbPrinterInfo2 );

    if ( pPrinterInfo2 == NULL ) {
        DBGMSG( DBG_WARNING, ("AddPrinterConnection failed GetRemotePrinterInfo %x\n", GetLastError() ));
        leave;
    }

    if (BoolFromHResult(DoesPolicyAllowPrinterConnectionsToServer(pSpool->pName, &bAllowPointAndPrint)) &&
        bAllowPointAndPrint)
    {
        bAllowDriverDownload = TRUE;
    }

    if (!RefreshPrinterDriver( pSpool, pPrinterInfo2->pDriverName, bAllowDriverDownload ? kDownloadDriver : kDontDownloadDriver) && (ERROR_PRINTER_DRIVER_BLOCKED == GetLastError()))
    {
        leave;
    }

    //
    //  Allocate My Extra Data for this Printer
    //  ( from RemoteGetPrinter )
    //  We need a pExtraData2 - if this is blocked by KM blocking we need to have a copy to
    //  retry the install.
    //

    pExtraData = AllocExtraData( pPrinterInfo2, cbPrinterInfo2 );

    if ( pExtraData == NULL )
        leave;

    pExtraData2 = AllocExtraData( pPrinterInfo2, cbPrinterInfo2 );

    if ( pExtraData2 == NULL )
        leave;

    pExtraData->cRef++;
    pExtraData2->cRef++;

    pExtraData2->cCacheID = pExtraData->cCacheID = pPrinter0->cChangeID;
    pExtraData2->dwServerVersion = pExtraData->dwServerVersion = pPrinter0->dwGetVersion;

    //
    //  Convert Remote Printer_Info_2 to Local Version for Cache
    //

    ConvertRemoteInfoToLocalInfo( pPrinterInfo2 );

    //
    //  Add Printer to Cache
    //

    hSplPrinter = SplAddPrinter(NULL, 2, (LPBYTE)pPrinterInfo2,
                                hIniSpooler, (LPBYTE)pExtraData,
                                NULL, 0);

    pExtraData = NULL;

    if ( (hSplPrinter == NULL || hSplPrinter == INVALID_HANDLE_VALUE) &&
         GetLastError() == ERROR_KM_DRIVER_BLOCKED                        ) {

        //
        // Failed due to KM Blocking
        //     - lets try add a driver from the local cab as this should fix this.
        //
        if( !AddDriverFromLocalCab( pPrinterInfo2->pDriverName, hIniSpooler ) ) {
            //
            // Set the old last error back as we don't really care that this failed.
            //
            SetLastError( ERROR_KM_DRIVER_BLOCKED );
        } else {

           hSplPrinter = SplAddPrinter(NULL, 2, (LPBYTE)pPrinterInfo2,
                                       hIniSpooler, (LPBYTE)pExtraData2,
                                       NULL, 0);
           pExtraData2 = NULL;
        }
    }

    if ( hSplPrinter == NULL ||
         hSplPrinter == INVALID_HANDLE_VALUE ) {

        LastError = GetLastError();

        if ( LastError == ERROR_PRINTER_ALREADY_EXISTS ) {

            SplCloseSpooler( pSpool->hIniSpooler );
            hIniSpooler = INVALID_HANDLE_VALUE;

            if ( bLoopDetected == FALSE ) {

                bLoopDetected = TRUE;
                goto    APC_OpenCache;

            } else {

                DBGMSG( DBG_WARNING, ("AddPrinterConnection APC_OpenCache Loop Detected << Should Never Happen >>\n"));
                leave;
            }
        }
        //
        // If we could not add the printer, and it wasn't because it is already
        // there, and we weren't able to download the driver because of policy,
        // then we need to return an appropriate error code so that the UI can
        // inform the user about it.
        //
        else if (!bAllowDriverDownload && LastError == ERROR_UNKNOWN_PRINTER_DRIVER)
        {
            LastError = ERROR_ACCESS_DISABLED_BY_POLICY;
        }

        // If we failed to Create the printer above, we should NOT be able to Open it now.

        DBGMSG( DBG_WARNING, ("AddPrinterConnection Failed SplAddPrinter error %d\n", LastError ));

        hSplPrinter = INVALID_HANDLE_VALUE;
        bSuccess    = FALSE;
        leave;

    }

    DBGMSG( DBG_TRACE, ("AddPrinterConnection SplAddPrinter SUCCESS hSplPrinter %x\n", hSplPrinter));

    pSpool->hSplPrinter = hSplPrinter;
    pSpool->Status |= WSPOOL_STATUS_USE_CACHE;

    RefreshFormsCache(pSpool);
    RefreshPrinterDataCache(pSpool);
    RefreshPrinterCopyFiles(pSpool);
    RefreshDriverEvent(pSpool);

    //
    // Just In Case something change whilst we were initializing the cache
    // go check it again now. Don't check policy again since we have recently
    // verified that we can comunicate with this server.
    //
    ConsistencyCheckCache(pSpool, bAllowDriverDownload ? kDownloadDriver : kDontDownloadDriver);

    bSuccess = TRUE;

 } finally {

    if ( !bSuccess ) {
        if ( LastError == ERROR_SUCCESS )
            LastError = GetLastError();

        InternalDeletePrinterConnection( pName, FALSE );

        if ( pSpool != NULL && pSpool != INVALID_HANDLE_VALUE ) {
            pSpool->Status &= ~WSPOOL_STATUS_TEMP_CONNECTION;
            CacheClosePrinter( pSpool );
        }

        SetLastError( LastError );
        DBGMSG( DBG_TRACE, ("AddPrinterConnection %ws Failed %d\n", pName, GetLastError() ));

        pSpool = NULL;
    }

    if ( pPrinterInfo2 != NULL )
        FreeSplMem( pPrinterInfo2 );

    if ( pPrinter0 != NULL )
        FreeSplMem( pPrinter0 );

    if ( pExtraData != NULL )
        CacheFreeExtraData( pExtraData );

    if ( pExtraData2 != NULL )
        CacheFreeExtraData( pExtraData2 );

 }

    return pSpool;
}

/*++

Function Name:

    AddPrinterConnectionPrivate

Function Description:

    AddPrinterConnectionPrivate creates a printer connection. It does
    not check to see if the printer connection already exists in the
    users registry.

Parameters:

    pName - name of the printer connection

Return Values:

    TRUE if successful;
    FALSE otherwise

--*/
BOOL
AddPrinterConnectionPrivate(
    LPWSTR pName
)
{
    PWSPOOL  pSpool;
    BOOL    bReturn;

    pSpool = InternalAddPrinterConnection(pName);

    if (pSpool != NULL)
    {
        //
        // We have a valid handle. The connection has been created. Succeed after
        // closing the handle
        //
        CacheClosePrinter(pSpool);
        bReturn = TRUE;
    }
    else
    {
        //
        // Failed to create the connection.
        //
        bReturn = FALSE;
    }

    return bReturn;
}

/*++

Function Name:

    AddPrinterConnection

Function Description:

    AddPrinterConnection creates a printer connection. We check to see
    whether the printer connection already exists in the user registry.
    This works because an OpenPrinter will always occur from the router
    before an AddPrinter Connection. So, this will always create a
    printer connection from the registry in CacheOpenPrinter(). If we see
    this state, we simpy return TRUE.

Parameters:

    pName - name of the printer connection

Return Values:

    TRUE if successful;
    FALSE otherwise

--*/
BOOL
AddPrinterConnection(
    LPWSTR pName
)
{
    HRESULT hr = E_FAIL;

    if (PrinterConnectionExists(pName))
    {
        hr = S_OK;
    }
    else
    {
        //
        // Make sure this request is coming from the local machine. Otherwise,
        // we could be tricked into connecting back to a remote server and
        // downloading their driver.
        //
        hr = CheckLocalCall();

        hr = hr == S_FALSE ? HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) : hr;

        if (SUCCEEDED(hr))
        {
            hr = AddPrinterConnectionPrivate(pName) ? S_OK : GetLastErrorAsHResultAndFail();
        }
    }

    return BoolFromHResult(hr);
}

VOID
RefreshFormsCache(
    PWSPOOL pSpool
)
/*++

Routine Description:

    This routine will check to see if any forms have changed.   If anything changed it adds
    or deletes forms from the cache so that it matches the server.

    Note it is very important that the order of the forms on the workstation matches those
    on the Server.

    Implementation:

        EnumRemoteForms
        EnumLocalForms
        If there is any difference
            Delete All LocalForms
            Add All the Remote Forms

    The code is optimized for the typical case

        Forms are added at the end only.
        Forms are hardly ever deleted.

Arguments:

    pSpool - Handle to remote printer.

Return Value:

    None

--*/

{
    PFORM_INFO_1 pRemoteForms = NULL , pSaveRemoteForms = NULL;
    PFORM_INFO_1 pLocalCacheForms = NULL,  pSaveLocalCacheForms = NULL;
    PFORM_INFO_1 pRemote = NULL, pLocal = NULL;
    DWORD   dwBuf = 0;
    DWORD   dwSplBuf = 0;
    DWORD   dwNeeded = 0;
    DWORD   dwSplNeeded = 0;
    DWORD   dwRemoteFormsReturned = 0;
    DWORD   dwSplReturned = 0;
    BOOL    bReturnValue = FALSE;
    DWORD   LastError = ERROR_INSUFFICIENT_BUFFER;
    INT     iCompRes = 0;
    DWORD   LoopCount;
    BOOL    bCacheMatchesRemoteMachine = FALSE;


    SPLASSERT( pSpool != NULL );
    SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
    SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );

    //
    //  Get Remote Machine Forms Data
    //

    do {

        bReturnValue = RemoteEnumForms( (HANDLE)pSpool, 1, (LPBYTE)pRemoteForms, dwBuf, &dwNeeded, &dwRemoteFormsReturned);

        if ( bReturnValue )
            break;

        LastError = GetLastError();

        if ( LastError != ERROR_INSUFFICIENT_BUFFER ) {

            DBGMSG( DBG_WARNING, ("RefreshFormsCache Failed RemoteEnumForms error %d\n", GetLastError()));
            goto RefreshFormsCacheErrorReturn;

        }

        if ( pRemoteForms != NULL )
            FreeSplMem( pRemoteForms );


        pRemoteForms = AllocSplMem( dwNeeded );
        pSaveRemoteForms = pRemoteForms;

        dwBuf = dwNeeded;

        if ( pRemoteForms == NULL ) {

            DBGMSG( DBG_WARNING, ("RefreshFormsCache Failed AllocSplMem Error %d dwNeeded %d\n", GetLastError(), dwNeeded));
            goto RefreshFormsCacheErrorReturn;

        }

    } while ( !bReturnValue && LastError == ERROR_INSUFFICIENT_BUFFER );

    if( pRemoteForms == NULL ) {

        DBGMSG( DBG_WARNING, ("RefreshFormsCache Failed pRemoteForms == NULL\n"));
        goto RefreshFormsCacheErrorReturn;
    }




    //
    //  Get LocalCachedForms Data
    //

    do {

        bReturnValue = SplEnumForms( pSpool->hSplPrinter, 1, (LPBYTE)pLocalCacheForms, dwSplBuf, &dwSplNeeded, &dwSplReturned);

        if ( bReturnValue )
            break;

        LastError = GetLastError();

        if ( LastError != ERROR_INSUFFICIENT_BUFFER ) {

            DBGMSG( DBG_WARNING, ("RefreshFormsCache Failed SplEnumForms hSplPrinter %x error %d\n", pSpool->hSplPrinter, GetLastError()));
            goto RefreshFormsCacheErrorReturn;

        }

        if ( pLocalCacheForms != NULL )
            FreeSplMem( pLocalCacheForms );


        pLocalCacheForms = AllocSplMem( dwSplNeeded );
        pSaveLocalCacheForms = pLocalCacheForms;
        dwSplBuf = dwSplNeeded;

        if ( pLocalCacheForms == NULL ) {

            DBGMSG( DBG_WARNING, ("RefreshFormsCache Failed AllocSplMem ( %d )\n",dwSplNeeded));
            goto RefreshFormsCacheErrorReturn;

        }

    } while ( !bReturnValue && LastError == ERROR_INSUFFICIENT_BUFFER );


    //
    //  Optimization Check Local vs Remote
    //  If nothing has changed no need to do anything
    //


    SPLASSERT( pRemoteForms != NULL );    

    for ( LoopCount = 0, pRemote = pRemoteForms, pLocal = pLocalCacheForms, bCacheMatchesRemoteMachine = TRUE;
          LoopCount < dwSplReturned && LoopCount < dwRemoteFormsReturned && bCacheMatchesRemoteMachine;
          LoopCount++, pRemote++, pLocal++ ) {


        //
        // If the form name is different, or the dimensions are different,
        // then refresh the forms cache.
        //
        // Note: if the forms are both built-in, then bypass the string
        // match since built in forms are standardized.  We actually
        // should be able to bypass all checks.
        //
        if (( wcscmp( pRemote->pName, pLocal->pName ) != STRINGS_ARE_EQUAL ) ||
            ( pRemote->Size.cx              != pLocal->Size.cx )             ||
            ( pRemote->Size.cy              != pLocal->Size.cy )             ||
            ( pRemote->ImageableArea.left   != pLocal->ImageableArea.left )  ||
            ( pRemote->ImageableArea.top    != pLocal->ImageableArea.top )   ||
            ( pRemote->ImageableArea.right  != pLocal->ImageableArea.right ) ||
            ( pRemote->ImageableArea.bottom != pLocal->ImageableArea.bottom ) ) {


            DBGMSG( DBG_TRACE, ("RefreshFormsCache Remote cx %d cy %d left %d right %d top %d bottom %d %ws\n",
                                 pRemote->Size.cx, pRemote->Size.cy,
                                 pRemote->ImageableArea.left,
                                 pRemote->ImageableArea.right,
                                 pRemote->ImageableArea.top,
                                 pRemote->ImageableArea.bottom,
                                 pRemote->pName));



            DBGMSG( DBG_TRACE, ("RefreshFormsCache Local  cx %d cy %d left %d right %d top %d bottom %d %ws - Does Not Match\n",
                                 pLocal->Size.cx, pLocal->Size.cy,
                                 pLocal->ImageableArea.left,
                                 pLocal->ImageableArea.right,
                                 pLocal->ImageableArea.top,
                                 pLocal->ImageableArea.bottom,
                                 pLocal->pName));

            bCacheMatchesRemoteMachine = FALSE;
        }
    }

    //
    //  If Everything matches we're done.
    //

    if ( bCacheMatchesRemoteMachine ) {


        if ( dwRemoteFormsReturned == dwSplReturned ) {

            DBGMSG( DBG_TRACE, ("RefreshFormsCache << Cache Forms Match Remote Forms - Nothing to do >>\n"));
            goto RefreshFormsCacheReturn;

        } else if (dwRemoteFormsReturned > dwSplReturned){

            //
            //  All the forms we have in the cache match
            //  Now add the Extra Remote Forms.

            dwRemoteFormsReturned -= dwSplReturned;
            pRemoteForms = pRemote;

            //  dwSplReturned == 0 will skip the delete loop

            dwSplReturned = 0;
        }
    }

    DBGMSG( DBG_TRACE, ("RefreshFormsCache - Something Doesn't Match, Delete all the Cache and Refresh it\n"));

    //
    //  Delete all the forms in the Cache
    //

    for ( LoopCount = dwSplReturned, pLocal = pLocalCacheForms;
          LoopCount != 0;
          pLocal++, LoopCount-- ) {

        bReturnValue = SplDeleteForm( pSpool->hSplPrinter, pLocal->pName );

        DBGMSG( DBG_TRACE, ("RefreshFormsCache %x SplDeleteForm( %x, %ws)\n",bReturnValue, pSpool->hSplPrinter, pLocal->pName));
    }


    //
    //  Add all the Remote Forms to the Cache
    //

    for ( LoopCount = dwRemoteFormsReturned, pRemote = pRemoteForms;
          LoopCount != 0;
          LoopCount--, pRemote++ ) {


        SPLASSERT( pRemote != NULL );

        bReturnValue = SplAddForm( pSpool->hSplPrinter, 1, (LPBYTE)pRemote );

        DBGMSG( DBG_TRACE, ("RefreshFormsCache %x SplAddForm( %x, 1, %ws)\n",bReturnValue, pSpool->hSplPrinter, pRemote->pName));

    }

RefreshFormsCacheReturn:
RefreshFormsCacheErrorReturn:

    if ( pSaveRemoteForms != NULL )
        FreeSplMem( pSaveRemoteForms );

    if ( pSaveLocalCacheForms != NULL )
        FreeSplMem( pSaveLocalCacheForms );

}

VOID
RefreshDriverDataCache(
    PWSPOOL pSpool
)
{
    DWORD   iCount = 0;
    DWORD   dwType = 0;
    DWORD   ReturnValue = 0;

    LPBYTE  lpbData = NULL;
    DWORD   dwSizeData;
    DWORD   dwMaxSizeData;

    LPWSTR  pValueString = NULL;
    DWORD   dwSizeValueString;
    DWORD   dwMaxSizeValueString = 0;


    SPLASSERT( pSpool != NULL );
    SPLASSERT( pSpool->signature == WSJ_SIGNATURE );
    SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
    SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );
    SPLASSERT( pSpool->pName != NULL );


    // Get the required sizes
    ReturnValue = RemoteEnumPrinterData(pSpool,
                                        iCount,
                                        pValueString,
                                        0,
                                        &dwMaxSizeValueString,
                                        &dwType,
                                        lpbData,
                                        0,
                                        &dwMaxSizeData);

    if (ReturnValue != ERROR_SUCCESS) {

        DBGMSG( DBG_TRACE, ("RefreshDriverDataCache Failed first RemoteEnumPrinterData %d\n", GetLastError()));
        goto RefreshDriverDataCacheError;
    }

    // Allocate
    if ((pValueString = AllocSplMem(dwMaxSizeValueString)) == NULL) {

        DBGMSG( DBG_WARNING, ("RefreshDriverDataCache Failed to allocate enough memory\n"));
        goto RefreshDriverDataCacheError;
    }

    if ((lpbData = AllocSplMem(dwMaxSizeData)) == NULL) {

        DBGMSG( DBG_WARNING, ("RefreshDriverDataCache Failed to allocate enough memory\n"));
        goto RefreshDriverDataCacheError;
    }


    // Enumerate
    for (iCount = 0 ;
         RemoteEnumPrinterData( pSpool,
                                iCount,
                                pValueString,
                                dwMaxSizeValueString,
                                &dwSizeValueString,
                                &dwType,
                                lpbData,
                                dwMaxSizeData,
                                &dwSizeData) == ERROR_SUCCESS ;
         ++iCount) {

        //
        //  Optimization - Do NOT write the data if it is the same
        //

        if ((ReturnValue = SplSetPrinterData(pSpool->hSplPrinter,
                                            (LPWSTR)pValueString,
                                            dwType,
                                            lpbData,
                                            dwSizeData )) != ERROR_SUCCESS) {

            DBGMSG( DBG_WARNING, ("RefreshDriverDataCache Failed SplSetPrinterData %d\n",ReturnValue ));
            goto    RefreshDriverDataCacheError;

        }
    }


RefreshDriverDataCacheError:

    FreeSplMem( lpbData );
    FreeSplStr( pValueString );
}


VOID
RefreshPrinterDataCache(
    PWSPOOL pSpool
)
{
    DWORD   ReturnValue = 0;
    DWORD   cbSubKeys;
    DWORD   dwResult;

    SPLASSERT( pSpool != NULL );
    SPLASSERT( pSpool->signature == WSJ_SIGNATURE );
    SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
    SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );
    SPLASSERT( pSpool->pName != NULL );


    // This call to RemoteEnumPrinterKey is here so we can find out
    // if the server exists and supports EnumPrinterKey
    dwResult = RemoteEnumPrinterKey(pSpool,
                                    L"",
                                    NULL,
                                    0,
                                    &cbSubKeys);

    DBGMSG(DBG_TRACE, ("RefreshPrinterDataCache: EnumPrinterKey Return: %0x\n", dwResult));

    if (dwResult == ERROR_MORE_DATA) {    // Server exists and supports EnumPrinterKey

        // Clean out old data
        SplDeletePrinterKey(pSpool->hSplPrinter, L"");

        // Enumerate and copy keys
        ReturnValue = EnumerateAndCopyKey(pSpool, L"");

    }
    else if (dwResult == RPC_S_PROCNUM_OUT_OF_RANGE) { // Server exists but doesn't support EnumPrinterKey

        // we still call refreshdriverdatacache so downlevel gets cached
        // Optimize: Only call for downlevel since EnumerateAndCopyKey copies Driver Data
        RefreshDriverDataCache(pSpool);

    }
    else if (dwResult == ERROR_INVALID_HANDLE || dwResult == RPC_S_CALL_FAILED) { // Server does not exist
        DBGMSG(DBG_TRACE, ("RefreshPrinterDataCache: Server \"%ws\" absent\n", pSpool->pName));
    }

    // Refresh PrinterInfo2
    RefreshPrinter(pSpool);

    // Refresh PrinterInfo7
    RefreshPrinterInfo7(pSpool);
}


DWORD
EnumerateAndCopyKey(
    PWSPOOL pSpool,
    LPWSTR  pKeyName
)
{
    DWORD   i;
    DWORD   dwResult = ERROR_SUCCESS;
    LPWSTR  pSubKeys = NULL;
    LPWSTR  pSubKey  = NULL;
    LPWSTR  pFullSubKey = NULL;
    DWORD   cbSubKey;
    DWORD   cbSubKeys;
    LPBYTE  pEnumValues = NULL;
    DWORD   cbEnumValues;
    DWORD   nEnumValues;
    PPRINTER_ENUM_VALUES pEnumValue = NULL;


    // Get SubKey size
    dwResult = RemoteEnumPrinterKey(pSpool,
                                    pKeyName,
                                    pSubKeys,
                                    0,
                                    &cbSubKeys);
    if (dwResult != ERROR_MORE_DATA)
        goto Cleanup;

    // Allocate SubKey buffer
    pSubKeys = AllocSplMem(cbSubKeys);
    if(!pSubKeys) {
        dwResult = GetLastError();
        goto Cleanup;
    }

    // Get SubKeys
    dwResult = RemoteEnumPrinterKey(pSpool,
                                    pKeyName,
                                    pSubKeys,
                                    cbSubKeys,
                                    &cbSubKeys);

    if (dwResult == ERROR_SUCCESS) {    // Found subkeys

        DWORD cbFullSubKey = 0;

        // Enumerate and copy Keys

        if (*pKeyName && *pSubKeys) {

            cbFullSubKey = cbSubKeys + (wcslen(pKeyName) + 2)*sizeof(WCHAR);

            // Allocate buffer for L"pKeyName\pSubKey"
            pFullSubKey = AllocSplMem(cbFullSubKey);
            if(!pFullSubKey) {
                dwResult = GetLastError();
                goto Cleanup;
            }
        }

        for(pSubKey = pSubKeys ; *pSubKey ; pSubKey += wcslen(pSubKey) + 1) {

            if (*pKeyName) {
                StringCbPrintf(pFullSubKey, cbFullSubKey, L"%ws\\%ws", pKeyName, pSubKey);
                dwResult = EnumerateAndCopyKey(pSpool, pFullSubKey);
            } else {
                dwResult = EnumerateAndCopyKey(pSpool, pSubKey);
            }

            if (dwResult != ERROR_SUCCESS)
                goto Cleanup;
        }
    }

    dwResult = RemoteEnumPrinterDataEx( pSpool,
                                        pKeyName,
                                        pEnumValues,
                                        0,
                                        &cbEnumValues,
                                        &nEnumValues);

    // We quit here if *pKeyName == NULL so we don't copy root key values
    if (dwResult != ERROR_MORE_DATA || !*pKeyName)
        goto Cleanup;

    // Allocate EnumValues buffer
    pEnumValues = AllocSplMem(cbEnumValues);
    if(!pEnumValues) {
        dwResult = GetLastError();
        goto Cleanup;
    }

    // Get Values
    dwResult = RemoteEnumPrinterDataEx( pSpool,
                                        pKeyName,
                                        pEnumValues,
                                        cbEnumValues,
                                        &cbEnumValues,
                                        &nEnumValues);

    // Did we get any data, this could fail.
    if (dwResult == ERROR_SUCCESS)
    {
        // Set Values for current key
        for (i = 0, pEnumValue = (PPRINTER_ENUM_VALUES) pEnumValues ; i < nEnumValues ; ++i, ++pEnumValue)
        {
            dwResult = SplSetPrinterDataEx( pSpool->hSplPrinter,
                                            pKeyName,
                                            pEnumValue->pValueName,
                                            pEnumValue->dwType,
                                            pEnumValue->pData,
                                            pEnumValue->cbData);
            if (dwResult != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        }
    }


Cleanup:

    FreeSplMem(pSubKeys);

    FreeSplMem(pEnumValues);

    FreeSplMem(pFullSubKey);

    return dwResult;
}



BOOL
CacheEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    PWSPOOL  pSpool = (PWSPOOL) hPrinter;
    BOOL    ReturnValue;

    VALIDATEW32HANDLE( pSpool );

    if ((pSpool->Status & WSPOOL_STATUS_USE_CACHE) && !IsAdminAccess(&pSpool->PrinterDefaults)) {

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );


        ReturnValue = SplEnumForms( pSpool->hSplPrinter,
                                    Level,
                                    pForm,
                                    cbBuf,
                                    pcbNeeded,
                                    pcReturned );

    } else {

        ReturnValue = RemoteEnumForms( hPrinter,
                                       Level,
                                       pForm,
                                       cbBuf,
                                       pcbNeeded,
                                       pcReturned );

    }

    return ReturnValue;

}





BOOL
CacheGetForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PWSPOOL  pSpool = (PWSPOOL) hPrinter;
    BOOL    ReturnValue;

    VALIDATEW32HANDLE( pSpool );

    if ((pSpool->Status & WSPOOL_STATUS_USE_CACHE) && !IsAdminAccess(&pSpool->PrinterDefaults)) {

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );



        ReturnValue = SplGetForm( pSpool->hSplPrinter,
                                    pFormName,
                                    Level,
                                    pForm,
                                    cbBuf,
                                    pcbNeeded );

    } else {

        ReturnValue = RemoteGetForm( hPrinter,
                                     pFormName,
                                     Level,
                                     pForm,
                                     cbBuf,
                                     pcbNeeded );

    }

    return ReturnValue;

}


DWORD
CacheGetPrinterData(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    PWSPOOL  pSpool = (PWSPOOL) hPrinter;
    DWORD    ReturnValue;
    BOOL     bPrintProc = FALSE;
    WCHAR    szPrintProcKey[] = L"PrintProcCaps_";

    VALIDATEW32HANDLE( pSpool );

    //
    // If the pValueName is "PrintProcCaps_[datatype]" call the remote print processor which
    // supports that datatype and return the options that it supports.
    //
    if (pValueName && wcsstr(pValueName, szPrintProcKey)) {

        bPrintProc = TRUE;
    }

    if ((pSpool->Status & WSPOOL_STATUS_USE_CACHE) && !bPrintProc && !IsAdminAccess(&pSpool->PrinterDefaults)) {

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );



        ReturnValue = SplGetPrinterData( pSpool->hSplPrinter,
                                         pValueName,
                                         pType,
                                         pData,
                                         nSize,
                                         pcbNeeded );

    } else {

        ReturnValue = RemoteGetPrinterData( hPrinter,
                                            pValueName,
                                            pType,
                                            pData,
                                            nSize,
                                            pcbNeeded );

    }

    return  ReturnValue;

}


DWORD
CacheGetPrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    PWSPOOL  pSpool = (PWSPOOL) hPrinter;
    DWORD   ReturnValue;

    VALIDATEW32HANDLE( pSpool );

    if ((pSpool->Status & WSPOOL_STATUS_USE_CACHE) && !IsAdminAccess(&pSpool->PrinterDefaults)) {

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );



        ReturnValue = SplGetPrinterDataEx(  pSpool->hSplPrinter,
                                            pKeyName,
                                            pValueName,
                                            pType,
                                            pData,
                                            nSize,
                                            pcbNeeded );

    } else {

        ReturnValue = RemoteGetPrinterDataEx( hPrinter,
                                              pKeyName,
                                              pValueName,
                                              pType,
                                              pData,
                                              nSize,
                                              pcbNeeded );

    }

    return  ReturnValue;

}



DWORD
CacheEnumPrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPBYTE   pEnumValues,
   DWORD    cbEnumValues,
   LPDWORD  pcbEnumValues,
   LPDWORD  pnEnumValues
)
{
    PWSPOOL  pSpool = (PWSPOOL) hPrinter;
    DWORD   ReturnValue;

    VALIDATEW32HANDLE( pSpool );

    if ((pSpool->Status & WSPOOL_STATUS_USE_CACHE) && !IsAdminAccess(&pSpool->PrinterDefaults)) {

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );


        ReturnValue = SplEnumPrinterDataEx( pSpool->hSplPrinter,
                                            pKeyName,
                                            pEnumValues,
                                            cbEnumValues,
                                            pcbEnumValues,
                                            pnEnumValues );

    } else {

        ReturnValue = RemoteEnumPrinterDataEx(  hPrinter,
                                                pKeyName,
                                                pEnumValues,
                                                cbEnumValues,
                                                pcbEnumValues,
                                                pnEnumValues );

    }

    return  ReturnValue;

}



DWORD
CacheEnumPrinterKey(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPWSTR   pSubkey,
   DWORD    cbSubkey,
   LPDWORD  pcbSubkey
)
{
    PWSPOOL  pSpool = (PWSPOOL) hPrinter;
    DWORD   ReturnValue;

    VALIDATEW32HANDLE( pSpool );

    if ((pSpool->Status & WSPOOL_STATUS_USE_CACHE) && !IsAdminAccess(&pSpool->PrinterDefaults)) {

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );

        ReturnValue = SplEnumPrinterKey(pSpool->hSplPrinter,
                                        pKeyName,
                                        pSubkey,
                                        cbSubkey,
                                        pcbSubkey);

    } else {

        ReturnValue = RemoteEnumPrinterKey( hPrinter,
                                            pKeyName,
                                            pSubkey,
                                            cbSubkey,
                                            pcbSubkey);

    }

    return  ReturnValue;

}


BOOL
CacheOpenPrinter(
   LPWSTR   pName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTS pDefault
)
{
    PWSPOOL pSpool                  = NULL;
    PWSPOOL pRemoteSpool            = NULL;
    HANDLE  hSplPrinter             = INVALID_HANDLE_VALUE;
    BOOL    ReturnValue             = FALSE;
    HANDLE  hIniSpooler             = INVALID_HANDLE_VALUE;
    BOOL    DoOpenOnError           = TRUE;
    DWORD   LastError               = ERROR_SUCCESS;
    BOOL    bSync                   = FALSE;
    BOOL    bCreateCacheAfterCheck  = FALSE;

    LPWSTR pCommastr, pFixname = NULL;

    if (!VALIDATE_NAME(pName)) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    //
    // search for pszCnvrtdmToken on the end of pName
    // note that pszCnvrtdmToken must begin with a ','
    //
    SPLASSERT(pszCnvrtdmToken[0] == L',');

    pFixname = AllocSplStr( pName );

    if ( pFixname == NULL )
    {
        EnterSplSem();
        goto OpenPrinterError;
    }

    StripString(pFixname, pszCnvrtdmToken, L",");
    StripString(pFixname, pszDrvConvert, L",");
    pName = pFixname;

    ReturnValue = OpenCachePrinterOnly( pName, &hSplPrinter, &hIniSpooler, pDefault , TRUE);

    if ( hIniSpooler == INVALID_HANDLE_VALUE ) {

        //
        // This means that the inispooler does not exist yet. Only create it
        // after some more confirmation.
        //
        hSplPrinter = INVALID_HANDLE_VALUE;
        bCreateCacheAfterCheck = TRUE;
    }

    if ( ReturnValue == FALSE ) {

        // Printer Not Found in Cache

        DBGMSG(DBG_TRACE, ("CacheOpenPrinter SplOpenPrinter %ws error %d\n",
                              pName,
                              GetLastError() ));

        // FLOATING PROFILE
        // If this is a Floating Profile then the following condition applies
        // there is an entry in HKEY_CURRENT_USER but not entry in
        // HKEY_LOCAL_MACHINE for the cache.
        // If this is the case then we need to establish the Cache now

        if (PrinterConnectionExists( pName )) {

            //
            // The printer connection exists in the registry. See if the inispooler
            // did not exist yet. If it does not, create it. This is to prevent us
            // hitting the wire on a default printer when some apps start up.
            //
            if (bCreateCacheAfterCheck) {

                bCreateCacheAfterCheck = FALSE;

                ReturnValue = OpenCachePrinterOnly( pName, &hSplPrinter, &hIniSpooler, pDefault, FALSE);

                if (hIniSpooler == INVALID_HANDLE_VALUE) {
                    EnterSplSem();
                    hSplPrinter = INVALID_HANDLE_VALUE;
                    goto    OpenPrinterError;
                }
            }

            if ( ReturnValue == FALSE ) {

                if ( !AddPrinterConnectionPrivate( pName ) ||
                     SplOpenPrinter( pName ,
                                     &hSplPrinter,
                                     pDefault,
                                     hIniSpooler,
                                     NULL,
                                     0) != ROUTER_SUCCESS ) {

                    DBGMSG( DBG_TRACE, ("CacheOpenPrinter Failed to establish Floating Profile into Cache %d\n",
                                            GetLastError() ));

                    DoOpenOnError = FALSE;
                    EnterSplSem();
                    goto    OpenPrinterError;
                }

                DBGMSG( DBG_TRACE, ("CacheOpenPrinter Floating Profile Added to Cache\n"));
            }
        }
        else {

            //
            // This is just a remote open printer, just hit the wire.
            //
            EnterSplSem();
            goto    OpenPrinterError;
        }
    }

    EnterSplSem();

    SplInSem();

    //
    //  Create a pSpool Object for this Cached Printer
    //

    pSpool = AllocWSpool();
    
    if ( pSpool == NULL ) {

        DBGMSG(DBG_WARNING, ("CacheOpenPrinter AllocWSpool error %d\n", GetLastError() ));

        ReturnValue = FALSE;
        goto    OpenPrinterError;

    }

    pSpool->pName = AllocSplStr( pName );

    if ( pSpool->pName == NULL ) {

        DBGMSG(DBG_WARNING, ("CacheOpenPrinter AllocSplStr error %d\n", GetLastError() ));

        ReturnValue = FALSE;
        goto    OpenPrinterError;

    }

    pSpool->Status = WSPOOL_STATUS_USE_CACHE | WSPOOL_STATUS_NO_RPC_HANDLE;

    if (pFixname)
        pSpool->Status |=  WSPOOL_STATUS_CNVRTDEVMODE;

    pSpool->hIniSpooler = hIniSpooler;
    pSpool->hSplPrinter = hSplPrinter;

    SPLASSERT( hIniSpooler != INVALID_HANDLE_VALUE );
    SPLASSERT( hSplPrinter != INVALID_HANDLE_VALUE );

    //
    // We want to hit the network if:
    // 1. The dwSyncOpenPrinter is non-zero, OR
    // 2. A default is specified AND:
    //    a. A datatype is specified, and it's not RAW OR
    //    b. Administrative access is requested.
    //
    // For admin, we want to get the true status of the printer, since
    // they will be administering it.
    //
    // If a non-default and non-RAW datatype is specified, we need to
    // be synchronous, since the remote machine may refuse the datatype
    // (e.g., connecting to 1057 with EMF).
    //
    if( pDefault ){

        if( ( pDefault->pDatatype && ( _wcsicmp( pDefault->pDatatype, pszRaw ) != STRINGS_ARE_EQUAL )) ||
            IsAdminAccess(pDefault)){

            bSync = TRUE;
        }
    }

    if( dwSyncOpenPrinter != 0 || bSync){

       LeaveSplSem();

        ReturnValue = RemoteOpenPrinter( pName, &pRemoteSpool, pDefault, DO_NOT_CALL_LM_OPEN );

       EnterSplSem();

        if ( ReturnValue ) {

            DBGMSG( DBG_TRACE, ( "CacheOpenPrinter Synchronous Open OK pRemoteSpool %x pSpool %x\n", pRemoteSpool, pSpool ));
            SPLASSERT( pRemoteSpool->Type == SJ_WIN32HANDLE );

            pSpool->RpcHandle = pRemoteSpool->RpcHandle;
            pSpool->Status   |= pRemoteSpool->Status;
            pSpool->RpcError  = pRemoteSpool->RpcError;
            pSpool->bNt3xServer = pRemoteSpool->bNt3xServer;

            pRemoteSpool->RpcHandle = NULL;
            FreepSpool( pRemoteSpool );
            pRemoteSpool = NULL;

            CopypDefaultTopSpool( pSpool, pDefault );
            pSpool->Status &= ~WSPOOL_STATUS_NO_RPC_HANDLE;

            LeaveSplSem();
            ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
            EnterSplSem();
        } else {

            DBGMSG( DBG_TRACE, ( "CacheOpenPrinter Synchronous Open Failed  pSpool %x LastError %d\n", pSpool, GetLastError() ));
            DoOpenOnError = FALSE;
        }

    } else {

        ReturnValue = DoAsyncRemoteOpenPrinter( pSpool, pDefault);
    }


OpenPrinterError:

    SplInSem();

    if ( !ReturnValue ) {

        // Failure

       LeaveSplSem();

        LastError = GetLastError();

        if (( hSplPrinter != INVALID_HANDLE_VALUE ) &&
            ( hSplPrinter != NULL ) ) {
            SplClosePrinter( hSplPrinter );
        }

        if ( hIniSpooler != INVALID_HANDLE_VALUE ) {
            SplCloseSpooler( hIniSpooler );
        }

       EnterSplSem();

        if ( pSpool != NULL ) {

            pSpool->hSplPrinter = INVALID_HANDLE_VALUE;
            pSpool->hIniSpooler = INVALID_HANDLE_VALUE;

            FreepSpool( pSpool );
            pSpool = NULL;

        }

       LeaveSplSem();

        SetLastError( LastError );


        if ( DoOpenOnError ) {

            ReturnValue = RemoteOpenPrinter( pName, phPrinter, pDefault, CALL_LM_OPEN );

        }

    } else {

        //  Success, pass back Handle

        *phPrinter = (HANDLE)pSpool;

        LeaveSplSem();

    }

    SplOutSem();

    if ( ReturnValue == FALSE ) {
        DBGMSG(DBG_TRACE,("CacheOpenPrinter %ws failed %d *phPrinter %x\n", pName, GetLastError(), *phPrinter ));
    }

    if (pFixname)
        FreeSplStr(pFixname);

    return ( ReturnValue );

}


/*++

ROUTINE NAME:

    IncThreadCount

ROUTINE DESCRIPTION:

    Increments the global thread count for the background threads allowed (cOpenPrinterThreads)
    Assumes that the call is made from inside the spooler critical section.

ARGUMENTS:

    VOID

RETURN VALUE:

    VOID

--*/
VOID
IncThreadCount(
    VOID
)
{
    SplInSem();
    cOpenPrinterThreads++;
}

/*++

ROUTINE NAME:

    DecThreadCount

ROUTINE DESCRIPTION:

    Decrements the global thread count for the background threads allowed (cOpenPrinterThreads)
    Assumes that the call is made from inside the spooler critical section.

ARGUMENTS:

    VOID

RETURN VALUE:

    VOID

--*/
VOID
DecThreadCount(
    VOID
)
{
    SplInSem();
    cOpenPrinterThreads--;
}

BOOL
CopypDefaults(
    LPPRINTER_DEFAULTSW pSrc,
    LPPRINTER_DEFAULTSW pDest
)
{
    DWORD      cbDevMode   = 0;
    BOOL       ReturnValue = TRUE;
    LPWSTR     pDatatype   = NULL;
    LPDEVMODEW pDevMode    = NULL;

    if ((pSrc != NULL) && (pDest != NULL)) 
    {
        if (pSrc->pDatatype) 
        {
            pDatatype = AllocSplStr(pSrc->pDatatype);
            if (!pDatatype)
            {
                ReturnValue = FALSE;
            }
        }        
        
        if (ReturnValue && pSrc->pDevMode != NULL) 
        {
            cbDevMode = pSrc->pDevMode->dmSize + pSrc->pDevMode->dmDriverExtra;

            pDevMode = AllocSplMem(cbDevMode);

            if (pDevMode != NULL) 
            {
                CopyMemory(pDevMode, pSrc->pDevMode, cbDevMode);
            } 
            else
            {
                ReturnValue = FALSE;
            }
        } 
        
        if (ReturnValue)
        {
            if (pDest->pDatatype)
            {
                FreeSplStr(pDest->pDatatype);
            }

            pDest->pDatatype = pDatatype;
            pDatatype = NULL;

            if (pDest->pDevMode)
            {
                FreeSplMem(pDest->pDevMode);
            }

            pDest->pDevMode = pDevMode;
            pDevMode = NULL;

            pDest->DesiredAccess = pSrc->DesiredAccess;
        }
    }

    FreeSplStr(pDatatype);
    FreeSplMem(pDevMode);
    return ReturnValue;
}

BOOL
CopypDefaultTopSpool(
    PWSPOOL pSpool,
    LPPRINTER_DEFAULTSW pDefault
)
{
    DWORD   cbDevMode = 0;
    BOOL    ReturnValue = FALSE;

    //
    //  Copy the pDefaults so we can use them later
    //

 try {

    if ( ( pDefault != NULL ) &&
         ( pDefault != &pSpool->PrinterDefaults ) ) {

        if (!ReallocSplStr( &pSpool->PrinterDefaults.pDatatype , pDefault->pDatatype )) {
            leave;
        }

        if ( pSpool->PrinterDefaults.pDevMode != NULL ) {

            cbDevMode = pSpool->PrinterDefaults.pDevMode->dmSize +
                        pSpool->PrinterDefaults.pDevMode->dmDriverExtra;

            FreeSplMem( pSpool->PrinterDefaults.pDevMode );

            pSpool->PrinterDefaults.pDevMode = NULL;

        }

        if ( pDefault->pDevMode != NULL ) {

            cbDevMode = pDefault->pDevMode->dmSize + pDefault->pDevMode->dmDriverExtra;

            pSpool->PrinterDefaults.pDevMode = AllocSplMem( cbDevMode );

            if ( pSpool->PrinterDefaults.pDevMode != NULL ) {
                CopyMemory( pSpool->PrinterDefaults.pDevMode, pDefault->pDevMode, cbDevMode );
            } else {
                leave;
            }


        } else pSpool->PrinterDefaults.pDevMode = NULL;

        pSpool->PrinterDefaults.DesiredAccess = pDefault->DesiredAccess;

    }

    ReturnValue = TRUE;

 } finally {
 }
    return ReturnValue;

}


BOOL
DoAsyncRemoteOpenPrinter(
    PWSPOOL pSpool,
    LPPRINTER_DEFAULTS pDefault
)
{
    HRESULT      hResult     = E_FAIL;

    SplInSem();

    SPLASSERT(pSpool->Status & WSPOOL_STATUS_USE_CACHE);

    hResult = pSpool ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hResult)) 
    {
        hResult = CopypDefaultTopSpool(pSpool, pDefault) ? S_OK : E_OUTOFMEMORY;

        if (SUCCEEDED(hResult)) 
        {
            hResult = BindThreadToHandle(pSpool);
        }
    }

    return BoolFromHResult(hResult);
}

BOOL
DoRemoteOpenPrinter(
   LPWSTR   pPrinterName,
   LPPRINTER_DEFAULTS pDefault,
   PWSPOOL   pSpool
)
{
    PWSPOOL pRemoteSpool = NULL;
    BOOL    bReturnValue;
    DWORD   dwLastError;

    SplOutSem();

    bReturnValue = RemoteOpenPrinter( pPrinterName, &pRemoteSpool, pDefault, DO_NOT_CALL_LM_OPEN );
    dwLastError = GetLastError();

    //
    // Copy useful values to our CacheHandle and discard the new handle
    //

   EnterSplSem();

    if ( bReturnValue ) {

        DBGMSG(DBG_TRACE, ("DoRemoteOpenPrinter RemoteOpenPrinter OK hRpcHandle %x\n", pRemoteSpool->RpcHandle ));

        SPLASSERT( WSJ_SIGNATURE == pSpool->signature );
        SPLASSERT( WSJ_SIGNATURE == pRemoteSpool->signature );
        SPLASSERT( pRemoteSpool->Type == SJ_WIN32HANDLE );
        SPLASSERT( pSpool->Type  == pRemoteSpool->Type );
        SPLASSERT( pRemoteSpool->pServer == NULL );
        SPLASSERT( pRemoteSpool->pShare  == NULL );

        pSpool->RpcHandle = pRemoteSpool->RpcHandle;
        pSpool->Status   |= pRemoteSpool->Status;
        pSpool->RpcError  = pRemoteSpool->RpcError;
        pSpool->bNt3xServer = pRemoteSpool->bNt3xServer;

        pRemoteSpool->RpcHandle = NULL;
        FreepSpool( pRemoteSpool );
        pRemoteSpool = NULL;

        if ( pSpool->RpcHandle ) {
            pSpool->Status &= ~WSPOOL_STATUS_OPEN_ERROR;
        }

    } else {

        DBGMSG(DBG_WARNING, ("DoRemoteOpenPrinter RemoteOpenPrinter %ws failed %d\n", pPrinterName, dwLastError ));

        pSpool->RpcHandle = NULL;
        pSpool->Status |= WSPOOL_STATUS_OPEN_ERROR;
        pSpool->RpcError = dwLastError;

        if (pSpool->pThread)
        {
            pSpool->pThread->dwRpcOpenPrinterError = dwLastError;            
        }

    }

    pSpool->Status &= ~WSPOOL_STATUS_NO_RPC_HANDLE;
    
    if (pSpool->pThread)
    {
        pSpool->pThread->hRpcHandle = pSpool->RpcHandle;

        if ( !SetEvent( pSpool->pThread->hWaitValidHandle ))
        {       
            DBGMSG(DBG_ERROR, ("RemoteOpenPrinterThread failed SetEvent pThread %x pThread->hWaitValidHandle %x\n",
                       pSpool->pThread, pSpool->pThread->hWaitValidHandle ));
        }
    }

    LeaveSplSem();

    //  Check Cache Consistency
    //  The Workstation and the Server have a version ID
    //  If the version number has changed on the server then update the
    //  workstation Cache.

    ConsistencyCheckCache(pSpool, kCheckPnPPolicy);

    SplOutSem();

    return ( bReturnValue );
}



DWORD
RemoteOpenPrinterThread(
    PWIN32THREAD pThread
)
{
    HRESULT hResult      = E_FAIL;
    PWSPOOL pSpool       = NULL;
    HANDLE  hSplPrinter  = INVALID_HANDLE_VALUE;
    HANDLE  hIniSpooler  = INVALID_HANDLE_VALUE;
    PPRINTER_DEFAULTSW pDefaults = NULL;

    SplOutSem();

    EnterSplSem();
    
    hResult = pThread ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hResult))
    {
        SetCurrentSid( pThread->hToken );

        pSpool = AllocWSpool();

        hResult = pSpool ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hResult))
    {
        pSpool->Status = WSPOOL_STATUS_USE_CACHE;

        pSpool->pThread = pThread;

        pDefaults = (PPRINTER_DEFAULTSW)AllocSplMem(sizeof(PRINTER_DEFAULTSW));

        hResult = pDefaults && CopypDefaults(pThread->pDefaults, pDefaults) ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hResult))
    {
        pSpool->pName = AllocSplStr( pThread->pName );

        hResult = pSpool->pName ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hResult))
    {
        LeaveSplSem();
        SplOutSem();

        hResult = OpenCachePrinterOnly(pSpool->pName, &(hSplPrinter), &(hIniSpooler), pDefaults, TRUE) ? S_OK : GetLastErrorAsHResultAndFail();

        EnterSplSem();
    }

    if (SUCCEEDED(hResult))
    {
        SPLASSERT( hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( hSplPrinter != INVALID_HANDLE_VALUE );

        pSpool->hIniSpooler = hIniSpooler;
        pSpool->hSplPrinter = hSplPrinter;

        SPLASSERT( pSpool->signature == WSJ_SIGNATURE );

        LeaveSplSem();
        SplOutSem();

        hResult = DoRemoteOpenPrinter(pSpool->pName, pDefaults, pSpool) ? S_OK : GetLastErrorAsHResultAndFail();
        
        EnterSplSem();
    }

    if (SUCCEEDED(hResult))
    {               
        LeaveSplSem();
        
        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);

        EnterSplSem();                              
    }

    //
    // Indicate that the background this is complete.
    // 
    if (pThread)
    {
        BackgroundThreadFinished(&pThread, pSpool);
    }
    
    DecThreadCount();

    if (pSpool)
    {
        //
        // Delete our temporary pSpool. If it still has the RpcHandle then we 
        // haven't assigned it to the thread object.
        //
        if (pSpool->RpcHandle)
        {
            LeaveSplSem();
            SplOutSem();

            RemoteClosePrinter((HANDLE)pSpool);

            EnterSplSem();
            SplInSem();
        }

        LeaveSplSem();
        SplOutSem();
         
        if (pSpool->hSplPrinter != INVALID_HANDLE_VALUE)
        {
            SplClosePrinter( pSpool->hSplPrinter );
        }
        if (pSpool->hIniSpooler != INVALID_HANDLE_VALUE)
        {
            SplCloseSpooler( pSpool->hIniSpooler );
        }

        EnterSplSem();

        pSpool->hSplPrinter = INVALID_HANDLE_VALUE;
        pSpool->hIniSpooler = INVALID_HANDLE_VALUE;

        FreepSpool( pSpool );
    }

    LeaveSplSem();

    SetCurrentSid( NULL );

    if (pDefaults)
    {
        FreeSplStr(pDefaults->pDatatype);
        FreeSplMem(pDefaults->pDevMode);
        FreeSplMem(pDefaults);
    }

    ExitThread( 0 );
    return( 0 );
}

PWSPOOL
AllocWSpool(
    VOID
)
{
    PWSPOOL pSpool = NULL;

    SplInSem();

    if (pSpool = AllocSplMem(sizeof(WSPOOL))) {

        pSpool->signature = WSJ_SIGNATURE;
        pSpool->Type = SJ_WIN32HANDLE;
        pSpool->RpcHandle        = NULL;
        pSpool->hFile            = INVALID_HANDLE_VALUE;
        pSpool->hIniSpooler      = INVALID_HANDLE_VALUE;
        pSpool->hSplPrinter      = INVALID_HANDLE_VALUE;
        pSpool->pThread          = NULL;

        // Add to List

        pSpool->pNext = pFirstWSpool;
        pSpool->pPrev = NULL;

        if ( pFirstWSpool != NULL ) {

            pFirstWSpool->pPrev = pSpool;

        }

        pFirstWSpool = pSpool;

    } else {

        DBGMSG( DBG_WARNING, ("AllocWSpool failed %d\n", GetLastError() ));

    }

    return ( pSpool );

}



VOID
FreepSpool(
    PWSPOOL  pSpool
)
{
    SplInSem();

    SPLASSERT( pSpool->hSplPrinter == INVALID_HANDLE_VALUE );
    SPLASSERT( pSpool->hIniSpooler == INVALID_HANDLE_VALUE );
    SPLASSERT( !pSpool->RpcHandle );
    SPLASSERT( pSpool->hFile       == INVALID_HANDLE_VALUE );

    // Remove form linked List

    if ( pSpool->pNext != NULL ) {
        SPLASSERT( pSpool->pNext->pPrev == pSpool);
        pSpool->pNext->pPrev = pSpool->pPrev;
    }

    if  ( pSpool->pPrev == NULL ) {

        SPLASSERT( pFirstWSpool == pSpool );
        pFirstWSpool = pSpool->pNext;

    } else {

        SPLASSERT( pSpool->pPrev->pNext == pSpool );
        pSpool->pPrev->pNext = pSpool->pNext;

    }

    FreeSplStr( pSpool->pName );
    FreeSplStr( pSpool->PrinterDefaults.pDatatype );

    if ( pSpool->PrinterDefaults.pDevMode != NULL ) {
        FreeSplMem( pSpool->PrinterDefaults.pDevMode );
    }

    FreeSplMem(pSpool);
}



BOOL
CacheClosePrinter(
    HANDLE  hPrinter
)
{
    BOOL ReturnValue = TRUE;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    SplOutSem();

    VALIDATEW32HANDLE( pSpool );

    if (pSpool->Status & WSPOOL_STATUS_PRINT_FILE) 
    {
        RemoteEndDocPrinter( pSpool );
    }

    ReturnThreadFromHandle(pSpool);

    EnterSplSem();

    if ( pSpool->Status & WSPOOL_STATUS_TEMP_CONNECTION ) 
    {
        pSpool->Status &= ~WSPOOL_STATUS_TEMP_CONNECTION;

        LeaveSplSem();
        if (!DeletePrinterConnection( pSpool->pName )) 
        {
            DBGMSG( DBG_TRACE, ("CacheClosePrinter failed DeletePrinterConnection %ws %d\n",
                                pSpool->pName, GetLastError() ));
        }
        EnterSplSem();

        SPLASSERT( pSpool->signature == WSJ_SIGNATURE );
    }


    SplInSem();

    if ( pSpool->Status & WSPOOL_STATUS_USE_CACHE ) 
    {
        if ( !(pSpool->Status & WSPOOL_STATUS_ASYNC) && pSpool->RpcHandle ) 
        {

            DBGMSG(DBG_TRACE, ("CacheClosePrinter pSpool %x RpcHandle %x Status %x\n",
                                pSpool, pSpool->RpcHandle, pSpool->Status));

            LeaveSplSem();
            SplOutSem();

            ReturnValue = RemoteClosePrinter( hPrinter );

            EnterSplSem();
        }

        SplInSem();

        SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );
        SPLASSERT( pSpool->hSplPrinter != INVALID_HANDLE_VALUE );

        LeaveSplSem();
        SplOutSem();

        SplClosePrinter( pSpool->hSplPrinter );
        SplCloseSpooler( pSpool->hIniSpooler );

        EnterSplSem();

        pSpool->hSplPrinter = INVALID_HANDLE_VALUE;
        pSpool->hIniSpooler = INVALID_HANDLE_VALUE;

        pSpool->Status &= ~WSPOOL_STATUS_USE_CACHE;

        FreepSpool( pSpool );

        LeaveSplSem();

    } 
    else 
    {
        SplInSem();

        if ( pSpool->hIniSpooler != INVALID_HANDLE_VALUE ) 
        {
            SplCloseSpooler( pSpool->hIniSpooler );
            pSpool->hIniSpooler = INVALID_HANDLE_VALUE;
        }

        LeaveSplSem();

        ReturnValue = RemoteClosePrinter( hPrinter );

        EnterSplSem();

        FreepSpool( pSpool );

        LeaveSplSem();
    }

    SplOutSem();

    return( ReturnValue );

}


BOOL
CacheSyncRpcHandle(
    PWSPOOL pSpool
)
{
    DWORD   dwLastError = ERROR_SUCCESS;
    
    EnterSplSem();

    WaitAndAcquireRpcHandle(pSpool);
    
    if ( pSpool->Status & WSPOOL_STATUS_OPEN_ERROR ) {

        BOOL    bRet = FALSE;
    
        DBGMSG(DBG_WARNING, ("CacheSyncRpcHandle pSpool %x Status %x; setting last error = %d\n",
                             pSpool,
                             pSpool->Status,
                             pSpool->RpcError));

        dwLastError = pSpool->RpcError;

        //
        //  If we failed to open the Server because it was unavailable
        //  then try and open it again ( provided the asynchronous thread is not active ).
        //
        if ((!pSpool->RpcHandle)     &&
            (pSpool->RpcError != ERROR_ACCESS_DENIED)) {

            LeaveSplSem();

            ReturnThreadFromHandle(pSpool);

            EnterSplSem();

            DBGMSG( DBG_WARNING, ("CacheSyncRpcHandle retrying Async OpenPrinter\n"));

            //
            // We have abadoned our RPC handle.
            // 
            pSpool->Status |= WSPOOL_STATUS_NO_RPC_HANDLE;

            //
            // We don't have an asynchronous thread for now.
            // We keep the error until we know we have spun a new thread.
            // 
            pSpool->Status &= ~WSPOOL_STATUS_ASYNC; 

            //
            // If this succeeds, then we know we have a background thread that
            // we can wait on. Otherwise, we don't have an RPC handle and the 
            // pSpool status is definitely asynchronous.
            // 
            if (DoAsyncRemoteOpenPrinter(pSpool, &pSpool->PrinterDefaults)) {

                //
                // We let the OpenPrinter error come from WaitAndAcquireRpcHandle;
                // 
                pSpool->Status &= ~WSPOOL_STATUS_OPEN_ERROR;
                pSpool->RpcError = ERROR_SUCCESS;
                
                WaitAndAcquireRpcHandle(pSpool);

                //
                // Either get the last error code or if there wasn't an open error clear it.
                // 
                if (pSpool->Status & WSPOOL_STATUS_OPEN_ERROR)
                {
                    dwLastError = pSpool->RpcError;
                }
                else
                {
                    bRet = TRUE;
                }
            }
        }

        LeaveSplSem();
                 
        if (!bRet) {

            if (dwLastError == ERROR_SUCCESS) {
                SetLastError( ERROR_INVALID_FUNCTION );
            }
            else {
                SetLastError( dwLastError );
            }
        }

        return bRet;
    }

    if ( pSpool->RpcHandle &&
         pSpool->Status & WSPOOL_STATUS_RESETPRINTER_PENDING ) {

        DBGMSG(DBG_TRACE, ("CacheSyncRpcHandle calling RemoteResetPrinter\n"));

        pSpool->Status &= ~ WSPOOL_STATUS_RESETPRINTER_PENDING;

        LeaveSplSem();

        if ( ! RemoteResetPrinter( pSpool, &pSpool->PrinterDefaults ) ) {
            EnterSplSem();
            pSpool->Status |= WSPOOL_STATUS_RESETPRINTER_PENDING;
        }
        else {
            EnterSplSem();
        }

        SplInSem();        
    }

    LeaveSplSem();

    return TRUE;
}


/*++

Name:

    WaitAndAcquireRpcHandle

Description:

    If the handle doesn't have an RPC handle assigned to it then wait for the 
    background thread to complete opening the RPC handle and write it into the
    foreground structure.

Arguments:

    pSpool          -   The foreground handle to use.

Return Value:

    Nothing

--*/
VOID
WaitAndAcquireRpcHandle(
    IN      PWSPOOL     pSpool
    )
{
    SplInSem();
    
    if ( pSpool->Status & WSPOOL_STATUS_NO_RPC_HANDLE ) {

        if (pSpool->pThread) {
            
            LeaveSplSem();

            DBGMSG(DBG_TRACE,("CacheSyncRpcHandle Status WSPOOL_STATUS_NO_RPC_HANDLE waiting for RpcHandle....\n"));

            SplOutSem();

            WaitForSingleObject(pSpool->pThread->hWaitValidHandle, INFINITE);
        
            EnterSplSem();

            pSpool->RpcHandle = pSpool->pThread->hRpcHandle;

            pSpool->Status &= ~WSPOOL_STATUS_NO_RPC_HANDLE;
        }
    }

    if (pSpool->pThread && pSpool->pThread->dwRpcOpenPrinterError != ERROR_SUCCESS) {
        pSpool->Status |= WSPOOL_STATUS_OPEN_ERROR;
        pSpool->RpcError = pSpool->pThread->dwRpcOpenPrinterError;
    }
}

BOOL
CacheGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL    ReturnValue = FALSE;
    DWORD   dwServerMajorVersion = 0, dwServerMinorVersion = 0, dwPrivateFlag = 0;
    PWSPOOL pSpool = (PWSPOOL) hPrinter, pTempSpool = NULL;
    DWORD   dwLastError;

    VALIDATEW32HANDLE( pSpool );

    try {

        if (pSpool->Type != SJ_WIN32HANDLE) {
            SetLastError(ERROR_INVALID_FUNCTION);
            leave;
        }

        if ( !(pSpool->Status & WSPOOL_STATUS_USE_CACHE) ) {

            // Someone is calling GetPrinterDriver without a connection
            // we must NEVER EVER pass the caller a UNC name since they
            // will LoadLibrary accross the network, which might lead
            // to InPageIOErrors ( if the net goes down).
            // The solution is to establish a Temporary Connection for the life
            // of the pSpool handle, the connection will be removed
            // in CacheClosePrinter.    The connection will ensure that the
            // drivers are copied locally and a local cache is established
            // for this printer.

            pSpool->Status |= WSPOOL_STATUS_TEMP_CONNECTION;

            pTempSpool = InternalAddPrinterConnection( pSpool->pName );

            if ( !pTempSpool )
            {
                pSpool->Status &= ~WSPOOL_STATUS_TEMP_CONNECTION;

                DBGMSG( DBG_TRACE, ("CacheGetPrinterDriver failed AddPrinterConnection %d\n",
                                       GetLastError() ));
                leave;
            }

            ReturnValue = OpenCachePrinterOnly( pSpool->pName, &pSpool->hSplPrinter,
                                                &pSpool->hIniSpooler, NULL, FALSE);

            if ( !ReturnValue )
            {
                SplCloseSpooler( pSpool->hIniSpooler );

                DBGMSG( DBG_WARNING,
                        ("CacheGetPrinterDriver Connection OK Failed CacheOpenPrinter %d\n",
                          GetLastError() ));
                leave;
            }

            pSpool->Status |= WSPOOL_STATUS_USE_CACHE;
        }

        SPLASSERT( pSpool->Status & WSPOOL_STATUS_USE_CACHE );

        ReturnValue = SplGetPrinterDriverEx( pSpool->hSplPrinter,
                                             pEnvironment,
                                             Level,
                                             pDriverInfo,
                                             cbBuf,
                                             pcbNeeded,
                                             cThisMajorVersion,
                                             cThisMinorVersion,
                                             &dwServerMajorVersion,
                                             &dwServerMinorVersion);


    } finally {

        if (pTempSpool) {
            dwLastError = GetLastError();
            CacheClosePrinter(pTempSpool);
            SetLastError(dwLastError);
        }
    }

    return ReturnValue;
}


BOOL
CacheResetPrinter(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTS pDefault
)
{
    PWSPOOL pSpool = (PWSPOOL) hPrinter;
    BOOL    ReturnValue =  FALSE;

    VALIDATEW32HANDLE(pSpool);

    if (pSpool->Status & WSPOOL_STATUS_USE_CACHE)
    {
        EnterSplSem();

        ReturnValue = SplResetPrinter(pSpool->hSplPrinter, pDefault);

        if (ReturnValue)
        {
            CopypDefaultTopSpool(pSpool, pDefault);

            if (pSpool->RpcHandle)
            {
                //
                //  Have RPC Handle
                //
                LeaveSplSem();

                ReturnValue = RemoteResetPrinter(hPrinter, pDefault);
            }
            else
            {
                //
                //  No RpcHandle
                //
                DBGMSG( DBG_TRACE, ("CacheResetPrinter %x NO_RPC_HANDLE Status Pending\n",
                                     pSpool ));

                pSpool->Status |= WSPOOL_STATUS_RESETPRINTER_PENDING;

                LeaveSplSem();
            }
        }
        else
        {
            LeaveSplSem();
        }
    }
    else
    {
        ReturnValue = RemoteResetPrinter(hPrinter, pDefault);
    }

    return ReturnValue;
}


BOOL
CacheGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PWSPOOL pSpool = (PWSPOOL) hPrinter;
    BOOL    ReturnValue =  FALSE;
    PWCACHEINIPRINTEREXTRA pExtraData = NULL;
    DWORD   LastError = ERROR_SUCCESS;
    DWORD   cbSize = 0;
    DWORD   cbDevMode;
    DWORD   cbSecDesc;
    LPWSTR  SourceStrings[sizeof(PRINTER_INFO_2)/sizeof(LPWSTR)];
    LPWSTR  *pSourceStrings=SourceStrings;
    LPBYTE  pEnd;
    DWORD   *pOffsets;
    PPRINTER_INFO_2W    pPrinter2 = (PPRINTER_INFO_2)pPrinter;
    PPRINTER_INFO_4W    pPrinter4 = (PPRINTER_INFO_4)pPrinter;
    PPRINTER_INFO_5W    pPrinter5 = (PPRINTER_INFO_5)pPrinter;
    BOOL                bCallRemote = TRUE;

    VALIDATEW32HANDLE( pSpool );

 try {

    if ( (Level == 2 || Level == 5) &&
         (pSpool->Status & WSPOOL_STATUS_USE_CACHE) ) {

        ReturnValue = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );

        if (ReturnValue && pExtraData) {

            if ( (GetTickCount() - pExtraData->dwTickCount) < REFRESH_TIMEOUT )
                bCallRemote = FALSE;
        }
        pExtraData = NULL;
    }

    if (( Level != 4) &&
        ( ((pSpool->RpcHandle) && bCallRemote ) ||

        IsAdminAccess(&pSpool->PrinterDefaults) ||

        !( pSpool->Status & WSPOOL_STATUS_USE_CACHE ) ||

        ( Level == GET_SECURITY_DESCRIPTOR ) ||

        ( Level == STRESSINFOLEVEL ))) {
                
        ReturnValue = RemoteGetPrinter( hPrinter,
                                        Level,
                                        pPrinter,
                                        cbBuf,
                                        pcbNeeded );

        if ( ReturnValue ) {
            leave;
        }


        LastError = GetLastError();


        if (IsAdminAccess(&pSpool->PrinterDefaults) ||

            !( pSpool->Status & WSPOOL_STATUS_USE_CACHE ) ||

            ( Level == GET_SECURITY_DESCRIPTOR ) ||

            ( Level == STRESSINFOLEVEL )) {

            leave;

        }

        SPLASSERT( pSpool->Status & WSPOOL_STATUS_USE_CACHE );

        if (( LastError != RPC_S_SERVER_UNAVAILABLE ) &&
            ( LastError != RPC_S_CALL_FAILED )        &&
            ( LastError != RPC_S_CALL_FAILED_DNE )    &&
            ( LastError != RPC_S_SERVER_TOO_BUSY )) {

            // Valid Error like ERROR_INSUFFICIENT_BUFFER or ERROR_INVALID_HANDLE.

            leave;

        }
    }

    //
    // If it is level 4, we must check if we have the information in the cache
    // If not, we return ERROR_INVALID_LEVEL.
    //

    if (Level == 4 && (! (pSpool->Status & WSPOOL_STATUS_USE_CACHE))) {
        LastError = ERROR_INVALID_LEVEL;
        ReturnValue = FALSE;

    }
    else {

        //
        // Assert to make sure the data is in the cache.
        //

        SPLASSERT( pSpool->Status & WSPOOL_STATUS_USE_CACHE );

        switch ( Level ) {

        case    1:
        case    7:

            ReturnValue = SplGetPrinter( pSpool->hSplPrinter,
                                         Level,
                                         pPrinter,
                                         cbBuf,
                                         pcbNeeded );

            if ( ReturnValue == FALSE ) {

                LastError = GetLastError();

            }

            break;

        case    4:

           EnterSplSem();

            ReturnValue = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );

            if ( ReturnValue == FALSE ) {

                DBGMSG( DBG_WARNING, ("CacheGetPrinter SplGetPrinterExtra pSpool %x error %d\n", pSpool, GetLastError() ));
                SPLASSERT( ReturnValue );

            }

            if ( pExtraData == NULL ) {
                LeaveSplSem();
                break;
            }

            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

            cbSize = pExtraData->cbPI2;
            *pcbNeeded = cbSize;

            if ( cbSize > cbBuf ) {
                LastError = ERROR_INSUFFICIENT_BUFFER;
                ReturnValue = FALSE;
                LeaveSplSem();
                break;
            }

            *pSourceStrings++ = pExtraData->pPI2->pPrinterName;
            *pSourceStrings++ = pExtraData->pPI2->pServerName;

            pOffsets = PrinterInfo4Strings;
            pEnd = pPrinter + cbBuf;

            pEnd = PackStrings(SourceStrings, pPrinter, pOffsets, pEnd);

            pPrinter4->Attributes      = pExtraData->pPI2->Attributes;

            ReturnValue = TRUE;

           LeaveSplSem();

            break;

        case    2:

           EnterSplSem();

            ReturnValue = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );

            if ( ReturnValue == FALSE ) {

                DBGMSG( DBG_WARNING, ("CacheGetPrinter SplGetPrinterExtra pSpool %x error %d\n", pSpool, GetLastError() ));
                SPLASSERT( ReturnValue );

            }

            if ( pExtraData == NULL ) {
                LeaveSplSem();
                break;
            }

            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

            cbSize = pExtraData->cbPI2;
            *pcbNeeded = cbSize;

            if ( cbSize > cbBuf ) {
                LastError = ERROR_INSUFFICIENT_BUFFER;
                ReturnValue = FALSE;
                LeaveSplSem();
                break;
            }

            // NOTE
            // In the case of EnumerateFavoritePrinters it expects us to pack our
            // strings at the end of the structure not just following it.
            // You might wrongly assume that you could just copy the complete structure
            // inluding strings but you would be wrong.

            *pSourceStrings++ = pExtraData->pPI2->pServerName;
            *pSourceStrings++ = pExtraData->pPI2->pPrinterName;
            *pSourceStrings++ = pExtraData->pPI2->pShareName;
            *pSourceStrings++ = pExtraData->pPI2->pPortName;
            *pSourceStrings++ = pExtraData->pPI2->pDriverName;
            *pSourceStrings++ = pExtraData->pPI2->pComment;
            *pSourceStrings++ = pExtraData->pPI2->pLocation;
            *pSourceStrings++ = pExtraData->pPI2->pSepFile;
            *pSourceStrings++ = pExtraData->pPI2->pPrintProcessor;
            *pSourceStrings++ = pExtraData->pPI2->pDatatype;
            *pSourceStrings++ = pExtraData->pPI2->pParameters;

            pOffsets = PrinterInfo2Strings;
            pEnd = pPrinter + cbBuf;

            pEnd = PackStrings(SourceStrings, pPrinter, pOffsets, pEnd);

            if ( pExtraData->pPI2->pDevMode != NULL ) {

                cbDevMode = ( pExtraData->pPI2->pDevMode->dmSize + pExtraData->pPI2->pDevMode->dmDriverExtra );
                pEnd -= cbDevMode;

                pEnd = (LPBYTE)ALIGN_PTR_DOWN(pEnd);

                pPrinter2->pDevMode = (LPDEVMODE)pEnd;

                CopyMemory(pPrinter2->pDevMode, pExtraData->pPI2->pDevMode, cbDevMode );

            } else {

                pPrinter2->pDevMode = NULL;

            }

            if ( pExtraData->pPI2->pSecurityDescriptor != NULL ) {

                cbSecDesc = GetSecurityDescriptorLength( pExtraData->pPI2->pSecurityDescriptor );

                pEnd -= cbSecDesc;
                pEnd = (LPBYTE)ALIGN_PTR_DOWN(pEnd);

                pPrinter2->pSecurityDescriptor = pEnd;

                CopyMemory( pPrinter2->pSecurityDescriptor, pExtraData->pPI2->pSecurityDescriptor, cbSecDesc );


            } else {

                pPrinter2->pSecurityDescriptor = NULL;

            }


            pPrinter2->Attributes      = pExtraData->pPI2->Attributes;
            pPrinter2->Priority        = pExtraData->pPI2->Priority;
            pPrinter2->DefaultPriority = pExtraData->pPI2->DefaultPriority;
            pPrinter2->StartTime       = pExtraData->pPI2->StartTime;
            pPrinter2->UntilTime       = pExtraData->pPI2->UntilTime;
            pPrinter2->Status          = pExtraData->pPI2->Status;
            pPrinter2->cJobs           = pExtraData->pPI2->cJobs;
            pPrinter2->AveragePPM      = pExtraData->pPI2->AveragePPM;

            ReturnValue = TRUE;

            LeaveSplSem();
            break;

        case 5:

            //
            // We need to support a cached level 5 get, the printer, the port
            // name and the attributes we get from the Cached PI2. For the port
            // attributes, we just return the default.
            //
            EnterSplSem();

            ReturnValue = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );

            if ( ReturnValue == FALSE ) {

                DBGMSG( DBG_WARNING, ("CacheGetPrinter SplGetPrinterExtra pSpool %x error %d\n", pSpool, GetLastError() ));
                SPLASSERT( ReturnValue );
            }

            if ( pExtraData == NULL ) {
                LeaveSplSem();
                break;
            }

            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

            //
            // The size is the size of the printer name, the port name, their NULL
            // terminating characters and the size of the PRINTER_INFO_5 structure
            // itself.
            //
            cbSize = (pExtraData->pPI2->pPrinterName ? (wcslen(pExtraData->pPI2->pPrinterName) + 1) : 0) * sizeof(WCHAR) +
                     (pExtraData->pPI2->pPortName    ? (wcslen(pExtraData->pPI2->pPortName)    + 1) : 0) * sizeof(WCHAR) +
                     sizeof(PRINTER_INFO_5);

            *pcbNeeded = cbSize;

            if ( cbSize > cbBuf ) {
                LastError = ERROR_INSUFFICIENT_BUFFER;
                ReturnValue = FALSE;
                LeaveSplSem();
                break;
            }

            *pSourceStrings++ = pExtraData->pPI2->pPrinterName;
            *pSourceStrings++ = pExtraData->pPI2->pPortName;

            pOffsets = PrinterInfo5Strings;
            pEnd = pPrinter + cbBuf;

            pEnd = PackStrings(SourceStrings, pPrinter, pOffsets, pEnd);

            pPrinter5->Attributes               = pExtraData->pPI2->Attributes;
            pPrinter5->DeviceNotSelectedTimeout = kDefaultDnsTimeout;
            pPrinter5->TransmissionRetryTimeout = kDefaultTxTimeout;

            ReturnValue = TRUE;

            LeaveSplSem();

            break;

        case    3:
            DBGMSG( DBG_ERROR, ("CacheGetPrinter Level 3 impossible\n"));

        default:
            LastError = ERROR_INVALID_LEVEL;
            ReturnValue = FALSE;
            break;

        }
    }

 } finally {

    if ( !ReturnValue ) {

        SetLastError( LastError );

    }

 }

 return ReturnValue;

}


//
//  Called When the Printer is read back from the registry
//


PWCACHEINIPRINTEREXTRA
CacheReadRegistryExtra(
    HKEY    hPrinterKey
)
{
    PWCACHEINIPRINTEREXTRA pExtraData = NULL;
    LONG    ReturnValue;
    PPRINTER_INFO_2W    pPrinterInfo2 = NULL;
    DWORD   cbSizeRequested = 0;
    DWORD   cbSizeInfo2 = 0;



    ReturnValue = RegQueryValueEx( hPrinterKey, szCachePrinterInfo2, NULL, NULL, NULL, &cbSizeRequested );

    if ((ReturnValue == ERROR_MORE_DATA) || (ReturnValue == ERROR_SUCCESS)) {

        cbSizeInfo2 = cbSizeRequested;
        pPrinterInfo2 = AllocSplMem( cbSizeInfo2 );

        if ( pPrinterInfo2 != NULL ) {

            ReturnValue = RegQueryValueEx( hPrinterKey,
                                           szCachePrinterInfo2,
                                           NULL, NULL, (LPBYTE)pPrinterInfo2,
                                           &cbSizeRequested );

            if ( ReturnValue == ERROR_SUCCESS ) {

                //
                //  Cached Structures on Disk have offsets for pointers
                //

                if (MarshallUpStructure((LPBYTE)pPrinterInfo2, PrinterInfo2Fields,
                                         sizeof(PRINTER_INFO_2), NATIVE_CALL))
                {
                    pExtraData = AllocExtraData( pPrinterInfo2, cbSizeInfo2 );
                }
            }

            FreeSplMem( pPrinterInfo2 );
        }

    }

    //
    //  Read the timestamp for the Cached Printer Data
    //

    if ( pExtraData != NULL ) {

        cbSizeRequested = sizeof( pExtraData->cCacheID );

        ReturnValue = RegQueryValueEx(hPrinterKey,
                                      szCacheTimeLastChange,
                                      NULL, NULL,
                                      (LPBYTE)&pExtraData->cCacheID, &cbSizeRequested );

        // Read the Connection Reference Count

        cbSizeRequested = sizeof( pExtraData->cRef );

        ReturnValue = RegQueryValueEx(hPrinterKey,
                                      szcRef,
                                      NULL, NULL,
                      (LPBYTE)&pExtraData->cRef, &cbSizeRequested );

        cbSizeRequested = sizeof(pExtraData->dwServerVersion);
        ReturnValue = RegQueryValueEx(hPrinterKey,
                                      szServerVersion,
                                      NULL, NULL,
                                      (LPBYTE)&pExtraData->dwServerVersion,
                                      &cbSizeRequested);

    }

    return pExtraData;

}


BOOL
CacheWriteRegistryExtra(
    LPWSTR  pName,
    HKEY    hPrinterKey,
    PWCACHEINIPRINTEREXTRA pExtraData
)
{
    PPRINTER_INFO_2 pPrinterInfo2 = NULL;
    DWORD   cbSize = 0;
    DWORD   dwLastError = ERROR_SUCCESS;
    DWORD   Status;

    if ( pExtraData == NULL ) return FALSE;

    SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

    cbSize = pExtraData->cbPI2;

    if ( cbSize != 0 ) {

        pPrinterInfo2 = AllocSplMem( cbSize );

        if ( pPrinterInfo2 != NULL ) {

            CacheCopyPrinterInfo( pPrinterInfo2, pExtraData->pPI2, cbSize );

            //
            //  Before writing it to the registry make all pointers offsets
            //
            if (MarshallDownStructure((LPBYTE)pPrinterInfo2, PrinterInfo2Fields,
                                      sizeof(PRINTER_INFO_2), NATIVE_CALL))
            {
                dwLastError = RegSetValueEx( hPrinterKey, szCachePrinterInfo2, 0,
                                             REG_BINARY, (LPBYTE)pPrinterInfo2, cbSize );
            }
            else
            {
                dwLastError = GetLastError();
            }

            FreeSplMem( pPrinterInfo2 );

        } else {

            dwLastError = GetLastError();

        }
    }


    //
    //  Write Cache TimeStamp to Registry
    //

    cbSize = sizeof ( pExtraData->cCacheID );
    Status = RegSetValueEx( hPrinterKey, szCacheTimeLastChange, 0, REG_DWORD, (LPBYTE)&pExtraData->cCacheID, cbSize );
    if ( Status != ERROR_SUCCESS ) dwLastError = Status;

    cbSize = sizeof(pExtraData->dwServerVersion);
    Status = RegSetValueEx( hPrinterKey, szServerVersion, 0, REG_DWORD, (LPBYTE)&pExtraData->dwServerVersion, cbSize );
    if ( Status != ERROR_SUCCESS ) dwLastError = Status;

    cbSize = sizeof ( pExtraData->cRef );
    Status = RegSetValueEx( hPrinterKey, szcRef, 0, REG_DWORD, (LPBYTE)&pExtraData->cRef, cbSize );
    if ( Status != ERROR_SUCCESS ) dwLastError = Status;

    if ( dwLastError == ERROR_SUCCESS ) {

        return TRUE;

    } else {

        SetLastError( dwLastError );

        return FALSE;
    }


}

/*++

-- ConsistencyCheckCache --

Routine Description:

    This will determine if the Printer cache needs updating, and update it if necessary.
    It has a timeout value so as to reduce traffic and have less calls going across the wire.
    Checks the remote printer's ChangeID, and if the value differs from one stored in the cache
    it triggers an update.

Arguments:

    pSpool          - Handle to remote printer.
    bCheckPolicy    - If TRUE, we should check to policy to see if we are
                      allowed to download the driver.

Return Value:

    None

--*/

HRESULT
ConsistencyCheckCache(
    IN      PWSPOOL             pSpool,
    IN      EDriverDownload     eDriverDownload
)
{
    BOOL    ReturnValue = FALSE;
    BOOL    bGotID = TRUE;
    BOOL    RefreshNeeded = TRUE;
    DWORD   cbBuf = MAX_PRINTER_INFO0;
    BYTE    PrinterInfoW0[ MAX_PRINTER_INFO0 ];
    LPPRINTER_INFO_STRESSW pPrinter0 = (LPPRINTER_INFO_STRESSW)&PrinterInfoW0;
    DWORD   dwNeeded;
    PWCACHEINIPRINTEREXTRA pExtraData;
    BOOL    bGetPrinterExtra = TRUE;
    DWORD   NewTick;
    DWORD   RemoteChangeID = 0, DataType = 0, SizeNeeded = 0;
    DWORD   dwRetVal = ERROR_SUCCESS;
    UINT    cRetries = 0;

    enum
    {
        kMaxCacheRefreshAttempts = 10
    };

    HRESULT hResult = S_OK;

    if ( ( !pSpool->RpcHandle ) ||
        !( pSpool->Status & WSPOOL_STATUS_USE_CACHE )) 
    {
        return hResult;
    }

    SPLASSERT( pSpool->Status & WSPOOL_STATUS_USE_CACHE );

    //
    // Get the Printer ExtraData from the cache Printer. This is used for the comparisons
    // of the ChangeID and TickCount
    //

    bGetPrinterExtra = SplGetPrinterExtra( pSpool->hSplPrinter, &(PBYTE)pExtraData );

    if ( bGetPrinterExtra && (pExtraData != NULL))
    {
        SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );
        SPLASSERT( pExtraData->pPI2 != NULL );

        NewTick = GetTickCount();

        //
        // Make sure an appropriate amount of time has elapsed before hitting
        // the network again.
        //

        //
        // This takes care of the rollover case too, although you may get an extra refresh
        // before the timeout is over.
        //
        if ( (NewTick > ( pExtraData->dwTickCount + GetCacheTimeout()))
             || (NewTick < pExtraData->dwTickCount))
        {
            //
            // Get the new ChangeID from the Server. Try the GetPrinterData call
            // first to reduce network usage. If that fails, fall back to the old way.
            //

            RefreshNeeded = TRUE;

            //
            // Keep Updating our Cache until we match the Server or run out of retries. We dont
            // want to keep doing it in an infinite loop. 
            //

            for (cRetries = 0; cRetries < kMaxCacheRefreshAttempts && RefreshNeeded; cRetries++)
            {
                dwRetVal = RemoteGetPrinterData(
                                      pSpool,
                                      L"ChangeId",
                                      &DataType,
                                      (PBYTE) &RemoteChangeID,
                                      sizeof(RemoteChangeID),
                                      &SizeNeeded );

                if ((dwRetVal == ERROR_INVALID_PARAMETER) ||
                    (dwRetVal == ERROR_FILE_NOT_FOUND) )
                {
                    //
                    // Fall back to the old STRESSINFOLEVEL call.
                    //

                    ReturnValue = RemoteGetPrinter( pSpool, STRESSINFOLEVEL, (LPBYTE)&PrinterInfoW0, cbBuf, &dwNeeded );

                    if ( ReturnValue )
                    {
                        RemoteChangeID = pPrinter0->cChangeID;
                        bGotID = TRUE;
                    }
                    else
                    {
                        SPLASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
                        DBGMSG( DBG_TRACE, ("ConsistencyCheckCache failed RemoteGetPrinter %d\n", GetLastError() ));
                        bGotID = FALSE;
                        hResult = HResultFromWin32(GetLastError());
                    }

                }
                else if (dwRetVal != ERROR_SUCCESS)
                {
                    //
                    // Something went badly wrong here.
                    //

                    DBGMSG( DBG_TRACE, ("ConsistencyCheckCache failed RemoteGetPrinterData %d\n", GetLastError() ));
                    bGotID = FALSE;
                    hResult = HResultFromWin32(GetLastError());
                }
                else
                {
                    bGotID = TRUE;
                }

                if ( bGotID && (pExtraData->cCacheID != RemoteChangeID) )
                {
                    DBGMSG( DBG_TRACE, ("ConsistencyCheckCache << Server cCacheID %x Workstation cChangeID %x >>\n",
                                         RemoteChangeID,
                                         pExtraData->cCacheID ));

                    //
                    // Now we want to change the info, since we need to update
                    //
                    if ( !ReturnValue )
                    {
                        ReturnValue = RemoteGetPrinter(pSpool, STRESSINFOLEVEL, (LPBYTE)&PrinterInfoW0, cbBuf, &dwNeeded);
                    }

                    if ( ReturnValue )
                    {
                        //
                        // Update Data we can't get from GetPrinterData.
                        // We might be able to leave this out. Not sure yet.
                        //
                        pExtraData->dwServerVersion = pPrinter0->dwGetVersion;
                        pExtraData->pPI2->cJobs  = pPrinter0->cJobs;
                        pExtraData->pPI2->Status = pPrinter0->Status;

                    }
                    else
                    {
                        SPLASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
                        DBGMSG( DBG_TRACE, ("ConsistencyCheckCache failed RemoteGetPrinter %d\n", GetLastError() ));
                        hResult = HResultFromWin32(GetLastError());
                    }


                    //
                    //  Don't have tons of threads doing a refresh at the same time
                    //  In stress when there are lots of folks changing printer settings
                    //  so the cChangeId changes a lot, but we don't want multiple threads
                    //  all doing a refresh since you get a LOT, it doesn't buy anything
                    //

                    EnterSplSem();

                    if ( !(pExtraData->Status & EXTRA_STATUS_DOING_REFRESH) ) 
                    {
                        pExtraData->Status |= EXTRA_STATUS_DOING_REFRESH;
                        pExtraData->cCacheID = RemoteChangeID;
                        pExtraData->dwTickCount = GetTickCount();

                        LeaveSplSem();

                        RefreshCompletePrinterCache(pSpool, eDriverDownload);

                        EnterSplSem();

                        SPLASSERT( pExtraData->Status & EXTRA_STATUS_DOING_REFRESH );

                        pExtraData->Status &= ~EXTRA_STATUS_DOING_REFRESH;
                    }
                    else
                    {
                        //
                        // If someone else is doing the refresh we dont need to do it so we bail out.
                        //
                        RefreshNeeded = FALSE;
                    }

                    LeaveSplSem();
                }
                else
                {
                    if ( bGotID )
                    {
                        //
                        // We need to Update the TickCount anyway
                        //
                        pExtraData->dwTickCount = GetTickCount();
                    }
                    //
                    // We either failed the GetPrinterData's or the ChangeID's were
                    // the same. Either way, we don't want to try again.
                    //

                    RefreshNeeded = FALSE;

                } // if gotid

            } // for cRetries < kMaxCacheRefreshAttempts && RefreshNeeded

        } // if newtick > timeout

    } // if SplGetPrinterExtra
    else
    {
        DBGMSG( DBG_WARNING, ("ConsistencyCheckCache SplGetPrinterExtra pSpool %x error %d\n", pSpool, GetLastError() ));
        SPLASSERT( bGetPrinterExtra );
    }

    return hResult;
}


BOOL
RefreshPrinterDriver(
    IN  PWSPOOL             pSpool,
    IN  LPWSTR              pszDriverName,
    IN  EDriverDownload     eDriverDownload
)
{
    LPBYTE pDriverInfo = NULL;
    DWORD  cbDriverInfo = MAX_DRIVER_INFO_VERSION;
    DWORD  cbNeeded, Level, dwLastError = ERROR_SUCCESS;
    BOOL   bReturnValue     = FALSE;
    BOOL   bAttemptDownload = FALSE;
    DWORD  LevelArray[] = { DRIVER_INFO_VERSION_LEVEL, 6 , 4 , 3 , 2 , 1 , -1 };
    DWORD  dwIndex;

    SPLASSERT( pSpool->hIniSpooler != INVALID_HANDLE_VALUE );

try {

    if ( !(pDriverInfo = AllocSplMem(cbDriverInfo)) )
        leave;

    //
    // Only download a driver from the remote server if we are allowed to by
    // policy, or, if the trusted path is set up, in which case we might try.
    //
    bAttemptDownload = eDriverDownload == kDownloadDriver || IsTrustedPathConfigured();

    if (bAttemptDownload) {
        //
        // When the trusted path is configured, we do not try the first level
        // (DRIVER_INFO_VERSION_LEVEL) in the LeveLArray, because the code in
        // DownloadDriverFiles doesnt know how to handle it. DownloadDriverFiles
        // fails and returns error invalid level, if the level is
        // DRIVER_INFO_VERSION_LEVEL. We are saving 2 RPC calls to the remote
        // server by checking ahead if the trusted path is configured and passing
        // the right level.
        //
        for (dwIndex = IsTrustedPathConfigured() ? 1 : 0;
             LevelArray[dwIndex] != -1                              &&
             !(bReturnValue = CopyDriversLocally(pSpool,
                                                 szEnvironment,
                                                 pDriverInfo,
                                                 LevelArray[dwIndex],
                                                 cbDriverInfo,
                                                 &cbNeeded))       &&
             (dwLastError = GetLastError()) == ERROR_INVALID_LEVEL ;
             dwIndex++ );

        Level = LevelArray[dwIndex];

        if ( !bReturnValue && dwLastError == ERROR_INSUFFICIENT_BUFFER ) {

            FreeSplMem( pDriverInfo );

            if ( pDriverInfo = AllocSplMem(cbNeeded) ) {

                cbDriverInfo = cbNeeded;
                bReturnValue = CopyDriversLocally(pSpool,
                                                  szEnvironment,
                                                  pDriverInfo,
                                                  Level,
                                                  cbDriverInfo,
                                                  &cbNeeded);
            }
        }
    }

    //
    // We could be looking at a remote environment that is different from ours
    // and doesn't have a relevant driver installed in my environment (eg no IA64 driver on x86)
    // or my environment didn't exist on the remote machine (e.g. w2K gold for IA64).
    // Try the local install on the driver name that is being used by the remote printer.
    // Only do this if we don't have SERVER_INSTALL_ONLY as the policy.
    //
    dwLastError = GetLastError();

    if( !bReturnValue                        &&
        pszDriverName                        &&
            (dwLastError == ERROR_UNKNOWN_PRINTER_DRIVER ||
             dwLastError == ERROR_INVALID_ENVIRONMENT    ||
             !bAttemptDownload) ) {

        bReturnValue = AddDriverFromLocalCab(pszDriverName, pSpool->hIniSpooler);
    }

 } finally {

    FreeSplMem(pDriverInfo);
 }

    if ( !bReturnValue )
        DBGMSG(DBG_WARNING,
               ("RefreshPrinterDriver Failed SplAddPrinterDriver %d\n",
                GetLastError() ));

    return bReturnValue;
}


BOOL
OpenCachePrinterOnly(
   LPWSTR               pName,
   LPHANDLE             phSplPrinter,
   LPHANDLE             phIniSpooler,
   LPPRINTER_DEFAULTS   pDefault,
   BOOL                 bOpenOnly
)
{
    PWCHAR  pMachineName = NULL;
    PWCHAR  pPrinterName;
    BOOL    ReturnValue = FALSE;
    PWSTR   psz;

    if (!VALIDATE_NAME(pName)) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }


 try {

    //
    //  See if we already known about this server in the cache
    //

    DBGMSG(DBG_TRACE, ("OpenCachePrinterOnly pName %ws \n",pName));

    //
    //  Find the Machine Name
    //

    SPLASSERT ( 0 == _wcsnicmp( pName, L"\\\\", 2 ) ) ;

    pMachineName = AllocSplStr( pName );

    if ( pMachineName == NULL )
        leave;

    //
    // Get Past leading \\ or \\server\printer
    //
    pPrinterName = pMachineName + 2;

    pPrinterName = wcschr( pPrinterName, L'\\' );

    //
    //  If this is a \\ServerName or contains ,XcvPort or ,XcvMonitor then don't bother with Cache
    //
    if ( pPrinterName == NULL ||
         wcsstr(pPrinterName, L",XcvPort") ||
         wcsstr(pPrinterName, L",XcvMonitor")) {

        leave;

    } else {

        psz = wcsstr(pName, L",NoCache");

        if (psz) {
            *psz = L'\0';
            leave;
        }
    }

    *pPrinterName = L'\0';

    DBGMSG(DBG_TRACE,("MachineName %ws pName %ws\n", pMachineName, pName));

    //
    //  Does this Machine Exist in the Cache ?
    //

    *phIniSpooler = CacheCreateSpooler( pMachineName , bOpenOnly);

    if ( *phIniSpooler == INVALID_HANDLE_VALUE ) {
        SPLASSERT( GetLastError( ));
        leave;
    }

    //
    // Try to Open the Cached Printer
    //

    ReturnValue = ( SplOpenPrinter( pName ,
                                    phSplPrinter,
                                    pDefault,
                                    *phIniSpooler,
                                    NULL,
                                    0) == ROUTER_SUCCESS );

 } finally {

    FreeSplStr( pMachineName );

 }

    return  ReturnValue;

}

/*++

Routine Name:

    DoesPolicyAllowPrinterConnectionsToServer

Description:

    Check to see whether policy allows us to connect to the server. The policy
    might allow unrestricted access to point and print, or it might only allow
    us to only point and print within our domain or it might allow us to only
    point and print to a restricted subset of print servers.

Arguments:

    pszQueue                - The queue we are considering allowing point and
                              print on.
    pbAllowPointAndPrint    - If TRUE, we can point and print to the server.

Return Value:

    An HRESULT.

--*/
HRESULT
DoesPolicyAllowPrinterConnectionsToServer(
    IN      PCWSTR              pszQueue,
        OUT BOOL                *pbAllowPointAndPrint
    )
{
    HRESULT hr = pszQueue && pbAllowPointAndPrint ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    BOOL    bAllowPointAndPrint = FALSE;
    HKEY    hKeyUser    = NULL;
    HKEY    hKeyPolicy  = NULL;

    //
    // First, are we on a domain? The policies only apply to domain joined machines.
    //
    if (SUCCEEDED(hr) && gbMachineInDomain)
    {
        DWORD   dwPointAndPrintRestricted       = 0;
        DWORD   dwPointAndPrintInForest         = 1;
        DWORD   dwPointAndPrintTrustedServers   = 0;
        DWORD   Type;
        DWORD   cbData = 0;
        PWSTR   pszServerName = NULL;

        cbData = sizeof(dwPointAndPrintRestricted);

        hr = HResultFromWin32(RegOpenCurrentUser(KEY_READ, &hKeyUser));

        //
        // Next, is the policy on.
        //
        if (SUCCEEDED(hr))
        {
            hr = HResultFromWin32(RegOpenKeyEx(hKeyUser, gszPointAndPrintPolicies, 0, KEY_READ, &hKeyPolicy));
        }

        //
        // Read the value.
        //
        if (SUCCEEDED(hr))
        {
            hr = HResultFromWin32(RegQueryValueEx(hKeyPolicy,
                                                  gszPointAndPrintRestricted,
                                                  NULL,
                                                  &Type,
                                                  (BYTE *)&dwPointAndPrintRestricted,
                                                  &cbData));

            hr = SUCCEEDED(hr) ? (Type == REG_DWORD ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_DATA)) : hr;
        }

        if (SUCCEEDED(hr))
        {
            bAllowPointAndPrint = dwPointAndPrintRestricted == 0;

            if (!bAllowPointAndPrint)
            {
                cbData = sizeof(dwPointAndPrintInForest);

                hr = HResultFromWin32(RegQueryValueEx(hKeyPolicy,
                                                      gszPointAndPrintInForest,
                                                      NULL,
                                                      &Type,
                                                      (BYTE *)(&dwPointAndPrintInForest),
                                                      &cbData));

                hr = SUCCEEDED(hr) ? (Type == REG_DWORD ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_DATA)) : hr;

                if (SUCCEEDED(hr))
                {
                    cbData = sizeof(dwPointAndPrintTrustedServers);

                    hr = HResultFromWin32(RegQueryValueEx(hKeyPolicy,
                                                          gszPointAndPrintTrustedServers,
                                                          NULL,
                                                          &Type,
                                                          (BYTE *)(&dwPointAndPrintTrustedServers),
                                                          &cbData));

                    hr = SUCCEEDED(hr) ? (Type == REG_DWORD ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_DATA)) : hr;
                }
            }
        }
        else
        {
            //
            // If the policy is unconfigured, we only allow point and print to
            // a machine within the forst.
            //
            hr = S_OK;
        }

        if (SUCCEEDED(hr) && !bAllowPointAndPrint)
        {
            hr = CheckUserPrintAdmin(&bAllowPointAndPrint);
        }

        //
        // If we are still not allowed to point and print we need to get the
        // server name from the queue name.
        //
        if (SUCCEEDED(hr) && !bAllowPointAndPrint)
        {
            hr = GetServerNameFromPrinterName(pszQueue, &pszServerName);
        }

        //
        // If the policy suggests checking against a set of trusted servers,
        // then let's try that. We do this first because it is the faster
        // check.
        //
        if (SUCCEEDED(hr) && dwPointAndPrintTrustedServers && !bAllowPointAndPrint)
        {
            hr = IsServerExplicitlyTrusted(hKeyPolicy, pszServerName, &bAllowPointAndPrint);
        }

        if (SUCCEEDED(hr) && dwPointAndPrintInForest && !bAllowPointAndPrint)
        {
            hr = IsServerInSameForest(pszServerName, &bAllowPointAndPrint);
        }

        FreeSplMem(pszServerName);
    }

    if (SUCCEEDED(hr) && !gbMachineInDomain)
    {
        bAllowPointAndPrint = TRUE;
    }

    if (pbAllowPointAndPrint)
    {
        *pbAllowPointAndPrint = bAllowPointAndPrint;
    }

    if (hKeyPolicy)
    {
        RegCloseKey(hKeyPolicy);
    }

    if (hKeyUser)
    {
        RegCloseKey(hKeyUser);
    }

    return hr;
}

/*++

Routine Name:

    IsServerExplicitlyTrusted

Description:

    Returns whether the server is in the semi-colon separated list of explicitely
    trusted servers as read from the policy key. We always use fully qualified
    DNS names for two reasons:

    1. It prevents the admin having to type in all the possible variants that a
       user might type.
    2. It prevents the user getting away with specifying another name that maps
       within their DNS search path.

Arguments:

    hKeyPolicy      -   The key under which the policy is located.
    pszServerName   -   The server name. We fully qualify
    pbServerTrusted -   If TRUE, then the server is trusted.

Return Value:

    An HRESULT.

--*/
HRESULT
IsServerExplicitlyTrusted(
    IN      HKEY                hKeyPolicy,
    IN      PCWSTR              pszServerName,
        OUT BOOL                *pbServerTrusted
    )
{
    HRESULT hr = hKeyPolicy && pszServerName && pbServerTrusted ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    PWSTR   pszServerList = NULL;
    PWSTR   pszFullyQualified = NULL;
    BOOL    bServerTrusted = FALSE;

    //
    // Get the list of servers, if this is empty, then no point and print.
    //
    if (SUCCEEDED(hr))
    {
        hr = SafeRegQueryValueAsStringPointer(hKeyPolicy, gszPointAndPrintServerList, &pszServerList, 0);
    }

    //
    // See if we can get the actual DNS name, this is done through reverse
    // address lookup and is gauranteed to be singular to the machine (of
    // course, the DNS has to have the mapping).
    //
    if (SUCCEEDED(hr))
    {
        hr = GetFullyQualifiedDomainName(pszServerName, &pszFullyQualified);

        //
        // If full reverse lookup failed, just do the best be can with the host
        // name.
        //
        if (hr == HRESULT_FROM_WIN32(WSANO_DATA))
        {
            hr = GetDNSNameFromServerName(pszServerName, &pszFullyQualified);
        }

        //
        // OK, we could not get the fully qualified name, just use whatever
        // name is specified.
        //
        if (FAILED(hr))
        {
            pszFullyQualified = AllocSplStr(pszServerName);

            hr = pszFullyQualified ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        }
    }

    //
    // Run the fully qualified server name against the list in the registry.
    //
    if (SUCCEEDED(hr))
    {
        PWSTR   pszServerStart      = pszServerList;
        PWSTR   pszServerEnd        = NULL;
        SIZE_T  cchFullyQualified   = 0;

        cchFullyQualified = wcslen(pszFullyQualified);

        for(pszServerEnd = wcschr(pszServerStart, L';'); !bServerTrusted;
            pszServerStart = pszServerEnd, pszServerEnd = wcschr(pszServerStart, L';'))
        {
            if (pszServerEnd)
            {
                //
                // Are the names exactly the same? (Case insensitive comparison).
                //
                if (pszServerEnd - pszServerStart == cchFullyQualified)
                {
                    bServerTrusted = !_wcsnicmp(pszFullyQualified, pszServerStart, cchFullyQualified);
                }

                //
                // Skip past the ; to the next server name.
                //
                pszServerEnd++;
            }
            else
            {
                bServerTrusted = !_wcsicmp(pszFullyQualified, pszServerStart);

                break;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        *pbServerTrusted = bServerTrusted;
    }

    FreeSplMem(pszServerList);
    FreeSplMem(pszFullyQualified);

    return hr;
}

/*++

Routine Name:

    IsServerInSameForest

Description:

    This routine determines whether the given server is in the same forest as we
    are.

Arguments:

    pszServerName           -   The server name.
    pbServerInSameForest    -   If TRUE, then the server is in the same forest.

Return Value:

    An HRESULT.

--*/
HRESULT
IsServerInSameForest(
    IN      PCWSTR              pszServerName,
        OUT BOOL                *pbServerInSameForest
    )
{
    WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH + 2];
    DWORD   cchComputerName = COUNTOF(ComputerName);
    PSID    pSid            = NULL;
    PWSTR   pszDomainName   = NULL;
    DWORD   cbSid           = 0;
    DWORD   cchDomainName   = 0;
    PWSTR   pszFullName     = NULL;
    BOOL    bServerInForest = FALSE;
    BOOL    bSameAddress    = FALSE;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    PUSER_INFO_1            pUserInfo1            = NULL;
    SID_NAME_USE            SidType;
    HRESULT hr = pszServerName && pbServerInSameForest ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    //
    // Use the fully qualified DNS name if we can get it. This is to handle
    // dotted notation resolution to the names. If we can't get it, then we
    // just use the passed in name. This requires reverse domain lookup, which
    // might not be available.
    //
    hr = GetFullyQualifiedDomainName(pszServerName, &pszFullName);

    if (SUCCEEDED(hr))
    {
        hr = DnsHostnameToComputerName(pszFullName, ComputerName, &cchComputerName) ? S_OK : GetLastErrorAsHResultAndFail();
    }
    else if (hr == HRESULT_FROM_WIN32(WSANO_DATA))
    {
        hr = DnsHostnameToComputerName(pszServerName, ComputerName, &cchComputerName) ? S_OK : GetLastErrorAsHResultAndFail();
    }

    //
    // Check to see whether the truncated computer name and the server name are
    // the same machine. This is to prevent printserver.hack3rz.org being confused
    // with printserver.mydomain.com.
    //
    if (SUCCEEDED(hr))
    {
        hr = CheckSamePhysicalAddress(pszServerName, ComputerName, &bSameAddress);
    }

    if (SUCCEEDED(hr) && bSameAddress)
    {
        if (SUCCEEDED(hr))
        {
            hr = StringCchCat(ComputerName, COUNTOF(ComputerName), L"$");
        }

        if (SUCCEEDED(hr))
        {
            hr = LookupAccountName(NULL, ComputerName, NULL, &cbSid, NULL, &cchDomainName, &SidType) ? S_OK : GetLastErrorAsHResultAndFail();

            //
            // This should only return ERROR_INSUFFICIENT_BUFFER, any other return
            // or a success is a failure.
            //
            hr = hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) ? S_OK : (SUCCEEDED(hr) ? E_FAIL : hr);
        }

        if (SUCCEEDED(hr))
        {
            pszDomainName = AllocSplMem(cchDomainName * sizeof(WCHAR));
            pSid          = AllocSplMem(cbSid);

            hr = pszDomainName && pSid ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        }

        if (SUCCEEDED(hr))
        {
            hr = LookupAccountName(NULL, ComputerName, pSid, &cbSid, pszDomainName, &cchDomainName, &SidType) ? S_OK : GetLastErrorAsHResultAndFail();
        }

        //
        // COMPUTER$ accounts are returned as user accounts when looked up, we don't
        // want a disabled or inactive account.
        //
        if (SUCCEEDED(hr) && SidType == SidTypeUser)
        {
            //
            // The account must be active. Otherwise I could create a workgroup machine
            // with the same name as an inactive account and fox the system that way.
            //
            hr = HResultFromWin32(DsGetDcName(NULL, pszDomainName, NULL, NULL, DS_IS_FLAT_NAME | DS_RETURN_DNS_NAME, &pDomainControllerInfo));

            if (SUCCEEDED(hr))
            {
                hr = HResultFromWin32(NetUserGetInfo(pDomainControllerInfo->DomainControllerName, ComputerName, 1, (BYTE **)(&pUserInfo1)));
            }

            //
            // The account cannot be locked out or disabled.
            //
            if (SUCCEEDED(hr))
            {
                bServerInForest = !(pUserInfo1->usri1_flags & (UF_LOCKOUT | UF_ACCOUNTDISABLE));
            }
        }
    }

    if (pbServerInSameForest)
    {
        *pbServerInSameForest = bServerInForest;
    }

    if (pUserInfo1)
    {
        NetApiBufferFree(pUserInfo1);
    }

    if (pDomainControllerInfo)
    {
        NetApiBufferFree(pDomainControllerInfo);
    }

    FreeSplMem(pszDomainName);
    FreeSplMem(pSid);
    FreeSplMem(pszFullName);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\sources.inc ===
NTPROFILEINPUT=yes

TARGETNAME=win32spl
TARGETPATH=obj
TARGETTYPE=DYNLINK

TARGETLIBS = \
           $(PROJECT_ROOT)\lib\$(O)\spoolss.lib \
           $(PROJECT_ROOT)\lib\$(O)\localspl.lib \
           $(SDK_LIB_PATH)\rpcrt4.lib   \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\rxapi.lib \
           $(SDK_LIB_PATH)\rxcommon.lib \
           $(SDK_LIB_PATH)\netrap.lib \
           $(SDK_LIB_PATH)\netlib.lib \
           $(SDK_LIB_PATH)\ws2_32.lib \
           $(DS_LIB_PATH)\netapi32p.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(PROJECT_ROOT)\lib\$(O)\spllib.lib

DLLENTRY=_DllMainCRTStartup
DLLDEF=..\$(TARGETNAME).def
DLLORDER=..\$(TARGETNAME).prf

INCLUDES=..\;..\..;                     \
         ..\..\..\inc;                  \
         ..\..\..\inc\$(O);             \
         ..\..\idl;                     \
         ..\..\idl\$(O);                \
         ..\..\..\..\..\inc;            \
         ..\..\..\..\inc;               \
         $(OAK_INC_PATH);               \
         $(PRINTSCAN_INC_PATH);         \
         $(WINDOWS_INC_PATH);           \
         $(SHELL_INC_PATH);             \
         $(DS_INC_PATH);                \
         $(NET_INC_PATH);

USE_MSVCRT=1

SOURCES=..\winsplc.c ..\pool.cxx ..\TPmgr.cxx ..\win32.c ..\trueconn.c ..\files.c \
        ..\bind.c ..\midluser.c ..\data.c ..\prnfile.c \
        ..\win32spl.rc ..\lmprn.c ..\util.c ..\lmjob.c ..\lmspl.c ..\port.c ..\change.c \
        ..\cache.c ..\cachemon.c 

UMTEST=
UMTYPE=console

UMLIBS=$(O)\win32spl.lib
UMRES=$(O)\win32spl.res

C_DEFINES=-DRPC_NO_WINDOWS_H -DUNICODE -DNO_STRICT -DSPOOLKM -D_HYDRA_

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\tpmgr.cxx ===
/*++

Copyright (c) 1990-2002  Microsoft Corporation

Module Name:

    TPmgr.hxx

Abstract:

    Declaration of functions used for initializing and using the Thread Pool.

Author:

    Ali Naqvi (alinaqvi) 3-May-2002

Revision History:

--*/

#include "precomp.h"
#include "pool.hxx"
#include "TPmgr.hxx"

TThreadPool *g_pThreadPool = NULL;

HRESULT
InitOpnPrnThreadPool(
    VOID
    )
{
    HRESULT hResult = E_FAIL;

    g_pThreadPool = new TThreadPool();

    hResult = g_pThreadPool ? S_OK : E_OUTOFMEMORY;

    return hResult;
}

VOID
DeleteOpnPrnThreadPool(
    VOID
    )
{
    delete g_pThreadPool;
}


/*++

Name:

    BindThreadToHandle

Description:

    This takes a handle and binds a background thread to it. This thread can 
    either come from the pool of threads currently wedged against a server, or
    if none in the pool satisfy, the tread will be created.

Arguments:

    pSpool      -   The forground handle that we will be binding the thread to.

Return Value:

    HRESULT

--*/
HRESULT
BindThreadToHandle(
    IN      PWSPOOL             pSpool
    )
{
    HRESULT hResult = pSpool ? S_OK : E_INVALIDARG;
    HANDLE  hThread = NULL;
    DWORD   IDThread;


    //
    // This must be called from inside the win32spl CS.
    // 
    SplInSem();

    if (SUCCEEDED(hResult))
    {
        //
        // First just try and pick up a thread that is currently wedged against
        // a slow server.
        // 
        hResult = g_pThreadPool->UseThread(pSpool->pName, &(pSpool->pThread), pSpool->PrinterDefaults.DesiredAccess);
    }

    if (hResult == S_FALSE)
    {
        hResult = g_pThreadPool->CreateThreadEntry(pSpool->pName, &(pSpool->PrinterDefaults), &(pSpool->pThread));

        if (SUCCEEDED(hResult))
        {
            IncThreadCount();

            hThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)RemoteOpenPrinterThread, pSpool->pThread, 0, &IDThread );

            hResult = hThread ? S_OK : HRESULT_FROM_WIN32(GetLastError());
        }
    }
 
    if (SUCCEEDED(hResult)) 
    {
        //
        // We are an asynchronous thread and we have a foreground handle.
        // 
        pSpool->Status |= WSPOOL_STATUS_ASYNC;
        pSpool->pThread->bForegroundClose = TRUE;
    }
    else 
    {
        if (pSpool && pSpool->pThread)
        {
            g_pThreadPool->DeleteThreadEntry(pSpool->pThread);
            pSpool->pThread = NULL;
            DecThreadCount();
        }
    }

    if (hThread)
    {
        CloseHandle( hThread );
    }

    return hResult;
}

/*++

Name:

    ReturnThreadFromHandle

Description:

    This gets a handle and returns the thread to the pool if it is still running.
    If it is not running, (The thread status will indicate this), then we close the 
    RpcHandle ourselves. We clear the foreground handle from the thread. This is a 
    signal to it that it must close the RPC handle when it terminates.

Arguments:

    pSpool      -   The forground handle that we are detaching the thread from.

Return Value:

    HRESULT

--*/
HRESULT 
ReturnThreadFromHandle(
    IN      PWSPOOL             pSpool
    )
{
    HRESULT hResult = pSpool ? S_OK : E_INVALIDARG;
    BOOL    bCloseRemote = FALSE;

    SplOutSem();

    if (SUCCEEDED(hResult) && (pSpool->Status & WSPOOL_STATUS_ASYNC))
    {
        EnterSplSem();

        //
        // Let the background thread know that it needs to close, if it is running.
        //
        pSpool->pThread->bForegroundClose = FALSE;

        //
        // If the thread terminated in the meanwhile, we should close the RPC
        // handle in this thread.
        //
        if (pSpool->pThread->dwStatus == THREAD_STATUS_TERMINATED)
        {
            
            bCloseRemote = TRUE;

            //
            // If the thread actually terminated, either we have a valid RPC handle
            // or the handle is signalled that OpenPrinter failed.
            // 
            pSpool->RpcHandle = pSpool->pThread->hRpcHandle;
            pSpool->Status &= ~WSPOOL_STATUS_NO_RPC_HANDLE;

            //
            // We just need to free the thread object since we know we are not returning it.
            // 
            g_pThreadPool->FreeThread(pSpool->pThread);        

            //
            // Don't need to see bForegroundClose because the thread 
            // 
        }        
        else
        {
            //
            // If there was an error in this thread then we don't want to 
            // return it to the pool.
            // 
            if (pSpool->pThread->dwRpcOpenPrinterError != ERROR_SUCCESS)
            {
                //
                // If there was an OpenPrinter error, there should not be an RPC handle,
                // So, neither thread actually needs to close the RPC handle.
                // 
                SPLASSERT(pSpool->pThread->hRpcHandle == NULL);

                //
                // We know that the background thread is running and we know 
                // that it doesn't need to close the handle. But it will delete
                // the thread entry. We don't put the thread back on the list because
                // we know that it is broken.
                // 
            }
            else
            {
                //
                // The thread hasn't terminated yet, so we should return it to the thread pool.
                // 
                g_pThreadPool->ReturnThread(pSpool->pThread);                
            }

            //
            // We don't need to close, but we also shoudn't use the RPC handle.
            // And if the foreground thread has picked it up then we want to
            // make sure that it is cleared or we will assert when we close the
            // handle.
            // 
            pSpool->RpcHandle = NULL;
            pSpool->Status |=  WSPOOL_STATUS_NO_RPC_HANDLE;

        }

        pSpool->pThread = NULL;

        LeaveSplSem();
    }

    SplOutSem();

    if (bCloseRemote && pSpool->RpcHandle)
    {
        hResult = RemoteClosePrinter((HANDLE)pSpool) ? S_OK : GetLastErrorAsHResultAndFail();
    }

    return hResult;
}

/*++

Name:

    BackgroundThreadFinished

Description:

    This is called when the background thread is finished. If we are no longer 
    linked with a foreground handle, we know we have to close the rpc handle. We
    mark the thread as terminated to prevent ourselves being put back on the 
    active list by the foreground thread.

Arguments:

    pThread             -   The thread that is finished
    pBackgroundHandle   -   The background handle that we might have to close.

Return Value:

    HRESULT

--*/
HRESULT
BackgroundThreadFinished(
    IN  OUT PWIN32THREAD        *ppThread,
    IN  OUT PWSPOOL             pBackgroundHandle
    )
{
    HRESULT hr = ppThread && *ppThread ? S_OK : E_INVALIDARG;

    SplInSem();

    if (SUCCEEDED(hr))
    {
        PWIN32THREAD        pThread = *ppThread;

        //
        // If we still have a forground handle, then NULL our RPC handle 
        // so that we won't close the handle ourselves and instead leave it
        // up to the foreground thread.
        // 
        pThread->dwStatus = THREAD_STATUS_TERMINATED;

        if (pThread->bForegroundClose)
        {
            if (pBackgroundHandle)
            {
                pBackgroundHandle->RpcHandle = NULL;
            }
        }
        else
        {
            //
            // We must also delete ourselves from the pool.
            //
            g_pThreadPool->DeleteThreadEntry(pThread);
        }

        *ppThread = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\trueconn.c ===
/*++


Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    trueconn.c

Abstract:

    This module contains routines for copying drivers from the Server to the
    Workstation for Point and Print or "True Connections."

Author:

    Krishna Ganugapati (Krishna Ganugapati) 21-Apr-1994

Revision History:
    21-Apr-1994 - Created.

    21-Apr-1994 - There are actually two code modules in this file. Both deal
                  with true connections

    27-Oct-1994 - Matthew Felton (mattfe) rewrite updatefile routine to allow
                  non power users to point and print, for caching.   Removed
                  old Caching code.

    23-Feb-1995 - Matthew Felton (mattfe) removed more code by allowing spladdprinterdriver
                  to do all file copying.

    24-Mar-1999 - Felix Maxa (AMaxa) AddPrinterDriver key must be read from the old location
                  of the Servers key in System hive

    19-Oct-2000 - Steve Kiraly (SteveKi) Read the AddPrinterDrivers key every time, group
                  policy modifies this key while the spooler is running, we don't want require
                  the customer to restart the spooler when this policy changes.
--*/

#include "precomp.h"

DWORD dwLoadTrustedDrivers = 0;
WCHAR TrustedDriverPath[MAX_PATH];
DWORD dwSyncOpenPrinter = 0;

BOOL
ReadImpersonateOnCreate(
    VOID
    )
{
    BOOL            bImpersonateOnCreate    = FALSE;
    HKEY            hKey                    = NULL;
    NT_PRODUCT_TYPE NtProductType           = {0};
    DWORD           dwRetval                = ERROR_SUCCESS;
    DWORD           cbData                  = sizeof(bImpersonateOnCreate);
    DWORD           dwType                  = REG_DWORD;

    //
    // Open the providers registry key
    //
    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            szOldLocationOfServersKey,
                            0,
                            KEY_READ, &hKey);

    if (dwRetval == ERROR_SUCCESS)
    {
        //
        // Attempt to read the AddPrinterDrivers policy.
        //
        dwRetval = RegQueryValueEx(hKey,
                                   L"AddPrinterDrivers",
                                   NULL,
                                   &dwType,
                                   (LPBYTE)&bImpersonateOnCreate,
                                   &cbData);
    }

    //
    // If we did not read the AddPrinterDrivers policy then set the default
    // based on the product type.
    //
    if (dwRetval != ERROR_SUCCESS)
    {
        bImpersonateOnCreate = FALSE;

        // Server Default       Always Impersonate on AddPrinterConnection
        // WorkStation Default  Do Not Impersonate on AddPrinterConnection

        if (RtlGetNtProductType(&NtProductType))
        {
            if (NtProductType != NtProductWinNt)
            {
                bImpersonateOnCreate = TRUE;
            }
        }
    }

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return bImpersonateOnCreate;
}

BOOL
CopyDriversLocally(
    PWSPOOL  pSpool,
    LPWSTR  pEnvironment,
    LPBYTE  pDriverInfo,
    DWORD   dwLevel,
    DWORD   cbDriverInfo,
    LPDWORD pcbNeeded)
{
    DWORD  ReturnValue=FALSE;
    DWORD  RpcError;
    DWORD  dwServerMajorVersion = 0;
    DWORD  dwServerMinorVersion = 0;
    BOOL   DaytonaServer = TRUE;
    BOOL   bReturn = FALSE;


    if (pSpool->Type != SJ_WIN32HANDLE) {

        SetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    //
    // Test RPC call to determine if we're talking to Daytona or Product 1
    //

    SYNCRPCHANDLE( pSpool );

    RpcTryExcept {

        ReturnValue = RpcGetPrinterDriver2(pSpool->RpcHandle,
                                           pEnvironment, dwLevel,
                                           pDriverInfo,
                                           cbDriverInfo,
                                           pcbNeeded,
                                           cThisMajorVersion,
                                           cThisMinorVersion,
                                           &dwServerMajorVersion,
                                           &dwServerMinorVersion);
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        RpcError = RpcExceptionCode();
        ReturnValue = RpcError;

        if (RpcError == RPC_S_PROCNUM_OUT_OF_RANGE) {

            //
            // Product 1 server
            //
            DaytonaServer = FALSE;
        }

    } RpcEndExcept

    if ( DaytonaServer ) {

        if (ReturnValue) {

            SetLastError(ReturnValue);
            goto FreeDone;
        }

    } else {

        RpcTryExcept {

            //
            // I am talking to a Product 1.0/511/528
            //

                        ReturnValue = RpcGetPrinterDriver( pSpool->RpcHandle,
                                               pEnvironment,
                                               dwLevel,
                                               pDriverInfo,
                                               cbDriverInfo,
                                               pcbNeeded );
        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            RpcError = RpcExceptionCode();

        } RpcEndExcept

        if (ReturnValue) {

            SetLastError(ReturnValue);
            goto FreeDone;
        }
    }

    switch (dwLevel) {

        case 2:
            bReturn = MarshallUpStructure(pDriverInfo, DriverInfo2Fields, sizeof(DRIVER_INFO_2), RPC_CALL);
            break;

        case 3:
            bReturn = MarshallUpStructure(pDriverInfo, DriverInfo3Fields, sizeof(DRIVER_INFO_3), RPC_CALL);
            break;

        case 4:
            bReturn = MarshallUpStructure(pDriverInfo, DriverInfo4Fields, sizeof(DRIVER_INFO_4), RPC_CALL);
             break;

        case 6:
            bReturn = MarshallUpStructure(pDriverInfo, DriverInfo6Fields, sizeof(DRIVER_INFO_6), RPC_CALL);
            break;

        case DRIVER_INFO_VERSION_LEVEL:
            bReturn = MarshallUpStructure(pDriverInfo, DriverInfoVersionFields, sizeof(DRIVER_INFO_VERSION), RPC_CALL);
            break;

        default:
            DBGMSG(DBG_ERROR,
                   ("CopyDriversLocally: Invalid level %d", dwLevel));

            SetLastError(ERROR_INVALID_LEVEL);
            bReturn =  FALSE;
            goto FreeDone;
    }

    if (bReturn)
    {
        bReturn = DownloadDriverFiles(pSpool, pDriverInfo, dwLevel);
    }

FreeDone:
    return bReturn;
}


BOOL
ConvertDependentFilesToTrustedPath(
    LPWSTR *pNewDependentFiles,
    LPWSTR  pOldDependentFiles,
    DWORD   dwVersion)
{
    //
    // Assuming version is single digit
    // we need space for \ and the version digit
    //
    DWORD   dwVersionPathLen = wcslen(TrustedDriverPath) + 2;

    DWORD   dwFilenameLen, cchSize;
    LPWSTR  pStr1, pStr2, pStr3;

    if ( !pOldDependentFiles || !*pOldDependentFiles ) {

        *pNewDependentFiles = NULL;
        return TRUE;
    }

    pStr1 = pOldDependentFiles;
    cchSize = 0;

    while ( *pStr1 ) {

        pStr2              = wcsrchr( pStr1, L'\\' );
        dwFilenameLen      = wcslen(pStr2) + 1;
        cchSize           += dwVersionPathLen + dwFilenameLen;
        pStr1              = pStr2 + dwFilenameLen;
    }

    // For the last \0
    ++cchSize;

    *pNewDependentFiles = AllocSplMem(cchSize*sizeof(WCHAR));

    if ( !*pNewDependentFiles ) {

        return FALSE;
    }

    pStr1 = pOldDependentFiles;
    pStr3 = *pNewDependentFiles;

    while ( *pStr1 ) {

        pStr2              = wcsrchr( pStr1, L'\\' );
        dwFilenameLen      = wcslen(pStr2) + 1;

        StringCchPrintf( pStr3, cchSize, L"%ws\\%d%ws", TrustedDriverPath, dwVersion, pStr2 );

        pStr1  = pStr2 + dwFilenameLen;
        pStr3 += dwVersionPathLen + dwFilenameLen;
        cchSize -= dwVersionPathLen + dwFilenameLen;
    }


    *pStr3 = '\0';
    return TRUE;
}


LPWSTR
ConvertToTrustedPath(
    PWCHAR  pScratchBuffer,
    DWORD   cchScratchBuffer,
    LPWSTR  pDriverPath,
    DWORD   cVersion

)
{
    PWSTR  pData;
    SPLASSERT( pScratchBuffer != NULL && pDriverPath != NULL );

    pData = wcsrchr( pDriverPath, L'\\' );

    StringCchPrintf( pScratchBuffer, cchScratchBuffer, L"%ws\\%d%ws", TrustedDriverPath, cVersion, pData );

    return ( AllocSplStr( pScratchBuffer ) );
}

//
// GetPolicy()
//
// We are hard coding the policy to try the server first and then
// to try the inf install if this installation failed.
//
// This function may be used in the future to leverage different policies.
//
DWORD
GetPolicy()
{
    return (SERVER_INF_INSTALL);
}


//
// If there is a language monitor associated with the driver and it is
// not installed on this machine NULL the pMonitorName field.
// We do not want to download the monitor from thr server since there 
// is no version associated with them
//
BOOL
NullMonitorName (
    LPBYTE  pDriverInfo,
    DWORD   dwLevel
    )
{
    LPWSTR  *ppMonitorName = NULL;
    BOOL    bReturn = FALSE;

    switch (dwLevel) {
        case 3:
        case 4:
        case 6:
        {
            ppMonitorName = &((LPDRIVER_INFO_6)pDriverInfo)->pMonitorName;
            break;
        }
        case DRIVER_INFO_VERSION_LEVEL:
        {
            ppMonitorName = &((LPDRIVER_INFO_VERSION)pDriverInfo)->pMonitorName;
            break;
        }
        default:
        {
            break;
        }
    }

    if (ppMonitorName && *ppMonitorName && **ppMonitorName  &&
        !SplMonitorIsInstalled(*ppMonitorName))
    {
        *ppMonitorName = NULL;
        bReturn = TRUE;
    }

    return bReturn;
}

BOOL
DownloadDriverFiles(
    PWSPOOL pSpool,
    LPBYTE  pDriverInfo,
    DWORD   dwLevel
)
{
    PWCHAR  pScratchBuffer  = NULL;
    BOOL    bReturnValue    = FALSE;
    LPBYTE  pTempDriverInfo = NULL;
    DWORD   dwVersion;
    DWORD   dwInstallPolicy = GetPolicy();
    LPDRIVER_INFO_6 pTempDriverInfo6, pDriverInfo6;

    //
    // If there is a language monitor associated with the driver and it is
    // not installed on this machine NULL the pMonitorName field.
    // We do not want to pull down the monitor since there is no version
    // associated with them
    //
    NullMonitorName(pDriverInfo, dwLevel);

    //
    // If LoadTrustedDrivers is FALSE
    // then we don't care, we load the files from
    // server itself because he has the files
    //

    if ( !IsTrustedPathConfigured() ) {
        //
        //  At this point dwInstallPolicy will always be SERVER_INF_INSTALL
        //  as this is hardcoded in the GetPolicy() call.
        //  This will always be executed in the current GetPolicy() implementation.
        //
        //  If this is only a server install or we're doing a server install first.
        //
        if( dwInstallPolicy & SERVER_INSTALL_ONLY || dwInstallPolicy & SERVER_INF_INSTALL )
        {
            //
            // SplAddPrinterDriverEx will do the copying of the Driver files if the
            // date and time are newer than the drivers it already has
            //
            bReturnValue =  SplAddPrinterDriverEx( NULL,
                                                   dwLevel,
                                                   pDriverInfo,
                                                   APD_COPY_NEW_FILES | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT,
                                                   pSpool->hIniSpooler,
                                                   DO_NOT_USE_SCRATCH_DIR,
                                                   ReadImpersonateOnCreate() );            
        }

        //
        //  dwInstallPolicy will be SERVER_INF_INSTALL at this point due to the
        //  current implementation of GetPolicy().  The below code will only be
        //  executed if the SplAddPrinterDriverEx calls above failed.
        //
        //  Do this only if we haven't tried a previous install or the previous attempt failed.
        //  Policy:  If this is an INF install only,
        //           or we're doing and INF install first,
        //           or the INF install is happening after the server install.
        //
        if( !bReturnValue && (ERROR_PRINTER_DRIVER_BLOCKED != GetLastError()) && !(dwInstallPolicy & SERVER_INSTALL_ONLY) )
        {
            LPDRIVER_INFO_2 pDriverInfo2 = (LPDRIVER_INFO_2)pDriverInfo;
            LPDRIVER_INFO_1 pDriverInfo1 = (LPDRIVER_INFO_1)pDriverInfo;

            //
            // Assume if info2 is valid, info1 is too.
            //
            if( pDriverInfo2 ) {
                //
                // Paranoid code.  We should never receive a call with a level
                // one, but if we did, the driver info struct for level 1 is
                // different to that in a level 2, so we could AV if we don't
                // do this.
                //
                bReturnValue = AddDriverFromLocalCab( dwLevel == 1 ? pDriverInfo1->pName : pDriverInfo2->pName,
                                                      pSpool->hIniSpooler );
            }
            else if( dwInstallPolicy & INF_INSTALL_ONLY )
            {
                //
                //  If this isn't an inf only install, then we should not overwrite the
                //  last error that will occur with AddPrinterDriver calls.
                //  If this is an inf install only, pDriverInfo2 was NULL
                //  so we need to set some last error for this install.
                //
                SetLastError( ERROR_INVALID_PARAMETER );
            }
        }

        //
        //  Due to the current implemenation of GetPolicy() the below section
        //  of code will never be executed.  If the GetPolicy() call changes from
        //  being hardcoded into something actually policy driven, then could be used.
        //
        //  If the inf install is followed by a server install.
        //  Do this only if the previous install has failed.
        //
        if( !bReturnValue && dwInstallPolicy & INF_SERVER_INSTALL )
        {
            //
            // SplAddPrinterDriverEx will do the copying of the Driver files if the
            // date and time are newer than the drivers it already has
            //
            bReturnValue =  SplAddPrinterDriverEx( NULL,
                                                   dwLevel,
                                                   pDriverInfo,
                                                   APD_COPY_NEW_FILES | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT,
                                                   pSpool->hIniSpooler,
                                                   DO_NOT_USE_SCRATCH_DIR,
                                                   ReadImpersonateOnCreate() );            
        }

        return bReturnValue;
    }

    //
    // check if we have a valid path to retrieve the files from
    //
    if ( !TrustedDriverPath || !*TrustedDriverPath ) {

        DBGMSG( DBG_WARNING, ( "DownloadDriverFiles Bad Trusted Driver Path\n" ));
        SetLastError( ERROR_FILE_NOT_FOUND );
        return(FALSE);
    }

    DBGMSG( DBG_TRACE, ( "Retrieving Files from Trusted Driver Path\n" ) );
    DBGMSG( DBG_TRACE, ( "Trusted Driver Path is %ws\n", TrustedDriverPath ) );

    //
    // In the code below the if statement we make the assumption that the caller 
    // passed in a pointer to a DRIVER_INFO_6 structure or to a DRIVER_INFO_6 
    // compatible structure, we need to check the level 
    //
    if (dwLevel == DRIVER_INFO_VERSION_LEVEL) 
    {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

 try {

    pScratchBuffer = AllocSplMem( MAX_PATH );
    if ( pScratchBuffer == NULL )
        leave;

    pDriverInfo6   = (LPDRIVER_INFO_6) pDriverInfo;
    pTempDriverInfo = AllocSplMem(sizeof(DRIVER_INFO_6));

    if ( pTempDriverInfo == NULL )
        leave;

    pTempDriverInfo6 = (LPDRIVER_INFO_6) pTempDriverInfo;

    pTempDriverInfo6->cVersion     = pDriverInfo6->cVersion;
    pTempDriverInfo6->pName        = pDriverInfo6->pName;
    pTempDriverInfo6->pEnvironment = pDriverInfo6->pEnvironment;

    pTempDriverInfo6->pDriverPath = ConvertToTrustedPath(pScratchBuffer,
                                                         MAX_PATH,
                                                         pDriverInfo6->pDriverPath,
                                                         pDriverInfo6->cVersion);

    pTempDriverInfo6->pConfigFile = ConvertToTrustedPath(pScratchBuffer,
                                                         MAX_PATH,
                                                         pDriverInfo6->pConfigFile,
                                                         pDriverInfo6->cVersion);

    pTempDriverInfo6->pDataFile = ConvertToTrustedPath(pScratchBuffer,
                                                       MAX_PATH,
                                                       pDriverInfo6->pDataFile,
                                                       pDriverInfo6->cVersion);


    if ( pTempDriverInfo6->pDataFile == NULL        ||
         pTempDriverInfo6->pDriverPath == NULL      ||
         pTempDriverInfo6->pConfigFile == NULL  ) {

        leave;
    }

    if ( dwLevel == 2 )
        goto Call;

    pTempDriverInfo6->pMonitorName      = pDriverInfo6->pMonitorName;
    pTempDriverInfo6->pDefaultDataType  = pDriverInfo6->pDefaultDataType;

    if ( pDriverInfo6->pHelpFile && *pDriverInfo6->pHelpFile ) {

        pTempDriverInfo6->pHelpFile = ConvertToTrustedPath(pScratchBuffer,
                                                           MAX_PATH,
                                                           pDriverInfo6->pHelpFile,
                                                           pDriverInfo6->cVersion);

        if ( !pTempDriverInfo6->pHelpFile )
            leave;
    }

    if ( !ConvertDependentFilesToTrustedPath(&pTempDriverInfo6->pDependentFiles,
                                             pDriverInfo6->pDependentFiles,
                                             pDriverInfo6->cVersion) )
        leave;

    if ( dwLevel == 3 )
        goto Call;

    SPLASSERT(dwLevel == 4 || dwLevel == 6);

    pTempDriverInfo6->pszzPreviousNames = pDriverInfo6->pszzPreviousNames;

Call:
    //
    //  At this point dwInstallPolicy will always be SERVER_INF_INSTALL
    //  as this is hardcoded in the GetPolicy() call.
    //  This will always be executed in the current GetPolicy() implementation
    //
    //  If this is only a server install or we're doing a server install first.
    //
    if( dwInstallPolicy & SERVER_INSTALL_ONLY || dwInstallPolicy & SERVER_INF_INSTALL )
    {
        //
        // SplAddPrinterDriverEx will do the copying of the Driver files if the
        // date and time are newer than the drivers it already has
        //
        bReturnValue =  SplAddPrinterDriverEx( NULL,
                                               dwLevel,
                                               pTempDriverInfo,
                                               APD_COPY_NEW_FILES | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT,
                                               pSpool->hIniSpooler,
                                               DO_NOT_USE_SCRATCH_DIR,
                                               ReadImpersonateOnCreate() );        
    }

    //
    //  dwInstallPolicy will be SERVER_INF_INSTALL at this point due to the
    //  current implementation of GetPolicy().  The below code will only be
    //  executed if the SplAddPrinterDriverEx calls above failed.
    //
    //  Do this only if we haven't tried a previous install or the previous attempt failed.
    //  Policy:  If this is an INF install only,
    //           or we're doing and INF install first,
    //           or the INF install is happening after the server install.
    //
    if( !bReturnValue && (ERROR_PRINTER_DRIVER_BLOCKED != GetLastError()) && !(dwInstallPolicy & SERVER_INSTALL_ONLY) ) {

        LPDRIVER_INFO_2 pDriverInfo2 = (LPDRIVER_INFO_2)pDriverInfo;
        LPDRIVER_INFO_1 pDriverInfo1 = (LPDRIVER_INFO_1)pDriverInfo;

        //
        // Set up the info structures first... (assume if info2 is valid, info1 is too)
        //
        if( pDriverInfo2 ) {
            //
            // Paranoid code.  We should never receive a call with a level
            // one, but if we did, the driver info struct for level 1 is
            // different to that in a level 2, so we could AV if we don't
            // treat them differently.
            //
            bReturnValue = AddDriverFromLocalCab( dwLevel == 1 ? pDriverInfo1->pName : pDriverInfo2->pName,
                                                  pSpool->hIniSpooler );
        }
        else if( dwInstallPolicy & INF_INSTALL_ONLY ) {
            //
            //  If this isn't an inf only install, then we should not overwrite the
            //  last error that will occur with AddPrinterDriver calls.
            //  If this install was only an inf install, pDriverInfo2 was NULL
            //  so we need to set some last error for this install.
            //
            SetLastError( ERROR_INVALID_PARAMETER );
        }
    }

    //
    //  Due to the current implemenation of GetPolicy() the below section
    //  of code will never be executed.  If the GetPolicy() call changes from
    //  being hardcoded into something actually policy driven, then could be used.
    //
    //  If the inf install is followed by a server install.
    //  Do this only if the previous install has failed.
    //
    if( !bReturnValue && dwInstallPolicy & INF_SERVER_INSTALL )
    {
        //
        // SplAddPrinterDriverEx will do the copying of the Driver files if the
        // date and time are newer than the drivers it already has
        //
        bReturnValue =  SplAddPrinterDriverEx( NULL,
                                               dwLevel,
                                               pTempDriverInfo,
                                               APD_COPY_NEW_FILES | APD_INSTALL_WARNED_DRIVER | APD_RETURN_BLOCKING_STATUS_CODE | APD_DONT_SET_CHECKPOINT,
                                               pSpool->hIniSpooler,
                                               DO_NOT_USE_SCRATCH_DIR,
                                               ReadImpersonateOnCreate() );        
    }

 } finally {

    FreeSplMem( pScratchBuffer );

    if ( pTempDriverInfo != NULL ) {

        FreeSplStr(pTempDriverInfo6->pDriverPath);
        FreeSplStr(pTempDriverInfo6->pConfigFile);
        FreeSplStr(pTempDriverInfo6->pDataFile);
        FreeSplStr(pTempDriverInfo6->pDependentFiles);

        FreeSplMem(pTempDriverInfo);
    }

 }

    return bReturnValue;

}




VOID
QueryTrustedDriverInformation(
    VOID
    )
{
    DWORD dwRet;
    DWORD cbData;
    DWORD dwType = 0;
    HKEY hKey;

    //
    // There was a migration of printer connections cache from System
    // to sftware. The Servers key and the AddPrinterDrivers values
    // remain at the old location, though.
    //
    dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOldLocationOfServersKey,
                                0, KEY_READ, &hKey);
    if (dwRet != ERROR_SUCCESS) {
        return;
    }

    cbData = sizeof(DWORD);
    dwRet = RegQueryValueEx(hKey, L"LoadTrustedDrivers", NULL, &dwType, (LPBYTE)&dwLoadTrustedDrivers, &cbData);

    if (dwRet != ERROR_SUCCESS) {
        dwLoadTrustedDrivers = 0;
    }

    //
    //  By Default we don't wait for the RemoteOpenPrinter to succeed if we have a cache ( Connection )
    //  Users might want to have Syncronous opens
    //
    cbData = sizeof(DWORD);
    dwRet = RegQueryValueEx(hKey, L"SyncOpenPrinter", NULL, &dwType, (LPBYTE)&dwSyncOpenPrinter, &cbData);

    if (dwRet != ERROR_SUCCESS) {
        dwSyncOpenPrinter = 0;
    }

    //
    // if  !dwLoadedTrustedDrivers then just return
    // we won't be using the driver path at all
    //
    if (!dwLoadTrustedDrivers) {
        DBGMSG(DBG_TRACE, ("dwLoadTrustedDrivers is %d\n", dwLoadTrustedDrivers));
        RegCloseKey(hKey);
        return;
    }

    cbData = sizeof(TrustedDriverPath);
    dwRet = RegQueryValueEx(hKey, L"TrustedDriverPath", NULL, &dwType, (LPBYTE)TrustedDriverPath, &cbData);
    if (dwRet != ERROR_SUCCESS) {
      dwLoadTrustedDrivers = 0;
      DBGMSG(DBG_TRACE, ("dwLoadTrustedDrivers is %d\n", dwLoadTrustedDrivers));
      RegCloseKey(hKey);
      return;
    }
    DBGMSG(DBG_TRACE, ("dwLoadTrustedDrivers is %d\n", dwLoadTrustedDrivers));
    DBGMSG(DBG_TRACE, ("TrustedPath is %ws\n", TrustedDriverPath));
    RegCloseKey(hKey);
    return;
}

BOOL
IsTrustedPathConfigured(
    IN VOID
    )
{
    return !!dwLoadTrustedDrivers; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\util.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module provides all the utility functions for the Routing Layer and
    the local Print Providor

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

MODULE_DEBUG_INIT( DBG_ERROR, DBG_ERROR );

// used to break infinite loop in ConvertDevMode
const WCHAR pszCnvrtdmToken[] = L",DEVMODE";
const WCHAR pszDrvConvert[] = L",DrvConvert";

DWORD
Win32IsOlderThan(
    DWORD i,
    DWORD j
    );


VOID
SplInSem(
   VOID
)
{
    if (SpoolerSection.OwningThread != (HANDLE) ULongToPtr(GetCurrentThreadId())) {
        DBGMSG(DBG_ERROR, ("Not in spooler semaphore\n"));
    }
}

VOID
SplOutSem(
   VOID
)
{
    if (SpoolerSection.OwningThread == (HANDLE) ULongToPtr(GetCurrentThreadId())) {
        DBGMSG(DBG_ERROR, ("Inside spooler semaphore !!\n"));
    }
}

VOID
EnterSplSem(
   VOID
)
{
    EnterCriticalSection(&SpoolerSection);
}

VOID
LeaveSplSem(
   VOID
)
{
    SplInSem();
    LeaveCriticalSection(&SpoolerSection);
}


PWINIPORT
FindPort(
   LPWSTR pName,
   PWINIPORT pFirstPort
)
{
   PWINIPORT pIniPort;

   pIniPort = pFirstPort;

   if (pName) {
      while (pIniPort) {

         if (!lstrcmpi( pIniPort->pName, pName )) {
            return pIniPort;
         }

      pIniPort=pIniPort->pNext;
      }
   }

   return FALSE;
}


BOOL
MyName(
    LPWSTR   pName
)
{
    if (!pName || !*pName)
        return TRUE;

    if (*pName == L'\\' && *(pName+1) == L'\\')
        if (!lstrcmpi(pName, szMachineName))
            return TRUE;

    return FALSE;
}

BOOL
MyUNCName(
    PWSTR pName
)
{
    BOOL bRet = VALIDATE_NAME(pName);

    if (bRet && !MyName(pName))
    {
        WCHAR *pcMark;

        pcMark = wcschr(pName + 2, L'\\');

        DBGMSG(DBG_TRACE, ("WIN32SPL MyUNCName input pName %ws\n", pName));

        if (pcMark)
        {
            *pcMark = 0;
        }

        bRet = CacheIsNameInNodeList(szMachineName + 2, pName + 2) == S_OK;

        DBGMSG(DBG_TRACE, ("WIN32SPL MyUNCName looking for %ws in name cache, result %u\n", pName, bRet));

        if (pcMark)
        {
            *pcMark = L'\\';
        }
    }

    return bRet;
}



#define MAX_CACHE_ENTRIES       20

LMCACHE LMCacheTable[MAX_CACHE_ENTRIES];


DWORD
FindEntryinLMCache(
    LPWSTR pServerName,
    LPWSTR pShareName
    )
{
    DWORD i;

    DBGMSG(DBG_TRACE, ("FindEntryinLMCache with %ws and %ws\n", pServerName, pShareName));
    for (i = 0; i < MAX_CACHE_ENTRIES; i++ ) {

        if (LMCacheTable[i].bAvailable) {
            if (!_wcsicmp(LMCacheTable[i].szServerName, pServerName)
                        && !_wcsicmp(LMCacheTable[i].szShareName, pShareName)) {
                //
                // update the time stamp so that it is current and not old
                //
                GetSystemTime(&LMCacheTable[i].st);

                //
                //
                //
                DBGMSG(DBG_TRACE, ("FindEntryinLMCache returning with %d\n", i));
                return(i);
            }
        }
    }

    DBGMSG(DBG_TRACE, ("FindEntryinLMCache returning with -1\n"));
    return((DWORD)-1);
}


DWORD
AddEntrytoLMCache(
    LPWSTR pServerName,
    LPWSTR pShareName
    )
{

    DWORD LRUEntry = (DWORD)-1;
    DWORD i;
    DBGMSG(DBG_TRACE, ("AddEntrytoLMCache with %ws and %ws\n", pServerName, pShareName));
    for (i = 0; i < MAX_CACHE_ENTRIES; i++ ) {

        if (!LMCacheTable[i].bAvailable) {
            LMCacheTable[i].bAvailable = TRUE;

            StringCchCopy(LMCacheTable[i].szServerName, COUNTOF(LMCacheTable[i].szServerName), pServerName);
            StringCchCopy(LMCacheTable[i].szShareName,  COUNTOF(LMCacheTable[i].szShareName),  pShareName);
            //
            // update the time stamp so that we know when this entry was made
            //
            GetSystemTime(&LMCacheTable[i].st);
            DBGMSG(DBG_TRACE, ("AddEntrytoLMCache returning with %d\n", i));
            return(i);
        } else {
            if ((LRUEntry == (DWORD)-1) ||
                    (i == IsOlderThan(i, LRUEntry))){
                        LRUEntry = i;
            }
        }

    }
    //
    // We have no available entries, replace with the
    // LRU Entry

    LMCacheTable[LRUEntry].bAvailable = TRUE;
    StringCchCopy(LMCacheTable[LRUEntry].szServerName, COUNTOF(LMCacheTable[LRUEntry].szServerName), pServerName);
    StringCchCopy(LMCacheTable[LRUEntry].szShareName,  COUNTOF(LMCacheTable[LRUEntry].szShareName),  pShareName);
    DBGMSG(DBG_TRACE, ("AddEntrytoLMCache returning with %d\n", LRUEntry));
    return(LRUEntry);
}


VOID
DeleteEntryfromLMCache(
    LPWSTR pServerName,
    LPWSTR pShareName
    )
{
    DWORD i;
    DBGMSG(DBG_TRACE, ("DeleteEntryFromLMCache with %ws and %ws\n", pServerName, pShareName));
    for (i = 0; i < MAX_CACHE_ENTRIES; i++ ) {
        if (LMCacheTable[i].bAvailable) {
            if (!_wcsicmp(LMCacheTable[i].szServerName, pServerName)
                        && !_wcsicmp(LMCacheTable[i].szShareName, pShareName)) {
                //
                //  reset the available flag on this node
                //

                LMCacheTable[i].bAvailable = FALSE;
                DBGMSG(DBG_TRACE, ("DeleteEntryFromLMCache returning after deleting the %d th entry\n", i));
                return;
            }
        }
    }
    DBGMSG(DBG_TRACE, ("DeleteEntryFromLMCache returning after not finding an entry to delete\n"));
}



DWORD
IsOlderThan(
    DWORD i,
    DWORD j
    )
{
    SYSTEMTIME *pi, *pj;
    DWORD iMs, jMs;

    DBGMSG(DBG_TRACE, ("IsOlderThan entering with i %d j %d\n", i, j));
    pi = &(LMCacheTable[i].st);
    pj = &(LMCacheTable[j].st);
    DBGMSG(DBG_TRACE, ("Index i %d - %d:%d:%d:%d:%d:%d:%d\n",
        i, pi->wYear, pi->wMonth, pi->wDay, pi->wHour, pi->wMinute, pi->wSecond, pi->wMilliseconds));


    DBGMSG(DBG_TRACE,("Index j %d - %d:%d:%d:%d:%d:%d:%d\n",
        j, pj->wYear, pj->wMonth, pj->wDay, pj->wHour, pj->wMinute, pj->wSecond, pj->wMilliseconds));

    if (pi->wYear < pj->wYear) {
        DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wYear > pj->wYear) {
        DBGMSG(DBG_TRACE, ("IsOlderThan than returns %d\n", j));
        return(j);
    } else if (pi->wMonth < pj->wMonth) {
        DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wMonth > pj->wMonth) {
        DBGMSG(DBG_TRACE, ("IsOlderThan than returns %d\n", j));
        return(j);
    } else if (pi->wDay < pj->wDay) {
        DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wDay > pj->wDay) {
        DBGMSG(DBG_TRACE, ("IsOlderThan than returns %d\n", j));
        return(j);
    } else {
        iMs = ((((pi->wHour * 60) + pi->wMinute)*60) + pi->wSecond)* 1000 + pi->wMilliseconds;
        jMs = ((((pj->wHour * 60) + pj->wMinute)*60) + pj->wSecond)* 1000 + pj->wMilliseconds;

        if (iMs <= jMs) {
            DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
            return(i);
        } else {
            DBGMSG(DBG_TRACE, ("IsOlderThan than returns %d\n", j));
            return(j);
        }
    }
}



WIN32LMCACHE  Win32LMCacheTable[MAX_CACHE_ENTRIES];

DWORD
FindEntryinWin32LMCache(
    LPWSTR pServerName
    )
{
    DWORD i;
    DBGMSG(DBG_TRACE, ("FindEntryinWin32LMCache with %ws\n", pServerName));
    for (i = 0; i < MAX_CACHE_ENTRIES; i++ ) {

        if (Win32LMCacheTable[i].bAvailable) {
            if (!_wcsicmp(Win32LMCacheTable[i].szServerName, pServerName)) {
                //
                // update the time stamp so that it is current and not old
                //
                GetSystemTime(&Win32LMCacheTable[i].st);

                //
                //
                //
                DBGMSG(DBG_TRACE, ("FindEntryinWin32LMCache returning with %d\n", i));
                return(i);
            }
        }
    }
    DBGMSG(DBG_TRACE, ("FindEntryinWin32LMCache returning with -1\n"));
    return((DWORD)-1);
}


DWORD
AddEntrytoWin32LMCache(
    LPWSTR pServerName
    )
{

    DWORD LRUEntry = (DWORD)-1;
    DWORD i;
    DBGMSG(DBG_TRACE, ("AddEntrytoWin32LMCache with %ws\n", pServerName));
    for (i = 0; i < MAX_CACHE_ENTRIES; i++ ) {

        if (!Win32LMCacheTable[i].bAvailable) {
            Win32LMCacheTable[i].bAvailable = TRUE;
            StringCchCopy(Win32LMCacheTable[i].szServerName, COUNTOF(Win32LMCacheTable[i].szServerName), pServerName);
            //
            // update the time stamp so that we know when this entry was made
            //
            GetSystemTime(&Win32LMCacheTable[i].st);
            DBGMSG(DBG_TRACE, ("AddEntrytoWin32LMCache returning with %d\n", i));
            return(i);
        } else {
            if ((LRUEntry == -1) ||
                    (i == Win32IsOlderThan(i, LRUEntry))){
                        LRUEntry = i;
            }
        }

    }
    //
    // We have no available entries, replace with the
    // LRU Entry

    Win32LMCacheTable[LRUEntry].bAvailable = TRUE;
    StringCchCopy(Win32LMCacheTable[LRUEntry].szServerName, COUNTOF(Win32LMCacheTable[LRUEntry].szServerName), pServerName);
    DBGMSG(DBG_TRACE, ("AddEntrytoWin32LMCache returning with %d\n", LRUEntry));
    return(LRUEntry);
}


VOID
DeleteEntryfromWin32LMCache(
    LPWSTR pServerName
    )
{
    DWORD i;

    DBGMSG(DBG_TRACE, ("DeleteEntryFromWin32LMCache with %ws\n", pServerName));
    for (i = 0; i < MAX_CACHE_ENTRIES; i++ ) {
        if (Win32LMCacheTable[i].bAvailable) {
            if (!_wcsicmp(Win32LMCacheTable[i].szServerName, pServerName)) {
                //
                //  reset the available flag on this node
                //

                Win32LMCacheTable[i].bAvailable = FALSE;
                DBGMSG(DBG_TRACE, ("DeleteEntryFromWin32LMCache returning after deleting the %d th entry\n", i));
                return;
            }
        }
    }
    DBGMSG(DBG_TRACE, ("DeleteEntryFromWin32LMCache returning after not finding an entry to delete\n"));
}



DWORD
Win32IsOlderThan(
    DWORD i,
    DWORD j
    )
{
    SYSTEMTIME *pi, *pj;
    DWORD iMs, jMs;
    DBGMSG(DBG_TRACE, ("Win32IsOlderThan entering with i %d j %d\n", i, j));
    pi = &(Win32LMCacheTable[i].st);
    pj = &(Win32LMCacheTable[j].st);
    DBGMSG(DBG_TRACE, ("Index i %d - %d:%d:%d:%d:%d:%d:%d\n",
        i, pi->wYear, pi->wMonth, pi->wDay, pi->wHour, pi->wMinute, pi->wSecond, pi->wMilliseconds));


    DBGMSG(DBG_TRACE,("Index j %d - %d:%d:%d:%d:%d:%d:%d\n",
        j, pj->wYear, pj->wMonth, pj->wDay, pj->wHour, pj->wMinute, pj->wSecond, pj->wMilliseconds));

    if (pi->wYear < pj->wYear) {
        DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wYear > pj->wYear) {
        DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", j));
        return(j);
    } else if (pi->wMonth < pj->wMonth) {
        DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wMonth > pj->wMonth) {
        DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", j));
        return(j);
    } else if (pi->wDay < pj->wDay) {
        DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wDay > pj->wDay) {
        DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", j));
        return(j);
    } else {
        iMs = ((((pi->wHour * 60) + pi->wMinute)*60) + pi->wSecond)* 1000 + pi->wMilliseconds;
        jMs = ((((pj->wHour * 60) + pj->wMinute)*60) + pj->wSecond)* 1000 + pj->wMilliseconds;

        if (iMs <= jMs) {
            DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", i));
            return(i);
        } else {
            DBGMSG(DBG_TRACE, ("Win32IsOlderThan returns %d\n", j));
            return(j);
        }
    }
}


BOOL
GetSid(
    PHANDLE phToken
)
{
    if (!OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE,
                          TRUE,
                          phToken)) {

        DBGMSG(DBG_WARNING, ("OpenThreadToken failed: %d\n", GetLastError()));
        return FALSE;

    } else {

        return TRUE;
    }
}



BOOL
SetCurrentSid(
    HANDLE  hToken
)
{
    NtSetInformationThread(NtCurrentThread(), ThreadImpersonationToken,
                               &hToken, sizeof(hToken));

    return TRUE;
}

BOOL
ValidateW32SpoolHandle(
    PWSPOOL pSpool
)
{
    SplOutSem();
    try {
        if (!pSpool || (pSpool->signature != WSJ_SIGNATURE)) {

            DBGMSG( DBG_TRACE, ("ValidateW32SpoolHandle error invalid handle %x\n", pSpool));

            SetLastError(ERROR_INVALID_HANDLE);
            return(FALSE);
        }
        return(TRUE);
    } except (1) {
        DBGMSG( DBG_TRACE, ("ValidateW32SpoolHandle error invalid handle %x\n", pSpool));
        return(FALSE);
    }
}

BOOL
ValidRawDatatype(
    LPCWSTR pszDatatype
    )
{
    if( !pszDatatype || _wcsnicmp( pszDatatype, pszRaw, 3 )){
        return FALSE;
    }
    return TRUE;
}

HANDLE
LoadDriverFiletoConvertDevmodeFromPSpool(
    HANDLE  hSplPrinter
    )
/*++
    Finds out full path to the driver file and creates a DEVMODECHG_INFO
    (which does a LoadLibrary)

Arguments:
    h   : A cache handle

Return Value:
    On succes a valid pointer, else NULL
--*/
{
    LPBYTE              pDriver = NULL;
    LPWSTR              pConfigFile;
    HANDLE              hDevModeChgInfo = NULL;
    DWORD               dwNeeded;
    DWORD               dwServerMajorVersion = 0, dwServerMinorVersion = 0;

    if ( hSplPrinter == INVALID_HANDLE_VALUE ) {

        SPLASSERT(hSplPrinter != INVALID_HANDLE_VALUE);
        return NULL;
    }


    SplGetPrinterDriverEx(hSplPrinter,
                          szEnvironment,
                          2,
                          NULL,
                          0,
                          &dwNeeded,
                          cThisMajorVersion,
                          cThisMinorVersion,
                          &dwServerMajorVersion,
                          &dwServerMinorVersion);

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        goto Cleanup;

    pDriver = AllocSplMem(dwNeeded);

    if ( !pDriver ||
         !SplGetPrinterDriverEx(hSplPrinter,
                                szEnvironment,
                                2,
                                (LPBYTE)pDriver,
                                dwNeeded,
                                &dwNeeded,
                                cThisMajorVersion,
                                cThisMinorVersion,
                                &dwServerMajorVersion,
                                &dwServerMinorVersion) )
        goto Cleanup;

    pConfigFile = ((LPDRIVER_INFO_2)pDriver)->pConfigFile;
    hDevModeChgInfo = LoadDriverFiletoConvertDevmode(pConfigFile);

Cleanup:

    if ( pDriver )
        FreeSplMem(pDriver);

    return hDevModeChgInfo;
}

BOOL
DoDevModeConversionAndBuildNewPrinterInfo2(
    IN     LPPRINTER_INFO_2 pInPrinter2,
    IN     DWORD            dwInSize,
    IN OUT LPBYTE           pOutBuf,
    IN     DWORD            dwOutSize,
    IN OUT LPDWORD          pcbNeeded,
    IN     PWSPOOL          pSpool
    )
/*++
    Calls driver to do a devmode conversion and builds a new printer info 2.

    Devmode is put at the end and then strings are packed from there.


Arguments:

    pInPrinter2 - Printer Info2 structure with devmode info

    dwInSize    - Number of characters needed to pack info in pInPrinter
                  (not necessarily the size of the input buffer)

    dwOutSize   - buffer size

    pOutBuf    - Buffer to do the operation

    pcbNeeded   - Amount of memory copied (in characters)

    pSpool      - Points to w32 handle


Return Value:
    TRUE    on success, FALSE on error

--*/
{
    BOOL                bReturn = FALSE;
    LPDEVMODE           pNewDevMode = NULL, pCacheDevMode, pInDevMode;
    DWORD               dwDevModeSize, dwSecuritySize, dwNeeded = 0;
    DWORD               cchPrinterName;
    HANDLE              hDevModeChgInfo = NULL;
    LPWSTR              SourceStrings[sizeof(PRINTER_INFO_2)/sizeof(LPWSTR)];
    LPWSTR             *pSourceStrings=SourceStrings;
    LPDWORD             pOffsets;
    LPBYTE              pEnd;
    PWCACHEINIPRINTEREXTRA  pExtraData;

    LPWSTR              pPrinterName = NULL;

    VALIDATEW32HANDLE(pSpool);

    pInDevMode = pInPrinter2->pDevMode;

    if ( !BoolFromHResult(SplIsValidDevmodeNoSizeW(pInDevMode)) || 
         pSpool->hSplPrinter == INVALID_HANDLE_VALUE ) {

        goto AfterDevModeConversion;
    }

    if ( !SplGetPrinterExtra(pSpool->hSplPrinter,
                             &(PBYTE)pExtraData) ) {

        DBGMSG(DBG_ERROR,
                ("DoDevModeConversionAndBuildNewPrinterInfo2: SplGetPrinterExtra error %d\n",
                 GetLastError()));
        goto AfterDevModeConversion;
    }

    //
    // Only time we do not have to convert devmode is if the server is running
    // same version NT and also we have a devmode which matches the server
    // devmode in dmSize, dmDriverExtra, dmSpecVersion, and dmDriverVersion
    //
    pCacheDevMode = pExtraData->pPI2 ? pExtraData->pPI2->pDevMode : NULL;
    if ( (pExtraData->dwServerVersion == gdwThisGetVersion ||
          (pSpool->Status & WSPOOL_STATUS_CNVRTDEVMODE))                     &&
         pCacheDevMode                                                      &&
         pInDevMode->dmSize             == pCacheDevMode->dmSize            &&
         pInDevMode->dmDriverExtra      == pCacheDevMode->dmDriverExtra     &&
         pInDevMode->dmSpecVersion      == pCacheDevMode->dmSpecVersion     &&
         pInDevMode->dmDriverVersion    == pCacheDevMode->dmDriverVersion ) {

        dwDevModeSize = pInDevMode->dmSize + pInDevMode->dmDriverExtra;
        dwNeeded = dwInSize;
        if ( dwOutSize < dwNeeded ) {

            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            goto Cleanup;
        }

        //
        // Put DevMode at the end
        //
        pNewDevMode = (LPDEVMODE)(pOutBuf + dwOutSize - dwDevModeSize);
        CopyMemory((LPBYTE)pNewDevMode,
                   (LPBYTE)pInDevMode,
                   dwDevModeSize);
        goto AfterDevModeConversion;
    }


    hDevModeChgInfo = LoadDriverFiletoConvertDevmodeFromPSpool(pSpool->hSplPrinter);

    if ( !hDevModeChgInfo )
        goto AfterDevModeConversion;

    dwDevModeSize = 0;

    SPLASSERT( pSpool->pName != NULL );

    //
    // Append ,DEVMODE to end of pSpool->pName
    //
    cchPrinterName = lstrlen(pSpool->pName) + lstrlen(pszCnvrtdmToken) + 1;

    pPrinterName = AllocSplMem(cchPrinterName * sizeof(WCHAR));
    if ( !pPrinterName )
        goto Cleanup;


    StrNCatBuff(pPrinterName,
                cchPrinterName,
                pSpool->pName,
                pszCnvrtdmToken,
                NULL);

    //
    // Findout size of default devmode
    //
    if ( ERROR_INSUFFICIENT_BUFFER != CallDrvDevModeConversion(hDevModeChgInfo,
                                                               pPrinterName,
                                                               NULL,
                                                               (LPBYTE *)&pNewDevMode,
                                                               &dwDevModeSize,
                                                               CDM_DRIVER_DEFAULT,
                                                               FALSE)  )
        goto AfterDevModeConversion;

    //
    // Findout size needed to have current version devmode
    //
    dwNeeded = dwInSize + dwDevModeSize - pInDevMode->dmSize
                                        - pInDevMode->dmDriverExtra;

    if ( dwOutSize < dwNeeded ) {

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    //
    // Put DevMode at the end
    //
    pNewDevMode = (LPDEVMODE)(pOutBuf + dwOutSize - dwDevModeSize);

    //
    // Get default devmode and then convert remote devmode to that format
    //
    if ( ERROR_SUCCESS != CallDrvDevModeConversion(hDevModeChgInfo,
                                                   pPrinterName,
                                                   NULL,
                                                   (LPBYTE *)&pNewDevMode,
                                                   &dwDevModeSize,
                                                   CDM_DRIVER_DEFAULT,
                                                   FALSE) ||
         ERROR_SUCCESS != CallDrvDevModeConversion(hDevModeChgInfo,
                                                   pPrinterName,
                                                   (LPBYTE)pInDevMode,
                                                   (LPBYTE *)&pNewDevMode,
                                                   &dwDevModeSize,
                                                   CDM_CONVERT,
                                                   FALSE) ) {

        pNewDevMode = NULL;
        goto AfterDevModeConversion;
    }


AfterDevModeConversion:
    //
    // At this point if pNewDevMode != NULL dev mode conversion has been done
    // by the driver. If not either we did not get a devmode or conversion failed
    // In either case set devmode to NULL
    //
    if ( !pNewDevMode ) {

        dwNeeded = dwInSize;

        if ( dwOutSize < dwNeeded ) {

            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            goto Cleanup;
        }
    }

    bReturn = TRUE;

    CopyMemory(pOutBuf, (LPBYTE)pInPrinter2, sizeof(PRINTER_INFO_2));
    ((LPPRINTER_INFO_2)pOutBuf)->pDevMode = pNewDevMode;

    pEnd = (pNewDevMode ? (LPBYTE) pNewDevMode
                        : (LPBYTE) (pOutBuf + dwOutSize));


    if ( pInPrinter2->pSecurityDescriptor ) {

        dwSecuritySize = GetSecurityDescriptorLength(
                                pInPrinter2->pSecurityDescriptor);
        pEnd -= dwSecuritySize;
        CopyMemory(pEnd, pInPrinter2->pSecurityDescriptor, dwSecuritySize);
        ((LPPRINTER_INFO_2)pOutBuf)->pSecurityDescriptor =
                                (PSECURITY_DESCRIPTOR) pEnd;
    } else {

        ((LPPRINTER_INFO_2)pOutBuf)->pSecurityDescriptor = NULL;

    }

    pOffsets = PrinterInfo2Strings;

    *pSourceStrings++ = pInPrinter2->pServerName;
    *pSourceStrings++ = pInPrinter2->pPrinterName;
    *pSourceStrings++ = pInPrinter2->pShareName;
    *pSourceStrings++ = pInPrinter2->pPortName;
    *pSourceStrings++ = pInPrinter2->pDriverName;
    *pSourceStrings++ = pInPrinter2->pComment;
    *pSourceStrings++ = pInPrinter2->pLocation;
    *pSourceStrings++ = pInPrinter2->pSepFile;
    *pSourceStrings++ = pInPrinter2->pPrintProcessor;
    *pSourceStrings++ = pInPrinter2->pDatatype;
    *pSourceStrings++ = pInPrinter2->pParameters;

    pEnd = PackStrings(SourceStrings, (LPBYTE)pOutBuf, pOffsets, pEnd);

    SPLASSERT(pEnd > pOutBuf && pEnd < pOutBuf + dwOutSize);

    bReturn = TRUE;

Cleanup:

    *pcbNeeded = dwNeeded;

    if ( hDevModeChgInfo )
        UnloadDriverFile(hDevModeChgInfo);

    if (pPrinterName)
        FreeSplMem(pPrinterName);

    return bReturn;
}



PWSTR
StripString(
    PWSTR pszString,
    PCWSTR pszStrip,
    PCWSTR pszTerminator
)
{
    //
    // Strips the first occurence of pszStrip from pszString if
    // the next character after pszStrip is one of the characters
    // in pszTerminator.  NULL is an implicit terminator, so if you
    // want to strip pszStrip only at the end of pszString, just pass
    // in an empty string for pszTerminator.
    //
    // Returns: Pointer to pszString if pszStrip was found
    //          NULL is pszStrip was not found
    //


    PWSTR    psz;
    DWORD    dwStripLength;

    if (!pszStrip || !pszString || !pszTerminator)
        return NULL;

    dwStripLength = wcslen(pszStrip);

    for(psz = pszString ; psz ;) {

        // find pszStrip in pszString
        if ((psz = wcsstr(psz, pszStrip))) {

            // check for the terminator & strip pszStrip
            if (!*(psz + dwStripLength) || wcschr(pszTerminator, *(psz + dwStripLength))) {
                StringCchCopy(psz, 1 + wcslen(psz), psz + dwStripLength);
                return pszString;
            } else {
                ++psz;
            }
        }
    }
    return NULL;
}

BOOL
AddDriverFromLocalCab(
    LPTSTR   pszDriverName,
    LPHANDLE pIniSpooler
    )
{
    DRIVER_INFO_7 DriverInfo7;

    if( GetPolicy() & SERVER_INSTALL_ONLY ) {

        return FALSE;
    }

    DriverInfo7.cbSize               = sizeof( DriverInfo7 );
    DriverInfo7.cVersion             = 0;
    DriverInfo7.pszDriverName        = pszDriverName;
    DriverInfo7.pszInfName           = NULL;
    DriverInfo7.pszInstallSourceRoot = NULL;

    return ( SplAddPrinterDriverEx( NULL,
                                    7,
                                    (LPBYTE)&DriverInfo7,
                                    APD_COPY_NEW_FILES,
                                    pIniSpooler,
                                    DO_NOT_USE_SCRATCH_DIR,
                                    FALSE ) );
}

/*++

Routine Name:

    IsAdminAccess

Description:

    This returns whether the given printer defaults are asking for admin access,
    we consider the request to be admin access if the printer defaults are
    non-NULL and have PRINTER_ACCESS_ADMINISTER or WRITE_DAC specified.

Arguments:

    pDefaults   -   The printer defaults, may be NULL.

Return Value:

    None.

--*/
BOOL
IsAdminAccess(
    IN  PRINTER_DEFAULTS    *pDefaults
    )
{
    return pDefaults && (pDefaults->DesiredAccess & (PRINTER_ACCESS_ADMINISTER | WRITE_DAC));
}

/*++

Routine Name:

    AreWeOnADomain

Description:

    This returns whether this machine is a domain joined machine or not.

Arguments:

    pbDomain        -   If TRUE, we are on a domain.

Return Value:

    An HRESULT.

--*/
HRESULT
AreWeOnADomain(
        OUT BOOL                *pbDomain
    )
{
    HRESULT hr = pbDomain ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pRoleInfo = NULL;
    BOOL    bOnDomain = FALSE;

    if (SUCCEEDED(hr))
    {
        hr = HResultFromWin32(DsRoleGetPrimaryDomainInformation(NULL,
                                                                DsRolePrimaryDomainInfoBasic,
                                                                (BYTE **)(&pRoleInfo)));
    }

    if (SUCCEEDED(hr))
    {
        bOnDomain = pRoleInfo->MachineRole == DsRole_RoleMemberWorkstation      ||
                    pRoleInfo->MachineRole == DsRole_RoleMemberServer           ||
                    pRoleInfo->MachineRole == DsRole_RoleBackupDomainController ||
                    pRoleInfo->MachineRole == DsRole_RolePrimaryDomainController;
    }

    if (pRoleInfo)
    {
        DsRoleFreeMemory((VOID *)pRoleInfo);
    }

    if (pbDomain)
    {
        *pbDomain = bOnDomain;
    }

    return hr;
}

/*++

Routine Name:

    GetServerNameFromQueue

Description:

    This returns the server name from the given queue name.

Arguments:

    pszQueue        -   The queue name,
    ppszServerName  -   The server name.

Return Value:

    An HRESULT.

--*/
HRESULT
GetServerNameFromPrinterName(
    IN      PCWSTR              pszQueue,
        OUT PWSTR               *ppszServerName
    )
{
    HRESULT hr = pszQueue && ppszServerName ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    PWSTR   pszServer = NULL;

    if (SUCCEEDED(hr))
    {
        hr = *pszQueue++ == L'\\' && *pszQueue++ == L'\\' ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PRINTER_NAME);
    }

    if (SUCCEEDED(hr))
    {
        pszServer = AllocSplStr(pszQueue);

        hr = pszServer ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
    }

    if (SUCCEEDED(hr))
    {
        PWSTR pszSlash = wcschr(&pszServer[2], L'\\');

        //
        // If there was no second slash, then what we have is the server name.
        //
        if (pszSlash)
        {
            *pszSlash = L'\0';
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppszServerName = pszServer;
        pszServer = NULL;
    }

    FreeSplMem(pszServer);

    return hr;
}


/*++

Routine Name:

    GetDNSNameFromServerName

Description:

    This returns a fully qualified DNS name from the server name. It is
    basically copied from localspl because this is dead-end code. In CSR,
    we will fix this properly.

Arguments:

    pszServerName       -   The server name whose fully qualified name we are obtaining.
    ppszFullyQualified  -

Return Value:

    An HRESULT.

--*/
HRESULT
GetDNSNameFromServerName(
    IN      PCWSTR       pszServerName,
        OUT PWSTR        *ppszFullyQualified
    )
{
    PSTR    pszAnsiMachineName = NULL;
    struct  hostent  *pHostEnt;
    WORD    wVersion;
    WSADATA WSAData;
    HRESULT hr =  pszServerName && *pszServerName && ppszFullyQualified ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);


    PWSTR   pszDummy = NULL;
    GetFullyQualifiedDomainName(pszServerName, &pszDummy);

    if (SUCCEEDED(hr))
    {
        wVersion = MAKEWORD(1, 1);

        hr = HResultFromWin32(WSAStartup(wVersion, &WSAData));
    }

    if (SUCCEEDED(hr))
    {
        hr = UnicodeToAnsiString(pszServerName, &pszAnsiMachineName);

        if (SUCCEEDED(hr))
        {
            pHostEnt = gethostbyname(pszAnsiMachineName);

            hr = pHostEnt ? S_OK : HResultFromWin32(WSAGetLastError());
        }

        if (SUCCEEDED(hr))
        {
            *ppszFullyQualified = AnsiToUnicodeStringWithAlloc(pHostEnt->h_name);

            hr = *ppszFullyQualified ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        }

        WSACleanup();
    }

    FreeSplMem(pszAnsiMachineName);

    return hr;
}

/*++

Routine Name:

    UnicodeToAnsiString

Routine Description:

    This allocates an ANSI string and converts it using the thread's codepage.

Arguments:

    pszUnicode      -   The incoming, non-NULL, NULL terminated unicode string.
    ppszAnsi        -   The returned ANSI string.

Return Value:

    An HRESULT

--*/
HRESULT
UnicodeToAnsiString(
    IN      PCWSTR          pszUnicode,
        OUT PSTR            *ppszAnsi
    )
{
    HRESULT hRetval          = E_FAIL;
    PSTR    pszAnsi          = NULL;
    INT     AnsiStringLength = 0;

    hRetval = pszUnicode && ppszAnsi ? S_OK : E_INVALIDARG;

    if (ppszAnsi)
    {
        *ppszAnsi = NULL;
    }

    if (SUCCEEDED(hRetval))
    {
        AnsiStringLength = WideCharToMultiByte(CP_THREAD_ACP, 0, pszUnicode, -1, NULL, 0, NULL, NULL);

        hRetval = AnsiStringLength != 0 ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        pszAnsi = AllocSplMem(AnsiStringLength);

        hRetval = pszAnsi ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hRetval))
    {
        hRetval = WideCharToMultiByte(CP_THREAD_ACP, 0, pszUnicode, -1, pszAnsi, AnsiStringLength, NULL, NULL) != 0 ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval))
    {
        *ppszAnsi = pszAnsi;
        pszAnsi = NULL;
    }

    FreeSplMem(pszAnsi);

    return hRetval;
}

/*++

Routine Name:

    AnsiToUnicodeStringWithAlloc

Description:

    Convert ANSI string to UNICODE. Routine allocates memory from the heap
    which should be freed by the caller.

Arguments:

    pAnsi    - Points to the ANSI string

Return Value:

    Pointer to UNICODE string

--*/
LPWSTR
AnsiToUnicodeStringWithAlloc(
    LPSTR   pAnsi
    )
{
    LPWSTR  pUnicode;
    DWORD   rc;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pAnsi,
                             -1,
                             NULL,
                             0);

    rc *= sizeof(WCHAR);
    if ( !rc || !(pUnicode = (LPWSTR) AllocSplMem(rc)) )
        return NULL;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             pAnsi,
                             -1,
                             pUnicode,
                             rc);

    if ( rc )
        return pUnicode;
    else {
        FreeSplMem(pUnicode);
        return NULL;
    }
}

/*++

Routine Name:

    CheckSamePhysicalAddress

Description:

    This checks to see whether two servers share a same network address. What it
    does is check to see whether the first physical network address of the first
    print server can be found in the list of addresses supported by the second
    print server.

Arguments:

    pszServer1      - The first server in the list.
    pszServer2      - The second server in the list.
    pbSameAddress   - If TRUE, the first physical address of server1 can be found
                      in server2.

Return Value:

    An HRESULT.

--*/
HRESULT
CheckSamePhysicalAddress(
    IN      PCWSTR              pszServer1,
    IN      PCWSTR              pszServer2,
        OUT BOOL                *pbSameAddress
    )
{
    BOOL        bSameAddress    = FALSE;
    PSTR        pszAnsiServer1  = NULL;
    PSTR        pszAnsiServer2  = NULL;
    ADDRINFO    *pAddrInfo1     = NULL;
    ADDRINFO    *pAddrInfo2     = NULL;
    WSADATA     WSAData;
    WORD        wVersion;
    HRESULT     hr = pszServer1 && pszServer2 && pbSameAddress ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    if (SUCCEEDED(hr))
    {
        wVersion = MAKEWORD(1, 1);

        hr = HResultFromWin32(WSAStartup(wVersion, &WSAData));
    }

    if (SUCCEEDED(hr))
    {
        ADDRINFO    *pAddrInfoScan = NULL;

        hr = UnicodeToAnsiString(pszServer1, &pszAnsiServer1);

        if (SUCCEEDED(hr))
        {
            hr = UnicodeToAnsiString(pszServer2, &pszAnsiServer2);
        }

        if (SUCCEEDED(hr))
        {
            hr = getaddrinfo(pszAnsiServer1, NULL, NULL, &pAddrInfo1) == 0 ? S_OK : HResultFromWin32(WSAGetLastError());
        }

        if (SUCCEEDED(hr))
        {
            hr = getaddrinfo(pszAnsiServer2, NULL, NULL, &pAddrInfo2) == 0 ? S_OK : HResultFromWin32(WSAGetLastError());
        }

        //
        // OK, now for the hokey bit, we check to see whether we can exactly
        // match the first element in pAddrInfo1 anywhere in pAddrInfo2.
        //
        for(pAddrInfoScan =  pAddrInfo2; pAddrInfo2 && !bSameAddress; pAddrInfo2 = pAddrInfo2->ai_next)
        {
            //
            // If the lengths of the addresses are the same, then compare the
            // actual addresses.
            //
            if (pAddrInfoScan->ai_addrlen == pAddrInfo1->ai_addrlen &&
                !memcmp(pAddrInfoScan->ai_addr, pAddrInfo1->ai_addr, pAddrInfoScan->ai_addrlen))
            {
                bSameAddress = TRUE;
            }
        }

        freeaddrinfo(pAddrInfo1);
        freeaddrinfo(pAddrInfo2);

        WSACleanup();
    }

    if (pbSameAddress)
    {
        *pbSameAddress = bSameAddress;
    }

    FreeSplMem(pszAnsiServer1);
    FreeSplMem(pszAnsiServer2);

    return hr;
}

/*++

Routine Name:

    CheckUserPrintAdmin

Description:

    This checks to see whether the given user is a print admin.

Arguments:

    pbUserAdmin     -   If TRUE, the user is a print admin.

Return Value:

    An HRESULT.

--*/
HRESULT
CheckUserPrintAdmin(
        OUT BOOL                *pbUserAdmin
    )
{
    //
    // Check to see whether the caller has access to the local print
    // server, if we do have access, then we allow point and print.
    //
    HANDLE              hServer = NULL;
    PRINTER_DEFAULTS    Defaults = {NULL, NULL, SERVER_ACCESS_ADMINISTER };
    HRESULT             hr       = pbUserAdmin ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    //
    // This actually calls into the router and not into winspool.drv.
    //
    if (SUCCEEDED(hr))
    {
    }
    hr = OpenPrinterW(NULL, &hServer, &Defaults) ? S_OK : GetLastErrorAsHResultAndFail();

    if (SUCCEEDED(hr))
    {
         *pbUserAdmin = TRUE;
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
    {
        *pbUserAdmin = FALSE;

        hr = S_OK;
    }

    if (hServer)
    {
        ClosePrinter(hServer);
    }

    return hr;
}

/*++

Routine Name:

    GetFullyQualifiedDomainName

Description:

    This returns a truly fully qualified name, being the name that the endpoint
    expects to use, or

Arguments:

    pszServerName       -   The server name whose fully qualified name we are obtaining.
    ppszFullyQualified  -   The returned fully qualified name.

Return Value:

    An HRESULT.

--*/
HRESULT
GetFullyQualifiedDomainName(
    IN      PCWSTR      pszServerName,
        OUT PWSTR       *ppszFullyQualified
    )
{
    WORD    wVersion;
    WSADATA WSAData;
    PSTR    pszAnsiMachineName = NULL;
    HRESULT hr =  pszServerName && *pszServerName && ppszFullyQualified ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    if (SUCCEEDED(hr))
    {
        wVersion = MAKEWORD(1, 1);

        hr = HResultFromWin32(WSAStartup(wVersion, &WSAData));
    }

    if (SUCCEEDED(hr))
    {
        ADDRINFO    *pAddrInfo = NULL;
        CHAR        HostName[NI_MAXHOST];

        hr = UnicodeToAnsiString(pszServerName, &pszAnsiMachineName);

        if (SUCCEEDED(hr))
        {
            hr = getaddrinfo(pszAnsiMachineName, NULL, NULL, &pAddrInfo) == 0 ? S_OK : HResultFromWin32(WSAGetLastError());
        }

        //
        // Now the we have a socket addr, do a reverse name lookup on the name.
        //
        if (SUCCEEDED(hr))
        {
            hr = HResultFromWin32(getnameinfo(pAddrInfo->ai_addr, pAddrInfo->ai_addrlen, HostName, sizeof(HostName), NULL, 0, NI_NAMEREQD));
        }

        if (SUCCEEDED(hr))
        {
            *ppszFullyQualified = AnsiToUnicodeStringWithAlloc(HostName);

            hr = *ppszFullyQualified ? S_OK : HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        }

        if (pAddrInfo)
        {
            freeaddrinfo(pAddrInfo);
        }

        WSACleanup();
    }

    FreeSplMem(pszAnsiMachineName);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\prnfile.c ===
/*++

Copyright (c) 1994 - 1995  Microsoft Corporation

Module Name:

    prnfile.c

Abstract:

    This module contains all the code necessary for testing printing"
    to file to remote printers. There are two criteria based on which
    we will print to a file.

    Case 1:

     This is the true NT style print to file. One of the ports of the
     printer is a file port denoted as FILE: We will disregard any other
     port and straight away dump this job to file.


    Case 2:

    This is the "PiggyBacking" case. Apps such as WinWord, Publisher

Author:

    Krishna Ganugapati (Krishna Ganugapati) 6-June-1994

Revision History:
    6-June-1994 - Created.

--*/
#include "precomp.h"

typedef struct _KEYDATA {
    DWORD   cb;
    DWORD   cTokens;
    LPWSTR  pTokens[1];
} KEYDATA, *PKEYDATA;


WCHAR *szFilePort = L"FILE:";
WCHAR  *szNetPort = L"Net:";

//
// Function prototypes
//

PKEYDATA
CreateTokenList(
   LPWSTR   pKeyData
);

PKEYDATA
GetPrinterPortList(
    HANDLE hPrinter
    );

BOOL
IsaFileName(
    LPWSTR pOutputFile
    );

BOOL
IsaPortName(
        PKEYDATA pKeyData,
        LPWSTR pOutputFile
        );

BOOL
Win32IsGoingToFile(
    HANDLE hPrinter,
    LPWSTR pOutputFile
    )
{
    PKEYDATA pKeyData = NULL;
    BOOL   bErrorCode = FALSE;

    if (!pOutputFile || !*pOutputFile) {
        return FALSE;
    }

    pKeyData = GetPrinterPortList(hPrinter);

    if (pKeyData) {

        //
        // If it's not a port and it is a file name,
        // then it is going to file.
        //
        if (!IsaPortName(pKeyData, pOutputFile) && IsaFileName(pOutputFile)) {
            bErrorCode = TRUE;
        }

        FreeSplMem(pKeyData);
    }

    return bErrorCode;
}


BOOL
IsaFileName(
    LPWSTR pOutputFile
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WCHAR FullPathName[MAX_PATH];
    LPWSTR pFileName=NULL;

    //
    // Hack for Word20c.Win
    //

    if (!_wcsicmp(pOutputFile, L"FILE")) {
        return(FALSE);
    }

    if (wcslen(pOutputFile) < MAX_PATH && 
        GetFullPathName(pOutputFile, COUNTOF(FullPathName), FullPathName, &pFileName)) {
        if ((hFile = CreateFile(pOutputFile,
                                GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL)) != INVALID_HANDLE_VALUE) {
            if (GetFileType(hFile) == FILE_TYPE_DISK) {
                CloseHandle(hFile);
                return(TRUE);
            }else {
                CloseHandle(hFile);
                return(FALSE);
            }
        }
    }
    return(FALSE);
}

BOOL
IsaPortName(
        PKEYDATA pKeyData,
        LPWSTR pOutputFile
        )
{
    DWORD i = 0;
    UINT uStrLen;

    if (!pKeyData) {
        return(FALSE);
    }
    for (i=0; i < pKeyData->cTokens; i++) {
        if (!lstrcmpi(pKeyData->pTokens[i], pOutputFile)) {
            return(TRUE);
        }
    }

    //
    // Hack for NeXY: ports
    //
    if (!_wcsnicmp(pOutputFile, L"Ne", 2)) {

        uStrLen = wcslen( pOutputFile );

        //
        // Ne00: or Ne00 if app truncates it
        //
        if ( ( uStrLen == 5 ) || ( uStrLen == 4 ) )  {

            // Check for two Digits

            if (( pOutputFile[2] >= L'0' ) && ( pOutputFile[2] <= L'9' ) &&
                ( pOutputFile[3] >= L'0' ) && ( pOutputFile[3] <= L'9' )) {

                //
                // Check for the final : as in Ne01:,
                // note some apps will truncate it.
                //
                if (( uStrLen == 5 ) && (pOutputFile[4] != L':')) {
                    return FALSE;
                }
                return TRUE;
            }
        }
    }

    return(FALSE);
}

PKEYDATA
GetPrinterPortList(
    HANDLE hPrinter
    )
{
    LPBYTE pMem;
    LPTSTR pPort;
    DWORD  dwPassed = 1024; //Try 1K to start with
    LPPRINTER_INFO_2 pPrinter;
    DWORD dwLevel = 2;
    DWORD dwNeeded;
    PKEYDATA pKeyData;
    DWORD i = 0;


    pMem = AllocSplMem(dwPassed);
    if (pMem == NULL) {
        return FALSE;
    }
    if (!CacheGetPrinter(hPrinter, dwLevel, pMem, dwPassed, &dwNeeded)) {
        DBGMSG(DBG_TRACE, ("GetPrinterPortList GetPrinter error is %d\n", GetLastError()));
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            return NULL;
        }
        
        FreeSplMem(pMem);
        
        pMem = AllocSplMem(dwNeeded);

        if (pMem == NULL) {
            return FALSE;
        }
        
        dwPassed = dwNeeded;
        
        if (!CacheGetPrinter(hPrinter, dwLevel, pMem, dwPassed, &dwNeeded)) {
            FreeSplMem(pMem);
            return (NULL);
        }
    }
    pPrinter = (LPPRINTER_INFO_2)pMem;

    //
    // Fixes the null pPrinter->pPortName problem where
    // downlevel may return null
    //

    if (!pPrinter->pPortName) {
        FreeSplMem(pMem);
        return(NULL);
    }

    pKeyData = CreateTokenList(pPrinter->pPortName);
    FreeSplMem(pMem);

    return(pKeyData);
}


PKEYDATA
CreateTokenList(
   LPWSTR   pKeyData
)
{
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR      pDest;
    LPWSTR      psz = pKeyData;
    LPWSTR     *ppToken;

    if (!psz || !*psz)
    {
        return NULL;
    }

    for (cTokens = 0; psz && *psz; )
    {
        //
        // We're skipping consecutive commas
        //
        while (psz && *psz == L',')
        {
            psz++;
        }

        if (psz && *psz)
        {
            cTokens++;

            psz = wcschr(psz, L',');
        }        
    }
    
    if (!cTokens)
    {
        SetLastError(ERROR_INVALID_PARAMETER);

        return NULL;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) + wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocSplMem(cb)))
    {
        return NULL;
    }

    pResult->cb = cb;

    /* Initialise pDest to point beyond the token pointers:
     */
    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR));

    /* Then copy the key data buffer there:
     */
    StringCbCopy(pDest, cb - ((PBYTE)pDest - (PBYTE)pResult), pKeyData);

    ppToken = pResult->pTokens;

    for (psz = pDest; psz && *psz; )
    {
        while (psz && *psz == L',')
        {
            psz++;
        }

        if (psz && *psz)
        {
            *ppToken++ = psz;

            psz = wcschr(psz, L',');

            if (psz)
            {
                *psz = L'\0';

                psz++;
            }            
        }        
    }
    
    pResult->cTokens = cTokens;

    return( pResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\w32types.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    w32types.h

Abstract:

    win32 spooler definitions

Author:

Revision History:

--*/

#ifndef _W32TYPES_H_
#define _W32TYPES_H_

#ifndef MODULE
#define MODULE "WIN32SPL:"
#define MODULE_DEBUG Win32splDebug
#endif

typedef struct _LMNOTIFY *PLMNOTIFY;

typedef struct _LMNOTIFY {
    HANDLE          ChangeEvent;    // Notifies LanMan Printers status
    HANDLE          hNotify;        // LanMan notification structure
    DWORD           fdwChangeFlags; // LanMan notification watch flags
} LMNOTIFY;


#define TP_SIGNATURE 0x5054    /* 'TP' is the signature value */

enum
{
    THREAD_STATUS_EXECUTING,
    THREAD_STATUS_TERMINATED,       
};

struct _win32thread;

// WARNING
// If you add anything here, initialize it in AllocWSpool and free it in FreepSpool

typedef struct _WSPOOL {
    DWORD                   signature;
    struct _WSPOOL          *pNext;
    struct _WSPOOL          *pPrev;
    LPWSTR                  pName;
    DWORD                   Type;
    HANDLE                  RpcHandle;
    LPWSTR                  pServer;
    LPWSTR                  pShare;
    HANDLE                  hFile;
    DWORD                   Status;
    DWORD                   RpcError;       // If Status & WSPOOL_STATUS_OPEN_ERROR
    LMNOTIFY                LMNotify;
    HANDLE                  hIniSpooler;    // Machine Handle returned by Cache
    HANDLE                  hSplPrinter;    // Local Spl Printer Handle
    PRINTER_DEFAULTSW       PrinterDefaults;    // From the CacheOpenPrinter
    BOOL                    bNt3xServer;
    struct _win32thread     *pThread;
} WSPOOL;

typedef WSPOOL *PWSPOOL;

typedef struct _win32thread {

    DWORD               signature;
    LPWSTR              pName;
    HANDLE              hRpcHandle;
    PPRINTER_DEFAULTSW  pDefaults; 
    DWORD               dwStatus;
    struct _win32thread *pNext;
    HANDLE              hToken;             // Users Token
    HANDLE              hWaitValidHandle;   // Wait on till RpcHandle becomes valid
    DWORD               dwRpcOpenPrinterError;
    PSID                pSid;
    BOOL                bForegroundClose;

}WIN32THREAD, *PWIN32THREAD;


#define WSJ_SIGNATURE    0x474E  /* 'NG' is the signature value */

#define SJ_WIN32HANDLE  0x00000001
#define LM_HANDLE       0x00000002

//  WARNING
//  If you add anything here add code to the debugger extentions to display it

#define WSPOOL_STATUS_STARTDOC                  0x00000001
#define WSPOOL_STATUS_TEMP_CONNECTION           0x00000002
#define WSPOOL_STATUS_OPEN_ERROR                0x00000004
#define WSPOOL_STATUS_PRINT_FILE                0x00000008
#define WSPOOL_STATUS_USE_CACHE                 0x00000010
#define WSPOOL_STATUS_NO_RPC_HANDLE             0x00000020
#define WSPOOL_STATUS_RESETPRINTER_PENDING      0x00000040
#define WSPOOL_STATUS_NOTIFY                    0x00000080
#define WSPOOL_STATUS_NOTIFY_POLL               0x00000100
#define WSPOOL_STATUS_CNVRTDEVMODE              0x00000200
#define WSPOOL_STATUS_ASYNC                     0x00000400

//  If you add to this structure also add code to CacheReadRegistryExtra
//  and CacheWriteRegistryExtra to make sure the cache items are persistant
//  Also See RefreshPrinter where data must be copied

typedef struct _WCACHEINIPRINTEREXTRA {
    DWORD   signature;
    DWORD   cb;
    LPPRINTER_INFO_2  pPI2;
    DWORD   cbPI2;
    DWORD   cCacheID;
    DWORD   cRef;
    DWORD   dwServerVersion;
    DWORD   dwTickCount;
    DWORD   Status;
} WCACHEINIPRINTEREXTRA, *PWCACHEINIPRINTEREXTRA;

#define WCIP_SIGNATURE  'WCIP'

#define EXTRA_STATUS_PENDING_FFPCN              0x00000001
#define EXTRA_STATUS_DOING_REFRESH              0x00000002

// Used in SplGetPrinterExtraEx to prevent recursion in AddPrinterConnection

#define EXTRAEX_STATUS_CREATING_CONNECTION      0x00000001

typedef struct _WINIPORT {       /* ipo */
    DWORD   signature;
    DWORD   cb;
    struct  _WINIPORT *pNext;
    LPWSTR  pName;
} WINIPORT, *PWINIPORT, **PPWINIPORT;

#define WIPO_SIGNATURE  'WIPO'

typedef struct _lmcache {
    WCHAR   szServerName[MAX_PATH];
    WCHAR   szShareName[MAX_PATH];
    BOOL    bAvailable;
    SYSTEMTIME st;
}LMCACHE, *PLMCACHE;


typedef struct _win32lmcache {
    WCHAR   szServerName[MAX_PATH];
    BOOL    bAvailable;
    SYSTEMTIME st;
}WIN32LMCACHE, *PWIN32LMCACHE;

// Define some constants to make parameters to CreateEvent a tad less obscure:

#define EVENT_RESET_MANUAL                  TRUE
#define EVENT_RESET_AUTOMATIC               FALSE
#define EVENT_INITIAL_STATE_SIGNALED        TRUE
#define EVENT_INITIAL_STATE_NOT_SIGNALED    FALSE

#endif // _W32TYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\win32.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation
All rights reserved

Module Name:

    win32 provider (win32spl)

Abstract:

Author:
    DaveSn

Environment:

    User Mode -Win32

Revision History:

    Matthew A Felton (Mattfe) July 16 1994
    Added Caching for remote NT printers
    MattFe Jan 1995 CleanUp DeletePrinterConnection ( for memory allocation errors )
    SWilson May 1996 Added RemoteEnumPrinterData & RemoteDeletePrinterData
    SWilson Dec 1996 Added RemoteDeletePrinterDataEx, RemoteGetPrinterDataEx,
                           RemoteSetPrinterDataEx, RemoteEnumPrinterDataEx,
                           RemoteEnumPrinterKey, RemoteDeletePrinterKey

--*/

#include <precomp.h>
#include "TPmgr.hxx"
#pragma hdrstop


DWORD
RpcValidate(
    );

BOOL
RemoteFindFirstPrinterChangeNotification(
   HANDLE hPrinter,
   DWORD fdwFlags,
   DWORD fdwOptions,
   HANDLE hNotify,
   PDWORD pfdwStatus,
   PVOID pvReserved0,
   PVOID pvReserved1);

BOOL
RemoteFindClosePrinterChangeNotification(
   HANDLE hPrinter);

BOOL
RemoteRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PVOID pPrinterNotifyRefresh,
    PVOID* ppPrinterNotifyInfo);

DWORD
RemoteSendRecvBidiData(
    IN  HANDLE                    hPrinter,
    IN  LPCTSTR                   pAction,
    IN  PBIDI_REQUEST_CONTAINER   pReqData,
    OUT PBIDI_RESPONSE_CONTAINER* ppResData
);

LPWSTR
AnsiToUnicodeStringWithAlloc(
    LPSTR   pAnsi
    );



HANDLE  hInst;  /* DLL instance handle, used for resources */

#define MAX_PRINTER_INFO2 1000

HANDLE  hNetApi;
NET_API_STATUS (*pfnNetServerEnum)();
NET_API_STATUS (*pfnNetShareEnum)();
NET_API_STATUS (*pfnNetWkstaUserGetInfo)();
NET_API_STATUS (*pfnNetWkstaGetInfo)();
NET_API_STATUS (*pfnNetServerGetInfo)();
NET_API_STATUS (*pfnNetApiBufferFree)();

WCHAR szPrintProvidorName[80];
WCHAR szPrintProvidorDescription[80];
WCHAR szPrintProvidorComment[80];

WCHAR *szLoggedOnDomain=L"Logged on Domain";
WCHAR *szRegistryConnections=L"Printers\\Connections";
WCHAR *szRegistryPath=NULL;
WCHAR *szRegistryPortNames=L"PortNames";
PWCHAR pszRemoteRegistryPrinters = L"SYSTEM\\CurrentControlSet\\Control\\Print\\Printers\\%ws\\PrinterDriverData";
WCHAR  szMachineName[MAX_COMPUTERNAME_LENGTH+3];
WCHAR *szVersion=L"Version";
WCHAR *szName=L"Name";
WCHAR *szConfigurationFile=L"Configuration File";
WCHAR *szDataFile=L"Data File";
WCHAR *szDriver=L"Driver";
WCHAR *szDevices=L"Devices";
WCHAR *szPrinterPorts=L"PrinterPorts";
WCHAR *szPorts=L"Ports";
WCHAR *szComma = L",";
WCHAR *szRegistryRoot     = L"System\\CurrentControlSet\\Control\\Print";
WCHAR *szMajorVersion     = L"MajorVersion";
WCHAR *szMinorVersion     = L"MinorVersion";

// kernel mode is 2.
DWORD cThisMajorVersion = SPOOLER_VERSION;

DWORD cThisMinorVersion = 0;

BOOL    bRpcPipeCleanup   = FALSE;
BOOL    gbMachineInDomain = FALSE;

SPLCLIENT_INFO_1   gSplClientInfo1;
DWORD              gdwThisGetVersion;

LPWSTR szEnvironment = LOCAL_ENVIRONMENT;

CRITICAL_SECTION SpoolerSection;

//
//  Note indented calls have some Cache Effect.
//

PRINTPROVIDOR PrintProvidor = { CacheOpenPrinter,
                               SetJob,
                               GetJob,
                               EnumJobs,
                               AddPrinter,
                               DeletePrinter,
                                SetPrinter,
                                CacheGetPrinter,
                               EnumPrinters,
                               RemoteAddPrinterDriver,
                               EnumPrinterDrivers,
                                CacheGetPrinterDriver,
                               RemoteGetPrinterDriverDirectory,
                               DeletePrinterDriver,
                               AddPrintProcessor,
                               EnumPrintProcessors,
                               GetPrintProcessorDirectory,
                               DeletePrintProcessor,
                               EnumPrintProcessorDatatypes,
                               StartDocPrinter,
                               StartPagePrinter,
                               WritePrinter,
                               EndPagePrinter,
                               AbortPrinter,
                               ReadPrinter,
                               RemoteEndDocPrinter,
                               AddJob,
                               ScheduleJob,
                                CacheGetPrinterData,
                                SetPrinterData,
                               WaitForPrinterChange,
                                CacheClosePrinter,
                                AddForm,
                                DeleteForm,
                                CacheGetForm,
                                SetForm,
                                CacheEnumForms,
                               EnumMonitors,
                               RemoteEnumPorts,
                               RemoteAddPort,
                               RemoteConfigurePort,
                               RemoteDeletePort,
                               CreatePrinterIC,
                               PlayGdiScriptOnPrinterIC,
                               DeletePrinterIC,
                                AddPrinterConnection,
                                DeletePrinterConnection,
                               PrinterMessageBox,
                               AddMonitor,
                               DeleteMonitor,
                                CacheResetPrinter,
                               NULL,
                               RemoteFindFirstPrinterChangeNotification,
                               RemoteFindClosePrinterChangeNotification,
                               RemoteAddPortEx,
                               NULL,
                               RemoteRefreshPrinterChangeNotification,
                               NULL,
                               NULL,
                               SetPort,
                               RemoteEnumPrinterData,
                               RemoteDeletePrinterData,
                               NULL, // Clustering
                               NULL, // Clustering
                               NULL, // Clustering
                               RemoteSetPrinterDataEx,
                                CacheGetPrinterDataEx,
                                CacheEnumPrinterDataEx,
                                CacheEnumPrinterKey,
                               RemoteDeletePrinterDataEx,
                               RemoteDeletePrinterKey,
                               SeekPrinter,
                               DeletePrinterDriverEx,
                               AddPerMachineConnection,
                               DeletePerMachineConnection,
                               EnumPerMachineConnections,
                               RemoteXcvData,
                               AddPrinterDriverEx,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               RemoteSendRecvBidiData,
                               NULL,
                              };

BOOL
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes
    )
{
    if (dwReason != DLL_PROCESS_ATTACH)
        return TRUE;

    hInst = hModule;

    InitializeCriticalSection(&SpoolerSection);
    DisableThreadLibraryCalls(hModule);

    return TRUE;

    UNREFERENCED_PARAMETER( lpRes );
}

PWCHAR gpSystemDir = NULL;
PWCHAR gpWin32SplDir = NULL;

BOOL
InitializePrintProvidor(
   LPPRINTPROVIDOR pPrintProvidor,
   DWORD    cbPrintProvidor,
   LPWSTR   pFullRegistryPath
)
{
    DWORD           i;
    WCHAR           SystemDir[MAX_PATH];
    DWORD           ReturnValue = TRUE;
    UINT            Index;
    OSVERSIONINFO   OSVersionInfo;
    SYSTEM_INFO     SystemInfo;


    if (!pFullRegistryPath || !*pFullRegistryPath) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    // DbgInit();

    if ( !GetPrintSystemVersion() ) {

        DBGMSG( DBG_WARNING, ("GetPrintSystemVersion ERROR %d\n", GetLastError() ));
        return FALSE;
    }

    if (!(szRegistryPath = AllocSplStr(pFullRegistryPath)))
        return FALSE;

    szPrintProvidorName[0] = L'\0';
    szPrintProvidorDescription[0] = L'\0';
    szPrintProvidorComment[0] = L'\0';

    if (!LoadString(hInst,  IDS_WINDOWS_NT_REMOTE_PRINTERS,
               szPrintProvidorName,
               sizeof(szPrintProvidorName) / sizeof(*szPrintProvidorName)))

        return FALSE;

    if (!LoadString(hInst,  IDS_MICROSOFT_WINDOWS_NETWORK,
               szPrintProvidorDescription,
               sizeof(szPrintProvidorDescription) / sizeof(*szPrintProvidorDescription)))

        return FALSE;

    if (!LoadString(hInst,  IDS_REMOTE_PRINTERS,
               szPrintProvidorComment,
               sizeof(szPrintProvidorComment) / sizeof(*szPrintProvidorComment)))

        return FALSE;

    if ((hNetApi = LoadLibrary(L"netapi32.dll"))) {

        pfnNetServerEnum = (NET_API_STATUS (*)())GetProcAddress(hNetApi, "NetServerEnum");
        pfnNetShareEnum = (NET_API_STATUS (*)())GetProcAddress(hNetApi, "NetShareEnum");
        pfnNetWkstaUserGetInfo = (NET_API_STATUS (*)())GetProcAddress(hNetApi, "NetWkstaUserGetInfo");
        pfnNetWkstaGetInfo = (NET_API_STATUS (*)())GetProcAddress(hNetApi, "NetWkstaGetInfo");
        pfnNetApiBufferFree = (NET_API_STATUS (*)())GetProcAddress(hNetApi, "NetApiBufferFree");
        pfnNetServerGetInfo = (NET_API_STATUS (*)())GetProcAddress(hNetApi, "NetServerGetInfo");

        if ( pfnNetServerEnum       == NULL ||
             pfnNetShareEnum        == NULL ||
             pfnNetWkstaUserGetInfo == NULL ||
             pfnNetWkstaGetInfo     == NULL ||
             pfnNetApiBufferFree    == NULL ||
             pfnNetServerGetInfo    == NULL ) {

            DBGMSG( DBG_WARNING, ("Failed GetProcAddres on Net Api's %d\n", GetLastError() ));
            return FALSE;

        }

    } else {

        DBGMSG(DBG_WARNING, ("Failed LoadLibrary( netapi32.dll ) %d\n", GetLastError() ));
        return FALSE;

    }

    if (!BoolFromHResult(AreWeOnADomain(&gbMachineInDomain))) {

        DBGMSG(DBG_WARNING, ("Failed to determine if we are on a domain (%d).\n", GetLastError()));
        return FALSE;
    }

    memcpy(pPrintProvidor, &PrintProvidor, min(sizeof(PRINTPROVIDOR), cbPrintProvidor));

    QueryTrustedDriverInformation();

    szMachineName[0] = szMachineName[1] = L'\\';

    i = MAX_COMPUTERNAME_LENGTH + 1;

    gdwThisGetVersion = GetVersion();
    GetSystemInfo(&SystemInfo);
    OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVersionInfo);

    if (!GetComputerName(szMachineName+2, &i)   ||
        !GetVersionEx(&OSVersionInfo)           ||
        !(gSplClientInfo1.pMachineName = AllocSplStr(szMachineName)) )
        return FALSE;

    gSplClientInfo1.dwSize          = sizeof(gSplClientInfo1);
    gSplClientInfo1.dwBuildNum      = OSVersionInfo.dwBuildNumber;
    gSplClientInfo1.dwMajorVersion  = cThisMajorVersion;
    gSplClientInfo1.dwMinorVersion  = cThisMinorVersion;
    gSplClientInfo1.pUserName       = NULL;

    gSplClientInfo1.wProcessorArchitecture = SystemInfo.wProcessorArchitecture;


    if ( InitializePortNames() != NO_ERROR )
        return FALSE;

    Index = GetSystemDirectory(SystemDir, COUNTOF(SystemDir));

    if ( Index == 0 ) {

        return FALSE;
    }

    gpSystemDir = AllocSplStr( SystemDir );
    if ( gpSystemDir == NULL ) {
        return FALSE;
    }

    StringCchCopyW(&SystemDir[Index], MAX_PATH - Index, szWin32SplDirectory);

    gpWin32SplDir = AllocSplStr( SystemDir );

    if ( gpWin32SplDir == NULL ) {
        return FALSE;
    }

    if(FAILED(InitOpnPrnThreadPool())) {
        return FALSE;
    }
    return  TRUE;
}


DWORD
InitializePortNames(
)
{
    LONG     Status;
    HKEY     hkeyPath;
    HKEY     hkeyPortNames;
    WCHAR    Buffer[MAX_PATH];
    DWORD    cchBuffer;
    DWORD    i;
    DWORD    dwReturnValue;

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szRegistryPath, 0,
                           KEY_READ, &hkeyPath );

    dwReturnValue = Status;

    if( Status == NO_ERROR ) {

        Status = RegOpenKeyEx( hkeyPath, szRegistryPortNames, 0,
                               KEY_READ, &hkeyPortNames );

        if( Status == NO_ERROR ) {

            i = 0;

            while( Status == NO_ERROR ) {

                cchBuffer = COUNTOF( Buffer );

                Status = RegEnumValue( hkeyPortNames, i, Buffer, &cchBuffer,
                                       NULL, NULL, NULL, NULL );

                if( Status == NO_ERROR )
                    CreatePortEntry( Buffer, &pIniFirstPort );

                i++;
            }

            /* We expect RegEnumKeyEx to return ERROR_NO_MORE_ITEMS
             * when it gets to the end of the keys, so reset the status:
             */
            if( Status == ERROR_NO_MORE_ITEMS )
                Status = NO_ERROR;

            RegCloseKey( hkeyPortNames );

        } else {

            DBGMSG( DBG_INFO, ( "RegOpenKeyEx (%ws) failed: Error = %d\n",
                                szRegistryPortNames, Status ) );
        }

        RegCloseKey( hkeyPath );

    } else {

        DBGMSG( DBG_WARNING, ( "RegOpenKeyEx (%ws) failed: Error = %d\n",
                               szRegistryPath, Status ) );
    }

    if ( dwReturnValue != NO_ERROR ) {
        SetLastError( dwReturnValue );
    }

    return dwReturnValue;
}

BOOL
EnumerateFavouritePrinters(
    LPWSTR  pDomain,
    DWORD   Level,
    DWORD   cbStruct,
    LPDWORD pOffsets,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    HKEY    hClientKey = NULL;
    HKEY    hKey1=NULL;
    DWORD   cPrinters, cbData;
    WCHAR   PrinterName[ MAX_UNC_PRINTER_NAME ];
    DWORD   cReturned, TotalcbNeeded, cbNeeded, cTotalReturned;
    DWORD   Error=0;
    DWORD   BufferSize=cbBuf;
    HANDLE  hPrinter;
    DWORD   Status;
    WCHAR   szBuffer[MAX_PATH];
    HKEY    hPrinterConnectionsKey;

    DBGMSG( DBG_TRACE, ("EnumerateFavouritePrinters called\n"));

    *pcbNeeded = 0;
    *pcReturned = 0;

    hClientKey = GetClientUserHandle(KEY_READ);

    if ( hClientKey == NULL ) {

        DBGMSG( DBG_WARNING, ("EnumerateFavouritePrinters GetClientUserHandle failed error %d\n", GetLastError() ));
        return FALSE;
    }

    Status = RegOpenKeyEx(hClientKey, szRegistryConnections, 0,
                 KEY_READ, &hKey1);

    if ( Status != ERROR_SUCCESS ) {

        RegCloseKey(hClientKey);
        SetLastError( Status );
        DBGMSG( DBG_WARNING, ("EnumerateFavouritePrinters RegOpenKeyEx failed error %d\n", GetLastError() ));
        return FALSE;
    }

    cReturned = cbNeeded = TotalcbNeeded = cTotalReturned = 0;

    for( cPrinters = 0;

         cbData = COUNTOF( PrinterName ),
         RegEnumKeyEx(hKey1,
                      cPrinters,
                      PrinterName,
                      &cbData,
                      NULL, NULL, NULL, NULL) == ERROR_SUCCESS;

         ++cPrinters ){

        //
        // Check if the key belongs to us.
        //
        Status = RegOpenKeyEx( hKey1,
                               PrinterName,
                               0,
                               KEY_READ,
                               &hPrinterConnectionsKey );

        if( Status != ERROR_SUCCESS ){
            continue;
        }

        cbData = sizeof(szBuffer);

        //
        // If there is a Provider value, and it doesn't match win32spl.dll,
        // then fail the call.
        //
        // If the provider value isn't there, succeed for backward
        // compatibility.
        //
        Status = RegQueryValueEx( hPrinterConnectionsKey,
                                  L"Provider",
                                  NULL,
                                  NULL,
                                  (LPBYTE)szBuffer,
                                  &cbData );

        RegCloseKey( hPrinterConnectionsKey );

        //
        // If the key exists but we failed to read it, or the
        // provider entry is incorrect, then don't enumerate it back.
        //
        // For backward compatibility, if the key doesn't exist,
        // we assume it belongs to win32spl.dll.
        //
        if( Status != ERROR_SUCCESS ){
            if( Status != ERROR_FILE_NOT_FOUND ){
                continue;
            }
        } else {

            //
            // Make sure it is NULL terminated
            //
            if (cbData == sizeof(szBuffer))
            {
                szBuffer[COUNTOF(szBuffer) - 1] = L'\0';
            }

            if (_wcsicmp(szBuffer, L"win32spl.dll")) {
                continue;
            }
        }


        FormatRegistryKeyForPrinter(PrinterName, PrinterName, COUNTOF(PrinterName));

        //
        // We need to try to add this name to the name cache. Otherwise the name cache might not
        // recognize it.
        //
        CacheAddName(PrinterName);

        // Do not fail if any of these calls fails, because we want
        // to return whatever we can find.

        if (MyUNCName(PrinterName))  // Roaming profiles can create connections to local printers
            continue;

        if (CacheOpenPrinter(PrinterName, &hPrinter, NULL)) {

            if (CacheGetPrinter(hPrinter, Level, pPrinter, BufferSize, &cbNeeded)) {

                if (Level == 2) {
                    ((PPRINTER_INFO_2)pPrinter)->Attributes |= PRINTER_ATTRIBUTE_NETWORK;
                    ((PPRINTER_INFO_2)pPrinter)->Attributes &= ~PRINTER_ATTRIBUTE_LOCAL;
                }
                else if (Level == 5) {
                    ((PPRINTER_INFO_5)pPrinter)->Attributes |= PRINTER_ATTRIBUTE_NETWORK;
                    ((PPRINTER_INFO_5)pPrinter)->Attributes &= ~PRINTER_ATTRIBUTE_LOCAL;
                }

                cTotalReturned++;

                pPrinter += cbStruct;

                if (cbNeeded <= BufferSize)
                    BufferSize -= cbNeeded;

                TotalcbNeeded += cbNeeded;

            } else {

                DWORD Error;

                if ((Error = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) {

                    if (cbNeeded <= BufferSize)
                        BufferSize -= cbNeeded;

                    TotalcbNeeded += cbNeeded;

                } else {

                    DBGMSG( DBG_WARNING, ( "GetPrinter( %ws ) failed: Error %d\n",
                                           PrinterName, Error ) );
                }
            }

            CacheClosePrinter(hPrinter);

        } else {

            DBGMSG( DBG_WARNING, ( "CacheOpenPrinter( %ws ) failed: Error %d\n",
                                   PrinterName, GetLastError( ) ) );
        }
    }

    RegCloseKey(hKey1);

    if (hClientKey) {
        RegCloseKey(hClientKey);
    }

    *pcbNeeded = TotalcbNeeded;

    *pcReturned = cTotalReturned;

    if (TotalcbNeeded > cbBuf) {

        DBGMSG( DBG_TRACE, ("EnumerateFavouritePrinters returns ERROR_INSUFFICIENT_BUFFER\n"));
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;

    }

    return TRUE;

}

DWORD
RpcValidate(
    VOID
    )

/*++

Routine Description:

    Validates that the call came from local machine. We do not want this function
    to call IsLocalCall in spoolss. IsLocalCall does a CheckTokenMembership to
    look at the network sid. This breaks scenarios like the following:
    W2k client prints to W2k server. The port monitor is Intel Network.
    Port Monitor. The start doc call originating from the client (thread token
    has the network bit set) will try to do OpenPrinter on the port name:
    \\intel-box\port in the spooler on the server. The call gets routed
    to win32spl. The line below will allow the call to get through.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS           - Call was local and we should RPC out.

    ERROR_INVALID_PARAMETER - Call was not local and shouldn't RPC out
                              since we may get into an infinite loop.

--*/

{
    return IsNamedPipeRpcCall() ? ERROR_INVALID_PARAMETER : ERROR_SUCCESS;
}


#define SIZEOFPARAM1    1
#define SIZEOFPARAM2    3
#define SIZEOFASCIIZ    1
#define SAFECOUNT               (SIZEOFPARAM1 + SIZEOFPARAM2 + SIZEOFASCIIZ)

BOOL
EnumerateDomainPrinters(
    LPWSTR  pDomain,
    DWORD   Level,
    DWORD   cbStruct,
    LPDWORD pOffsets,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   i, j, NoReturned, Total, OuterLoopCount;
    DWORD   rc = 0;
    PSERVER_INFO_101 pserver_info_101;
    DWORD   ReturnValue=FALSE;
    WCHAR   string[3*MAX_PATH];
    PPRINTER_INFO_1    pPrinterInfo1;
    DWORD   cb=cbBuf;
    LPWSTR  SourceStrings[sizeof(PRINTER_INFO_1)/sizeof(LPWSTR)];
    LPBYTE  pEnd;
    DWORD   ServerType;
    BOOL    bServerFound = FALSE, bMarshall;

    DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters called\n"));

    string[0] = string[1] = '\\';

    *pcbNeeded = *pcReturned = 0;

    if (!(*pfnNetServerEnum)(NULL, 101, (LPBYTE *)&pserver_info_101, -1,
                             &NoReturned, &Total,
                             SV_TYPE_PRINTQ_SERVER | SV_TYPE_WFW,
                             pDomain, NULL)) {

        DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters NetServerEnum returned %d\n", NoReturned));

        //
        //  First Look try NT Servers, then if that Fails Look at the WorkStations
        //

        for ( ServerType = ( SV_TYPE_SERVER_NT | SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL ), OuterLoopCount = 0;
              bServerFound == FALSE && OuterLoopCount < 2;
              ServerType = SV_TYPE_NT, OuterLoopCount++ ) {

            //
            //  Loop Through looking for a print server that will return a good browse list
            //

            for ( i = 0; i < NoReturned; i++ ) {

                if ( pserver_info_101[i].sv101_type & ServerType ) {

                    StringCchCopyW(&string[2], COUNTOF(string) - 2, pserver_info_101[i].sv101_name );

                    RpcTryExcept {

                        DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters Trying %ws ENUM_NETWORK type %x\n", string, ServerType ));

                        if ( !(rc = RpcValidate()) &&

                             !(rc = RpcEnumPrinters(PRINTER_ENUM_NETWORK,
                                                    string,
                                                    1, pPrinter,
                                                    cbBuf, pcbNeeded,
                                                    pcReturned) ,
                               rc = UpdateBufferSize(PrinterInfo1Fields,
                                                     sizeof(PRINTER_INFO_1),
                                                     pcbNeeded,
                                                     cbBuf,
                                                     rc,
                                                     pcReturned)) ) {

                            if ( bMarshall =  MarshallUpStructuresArray(pPrinter, *pcReturned, PrinterInfo1Fields,
                                                                        sizeof(PRINTER_INFO_1), RPC_CALL)) {

                                //
                                // pPrinter must point after lats structure in array.
                                // More structures needs to be added by the other providers.
                                //
                                pPrinter += (*pcReturned) * cbStruct;
                            }

                            if (!bMarshall) {
                                bServerFound = TRUE;
                                break;
                            }

                            //
                            //  Only return success if we found some data.
                            //

                            if ( *pcReturned != 0 ) {

                                DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters %ws ENUM_NETWORK Success %d returned\n", string, *pcReturned ));

                                bServerFound = TRUE;
                                break;
                            }

                        } else if (rc == ERROR_INSUFFICIENT_BUFFER) {

                            DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters %ws ENUM_NETWORK ERROR_INSUFFICIENT_BUFFER\n", string ));

                            bServerFound = TRUE;
                            break;
                        }

                    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
                        DBGMSG( DBG_TRACE,( "Failed to connect to Print Server%ws\n",
                                pserver_info_101[i].sv101_name ) );
                    } RpcEndExcept

                } else {

                    DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters %ws type %x not type %x\n", pserver_info_101[i].sv101_name, pserver_info_101[i].sv101_type, ServerType));
                }
            }
        }

        pPrinterInfo1 = (PPRINTER_INFO_1)pPrinter;

        pEnd = (LPBYTE)pPrinterInfo1 + cb - *pcbNeeded;

        for ( i = 0; i < NoReturned; i++ ) {

            DWORD cchString = COUNTOF(string);

            rc = StrNCatBuff(string,
                             cchString,
                             szPrintProvidorName,
                             L"!",
                             pDomain ? pDomain : L"",
                             L"!\\\\",
                             pserver_info_101[i].sv101_name,
                             NULL);

            if (rc == ERROR_SUCCESS)
            {
                cb = wcslen(pserver_info_101[i].sv101_name)*sizeof(WCHAR) + sizeof(WCHAR) +
                     wcslen(string)*sizeof(WCHAR) + sizeof(WCHAR) +
                     wcslen(szLoggedOnDomain)*sizeof(WCHAR) + sizeof(WCHAR) +
                     sizeof(PRINTER_INFO_1);

                (*pcbNeeded) += cb;

                if ( cbBuf >= *pcbNeeded ) {

                    (*pcReturned)++;

                    pPrinterInfo1->Flags = PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON3;

                    SourceStrings[0] = pserver_info_101[i].sv101_name;
                    SourceStrings[1] = string;
                    SourceStrings[2] = szLoggedOnDomain;

                    pEnd = PackStrings( SourceStrings, (LPBYTE)pPrinterInfo1,
                                        PrinterInfo1Strings, pEnd );

                    pPrinterInfo1++;
                }
            }
            else
            {
                (*pfnNetApiBufferFree)((LPVOID)pserver_info_101);
                SetLastError(rc);
                return FALSE;
            }
        }

        (*pfnNetApiBufferFree)((LPVOID)pserver_info_101);

        if ( cbBuf < *pcbNeeded ) {

            DBGMSG( DBG_TRACE, ("EnumerateDomainPrinters returns ERROR_INSUFFICIENT_BUFFER\n"));
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
EnumerateDomains(
    PRINTER_INFO_1 *pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned,
    LPBYTE  pEnd
)
{
    DWORD   i, NoReturned, Total;
    DWORD   cb;
    SERVER_INFO_100 *pNames;
    PWKSTA_INFO_100 pWkstaInfo = NULL;
    LPWSTR  SourceStrings[sizeof(PRINTER_INFO_1)/sizeof(LPWSTR)];
    WCHAR   string[3*MAX_PATH];

    DBGMSG( DBG_TRACE, ("EnumerateDomains pPrinter %x cbBuf %d pcbNeeded %x pcReturned %x pEnd %x\n",
                         pPrinter, cbBuf, pcbNeeded, pcReturned, pEnd ));

    *pcReturned = 0;
    *pcbNeeded = 0;

    if (!(*pfnNetServerEnum)(NULL, 100, (LPBYTE *)&pNames, -1,
                             &NoReturned, &Total, SV_TYPE_DOMAIN_ENUM,
                             NULL, NULL)) {

        DBGMSG( DBG_TRACE, ("EnumerateDomains - NetServerEnum returned %d\n", NoReturned));

        (*pfnNetWkstaGetInfo)(NULL, 100, (LPBYTE *)&pWkstaInfo);

        DBGMSG( DBG_TRACE, ("EnumerateDomains - NetWkstaGetInfo returned pWkstaInfo %x\n", pWkstaInfo));

        for (i=0; i<NoReturned; i++) {

            StrNCatBuff(string,
                        COUNTOF(string),
                        szPrintProvidorName,
                        L"!",
                        pNames[i].sv100_name,
                        NULL);

            cb = wcslen(pNames[i].sv100_name)*sizeof(WCHAR) + sizeof(WCHAR) +
                 wcslen(string)*sizeof(WCHAR) + sizeof(WCHAR) +
                 wcslen(szLoggedOnDomain)*sizeof(WCHAR) + sizeof(WCHAR) +
                 sizeof(PRINTER_INFO_1);

            (*pcbNeeded)+=cb;

            if (cbBuf >= *pcbNeeded) {

                (*pcReturned)++;

                pPrinter->Flags = PRINTER_ENUM_CONTAINER | PRINTER_ENUM_ICON2;

                /* Set the PRINTER_ENUM_EXPAND flag for the user's logon domain
                 */
                if (!lstrcmpi(pNames[i].sv100_name,
                             pWkstaInfo->wki100_langroup))
                    pPrinter->Flags |= PRINTER_ENUM_EXPAND;

                SourceStrings[0]=pNames[i].sv100_name;
                SourceStrings[1]=string;
                SourceStrings[2]=szLoggedOnDomain;

                pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinter,
                                   PrinterInfo1Strings, pEnd);

                pPrinter++;
            }
        }

        (*pfnNetApiBufferFree)((LPVOID)pNames);
        (*pfnNetApiBufferFree)((LPVOID)pWkstaInfo);

        if (cbBuf < *pcbNeeded) {

            DBGMSG( DBG_TRACE, ("EnumerateDomains returns ERROR_INSUFFICIENT_BUFFER\n"));
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
            return FALSE;
        }

        return TRUE;
    }

    return TRUE;
}

BOOL
EnumeratePrintShares(
    LPWSTR  pDomain,
    LPWSTR  pServer,
    DWORD   Level,
    DWORD   cbStruct,
    LPDWORD pOffsets,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   i, NoReturned, Total;
    DWORD   cb;
    SHARE_INFO_1 *pNames;
    LPWSTR  SourceStrings[sizeof(PRINTER_INFO_1)/sizeof(LPWSTR)];
    WCHAR   string[MAX_UNC_PRINTER_NAME] = {0};
    PRINTER_INFO_1 *pPrinterInfo1 = (PRINTER_INFO_1 *)pPrinter;
    LPBYTE  pEnd=pPrinter+cbBuf;
    WCHAR   FullName[MAX_UNC_PRINTER_NAME] = {0};

    DBGMSG( DBG_TRACE, ("EnumeratePrintShares\n"));

    *pcReturned = 0;
    *pcbNeeded = 0;

    if (!(*pfnNetShareEnum)(pServer, 1, (LPBYTE *)&pNames, -1,
                             &NoReturned, &Total, NULL)) {

        DBGMSG( DBG_TRACE, ("EnumeratePrintShares NetShareEnum returned %d\n", NoReturned));

        for (i=0; i<NoReturned; i++) {

            if (pNames[i].shi1_type == STYPE_PRINTQ) {

                DWORD dwRet;

                if(((dwRet = StrNCatBuff(string ,
                                         MAX_UNC_PRINTER_NAME,
                                         pNames[i].shi1_netname,
                                         L",",
                                         pNames[i].shi1_remark,
                                         NULL
                                        )) != ERROR_SUCCESS) ||
                    ((dwRet = StrNCatBuff(FullName,
                                          MAX_UNC_PRINTER_NAME,
                                          pServer,
                                          L"\\",
                                          pNames[i].shi1_netname,
                                          NULL
                                         )) != ERROR_SUCCESS))
                {
                    SetLastError(dwRet);
                    return(FALSE);
                }

                cb = wcslen(FullName)*sizeof(WCHAR) + sizeof(WCHAR) +
                     wcslen(string)*sizeof(WCHAR) + sizeof(WCHAR) +
                     wcslen(szLoggedOnDomain)*sizeof(WCHAR) + sizeof(WCHAR) +
                     sizeof(PRINTER_INFO_1);

                (*pcbNeeded)+=cb;

                if (cbBuf >= *pcbNeeded) {

                    (*pcReturned)++;

                    pPrinterInfo1->Flags = PRINTER_ENUM_ICON8;

                    SourceStrings[0]=string;
                    SourceStrings[1]=FullName;
                    SourceStrings[2]=szLoggedOnDomain;

                    pEnd = PackStrings(SourceStrings, (LPBYTE)pPrinterInfo1,
                                       PrinterInfo1Strings, pEnd);

                    pPrinterInfo1++;
                }
            }
        }

        (*pfnNetApiBufferFree)((LPVOID)pNames);

        if ( cbBuf < *pcbNeeded ) {

            DBGMSG( DBG_TRACE, ("EnumeratePrintShares returns ERROR_INSUFFICIENT_BUFFER\n"));
            SetLastError( ERROR_INSUFFICIENT_BUFFER );
            return FALSE;
        }

        return TRUE;
    }

    return TRUE;
}

BOOL
EnumPrinters(
    DWORD   Flags,
    LPWSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue = FALSE;
    DWORD   cbStruct, cb;
    DWORD   *pOffsets;
    FieldInfo *pFieldInfo;
    DWORD   NoReturned=0, i, rc;
    LPBYTE  pKeepPrinter = pPrinter;
    BOOL    OutOfMemory = FALSE;
    PPRINTER_INFO_1 pPrinter1=(PPRINTER_INFO_1)pPrinter;
    PWSTR   pszFullName = NULL;
    WCHAR   *pDomain, *pServer;


    DBGMSG( DBG_TRACE, ("EnumPrinters Flags %x pName %x Level %d pPrinter %x cbBuf %d pcbNeeded %x pcReturned %x\n",
                         Flags, Name, Level, pPrinter, cbBuf, pcbNeeded, pcReturned ));

    *pcReturned = 0;
    *pcbNeeded = 0;

    switch (Level) {

    case STRESSINFOLEVEL:
        pOffsets = PrinterInfoStressOffsets;
        pFieldInfo = PrinterInfoStressFields;
        cbStruct = sizeof(PRINTER_INFO_STRESS);
        break;

    case 1:
        pOffsets = PrinterInfo1Offsets;
        pFieldInfo = PrinterInfo1Fields;
        cbStruct = sizeof(PRINTER_INFO_1);
        break;

    case 2:
        pOffsets = PrinterInfo2Offsets;
        pFieldInfo = PrinterInfo2Fields;
        cbStruct = sizeof(PRINTER_INFO_2);
        break;

    case 4:

        //
        // There are no local printers in win32spl, and connections
        // are handled by the router.
        //
        return TRUE;

    case 5:
        pOffsets = PrinterInfo5Offsets;
        pFieldInfo = PrinterInfo5Fields;
        cbStruct = sizeof(PRINTER_INFO_5);
        break;

    default:
        SetLastError( ERROR_INVALID_LEVEL );
        DBGMSG( DBG_TRACE, ("EnumPrinters failed ERROR_INVALID_LEVEL\n"));
        return FALSE;
    }

    if ( Flags & PRINTER_ENUM_NAME ) {

        if (!Name && (Level == 1)) {

            LPWSTR   SourceStrings[sizeof(PRINTER_INFO_1)/sizeof(LPWSTR)];
            LPWSTR   *pSourceStrings=SourceStrings;

            cb = wcslen(szPrintProvidorName)*sizeof(WCHAR) + sizeof(WCHAR) +
                 wcslen(szPrintProvidorDescription)*sizeof(WCHAR) + sizeof(WCHAR) +
                 wcslen(szPrintProvidorComment)*sizeof(WCHAR) + sizeof(WCHAR) +
                 sizeof(PRINTER_INFO_1);

            *pcbNeeded=cb;

            if ( cb > cbBuf ) {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                DBGMSG( DBG_TRACE, ("EnumPrinters returns ERROR_INSUFFICIENT_BUFFER\n"));
                return FALSE;
            }

            *pcReturned = 1;

            pPrinter1->Flags = PRINTER_ENUM_CONTAINER |
                               PRINTER_ENUM_ICON1 |
                               PRINTER_ENUM_EXPAND;

            *pSourceStrings++=szPrintProvidorDescription;
            *pSourceStrings++=szPrintProvidorName;
            *pSourceStrings++=szPrintProvidorComment;

            PackStrings( SourceStrings, pPrinter, PrinterInfo1Strings,
                         pPrinter+cbBuf );

            DBGMSG( DBG_TRACE, ("EnumPrinters returns Success just Provider Info\n"));

            return TRUE;
        }

        if (Name && *Name && (Level == 1)) {

            if (!(pszFullName = AllocSplStr(Name)))
                return FALSE;

            pServer = NULL;
            pDomain = wcschr(pszFullName, L'!');

            if (pDomain) {
                *pDomain++ = 0;

                pServer = wcschr(pDomain, L'!');

                if (pServer)
                    *pServer++ = 0;
            }

            if (!lstrcmpi(pszFullName, szPrintProvidorName)) {
                ReturnValue = !pServer ? !pDomain ?  EnumerateDomains((PRINTER_INFO_1 *)pPrinter,
                                                                       cbBuf, pcbNeeded,
                                                                       pcReturned, pPrinter+cbBuf)
                                                  :  EnumerateDomainPrinters(pDomain,
                                                                             Level, cbStruct,
                                                                             pOffsets, pPrinter, cbBuf,
                                                                             pcbNeeded, pcReturned)
                                       : EnumeratePrintShares(pDomain, pServer, Level,
                                                              cbStruct, pOffsets, pPrinter,
                                                              cbBuf, pcbNeeded, pcReturned);
               FreeSplMem(pszFullName);
               return(ReturnValue);
            }
            FreeSplMem(pszFullName);
        }

        if ( !VALIDATE_NAME(Name) || MyUNCName(Name)) {
            SetLastError(ERROR_INVALID_NAME);
            return FALSE;
        }

        if (pPrinter)
            memset(pPrinter, 0, cbBuf);

        RpcTryExcept {

            if ( (rc = RpcValidate()) ||

                 (rc = RpcEnumPrinters(Flags,
                                        Name,
                                        Level, pPrinter,
                                        cbBuf, pcbNeeded,
                                        pcReturned),
                  rc = UpdateBufferSize(pFieldInfo,
                                        cbStruct,
                                        pcbNeeded,
                                        cbBuf,
                                        rc,
                                        pcReturned)) ) {

                SetLastError(rc);
                // ReturnValue = FALSE;
                return FALSE;

            } else {

                ReturnValue = TRUE;

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            DBGMSG( DBG_TRACE, ( "Failed to connect to Print Server%ws\n", Name ) );

            *pcbNeeded = 0;
            *pcReturned = 0;
            SetLastError(RpcExceptionCode());
            // ReturnValue = FALSE;
            return FALSE;

        } RpcEndExcept


        if(! MarshallUpStructuresArray(pPrinter, *pcReturned, pFieldInfo, cbStruct, RPC_CALL) ) {
            return FALSE;
        }

         i = *pcReturned;

        while (i--) {

            if (Level == 2) {
                ((PPRINTER_INFO_2)pPrinter)->Attributes |=
                                            PRINTER_ATTRIBUTE_NETWORK;
                ((PPRINTER_INFO_2)pPrinter)->Attributes &=
                                                ~PRINTER_ATTRIBUTE_LOCAL;
            }

            if (Level == 5) {
                ((PPRINTER_INFO_5)pPrinter)->Attributes |=
                                            PRINTER_ATTRIBUTE_NETWORK;
                ((PPRINTER_INFO_5)pPrinter)->Attributes &=
                                                ~PRINTER_ATTRIBUTE_LOCAL;
            }
            pPrinter += cbStruct;
        }


    } else if (Flags & PRINTER_ENUM_REMOTE) {

        if (Level != 1) {

            SetLastError(ERROR_INVALID_LEVEL);
            ReturnValue = FALSE;

        } else {

            ReturnValue = EnumerateDomainPrinters(NULL, Level,
                                                  cbStruct, pOffsets,
                                                  pPrinter, cbBuf,
                                                  pcbNeeded, pcReturned);
        }

    } else if (Flags & PRINTER_ENUM_CONNECTIONS) {

        ReturnValue = EnumerateFavouritePrinters(NULL, Level,
                                                 cbStruct, pOffsets,
                                                 pPrinter, cbBuf,
                                                 pcbNeeded, pcReturned);
    }

    return ReturnValue;
}


BOOL
RemoteOpenPrinter(
   LPWSTR   pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTS pDefault,
   BOOL     CallLMOpenPrinter
)
{
    DWORD               RpcReturnValue;
    BOOL                ReturnValue = FALSE;
    DEVMODE_CONTAINER   DevModeContainer;
    SPLCLIENT_CONTAINER SplClientContainer;
    SPLCLIENT_INFO_1    SplClientInfo;
    HANDLE              hPrinter;
    PWSPOOL             pSpool;
    DWORD               Status = 0;
    DWORD               RpcError = 0;
    DWORD               dwIndex;
    WCHAR               UserName[MAX_PATH+1];
    HANDLE              hSplPrinter, hIniSpooler, hDevModeChgInfo;

    if ( !VALIDATE_NAME(pPrinterName)   ||
         MyUNCName(pPrinterName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    // enable named pipe timeouts

    if (bRpcPipeCleanup == FALSE) {
        EnterSplSem();
        if (bRpcPipeCleanup == FALSE) {
            bRpcPipeCleanup = TRUE;
            LeaveSplSem();
            (VOID)RpcMgmtEnableIdleCleanup();
        } else {
            LeaveSplSem();
        }
    }

    if (pDefault && pDefault->pDevMode) {

        DevModeContainer.cbBuf = pDefault->pDevMode->dmSize +
                                 pDefault->pDevMode->dmDriverExtra;
        DevModeContainer.pDevMode = (LPBYTE)pDefault->pDevMode;

    } else {

        DevModeContainer.cbBuf = 0;
        DevModeContainer.pDevMode = NULL;
    }


    if ( CallLMOpenPrinter ) {

        //
        // Now check if we have an entry in the
        // downlevel cache. We don't want to hit the wire, search the whole net
        // and fail if we know that the printer is LM. if the printer is LM
        // try and succeed
        //

        EnterSplSem();

        dwIndex = FindEntryinWin32LMCache(pPrinterName);

        LeaveSplSem();

        if (dwIndex != -1) {
            ReturnValue = LMOpenPrinter(pPrinterName, phPrinter, pDefault);
            if (ReturnValue) {
                return  TRUE ;
            }
            //
            // Delete Entry in Cache

            EnterSplSem();
            DeleteEntryfromWin32LMCache(pPrinterName);
            LeaveSplSem();
        }
    }

    CopyMemory((LPBYTE)&SplClientInfo,
               (LPBYTE)&gSplClientInfo1,
               sizeof(SplClientInfo));

    dwIndex  = sizeof(UserName)/sizeof(UserName[0]) - 1;
    if ( !GetUserName(UserName, &dwIndex) ) {

        goto Cleanup;
    }

    SplClientInfo.pUserName = UserName;
    SplClientContainer.ClientInfo.pClientInfo1  = &SplClientInfo;
    SplClientContainer.Level                    = 1;

    RpcTryExcept {

        EnterSplSem();
        pSpool = AllocWSpool();
        LeaveSplSem();

        if ( pSpool != NULL ) {

            pSpool->pName = AllocSplStr( pPrinterName );

            if ( pSpool->pName != NULL ) {

                pSpool->Status = Status;

                if ( CopypDefaultTopSpool( pSpool, pDefault ) ) {

                    RpcReturnValue = RpcValidate();

                    if ( RpcReturnValue == ERROR_SUCCESS )
                        RpcReturnValue = RpcOpenPrinterEx(
                                            pPrinterName,
                                            &hPrinter,
                                            pDefault ? pDefault->pDatatype
                                                     : NULL,
                                            &DevModeContainer,
                                            pDefault ? pDefault->DesiredAccess
                                                     : 0,
                                            &SplClientContainer);

                    if (RpcReturnValue) {

                        SetLastError(RpcReturnValue);

                    } else {

                        pSpool->RpcHandle = hPrinter;
                        *phPrinter = (HANDLE)pSpool;
                        ReturnValue = TRUE;
                    }
                }
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        RpcError = RpcExceptionCode();
    } RpcEndExcept;

    if ( RpcError == RPC_S_PROCNUM_OUT_OF_RANGE ) {

        RpcError = 0;

        if ( pDefault && pDefault->pDevMode ) {

            DevModeContainer.cbBuf = 0;
            DevModeContainer.pDevMode = NULL;

            if ( OpenCachePrinterOnly(pPrinterName, &hPrinter, &hIniSpooler, NULL, FALSE) ) {

                hDevModeChgInfo = LoadDriverFiletoConvertDevmodeFromPSpool(hPrinter);
                if ( hDevModeChgInfo ) {

                    (VOID)CallDrvDevModeConversion(hDevModeChgInfo,
                                                   pPrinterName,
                                                   (LPBYTE)pDefault->pDevMode,
                                                   &DevModeContainer.pDevMode,
                                                   &DevModeContainer.cbBuf,
                                                   CDM_CONVERT351,
                                                   TRUE);

                    UnloadDriverFile(hDevModeChgInfo);
                }

                CacheClosePrinter(hPrinter);
            }
        }

        RpcTryExcept {

            RpcReturnValue = RpcOpenPrinter(pPrinterName,
                                            &hPrinter,
                                            pDefault ? pDefault->pDatatype
                                                     : NULL,
                                            &DevModeContainer,
                                            pDefault ? pDefault->DesiredAccess
                                                     : 0);

            if (RpcReturnValue) {

                SetLastError(RpcReturnValue);
            } else {

                pSpool->RpcHandle = hPrinter;
                pSpool->bNt3xServer = TRUE;
                *phPrinter = (HANDLE)pSpool;
                ReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            RpcError = RpcExceptionCode();
            DBGMSG(DBG_WARNING,("RpcOpenPrinter exception %d\n", RpcError));
        } RpcEndExcept;
    }

    if ( RpcError ) {

        SetLastError(RpcError);
    }

    if ( ReturnValue == FALSE && pSpool != NULL ) {

        EnterSplSem();
        FreepSpool( pSpool );
        LeaveSplSem();
    }

    if ( (RpcError == RPC_S_SERVER_UNAVAILABLE) && CallLMOpenPrinter ) {

        ReturnValue = LMOpenPrinter(pPrinterName, phPrinter, pDefault);

        if (ReturnValue) {

            EnterSplSem();
            AddEntrytoWin32LMCache(pPrinterName);
            LeaveSplSem();
        }
    }

    if ( !ReturnValue ) {

        DBGMSG(DBG_TRACE,
               ("RemoteOpenPrinter %ws failed %d\n",
                pPrinterName, GetLastError() ));


    }

Cleanup:

    if ( DevModeContainer.pDevMode &&
         DevModeContainer.pDevMode != (LPBYTE)pDefault->pDevMode ) {

        FreeSplMem(DevModeContainer.pDevMode);
    }

    return ReturnValue;
}


BOOL PrinterConnectionExists(
    LPWSTR pPrinterName
)
{
    HKEY    hClientKey      = NULL;
    HKEY    hKeyConnections = NULL;
    HKEY    hKeyPrinter     = NULL;
    BOOL    ConnectionFound = FALSE;
    DWORD   Status;

    if (pPrinterName &&
        (hClientKey = GetClientUserHandle(KEY_READ)))
    {
        if ((Status = RegOpenKeyEx(hClientKey,
                                   szRegistryConnections,
                                   0,
                                   KEY_READ,
                                   &hKeyConnections)) == ERROR_SUCCESS)
        {
             LPWSTR pszBuffer = NULL;
             DWORD  cchBuffer = wcslen(pPrinterName) + 1;
             LPWSTR pKeyName  = NULL;

             if (pszBuffer = AllocSplMem(cchBuffer * sizeof(WCHAR)))
             {
                 pKeyName = FormatPrinterForRegistryKey(pPrinterName, pszBuffer, cchBuffer);

                 if (RegOpenKeyEx(hKeyConnections,
                                  pKeyName,
                                  REG_OPTION_RESERVED,
                                  KEY_READ,
                                  &hKeyPrinter) == ERROR_SUCCESS)
                 {
                    RegCloseKey(hKeyPrinter);
                    ConnectionFound = TRUE;
                 }

                 FreeSplMem(pszBuffer);
             }
             else
             {
                 DBGMSG(DBG_WARNING, ("PrinterConnectionExists AllocMem failed Error %d\n", GetLastError()));
             }

             RegCloseKey(hKeyConnections);
        }
        else
        {
            DBGMSG(DBG_WARNING, ("RegOpenKeyEx failed: %ws Error %d\n", szRegistryConnections ,Status));
        }

        RegCloseKey(hClientKey);
    }

    return ConnectionFound;
}


BOOL
RemoteResetPrinter(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTS pDefault
)
{
    BOOL  ReturnValue;
    DEVMODE_CONTAINER    DevModeContainer;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    DBGMSG(DBG_TRACE, ("ResetPrinter\n"));

    SYNCRPCHANDLE( pSpool );

    if (pDefault && pDefault->pDevMode)
    {
        DevModeContainer.cbBuf = pDefault->pDevMode->dmSize +
                                 pDefault->pDevMode->dmDriverExtra;
        DevModeContainer.pDevMode = (LPBYTE)pDefault->pDevMode;
    }
    else
    {
        DevModeContainer.cbBuf = 0;
        DevModeContainer.pDevMode = NULL;
    }

    RpcTryExcept {

        if ( ReturnValue = RpcResetPrinter(pSpool->RpcHandle,
                                           pDefault ? pDefault->pDatatype : NULL,
                                           &DevModeContainer) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
SetJob(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
)
{
    BOOL  ReturnValue;
    GENERIC_CONTAINER   GenericContainer;
    GENERIC_CONTAINER *pGenericContainer;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (pJob) {

                GenericContainer.Level = Level;
                GenericContainer.pData = pJob;
                pGenericContainer = &GenericContainer;

            } else

                pGenericContainer = NULL;

            //
            // JOB_CONTROL_DELETE was added in NT 4.0
            //
            if ( pSpool->bNt3xServer && Command == JOB_CONTROL_DELETE )
                Command = JOB_CONTROL_CANCEL;

            if ( ReturnValue = RpcSetJob(pSpool->RpcHandle, JobId,
                                         (JOB_CONTAINER *)pGenericContainer,
                                          Command) ) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMSetJob(hPrinter, JobId, Level, pJob, Command);

    return ReturnValue;
}

BOOL
GetJob(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
)
{
    BOOL  ReturnValue = FALSE;
    FieldInfo *pFieldInfo;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;
    SIZE_T cbStruct;
    DWORD  cReturned = 1;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        switch (Level) {

        case 1:
            pFieldInfo = JobInfo1Fields;
            cbStruct = sizeof(JOB_INFO_1);
            break;

        case 2:
            pFieldInfo = JobInfo2Fields;
            cbStruct = sizeof(JOB_INFO_2);
            break;

        case 3:
            pFieldInfo = JobInfo3Fields;
            cbStruct = sizeof(JOB_INFO_3);
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        RpcTryExcept {

            if (pJob)
                memset(pJob, 0, cbBuf);

            if ( ReturnValue = RpcGetJob(pSpool->RpcHandle, JobId, Level, pJob,
                                         cbBuf, pcbNeeded),

                 ReturnValue = UpdateBufferSize(pFieldInfo,
                                                 cbStruct,
                                                 pcbNeeded,
                                                 cbBuf,
                                                 ReturnValue,
                                                 &cReturned)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                if (pJob) {
                    ReturnValue =  MarshallUpStructure(pJob, pFieldInfo, cbStruct, RPC_CALL);
                }
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());

            //
            // This will be thrown by the server if a cbBuf > 1 Meg is
            // passed across the wire.
            //
            SPLASSERT( GetLastError() != ERROR_INVALID_USER_BUFFER );
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMGetJob(hPrinter, JobId, Level, pJob, cbBuf, pcbNeeded);

    return ReturnValue;
}

BOOL
EnumJobs(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD    ReturnValue, i, cbStruct;
    FieldInfo *pFieldInfo;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        switch (Level) {

        case 1:
            pFieldInfo = JobInfo1Fields;
            cbStruct = sizeof(JOB_INFO_1);
            break;

        case 2:
            pFieldInfo = JobInfo2Fields;
            cbStruct = sizeof(JOB_INFO_2);
            break;

        case 3:
            pFieldInfo = JobInfo3Fields;
            cbStruct = sizeof(JOB_INFO_3);
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        RpcTryExcept {

            if (pJob)
                memset(pJob, 0, cbBuf);

            if (ReturnValue = RpcEnumJobs(pSpool->RpcHandle,
                                          FirstJob, NoJobs,
                                          Level, pJob,
                                          cbBuf, pcbNeeded,
                                          pcReturned) ,

                ReturnValue = UpdateBufferSize(pFieldInfo,
                                               cbStruct,
                                               pcbNeeded,
                                               cbBuf,
                                               ReturnValue,
                                               pcReturned))
            {
                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            }
            else
            {
                ReturnValue = TRUE;

                if(! MarshallUpStructuresArray(pJob, *pcReturned, pFieldInfo, cbStruct, RPC_CALL) ) {
                    return FALSE;
                }

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMEnumJobs(hPrinter, FirstJob, NoJobs, Level, pJob, cbBuf,
                          pcbNeeded, pcReturned);

    return (BOOL)ReturnValue;
}

HANDLE
AddPrinter(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
)
{
    DWORD               ReturnValue;
    PRINTER_CONTAINER   PrinterContainer;
    DEVMODE_CONTAINER   DevModeContainer;
    SECURITY_CONTAINER  SecurityContainer;
    HANDLE              hPrinter = NULL;
    PWSPOOL             pSpool = NULL;
    PWSTR               pScratchBuffer = NULL;
    PWSTR               pCopyPrinterName = NULL;
    SPLCLIENT_CONTAINER SplClientContainer;
    SPLCLIENT_INFO_1    SplClientInfo;
    WCHAR               UserName[MAX_PATH+1];
    DWORD               dwRpcError = 0;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }


    CopyMemory((LPBYTE)&SplClientInfo,
               (LPBYTE)&gSplClientInfo1,
               sizeof(SplClientInfo));

    //
    // Don't pass in user name for browsing level because this
    // causes LSA to chew up a lot of CPU.  This isn't needed anyway
    // because an AddPrinter( LEVEL_1 ) call never returns a print
    // handle.
    //
    if( Level == 1 ){

        UserName[0] = 0;

    } else {

        DWORD dwSize = sizeof(UserName)/sizeof(UserName[0]) - 1;

        if ( !GetUserName(UserName, &dwSize) ) {
            return FALSE;
        }
    }

    PrinterContainer.Level = Level;
    PrinterContainer.PrinterInfo.pPrinterInfo1 = (PPRINTER_INFO_1)pPrinter;

    SplClientInfo.pUserName                     = UserName;
    SplClientContainer.Level                    = 1;
    SplClientContainer.ClientInfo.pClientInfo1  = &SplClientInfo;

    if (Level == 2) {

        PPRINTER_INFO_2 pPrinterInfo = (PPRINTER_INFO_2)pPrinter;

        if (pPrinterInfo->pDevMode) {

            DevModeContainer.cbBuf = pPrinterInfo->pDevMode->dmSize +
                                      pPrinterInfo->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pPrinterInfo->pDevMode;

            //
            // Set pDevMode to NULL. Import.h defines pDevMode and pSecurityDescriptor as pointers now.
            // pDevMode and pSecurityDescriptor used to be defined as DWORD, but this doesn't work
            // across 32b and 64b.
            // These pointers must be set on NULL, otherwise RPC will marshall them as strings.
            //
            pPrinterInfo->pDevMode = NULL;

        } else {

            DevModeContainer.cbBuf = 0;
            DevModeContainer.pDevMode = NULL;
        }

        if (pPrinterInfo->pSecurityDescriptor) {

            SecurityContainer.cbBuf = GetSecurityDescriptorLength(pPrinterInfo->pSecurityDescriptor);
            SecurityContainer.pSecurity = pPrinterInfo->pSecurityDescriptor;

            //
            // Set pSecurityDescriptor to NULL.
            //
            pPrinterInfo->pSecurityDescriptor = NULL;

        } else {

            SecurityContainer.cbBuf = 0;
            SecurityContainer.pSecurity = NULL;
        }

        if (!pPrinterInfo->pPrinterName) {
            SetLastError(ERROR_INVALID_PRINTER_NAME);
            return FALSE;
        }

        if ( pScratchBuffer = AllocSplMem( MAX_UNC_PRINTER_NAME * sizeof(WCHAR) )) {

            StringCchPrintf( pScratchBuffer, MAX_UNC_PRINTER_NAME, L"%ws\\%ws", pName, pPrinterInfo->pPrinterName );
            pCopyPrinterName = AllocSplStr( pScratchBuffer );
            FreeSplMem( pScratchBuffer );
        }

    } else {

        DevModeContainer.cbBuf = 0;
        DevModeContainer.pDevMode = NULL;

        SecurityContainer.cbBuf = 0;
        SecurityContainer.pSecurity = NULL;
    }

   EnterSplSem();


        pSpool = AllocWSpool();

   LeaveSplSem();

    if ( pSpool != NULL ) {

        pSpool->pName = pCopyPrinterName;

        pCopyPrinterName = NULL;

        RpcTryExcept {

            if ( (ReturnValue = RpcValidate()) ||
                 (ReturnValue = RpcAddPrinterEx(pName,
                                        (PPRINTER_CONTAINER)&PrinterContainer,
                                        (PDEVMODE_CONTAINER)&DevModeContainer,
                                        (PSECURITY_CONTAINER)&SecurityContainer,
                                        &SplClientContainer,
                                        &hPrinter)) ) {

                SetLastError(ReturnValue);
                hPrinter = NULL;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwRpcError = RpcExceptionCode();

        } RpcEndExcept

        if ( dwRpcError == RPC_S_PROCNUM_OUT_OF_RANGE ) {

            dwRpcError = ERROR_SUCCESS;
            RpcTryExcept {

                if ( ReturnValue = RpcAddPrinter
                                        (pName,
                                         (PPRINTER_CONTAINER)&PrinterContainer,
                                         (PDEVMODE_CONTAINER)&DevModeContainer,
                                         (PSECURITY_CONTAINER)&SecurityContainer,
                                         &hPrinter) ) {

                    SetLastError(ReturnValue);
                    hPrinter = NULL;
                }

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                dwRpcError = RpcExceptionCode();

            } RpcEndExcept

        }

        if ( dwRpcError ) {

            SetLastError(dwRpcError);
            hPrinter = NULL;
        }


       EnterSplSem();

        if ( hPrinter ) {

            pSpool->RpcHandle = hPrinter;

        } else {

            FreepSpool( pSpool );
            pSpool = NULL;

        }

       LeaveSplSem();


    } else {

        // Failed to allocate Printer Handle

        FreeSplStr( pCopyPrinterName );
    }

    if( Level == 2 ) {

        //
        // Restore pSecurityDescriptor and pDevMode. They were set to NULL to avoid RPC marshalling.
        //
        (LPBYTE)((PPRINTER_INFO_2)pPrinter)->pSecurityDescriptor = SecurityContainer.pSecurity;

        (LPBYTE)((PPRINTER_INFO_2)pPrinter)->pDevMode = DevModeContainer.pDevMode;
    }

    SplOutSem();

    return (HANDLE)pSpool;
}

BOOL
DeletePrinter(
   HANDLE   hPrinter
)
{
    BOOL  ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if ( ReturnValue = RpcDeletePrinter(pSpool->RpcHandle) ) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else {

        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    return ReturnValue;
}

BOOL
InternalDeletePrinterConnection(
    LPWSTR   pName,
    BOOL     bNotifyDriver
    )

/*++

Routine Description:

    Delete a printer connection (printer name or share name) that
    belongs to win32spl.dll.

    Note: The Router takes care of updating win.ini and per user connections
          section based on returning True / False.

Arguments:

    pName - Either a printer or share name.
    bNotifyDriver - flag to notify the driver

Return Value:

    TRUE - success, FALSE - fail.  LastError set.

--*/

{
    BOOL  bReturnValue = FALSE;
    HKEY  hClientKey = NULL;
    HKEY  hPrinterConnectionsKey = NULL;
    DWORD i;
    WCHAR szBuffer[MAX_UNC_PRINTER_NAME + 30]; // space for szRegistryConnections
    DWORD cbBuffer;
    PWCACHEINIPRINTEREXTRA pExtraData;
    HANDLE  hSplPrinter = NULL;
    HANDLE  hIniSpooler = NULL;
    DWORD   cRef;

    DWORD dwPrnEvntError = ERROR_SUCCESS;

    WCHAR   PrinterInfo1[ MAX_PRINTER_INFO1 ];
    LPPRINTER_INFO_1W pPrinter1 = (LPPRINTER_INFO_1W)&PrinterInfo1;

    LPWSTR  pConnectionName = pName;

#if DBG
    SetLastError( 0 );
#endif

 try {

    if ( !VALIDATE_NAME( pName ) ) {
        SetLastError( ERROR_INVALID_NAME );
        leave;
    }

    //
    // If the Printer is in the Cache then Decrement its connection
    // reference count.
    //

    if( !OpenCachePrinterOnly( pName, &hSplPrinter, &hIniSpooler, NULL, FALSE)){

        DWORD dwLastError;

        hSplPrinter = NULL;
        hIniSpooler = NULL;

        dwLastError = GetLastError();

        if (( dwLastError != ERROR_INVALID_PRINTER_NAME ) &&
            ( dwLastError != ERROR_INVALID_NAME )) {

            DBGMSG( DBG_WARNING, ("DeletePrinterConnection failed OpenCachePrinterOnly %ws error %d\n", pName, dwLastError ));
            leave;
        }

        //
        // Printer Is NOT in Cache,
        //
        // Continue to remove from HKEY_CURRENT_USER
        // Can happen with Floating Profiles
        //

    } else {

        //
        // Printer is in Cache
        // Support for DeletetPrinterConnection( \\server\share );
        //

        if( !SplGetPrinter( hSplPrinter,
                            1,
                            (LPBYTE)pPrinter1,
                            sizeof( PrinterInfo1),
                            &cbBuffer )){

            DBGMSG( DBG_WARNING, ("DeletePrinterConenction failed SplGetPrinter %d hSplPrinter %x\n", GetLastError(), hSplPrinter ));
            SPLASSERT( pConnectionName == pName );

        } else {
            pConnectionName = pPrinter1->pName;
        }

        //
        //  Update Connection Reference Count
        //

       EnterSplSem();

        if( !SplGetPrinterExtra( hSplPrinter, &(PBYTE)pExtraData )){

            DBGMSG( DBG_WARNING,
                    ("DeletePrinterConnection SplGetPrinterExtra pSplPrinter %x error %d\n",
                    hSplPrinter, GetLastError() ));

            pExtraData = NULL;
        }

        if (( pExtraData != NULL ) &&
            ( pExtraData->cRef != 0 )) {

            SPLASSERT( pExtraData->signature == WCIP_SIGNATURE );

            pExtraData->cRef--;
            cRef = pExtraData->cRef;

        } else {

            cRef = 0;
        }


       LeaveSplSem();


        if ( cRef == 0 ) {

            //
            //  Allow the Driver to do Per Cache Connection Cleanup
            //

            if (bNotifyDriver) {
                SplDriverEvent( pConnectionName, PRINTER_EVENT_CACHE_DELETE, (LPARAM)NULL, &dwPrnEvntError );
            }

            //
            //  Remove Cache for this printer
            //

            if ( !SplDeletePrinter( hSplPrinter )) {

                DBGMSG( DBG_WARNING, ("DeletePrinterConnection failed SplDeletePrinter %d\n", GetLastError() ));
                leave;
            }

        } else {

            if ( !SplSetPrinterExtra( hSplPrinter, (LPBYTE)pExtraData ) ) {

                DBGMSG( DBG_ERROR, ("DeletePrinterConnection SplSetPrinterExtra failed %x\n", GetLastError() ));
                leave;
            }
        }

        SplOutSem();
    }

    //
    //  Note pConnectionName will either be the name passed in
    //  or if the Printer was in the Cache, would be the printer
    //  name from the cache.
    //  This will allow somone to call DeleteprinterConnection
    //  with a UNC Share name.
    //

    hClientKey = GetClientUserHandle(KEY_READ);

    if ( hClientKey == NULL ) {

        DBGMSG( DBG_WARNING, ("DeletePrinterConnection failed %d\n", GetLastError() ));
        leave;
    }


    StringCchCopy(szBuffer, COUNTOF(szBuffer), szRegistryConnections);

    i = wcslen(szBuffer);
    szBuffer[i++] = L'\\';

    FormatPrinterForRegistryKey( pConnectionName, szBuffer + i, COUNTOF(szBuffer) - i);

    if( ERROR_SUCCESS != RegOpenKeyEx( hClientKey,
                                       szBuffer,
                                       0,
                                       KEY_READ,
                                       &hPrinterConnectionsKey )){

        if ( pConnectionName == pName ) {

            SetLastError( ERROR_INVALID_PRINTER_NAME );
            leave;
        }

        //
        // If we have a printer on the server whose sharename is the same
        // as a previously deleted printers printername then CacheOpenPrinter
        // would have succeded but you are not going to find the share name in
        // the registry
        //
        FormatPrinterForRegistryKey( pName, szBuffer + i, COUNTOF(szBuffer) - i);

        if ( ERROR_SUCCESS != RegOpenKeyEx(hClientKey,
                                           szBuffer,
                                           0,
                                           KEY_READ,
                                           &hPrinterConnectionsKey) ) {

            SetLastError( ERROR_INVALID_PRINTER_NAME );
            leave;
        }
    }

    //
    // Common case is success, so set the return value here.
    // Only if we fail will we set it to FALSE now.
    //
    bReturnValue = TRUE;

    cbBuffer = sizeof(szBuffer);

    //
    // If there is a Provider value, and it doesn't match win32spl.dll,
    // then fail the call.
    //
    // If the provider value isn't there, succeed for backward
    // compatibility.
    //
    if( ERROR_SUCCESS == RegQueryValueEx( hPrinterConnectionsKey,
                                          L"Provider",
                                          NULL,
                                          NULL,
                                          (LPBYTE)szBuffer,
                                          &cbBuffer) &&
        _wcsicmp( szBuffer, L"win32spl.dll" )){

        bReturnValue = FALSE;
        SetLastError( ERROR_INVALID_PRINTER_NAME );
    }

    RegCloseKey( hPrinterConnectionsKey );

 } finally {

    if( hClientKey ){
        RegCloseKey( hClientKey );
    }

    if( hSplPrinter ){
        if (!SplClosePrinter( hSplPrinter )){
            DBGMSG( DBG_WARNING, ("DeletePrinterConnection failed to close hSplPrinter %x error %d\n", hSplPrinter, GetLastError() ));
        }
    }

    if( hIniSpooler ){
        if( !SplCloseSpooler( hIniSpooler )){
            DBGMSG( DBG_WARNING, ("DeletePrinterConnection failed to close hSplSpooler %x error %d\n", hIniSpooler, GetLastError() ));
        }
    }
 }

    if( !bReturnValue ){
        SPLASSERT( GetLastError( ));
    }

    return bReturnValue;
}

BOOL
DeletePrinterConnection(
    LPWSTR   pName
    )
{
    return InternalDeletePrinterConnection(pName, TRUE);
}

BOOL
SetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
    )
{
    BOOL                ReturnValue;
    PRINTER_CONTAINER   PrinterContainer;
    DEVMODE_CONTAINER   DevModeContainer;
    SECURITY_CONTAINER  SecurityContainer;
    PPRINTER_INFO_2     pPrinterInfo2;
    PPRINTER_INFO_3     pPrinterInfo3;
    PPRINTER_INFO_5     pPrinterInfo5;
    PPRINTER_INFO_6     pPrinterInfo6;
    PPRINTER_INFO_7     pPrinterInfo7;
    PWSPOOL             pSpool = (PWSPOOL)hPrinter;
    BOOL                bNeedToFreeDevMode = FALSE;
    HANDLE              hDevModeChgInfo = NULL;
    LPDEVMODE           pOldDevMode = NULL;

    VALIDATEW32HANDLE( pSpool );

    if (pSpool->Type != SJ_WIN32HANDLE) {

        return LMSetPrinter(hPrinter, Level, pPrinter, Command);

    }

    SYNCRPCHANDLE( pSpool );

    PrinterContainer.Level = Level;
    PrinterContainer.PrinterInfo.pPrinterInfo1 = (PPRINTER_INFO_1)pPrinter;

    DevModeContainer.cbBuf = 0;
    DevModeContainer.pDevMode = NULL;

    SecurityContainer.cbBuf = 0;
    SecurityContainer.pSecurity = NULL;

    switch (Level) {

    case 0:
    case 1:

        break;


    case 2:

        pPrinterInfo2 = (PPRINTER_INFO_2)pPrinter;

        if (pPrinterInfo2->pDevMode) {

            if ( pSpool->bNt3xServer ) {

                //
                // If Nt 3xserver we will set devmode only if we can convert
                //
                if ( pSpool->Status & WSPOOL_STATUS_USE_CACHE ) {

                    hDevModeChgInfo = LoadDriverFiletoConvertDevmodeFromPSpool(pSpool->hSplPrinter);
                    if ( hDevModeChgInfo ) {

                        SPLASSERT( pSpool->pName != NULL );

                        if ( ERROR_SUCCESS == CallDrvDevModeConversion(
                                                hDevModeChgInfo,
                                                pSpool->pName,
                                                (LPBYTE)pPrinterInfo2->pDevMode,
                                                (LPBYTE *)&DevModeContainer.pDevMode,
                                                &DevModeContainer.cbBuf,
                                                CDM_CONVERT351,
                                                TRUE) ) {

                            bNeedToFreeDevMode = TRUE;
                        }
                    }
                }
            } else {

                DevModeContainer.cbBuf = pPrinterInfo2->pDevMode->dmSize +
                                         pPrinterInfo2->pDevMode->dmDriverExtra;
                DevModeContainer.pDevMode = (LPBYTE)pPrinterInfo2->pDevMode;
            }

            //
            // Set pDevMode to NULL. Import.h defines pDevMode and pSecurityDescriptor as pointers now.
            // pDevMode and pSecurityDescriptor used to be defined as DWORD, but this doesn't work
            // across 32b and 64b.
            // These pointers must be set on NULL, otherwise RPC will marshall them as strings.
            //
            pOldDevMode = pPrinterInfo2->pDevMode;
            pPrinterInfo2->pDevMode = NULL;

        }

        if (pPrinterInfo2->pSecurityDescriptor) {

            SecurityContainer.cbBuf = GetSecurityDescriptorLength(pPrinterInfo2->pSecurityDescriptor);
            SecurityContainer.pSecurity = pPrinterInfo2->pSecurityDescriptor;
            //
            // Set pSecurityDescriptor to NULL.
            //
            pPrinterInfo2->pSecurityDescriptor = NULL;

        }
        break;

    case 3:

        pPrinterInfo3 = (PPRINTER_INFO_3)pPrinter;

        //
        // If this is NULL, should we even rpc out?
        //

        if (pPrinterInfo3->pSecurityDescriptor) {

            SecurityContainer.cbBuf = GetSecurityDescriptorLength(pPrinterInfo3->pSecurityDescriptor);
            SecurityContainer.pSecurity = pPrinterInfo3->pSecurityDescriptor;
        }

        break;

    case 5:

        pPrinterInfo5 = (PPRINTER_INFO_5)pPrinter;
        break;

    case 6:

        pPrinterInfo6 = (PPRINTER_INFO_6)pPrinter;
        break;

    case 7:

        pPrinterInfo7 = (PPRINTER_INFO_7)pPrinter;
        break;

    default:

        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }


    RpcTryExcept {

        if ( ReturnValue = RpcSetPrinter(pSpool->RpcHandle,
                                    (PPRINTER_CONTAINER)&PrinterContainer,
                                    (PDEVMODE_CONTAINER)&DevModeContainer,
                                    (PSECURITY_CONTAINER)&SecurityContainer,
                                    Command) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    //
    //  Make sure Forms Cache is consistent
    //


    if ( ReturnValue ) {

        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
    }

    if( Level == 2 ) {

        //
        // Restore pSecurityDescriptor and pDevMode. They were set to NULL to avoid RPC marshalling.
        //
        (LPBYTE)pPrinterInfo2->pSecurityDescriptor = SecurityContainer.pSecurity;

        pPrinterInfo2->pDevMode = pOldDevMode;
    }

    if ( bNeedToFreeDevMode )
        FreeSplMem(DevModeContainer.pDevMode);

    if ( hDevModeChgInfo )
        UnloadDriverFile(hDevModeChgInfo);

    return ReturnValue;
}

BOOL
RemoteGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL        ReturnValue = FALSE;
    DWORD       dwReturnValue = 0;
    FieldInfo   *pFieldInfo;
    PWSPOOL     pSpool = (PWSPOOL)hPrinter;
    LPBYTE      pNewPrinter = NULL;
    DWORD       dwNewSize;
    SIZE_T      cbStruct;
    DWORD       cReturned = 1;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        switch (Level) {

        case STRESSINFOLEVEL:
            pFieldInfo = PrinterInfoStressFields;
            cbStruct = sizeof(PRINTER_INFO_STRESS);
            break;

        case 1:
            pFieldInfo = PrinterInfo1Fields;
            cbStruct = sizeof(PRINTER_INFO_1);
            break;

        case 2:
            pFieldInfo = PrinterInfo2Fields;
            cbStruct = sizeof(PRINTER_INFO_2);
            break;

        case 3:
            pFieldInfo = PrinterInfo3Fields;
            cbStruct = sizeof(PRINTER_INFO_3);
            break;

        case 5:
            pFieldInfo = PrinterInfo5Fields;
            cbStruct = sizeof(PRINTER_INFO_5);
            break;

        case 6:
            pFieldInfo = PrinterInfo6Fields;
            cbStruct = sizeof(PRINTER_INFO_6);
            break;

        case 7:
            pFieldInfo = PrinterInfo7Fields;
            cbStruct = sizeof(PRINTER_INFO_7);
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        if (pPrinter)
            memset(pPrinter, 0, cbBuf);

        //
        // If going to different version and we have localspl handle want
        // to do devmode conversion
        //
        if ( Level == 2 &&
             (pSpool->Status & WSPOOL_STATUS_USE_CACHE) ) {

            dwNewSize       = cbBuf + MAX_PRINTER_INFO2;
            pNewPrinter = AllocSplMem(dwNewSize);

            if ( !pNewPrinter )
                goto Cleanup;
        } else {

            dwNewSize       = cbBuf;
            pNewPrinter     = pPrinter;
        }

        do {

            RpcTryExcept {

                dwReturnValue = RpcGetPrinter(   pSpool->RpcHandle,
                                                 Level,
                                                 pNewPrinter,
                                                 dwNewSize,
                                                 pcbNeeded);

                dwReturnValue = UpdateBufferSize(    pFieldInfo,
                                                     cbStruct,
                                                     pcbNeeded,
                                                     dwNewSize,
                                                     dwReturnValue,
                                                     &cReturned);

                if ( dwReturnValue ){

                    if ( Level == 2 &&
                         pNewPrinter != pPrinter &&
                         dwReturnValue == ERROR_INSUFFICIENT_BUFFER ) {

                        FreeSplMem(pNewPrinter);

                        dwNewSize = *pcbNeeded;
                        pNewPrinter = AllocSplMem(dwNewSize);
                        // do loop if pNewPrinter != NULL
                    } else {

                        SetLastError(dwReturnValue);
                        ReturnValue = FALSE;
                    }

                } else {

                    ReturnValue = TRUE;


                    if (pNewPrinter &&
                        (ReturnValue = MarshallUpStructure(pNewPrinter, pFieldInfo, cbStruct, RPC_CALL))) {

                        if (Level == 2 ) {

                            //
                            //  In the Cache && Different OS Level
                            //

                            if ( pNewPrinter != pPrinter ) {

                                SPLASSERT(pSpool->Status & WSPOOL_STATUS_USE_CACHE);
                                SPLASSERT(pSpool->pName != NULL );

                                ReturnValue = DoDevModeConversionAndBuildNewPrinterInfo2(
                                                (LPPRINTER_INFO_2)pNewPrinter,
                                                *pcbNeeded,
                                                pPrinter,
                                                cbBuf,
                                                pcbNeeded,
                                                pSpool);
                            }

                            if ( ReturnValue ) {

                                ((PPRINTER_INFO_2)pPrinter)->Attributes |=
                                                    PRINTER_ATTRIBUTE_NETWORK;
                                ((PPRINTER_INFO_2)pPrinter)->Attributes &=
                                                    ~PRINTER_ATTRIBUTE_LOCAL;
                            }
                        }

                        if (Level == 5) {
                            ((PPRINTER_INFO_5)pPrinter)->Attributes |=
                                                    PRINTER_ATTRIBUTE_NETWORK;
                            ((PPRINTER_INFO_5)pPrinter)->Attributes &=
                                                    ~PRINTER_ATTRIBUTE_LOCAL;
                        }
                    }

                }

            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                dwReturnValue = RpcExceptionCode();

                ReturnValue = FALSE;

                //
                // We want to break out of the do-while loop if an exception is raised by RPC.
                // The loop breaks when dwReturnValue is not ERROR_INSUFFICIENT_BUFFER. We need
                // to make sure that the exception raised is not ERROR_INSUFFICIENT_BUFFER.
                // It's not likely, but one can never know...
                //
                if (dwReturnValue == ERROR_INSUFFICIENT_BUFFER)
                {
                    dwReturnValue = ERROR_INVALID_FUNCTION;
                }

                SetLastError(dwReturnValue);

            } RpcEndExcept

        } while ( Level == 2 &&
                  dwReturnValue == ERROR_INSUFFICIENT_BUFFER &&
                  pNewPrinter != pPrinter &&
                  pNewPrinter );

    } else {
        return LMGetPrinter(hPrinter, Level, pPrinter, cbBuf, pcbNeeded);
    }

Cleanup:

    if ( pNewPrinter != pPrinter )
        FreeSplMem(pNewPrinter );

    return ReturnValue;
}


BOOL
AddPrinterDriverEx(
    LPWSTR   pName,
    DWORD   Level,
    PBYTE   pDriverInfo,
    DWORD   dwFileCopyFlags
)
{
    BOOL                   bReturnValue;
    DWORD                  dwRpcError = 0, dwReturnValue;
    DRIVER_CONTAINER       DriverContainer;
    PDRIVER_INFO_2W        pDriverInfo2 = (PDRIVER_INFO_2W) pDriverInfo;
    PDRIVER_INFO_3W        pDriverInfo3 = (PDRIVER_INFO_3W) pDriverInfo;
    PDRIVER_INFO_6W        pDriverInfo6 = (PDRIVER_INFO_6W) pDriverInfo;
    LPRPC_DRIVER_INFO_6W   pRpcDriverInfo6 = NULL;
    LPWSTR                 pBase, pStr;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    //
    // The dwFileCopyFlags don't send the APD_DRIVER_SIGNATURE_VALID to the remote
    // machine. This is because for now we only support check-pointing on the local
    // machine only. Maybe in the future when this is supported on all skus we could
    // do a version check here and support check-pointing remote.
    //
    dwFileCopyFlags &= ~APD_DONT_SET_CHECKPOINT;

    //
    // ClientSide should have set a default environment if one was not
    // specified.
    //
    switch (Level) {
        case 2:
            SPLASSERT( ( pDriverInfo2->pEnvironment != NULL ) &&
                       (*pDriverInfo2->pEnvironment != L'\0') );
            break;

        case 3:
        case 4:
            SPLASSERT( ( pDriverInfo3->pEnvironment != NULL ) &&
                       (*pDriverInfo3->pEnvironment != L'\0') );
            break;

        case 6:
            SPLASSERT( ( pDriverInfo6->pEnvironment != NULL ) &&
                       (*pDriverInfo6->pEnvironment != L'\0') );
            break;

        default:
            DBGMSG(DBG_ERROR, ("RemoteAddPrinterDriver: invalid level %d", Level));
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
    }

    DriverContainer.Level = Level;
    if ( Level == 2 ) {

        DriverContainer.DriverInfo.Level2 = (DRIVER_INFO_2 *)pDriverInfo;

    } else {

        //
        // Level == 3 || Level == 4 || Level == 6
        //
        if( !( pRpcDriverInfo6 = AllocSplMem( sizeof( *pRpcDriverInfo6 )))) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;

        } else {

            pRpcDriverInfo6->cVersion         = pDriverInfo3->cVersion;
            pRpcDriverInfo6->pName            = pDriverInfo3->pName;
            pRpcDriverInfo6->pEnvironment     = pDriverInfo3->pEnvironment;
            pRpcDriverInfo6->pDriverPath      = pDriverInfo3->pDriverPath;
            pRpcDriverInfo6->pDataFile        = pDriverInfo3->pDataFile;
            pRpcDriverInfo6->pConfigFile      = pDriverInfo3->pConfigFile;
            pRpcDriverInfo6->pHelpFile        = pDriverInfo3->pHelpFile;
            pRpcDriverInfo6->pMonitorName     = pDriverInfo3->pMonitorName;
            pRpcDriverInfo6->pDefaultDataType = pDriverInfo3->pDefaultDataType;

            //
            // Set the char count of the mz string.
            // NULL   --- 0
            // szNULL --- 1
            // string --- number of characters in the string including the last '\0'
            //
            if ( pBase = pDriverInfo3->pDependentFiles ) {

                for ( pStr = pBase ; *pStr; pStr += wcslen(pStr) + 1 )
                ;
                pRpcDriverInfo6->cchDependentFiles = (DWORD) (pStr - pBase + 1);

                if ( pRpcDriverInfo6->cchDependentFiles )
                    pRpcDriverInfo6->pDependentFiles = pBase;
            } else {

                pRpcDriverInfo6->cchDependentFiles = 0;
            }

            if ( (Level == 4 || Level==6)    &&
                 (pBase = ((LPDRIVER_INFO_4W)pDriverInfo)->pszzPreviousNames) ) {

                pRpcDriverInfo6->pszzPreviousNames = pBase;

                for ( pStr = pBase; *pStr ; pStr += wcslen(pStr) + 1 )
                ;

                pRpcDriverInfo6->cchPreviousNames = (DWORD) (pStr - pBase + 1);
            } else {

                pRpcDriverInfo6->cchPreviousNames = 0;
            }

            if (Level==6) {
                pRpcDriverInfo6->pMfgName          = pDriverInfo6->pszMfgName;
                pRpcDriverInfo6->pOEMUrl           = pDriverInfo6->pszOEMUrl;
                pRpcDriverInfo6->pHardwareID       = pDriverInfo6->pszHardwareID;
                pRpcDriverInfo6->pProvider         = pDriverInfo6->pszProvider;
                pRpcDriverInfo6->ftDriverDate      = pDriverInfo6->ftDriverDate;
                pRpcDriverInfo6->dwlDriverVersion  = pDriverInfo6->dwlDriverVersion;
            }

            DriverContainer.DriverInfo.Level6 = pRpcDriverInfo6;
        }

    }

    RpcTryExcept {

        if ( (dwReturnValue = RpcValidate()) ||
             (dwReturnValue = RpcAddPrinterDriverEx(pName,
                                                    &DriverContainer,
                                                    dwFileCopyFlags)) ) {

            SetLastError(dwReturnValue);
            bReturnValue = FALSE;
        } else {
            bReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwRpcError = RpcExceptionCode();
        bReturnValue = FALSE;

    } RpcEndExcept

    if ((dwRpcError == RPC_S_PROCNUM_OUT_OF_RANGE) &&
        (dwFileCopyFlags == APD_COPY_NEW_FILES)) {

        bReturnValue = TRUE;
        dwRpcError = ERROR_SUCCESS;

        RpcTryExcept {

            if ( dwReturnValue = RpcAddPrinterDriver(pName,
                                                     &DriverContainer) ) {
                SetLastError(dwReturnValue);
                bReturnValue = FALSE;
            } else {
                bReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwRpcError = RpcExceptionCode();
            bReturnValue = FALSE;

        } RpcEndExcept

    }

    if ( dwRpcError ) {

        if (dwRpcError == RPC_S_INVALID_TAG ) {
           dwRpcError = ERROR_INVALID_LEVEL;
        }

        SetLastError(dwRpcError);
    }

    FreeSplMem(pRpcDriverInfo6);

    return bReturnValue;
}


BOOL
RemoteAddPrinterDriver(
    LPWSTR   pName,
    DWORD   Level,
    PBYTE   pDriverInfo
    )
{
    return AddPrinterDriverEx(pName, Level, pDriverInfo, APD_COPY_NEW_FILES);
}


BOOL
EnumPrinterDrivers(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   i, cbStruct, ReturnValue;
    FieldInfo *pFieldInfo;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (Level) {

    case 1:
        pFieldInfo = DriverInfo1Fields;
        cbStruct = sizeof(DRIVER_INFO_1);
        break;

    case 2:
        pFieldInfo = DriverInfo2Fields;
        cbStruct = sizeof(DRIVER_INFO_2);
        break;

    case 3:
        pFieldInfo = DriverInfo3Fields;
        cbStruct = sizeof(DRIVER_INFO_3);
        break;

    case 4:
        pFieldInfo = DriverInfo4Fields;
        cbStruct = sizeof(DRIVER_INFO_4);
        break;

    case 5:
        pFieldInfo = DriverInfo5Fields;
        cbStruct = sizeof(DRIVER_INFO_5);
        break;

    case 6:
        pFieldInfo = DriverInfo6Fields;
        cbStruct = sizeof(DRIVER_INFO_6);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||

             (ReturnValue = RpcEnumPrinterDrivers(pName, pEnvironment, Level,
                                                  pDriverInfo, cbBuf,
                                                  pcbNeeded, pcReturned) ,
              ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             pcReturned)) )
        {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;
        }
        else
        {
            ReturnValue = TRUE;

            if (pDriverInfo) {

                if(! MarshallUpStructuresArray( pDriverInfo, *pcReturned, pFieldInfo,
                                                cbStruct, RPC_CALL) ) {
                    return FALSE;
                }
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return (BOOL)ReturnValue;
}

BOOL
RemoteGetPrinterDriverDirectory(
    LPWSTR   pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcGetPrinterDriverDirectory(pName, pEnvironment,
                                                         Level,
                                                         pDriverDirectory,
                                                         cbBuf, pcbNeeded)) ) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}


BOOL
DeletePrinterDriver(
    LPWSTR    pName,
    LPWSTR    pEnvironment,
    LPWSTR    pDriverName
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcDeletePrinterDriver(pName,
                                                   pEnvironment,
                                                   pDriverName)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;

}


BOOL
DeletePrinterDriverEx(
   LPWSTR    pName,
   LPWSTR    pEnvironment,
   LPWSTR    pDriverName,
   DWORD     dwDeleteFlag,
   DWORD     dwVersionNum
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcDeletePrinterDriverEx(pName,
                                                     pEnvironment,
                                                     pDriverName,
                                                     dwDeleteFlag,
                                                     dwVersionNum)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
AddPerMachineConnection(
   LPCWSTR    pServer,
   LPCWSTR    pPrinterName,
   LPCWSTR    pPrintServer,
   LPCWSTR    pProvider
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME((LPWSTR)pServer) || MyUNCName((LPWSTR)pServer) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcAddPerMachineConnection((LPWSTR) pServer,
                                                       pPrinterName,
                                                       pPrintServer,
                                                       pProvider)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePerMachineConnection(
   LPCWSTR    pServer,
   LPCWSTR    pPrinterName
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME((LPWSTR) pServer) || MyUNCName((LPWSTR) pServer) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcDeletePerMachineConnection((LPWSTR) pServer,
                                                          pPrinterName)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
EnumPerMachineConnections(
   LPCWSTR    pServer,
   LPBYTE     pPrinterEnum,
   DWORD      cbBuf,
   LPDWORD    pcbNeeded,
   LPDWORD    pcReturned
)
{
    BOOL  ReturnValue;
    FieldInfo *pFieldInfo = PrinterInfo4Fields;
    DWORD cbStruct = sizeof(PRINTER_INFO_4),index;

    if ( !VALIDATE_NAME((LPWSTR) pServer) || MyUNCName((LPWSTR) pServer) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||

             (ReturnValue = RpcEnumPerMachineConnections((LPWSTR) pServer,
                                                         pPrinterEnum,
                                                         cbBuf,
                                                         pcbNeeded,
                                                         pcReturned) ,
              ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             pcReturned)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
            if (pPrinterEnum) {

                if(! MarshallUpStructuresArray(pPrinterEnum, *pcReturned, pFieldInfo,
                                                cbStruct, RPC_CALL) ) {
                    return FALSE;
                }
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return (BOOL)ReturnValue;
}

BOOL
AddPrintProcessor(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName
)
{
    BOOL ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcAddPrintProcessor(pName , pEnvironment,pPathName,
                                                 pPrintProcessorName)) ) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
EnumPrintProcessors(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   i, cbStruct, ReturnValue;
    FieldInfo *pFieldInfo;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (Level) {

    case 1:
        pFieldInfo = PrintProcessorInfo1Fields;
        cbStruct = sizeof(PRINTPROCESSOR_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||

             (ReturnValue = RpcEnumPrintProcessors(pName, pEnvironment, Level,
                                                   pPrintProcessorInfo, cbBuf,
                                                   pcbNeeded, pcReturned) ,
              ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             pcReturned)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pPrintProcessorInfo) {

                if(! MarshallUpStructuresArray( pPrintProcessorInfo, *pcReturned, pFieldInfo,
                                                cbStruct, RPC_CALL) ) {
                    return FALSE;
                }
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return (BOOL) ReturnValue;
}

BOOL
EnumPrintProcessorDatatypes(
    LPWSTR   pName,
    LPWSTR   pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   ReturnValue, i, cbStruct;
    FieldInfo *pFieldInfo;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (Level) {

    case 1:
        pFieldInfo = DatatypeInfo1Fields;
        cbStruct = sizeof(DATATYPES_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||

             (ReturnValue = RpcEnumPrintProcessorDatatypes(pName,
                                                           pPrintProcessorName,
                                                           Level,
                                                           pDatatypes,
                                                           cbBuf,
                                                           pcbNeeded,
                                                           pcReturned) ,
              ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             pcReturned)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pDatatypes) {

                if(! MarshallUpStructuresArray( pDatatypes, *pcReturned, pFieldInfo,
                                                cbStruct, RPC_CALL) ) {
                    return FALSE;
                }
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return (BOOL) ReturnValue;
}

BOOL
GetPrintProcessorDirectory(
    LPWSTR   pName,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcGetPrintProcessorDirectory(pName, pEnvironment,
                                                          Level,
                                                          pPrintProcessorDirectory,
                                                          cbBuf, pcbNeeded)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}
DWORD
StartDocPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    BOOL        ReturnValue;
    DWORD       JobId;
    PWSPOOL     pSpool       = (PWSPOOL)hPrinter;
    PWSPOOL     pRemoteSpool = NULL;
    PDOC_INFO_1 pDocInfo1    = (PDOC_INFO_1)pDocInfo;
    GENERIC_CONTAINER DocInfoContainer;
    PRINTER_DEFAULTSW Defaults;
    
    LPWSTR           pName     = NULL;

    SplOutSem();

    if (pSpool->pThread) {
        //
        // We cannot used the pooled thread in StartDocPrinter so we are going to go synchronously
        //
        Defaults.pDatatype = NULL;
        Defaults.pDevMode = NULL;
        Defaults.DesiredAccess = 0;

        EnterSplSem();

        ReturnValue = CopypDefaults(&(pSpool->PrinterDefaults), &Defaults);
        
        if (ReturnValue)
        {
            pName = AllocSplStr(pSpool->pName);
            ReturnValue = pName ? TRUE : FALSE;
        }

        LeaveSplSem();
        SplOutSem();

        if (ReturnValue) {

            ReturnValue = RemoteOpenPrinter( pName, &pRemoteSpool, &Defaults, DO_NOT_CALL_LM_OPEN );
        }

        if ( ReturnValue ) {

            DBGMSG( DBG_TRACE, ( "CacheOpenPrinter Synchronous Open OK pRemoteSpool %x pSpool %x\n", pRemoteSpool, pSpool ));
            SPLASSERT( pRemoteSpool->Type == SJ_WIN32HANDLE );

            //
            // Return the thread And/Or close the RPC handle.
            //             
            ReturnThreadFromHandle(pSpool);

            EnterSplSem();

            //
            // This is no longer an asynchronous handle.
            // 
            pSpool->Status &= ~WSPOOL_STATUS_ASYNC;
            pSpool->RpcHandle = pRemoteSpool->RpcHandle;
            pSpool->Status   |= pRemoteSpool->Status;
            pSpool->RpcError  = pRemoteSpool->RpcError;
            pSpool->bNt3xServer = pRemoteSpool->bNt3xServer;

            pRemoteSpool->RpcHandle = NULL;

            pSpool->Status &= ~WSPOOL_STATUS_NO_RPC_HANDLE;

            FreepSpool( pRemoteSpool );

            pRemoteSpool = NULL;

            if ( pSpool->RpcHandle ) {
                pSpool->Status &= ~WSPOOL_STATUS_OPEN_ERROR;
            }
            
            LeaveSplSem();
            SplOutSem();

        } else {

            DBGMSG( DBG_TRACE, ( "CacheOpenPrinter Synchronous Open Failed  pSpool %x LastError %d\n", pSpool, GetLastError() ));
        }

        FreeSplStr(pName);
        FreeSplStr(Defaults.pDatatype);
        FreeSplMem(Defaults.pDevMode);
    }

    VALIDATEW32HANDLE( pSpool );


    if (Win32IsGoingToFile(pSpool, pDocInfo1->pOutputFile)) {

        HANDLE hFile;

        //
        // POLICY?
        //
        // If no datatype is specified, and the default is non-raw,
        // should we fail?
        //
        if( pDocInfo1 &&
            pDocInfo1->pDatatype &&
            !ValidRawDatatype( pDocInfo1->pDatatype )){

            SetLastError( ERROR_INVALID_DATATYPE );
            return FALSE;
        }

        pSpool->Status |= WSPOOL_STATUS_PRINT_FILE;
        hFile = CreateFile( pDocInfo1->pOutputFile, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL );
        if (hFile == INVALID_HANDLE_VALUE) {
            return FALSE;
        } else {
            pSpool->hFile = hFile;
            return TRUE;
        }
    }

    if (pSpool->Type == SJ_WIN32HANDLE) {

        DocInfoContainer.Level = Level;
        DocInfoContainer.pData = pDocInfo;

        RpcTryExcept {

            if ( ReturnValue = RpcStartDocPrinter(pSpool->RpcHandle,
                                                  (LPDOC_INFO_CONTAINER)&DocInfoContainer,
                                                   &JobId) ) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = JobId;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMStartDocPrinter(hPrinter, Level, pDocInfo);

    return ReturnValue;
}

BOOL
StartPagePrinter(
    HANDLE hPrinter
)
{
    BOOL ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );


    if (pSpool->Status & WSPOOL_STATUS_PRINT_FILE) {
        return TRUE;
    }

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if ( ReturnValue = RpcStartPagePrinter(pSpool->RpcHandle) ) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMStartPagePrinter(hPrinter);

    return ReturnValue;
}

BOOL
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    BOOL ReturnValue=TRUE;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    *pcWritten = 0;

    if (pSpool->Status & WSPOOL_STATUS_PRINT_FILE) {

        ReturnValue = WriteFile(pSpool->hFile, pBuf, cbBuf, pcWritten, NULL);
        return ReturnValue;

    }

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            // Note this code used chop the request into 4k chunks which were
            // the prefered size for Rpc.   However the client dll batches all
            // data into 4k chunks so no need to duplcate that code here.

            if (ReturnValue = RpcWritePrinter(pSpool->RpcHandle, pBuf, cbBuf, pcWritten)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept


    } else {

        return LMWritePrinter(hPrinter, pBuf, cbBuf, pcWritten);

    }

    return ReturnValue;
}

BOOL
SeekPrinter(
    HANDLE  hPrinter,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER pliNewPointer,
    DWORD dwMoveMethod,
    BOOL bWrite
)
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
FlushPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    DWORD   cSleep
)
{
    BOOL     bReturn = TRUE;
    DWORD    dwError;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    RpcTryExcept {

        if ((dwError = RpcValidate()) ||
            (dwError = RpcFlushPrinter(pSpool->RpcHandle,
                                       pBuf,
                                       cbBuf,
                                       pcWritten,
                                       cSleep)))
        {
            SetLastError( dwError );
            bReturn = FALSE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError( RpcExceptionCode() );
        bReturn = FALSE;

    } RpcEndExcept

    return bReturn;
}

BOOL
EndPagePrinter(
    HANDLE  hPrinter
)
{
    BOOL ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    if (pSpool->Status & WSPOOL_STATUS_PRINT_FILE) {
        return TRUE;
    }

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcEndPagePrinter(pSpool->RpcHandle)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMEndPagePrinter(hPrinter);

    return ReturnValue;
}

BOOL
AbortPrinter(
    HANDLE  hPrinter
)
{
    BOOL  ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcAbortPrinter(pSpool->RpcHandle)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMAbortPrinter(hPrinter);

    return ReturnValue;
}

BOOL
ReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead
)
{
    BOOL ReturnValue=TRUE;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );


    if (pSpool->Status & WSPOOL_STATUS_PRINT_FILE ) {
        return FALSE;
    }

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcReadPrinter(pSpool->RpcHandle, pBuf, cbBuf, pNoBytesRead)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMReadPrinter(hPrinter, pBuf, cbBuf, pNoBytesRead);

    return ReturnValue;
}

BOOL
RemoteEndDocPrinter(
   HANDLE   hPrinter
)
{
    BOOL ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    if (pSpool->Status & WSPOOL_STATUS_PRINT_FILE) {
        CloseHandle( pSpool->hFile );
        pSpool->hFile = INVALID_HANDLE_VALUE;
        pSpool->Status &= ~WSPOOL_STATUS_PRINT_FILE;
        return TRUE;
    }

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcEndDocPrinter(pSpool->RpcHandle)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMEndDocPrinter(hPrinter);

   return ReturnValue;
}

BOOL
AddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL     ReturnValue = FALSE;
    DWORD    dwRet = 0;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;
    DWORD    cReturned = 1;
    FieldInfo *pFieldInfo;
    SIZE_T   cbStruct;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        switch (Level) {

        case 1:
            pFieldInfo = AddJobFields;
            cbStruct = sizeof(ADDJOB_INFO_1W);
            break;
        case 2:
        case 3:
            //
            // Block level 2 & 3 calls across the network.
            //
        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        RpcTryExcept {

            if (dwRet = RpcAddJob(pSpool->RpcHandle, Level, pData,cbBuf, pcbNeeded) ) {

                dwRet = UpdateBufferSize(pFieldInfo, cbStruct, pcbNeeded, cbBuf, dwRet, &cReturned);

                SetLastError(dwRet);
                ReturnValue = FALSE;

            } else {

                ReturnValue = MarshallUpStructure(pData, AddJobFields, cbStruct, RPC_CALL);
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMAddJob(hPrinter, Level, pData, cbBuf, pcbNeeded);

    return ReturnValue;
}

BOOL
ScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
)
{
    BOOL ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcScheduleJob(pSpool->RpcHandle, JobId)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else

        return LMScheduleJob(hPrinter, JobId);

    return ReturnValue;
}

DWORD
RemoteGetPrinterData(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD    ReturnValue = 0;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;
    DWORD    Type = REG_SZ, cbNeeded = 0;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue =  RpcGetPrinterData(pSpool->RpcHandle, pValueName, &Type,
                                             pData, nSize, &cbNeeded);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    if (pType) {

        *pType = Type;
    }

    if (pcbNeeded) {

        *pcbNeeded = cbNeeded;
    }

    return ReturnValue;
}

DWORD
RemoteGetPrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD    ReturnValue = 0;
    PWSPOOL  pSpool      = (PWSPOOL)hPrinter;
    DWORD    Type = REG_SZ, cbNeeded = 0;


    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue =  RpcGetPrinterDataEx( pSpool->RpcHandle,
                                                pKeyName,
                                                pValueName,
                                                &Type,
                                                pData,
                                                nSize,
                                                &cbNeeded);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    if (pType) {

        *pType = Type;
    }

    if (pcbNeeded) {

        *pcbNeeded = cbNeeded;
    }

    return ReturnValue;
}


DWORD
RemoteEnumPrinterData(
   HANDLE   hPrinter,
   DWORD    dwIndex,
   LPWSTR   pValueName,
   DWORD    cbValueName,
   LPDWORD  pcbValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    cbData,
   LPDWORD  pcbData
)
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    DWORD   ReturnCbData = 0;

    PWSPOOL pSpool = (PWSPOOL)hPrinter;
    DWORD   Type, cbNeeded;

    // Downlevel variables
    LPWSTR  pKeyName = NULL;
    PWCHAR  pPrinterName = NULL;
    PWCHAR  pScratch = NULL;
    PWCHAR  pBuffer = NULL;
    LPPRINTER_INFO_1W pPrinter1 = NULL;
    PWCHAR  pMachineName = NULL;
    HKEY    hkMachine = INVALID_HANDLE_VALUE;
    HKEY    hkDownlevel = INVALID_HANDLE_VALUE;
    DWORD   dwNeeded;


    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        //
        // The user should be able to pass in NULL for buffer, and
        // 0 for size.  However, the RPC interface specifies a ref pointer,
        // so we must pass in a valid pointer.  Pass in a pointer to
        // a dummy pointer.
        //

        if (!pValueName && !cbValueName)
            pValueName = (LPWSTR) &ReturnValue;

        if(!pData && !cbData)
            pData = (PBYTE)&ReturnValue;

        if (!pType)
            pType = (PDWORD) &ReturnType;

        if (!pcbData)
            pcbData = &ReturnCbData;

        RpcTryExcept {

            ReturnValue =  RpcEnumPrinterData(  pSpool->RpcHandle,
                                                dwIndex,
                                                pValueName,
                                                cbValueName,
                                                pcbValueName,
                                                pType,
                                                pData,
                                                cbData,
                                                pcbData
                                              );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    // If the remote spooler doesn't support EnumPrinterData, do it the old way
    if (ReturnValue == RPC_S_PROCNUM_OUT_OF_RANGE) {

        DWORD cchBuffer = wcslen(pszRemoteRegistryPrinters) + MAX_UNC_PRINTER_NAME;

        pBuffer    = AllocSplMem(cchBuffer * sizeof(WCHAR));
        pScratch   = AllocSplMem(MAX_UNC_PRINTER_NAME*sizeof(WCHAR));
        pPrinter1  = AllocSplMem(MAX_PRINTER_INFO1);

        if (pBuffer == NULL || pScratch == NULL || pPrinter1 == NULL) {
            ReturnValue = GetLastError();
            goto DownlevelDone;
        }

        SPLASSERT ( 0 == _wcsnicmp( pSpool->pName, L"\\\\", 2 ) ) ;
        SPLASSERT ( pSpool->Status & WSPOOL_STATUS_USE_CACHE );

        StringCchCopy(pBuffer, cchBuffer, pSpool->pName);

        pPrinterName = wcschr( pBuffer+2, L'\\' );
        *pPrinterName = L'\0';
        pMachineName = AllocSplStr( pBuffer );

        if (pMachineName == NULL) {
            ReturnValue = GetLastError();
            goto DownlevelDone;
        }

        //  We cannot use pSpool->pName since this might be the share name which will
        //  fail if we try to use it as a registry key on the remote machine
        //  Get the full friendly name from the cache

        if ( !SplGetPrinter( pSpool->hSplPrinter, 1, (LPBYTE)pPrinter1, MAX_PRINTER_INFO1, &dwNeeded )) {
            DBGMSG( DBG_ERROR, ("RemoteEnumPrinterData failed SplGetPrinter %d pSpool %x\n", GetLastError(), pSpool ));
            ReturnValue = GetLastError();
            goto    DownlevelDone;
        }

        pPrinterName = wcschr( pPrinter1->pName+2, L'\\' );

        if ( pPrinterName++ == NULL ) {
            ReturnValue = ERROR_INVALID_PARAMETER;
            goto    DownlevelDone;
        }

        //
        //  Generate the Correct KeyName from the Printer Name
        //

        DBGMSG( DBG_TRACE,(" pSpool->pName %ws pPrinterName %ws\n", pSpool->pName, pPrinterName));

        pKeyName = FormatPrinterForRegistryKey( pPrinterName, pScratch, MAX_UNC_PRINTER_NAME);

        StringCchPrintf( pBuffer, cchBuffer, pszRemoteRegistryPrinters, pKeyName );

        //  Because there is no EnumPrinterData downlevel we are forced to open the remote registry
        //  for LocalSpl and use the registry RegEnumValue to read through the printer data
        //  values.

        ReturnValue = RegConnectRegistry( pMachineName, HKEY_LOCAL_MACHINE, &hkMachine);

        if (ReturnValue != ERROR_SUCCESS) {
            DBGMSG( DBG_WARNING, ("RemoteEnumPrinterData RegConnectRegistry error %d\n",GetLastError()));
            goto    DownlevelDone;
        }

        ReturnValue = RegOpenKeyEx(hkMachine, pBuffer, 0, KEY_READ, &hkDownlevel);

        if ( ReturnValue != ERROR_SUCCESS ) {

            DBGMSG( DBG_WARNING, ("RemoteEnumPrinterData RegOpenKeyEx %ws error %d\n", pBuffer, ReturnValue ));
            goto    DownlevelDone;
        }

        // Get the max sizes
        if (!cbValueName && !cbData) {
            ReturnValue = RegQueryInfoKey(  hkDownlevel,    // Key
                                            NULL,           // lpClass
                                            NULL,           // lpcbClass
                                            NULL,           // lpReserved
                                            NULL,           // lpcSubKeys
                                            NULL,           // lpcbMaxSubKeyLen
                                            NULL,           // lpcbMaxClassLen
                                            NULL,           // lpcValues
                                            pcbValueName,   // lpcbMaxValueNameLen
                                            pcbData,        // lpcbMaxValueLen
                                            NULL,           // lpcbSecurityDescriptor
                                            NULL            // lpftLastWriteTime
                                        );

            *pcbValueName = (*pcbValueName + 1)*sizeof(WCHAR);

        } else {   // Do an enum

            *pcbValueName = cbValueName/sizeof(WCHAR);
            *pcbData = cbData;
            ReturnValue = RegEnumValue( hkDownlevel,
                                        dwIndex,
                                        pValueName,
                                        pcbValueName,
                                        NULL,
                                        pType,
                                        pData,
                                        pcbData
                                      );
            *pcbValueName = (*pcbValueName + 1)*sizeof(WCHAR);
        }

DownlevelDone:

        FreeSplMem(pBuffer);
        FreeSplStr(pScratch);
        FreeSplMem(pPrinter1);
        FreeSplStr(pMachineName);

        if (hkMachine != INVALID_HANDLE_VALUE)
            RegCloseKey(hkMachine);

        if (hkDownlevel != INVALID_HANDLE_VALUE)
            RegCloseKey(hkDownlevel);
    }

    return ReturnValue;
}


DWORD
RemoteEnumPrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPBYTE   pEnumValues,
   DWORD    cbEnumValues,
   LPDWORD  pcbEnumValues,
   LPDWORD  pnEnumValues
)
{
    DWORD   ReturnValue = 0;
    DWORD   RpcReturnValue = 0;
    DWORD   i;
    PWSPOOL pSpool = (PWSPOOL)hPrinter;
    PPRINTER_ENUM_VALUES pEnumValue = (PPRINTER_ENUM_VALUES) pEnumValues;
    DWORD    nEnumValues = 0;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        //
        // The user should be able to pass in NULL for buffer, and
        // 0 for size.  However, the RPC interface specifies a ref pointer,
        // so we must pass in a valid pointer.  Pass in a pointer to
        // a dummy pointer.
        //

        if (!pEnumValues && !cbEnumValues)
            pEnumValues = (LPBYTE) &ReturnValue;


        RpcTryExcept {

            ReturnValue =  RpcEnumPrinterDataEx(pSpool->RpcHandle,
                                                pKeyName,
                                                pEnumValues,
                                                cbEnumValues,
                                                pcbEnumValues,
                                                &nEnumValues);

            RpcReturnValue = ReturnValue;

            ReturnValue = UpdateBufferSize(PrinterEnumValuesFields,
                                           sizeof(PRINTER_ENUM_VALUES),
                                           pcbEnumValues,
                                           cbEnumValues,
                                           ReturnValue,
                                           &nEnumValues);

            //
            // When talking with a 32bit machine, the buffer could be big enough to acomodate
            // the data packed on 32bit boundaries but not big enough to expand it for 64bit.
            // In this case, UpdateBufferSize fails with ERROR_INSUFFICIENT_BUFFER which
            // is a valid error for all printing APIs but EnumPrinterDataEx.
            // SDK specifies that EnumPrinterDataEx should fail with ERROR_MORE_DATA in this case,
            // so here we go.
            //
            //
            if (RpcReturnValue == ERROR_SUCCESS &&
                ReturnValue == ERROR_INSUFFICIENT_BUFFER) {

                ReturnValue = ERROR_MORE_DATA;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept



        if (ReturnValue == ERROR_SUCCESS) {
            if (pEnumValues) {

                SIZE_T   ShrinkedSize = 0;
                SIZE_T   Difference = 0;

                if (GetShrinkedSize(PrinterEnumValuesFields, &ShrinkedSize)) {

                    //
                    // SplEnumPrinterDataEx ( in localspl.dll ) packs the data right after
                    // the end of array of PPRINTER_ENUM_VALUES structures. Our Marshalling
                    // code relies on the fact that there is enough unused space between the end of
                    // structure/array and the beginning of data to expand a 32bit flat structure to
                    // a 64 bit structure.For all other structures we pack data from end to beginning
                    // of buffer. localspl.dll could have been fixed to do the same thing, but Win2K
                    // servers would still have this problem.
                    // The fix is to still ask for bigger buffers for 64bit (UpdateBufferSize)
                    // and then move the chunk containing data inside the buffer so that it leaves
                    // space for structure to grow.
                    // On Win32 we don't do anything since ShrinkedSize is equal with sizeof(PRINTER_ENUM_VALUES).
                    //
                    MoveMemory((LPBYTE)pEnumValue + sizeof(PRINTER_ENUM_VALUES) * (nEnumValues),
                               (LPBYTE)pEnumValue + ShrinkedSize * (nEnumValues),
                               cbEnumValues - sizeof(PRINTER_ENUM_VALUES) * (nEnumValues));

                    //
                    // Difference is the number of bytes we moved data section inside pEnumValue buffer
                    // It should be 0 in Win32
                    //
                    Difference = (sizeof(PRINTER_ENUM_VALUES) - ShrinkedSize ) * (nEnumValues);

                    if(! MarshallUpStructuresArray((LPBYTE) pEnumValue, nEnumValues, PrinterEnumValuesFields,
                                                    sizeof(PRINTER_ENUM_VALUES), RPC_CALL) ) {
                        ReturnValue = GetLastError();
                    }

                    //
                    // We need to adjust the offsets with Difference inside structures since data got moved.
                    //
                    AdjustPointersInStructuresArray((LPBYTE) pEnumValue, nEnumValues, PrinterEnumValuesFields,
                                                    sizeof(PRINTER_ENUM_VALUES), Difference);

                } else {

                    ReturnValue = GetLastError();
                }

            }
        }
    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    if (pnEnumValues) {

        *pnEnumValues = nEnumValues;
    }

    return ReturnValue;
}

DWORD
RemoteEnumPrinterKey(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPWSTR   pSubkey,
   DWORD    cbSubkey,
   LPDWORD  pcbSubkey
)
{
    DWORD   ReturnValue = 0;
    DWORD   ReturnType = 0;
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        //
        // The user should be able to pass in NULL for buffer, and
        // 0 for size.  However, the RPC interface specifies a ref pointer,
        // so we must pass in a valid pointer.  Pass in a pointer to
        // a dummy pointer.
        //

        if (!pSubkey && !cbSubkey)
            pSubkey = (LPWSTR) &ReturnValue;


        RpcTryExcept {

            ReturnValue =  RpcEnumPrinterKey(pSpool->RpcHandle,
                                             pKeyName,
                                             pSubkey,
                                             cbSubkey,
                                             pcbSubkey
                                             );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    return ReturnValue;
}



DWORD
RemoteDeletePrinterData(
   HANDLE   hPrinter,
   LPWSTR   pValueName
)
{
    DWORD   ReturnValue = 0;
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue =  RpcDeletePrinterData(pSpool->RpcHandle, pValueName);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    if ( ReturnValue == ERROR_SUCCESS )
        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);

    return ReturnValue;
}


DWORD
RemoteDeletePrinterDataEx(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName,
   LPCWSTR  pValueName
)
{
    DWORD   ReturnValue = 0;
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue =  RpcDeletePrinterDataEx(pSpool->RpcHandle, pKeyName, pValueName);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    if ( ReturnValue == ERROR_SUCCESS )
        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);

    return ReturnValue;
}


DWORD
RemoteDeletePrinterKey(
   HANDLE   hPrinter,
   LPCWSTR  pKeyName
)
{
    DWORD   ReturnValue = 0;
    PWSPOOL pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue =  RpcDeletePrinterKey(pSpool->RpcHandle, pKeyName);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    if ( ReturnValue == ERROR_SUCCESS )
        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);

    return ReturnValue;
}



DWORD
SetPrinterData(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue = RpcSetPrinterData(pSpool->RpcHandle, pValueName, Type,
                                            pData, cbData);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }

    //
    //  Make sure Driver Data Cache is consistent
    //


    if ( ReturnValue == ERROR_SUCCESS ) {

        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
    }

    return ReturnValue;
}


DWORD
RemoteSetPrinterDataEx(
    HANDLE  hPrinter,
    LPCWSTR pKeyName,
    LPCWSTR pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            ReturnValue = RpcSetPrinterDataEx(  pSpool->RpcHandle,
                                                pKeyName,
                                                pValueName,
                                                Type,
                                                pData,
                                                cbData);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ReturnValue = RpcExceptionCode();

        } RpcEndExcept

    } else {

        ReturnValue = ERROR_INVALID_FUNCTION;
    }


    if ( ReturnValue == ERROR_SUCCESS ) {

        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
    }

    return ReturnValue;
}



BOOL
RemoteClosePrinter(
    HANDLE  hPrinter
)
{
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    if (pSpool->Status & WSPOOL_STATUS_OPEN_ERROR) {

        DBGMSG(DBG_WARNING, ("Closing dummy handle to %ws\n", pSpool->pName));

        return TRUE;
    }

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            RpcClosePrinter(&pSpool->RpcHandle);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        } RpcEndExcept

        //
        // If we failed for some reason, then RpcClosePrinter did not
        // zero out the context handle.  Destroy it here.
        //
        if( pSpool->RpcHandle ){
            RpcSmDestroyClientContext( &pSpool->RpcHandle );
        }

        EnterSplSem();

         pSpool->RpcHandle = NULL;

        LeaveSplSem();

    } else

        return LMClosePrinter(hPrinter);

    return TRUE;
}

DWORD
WaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
)
{
    DWORD   ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if( pSpool->Status & WSPOOL_STATUS_NOTIFY ){
        DBGMSG( DBG_WARNING, ( "WPC: Already waiting.\n" ));
        SetLastError( ERROR_ALREADY_WAITING );
        return 0;
    }

    pSpool->Status |= WSPOOL_STATUS_NOTIFY;

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcWaitForPrinterChange(pSpool->RpcHandle, Flags, &Flags)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = Flags;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else {

        ReturnValue = LMWaitForPrinterChange(hPrinter, Flags);
    }

    pSpool->Status &= ~WSPOOL_STATUS_NOTIFY;

    return ReturnValue;
}

BOOL
AddForm(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
)
{
    BOOL  ReturnValue;
    GENERIC_CONTAINER   FormContainer;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        FormContainer.Level = Level;
        FormContainer.pData = pForm;

        RpcTryExcept {

            if (ReturnValue = RpcAddForm(pSpool->RpcHandle, (PFORM_CONTAINER)&FormContainer)) {
                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;;

        } RpcEndExcept

    } else {

        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    //
    //  Make sure Forms Cache is consistent
    //


    if ( ReturnValue ) {

        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
    }


    return ReturnValue;
}

BOOL
DeleteForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName
)
{
    BOOL  ReturnValue;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        RpcTryExcept {

            if (ReturnValue = RpcDeleteForm(pSpool->RpcHandle, pFormName)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;;

        } RpcEndExcept

    } else {

        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    //
    //  Make sure Forms Cache is consistent
    //


    if ( ReturnValue ) {

        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
    }


    return ReturnValue;
}

BOOL
RemoteGetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue = FALSE;
    FieldInfo *pFieldInfo;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;
    SIZE_T   cbStruct;
    DWORD   cReturned = 1;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        switch (Level) {

        case 1:
            pFieldInfo = FormInfo1Fields;
            cbStruct = sizeof(FORM_INFO_1);
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        if (pForm)
            memset(pForm, 0, cbBuf);

        RpcTryExcept {

            if (ReturnValue = RpcGetForm(pSpool->RpcHandle, pFormName, Level, pForm, cbBuf,
                                         pcbNeeded) ) {

                ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             &cReturned);

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

                if (pForm) {

                    ReturnValue = MarshallUpStructure(pForm, pFieldInfo, cbStruct, RPC_CALL);
                }

            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else {

        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    return ReturnValue;
}

BOOL
SetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
)
{
    BOOL  ReturnValue;
    GENERIC_CONTAINER   FormContainer;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        FormContainer.Level = Level;
        FormContainer.pData = pForm;

        RpcTryExcept {

            if (ReturnValue = RpcSetForm(pSpool->RpcHandle, pFormName,
                                    (PFORM_CONTAINER)&FormContainer)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;;

        } RpcEndExcept

    } else {

        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    //
    //  Make sure Forms Cache is consistent
    //
    if ( ReturnValue ) {

        ConsistencyCheckCache(pSpool, kCheckPnPPolicy);
    }

    return ReturnValue;
}

BOOL
RemoteEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   ReturnValue, cbStruct;
    FieldInfo *pFieldInfo;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        switch (Level) {

        case 1:
            pFieldInfo = FormInfo1Fields;
            cbStruct = sizeof(FORM_INFO_1);
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        RpcTryExcept {

            if (pForm)
                memset(pForm, 0, cbBuf);

            if (ReturnValue = RpcEnumForms(pSpool->RpcHandle, Level,
                                           pForm, cbBuf,
                                           pcbNeeded, pcReturned) ,

                ReturnValue = UpdateBufferSize(pFieldInfo,
                                               cbStruct,
                                               pcbNeeded,
                                               cbBuf,
                                               ReturnValue,
                                               pcReturned)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {

                ReturnValue = TRUE;

                if (pForm) {

                    if(! MarshallUpStructuresArray(pForm, *pcReturned, pFieldInfo,
                                                   cbStruct, RPC_CALL) ) {
                        return FALSE;
                    }

                }
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;;

        } RpcEndExcept

    } else {

        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    return (BOOL)ReturnValue;
}

BOOL
RemoteEnumPorts(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPort,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   ReturnValue, cbStruct;
    FieldInfo *pFieldInfo;

    *pcReturned = 0;
    *pcbNeeded = 0;

    if (MyName(pName))
        return LMEnumPorts(pName, Level, pPort, cbBuf, pcbNeeded, pcReturned);

    if (MyUNCName(pName)) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (Level) {

    case 1:
        pFieldInfo = PortInfo1Fields;
        cbStruct = sizeof(PORT_INFO_1);
        break;

    case 2:
        pFieldInfo = PortInfo2Fields;
        cbStruct = sizeof(PORT_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (pPort)
            memset(pPort, 0, cbBuf);

        if ( (ReturnValue = RpcValidate()) ||

             (ReturnValue = RpcEnumPorts(pName, Level, pPort,
                                         cbBuf, pcbNeeded,
                                         pcReturned ) ,

              ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             pcReturned)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pPort) {

                if(! MarshallUpStructuresArray( pPort, *pcReturned, pFieldInfo,
                                                cbStruct, RPC_CALL) ) {
                    return FALSE;
                }

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return (BOOL) ReturnValue;
}

BOOL
EnumMonitors(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitor,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   ReturnValue, cbStruct;
    FieldInfo *pFieldInfo;

    *pcReturned = 0;
    *pcbNeeded = 0;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (Level) {

    case 1:
        pFieldInfo = MonitorInfo1Fields;
        cbStruct = sizeof(MONITOR_INFO_1);
        break;

    case 2:
        pFieldInfo = MonitorInfo2Fields;
        cbStruct = sizeof(MONITOR_INFO_2);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {

        if (pMonitor)
            memset(pMonitor, 0, cbBuf);

        if ( (ReturnValue = RpcValidate()) ||

             (ReturnValue = RpcEnumMonitors(pName, Level, pMonitor, cbBuf,
                                            pcbNeeded, pcReturned) ,
              ReturnValue = UpdateBufferSize(pFieldInfo,
                                             cbStruct,
                                             pcbNeeded,
                                             cbBuf,
                                             ReturnValue,
                                             pcReturned)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

            if (pMonitor) {

                if(! MarshallUpStructuresArray( pMonitor, *pcReturned, pFieldInfo,
                                                cbStruct, RPC_CALL) ) {
                    return FALSE;
                }

            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return (BOOL) ReturnValue;
}

BOOL
RemoteAddPort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
)
{
    if (MyName(pName) || (VALIDATE_NAME(pName) && !MyUNCName(pName))) {
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    SetLastError(ERROR_INVALID_NAME);
    return FALSE;
}

BOOL
RemoteConfigurePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
)
{
    if (MyName(pName) || (VALIDATE_NAME(pName) && !MyUNCName(pName))) {
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    SetLastError(ERROR_INVALID_NAME);
    return FALSE;
}

BOOL
RemoteDeletePort(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
)
{
    if (MyName(pName))
        return LMDeletePort(pName, hWnd, pPortName);

    if (MyName(pName) || (VALIDATE_NAME(pName) && !MyUNCName(pName))) {
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    SetLastError(ERROR_INVALID_NAME);
    return FALSE;
}

HANDLE
CreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODE   pDevMode
)
{
    HANDLE  ReturnValue;
    DWORD   Error;
    DEVMODE_CONTAINER    DevModeContainer;
    HANDLE  hGdi;
    PWSPOOL  pSpool = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        if (pDevMode)

            DevModeContainer.cbBuf = pDevMode->dmSize + pDevMode->dmDriverExtra;

        else

            DevModeContainer.cbBuf = 0;

        DevModeContainer.pDevMode = (LPBYTE)pDevMode;

        RpcTryExcept {

            if (Error = RpcCreatePrinterIC(pSpool->RpcHandle, &hGdi,
                                                 &DevModeContainer)) {

                SetLastError(Error);
                ReturnValue = FALSE;

            } else

                ReturnValue = hGdi;

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

    } else {
        SetLastError(ERROR_INVALID_FUNCTION);
        ReturnValue = FALSE;
    }

    return ReturnValue;
}

BOOL
PlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
)
{
    BOOL ReturnValue;

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcPlayGdiScriptOnPrinterIC(hPrinterIC, pIn, cIn,
                                                        pOut, cOut, ul)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePrinterIC(
    HANDLE  hPrinterIC
)
{
    BOOL    ReturnValue;

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcDeletePrinterIC(&hPrinterIC)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

DWORD
PrinterMessageBox(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD   dwType
)
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}

BOOL
AddMonitorW(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pMonitorInfo
)
{
    BOOL  ReturnValue;
    MONITOR_CONTAINER   MonitorContainer;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (Level) {

    case 2:
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    MonitorContainer.Level = Level;
    MonitorContainer.MonitorInfo.pMonitorInfo2 = (MONITOR_INFO_2 *)pMonitorInfo;

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcAddMonitor(pName, &MonitorContainer)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeleteMonitorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pMonitorName
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcDeleteMonitor(pName,
                                             pEnvironment,
                                             pMonitorName)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
DeletePrintProcessorW(
    LPWSTR  pName,
    LPWSTR  pEnvironment,
    LPWSTR  pPrintProcessorName
)
{
    BOOL  ReturnValue;

    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcDeletePrintProcessor(pName,
                                                    pEnvironment,
                                                    pPrintProcessorName)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;

    } RpcEndExcept

    return ReturnValue;
}

BOOL
GetPrintSystemVersion(
)
{
    DWORD Status;
    HKEY hKey;
    DWORD cbData;

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegistryRoot, 0,
                          KEY_READ, &hKey);
    if (Status != ERROR_SUCCESS) {
        DBGMSG(DBG_ERROR, ("Cannot determine Print System Version Number\n"));
        return FALSE;
    }


    cbData = sizeof (cThisMinorVersion);
    if (RegQueryValueEx(hKey, szMinorVersion, NULL, NULL,
                    (LPBYTE)&cThisMinorVersion, &cbData)
                                            == ERROR_SUCCESS) {
        DBGMSG(DBG_TRACE, ("This Minor Version - %d\n", cThisMinorVersion));
    }

    RegCloseKey(hKey);

    return TRUE;
}



BOOL
RemoteAddPortEx(
   LPWSTR   pName,
   DWORD    Level,
   LPBYTE   lpBuffer,
   LPWSTR   lpMonitorName
)
{
    DWORD   ReturnValue;
    PORT_CONTAINER PortContainer;
    PORT_VAR_CONTAINER PortVarContainer;
    PPORT_INFO_FF pPortInfoFF;
    PPORT_INFO_1 pPortInfo1;


    if ( !VALIDATE_NAME(pName) || MyUNCName(pName) ) {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    if (!lpBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    switch (Level) {
    case (DWORD)-1:
        pPortInfoFF = (PPORT_INFO_FF)lpBuffer;
        PortContainer.Level = Level;
        PortContainer.PortInfo.pPortInfoFF = (PPORT_INFO_FF)pPortInfoFF;
        PortVarContainer.cbMonitorData = pPortInfoFF->cbMonitorData;
        PortVarContainer.pMonitorData = pPortInfoFF->pMonitorData;
        break;

    case 1:
        pPortInfo1 = (PPORT_INFO_1)lpBuffer;
        PortContainer.Level = Level;
        PortContainer.PortInfo.pPortInfo1 = (PPORT_INFO_1)pPortInfo1;
        PortVarContainer.cbMonitorData = 0;
        PortVarContainer.pMonitorData = NULL;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    RpcTryExcept {
        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcAddPortEx(pName, (LPPORT_CONTAINER)&PortContainer,
                                         (LPPORT_VAR_CONTAINER)&PortVarContainer,
                                         lpMonitorName)) ) {

            SetLastError(ReturnValue);
            return FALSE;
        } else {
            return TRUE ;
        }
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        SetLastError(RpcExceptionCode());
        return  FALSE;

    } RpcEndExcept
}


BOOL
SetPort(
    LPWSTR      pszName,
    LPWSTR      pszPortName,
    DWORD       dwLevel,
    LPBYTE      pPortInfo
    )
{
    BOOL            ReturnValue = FALSE;
    PORT_CONTAINER  PortContainer;

    if ( !VALIDATE_NAME(pszName) || MyUNCName(pszName) ) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    switch (dwLevel) {

        case 3:
            PortContainer.Level                 = dwLevel;
            PortContainer.PortInfo.pPortInfo3   = (LPPORT_INFO_3W) pPortInfo;
            break;

        default:
            SetLastError(ERROR_INVALID_LEVEL);
            goto Cleanup;
    }

    RpcTryExcept {

        if ( (ReturnValue = RpcValidate()) ||
             (ReturnValue = RpcSetPort(pszName, pszPortName, &PortContainer)) ) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;
        } else {

            ReturnValue = TRUE;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        SetLastError(RpcExceptionCode());
        ReturnValue = FALSE;
    } RpcEndExcept

Cleanup:
    return ReturnValue;
}

BOOL
RemoteXcvData(
    HANDLE      hXcv,
    PCWSTR      pszDataName,
    PBYTE       pInputData,
    DWORD       cbInputData,
    PBYTE       pOutputData,
    DWORD       cbOutputData,
    PDWORD      pcbOutputNeeded,
    PDWORD      pdwStatus
)
{

    DWORD   ReturnValue = 0;
    PWSPOOL pSpool = (PWSPOOL)hXcv;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE) {

        //
        // The user should be able to pass in NULL for buffer, and
        // 0 for size.  However, the RPC interface specifies a ref pointer,
        // so we must pass in a valid pointer.  Pass in a pointer to
        // a dummy pointer.
        //

        if (!pInputData && !cbInputData)
            pInputData = (PBYTE) &ReturnValue;

        if (!pOutputData && !cbOutputData)
            pOutputData = (PBYTE) &ReturnValue;


        RpcTryExcept {

            if (ReturnValue = RpcXcvData(   pSpool->RpcHandle,
                                            pszDataName,
                                            pInputData,
                                            cbInputData,
                                            pOutputData,
                                            cbOutputData,
                                            pcbOutputNeeded,
                                            pdwStatus)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else {
                ReturnValue = TRUE;
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
            ReturnValue = FALSE;

        } RpcEndExcept

        if (!ReturnValue)
            DBGMSG(DBG_TRACE,("XcvData Exception: %d\n", GetLastError()));

    } else {

        SetLastError( ERROR_NOT_SUPPORTED );
        ReturnValue = FALSE;
    }

    return ReturnValue;
}

DWORD
RemoteSendRecvBidiData(
    IN  HANDLE                    hPrinter,
    IN  LPCTSTR                   pAction,
    IN  PBIDI_REQUEST_CONTAINER   pReqData,
    OUT PBIDI_RESPONSE_CONTAINER* ppResData
)
{
    DWORD        dwRet   = ERROR_SUCCESS;
    PWSPOOL      pSpool  = (PWSPOOL)hPrinter;

    VALIDATEW32HANDLE( pSpool );

    SYNCRPCHANDLE( pSpool );

    if (pSpool->Type == SJ_WIN32HANDLE)
    {

        RpcTryExcept
        {
            dwRet = RpcSendRecvBidiData(pSpool->RpcHandle,
                                        pAction,
                                        (PRPC_BIDI_REQUEST_CONTAINER)pReqData,
                                        (PRPC_BIDI_RESPONSE_CONTAINER*)ppResData);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            dwRet = RpcExceptionCode();
        }
        RpcEndExcept
    }
    else
    {
        dwRet = ERROR_NOT_SUPPORTED;
    }

    return (dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\spoolss\win32\winsplc.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    winsplc.c

Abstract:

    Stub file to allow winspl_c.c to work with precompiled headers.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#include "winspl_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\wpnpinst\exe\globals.c ===
/*----------------------------------------------------------------------------*\
| MODULE: GLOBALS.C
|
|   Global variables for wpnpinst program.
|
|   Copyright (C) 1997 Microsoft
|   Copyright (C) 1997 Hewlett Packard
|
| history:
|   26-Aug-1997 <rbkunz> Created
|
\*----------------------------------------------------------------------------*/
#include "pch.h"

HINSTANCE  g_hInstance;

// Misc Character constants
//
CONST TCHAR g_chBackslash   = TEXT('\\');
CONST TCHAR g_chDot         = TEXT('.');
CONST TCHAR g_chDoubleQuote = TEXT('\"');


//
//
CONST TCHAR g_szDotEXE[]  = TEXT(".EXE");
CONST TCHAR g_szDotDLL[]  = TEXT(".DLL");
CONST TCHAR g_szFNFmt []  = TEXT("%1\\%2");
CONST TCHAR g_szTNFmt []  = TEXT("~WP");


// Wide Char parm string to pass to PrintUIEntryW
//
CONST WCHAR g_wszParmString[] = L"@cab_ipp.dat";


// Module and entry point constants
//
CONST TCHAR g_szPrintUIMod   [] = TEXT("PRINTUI.DLL");
CONST CHAR  g_szPrintUIEntryW[] = "PrintUIEntryW";


// Localizable Error Strings
//
LPTSTR g_szErrorFormat          = NULL;
LPTSTR g_szError                = NULL;
LPTSTR g_szEGeneric             = NULL;
LPTSTR g_szEBadCAB              = NULL;
LPTSTR g_szEInvalidParameter    = NULL;
LPTSTR g_szENoMemory            = NULL;
LPTSTR g_szEInvalidCABName      = NULL;
LPTSTR g_szENoDATFile           = NULL;
LPTSTR g_szECABExtract          = NULL;
LPTSTR g_szENoPrintUI           = NULL;
LPTSTR g_szENoPrintUIEntry      = NULL;
LPTSTR g_szEPrintUIEntryFail    = NULL;
LPTSTR g_szENotSupported        = NULL;

FAKEFILE g_FileTable[FILETABLESIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\wpnpinst\exe\sources.inc ===
!IF 0
/*---------------------------------------------------------------------------*\
| MODULE: sources
|
|   FLAGS
|   -----
|   USE_MSVCRT
|   USE_CHWDLL
|
|
| history:
|   29-Dec-1996 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
!ENDIF

MAJORCOMP = windows
MINORCOMP = wpnpinst

TARGETNAME  = wpnpinst
TARGETPATH  = obj
TARGETTYPE  = PROGRAM

USE_MSVCRT = 1

INCLUDES = $(BASEDIR)\public\sdk\inc

MSC_WARNING_LEVEL=/W3 /WX

SOURCES = wpnpinst.c \
          globals.c  \
          wpnpinst.rc

UMTYPE  = $(MAJORCOMP)
UMAPPL  = $(MINORCOMP)
UMENTRY = $(TARGETENTRY)
UMBASE  = 0x4000000
TARGETLIBS  = $(SDK_LIB_PATH)\winspool.lib  \
          $(SDK_LIB_PATH)\wintrust.lib  \
          $(SDK_LIB_PATH)\fdi.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\wpnpinst\exe\wpnpinst.h ===
/*---------------------------------------------------------------------------*\
| MODULE: wnpinstl.h
|
|   This is the main header module for the application.
|
|
| Copyright (C) 1997 Microsoft Corporation
| Copyright (C) 1997 Hewlett Packard
|
| history:
|   25-Jul-1997 <rbkunz> created.
|
\*---------------------------------------------------------------------------*/

// Application Includes Section.
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>

#define C_RUNTIME_IO_ERROR -1
#define C_RUNTIME_SEEK_ERROR -1L

#define NT_VER_5 5
#define NT_VER_4 4

#define MAX_ARGS 3

#define MAX_RESBUF  128

#define IDS_ERR_FORMAT      1
#define IDS_ERR_ERROR       2
#define IDS_ERR_GENERIC     3
#define IDS_ERR_BADCAB      4
#define IDS_ERR_INVPARM     5
#define IDS_ERR_NOMEM       6
#define IDS_ERR_INVNAME     7
#define IDS_ERR_NODAT       8
#define IDS_ERR_CABFAIL     9
#define IDS_ERR_NOPRTUI    10
#define IDS_ERR_PRTUIENTRY 11
#define IDS_ERR_PRTUIFAIL  12
#define IDS_ERR_NOSUPPORT  13



typedef struct _FILENODE {
    PTSTR               pFileName;
    struct _FILENODE *  pNextFile;
} FILENODE, *PFILENODE;

typedef struct {
    PTSTR       pFullCABPath;
    PTSTR       pCABDir;
    PTSTR       pCABName;
    PTSTR       pTempDir;
    PFILENODE   pFileList;
} WPNPINFO, *PWPNPINFO;


// Local function declarations
//
BOOL    AdjustFileTime( INT_PTR hf, USHORT date, USHORT time );
DWORD   Attr32FromAttrFAT( WORD attrMSDOS );
LPWSTR  WCFromMB(LPCSTR lpszStr);
LPTSTR  BuildFileName(LPCTSTR lpszPath, LPCTSTR lpszName);
LPTSTR  FindRChar(LPTSTR lpszStr, CHAR cch);
LPTSTR  GetDirectory(LPTSTR lpszFile, LPDWORD lpdwReturn);
LPTSTR  GetName(LPTSTR lpszFile, LPDWORD ldwReturn);


PTSTR   GetCABName(PTSTR pCmdLine, LPDWORD lpdwReturn);
BOOL    AddFileToList(PWPNPINFO pInfo, PTSTR lpszFile);
VOID    CleanupFileList(PWPNPINFO pInfo);
BOOL    Extract(PWPNPINFO pInfo);
LPTSTR  GetWPNPSetupLibName(LPDWORD lpdwReturn);
DWORD   InvokePrintWizard(PWPNPINFO pInfo, LPDWORD lpAuthError);
DWORD   WebPnPCABInstall(LPTSTR lpszCABName, LPDWORD lpAuthError);
LPCTSTR LookupErrorString(DWORD dwErrorCode);
VOID    CheckErrors(DWORD dwErrorCode, DWORD dwAuthError);

INT WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\wpnpinst\exe\wpnpinst.c ===
/*---------------------------------------------------------------------------*\
| MODULE: WPNPINST.CXX
|
|   This is the main module for the WPNPINST application.
|
|   Copyright (C) 1997 Microsoft Corporation
|   Copyright (C) 1997 Hewlett Packard
|
| history:
|   25-Jul-1997 <rbkunz> Created.
|
\*---------------------------------------------------------------------------*/

#include "pch.h"

#define strFree(pszStr) {if (pszStr) GlobalFree((HANDLE)pszStr);}

/*****************************************************************************\
* strAlloc
*
*   Allocates a string from the heap.  This pointer must be freed with
*   a call to strFree().
*
\*****************************************************************************/
LPTSTR strAlloc(
    LPCTSTR pszSrc)
{
    DWORD  cbSize;
    LPTSTR pszDst = NULL;


    cbSize = (pszSrc ? ((lstrlen(pszSrc) + 1) * sizeof(TCHAR)) : 0);

    if (cbSize) {

        if (pszDst = (LPTSTR)GlobalAlloc(GPTR, cbSize))
            CopyMemory(pszDst, pszSrc, cbSize);
    }

    return pszDst;
}

/*****************************************************************************\
* strAllocAndCat
*
*   Allocates a string from the heap and concattenates another onto it.
*   This pointer must be freed with a call to strFree().
*
\*****************************************************************************/
LPTSTR strAllocAndCat(
    LPCTSTR pszSrc1,
    LPCTSTR pszSrc2)
{
    DWORD  cbSize;
    LPTSTR pszDst = NULL;


    cbSize = (pszSrc1 && pszSrc2 ? ((lstrlen(pszSrc1) + lstrlen(pszSrc2) + 1) * sizeof(TCHAR)) : 0);

    if (cbSize) {

        if (pszDst = (LPTSTR)GlobalAlloc(GPTR, cbSize)) 
        {
            if (FAILED(StringCbCopy(pszDst, cbSize, pszSrc1)) ||
                FAILED(StringCbCat (pszDst, cbSize, pszSrc2)))
            {
                GlobalFree(pszDst);
                pszDst = NULL;
            }
        }
    }

    return pszDst;
}


/*****************************************************************************\
* strLoad
*
*   Get string from resource based upon the ID passed in.
*
\*****************************************************************************/
LPTSTR strLoad(
    UINT ids)
{
    TCHAR szStr[MAX_RESBUF];


    if (LoadString(g_hInstance, ids, szStr, sizeof(szStr) / sizeof (TCHAR)) == 0)
        szStr[0] = TEXT('\0');

    return strAlloc(szStr);
}


/*****************************************************************************\
* InitStrings
*
*
\*****************************************************************************/
BOOL InitStrings(VOID)
{
    g_szErrorFormat       = strLoad(IDS_ERR_FORMAT);
    g_szError             = strLoad(IDS_ERR_ERROR);
    g_szEGeneric          = strLoad(IDS_ERR_GENERIC);
    g_szEBadCAB           = strLoad(IDS_ERR_BADCAB);
    g_szEInvalidParameter = strLoad(IDS_ERR_INVPARM);
    g_szENoMemory         = strLoad(IDS_ERR_NOMEM);
    g_szEInvalidCABName   = strLoad(IDS_ERR_INVNAME);
    g_szENoDATFile        = strLoad(IDS_ERR_NODAT);
    g_szECABExtract       = strLoad(IDS_ERR_CABFAIL);
    g_szENoPrintUI        = strLoad(IDS_ERR_NOPRTUI);
    g_szENoPrintUIEntry   = strLoad(IDS_ERR_PRTUIENTRY);
    g_szEPrintUIEntryFail = strLoad(IDS_ERR_PRTUIFAIL);
    g_szENotSupported     = strLoad(IDS_ERR_NOSUPPORT);


    return (g_szErrorFormat       &&
            g_szError             &&
            g_szEGeneric          &&
            g_szEBadCAB           &&
            g_szEInvalidParameter &&
            g_szENoMemory         &&
            g_szEInvalidCABName   &&
            g_szENoDATFile        &&
            g_szECABExtract       &&
            g_szENoPrintUI        &&
            g_szENoPrintUIEntry   &&
            g_szEPrintUIEntryFail &&
            g_szENotSupported
           );
}


/*****************************************************************************\
* FreeeStrings
*
*
\*****************************************************************************/
VOID FreeStrings(VOID)
{
    strFree(g_szErrorFormat);
    strFree(g_szError);
    strFree(g_szEGeneric);
    strFree(g_szEBadCAB);
    strFree(g_szEInvalidParameter);
    strFree(g_szENoMemory);
    strFree(g_szEInvalidCABName);
    strFree(g_szENoDATFile);
    strFree(g_szECABExtract);
    strFree(g_szENoPrintUI);
    strFree(g_szENoPrintUIEntry);
    strFree(g_szEPrintUIEntryFail);
    strFree(g_szENotSupported);
}


/*****************************************************************************\
*
* Win32Open (Local Routine)
*
* Translate a C-Runtime _open() call into appropriate Win32 CreateFile()
*
* NOTE:       Doesn't fully implement C-Runtime _open()
*             capability but it currently supports all callbacks
*             that FDI will give us
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\*****************************************************************************/
HANDLE Win32Open( LPCTSTR pszFile, int oflag, int pmode )
{
    HANDLE  FileHandle;
    BOOL    fExists     = FALSE;
    DWORD   fAccess;
    DWORD   fCreate;

    // NOTE: No Append Mode Support
    if (oflag & _O_APPEND)
        return INVALID_HANDLE_VALUE;

    // Set Read-Write Access
    if ((oflag & _O_RDWR) || (oflag & _O_WRONLY))
        fAccess = GENERIC_WRITE;
    else
        fAccess = GENERIC_READ;

    // Set Create Flags
    if (oflag & _O_CREAT)  {
        if (oflag & _O_EXCL)
            fCreate = CREATE_NEW;
        else if (oflag & _O_TRUNC)
            fCreate = CREATE_ALWAYS;
        else
            fCreate = OPEN_ALWAYS;
    } else {
        if (oflag & _O_TRUNC)
            fCreate = TRUNCATE_EXISTING;
        else
            fCreate = OPEN_EXISTING;
    }

    FileHandle = CreateFile( pszFile, fAccess, FILE_SHARE_READ, NULL, fCreate,
                             FILE_ATTRIBUTE_TEMPORARY | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,
                             NULL );

    // NOTE:  Doesn't create directories like C runtime.
    // We don't need this capability for this app though.
    // All our directories will already exist

    return FileHandle;
}

/******************************************************************************\
*
* openfunc (Local Routine)
*
* Opens a file.  Used by FDI interface.
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\******************************************************************************/
INT_PTR FAR DIAMONDAPI openfunc( CHAR FAR *pszFile, INT oflag, INT pmode ) {

    INT     rc;
    INT     i;
    PWSTR pwszFile = NULL;

    // Find Available File Handle in Fake File Table
    for ( i = 0; i < FILETABLESIZE; i++ ) {
        if ( g_FileTable[i].bAvailable == TRUE ) {
            break;
        }
    }

    // Running out of file handles should never happen
    if ( i == FILETABLESIZE )  {
        rc = C_RUNTIME_IO_ERROR;
    }


    if (NULL != (pwszFile = WCFromMB(pszFile)))
    {
        g_FileTable[i].hFile = Win32Open(pwszFile, oflag, pmode );
        GlobalFree(pwszFile);
    }

    if ( g_FileTable[i].hFile != INVALID_HANDLE_VALUE )  {
        g_FileTable[i].bAvailable = FALSE;
        rc = i;
    } else {
        rc = C_RUNTIME_IO_ERROR;
    }
    return rc;
}

/******************************************************************************\
*
* openfunc (Local Routine)
*
* Opens a file.  Used by FDINotify.
*
\******************************************************************************/
INT_PTR FAR DIAMONDAPI openfuncW( WCHAR FAR *pszFile, INT oflag, INT pmode ) {

    INT     rc;
    INT     i;

    // Find Available File Handle in Fake File Table
    for ( i = 0; i < FILETABLESIZE; i++ ) {
        if ( g_FileTable[i].bAvailable == TRUE ) {
            break;
        }
    }

    // Running out of file handles should never happen
    if ( i == FILETABLESIZE )  {
        rc = C_RUNTIME_IO_ERROR;
    }

    g_FileTable[i].hFile = Win32Open(pszFile, oflag, pmode );

    if ( g_FileTable[i].hFile != INVALID_HANDLE_VALUE )  {
        g_FileTable[i].bAvailable = FALSE;
        rc = i;
    } else {
        rc = C_RUNTIME_IO_ERROR;
    }
    return rc;
}

/******************************************************************************\
*
* closefunc (Local Routine)
*
* Closes a file.  Used by FDI interface.
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\******************************************************************************/
INT FAR DIAMONDAPI closefunc( INT_PTR hf ) {

    INT rc = C_RUNTIME_IO_ERROR;

    if (hf < FILETABLESIZE)
    {
        if ( CloseHandle( g_FileTable[hf].hFile ) )  {
            rc = 0;
            g_FileTable[hf].bAvailable = TRUE;
        }
    }
    
    return rc;
}

/******************************************************************************\
*
* readfunc (Local Routine)
*
* Reads a file.  Used by FDI interface.
*
\******************************************************************************/
UINT FAR DIAMONDAPI readfunc( INT_PTR hf, PVOID pv, UINT cb ) {

    INT     rc = C_RUNTIME_IO_ERROR;
    INT     cbRead;

    if (hf < FILETABLESIZE)
    {
        if ( ! ReadFile( g_FileTable[hf].hFile, pv, cb, (DWORD *) &cb, NULL ) ) {
            rc = C_RUNTIME_IO_ERROR;
        } else  {
            rc = cb;
        }
    }

    return rc;
}


/******************************************************************************\
*
* writefunc (Local Routine)
*
* Writes a file.  Used by FDI interface
*
\******************************************************************************/
UINT FAR DIAMONDAPI writefunc( INT_PTR hf, PVOID pv, UINT cb ) {

    INT rc = C_RUNTIME_IO_ERROR;
    
    if (hf < FILETABLESIZE)
    {
        if ( WriteFile( g_FileTable[hf].hFile, pv, cb, (DWORD *) &cb, NULL ) )  {
            rc = cb;
        }
    }

    return rc;
}

/******************************************************************************\
*
* seekfunc (Local Routine)
*
* Repositions the file pointer.  Used by FDI interface.
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\******************************************************************************/
LONG FAR DIAMONDAPI seekfunc( INT_PTR hf, LONG dist, INT seektype ) {

    LONG    rc = C_RUNTIME_IO_ERROR;
    DWORD   dwResult;
    DWORD   W32seektype;

    switch (seektype) {
        case SEEK_SET:
            W32seektype = FILE_BEGIN;
            break;
        case SEEK_CUR:
            W32seektype = FILE_CURRENT;
            break;
        case SEEK_END:
            W32seektype = FILE_END;
            break;
    }

    if (hf < FILETABLESIZE)
    {
        dwResult = SetFilePointer(g_FileTable[hf].hFile, dist, NULL, W32seektype);
        if (dwResult == 0xFFFFFFFF) {
            rc = C_RUNTIME_SEEK_ERROR;
        }
        else
            rc = (LONG)dwResult;
    }

    return rc;
}

/******************************************************************************\
*
* allocfunc (Local Routine)
*
* Allocates memory.  Used by FDI interface.
*
\******************************************************************************/
void HUGE * FAR DIAMONDAPI allocfunc(ULONG cb) {

    PVOID pv;

    pv = (PVOID) GlobalAlloc( GPTR, cb );
    return pv;
}

/******************************************************************************\
*
* freefunc (Local Routine)
*
* Frees memory.  Used by FDI interface.
*
\******************************************************************************/
void FAR DIAMONDAPI freefunc(void HUGE *pv) {

    GlobalFree( pv );
}

/******************************************************************************\
*
* AdjustFileTime (Local Routine)
*
* Sets file time.
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\******************************************************************************/
BOOL AdjustFileTime( INT_PTR hf, USHORT date, USHORT time )
{
    FILETIME    ft;
    FILETIME    ftUTC;

    if (hf >= FILETABLESIZE) {
        return FALSE;
    }
    
    if ( ! DosDateTimeToFileTime( date, time, &ft ) ) {
        return FALSE;
    }

    if ( ! LocalFileTimeToFileTime( &ft, &ftUTC ) ) {
        return FALSE;
    }
    
    if ( ! SetFileTime( g_FileTable[hf].hFile, &ftUTC, &ftUTC, &ftUTC ) ) {
        return FALSE;
    }

    return TRUE;
}


/******************************************************************************\
*
* Attr32FromAttrFAT (Local Routine)
*
* Translate FAT attributes to Win32 Attributes
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\******************************************************************************/
DWORD Attr32FromAttrFAT( WORD attrMSDOS )
{
    //** Quick out for normal file special case
    if (attrMSDOS == _A_NORMAL) {
        return FILE_ATTRIBUTE_NORMAL;
    }

    //** Otherwise, mask off read-only, hidden, system, and archive bits
    //   NOTE: These bits are in the same places in MS-DOS and Win32!

    return attrMSDOS & (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);
}


/******************************************************************************\
*
* fdiNotify (Local Routine)
*
* Processes Notification messages from FDI interface.
*
* Leveraged from nt\private\inet\setup\iexpress\wextract\wextract.c
*
\******************************************************************************/
INT_PTR FAR DIAMONDAPI fdiNotify(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin) {

    INT_PTR     fh;                       // File Handle
    LPTSTR      lpszFile;                 // Current File
    PWPNPINFO   pInfo;                    // Pointer to a "Web-Point-N-Print" info structure
    INT_PTR     nReturn;
    DWORD       dwError;

    // The user-defined 'pv' is a pointer to our saved info
    pInfo = (PWPNPINFO)pfdin->pv;

    nReturn = 0;

    switch ( fdint )  {

        //*******************************************************************
        case fdintCABINET_INFO:
            nReturn = 0;
            break;

        //*******************************************************************
        case fdintCOPY_FILE:

            nReturn = C_RUNTIME_IO_ERROR;

            {
                PWSTR pwszFile = NULL;

                if (NULL != (pwszFile = WCFromMB(pfdin->psz1)))
                {
                    if (NULL != (lpszFile = BuildFileName((LPCTSTR)pInfo->pTempDir, pwszFile))) 
                    {
                        fh = openfuncW( lpszFile, _O_BINARY | _O_EXCL | _O_RDWR |
                                        _O_CREAT, _S_IREAD | _S_IWRITE );
                    }
                    GlobalFree(pwszFile);

                    if (C_RUNTIME_IO_ERROR != fh) {

                        if (AddFileToList(pInfo, lpszFile)) {
                            nReturn = fh;
                        }
                        else {
                            closefunc(fh);
                        }
                    }

                    GlobalFree(lpszFile);
                }
            }
            break;

        //*******************************************************************
        case fdintCLOSE_FILE_INFO:

            nReturn = C_RUNTIME_IO_ERROR;
            if (AdjustFileTime( pfdin->hf, pfdin->date, pfdin->time ) ) 
            {

                closefunc( pfdin->hf );

                {
                    PWSTR pwszFile = NULL;

                    if (NULL != (pwszFile = WCFromMB(pfdin->psz1)))
                    {
                        if (NULL != (lpszFile = BuildFileName((LPCTSTR)pInfo->pTempDir, pwszFile))) 
                        {
                            if (SetFileAttributes( lpszFile, FILE_ATTRIBUTE_NORMAL ) ) 
                            {
                                nReturn = TRUE;
                            }
                            GlobalFree(lpszFile);
                        }
                        GlobalFree(pwszFile);
                    }
                }
            }
            break;

        //*******************************************************************
        case fdintPARTIAL_FILE:
            nReturn = 0;
            break;

        //*******************************************************************
        case fdintNEXT_CABINET:
            nReturn = 0;
            break;

        //*******************************************************************
        case fdintENUMERATE:
            nReturn = 0;
            break;

        //*******************************************************************
        default:
            break;
    }

    return nReturn;
}

/*****************************************************************************\
* GetCurDir
*
* Returns string indicating current-directory.
*
\*****************************************************************************/
LPTSTR GetCurDir(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszDir = NULL;


    cbSize = GetCurrentDirectory(0, NULL);

    if (cbSize && (lpszDir = (LPTSTR)GlobalAlloc(GPTR, (cbSize * sizeof(TCHAR)))))
        GetCurrentDirectory(cbSize, lpszDir);

    return lpszDir;
}


/*****************************************************************************\
* WCFromMB (Local Routine)
*
* This routine returns a buffer of wide-character representation of a
* ansi string.  The caller is responsible for freeing this pointer returned
* by this function.
*
\*****************************************************************************/
LPWSTR WCFromMB(
    LPCSTR lpszStr)
{
    DWORD  cbSize;
    DWORD  dwChars;
    LPWSTR lpwszBuf = NULL;

    cbSize = 0;

    dwChars = (DWORD)MultiByteToWideChar(CP_ACP,
                                        MB_PRECOMPOSED,
                                        lpszStr,
                                        -1,
                                        lpwszBuf,
                                        0);

    //
    // sanity check
    //
    if (dwChars < 4096)
    {
        cbSize = (dwChars + 1) * sizeof(WCHAR); // +1 to make sure the string is zero-terminated
    
        if (cbSize && (lpwszBuf = (LPWSTR)GlobalAlloc(GPTR, cbSize)))
        {
            if (0 == MultiByteToWideChar(CP_ACP,
                                         MB_PRECOMPOSED,
                                         lpszStr,
                                         -1,
                                         lpwszBuf, 
                                         dwChars)) 
            {
                GlobalFree(lpwszBuf);
                lpwszBuf = NULL;
            }
        }
    }

    return lpwszBuf;
}



/******************************************************************************\
*
* BuildFileName (Local Routine)
*
* Concatenates a path and file to produce a full pathname.
*
\******************************************************************************/
LPTSTR BuildFileName(
    LPCTSTR lpszPath,
    LPCTSTR lpszName)
{
    BOOL bReturn = FALSE;
    LPTSTR lpszMessage = NULL;
    INT cch = 0;
    UINT_PTR Args[MAX_ARGS];

    // Calculate the size necessary to hold the full-path filename.
    //
    cch += (lpszPath ? lstrlen(lpszPath) : 0);
    cch += (lpszName ? lstrlen(lpszName) : 0);
    cch++; // Must include back slash character

    if (cch >= MAX_PATH)
    {
        return NULL;
    }

    if (lpszName)
    {
        TCHAR       *pChar       = (TCHAR*) lpszName;
        BOOL        bAllowedName = TRUE;

        while (bAllowedName && *pChar)
        {
            if((*pChar == TEXT('\\')) || (*pChar == TEXT('/')) || (*pChar == TEXT(':')))
            {
                bAllowedName = FALSE;
            }

            pChar++;
        }

        if (!bAllowedName)
        {
            return NULL;
        }
    }

    // Concatenate the path and file
    //
    if (lpszPath) {

        Args[0] = (UINT_PTR) lpszPath;
        Args[1] = (UINT_PTR) lpszName;
        Args[2] = 0;

        if (0 != (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                g_szFNFmt,
                                0,
                                0,
                                (LPTSTR)&lpszMessage,
                                0,
                                (va_list*)Args ))) {
            bReturn = TRUE;
        }
    }

    return lpszMessage;
}

/******************************************************************************\
*
* GetDirectory (Local Routine)
*
* Returns the directory portion of a full pathname.
*
\******************************************************************************/
LPTSTR GetDirectory(LPTSTR lpszFile, LPDWORD lpdwReturn) {

    LPTSTR lpszSlash;
    LPTSTR lpszDir;
    SIZE_T Len;

    lpszSlash = _tcsrchr(lpszFile, g_chBackslash);

    if (lpszSlash != NULL) {

        Len = lpszSlash - lpszFile + 2;
        if (NULL != (lpszDir = (LPTSTR)GlobalAlloc(GPTR,  Len * sizeof(TCHAR)))) {

            StringCchCopy(lpszDir, Len, lpszFile);
            *lpdwReturn = ERR_NONE;
            return lpszDir;
        }
        else {
            *lpdwReturn = ERR_NO_MEMORY;
        }
    }
    else {
        *lpdwReturn = ERR_INVALID_PARAMETER;
    }

    return NULL;
}

/******************************************************************************\
*
* GetName (Local Routine)
*
* Returns the filename portion of a full pathname.
*
\******************************************************************************/
LPTSTR GetName(LPTSTR lpszFile, LPDWORD lpdwReturn) {

    LPTSTR lpszSlash;
    LPTSTR lpszName;
    int    nLength;

    lpszSlash = _tcsrchr(lpszFile, g_chBackslash);

    if (lpszSlash != NULL) {

        nLength = lstrlen(lpszSlash);

        if (NULL != (lpszName = (LPTSTR)GlobalAlloc(GPTR, (nLength * sizeof(TCHAR))))) {

            StringCchCopy(lpszName, nLength, ++lpszSlash);

            *lpdwReturn = ERR_NONE;
            return lpszName;
        }
        else {
            *lpdwReturn = ERR_NO_MEMORY;
        }
    }
    else {
        *lpdwReturn = ERR_INVALID_PARAMETER;
    }

    return NULL;
}


/******************************************************************************\
*
* CreateTempDirectory (Local Routine)
*
* Creates a unique temp directory to extract files into.
*
\******************************************************************************/
LPTSTR CreateTempDirectory() {

    LPTSTR pReturnDir = NULL;
    LPTSTR pTempDir;
    LPTSTR pCurrDir;
    LPTSTR pWinDir;
    DWORD  dwRequired = 0;

    //
    // Get the temp path, so we can create a temp directory
    // to extract the cabinet file into
    //
    if (dwRequired = GetTempPath(0, NULL)) {

        if (pTempDir = (LPTSTR)GlobalAlloc(GPTR, dwRequired * sizeof(TCHAR))) {

            if (GetTempPath(dwRequired, pTempDir) <= dwRequired) {

                // Now create a unique temp file name.
                //
                if (pReturnDir = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH * sizeof(TCHAR))) {

                    if (GetTempFileName(pTempDir, g_szTNFmt, 0, pReturnDir)) {

                        // But what we really needed was a directory, so delete the file (now that
                        // we know that we have a unique name) and create a directory with
                        // the same name as the file.
                        //
                        DeleteFile(pReturnDir);
                        if (!CreateDirectory(pReturnDir, NULL)) {
                            GlobalFree(pReturnDir);
                            pReturnDir = NULL;
                        }
                        // else We succeeded in creating the temp dir.
                        //
                    }
                    // else we can't create a temp directory...cleanup.
                    //
                    else {
                        GlobalFree(pReturnDir);
                        pReturnDir = NULL;
                    }
                }
            }

            GlobalFree(pTempDir);
        }
    }

    return pReturnDir;
}



/******************************************************************************\
*
* GetCABName (Local Routine)
*
* Parses the CAB name from the command line.
*
\******************************************************************************/
PTSTR GetCABName(PTSTR pCmdLine, LPDWORD lpdwReturn) {

    PTSTR  pEnd = 0;
    PTSTR  pPtr;
    PTSTR  pName;
    SIZE_T Len;

    pPtr = pCmdLine;

    if (pPtr) {

        if (*pPtr == g_chDoubleQuote) {
            pPtr++;
            pEnd = _tcschr(pPtr, g_chDoubleQuote);
            if (pEnd)
                *pEnd = 0;
        }

        // If we haven't found an End-Quote, treat it as the end of the string.
        if (pEnd == NULL)
            pEnd = pPtr + lstrlen(pPtr);


        Len = pEnd - pPtr + 1;
        if (pName = (PTSTR)GlobalAlloc(GPTR, Len * sizeof(TCHAR))) {
            StringCchCopy(pName, Len, pPtr);
            *lpdwReturn = ERR_NONE;
        }
        else {
            *lpdwReturn = ERR_NO_MEMORY;
        }

        return pName;
    }
    else {
        *lpdwReturn = ERR_INVALID_PARAMETER;
    }

    return NULL;
}

/******************************************************************************\
*
* AddFileToList (Local Routine)
*
* Adds a file to the list of extracted files.
*
\******************************************************************************/
BOOL AddFileToList(PWPNPINFO pInfo, PTSTR lpszFile) {

    PFILENODE       pInsertHere;
    BOOL            bReturn;
    DWORD           Len;

    bReturn = FALSE;

    if (NULL == (pInfo->pFileList)) {

        if (NULL != (pInfo->pFileList = (PFILENODE)GlobalAlloc(GPTR, sizeof(FILENODE)))) {

            pInsertHere = pInfo->pFileList;
            pInsertHere->pNextFile = NULL;
            bReturn = TRUE;
        }
    }
    else {
        if (NULL != (pInsertHere = (PFILENODE)GlobalAlloc(GPTR, sizeof(FILENODE)))) {

            pInsertHere->pNextFile = pInfo->pFileList;
            pInfo->pFileList = pInsertHere;
            bReturn = TRUE;
        }
    }

    Len = lstrlen(lpszFile) + 1;
    if (bReturn && (NULL != (pInsertHere->pFileName = (LPTSTR)GlobalAlloc(GPTR, Len * sizeof(TCHAR))) ) ) {
        StringCchCopy(pInsertHere->pFileName, Len, lpszFile);
        bReturn = TRUE;
    }
    else {
        bReturn = FALSE;
    }

    return bReturn;
}

/******************************************************************************\
*
* FreeFileList (Local Routine)
*
* Frees memory allocated for file list.
*
\******************************************************************************/
VOID CleanupFileList(PWPNPINFO pInfo) {

    PFILENODE       pCurrentNode, pNextNode;
    HANDLE          hFindFind;
    LPTSTR          lpstrPos;
    LPTSTR          lpstrTemp;
    WIN32_FIND_DATA FindData;

    pCurrentNode = pInfo->pFileList;

    // Erase all extracted files and cleanup our memory structure.
    while (pCurrentNode) {
        if (!DeleteFile(pCurrentNode->pFileName)) {
            // We might have renamed one of our original cat files to this name. So
            // look for poem*.cat in the same directory
            lpstrPos = _tcsrchr(pCurrentNode->pFileName, TEXT('\\') );

            if (lpstrPos) {
                lpstrPos[1] = TEXT('\0');

                // Now pCurrentNode->pFileName has our directory path
                lpstrTemp = strAllocAndCat( pCurrentNode->pFileName , TEXT("poem*.cat") );

                if (lpstrTemp) {
                    hFindFind = FindFirstFile( lpstrTemp , &FindData );

                    if (hFindFind != INVALID_HANDLE_VALUE) {
                        // Delete the file
                        DeleteFile( FindData.cFileName );
                        FindClose( hFindFind );
                    }

                    strFree( lpstrTemp );
                }
            }
        }
        pNextNode = pCurrentNode->pNextFile;
        GlobalFree(pCurrentNode);
        pCurrentNode = pNextNode;
    }

    pInfo->pFileList = NULL;
}

/******************************************************************************\
*
* Extract (Local Routine)
*
* Extracts all files from the CAB file and adds them to a file list.
*
\******************************************************************************/
BOOL Extract(PWPNPINFO pInfo) {

    HFDI hfdi;
    ERF  erf;
    INT  nError;
    BOOL bReturn;
    int  i;

    bReturn = FALSE;

    // Initialize file table
    for ( i = 0; i < FILETABLESIZE; i++ ) {
        g_FileTable[i].bAvailable = TRUE;
    }

    hfdi = FDICreate( allocfunc, freefunc, openfunc, readfunc, writefunc,
                      closefunc, seekfunc, cpu80386, &erf);
    if (NULL != hfdi){

        char achCABName[_MAX_PATH]={0}, achCABDir[_MAX_DIR]={0};

        wcstombs(achCABName, pInfo->pCABName, sizeof(achCABName)-1); // -1 to ensure it's zero-terminated
        wcstombs(achCABDir, pInfo->pCABDir, sizeof(achCABDir)-1);

        if (0 != (nError = FDICopy(hfdi, achCABName, achCABDir, 0, fdiNotify, NULL, (LPVOID)(pInfo))))
            bReturn = TRUE;
        else {
            CleanupFileList(pInfo);
        }

        FDIDestroy(hfdi);
    }

    return bReturn;
}

/******************************************************************************\
*
* GetWPNPSetupLibName (Local Routine)
*
* Returns the name of the print wizard library. this is a remnant of the days
* when we built a Win9x client.
*
\******************************************************************************/
LPTSTR GetWPNPSetupLibName(LPDWORD lpdwReturn) {

    LPTSTR        lpszLibName;
    OSVERSIONINFO OSVersionInfo;

    *lpdwReturn = ERR_GENERIC;

    OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&OSVersionInfo)) {

        switch (OSVersionInfo.dwPlatformId) {

            // NT clients
            case VER_PLATFORM_WIN32_NT:

                // NT 5 or better
                if (OSVersionInfo.dwMajorVersion >= NT_VER_5) {

                    *lpdwReturn = ERR_NONE;
                    return (LPTSTR)g_szPrintUIMod;
                }
                // NT clients: ver < 5.0
                else {

                    *lpdwReturn = ERR_PLATFORM_NOT_SUPPORTED;
                    return NULL;
                }

            // Other clients ?
            default:

                *lpdwReturn = ERR_PLATFORM_NOT_SUPPORTED;
                return NULL;
        }
    }

    return NULL;
}

/******************************************************************************\
*
* LoadLibraryUsingFullPath (Local Routine)
*
* Loads the DLL lpFileName after prepending system directory to it.
*
\******************************************************************************/
HMODULE
LoadLibraryUsingFullPath(
    LPCTSTR lpFileName
    )
{
    TCHAR szSystemPath[MAX_PATH];
    INT   cLength         = 0;
    INT   cFileNameLength = 0;


    if (!lpFileName || ((cFileNameLength = lstrlen(lpFileName)) == 0))
    {
        return NULL;
    }
    if (GetSystemDirectory(szSystemPath, MAX_PATH ) == 0)
    {
        return NULL;
    }
    cLength = lstrlen(szSystemPath);
    if (szSystemPath[cLength-1] != TEXT('\\'))
    {
        if ((cLength + 1) >= MAX_PATH)
        {
            return NULL;
        }
        szSystemPath[cLength]     = TEXT('\\');
        szSystemPath[cLength + 1] = TEXT('\0');
        cLength++;
    }
    if ((cLength + cFileNameLength) >= MAX_PATH)
    {
        return NULL;
    }
    StringCchCat(szSystemPath, MAX_PATH, lpFileName);

    return LoadLibrary( szSystemPath );
}

/******************************************************************************\
*
* InvokePrintWizard (Local Routine)
*
* Calls the PrintWizard
* for printer setup and installation.
*
\******************************************************************************/
DWORD InvokePrintWizard(PWPNPINFO pInfo, LPDWORD lpAuthError) {

    DWORD   dwReturn;
    DWORD   dwErr;
    LPTSTR  lpszSetupLibName;
    HMODULE hLibrary;
    FARPROC lpProc;

    // Get the name of the print wizard module
    //
    if (NULL != (lpszSetupLibName = GetWPNPSetupLibName(&dwReturn)) ) {

        // Load the print wizard module
        //
        if (NULL != (hLibrary = LoadLibraryUsingFullPath(lpszSetupLibName)) ) {

            // Find the webpnp installation proc address
            //
            if (NULL != (lpProc = GetProcAddress(hLibrary, g_szPrintUIEntryW) ) ) {

                // Call the webpnp installation entry point with the correct parameters
                //
                if ((*lpAuthError) = (UINT32) (*lpProc)(NULL, g_hInstance, g_wszParmString, SW_SHOWDEFAULT))
                    dwReturn = ERR_AUTHENTICODE;
                else
                    dwReturn = ERR_NONE;

            } else {

                dwReturn = ERR_NO_PRINTUIENTRY;
            }

            FreeLibrary(hLibrary);

        } else {

            dwReturn = ERR_NO_PRINTUI;
        }
    }

    return dwReturn;
}

/******************************************************************************\
*
* WebPnPCABInstall (Local Routine)
*
* Takes a CAB file and does the driver extraction and printer installation.
*
\******************************************************************************/
DWORD WebPnPCABInstall(PTSTR pCABName, PDWORD lpAuthError)
{
    PTSTR       pFileList;
    PTSTR       pOldDir;
    PWPNPINFO   pInfo;
    DWORD       dwReturn = ERR_NONE;
    DWORD       BufSize;

    if (NULL != (pInfo = (PWPNPINFO)GlobalAlloc(GPTR, sizeof(WPNPINFO)))) {

        BufSize = (lstrlen(pCABName) + 1) * sizeof(TCHAR);

        if (NULL != (pInfo->pFullCABPath = (PTSTR)GlobalAlloc(GPTR, BufSize))) {

            if (SUCCEEDED(StringCbCopy(pInfo->pFullCABPath, BufSize, pCABName)))
            {
                if (pInfo->pCABDir = GetDirectory(pInfo->pFullCABPath, &dwReturn)) {
    
                    if (pOldDir = GetCurDir()) {
    
                        if (pInfo->pTempDir = CreateTempDirectory() ) {
    
                            SetCurrentDirectory(pInfo->pTempDir);
    
                            if (pInfo->pCABName = GetName(pInfo->pFullCABPath, &dwReturn)) {
    
                                if (Extract(pInfo)) {
    
    // Verification of files removed
    //                            if (ERR_NONE == (dwReturn = VerifyFiles(pInfo, lpAuthError))) {
    
                                    dwReturn = InvokePrintWizard(pInfo, lpAuthError);
    //                            }
    
                                    CleanupFileList(pInfo);
    
                                } else {
    
                                    dwReturn = ERR_CAB_EXTRACT;
                                }
    
                                GlobalFree(pInfo->pCABName);
                            }
    
                            SetCurrentDirectory(pOldDir);
                            RemoveDirectory(pInfo->pTempDir);
                            GlobalFree(pInfo->pTempDir);
                        }
    
                        GlobalFree(pOldDir);
                    }
    
                    GlobalFree(pInfo->pCABDir);
                }

            }
            GlobalFree(pInfo->pFullCABPath);

        } else {

            dwReturn = ERR_NO_MEMORY;
        }

        GlobalFree(pInfo);

    } else {

        dwReturn = ERR_NO_MEMORY;
    }

    return dwReturn;
}

/******************************************************************************\
*
* LookupErrorString (Local Routine)
*
* Returns an error string associated with dwErrorCode
*
\******************************************************************************/
LPCTSTR LookupErrorString(DWORD dwErrorCode) {

    int i;
    int nCount;


    static ERROR_MAPPING s_ErrorMap[] = {

        { ERR_NO_MEMORY,              &g_szENoMemory         },
        { ERR_BAD_CAB,                &g_szEBadCAB           },
        { ERR_INVALID_PARAMETER,      &g_szEInvalidParameter },
        { ERR_INVALID_CAB_NAME,       &g_szEInvalidCABName   },
        { ERR_CAB_EXTRACT,            &g_szECABExtract       },
        { ERR_NO_DAT_FILE,            &g_szENoDATFile        },
        { ERR_NO_PRINTUI,             &g_szENoPrintUI        },
        { ERR_NO_PRINTUIENTRY,        &g_szENoPrintUIEntry   },
        { ERR_PRINTUIENTRY_FAIL,      &g_szEPrintUIEntryFail },
        { ERR_PLATFORM_NOT_SUPPORTED, &g_szENotSupported     }
    };


    nCount = sizeof(s_ErrorMap) / sizeof(s_ErrorMap[0]);

    for (i=0; i < nCount; i++) {

        if (0 != ((s_ErrorMap[i].dwErrorCode) & dwErrorCode & ~(ERR_GENERIC)) )
            return *(s_ErrorMap[i].lpszError);
    }

    return g_szEGeneric;
}

/******************************************************************************\
*
* CheckErrors (Local Routine)
*
* Checks dwErrorCode for any error conditions
*
\******************************************************************************/
VOID CheckErrors(DWORD dwErrorCode, DWORD dwAuthError) {

    LPTSTR   lpszMessage = NULL;
    LPTSTR   lpszErrorString = NULL;
    BOOL     bAuthErrorAllocated;
    UINT_PTR Args[MAX_ARGS];

    bAuthErrorAllocated = FALSE;

    if (dwErrorCode != ERR_NONE) {

        // Check for Authenticode errors here
        if (dwErrorCode == ERR_AUTHENTICODE) {

            // Format the authenticode error message.
            // If the message can't be found in the system, use our generic error message
            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL, dwAuthError, 0, (LPTSTR)&lpszErrorString, 0, NULL)) {
                bAuthErrorAllocated = TRUE;
            }
            else {
                lpszErrorString = (LPTSTR)LookupErrorString(ERR_GENERIC);
            }
        }
        // If the error is not Authenticode, it must be ours.
        // Look it up in our error string table.
        else {
            lpszErrorString = (LPTSTR)LookupErrorString(dwErrorCode);
        }

        // Set up our arg list.
        Args[0] = (UINT_PTR) lpszErrorString;
        if (dwErrorCode == ERR_AUTHENTICODE) {
            Args[1] = dwAuthError;
        }
        else
            Args[1] = dwErrorCode;
        Args[2] = 0;

        // Format our error message and display it in a message box.
        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          g_szErrorFormat, 0, 0, (LPTSTR)&lpszMessage, 0, (va_list*)Args )) {

            if (lpszMessage) {
                MessageBox(NULL, lpszMessage, g_szError, MB_ICONEXCLAMATION | MB_OK);

                // Free the buffer
                LocalFree(lpszMessage);
            }

        }

    }

    // Free up the Authenticode error string allocated for us by FormatMessage().
    if (bAuthErrorAllocated)
        LocalFree(lpszErrorString);
}

/******************************************************************************\
*
* WinMain
*
* Main entrypoint for the program.
*
\******************************************************************************/
INT WINAPI _tWinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPTSTR lpszCmdLine, INT nCmdShow)
{
    LPTSTR lpszCABName;
    DWORD  dwReturn    = ERR_NONE;
    DWORD  dwAuthError = ERROR_SUCCESS;

    g_hInstance = hInstance;

    if (InitStrings()) {

        if (NULL != (lpszCABName = GetCABName(lpszCmdLine, &dwReturn))) {

            dwReturn = WebPnPCABInstall(lpszCABName, &dwAuthError);
            GlobalFree(lpszCABName);
        }

        // Decide which error code we must return
        //
        if (dwReturn == ERR_NONE) {

            dwReturn = SUCCESS_EXITCODE;

        } else {

            if (dwReturn == ERR_AUTHENTICODE) {

                if (dwAuthError == ERROR_SUCCESS) {

                    dwReturn = SUCCESS_EXITCODE;

                } else {

                    dwReturn = dwAuthError;
                }
            }
        }

        FreeStrings();
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\wpnpinst\exe\pch.h ===
#include <windows.h>
#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <tchar.h>
#include <strsafe.h>
#include "wpnpinst.h"
#include "wincrypt.h"
#include "softpub.h"
#include "wintrust.h"
#include "fdi.h"
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\publish\compstui.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    compstui.h


Abstract:

    This module contains global header definition for the COMMON DRIVER UI


Author:

    19-Jun-1995 Mon 11:52:01 created  -by-  Daniel Chou (danielc)

    17-Aug-1995 Thu 14:59:28 updated  -by-  Daniel Chou (danielc)
        Updated for the first draft.

    23-Aug-1995 Wed 15:13:27 updated  -by-  Daniel Chou (danielc)
        Updated for second draft

    29-Aug-1995 Tue 11:33:24 updated  -by-  Daniel Chou (danielc)
        Adding ExtChkBox for some TVOT_xxx type

    31-Aug-1995 Thu 04:04:23 updated  -by-  Daniel Chou (danielc)
        Making UNICODE type

    01-Sep-1995 Fri 17:29:18 updated  -by-  Daniel Chou (danielc)
        Change the API interface type, so that it can be dynamically called
        and generate the property pages to be merge with the shell

    05-Sep-1995 Tue 11:52:43 updated  -by-  Daniel Chou (danielc)
        Rename to compspui.h and update the API entry structure

    07-Sep-1995 Thu 14:46:55 updated  -by-  Daniel Chou (danielc)
        rename to compstui.h and update comments

    07-Sep-1995 Thu 16:07:31 updated  -by-  Daniel Chou (danielc)
        Adding UNION type for pSel/Sel, pOldSel/OldSel

    08-Sep-1995 Fri 09:23:38 updated  -by-  Daniel Chou (danielc)
        Remove TypeIdx from OPTITEM and use pOptType, and remove all
        pOptType passed in the CPSUICBPARAM and COMPROPSHEETUI structures

    25-Sep-1995 Mon 19:39:45 updated  -by-  Daniel Chou (danielc)
        add other related stuff.

    26-Sep-1995 Tue 11:02:26 updated  -by-  Daniel Chou (danielc)
        Add error codes for GETLASTERROR

    27-Sep-1995 Wed 16:32:37 updated  -by-  Daniel Chou (danielc)
        Move hWndParent, pTitle, hInst and TitleIconID out from
        COMPROPSHEETUI to COMPROPSHEETUIHEADER.

    28-Sep-1995 Thu 17:06:46 updated  -by-  Daniel Chou (danielc)
        Add hInstCaller to COMPROPSHEETUI and add _COMPSTUI_ and cplusplus
        stuff

    28-Sep-1995 Thu 23:16:34 updated  -by-  Daniel Chou (danielc)
        change tick count for trackbar/scrollbar to multiply factor. and
        add the push button flag which can overwrite the update permission so
        it can let user view the current setting from push button's dialog
        display

    07-Feb-1996 Wed 17:45:31 updated  -by-  Daniel Chou (danielc)
        Change the API CommonPropSheetUI to CommonPropertySheetUI so that it
        not using stack but message base, this way any caller can add/delete
        pages as they want without worry about how many pages been added from
        its children.

    7:15 AM 2/14/2001 updated -by- Lazar Ivanov (LazarI)
        Making compstui fusion aware. Attaching a fusion activation context
        to the compstui handles and adding a new message for setting it called 
        CPSFUNC_SET_FUSION_CONTEXT. when a page is about to be created/inserted and 
        it doesn't specify an activation context in its PROPSHEETPAGE structure it 
        will be created into the parent's page activation context. if the parent's 
        activation context is not set then we look up the next parent and so on until 
        the top level parent is reached or until we find a parent with an activation 
        context properly set. if none of the parents have an activation context set, 
        then we force the default (NULL) activation context prior creating the page.

[Environment:]

    NT Windows - Common Property Sheet UI DLL.


[Notes:]


Revision History:


--*/

#ifndef _COMPSTUI_
#define _COMPSTUI_

#ifdef __cplusplus
extern "C" {
#endif


#if (!defined(RC_INVOKED))


//
// For compilers that don't support nameless unions
//

#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME      u
#define DUMMYUNIONNAME2     u2
#define DUMMYUNIONNAME3     u3
#define DUMMYUNIONNAME4     u4
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#endif
#endif

//
// Predefined ID for the TreeView Option Type
//
//


#define TVOT_2STATES        0
#define TVOT_3STATES        1
#define TVOT_UDARROW        2
#define TVOT_TRACKBAR       3
#define TVOT_SCROLLBAR      4
#define TVOT_LISTBOX        5
#define TVOT_COMBOBOX       6
#define TVOT_EDITBOX        7
#define TVOT_PUSHBUTTON     8
#define TVOT_CHKBOX         9
#define TVOT_LAST           TVOT_CHKBOX
#define TVOT_NONE           (TVOT_LAST + 1)

//
// Predefined ID for the TreeView Option Type
//
//
// TVOT_2STATES:
//      Count       = 2
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//
//      BegCtrlID  = 2 States Group Box ID
//      BegCtrlID+1= 2 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_3STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//
// TVOT_3STATES:
//      Count       = 3
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//      pOptParam[2]=pointer to the State 3 OPTPARAM
//
//      BegCtrlID  = 3 States Group Box ID
//      BegCtrlID+1= 3 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= state 3 Radio button ID
//      BegCtrlID+7= state 3 icon control ID
//      BegCtrlID+8= Extended Check Box/Push Button control ID
//      BegCtrlID+9= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_2STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//  ** For TVOT_2STATES, TVOT_3STSATES the 'Sel' field in the OPTITEM has
//     following definitions
//
//      State 1, Sel = 0
//      State 2, Sel = 1
//      State 3, Sel = 2
//
//      for any selection which based on false/true, no/yes, off/ontrue/false,
//      none/select then state 1 (sel=0) must always be the NO, FALSE, OFF or
//      NONE type.
//
//
// TVOT_UDARROW:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = (SHORT)Low range of the up-down control
//                      lParam = (SHORT)High range of the up-down control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//          if pData pointed to no help text then common UI automatically
//          set the (# - #) as help line
//
//      BegCtrlID  = udarrow Group Box ID
//      BegCtrlID+1= udarrow title static title ID
//      BegCtrlID+2= udarrow's editbox ID
//      BegCtrlID+3= udarrow icon control ID
//      BegCtrlID+4= udarrow postfix static text ID
//      BegCtrlID+5= udarrow help static text ID
//      BegCtrlID+6= udarrow arrow ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_TRACKBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the trackbar control
//                      lParam = (SHORT)High range of the trackbar control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//      BegCtrlID  = trackbar Group Box ID
//      BegCtrlID+1= trackbar static title ID
//      BegCtrlID+2= trackbar(horizontal) ID (static FRAME to define size)
//      BegCtrlID+3= trackbar icon control ID
//      BegCtrlID+4= trackbar low range text control ID
//      BegCtrlID+5= trackbar high range text control ID
//      BegCtrlID+6= trackbar postfix ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * the tick frequency is automatically to set to PageSize increment
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_SCROLLBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the scrollbar control
//                      lParam = (SHORT)High range of the scroll control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//
//      BegCtrlID  = scrollbar(horizontal) group box ID
//      BegCtrlID+1= scrollbar(horizontal) static text ID
//      BegCtrlID+2= scrollbar(horizontal) ID
//      BegCtrlID+3= scrollbar icon control ID
//      BegCtrlID+4= scrollbar low range text control ID
//      BegCtrlID+5= scrollbar high range text control ID
//      BegCtrlID+6= scrollbar postfix control ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * Style field in the OPTPARAM is ignored
//
//
//
// TVOT_LISTBOX:
// TVOT_COMBOBOX:
//      Count       = N
//      pOptParam[0]=pointer to the first OPTPARAM (pData=string pointer)
//      pOptParam[1]=pointer to the second OPTPARAM (pData=string pointer)
//          .
//          .
//      pOptParam[N-1]=pointer to the N item string
//
//      BegCtrlID  = Listbox/ComboBox group box ID
//      BegCtrlID+1= Listbox/ComboBox static title ID
//      BegCtrlID+2= Listbox/Combobox ID
//      BegCtrlID+3= Listbox/Combobox icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, the field used as
//
//          Style =Ignored by the common UI
//          pData =Pointer to the name of item
//          IconID=Icon resource ID for the item
//          lParam=ignored by the common UI
//
//      * Only SINGLE selection is supported, to do a multiple selction use
//        multiple OPTITEM and create a header for it
//
//      * an OTLBCBS_SORT style can be specified in the OPTTYPE's LBCBStyle
//        field, and the listbox or combobox will be sorted according to the
//        item's string.
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, when it get received the keyboard
//        focus then common UI will call callback function (only if
//        OPTIF_CALLBACK bit set) with reason of CPSUICB_REASON_LBCB_ACTIVE,
//        this give caller a chance to modify following structure flags/pdata
//        which associate with the current OPTITEM.   The caller's callback
//        function can ONLY modify the flags/data specified here.
//
//          OPTTYPE pointed by the pOptType from OPTITEM
//
//              Style: OTS_LBCB_SORT
//                     OTS_LBCB_INCL_ITEM_NONE
//
//          OPTPARAMs pointed by the pOptParam from the OPTTYPE
//
//              Flags: OPTPF_HIDE
//                     OPTPF_DISABLED
//
//              pData: change string name
//
//
//      * The TVOT_COMBOBOX typically only used in the tree-view if there is
//        only one selection available for that item, when there is only one
//        item then dropdown list will not enabled by the common UI
//
//
//
// TVOT_EDITBOX:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = Edit buffer sie in character pointed by pSel
//                                 this is including the NULL terminator.
//                      lParam = ignored.
//
//      BegCtrlID  = editBox group Box ID
//      BegCtrlID+1= editBox static title ID
//      BegCtrlID+2= editbox ID
//      BegCtrlID+3= editbox icon control ID
//      BegCtrlID+4= editbox postfix ID
//      BegCtrlID+5= editbox help ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//      * Style field is ignored
//
//      * pSel in the OPTITEM is the pointer to the editing string, the pSel
//        must pointed to a buffer eqaul or larger than the count of the buffer
//        (pOptParam[1]->IconID) size
//
//
// TVOT_PUSHBUTTON:
//      Count       = 1
//
//      BegCtrlID  = push button group box ID
//      BegCtrlID+1= push button static text ID (Not used by common UI)
//      BegCtrlID+2= push button ID
//      BegCtrlID+3= push button icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//      PUSHBUTTON_TYPE_xxx specified the action and content of pData in the
//      pOptParam[0] as describe in the following
//
//          PUSHBUTTON_TYPE_DLGPROC
//
//              This push button is designed to bring up caller's dialog box
//
//                  pOptParam[0].pData  = Caller's DLGPROC
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_DLGPROC
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Caller's DIALOG resource template ID
//                                        or handle to the DLGTEMPLATE depends
//                                        on the OPTPF_USE_HDLGTEMPLATE flag
//
//
//              The 'lParam' passed to the DLGPROC's WM_INITDIALOG is the
//              CPSUICBPARAM structure pointer, and the reason field is set
//              to CPSUICB_REASON_DLGPROC.
//
//
//          PUSHBUTTON_TYPE_CALLBACK
//
//              This push button is designed to have caller process the item
//              which cannot accomplished with the dialog box along.
//
//                  pOptParam[0].pData  = CPSUICALLBACK function pointer
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_CALLBACK
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//              Durning the callback the Reason field in CPSUICBPARAM will
//              set to CPSUICB_REASON_PUSHBUTTON.
//
//              ** If pOptParam[0].pData callback function is NULL then common
//                 UI will call the pfnCallBack pointer set in the
//                 COMPROPSHEETUI structure if it is not NULL
//
//              ** The callback function should put the result of the callback
//                 in the pSel/Sel of OPTITEM associate with the push button
//
//          PUSHBUTTON_TYPE_HTCLRADJ
//
//              This push button is designed to bring up halftone color
//              adjustment dialog box.
//
//                  pOptParam[0].pData  = pointer to COLORADJUSTMENT structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTCLRADJ
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam =  Not Used;
//
//
//          PUSHBUTTON_TYPE_HTSETUP
//
//              This push button is designed to bring up device halftone
//              setup dialog box.
//
//                  pOptParam[0].pData  = pointer to DEVHTADJDATA structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTSETUP
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//
//      * 'Sel' field in the OPTITEM for the PUSHBUTTON is the last returned
//        LONG result from the called dialog box or funcitons.  The result
//        only valid if OPTIF_CHANGEONCE flag is set.  The common UI will set
//        OPTIF_CHANGEONCE if push button ever pushed.
//
//      * Since common UI donot know the meaning of the return value and
//        content of the called parameter, it is up to the caller to use
//        callback function to determine the returned result.
//
//      * When returned from the push button except push botton type
//        PUSHBUTTON_TYPE_CALLBACK common ui will call the callback function
//        if the OPTIF_CALLBACK flat is set.  The callback reason is set to
//        CPSUICB_REASON_SEL_CHANGED.
//
//      * If the passed in CPSUIF_UPDATE_PERMISSION Flags in the COMPROPSHEETUI
//        is clear then the callback function must ONLY display the dialog box
//        and not changed any OPTITEM data if OTS_PUSH_ENABLE_ALWAYS
//        flag is set in the OPTTYPE
//
//
// TVOT_CHKBOX:
//      Count               = 1
//
//      pOptparam[0].Style  = CHKBOXS_FALSE_TRUE    False/True
//                            CHKBOXS_NO_YES,       No/YES
//                            CHKBOXS_OFF_ON,       Off/ON
//                            CHKBOXS_FALSEPDATA    False/pData
//                            CHKBOXS_NO_PDATA      No/pData
//                            CHKBOXS_OFF_PDATA     Off/pData
//                            CHKBOXS_NONE_PDATA    None/pData
//      pOptParam[0].pData  = Only used if Style is CHKBOXS_NONE_PDATA
//      pOptParam[0].IconID = Icon resource ID
//      pOptParam[0].lParam = Ignored
//
//
//      BegCtrlID  = check box group ID
//      BegCtrlID+1= Check Box static text (not used by common UI)
//      BegCtrlID+2= check box button ID
//      BegCtrlID+3= check box icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//  * BegCtrlID only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//    which has non-common UI dialog box template (DlgTemplateID in the DLGPAGE
//    is not standard DP_STD_xxx common ui dialog box template).    The common
//    UI used this ID to managed caller's dialog boxes item's selections and
//    initialization.
//
//  * for each item, it has group box ID (BegCtrlID) and static text ctronl ID
//    (BegCtrlID + 1).  The common UI will set the text in one of these two
//    control ID in followng seauence.
//
//      1) If group box control ID's window (BegCtrlID) is exist and the
//         OPTITEM's flag OPTIF_NO_GROUPBOX_NAME is not set then common UI will
//         set the pName from OPTITEM to the group box.
//
//      2) If the group box name is not set and static control ID's window
//         (BegCtrlID + 1) is exist then common UI will set the pName from
//         OPTITEM to the static text control.
//
//  * for TVOT_TRACKBAR and TVOT_SCROLLBAR, if pName in the OPTITEM is set to
//    either group box or static text control then common UI will also append
//    the current selection position of trackbar or scroll bar to the pName.
//
//  * If multiple OPTITEMs using the same POPTPARAM and need different
//    BegCtrlID for each control then then a separate OPTTYPE structure should
//    be generated but POPTPARAM pointed to the same OPTPARAM[]
//
//  * If a BegCtrlID+N is not used then skip that ID in your dialog box
//    template
//
//

#define CHKBOXS_FALSE_TRUE          0
#define CHKBOXS_NO_YES              1
#define CHKBOXS_OFF_ON              2
#define CHKBOXS_FALSE_PDATA         3
#define CHKBOXS_NO_PDATA            4
#define CHKBOXS_OFF_PDATA           5
#define CHKBOXS_NONE_PDATA          6


#define PUSHBUTTON_TYPE_DLGPROC     0
#define PUSHBUTTON_TYPE_CALLBACK    1
#define PUSHBUTTON_TYPE_HTCLRADJ    2
#define PUSHBUTTON_TYPE_HTSETUP     3


#define MAX_RES_STR_CHARS           160

//
// Common Printer UI's LPTSTR
//
// All string pointer in common printer UI structures can be either a real
// memory pointer or a string resource ID.  These are applied to LPTSTR type.
//
// The LPTSTR is defined to identify that the pointer can be a real string
// pointer or a resource ID (either common printer UI provided ID or caller's
// own resource ID).  common UI using following logic to get the final string.
//
//  LPTSTR  pData;
//
//      if ((pData & ~(ULONG_PTR)0xFFFF) != 0) then pData is a NULL terminated
//      string pointer
//
//          ELSE
//
//          (pData & (ULONG_PTR)0xFFFF) = Resource ID
//
//          if (Resource ID is within the common UI string resource ID range)
//          then it load the string from common UI DLL
//
//          ELSE
//
//              it load string from caller's resource
//
//
//  *  You can use MAKEINTRESOURCE(StrResID) to set this field
//
//  * The MAX characters loaded by the common UI from the resource is defined
//    as MAX_RES_STR_CHARS
//
//  * You cannot use LPTSTR as resource ID for the TVOT_EDITBOX style's
//    pSel in the OPTITEM, this pointer must be a real buffer pointer
//
//
//
// ICONs
//
//  Common UI using two types of Icons, One is 32x32 and the other is 16x16
//  plus if any monochrome icon with 32x32 and 16x16 sizes.
//
//  The 16x16 icon when displayed on the screen is using 16x17 pixel space,
//  this is ensure that downware adjacent icon is not crowded together.
//
//  In common UI, if you need to passed a ICON ID, it can either passed a
//  common UI's predefined ID or caller's own ICON resource ID.
//
//
//  * You can use to imagedit or any other Window icon editor to create the
//    icon, each icon file should have one unique icon resource ID which is
//    not overlay with the standard common UI IDI_CPSUI_xxx identifier.  For
//    each icon file, its should have both 32x32 and 16x16 size icon on
//    different display. (ie. monochrome).
//
//    Common UI will try to load the correct size of icon from the icon
//    resource, but it will stretch them if the size is not found.
//
//

//
// Flags for the OPTTYPE
//
//

#define OPTPF_HIDE                  0x01
#define OPTPF_DISABLED              0x02
#define OPTPF_ICONID_AS_HICON       0x04
#define OPTPF_OVERLAY_WARNING_ICON  0x08
#define OPTPF_OVERLAY_STOP_ICON     0x10
#define OPTPF_OVERLAY_NO_ICON       0x20
#define OPTPF_USE_HDLGTEMPLATE      0x40

typedef struct _OPTPARAM {
    WORD        cbSize;         // size of this structure
    BYTE        Flags;          // OPTPF_xxxx flags
    BYTE        Style;          // style use in this structure
    LPTSTR      pData;          // pointer to the data
    ULONG_PTR   IconID;         // iconID;
    LPARAM      lParam;         // parameter used
    ULONG_PTR   dwReserved[2];  // reserved dword, must be 0
    } OPTPARAM, *POPTPARAM;


//
// OPTPARAM
//
//  The OPTPARAM structure is used to describe each slectable item in the
//  common UI such as 'letter', 'legal' in the form slection list box
//
//  cbSize      - size of this structure
//
//  Flags       - defined as OPTPF_xxxx
//
//                  OPTPF_HIDE
//
//                      Specified hide this listed selection item and not
//                      availabe for user to select. This only available to
//                      following TVOT_xxx types
//
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//
//                      If all the seclection items are OPTPF_HIDE then the
//                      OPTITEM is automatically hided by the common UI, if
//                      TVOT_3STATES has 2 states hide then an error is
//                      returned
//
//
//                  OPTPF_DISABLED
//
//                      Specified this listed selection item is disabled and
//                      not availabe for user to select.   This only available
//                      to following TVOT_xxx types
//
//                          TVOT_2STATES
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//
//
//                  OPTPF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  OPTPF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  OPTPF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  OPTPF_OVERLAY_NO_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  Style       - Style for the OPTPARAM, it depends on the TVOT_xxx type as
//                describe below
//
//                  TVOT_PUSBUTTON
//
//                      it can be one of PUSHBUTTON_TYPE_xxxx.
//
//                  other TVOT_xxxx
//
//                      this fields is not used.
//
//
//  pData       - Is either a pointer to the item name (string) or it is
//                used to describe other data.
//
//                   * If the pData in the OPTPARAM is supposed to be a static
//                     pointer to a string and the string is a common UI
//                     standard resource ID then common UI will check if pData
//                     is equal to IDS_CPSUI_NOTINSTALLED, if true then
//                     common UI will overaly a not installed icon on top of
//                     the OPTPARAM's Icon.   This will not applied to the
//                     TVOT_EDITBOX type since the pData is not a static text
//                     pointer or a string resource ID.
//
//                  ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if OPTPF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  lParam      - Extra data used by the OPTPARAM, it depends on the TVOT_xxx
//                type.
//
//  dwReserved[]- Reserved DWORDs, must be 0
//
//


#define OPTTF_TYPE_DISABLED             0x01
#define OPTTF_NOSPACE_BEFORE_POSTFIX    0x02


#define OTS_LBCB_SORT                   0x0001
#define OTS_LBCB_PROPPAGE_LBUSECB       0x0002
#define OTS_LBCB_PROPPAGE_CBUSELB       0x0004
#define OTS_LBCB_INCL_ITEM_NONE         0x0008
#define OTS_LBCB_NO_ICON16_IN_ITEM      0x0010
#define OTS_PUSH_INCL_SETUP_TITLE       0x0020
#define OTS_PUSH_NO_DOT_DOT_DOT         0x0040
#define OTS_PUSH_ENABLE_ALWAYS          0x0080


typedef struct _OPTTYPE {
    WORD        cbSize;
    BYTE        Type;           // TVOT_xxxx type of OPTIONS
    BYTE        Flags;          // OPTTF_xxx flags
    WORD        Count;          // Count of pOptParam passed
    WORD        BegCtrlID;      // start of item's group window ID
    POPTPARAM   pOptParam;      // pointer to the OPTPARAM
    WORD        Style;          // option type style as OTS_xxxx
    WORD        wReserved[3];   // wReserved, must be 0
    ULONG_PTR   dwReserved[3];  // DWORD reserved field (must be 0)
} OPTTYPE, *POPTTYPE;


//
// OPTTYPE
//
//  The OPTTYPE structure is used to describe a set of selection and its
//  select method,  such as Form/Tray assignment.  It has a pointer to a set
//  of selection item (OPTPARAM)
//
//
//  cbSize      - size of this structure
//
//  Type        - Specified the option type using predefined ID as TVOT_xxxx
//
//  Flags       - currently only one flag is defined
//
//
//                  OPTTF_TYPE_DISABLED
//
//                      The whole OPTTYPE's OPTPARAMs are disabled, and non of
//                      the selection in the OPTTYPE can be selected
//
//
//                  OPTTF_NOSPACE_BEFORE_POSTFIX
//
//                      This bit only valid if the OPTTYPE's pOptParam item
//                      specified a postfix string as describe in the above
//                      section.  If this flag is set then it asked common UI
//                      do not add a space character before the postfix string
//                      when it combine the pName in the OPTITEM and postfix
//                      string.   Typeically this bit is not set for the
//                      postfix string, but sometime it may be required not to
//                      add a space character in front of it, such as '%'
//                      postfix string.
//
//
//  Count       - Count of item pointed by pOptParam.  Some predefined number
//                must be set according to the TVOT_XXX description.
//
//  BegCtrlID   - Only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//                which has non-common UI dialog box template (DlgTemplateID
//                in the DLGPAGE is not standard DP_STD_xxx common ui dialog
//                box template).    The common UI used this ID to managed
//                caller's dialog boxes item's selections and initialization.
//
//                Each OPTITEM has predefined number of window ID which
//                associated with that item, the BegCtrlID specified the start
//                control window ID.  Each control window ID in the OPTITEM
//                must have the control ID sequence as describe in the TVOT_xxx
//                above.
//
//  pOptParam   - Pointer to array of OPTPARAM to describe each selectable item
//
//  Style       - Specified the style of type of control box, certain style
//                only apply to centain type of TVOT_xxxx.
//
//                OTS_LBCB_xxx only applied to TVOT_LISTBOX, TVOT_COMBOBOX
//                OTS_PUSH_xxx only applied to TVOT_PUSHBUTTON
//
//
//                  OTS_LBCB_SORT
//
//                      Specified that the listbox or combobox item is sorted
//                      in ascending order based on the pData string
//
//
//                  OTS_LBCB_PROPAGE_LBUSECB
//
//                      Used when Type is TVOT_LISTBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is comobobox instead of listbox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_PROPAGE_CBUSELB
//
//                      Used when Type is TVOT_COMBOBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is listbox instead of combobox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_INCL_ITEM_NONE
//
//                      when this flag is specified, the common ui will
//                      automatically add a 'None' selection to the listbox or
//                      combobox.   The 'Sel' will set to -1 if 'none' is
//                      selection is selected by the user.  It will also
//                      validate the 'Sel' durning the initialization,  any
//                      out of range value will be set to -1 (None).
//
//
//                  OTS_LBCB_NO_ICON16_IN_ITEM
//
//                      By default, each listbox, combox will have a small
//                      icon (16x16) in front of item text. by specified this
//                      bit, the listbox/combobox will not includes icons
//                      in the listbox/combobox.
//
//                      If clear then it specified that in the listbox/combobox
//                      to have 16x16 Icon added to the front of each item
//
//
//                  OTS_PUSH_INCL_SETUP_TITLE
//
//                      If specified for the push button then it automatically
//                      add the 'Setup' to the end of push botton text.
//
//
//                  OTS_PUSH_NO_DOT_DOT_DOT
//
//                      If specified then common UI will not add '...' to the
//                      end of the pName in the OPTITEM and push button name
//
//
//                  OTS_PUSH_ENABLE_ALWAYS
//
//                      This flag specified that even update permissio is not
//                      allowed, it still let user push the push button, if
//                      this flag is set then callback function or dialog box
//                      proc must disable all the control which let user
//                      modified the content, but just let user view the
//                      current setting.
//
//
//  wReserved[] - Reserved fields, must be 0
//
//  dwReserved[]- Reserved fields, must be 0
//
//


//
// Following are flags for the EXTPUSH
//


#define EPF_PUSH_TYPE_DLGPROC       0x0001
#define EPF_INCL_SETUP_TITLE        0x0002
#define EPF_NO_DOT_DOT_DOT          0x0004
#define EPF_ICONID_AS_HICON         0x0008
#define EPF_OVERLAY_WARNING_ICON    0x0010
#define EPF_OVERLAY_STOP_ICON       0x0020
#define EPF_OVERLAY_NO_ICON         0x0040
#define EPF_USE_HDLGTEMPLATE        0x0080


typedef struct _EXTPUSH {
    WORD                cbSize;         // size of the structure
    WORD                Flags;          // EPCBF_xxx flags
    LPTSTR              pTitle;         // extended push botton title
    union {
        DLGPROC         DlgProc;        // pointer to the dialog box proc
        FARPROC         pfnCallBack;    // callback function pointer
        } DUMMYUNIONNAME;
    ULONG_PTR           IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;          // dialog box template ID
        HANDLE  hDlgTemplate;           // handle to the dialog template
        } DUMMYUNIONNAME;
    ULONG_PTR   dwReserved[3];          // reserved field, must be 0
    } EXTPUSH, *PEXTPUSH;

//
// EXTPUSH structure is used to describe the extened push button available
// on OPTITEM/OPTITEM, each OPTTYPE can optional have either one extended check
// box or one extended push button callback.
//
//
//  cbSize          - size of this structure
//
//  Flags           - flags for the EXTPUSH as EPF_xxxx
//
//                      EPF_PUSH_TYPE_DLGPROC
//
//                          If this bit is set then it specified the extended
//                          push button is type of DLGPROC and DlgProc and
//                          DlgTemplateID is valid for common UI to call.
//
//                          If this bit is clear then it specfied the extended
//                          push button is the callback style and pfnCallBack
//                          should be called by the common UI
//
//
//                      EPF_INCL_SETUP_TITLE
//
//                          If specified for the extended push button then it
//                          automatically add the 'Setup' to the end of
//                          extended push button's title
//
//
//                      EPF_NO_DOT_DOT_DOT
//
//                          If specified then common UI will not add '...' to
//                          the end of the pTitle in the EXTPUSH.
//
//
//                      EPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID.
//
//
//                      EPF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                      EPF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                      EPF_OVERLAY_NO_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle          - Pointed to extended push botton title
//
//                      ** See LPTSTR description above
//
//  DlgProc         - Pointer to the DLGPROC function supplied by the caller.
//                    When user push the button the common UI will call
//                    DialogBoxParam() with this fucction pointer and passed
//                    CPSUICBPARAM structure pointer to the WM_INITDIALOG with
//                    the Reason set to CPSUICB_REASON_EXTPUSH.  If this
//                    filed is NULL then common UI assumed that EXTPUSH is
//                    disabled (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE), this
//                    fields only used if EPF_PUSH_TYPE_DLGPROC flag is set
//
//  pfnCallBack     - Pointer to CPSUICALLBACK function, this only used if
//                    EPF_PUSH_TYPE_DLGPROC bit is clear, duringing callback
//                    it passed the CPSUICBPARAM pointer as parameter
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    EPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - Specified the ressource ID for the dilaog box. If the
//                    DlgTemplateID = 0 then common UI will call the DlgProc
//                    with following parameter.
//
//                      DlgProc(hDlg, WM_USER, NULL, (LPARAM)pCPSUICBPaam);
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//  wReserved[]     - WORD reserved field, must be 0
//
//  dwReserved[]    - DWORD reserved field, must be 0
//
//
//


//
// Following are flags for the EXTCHKBOX
//

#define ECBF_CHECKNAME_AT_FRONT         0x0001
#define ECBF_CHECKNAME_ONLY_ENABLED     0x0002
#define ECBF_ICONID_AS_HICON            0x0004
#define ECBF_OVERLAY_WARNING_ICON       0x0008
#define ECBF_OVERLAY_ECBICON_IF_CHECKED 0x0010
#define ECBF_OVERLAY_STOP_ICON          0x0020
#define ECBF_OVERLAY_NO_ICON            0x0040
#define ECBF_CHECKNAME_ONLY             0x0080


typedef struct _EXTCHKBOX {
    WORD        cbSize;         // size of the structure
    WORD        Flags;          // ECBF_xxx flags
    LPTSTR      pTitle;         // extended checkbox title
    LPTSTR      pSeparator;     // pointer to separator string for treeview
    LPTSTR      pCheckedName;   // string to be displayed when checked
    ULONG_PTR   IconID;         // icon to be used
    WORD        wReserved[4];   // reserved word, must be 0
    ULONG_PTR   dwReserved[2];  // reserved field, must be 0
    } EXTCHKBOX, *PEXTCHKBOX;


//
// EXTCHKBOX structure is used to describe the extened check box available on
// OPTITEM/OPTITEM, each OPTTYPE can optional have one extended check box.
// When using EXTCHKBOX the selection item can be checked or not checked
// based on user input.
//
//
//  cbSize      - size of this structure
//
//  Flags       - flags for the EXTCHKBOX as ECBF_xxxx
//
//                  ECBF_CHECKNAME_AT_FRONT
//
//                      This flag specified how to display item's name and its
//                      checked name in the treeview display.   If this flag is
//                      set then the checked name is display in front of
//                      separator name, otherwise the checked name is displayed
//                      after the separator.  For Example.
//
//                      Flag Set:   pCheckedName pSeparator SelectName
//                      Flag Clear: SelectName pSeparator pCheckedName
//
//
//                  ECBF_CHECKNAME_ONLY_ENABLED
//
//                      If set then it specified that in the treeview display,
//                      it will only show the pCheckedName if this extended
//                      check box is visible and enabled.  Some items may not
//                      desired to display the pCheckedName if the extended
//                      check box is disabled, such as Copy/Collate checkbox.
//
//
//                  ECBF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  ECBF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  ECBF_OVERLAY_ECBICON_IF_CHECKED
//
//                      This bit specified to overlay the ExtChkBox's Icon to
//                      the OPTITEM's icon (or OPTPARAM) if the the extended
//                      checked box is checked
//
//
//                  ECBF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  ECBF_OVERLAY_NO_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle      - Pointed to extended check box title
//
//                  ** See LPTSTR description above
//
//  pSeparator  - Pointer to the separator to be used in the treeview
//                display or the static title control in the non-treeview
//                page,
//
//  pCheckedName- Pointed to the name to be displayed in the treeview if item
//                is checked.  pCheckedName is added according to the
//                pSeparator and the ECBF_CHECKNAME_AT_FRONT flags.
//
//                  * If the pCheckedName is equal to IDS_CPSUI_NOTINSTALLED
//                    then common UI will automatically overaly a not installed
//                    icon on top of the extended check box Icon.
//
//                      ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if ECBF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  wReserved[] - WORD reserved field, must be 0
//
//  dwReserved[]- DWORD reserved field, must be 0
//


//
// Following the the Flags for the OPTITEM
//

#define OPTIF_COLLAPSE              0x00000001L
#define OPTIF_HIDE                  0x00000002L
#define OPTIF_CALLBACK              0x00000004L
#define OPTIF_CHANGED               0x00000008L
#define OPTIF_CHANGEONCE            0x00000010L
#define OPTIF_DISABLED              0x00000020L
#define OPTIF_ECB_CHECKED           0x00000040L
#define OPTIF_EXT_HIDE              0x00000080L
#define OPTIF_EXT_DISABLED          0x00000100L
#define OPTIF_SEL_AS_HICON          0x00000200L
#define OPTIF_EXT_IS_EXTPUSH        0x00000400L
#define OPTIF_NO_GROUPBOX_NAME      0x00000800L
#define OPTIF_OVERLAY_WARNING_ICON  0x00001000L
#define OPTIF_OVERLAY_STOP_ICON     0x00002000L
#define OPTIF_OVERLAY_NO_ICON       0x00004000L
#define OPTIF_INITIAL_TVITEM        0x00008000L
#define OPTIF_HAS_POIEXT            0x00010000L

#define OPTIF_MASK                  0x0001ffffL


#define DMPUB_NONE                  0
#define DMPUB_FIRST                 1

#define DMPUB_ORIENTATION           1
#define DMPUB_SCALE                 2
#define DMPUB_COPIES_COLLATE        3
#define DMPUB_DEFSOURCE             4
#define DMPUB_PRINTQUALITY          5
#define DMPUB_COLOR                 6
#define DMPUB_DUPLEX                7
#define DMPUB_TTOPTION              8
#define DMPUB_FORMNAME              9
#define DMPUB_ICMMETHOD             10
#define DMPUB_ICMINTENT             11
#define DMPUB_MEDIATYPE             12
#define DMPUB_DITHERTYPE            13
#define DMPUB_OUTPUTBIN             14
#define DMPUB_QUALITY               15
#define DMPUB_NUP                   16
#define DMPUB_PAGEORDER             17

#define DMPUB_LAST                  17

#define DMPUB_OEM_PAPER_ITEM        97
#define DMPUB_OEM_GRAPHIC_ITEM      98
#define DMPUB_OEM_ROOT_ITEM         99
#define DMPUB_USER                  100

#define MAKE_DMPUB_HIDEBIT(DMPub)   (DWORD)(((DWORD)0x01 << ((DMPub) - 1)))
#define IS_DMPUB_HIDDEN(dw, DMPub)  (BOOL)((DWORD)(dw) &                    \
                                           MAKE_DMPUB_HIDEBIT(DMPub))

//
// DMPUB_xxxx is used in OPTITEM to identify if the item is a DEVMODE public
// field. Following it identify which field correspond to the DMPUB_xxxx
//
//
//  DMPUB_ORIENTATION   - dmOrientation
//
//  DMPUB_SCALE         - dmScale
//
//  DMPUB_COPIES_COLLATE- dmCopies/dmCollate
//
//  DMPUB_DEFSOURCE     - dmDefSource    (Should only used form by caller)
//
//  DMPUB_PRINTQUALITY  - dmPrintQuality
//
//  DMPUB_COLOR         - dmColor
//
//  DMPUB_DUPLEX        - dmDuplex
//
//  DMPUB_TTOPTION      - dmTTOption
//
//  DMPUB_FORMNAME      - dmFormName
//
//  DMPUB_ICMMETHOD     - dmICMMethod
//
//  DMPUB_ICMINTENT     - dmICMIntent
//
//  DMPUB_MEDIATYPE     - dmMediaType
//
//  DMPUB_DITHERTYPE    - dmDitherType
//
//  DMPUB_USER          - Anything greater than or equal to DMPUB_USER can be
//                        used by the caller.
//
//  DMPUB_OUTPUTBIN     - Private
//
//  DMPUB_QUALITY       - Private
//
//  DMPUB_NUP           - Private
//
//  DMPUB_PAGEORDER     - Private
//
// When common UI is called for the 'Document Properties' (DEVMODE), it will
// group some of public items together simillar to the following in the
// treeview. How it group is common UI version dependent and caller should not
// concern its placement
//
//      Paper/Output                (Add in by the common UI)
//        Document Form             (DMPUB_FORMNAME)
//        Output Bin                (DMPUB_OUTPUTBIN)
//        Orientation               (DMPUB_ORIENTATION)
//        Source                    (DMPUB_DEFSOURCE)
//        Media                     (DMPUB_MEDIATYPE)
//        Number of Copies          (DMPUB_COPIES_COLLATE)
//        Page Order                (DMPUB_PAGEORDER)
//        Page Per Sheet            (DMPUB_NUP)
//        Duplex                    (DMPUB_DUPLEX)
//
//      Graphic                     (Add in by the common UI)
//        Print Quality             (DMPUB_PRINTQUALITY)
//        Quality Settings          (DMPUB_QUALITY)
//        Color                     (DMPUB_COLOR)
//          Image Color Matching    (Add in by the common UI)
//              ICM Method          (DMPUB_ICMMETHOD)
//              ICM Intent          (DMPUB_ICMINTENT)
//        Scaling                   (DMPUB_SCALE)
//        Dithering                 (DMPUB_DITHERTYPE)
//        TrueType Option           (DMPUB_TTOPTION)
//
//      Options
//        Halftone Color Adjustment...
//        ALL Other Caller's Document sticky options
//
//
//  For 'Document Properties' the standard page 1 (user friendly page) will
//  consist following items if it appear in the OPTITEM array passed by the
//  caller.   These items must have following predefined TVOT_xxx type
//  defined here and specified in the OPTTYPE's Type field.
//
//  All DMPUB_xxx (except >= DMPUB_USER) public ID must have following
//  TVOT_xxxx type specified, else a CPDU_INVALID_DMPUB_TVOT error is returned
//
//      DMPUB_ORIENTATION       - TVOT_2STATES/TVOT_3STATES
//      DMPUB_SCALE             - TVOT_UDARROW
//      DMPUB_COPIES_COLLATE    - TVOT_UDARROW + EXTCHKBOX (Collate)
//      DMPUB_DEFSOURCE         - TVOT_LISTBOX
//      DMPUB_PRINTQUALITY      - TVOT_LISTBOX
//      DMPUB_COLOR             - TVOT_2STATES
//      DMPUB_DUPLEX            - TVOT_2STATES/TVOT_3STATES
//      DMPUB_TTOPTION          - TVOT_LISTBOX
//      DMPUB_FORMNAME          - TVOT_LISTBOX
//      DMPUB_ICMMETHOD         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_ICMINTENT         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_MEDIATYPE         - TVOT_LISTBOX
//      DMPUB_DITHERTYPE        - TVOT_LISTBOX
//
//


#define OIEXTF_ANSI_STRING      0x0001

typedef struct _OIEXT {
    WORD        cbSize;
    WORD        Flags;
    HINSTANCE   hInstCaller;
    LPTSTR      pHelpFile;
    ULONG_PTR   dwReserved[4];
    } OIEXT, *POIEXT;

//
// OIEXT is a data structure used as extension to the OPTITEM data structure
//
//
//  cbSize      - sizeof this structure
//
//  Flags       - One or more of OIEXTF_xxxx may be specified.
//
//                  OIEXTF_ANSI_STRING
//
//                      Specified that LPTSTR in this data structure is a ansi
//                      string (not UNICODE).  This bit only checked if the
//                      LPTSTR is not the resource string ID
//
//  hInstCaller - DLL instance handle, when this hInst is not NULL then all
//                resource string and icon loading for this OPTITEM and its
//                OPTTYPE, OPTPARAM are loaded from this hInstCaller Handle.
//                If this filed is NULL then it will use the hInstCaller handle
//                specified in the COMPROPSHEETUI data structure
//
//  pHelpFile   - Resource string ID or pointer to the help file for this
//                OPTITEM.  If this pointer is NULL then help file for the
//                help index is assume specified in the pHelpFile field in the
//                COMPROPSHEETUI data structure.
//
//  dwReserved  - These fields are not used now, and must 0
//


typedef struct _OPTITEM {
    WORD        cbSize;                 // size of this structure
    BYTE        Level;                  // level in the tree view
    BYTE        DlgPageIdx;             // Index to the pDlgPage
    DWORD       Flags;                  // OPTIF_xxxx flags
    ULONG_PTR   UserData;               // caller's own data
    LPTSTR      pName;                  // name of the item
    union {
        LONG    Sel;                    // current selection (index)
        LPTSTR  pSel;                   // current selection (pStr)
        } DUMMYUNIONNAME;
    union {
        PEXTCHKBOX  pExtChkBox;         // Pointer to EXTCHKBOX structure
        PEXTPUSH    pExtPush;           // Pointer to EXTPUSH
        } DUMMYUNIONNAME2;
    POPTTYPE    pOptType;               // pointer to OPTTYPE structure
    DWORD       HelpIndex;              // Help file index
    BYTE        DMPubID;                // Devmode public filed ID
    BYTE        UserItemID;             // caller's own item ID
    WORD        wReserved;              // reserved WORD field, must be 0
    POIEXT      pOIExt;                 // Optitem extension pointer
    ULONG_PTR   dwReserved[3];          // reserved DWORD fields (must be 0)
    } OPTITEM, *POPTITEM;

//
// OPTITEM is to describe each treeview item's name, selection type and
// possible selection
//
//  cbSize          - sizeof this structure
//
//  Level           - The level in the treeview, the root should have lowest
//                    number and number should start with level 0.  the maximum
//                    number of levels are 256.
//
//  DlgPageIdx      - Zero-based index to the DLGPAGE araay pointee by
//                    pDlgPage. The Maximum index is MAX_DLGPPAGE_COUNT, if
//                    pDlgPage is a standard CPSUI_PDLGPAGE_xxxx then this
//                    field is automatically set the common UI
//
//  Flags           - OPTIF_xxxx flags as describe above
//
//                      OPTIF_COLLAPSE
//
//                          Collaspe treeview item and its children so it is
//                          not expanded initially.
//
//
//                      OPTIF_HIDE
//
//                          Hide this item from the treeview
//
//
//                      OPTIF_CALLBACK
//
//                          Callback to the caller when user making some
//                          changes a pointer (pfnCallBack) must provided and
//                          process as defined by the common UI.
//
//
//                      OPTIF_CHANGED
//
//                          This item was changed and need to re-display. this
//                          flag only used when caller returned from callback
//                          funciton.
//
//
//                      OPTIF_CHANGEONCE
//
//                          This item has been changed at least once.
//
//
//                      OPTIF_DISABLED
//
//                          Disable this item so it become not selectable.
//
//
//                      OPTIF_ECB_CHECKED
//
//                          Specified the associated extended check box is
//                          in checked state.
//
//
//                      OPTIF_EXT_HIDE
//
//                          Hide the extended check box/extended push botton.
//
//
//                      OPTIF_EXT_DISABLED
//
//                          The Extended check box/push botton is disabled and
//                          not selectable
//
//
//                      OPTIF_SEL_AS_HICON
//
//                          This flag only used if this item has no type,
//                          pOptType=NULL that is, when pOptType is NULL then
//                          'Sel' field is the IconID. if flag is set then it
//                          indicate 'pSel' is the Icon handle rather
//                          than the icon resource ID specified in Sel.
//
//
//                      OPTIF_EXT_IS_EXTPUSH
//
//                          Specified that pExtPush should be used when this
//                          pointer is not NULL, if this pointer is not NULL
//                          and this flag is clear then pExtChkBox is assumed.
//
//
//                      OPTIF_NO_GROUPBOX_NAME
//
//                          Specified that do not overwrite the group box title
//                          text, if group box ID is defined. See the TVOT_xx
//                          description above.
//
//
//                      OPTIF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's
//                          IDI_CPSUI_WARNING icon.  This bit only used if this
//                          item has no type, pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_STOP
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_NO_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_NO
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_INITIAL_TVITEM
//
//                          Specified that this item will be the initial item
//                          to be selected and display on the treeview page.
//                          If the selected item is currently a child or
//                          collapse then common UI will expand the selection
//                          then scroll it into view.
//
//                          If this flag is clear or the set item is in hide
//                          status common UI will pick the initial item to
//                          display.
//
//                      OPTIF_HAS_POIEXT
//
//                          Specified that pOIExt field is a valid pointer that
//                          points to OIEXT data structure.  The pOIExt only
//                          used by the common UI if this bit is set.
//
//
//  UserData        - a 32-bit number used by the caller and common UI will not
//                    modify it.
//
//  pName           - Pointer to the item's name, such as 'Upper Tray',
//                    'Memory' or it is used as data as describe in
//                    OPTPARAM/OPTTYPE structure
//
//                      ** See LPTSTR description above
//
//  pSel
//  Sel             - Current selection for this item. This is a union field
//                    which can be a pointer to a string or a LONG index
//                    selection.
//
//                      ** If pOptType field is NULL then 'Sel' is the icon ID
//                         to be used for the header.
//
//  pExtPush
//  pExtChkBox      - Pointer to either EXTPUSH or EXTCHKBOX data structure,
//                    if this pointer is NULL then this item does not have
//                    ectended check box/push botton associate with it.
//
//                    When an extended check box is associate with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH must not set, the
//                    OPTIF_ECB_CHECKED flag specified if the extended check
//                    box is checked or not checked.
//
//                    When an Extended push botton is associated with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH flag must set.
//
//                    The following flags are used in both EXTCHKBOX or
//                    EXTPUSH
//
//                      OPTIF_EXT_HIDE,
//                      OPTIF_EXT_DISABLED
//                      OPTIF_EXT_CHANGEONCE
//
//
//  pOptType        - Pointer to the OPTTYPE structure to describe the display
//                    and selections of the item.   If this pointer is NULL
//                    then this this item does not have any selection. and it
//                    is used as sub-items' header.
//
//                      * When pOptType is NULL then the 'Sel' is the Icon ID.
//
//
//  HelpIndex       - a index to the help file for context sensitive help
//                    if HelpInex=0 then there is no help for this item
//
//  DMPubID         - specified if this item is one of the public fields in the
//                    DEVMODE structure and supported by the common UI.
//
//                      DMPUB_NONE              - Not DEVMODE public fields
//                      DMPUB_ORIENTATION       - dmOrientation
//                      DMPUB_SCALE             - dmScale
//                      DMPUB_COPIES_COLLATE    - dmCopies/dmCollate
//                      DMPUB_DEFSOURCE         - dmDefSource
//                      DMPUB_PRINTQUALITY      - dmPrintQuality
//                      DMPUB_COLOR             - dmColor
//                      DMPUB_DUPLEX            - dmDuplex
//                      DMPUB_TTOPTION          - dmTTOption
//                      DMPUB_FORMNAME          - dmFormName
//                      DMPUB_ICMMETHOD         - dmICMMethod
//                      DMPUB_ICMINTENT         - dmICMIntent
//                      DMPUB_MEDIATYPE         - dmMediaType
//                      DMPUB_DITHERTYPE        - dmDitherType
//
//                      ** for most of DMPUB_FIRST to DMPUB_LAST each OPTITEM's
//                         pName is automatically set to the standard
//                         IDS_CPSUI_xxx for the consistancy reason, the
//                         standard pName is set according to following table.
//
//                          DMPUB_ORIENTATION    - IDS_CPSUI_ORIENTATION
//                          DMPUB_SCALE          - IDS_CPSUI_SCALING
//                          DMPUB_COPIES_COLLATE - IDS_CPSUI_COPIES
//                          DMPUB_DEFSOURCE      - IDS_CPSUI_SOURCE
//                          DMPUB_PRINTQUALITY   - IDS_CPSUI_PRINTQUALITY
//                                                 IDS_CPSUI_RESOLUTION
//                          DMPUB_COLOR          - IDS_CPSUI_COLOR_APPERANCE
//                          DMPUB_DUPLEX         - IDS_CPSUI_DUPLEX
//                          DMPUB_TTOPTION       - IDS_CPSUI_TTOPTION
//                          DMPUB_FORMNAME       - IDS_CPSUI_FORMNAME
//                          DMPUB_ICMMETHOD      - IDS_CPSUI_ICMMETHOD
//                          DMPUB_ICMINTENT      - IDS_CPSUI_ICMINTENT
//                          DMPUB_MEDIATYPE      - IDS_CPSUI_MEDIA
//                          DMPUB_DITHERTYPE     - IDS_CPSUI_DITHERING
//
//                          for DMPUB_PRINTQUALITY, if the pName is not one of
//                          IDS_CPSUI_PRINTQUALITY or IDS_CPSUI_RESOLUTION then
//                          common UI will automatically default the pName to
//                          IDS_CPSUI_RESOLUTION.
//
//                          Each pData (OPTPARAM) selection in OPTPARAM which
//                          OPTITEM's pOptType pointed to should use as much
//                          as IDS_CPSUI_xxx standard name as possible.
//
//
//                      ** for DMPUB_COPIES_COLLATE the common UI automatically
//                         doing the following before the callback
//
//                          1) Enable/Disable the collate extended check box if
//                             OPTIF_EXT_HIDE is not specified and pExtChkBox
//                             is not NULL in the OPTITEM.
//
//                          2) Automatically change the postfix for this item
//                             to be 'Copy' if selection is one, and 'Copies'
//                             if selection is greater than one in the treeview
//                             page, and it will also set the postfix in
//                             standard document property page if the postfix
//                             ID is provided (BegCtrlID + 4)
//
//
//                      ** for DMPUB_COLOR the common UI automatically doing
//                         the following before the callback, the gray
//                         selection must be Sel=0 and Color slection must be
//                         Sel=1
//
//                          1) Calling halftone color adjustment with current
//                             color/mono selection
//
//                          2) Disable ICM when color is not selected
//
//
//                      ** Please see above DMPUB_xx description for details.
//
//  UserItemID      - This is a byte ID intented to be used by the caller to
//                    identify the item
//
//  wReserved       - WORD reserved. Must be zero
//
//  pOIExt          - Pointer to the OIEXT data structure to specified that
//                    it has a OPTITEM extenstion structure.
//
//  dwReserved[]    - DWORD reserved and must be 0
//
//

//
// predefined ID for call back reason
//

#define CPSUICB_REASON_SEL_CHANGED      0
#define CPSUICB_REASON_PUSHBUTTON       1
#define CPSUICB_REASON_ECB_CHANGED      2
#define CPSUICB_REASON_DLGPROC          3
#define CPSUICB_REASON_UNDO_CHANGES     4
#define CPSUICB_REASON_EXTPUSH          5
#define CPSUICB_REASON_APPLYNOW         6
#define CPSUICB_REASON_OPTITEM_SETFOCUS 7
#define CPSUICB_REASON_ITEMS_REVERTED   8
#define CPSUICB_REASON_ABOUT            9
#define CPSUICB_REASON_SETACTIVE        10
#define CPSUICB_REASON_KILLACTIVE       11


//
// predefined ID for call back action
//

#define CPSUICB_ACTION_NONE             0
#define CPSUICB_ACTION_OPTIF_CHANGED    1
#define CPSUICB_ACTION_REINIT_ITEMS     2
#define CPSUICB_ACTION_NO_APPLY_EXIT    3
#define CPSUICB_ACTION_ITEMS_APPLIED    4


typedef struct _CPSUICBPARAM {
    WORD        cbSize;             // size of this structure
    WORD        Reason;             // CPSUICB_REASON_XXXXX callback reason
    HWND        hDlg;               // handle of the dialog box
    POPTITEM    pOptItem;           // pOptItem field from COMPROPSHEETUI
    WORD        cOptItem;           // cOptItem field from COMPROPSHEETUI
    WORD        Flags;              // flags field from COMPROPSHEETUI
    POPTITEM    pCurItem;           // current selected item of callback
    union {
        LONG    OldSel;             // Last selection (index)
        LPTSTR  pOldSel;            // Last selection (pStr)
        } DUMMYUNIONNAME;
    ULONG_PTR   UserData;           // UserData in the COMPROPSHEETUI struct.
    ULONG_PTR   Result;             // OUT parameter for the APPLYNOW
    } CPSUICBPARAM, *PCPSUICBPARAM;


typedef LONG (APIENTRY *_CPSUICALLBACK)(PCPSUICBPARAM pCPSUICBParam);
#define CPSUICALLBACK   LONG APIENTRY


//
// CPSUICBPARAM is used when commom UI callback to the caller, this structure
// describe the nature of callback and passed all necessary parameter for the
// caller to make changes in the pOptItem and passed an action back to the
// commom UI to redisplay the tree or page 1 data
//
//
//  cbSize      - must be CPSUICBPARAM
//
//  Reason      - defined the nature of the callback
//
//                  CPSUICB_REASON_SEL_CHANGED
//
//                      User make change to the pCurItem.  if the item is
//                      DMPUB_COPIES_COLLATE then common UI automatically
//                      change the collate extended check box without callback
//                      to the caller of the extended check box changes
//
//
//                  CPSUICB_REASON_PUSHBUTTON
//
//                      User push the push button and push button item is set
//                      to PUSHBUTTON_TYPE_CALLBACK.
//
//
//                  CPSUICB_REASON_ECB_CHANGED
//
//                      User make change to the extended checked box (i.e. it
//                      eiterh checked or not checked) EXTCHKBOX in the
//                      pCurItem passed in the call back parameter.
//
//
//                  CPSUICB_REASON_DLGPROC
//
//                      The callback reason is PUSHBUTTON_TYPE_DLGPROC
//
//
//                  CPSUICB_REASON_UNDO_CHANGES
//
//                      This callback currently is not implmented.
//
//
//                  CPSUICB_REASON_EXTPUSH
//
//                      The callback is result of user push the extend push
//                      button.
//
//
//                  CPSUICB_REASON_APPLYNOW
//
//                      The user press the apply now button. Durning callback
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the active DlgPageIdx
//                      (compare to the OPTITEM's DlgPageIdx) which the page
//                      user hitting the apply now button if the page is
//                      non-treeview page, otherwise the 'OldSel' is set to -1
//                      (for treeview page) to indicate all valid item should
//                      be apply now, if the callback return
//                      CPSUICB_ACTION_NONE then the common UI will exit the
//                      property sheet and returned CPSUI_OK back to the
//                      caller, and if the callback function returned
//                      CPSUICB_ACTION_NO_APPLY_EXIT then common UI will not
//                      exit the property sheet and callback function must
//                      pop-up messages dialog box to tell user why it cannot
//                      exist the property sheet until certain action is take
//                      by the user.
//
//
//                  CPSUICB_REASON_OPTITEM_SETFOCUS
//
//                      This callback reason is used when an OPTITEM is getting
//                      the keyboard focus. and give the callback function a
//                      chance to examine the item.
//
//
//                  CPSUICB_REASON_ITEMS_REVERTED
//
//                      This callback reason is used when user changed items
//                      and decided to revert changes from the parent item in
//                      the treeview.  The callback funciton is called after
//                      all revertable items are reverted to its original.
//
//                      The CPSUICBPARAM's pCurItem is same as pOptItem and
//                      'OldSel' field is same as cOptItem field.  for each of
//                      reverted item, the OPTIF_CHANGED bit will be set in the
//                      OPTITEM by the common UI to indicate the item is revert
//                      by the common UI.   The callback function MUST NOT
//                      reset this bit if it is set.
//
//
//                  CPSUICB_REASON_ABOUT
//
//                      This callback reason is used when user hit 'About...'
//                      push button in the treeview page, and the flag
//                      CPSUIF_ABOUT_CALLBACK is set.  The pCurItem is set to
//                      same as pOptItem and 'pOldSel' is a pointer pointed to
//                      original copy of COMPROPSHEETUI data structure which
//                      passed to the common UI.
//
//
//                  CPSUICB_REASON_SETACTIVE
//                  CPSUICB_REASON_KILLACTIVE
//
//                      The current property sheet is gaining or loosing focus,
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the current active
//                      DlgPageIdx (compare to the OPTITEM's DlgPageIdx).
//                      if the page is non-treeview page, otherwise the
//                      'OldSel' is set to -1 (for treeview page).
//
//  hDlg        - The handle to the dialog box (Properties page TAB) current
//                active for the callback.
//
//                Durning the callback the caller must not change the
//                DWLP_USERDATA on hDlg, otherwise the common UI will be crash.
//                If callback function need to get/set DWLP_USERDATA it should
//                call common UI's SetCPSUIUserData() and GetCPSUIUserData()
//                functions instead.
//
//  pCurItem    - Pointed to POPTITEM which the callback is generated for.
//
//  pOldSel
//  OldSel      - The last OPTITEM's pSel/Sel field before the change was made
//                by the user.  The pOldSel/OldSel only valid if the callback
//                reason is CPSUICB_REASON_SEL_CHANGED, this give the callback
//                function a chance to check against the previous item
//                selection.  This is a union field which can be a pointer to
//                a string or a LONG index selection.
//
//  UserData    - a 32-bit user defined data in the COMPROPSHEETUI structure,
//                commom UI will not changed it.
//
//  Result      - When the reason is CPSUICB_REASON_APPLYNOW, the callback
//                function MUST set the requested result for the caller into
//                'Result' field when it returned a value other than the
//                CPSUICB_ACTION_NO_APPLY_EXIT and common UI will send the
//                'Result' field value to this page's parent.
//
//                The called function should save the current result of
//                pOptItem.  The default 'Result' is set to CPSUI_OK (1) from
//                common UI.  This function can alter this result before it
//                return back to to the common UI.
//
//
//  Return Values:
//
//      CPSUICB_ACTION_NONE             - No action need to be take by the
//                                        common UI.
//
//      CPSUICB_ACTION_OPTIF_CHANGED    - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-display because of OPTITEM's Flags
//                                        field changed or item's selection
//                                        changed.   This is different from
//                                        CPSUICB_ACTION_REINIT_ITEMS which
//                                        it assume OPTTYPE or OPTPARAM data
//                                        also changed.
//
//
//      CPSUICB_ACTION_REINIT_ITEMS     - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-initialized in the dilaog box
//                                        control.  This happened if item's
//                                        OPTTYPE or OPTPARAMs flag/pdata
//                                        changed.
//
//
//      CPSUICB_ACTION_NO_APPLY_EXIT    - This return value only valid durning
//                                        CPSUICB_REASON_APPLYNOW callback
//                                        reason, it tell common UI it has
//                                        some constraints in its OPTITEM which
//                                        must correct or confirm by the user
//                                        before exit.  The callback function
//                                        must display and/or have user taking
//                                        some actions before return this
//                                        action to the common UI
//
//      CPSUICB_ACTION_ITEMS_APPLIED    - When responsed to the
//                                        CPSUICB_REASON_APPLYNOW, if the
//                                        returned action is
//                                        CPSUICB_ACTION_ITEMS_APPLIED then
//                                        common UI will reset OPTIF_CHANGEONCE
//                                        bit and save the new default for the
//                                        future undo operations.
//
//

#define DP_STD_TREEVIEWPAGE             0xFFFF
#define DP_STD_DOCPROPPAGE2             0xFFFE
#define DP_STD_DOCPROPPAGE1             0XFFFD
#define DP_STD_RESERVED_START           0xFFF0

#define MAX_DLGPAGE_COUNT               64

#define DPF_ICONID_AS_HICON             0x0001
#define DPF_USE_HDLGTEMPLATE            0x0002

typedef struct _DLGPAGE {
    WORD        cbSize;         // size of this structure
    WORD        Flags;          // DPF_xxxx flags
    DLGPROC     DlgProc;        // caller's dialog box subclass procedue
    LPTSTR      pTabName;       // pointer to the tab name
    ULONG_PTR   IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;  // dialog box template ID
        HANDLE  hDlgTemplate;   // handle to the dialog template
        } DUMMYUNIONNAME;
    } DLGPAGE, *PDLGPAGE;


//
// DLGPAGE structure describe non-treeview page characteristics
//
//
//  cbSize          - size of this structure
//
//  Flags           - DPF_xxxx flags
//
//                      DPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID
//
//
//  DlgProc         - caller's supplied DLGPROC for sub-class the page
//                    dialog box processing,
//
//                    if DlgProc is not NULL then common UI do the following
//                    according the the message received except for the
//                    DP_STD_xxx pages
//
//
//                      WM_INITDIALOG
//
//                          Common UI initialize the dialog box and then call
//                          DlgProc(WM_INITDIALOG) the DlgProc should return
//                          exactly the behavior for the WM_INITDIALOG
//
//                          The lParam in the WM_INITDIALOG data structure is
//                          a pointer to the PROPSHEETPAGE data structure.
//
//                          the lParam field in the PROPSHEETPAGE (lParam
//                          passed to the WM_INITDIALOG) is the UserData
//                          defined in COMPROPSHEETUI data structure
//
//                          To access to the PSPINFO data structure which
//                          associate with this page, use the common UI macro
//                          PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) where
//                          lParam is the parameter passed to the
//                          WM_INITDIALOG message.
//
//                          The subclass function should save these pointers
//                          for its later use, but it MUST NOT modified the
//                          content of the PSPINFO data structure or system
//                          may crashed.
//
//
//                      OTHER DIALOG MESSAGES
//
//                          Iit call DlgProc() and if it returned the value is
//                          non-zero then common UI assume DlgProc() processed
//                          the message and will not process this message.
//
//                          If the returned vlaue from DlgProc() is zero then
//                          common UI will process this message.
//
//
//                      * Durning the DlgProc the caller must not change the
//                        DWLP_USERDATA on hDlg, otherwise the common UI will
//                        be crash.  If caller need to get/set DWLP_USERDATA it
//                        should call common UI's SetCPSUIUserData() and
//                        GetCPSUIUserData() instead.
//
//  pTabName        - Pointer to a string to describe the TAB title
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    DPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - The template id to be use for the ProPage, it can be
//                    one of DP_STD_xxxx, the DP_STD_xxx has 240 x 240 dialog
//                    box units.
//
//
//                      DP_STD_TREEVIEWPAGE
//
//                          Specified that this page is a standard treeview
//                          page provided by the common ui.  The treeview page
//                          is a page using treeview display all valid OPTITEM
//                          passed to the common UI.  User can modify every
//                          valid selectable OPTITEM from the treeview page.
//
//                      DP_STD_DOCPROPPAGE
//
//                          Specified that this page is a standard document
//                          property page provided by the common UI
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//
//  wReserved[]
//  dwReserved[]    - Reserved fields, must be 0
//
//
//  ** Tips of designing the dialog box controls
//
//      When designing the dialog box controls, each OPTITEM is correspoonds
//      to one input control plus one extended check box or extended push
//      button.  Since common UI will automatically disable and remove
//      OPTIF_HIDE items item from the property sheet and dynamically move
//      other controls, the following tips of designing the dialog box controls
//      should follow.
//
//      * Each item should have one input control plus optional of extended
//        check box/push botton, one icon control and other static controls
//
//      * Each item should occupied whole horizontal spaces of the property
//        sheet, items must not overlay in vertical direction.
//
//      * for TVOT_2STATES, TVOT_3STATES, if it araange radio buttons from
//        left to right in state order (ie. from first state's OPTPARAM to
//        last state's OPTPARAM) then the radio buttons and icons should
//        aligned in the Y coordinate.    If it arrange radio buttons from top
//        to bottom (ie. from first state's OPTPARAM to last state's OPTPARAM)
//        then the radio buttons and icons should aligned in the X coordinate.
//
//        common UI will automatically hide/move the radio buttons to compact
//        the dialog box controls.  If radio buttons/icons are arranged in
//        top/down order and there is other controls obscure in Y direction
//        then radio buttons will only be re-arranged but not remove any white
//        spaces in Y direction.
//
//      * If multiple items shared one group box, then the group box must
//        belongs to the first item (topmost in the dialog box group) in the
//        group, the group box must large enough to cover all the items in
//        side the group box.
//
//


#define CPSUIF_UPDATE_PERMISSION        0x0001
#define CPSUIF_ICONID_AS_HICON          0x0002
#define CPSUIF_ABOUT_CALLBACK           0x0004

#define CPSUI_PDLGPAGE_DOCPROP          (PDLGPAGE)1
#define CPSUI_PDLGPAGE_ADVDOCPROP       (PDLGPAGE)2
#define CPSUI_PDLGPAGE_PRINTERPROP      (PDLGPAGE)3
#define CPSUI_PDLGPAGE_TREEVIEWONLY     (PDLGPAGE)4

//
// For compatible misspelling #define
//

#define CPSUI_PDLGPAGE_TREEVIWONLY      CPSUI_PDLGPAGE_TREEVIEWONLY

typedef struct _COMPROPSHEETUI {
    WORD            cbSize;             // size of this structure
    WORD            Flags;              // CPSUIF_xxxx flags
    HINSTANCE       hInstCaller;        // caller's hInstance
    LPTSTR          pCallerName;        // pointer to the caller's name
    ULONG_PTR       UserData;           // caller's own data
    LPTSTR          pHelpFile;          // pointer to the help file
    _CPSUICALLBACK  pfnCallBack;        // callback function pointer
    POPTITEM        pOptItem;           // pointer to POPTITEM array
    PDLGPAGE        pDlgPage;           // pointer to the DLGPAGE array
    WORD            cOptItem;           // count of pOptItem array
    WORD            cDlgPage;           // count of pDlgPage array
    ULONG_PTR       IconID;             // icon to be used
    LPTSTR          pOptItemName;       // pointer to the optitem's data name
    WORD            CallerVersion;      // version for the caller apps
    WORD            OptItemVersion;     // version for the optitem name
    ULONG_PTR       dwReserved[4];      // reserved, must be 0
    } COMPROPSHEETUI, *PCOMPROPSHEETUI;


//
// COMPROPSHEETUI data structure is used when calling common UI to display dialog
// box of properties pages.
//
//
//  Size                - Must be sizeof (COMPROPSHEETUI)
//
//  Flags               - can be one or more of following
//
//                          CPSUIF_UPDATE_PERMISSION
//
//                              Specified the any valid pOptItem items are
//                              changeable by the user.
//
//
//                          CPSUIF_ICONID_AS_HICON
//
//                              If this flag is set then IconID DWORD field is
//                              treated as a handle to the icon rather then the
//                              resource ID
//
//
//                          CPSUIF_ABOUT_CALLBACK
//
//                              If this flag bit is set, then when user hit
//                              'About...' button in the treeview tab, it will
//                              call the callback function with a reason of
//                              CPSUICB_REASON_ABOUT, and callback MUST handle
//                              the about which pop-up dialog box to show user
//                              the information about the caller and OPTITEMs.
//
//                              If this bit is not set then common UI will call
//                              the ShellAbout() with formatted caller Name and
//                              pOptItemName with version numbers.
//
//
//  hInstCaller         - the caller's handle to its instance.  Commom UI use
//                        this handle to load caller's icon and other resources.
//
//  pCallerName         - Pointer to the caller's NULL terminated caller's
//                        name, most time this is driver's name,
//                        such as 'Postscript Driver'
//
//  UserData            - a 32-bit number used by the caller and common UI will
//                        not modify it.  this 32-bit number is passed back to
//                        the caller durning the callback function
//
//  pHelpFile           - specified a standard microsoft help file (path/file)
//                        for using in the common UI.  in OPTITEM specified
//                        HelpIndex for help in each item.
//
//  pfnCallBack         - Pointer to _CPSUICALLBACK callback function.  Common
//                        UI only callback to the caller if an OPTIF_CALLBACK
//                        is set OPTITEM data structure's flag fields and the
//                        item selection is changed by the user.
//
//  pOptItem            - Pointer to array of OPTITEM structure to be displayed
//                        by the common UI
//
//  pDlgPage            - Pointer to array of DLGPAGE structure to describe
//                        each property sheet page infomation, the following
//                        are the standard common ui DLGPAGEs.  When specified
//                        CPSUI_PDLGPAGE_xxxx, the common UI will automatically
//                        modify DlgPageIdx field in the OPTITEM, caller must
//                        set the iStartPage correctly.
//
//                          CPSUI_PDLGPAGE_DOCPROP
//
//                              specified this a common ui standard document
//                              property sheets. This includes two property
//                              sheets, 1) Page Setup 2) Advance (TreeView)
//
//
//                          CPSUI_PDLGPAGE_ADVDOCPROP
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page with tab of 'Advance'
//
//
//                          CPSUI_PDLGPAGE_PRINTERPROP
//
//                              Specified this is a common UI standard printer
//                              property sheet.  This only has one treeview
//                              page with tab of 'Device Options'
//
//
//                          CPSUI_PDLGPAGE_TREEVIEWONLY
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page
//
//
//
//  cOptItem            - Count of OPTITEM pointed by the pOptItem above
//
//  cDlgPage            - Count of DLGPAGE pointed by the pDlgPage.  If
//                        pDlgPage is one of the CPSUI_PDLGPAGE_xxxx then this
//                        field is ignored by the common UI.
//
//  IconID              - This is the icon identifier, which can be a common
//                        strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                        resource ID, or a handle to the caller defined icon
//                        if CPSUIF_ICONID_AS_HICON flag is set, in any case
//                        if the IconID is zero then it indicated no icon.
//
//  pOptItemName        - Pointer to the pOptItem data NULL terminated name,
//                        most time this is device name, such as 'HP 4si'
//
//  CallerVersion       - Version for the caller, the HIBYTE(CallerVersion) is
//                        the major version, and LOBYTE(CallerVersion) is the
//                        minor version, such as 0x310 display as 3.16, 0x3ff
//                        display as 3.255 and 0x30a display as 3.10
//
//  OptItemVersion      - Version for the OPTITEM's data, the
//                        HIBYTE(OptItemVersion) is the major version, and
//                        LOBYTE(OptItemVersion) is the minor version, such as
//                        0x310 display as 3.16, 0x3ff display as 3.255 and
//                        0x30a display as 3.10.
//
//  dwReserved[4]       - reserved fields, must be 0
//
//
//  ** pTitlee and TitleBarIcon only used if CommonPrinterPropSheetUI()
//     is the last one the Property sheet UI chain and call the PropertySheet()
//
//


#define CPSFUNC_ADD_HPROPSHEETPAGE          0
#define CPSFUNC_ADD_PROPSHEETPAGEW          1
#define CPSFUNC_ADD_PCOMPROPSHEETUIA        2
#define CPSFUNC_ADD_PCOMPROPSHEETUIW        3
#define CPSFUNC_ADD_PFNPROPSHEETUIA         4
#define CPSFUNC_ADD_PFNPROPSHEETUIW         5
#define CPSFUNC_DELETE_HCOMPROPSHEET        6
#define CPSFUNC_SET_HSTARTPAGE              7
#define CPSFUNC_GET_PAGECOUNT               8
#define CPSFUNC_SET_RESULT                  9
#define CPSFUNC_GET_HPSUIPAGES              10
#define CPSFUNC_LOAD_CPSUI_STRINGA          11
#define CPSFUNC_LOAD_CPSUI_STRINGW          12
#define CPSFUNC_LOAD_CPSUI_ICON             13
#define CPSFUNC_GET_PFNPROPSHEETUI_ICON     14
#define CPSFUNC_ADD_PROPSHEETPAGEA          15
#define CPSFUNC_INSERT_PSUIPAGEA            16
#define CPSFUNC_INSERT_PSUIPAGEW            17
#define CPSFUNC_SET_PSUIPAGE_TITLEA         18
#define CPSFUNC_SET_PSUIPAGE_TITLEW         19
#define CPSFUNC_SET_PSUIPAGE_ICON           20
#define CPSFUNC_SET_DATABLOCK               21
#define CPSFUNC_QUERY_DATABLOCK             22
#define CPSFUNC_SET_DMPUB_HIDEBITS          23
#define CPSFUNC_IGNORE_CPSUI_PSN_APPLY      24
#define CPSFUNC_DO_APPLY_CPSUI              25
#define CPSFUNC_SET_FUSION_CONTEXT          26
#define MAX_CPSFUNC_INDEX                   26

#ifdef UNICODE
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIW
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIW
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGW
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEW
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEW
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEW

#else
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIA
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIA
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGA
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEA
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEA
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEA

#endif

//
// for the CPSFUNC_SET_RESULT
//

#define SR_OWNER            0
#define SR_OWNER_PARENT     1

typedef struct _SETRESULT_INFO {
    WORD        cbSize;
    WORD        wReserved;
    HANDLE      hSetResult;
    LRESULT     Result;
    } SETRESULT_INFO, *PSETRESULT_INFO;

//
// This is for CPSFUNC_INSERT_PSUIPAGE
//

#define HINSPSUIPAGE_FIRST              (HANDLE)0xFFFFFFFE
#define HINSPSUIPAGE_LAST               (HANDLE)0xFFFFFFFF
#define HINSPSUIPAGE_INDEX(i)           (HANDLE)MAKELONG(i, 0);

#define PSUIPAGEINSERT_GROUP_PARENT     0
#define PSUIPAGEINSERT_PCOMPROPSHEETUI  1
#define PSUIPAGEINSERT_PFNPROPSHEETUI   2
#define PSUIPAGEINSERT_PROPSHEETPAGE    3
#define PSUIPAGEINSERT_HPROPSHEETPAGE   4
#define PSUIPAGEINSERT_DLL              5
#define MAX_PSUIPAGEINSERT_INDEX        5


#define INSPSUIPAGE_MODE_BEFORE         0
#define INSPSUIPAGE_MODE_AFTER          1
#define INSPSUIPAGE_MODE_FIRST_CHILD    2
#define INSPSUIPAGE_MODE_LAST_CHILD     3
#define INSPSUIPAGE_MODE_INDEX          4


typedef struct _INSERTPSUIPAGE_INFO {
    WORD        cbSize;
    BYTE        Type;
    BYTE        Mode;
    ULONG_PTR   dwData1;
    ULONG_PTR   dwData2;
    ULONG_PTR   dwData3;
    } INSERTPSUIPAGE_INFO, *PINSERTPSUIPAGE_INFO;


//
// for the CPSFUNC_SET_HSTARTPAGE
//

#define SSP_TVPAGE          10000
#define SSP_STDPAGE1        10001
#define SSP_STDPAGE2        10002

typedef LONG_PTR (CALLBACK *PFNCOMPROPSHEET)(HANDLE hComPropSheet,
                                             UINT   Function,
                                             LPARAM lParam1,
                                             LPARAM lParam2);


typedef struct _PSPINFO {
    WORD            cbSize;
    WORD            wReserved;
    HANDLE          hComPropSheet;
    HANDLE          hCPSUIPage;
    PFNCOMPROPSHEET pfnComPropSheet;
    } PSPINFO, *PPSPINFO;

//
// PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) macro retrieve a pointer to the
// PSPINFO data structure. the lParam must be the lParam passed to the
// WM_INITDIALOG, otherwise the system can failed
//

#define PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam)  \
                (PPSPINFO)((LPBYTE)lParam + ((LPPROPSHEETPAGE)lParam)->dwSize)

//
// PSPINFO
//
//  This structure is used durning property sheet page's WM_INITDIALOG message.
//  At WM_INITDIALOG, the lParam is a pointer to the PROPSHEETPAGE, and
//  lParam field in the PROPSHEETPAGE is a pointer to the PSPINFO.  the
//  original lParam in the PROPSHEETPAGE is saved in the lParam field in the
//  PSPINFO data structure.
//
//  When process WM_INITDIALOG message, it should save the lParam (PSPINFO
//  structure pointer) for later to call common UI callback functions.
//
//
//  cbSize          - Size of this structure in bytes
//
//  wReserved       - Reserved, must be set to zero
//
//  hComPropSheet   - Handle to the parent page which is the hComPropSheet
//                    passed to the CPSFUNC_ADD_PROPSHEETPAGE
//
//  hCPSUIPage      - Handle to the this added common UI property sheet page.
//
//  pfnComPropSheet - Pointer to the common UI callback function, using this
//                    function pointer to do CPSFUNC_xxxx
//
//

typedef struct _CPSUIDATABLOCK {
    DWORD   cbData;
    LPBYTE  pbData;
    } CPSUIDATABLOCK, *PCPSUIDATABLOCK;


#define APPLYCPSUI_NO_NEWDEF        0x00000001
#define APPLYCPSUI_OK_CANCEL_BUTTON 0x00000002

//
// PFNCOMPROPSHEET function descriptions
//
// For each function index, it passed a handle, a Function Index and two (2)
// long parameters, the 'hComPropSheet' handle passed must be the handle passed
// from common UI when common UI called the caller supplied function
//
// pfnPropSheetUI(pPropSheetUIData);
//
// Following are the description of each function index
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_HPROPSHEETPAGE
//
//      This function add a page to the hComPropSheet using handle to the
//      PROPSHEETPAGE
//
//
//  Parameters:
//
//      lParam1 - is a handle to the PROPSHEETPAGE that created by the caller
//                using CreatePropertySheetPage()
//
//      lParam2 - Not used, must be 0
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page, if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PROPSHEETPAGE
//
//      This function add a page to the hComPropSheet using PROPSHEETPAGE
//      data structure.
//
//
//  Parameters:
//
//      lParam1 - is a pointer to PROPSHEETPAGE data structure
//
//      lParam2 - Not used.
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page, if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PCOMPROPSHEETUI
//
//      This function add propety page(s) to the hComPropSheet handle using
//      COMPROPSHEETUI data structure.
//
//
//  Parameters:
//
//      lParam1 - is a pointer to COMPROPSHEETUI data structure
//
//      lParam2 - pointer to a 32-bit location that received the total pages
//                added by the COMPROPSHEETUI data structure if sucessful else
//                it contains the ERR_CPSUI_xxx error codes.
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page(s), if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PFNPROPSHEETUI
//
//      This function add property page(s) to the hChild handle using
//      lParam1 as PFNPROPSHEETUI function pointer and lParam2 as the function
//      parameter.   The common UI call supplied function as following
//
//          PROPSHEETUI_INFO    PSUIInfo;
//
//          PSUIInfo.cbSize          = sizeof(PROPSHEETUI_INFO);
//          PSUIInfo.Version         = PROPSHEETUI_INFO_VERSION;
//          PSUIInfo.Flags           = (Ansi) ? 0: PSUIINFO_UNICODE;
//          PSUIInfo.Reason          = PROPSHEETUI_REASON_INIT;
//          PSUIInfo.hComPropSheet   = hComPropSheet;
//          PSUIInfo.pfnComPropSheet = ComPropSheetUICallBack;
//          PSUIInfo.lParamInit      = lParam2;
//          PSUIInfo.UserData        = 0;
//          PSUIInfo.Result          = 0;
//
//          ((PFNPROPSHEETUI)lParam1)(&PSUIInfo, lParam2);
//
//
//          If the pfnPropSheetUI() need to add/delete any common UI pages then
//          it must use hComPropSheet as its handle when calling the
//          ComPropSheetUICallBack().
//
//
//  Parameters:
//
//      lParam1 - a PFNPROPSHEETUI function pointer.
//
//      lParam2 - a 32-bit data that will be used as lParam when calling
//                PFNPROPSHEETUI function pointer.
//
//
//  Return Value:
//
//      The return value is the newly added property pages function handle, if
//      return value is NULL then function failed or no page is added.
//
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_DELETE_HCOMPROPSHEET
//
//      This function delete child property page(s) from hComPropSheet parent
//      using the child handle passed.
//
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that to be deleted.
//                This handle must be the handle returned from CPSFUNC_ADD_xxx
//                functions.
//
//      lParam2 - not used, must be 0
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_PAGECOUNT
//
//      This function return total property sheet pages belongs to a common
//      UI property sheet page handle hComPropSheet
//
//
//  Parameters:
//
//      lParam1 - not used, must be 0
//
//      lParam2 - not used, must be 0.
//
//
//  Return Value:
//
//      The return value is total page count if function sucessful or zero if
//      function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_RESULT
//
//      This function set the result of property sheet page to its owner that
//      added this page by CPSFUNC_ADD_xxx function indices
//
//  Parameters:
//
//      lParam1 - Handle to the common UI property sheet page that setting the
//                result.  If this handle is NULL then it is treated as
//                equal to the hComPropSheet.
//
//      lParam2 - a 32-bit DWORD result to be set.
//
//
//  Return Value:
//
//      > 0: Successful, return value is total count of parents set the result
//      = 0: There is no owner or parent for the lParam1 handle.
//      < 0: function failed because of invalid lParam1 handle.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_HSTARTPAGE
//
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that to be set
//                as initial page that appear when the property sheet dialog
//                boxes is created.  This handle must be the handle returned
//                from CPSFUNC_ADD_xxx functions.
//
//                If lParam1 is NULL then lParam2 is a string pointer to the
//                page name (tab) that to be set for the start page
//
//      lParam2 - a LONG number to specified the children index. if lParam1
//                handle is a parent then lParam2 specified zero base children
//                index for using as start page.
//
//                It also can be one of following special index
//
//                  SSP_TVPAGE
//
//                      set to the treeview page, this only valid if lParam1
//                      handle was added by the CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//                  SSP_STDPAGE
//
//                      Set to the standard document property sheet page
//                      (Page 1 user friendly page).  this only valid if
//                      lParam1 handle was added by the
//                      CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.  This function can only be
//      called when the property sheet is not display yet so the place to
//      call is during the PROPSHEETUI_REASON_GET_INFO_HEADER callback.
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_HPSUIPAGES
//
//      This function return array of children HPROPSHEETPAGE belongs to
//      the parent hComPropSheet UI property sheet page handle hComPropSheet
//
//
//  Parameters:
//
//      lParam1 - Pointer to an array of HPROPSHEETPAGE that to be stored
//                the handle upon return.
//
//      lParam2 - Count of HPROPSHEETPAGE array pointed by the lParam1
//
//
//  Return Value:
//
//      The return value is total HPROPSHEETPAGE stored in the array pointed
//      by the lParam1.   To get all hPropSheetPage for any common property
//      sheet handle's (hCPSUIPage) children, it can use following sequence.
//
//          if ((cPage = pfnComPropSheet(hComPropSheet,
//                                       CPSFUNC_GET_PAGECOUNT,
//                                       (LPARAM)hCPSUIPage,
//                                       0L))   &&
//              (phPage = ALLOCMEM(cPage * sizeof(HANDLE)))) {
//
//              pfnComPropSheet(hCPSUIPage,
//                              CPSFUNC_GET_HPSUIPAGES,
//                              (LPARAM)phPage,
//                              (LPARAM)cPage);
//          }
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_LOAD_CPSUI_STRING
//
//      This function load the common property sheet UI resource string
//
//  Parameters:
//
//      lParam1 - Pointer to LPTSTR string which will stored the loaded
//                resource string from the common property sheet UI DLL.
//
//      lParam2 - LOWORD(lParam2) = Count of characters (includes null
//                                  terminator) which pointed by the lParam1
//
//                HIWORD(lParam2) = Common property sheet UI predefined string
//                                  resource ID as IDS_CPSUI_xxxx
//
//
//  Return Value:
//
//      > 0: Total characters stored in the string pointed by the lParam1, this
//           is not includes the null terminator
//      = 0: Invalid IDS_CPSUI_xxx passed from HIWORD(lParam)
//      < 0: Either lParam1 is NULL or count of character is 0 from
//           LOWORD(lParam2)
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_LOAD_CPSUI_ICON
//
//      This function load the common property sheet UI resource icon.
//
//  Parameters:
//
//      lParam1 - Common property sheet UI predefined icon resource ID as
//                IDI_CPSUI_xxxx.
//
//      lParam2 - LOWORD(lParam2) = cx icon size in pixel.  If zero then
//                                  SM_CXICON is used
//                HIWORD(lParam2) = cy icon size in pixel.  If zero then
//                                  SM_CYICON is used
//
//
//  Return Value:
//
//      Return value is the handle to the hIcon if function succeed, a NULL
//      if function failed. The caller must call DestroyIcon() when it no
//      longer need to use the hIcon returned
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_PFNPROPSHEETUI_ICON
//
//      This function let the caller return hIcon of its children pages that
//      was added by CPSFUNC_ADD_PFNPROPSHEETUI
//
//  Parameters:
//
//      lParam1 - Handle of common property sheet pages that the hIcon will be
//                queried.  This handle must be the handle returned from
//                CPSFUNC_ADD_PFNPROPSHEETUI function.
//
//      lParam2 - LOWORD(lParam2) = cx icon size in pixel.  If zero then
//                                  SM_CXICON is used
//                HIWORD(lParam2) = cy icon size in pixel.  If zero then
//                                  SM_CYICON is used
//
//
//  Return Value:
//
//      Return value is the handle to the hIcon if function succeed, a NULL
//      if function failed. The caller must call DestroyIcon() when it no
//      longer need to use the hIcon returned
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_INSERT_PSUIPAGE
//
//      This function let the caller insert common property sheet pages at
//      set position.  The hComPropSheet must be the parent handle.
//
//  Parameters:
//
//      lParam1 - Handle of common property sheet pages that the page position
//                will be inserted.  This handle must be the handle returned
//                from previous CPSFUNC_ADD_xxx or CPSFUNC_INSERT_PSUIPAGE that
//                added or inserted using the hComPropSheet if the Mode field
//                in INSPSUIPAGE_INFO data structure is one of the follwing
//
//                  INSPSUIPAGE_MODE_BEFORE
//                  INSPSUIPAGE_MODE_AFTER      - Common UI page handle
//
//                  INSPSUIPAGE_MODE_INDEX      - the lParam1 is an zero based
//                                                child index.
//
//                  INSPSUIPAGE_MODE_FIRST_CHILD
//                  INSPSUIPAGE_MODE_LAST_CHILD - The lParam1 is ignonred.
//
//
//                If lParam1 is a valid common property sheet page handle then
//                it is  the child page handle of hComPropSheet that added by
//                CPSFUNC_ADD_xxx or inserted by CPSFUNC_INSERT_PSUIPAGE.
//
//      lParam2 - A pointer that points to INSERTPSUIPAGE_INFO data structure.
//                Fields must set according to the following.
//
//                  cbSize  - size of this structure
//
//                  Type    - Type of page(s) to be inserted.  It can be one
//                            of the following
//
//                      PSUIPAGEINSERT_GROUP_PARENT
//
//                          Insert a group parent that can be used to insert
//                          new pages under it.  This is typically used when
//                          a set of common UI pages must be group together and
//                          can be deleted later using a single group parent
//                          handle without individual deleting each page.
//
//                          This handle can be nested.  After this function
//                          returned the group parent handle, it can be used
//                          as hComPropSheet handle (first parameter in the
//                          common UI callback) as parent handle so insertion
//                          will be inserted at level below returned group
//                          parent handle.
//
//
//                      PSUIPAGEINSERT_PCOMPROPSHEETUI
//
//                          Insert pages using COMPROPSHEETUI data structure,
//                          dwData1 is a pointer to the COMPROPSHEETUI data
//                          structure.
//
//
//                      PSUIPAGEINSERT_PFNPROPSHEETUI
//
//                          Insert pages using PFNPROPSHEETUI function pointer.
//                          The dwData1 is a PFNPROPSHEETUI function pointer.
//                          The common UI will call this pfnPropSheetUI()
//                          function pointer with PROPSHEETUI_REASON_INIT to
//                          have it add pages.
//
//                          When common UI call pfnPropSheetUI() (dwData1) it
//                          also passed a 32-bit parameter from the dwData2
//                          field in INSERTPSUIPAGE_INFO data structure.
//
//
//                      PSUIPAGEINSERT_PROPSHEETPAGE
//
//                          Insert pages using PROPSHEETPAGE data structure.
//                          The dwData1 is a pointer to the PROPSHEETPAGE
//                          data structure.
//
//
//                      PSUIPAGEINSERT_HPROPSHEETPAGE
//
//                          Insert pages using HPROPSHEETPAGE handle.  The
//                          dwData1 is a PROPSHEETPAGE handle which was
//                          created by CreatePropertySheetPage().
//
//
//                      PSUIPAGEINSERT_DLL
//
//                          Insert pages from a dynnmaic link library.  The
//                          dwData1 is a pointer to a null terminated string
//                          that specified the dynamic link library file name.
//
//                          The dwData2 is a pointer to a null terminated ASCII
//                          string that specified the pfnPropSheetUI function
//                          name. (MUST BE ASCII STRING)
//
//                          Common UI will do a LoadLibrary((LPTSTR)dwData1),
//                          pfnPropSheetUI = GetProcAddress((LPTSTR)dwData2)
//                          then call the pfnPropSheetUI with a lParam from
//                          dwData3.  The called reason from common UI is
//                          set to PROPSHEETUI_REASON_INIT.
//
//                          Using this method insert pages will guaranteed that
//                          library will be unload correctly.
//
//
//                  Mode    - Insert Mode, it can be one of the following
//
//
//                      INSPSUIPAGE_MODE_BEFORE
//
//                          Insert pages before the common property sheet page
//                          handle specified by lParam1
//
//
//                      INSPSUIPAGE_MODE_AFTER
//
//                          Insert pages after the common property sheet page
//                          handle specified by lParam1
//
//
//                      INSPSUIPAGE_MODE_FIRST_CHILD
//
//                          Insert pages as the first child of hComPropSheet
//                          parent handle, the lParam1 is ignored
//
//
//                      INSPSUIPAGE_MODE_LAST_CHILD
//
//                          Insert pages as the last child of hComPropSheet
//                          parent handle, the lParam1 is ignored
//
//
//                      INSPSUIPAGE_MODE_INDEX
//
//                          Insert pages as a zero base child index of its
//                          parent handle specified by hComPropSheet.
//
//                          The lParam1 is the zero based index special handle
//                          that must generated by HINSPSUIPAGE_INDEX(Index)
//                          macro.   If the index is greater than or equal to
//                          the total count of children then it will treat the
//                          mode same as INSPSUIPAGE_MODE_LAST_CHILD
//
//
//                  dwData1
//                  dwData2
//                  dwData3 - 32-bit data associate with the 'Type' field
//                            as following
//
//
//                      PSUIPAGEINSERT_GROUP_PARENT
//
//                          dwData1 = Not used, must be 0
//                          dwData2 = Not used, must be 0
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PCOMPROPSHEETUI
//
//                          dwData1 = pointer to COMPORPSHEETUI data structure.
//                          dwData2 = at return if sucessful, it contains total
//                                    page added.  If failed, it contains the
//                                    ERR_CPSUI_xxx codes
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PFNPROPSHEETUI
//
//                          dwData1 = PFNPROPSHEETUI function pointer
//                          dwData2 = 32-bit parameter passed to pfnPropSheetUI
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PROPSHEETPAGE
//
//                          dwData1 = Pointer to PROPSHEETPAGE data structure.
//                          dwData2 = not used, must be 0
//                          dwData3 = not used, must be 0
//
//
//                      PSUIPAGEINSERT_HPROPSHEETPAGE
//
//                          dwData1 = Is the HPROPSHEETPAGE handle that created
//                                    by a call to CreatePropertySheetPage().
//                          dwData2 = not used, must be 0
//                          dwData3 = not used, must be 0
//
//
//                      PSUIPAGEINSERT_DLL
//
//                          dwData1 = Pointer to a null terminated dynamic link
//                                    library filename.
//                          dwData2 = Pointer to a null terminated function
//                                    name (PFNPROPSHEETUI) in the dynamin link
//                                    library.
//                          dwData3 = 32-bit parameter passed to pfnPropSheetUI
//                                    (PFNPROPSHEETUI) function from dwData2
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page(s), if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_PSUIPAGE_TITLE
//
//      This function let the caller set a new title for a particular common
//      UI page title (on the property sheet page tab)
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that title to be
//                set.  This handle must be the handle returned from following
//
//                  CPSFUNC_ADD_PROPSHEETPAGE
//                  CPSFUNC_ADD_HPROPSHEETPAGE
//                  CPSFUNC_INSERT_PSUIPAGE with type of
//                              PSUIPAGEINSERT_PROPSHEETPAGE or
//                              PSUIPAGEINSERT_HPROPSHEETPAGE
//
//      lParam2 - Pointer to a null terminated string for the new title
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
//      This function will returned 0 if the property sheet pages is not
//      currently displayed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_PSUIPAGE_ICON
//
//      This function let the caller set a new icon for a particular common
//      UI page icon (on the property sheet page tab)
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that icon to be
//                set.  This handle must be the handle returned from following
//
//                  CPSFUNC_ADD_PROPSHEETPAGE
//                  CPSFUNC_ADD_HPROPSHEETPAGE
//                  CPSFUNC_INSERT_PSUIPAGE with type of
//                              PSUIPAGEINSERT_PROPSHEETPAGE or
//                              PSUIPAGEINSERT_HPROPSHEETPAGE
//
//      lParam2 - Handle to Icon, this icon is best as 16x16 icon otherwise it
//                will be stretch to 16x16 (pixel).
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
//      This function will returned 0 if the property sheet pages is not
//      currently displayed.
//
//      After this function is successful set the icon, the caller can destroy
//      the hIcon using DestroyIcon() if the hIcon is created by CreateIcon().
//      If the hIcon (lParam2) passed is using LoadIcon() then it does not need
//      to destroy the icon.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_DATABLOCK
//
//      This function let the caller register a new data block so it can be
//      later query by other pages in the property sheet, this function should
//      call durning PSN_KILLACTIVE message
//
//  Parameters:
//
//      lParam1 - pointer CPSUIDATABLOCK structure which speicifed the buffer
//                and size for queried datablock identify by lParam2 to be set.
//
//      lParam2 - DWORD Identifier of data block to be set
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful which
//      indicate total bytes of data block registered.  If return value is less
//      or equal to zero then function failed and data block is not registered.
//
//      If lParam1 is NULL, (lParam1)->cbData or (lParam1)->pbbData is NULL
//      it return a -1 to indicate an error parameter passed.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_QUERY_DATABLOCK
//
//      This function let the caller query a registered data block so it can
//      used this data block to communicate between property sheet pages.
//      This function should call durning PSN_SETACTIVE message
//
//  Parameters:
//
//      lParam1 - pointer CPSUIDATABLOCK structure which speicifed the buffer
//                and size for queried datablock identify by lParam2
//
//      lParam2 - DWORD Identifier of data block to be queried
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful which
//      indicate total bytes of data block copied into the pointer pointed by
//      the lParam1.  If return value is less or equal to zero then function
//      failed and data block is not copied to diciate the spcified datablock
//      Identifier (lParam2) is not found.
//
//      If CPSUIDATABLOCK pointer (lParam1) is NULL, (lParam1)->cbData or
//      (lParam1)->pbData is NULL then return value is the total bytes required
//      to copy the specified datablock identifier, if return value is less or
//      equal to zero then it indicate the spcified datablock identifier is
//      not found.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_DMPUB_HIDEBITS
//
//      This function let the caller hide a set of predefined OPTITEMS in the
//      pages that was created using PSUIPAGEINSERT_PCOMPROPSHEETUI or
//      CPSFUNC_ADD_PCOMPROPSHEETUI with pDlgPage equal to
//      CPSUI_PDLGPAGE_DOCPROP or CPSUI_PDLGPAGE_ADVDOCPROP.
//
//      This function MUST called BEFORE the DOCPROP or ADVDOCPROP property
//      sheet pages are added using  PSUIPAGEINSERT_PCOMPROPSHEETUI or
//      CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//  Parameters:
//
//      lParam1 - prdefined bit array masks to specified which DOCPROP item to
//                be hidden.  Each DMPUB item bit can be generate using macro
//                MAKE_DMPUB_HIDEBIT() and all items can be OR together.
//
//      lParam2 - Not used, MUST be 0
//
//
//  Return Value:
//
//      The return value is equal to lParam1 if this function is called before
//      DOCPROP or ADVDOCPROP pages are added. Return value is zero if these
//      pages already added which means failure.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_IGNORE_CPSUI_PSN_APPLY
//
//      This function let caller control how CPSUI process PSN_APPLY messages
//      for pages added through CPSFUNC_ADD_PCOMPROPSHEETUI or
//      CPSFUNC_INSERT_PSUIPAGE with type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      If this function never called, the Default CPSUI behavior is to process
//      PSN_APPLY messages.
//
//  Parameters:
//
//      lParam1 - Handle to the page returned from pages added by using
//                CPSFUNC_ADD_PCOMPROPSHEETUI or CPSFUNC_INSERT_PSUIPAGE with
//                type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      lParam2 - A non-zero value indicate to IGNORE the PSN_APPLY messages
//                for pages handle of lParam1.
//
//                A zero value to have CPSUI nomally process (not ignored) the
//                PSN_APPLY messages for pages handle of lParam1.
//
//                WARNING: if a PSN_APPLY messages are ignored, the caller must
//                         simulate a PSN_APPLY using CPSFUNC_DO_APPLY_CPSUI
//                         function or all changes WILL NOT applied, this is
//                         true even user hit 'OK' button.
//
//  Return Value:
//
//      the return value is zero if function failed, or non-zero to indicate
//      the function is successful.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_DO_APPLY_CPSUI
//
//      This function let caller simulate an apply (PSN_APPLY) to the pages
//      which added through CPSFUNC_ADD_PCOMPROPSHEETUI or
//      CPSFUNC_INSERT_PSUIPAGE with type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//  Parameters:
//
//      lParam1 - Handle to the page returned from pages added by using
//                CPSFUNC_ADD_PCOMPROPSHEETUI or CPSFUNC_INSERT_PSUIPAGE with
//                type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      lParam2 - 32-bit flag to indicate how to do apply, currently only
//
//                  APPLYCPSUI_NO_NEWDEF
//
//                      The APPLYCPSUI_NO_NEWDEF bit specified that after the
//                      apply is done the undo buffer for all OPTITEMs still
//                      remain unchanged, this make next undo still possible.
//
//                      If APPLYCPSUI_NO_NEWDEF bit is clear then undo buffers
//                      are re-initialized after apply is done, the current
//                      changes for all OPTITEMs become the new undo default.
//
//
//                  APPLYCPSUI_OK_CANCEL_BUTTON
//
//                      If bit is set then it specified the apply is simulate
//                      a user hit 'Ok' or 'Cancel' button, if this bit is
//                      clear then it simulate a user hit 'Close' or 'Apply'
//                      button.  If caller getting a PSN_APPLY message, it can
//                      simulated using passed PSHNOTIFY (passed as lParam in
//                      WM_NOTIFY message) structure to determine how to set
//                      this bit as follow.
//
//                          if PSHNOTIFY.lParam == 0, then clear this bit
//                          otherwise set this bit.
//
//
//  Return Value:
//
//      the return value is less or equal to zero if it encounter an error and
//      apply failed (the active page will be switch to these pages).
//
//      If return value is greater than zero then changes were applied and
//      function sucessful.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_FUSION_CONTEXT
//
//      This function is used to set a fusion activation context for
//      the specified page.
//
//  Parameters:
//
//      lParam1 - handle to fusion context. compstui duplicates the handle 
//                prior attaching it to its internal structures, so the caller
//                is not bound to keep the handle around. we release the 
//                passed in context handle when the compstui handle is deleted.
//
//      lParam2 - not used
//
//  Return Value:
//
//      the return value is less or equal to zero if it encounter an error and/or
//      something failed (look up the last error for details).
//
//      If return value is greater than zero then the call was sucessful.
//
// -------------------------------------------------------------------------
//


#define PROPSHEETUI_REASON_INIT             0
#define PROPSHEETUI_REASON_GET_INFO_HEADER  1
#define PROPSHEETUI_REASON_DESTROY          2
#define PROPSHEETUI_REASON_SET_RESULT       3
#define PROPSHEETUI_REASON_GET_ICON         4
#define MAX_PROPSHEETUI_REASON_INDEX        4

#define PROPSHEETUI_INFO_VERSION            0x0100

#define PSUIINFO_UNICODE                    0x0001

typedef struct _PROPSHEETUI_INFO {
    WORD            cbSize;
    WORD            Version;
    WORD            Flags;
    WORD            Reason;
    HANDLE          hComPropSheet;
    PFNCOMPROPSHEET pfnComPropSheet;
    LPARAM          lParamInit;
    ULONG_PTR       UserData;
    ULONG_PTR       Result;
    } PROPSHEETUI_INFO, *PPROPSHEETUI_INFO;


//
// For the PROPSHEETUI_REASON_GET_ICON call which lParam is a pointer to
// PROPSHEETUI_GETICON_INFO
//

typedef struct _PROPSHEETUI_GETICON_INFO {
    WORD    cbSize;
    WORD    Flags;
    WORD    cxIcon;
    WORD    cyIcon;
    HICON   hIcon;
    } PROPSHEETUI_GETICON_INFO, *PPROPSHEETUI_GETICON_INFO;


typedef LONG (FAR *PFNPROPSHEETUI)(PPROPSHEETUI_INFO   pPSUIInfo,
                                   LPARAM              lParam);


//
// PFNPROPSHEETUI
//
//  This function is user defined function which will be called by the common
//  UI when a caller wish to include the executable property sheets.
//
//  pPSUIInfo   - Pointer to PROPSHEETUI_INFO below for description of
//                PROPSHEETUI_INFO.
//
//                If this pointer is NULL then this function is not called from
//                common UI, and lParam should be used to determined the
//                action and outcome of this funciton.
//
//  lParam      - A LPARAM intented for this funciton depends on the reason.
//                If pPSUIInfo is NULL then this function is not called from
//                common UI, the lParam is the parameter which agreed with
//                the caller.
//
//                if pPSUIInfo is not NULL then this function assume the call
//                is from the common UI.  lParam has following meanion depends
//                on the reason field.
//
//                PROPSHEETUI_REASON_INIT
//
//                  The lParam is either passed from CPSFUNC_ADD_PFNPROPSHEETUI
//                  callback function's second parameter (lParam2) or it is
//                  from CommonPropertySheetUI()'s lParam (seccond parameter)
//                  without any modification.
//
//                  The lParam MUST NOT be a variable or a pointer to memory
//                  block which resides on the caller function's stack, since
//                  after this function exit, the lParam will become invalid
//                  and can cause fatal system error.
//
//                  The lParam parameter is copied to the lParamInit field in
//                  PROPSHEETUI_INFO data structure.  The lParamInit field
//                  will be passed to all subsequent pfnPropSheetUI() calls
//                  without any modification.
//
//
//                PROPSHEETUI_REASON_GET_INFO_HEADER:
//
//                  lParam is a pointer to the PROPSHEETUI_INFO_HEADER data
//                  structure. this function must correctly fill this structure
//                  fields before it returned.
//
//
//                PROPSHEETUI_REASON_DESTROY
//
//                  lParam is zero to indicate the destroy is cause either by a
//                  caller calling CPSFUNC_DELETE_HCOMPROPSHEET or failed
//                  in caller's CPSFUNC_ADD_xxxx.
//
//                  lParam is non zero to indicate the destroy is cause by
//                  exiting from the property sheet user interface.
//
//
//                PROPSHEETUI_REASON_SET_RESULT
//
//                  lParam is a pointer to SETRESULT_INFO data structure.
//                  Fields in SETRESULT_INFO data structure is set to following
//
//                      hSetResult: Handle to the common UI property sheet
//                                  pages which added by the CPSFUNC_ADD_xxx
//                                  callback function indices.
//
//                          Result: The result from the hSetResult to be set.
//                                  When return greater than zero then Result
//                                  in this field is set to its parent.
//
//
//                PROPSHEETUI_REASON_GET_ICON
//
//                  lParam is a pointer to PROPSHEETUI_GETICON_INFO data
//                  structure.  Fields in PROPSHEETUI_GETICON_INFO data
//                  structure are set to following
//
//                      cxIcon = cx Icon size in pixel
//                      cyIcon = cy Icon size in pixel
//                      hIcon  = Initial to NULL, and this function must put
//                               the created icon handle in this field before
//                               returned.
//


//
// PROPSHEETUI_INFO
//
//  This structure is used when common UI calling the caller passed function
//  entry point PFNPROPSHEETUI, the pfnPropSheetUI() return a LONG to
//  indicate result of this function.
//
//  When the pfnPropSheetUI() returned, it must also put the required result
//  in the Result field, each PROPSHEETUI_REASON_xxx has different required
//  result as describe below.
//
//
//
//  cbSize          - sizeof this structure (PROPSHEETUI_INFO)
//
//  Version         - the PROPSHEETUI_INFO data structure version. Current
//                    version is set to PROPSHEETUI_INFO_VERSION
//
//  Flags           - One or more following is may be defined
//
//                      PSUIINFO_UNICODE
//
//                          The caller's executable was original compiled was
//                          intented using unicode.
//
//
//  Reason          - Following reasons are defined.
//
//                      PROPSHEETUI_REASON_INIT
//
//                          When first time the pfnPropSheetUI() called, this
//                          reason is used to have the function initialize
//                          itself and use the pfnComPropSheet() function
//                          pointer provided to add new pages to the
//                          hComPropSheet handle passed.   The UserData in this
//                          data structure is initially set equal to zero (0).
//
//                          * Return > 0 to indicate sucesful and <= 0 to
//                            indicate error.
//
//                      *NOTE*
//
//                          The lParam MUST NOT be a variable or a pointer to
//                          memory block which resides on the caller function's
//                          stack, since after this function exit, the lParam
//                          will become invalid and can cause fatal system
//                          error.
//
//                          If this function reason returned failed ( <= 0),
//                          this function (pfnPropSheetUI) will received a
//                          PROPSHEETUI_REASON_DESTROY function reason right
//                          after this function reason returned.
//
//
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//
//                          It is called after the PROPSHEETUI_REASON_INIT is
//                          successful returned.  This reason is used to asked
//                          the function fill in the PROPSHEETUI_INFO_HEADER
//                          for pop-up the property sheet dialog boxes.
//
//                          lParam in this reason is a pointer to the
//                          PROPSHEETUI_INFO_HEADER data structure, following
//                          fields are requrested to be filled in.
//
//                              Flags       - PSUIHDRF_xxx flags
//                              pTitle      - The property sheet title
//                              hWndParent  - handle to the parent of property
//                                            sheet pages.
//                              hInst       - Instance data handle for this
//                                            function.
//                              hIcon
//                              IconID      - Icon used on the title bar.
//
//                          * Return > 0 to indicate sucesful and pop-up the
//                            property sheet dialog boxes or returned <= 0 to
//                            indicate error (not property sheet UI appeared)
//
//
//                      PROPSHEETUI_REASON_DESTROY
//
//                          When the property sheet ready to dismissed or the
//                          caller is delete the common UI pages added by the
//                          pfnPropSheetUI(), the common UI will call this
//                          entry point to have it de-initialized itself and
//                          free up all the memory used for this function
//                          instance.  The UserData field passed is the
//                          'UserData' field which returned from previous
//                          PROPSHEETUI_REASON_xxxx.
//
//                          When this function called, all hComPropSheet's
//                          children are desotroyed and children's common UI
//                          handles are not longer valid.
//
//                          * Return > 0 to indicate sucesful and <= 0 to
//                            indicate error.
//
//
//                      PROPSHEETUI_REASON_SET_RESULT
//
//                          The reason is used when an added handle from
//                          CPSFUNC_ADD_xxxx whant to return the result to
//                          this pfnPropSheetUI() caller.
//
//                          The lParam in second parameter is a pointer to a
//                          SETRESULT_INFO data structure.
//
//                              hSetResult: specified the common UI property
//                                          sheet page handle which added by
//                                          this function using
//                                          CPSFUNC_ADD_xxx indicies.
//
//                                  Result: Specified the Result to be set to
//                                          this pfnPropSheetUI() form the
//                                          hSetResult property sheet page
//                                          handle. If return value is greater
//                                          than zero then the value in this
//                                          Result field will be set to its
//                                          parent if one exist, at this case
//                                          this function can alter the Result
//                                          field value for its parent.
//
//                          * Returned greater than zero to continue send to
//                            its parent, else it stop sending the Result filed
//                            value to its parent.
//
//
//                      PROPSHEETUI_REASON_GET_ICON
//
//                          The reason is used to retrived the Icon which
//                          represent this pfnPropSheetUI().
//
//                          lParam is a pointer to PROPSHEETUI_GETICON_INFO '
//                          data structure.  Fields in PROPSHEETUI_GETICON_INFO
//                          data structure are set to following
//
//                              cxIcon = cx Icon size in pixel
//                              cyIcon = cy Icon size in pixel
//                              hIcon  = Initial to NULL, and this function
//                                       must put the created icon handle in
//                                       this field before return.
//
//
//                          * Return > 0 to indicate sucesful (hIcon is the
//                            requested icon handle).   Return = 0 to indicate
//                            no icon available, or return < 0 to indicate an
//                            error.
//
//              *NOTE*
//
//                  * For all PROPSHEETUI_REASON_xxx, the function can set new
//                    user defined DWORD data in the PROPSHEETUI_INFO data
//                    structure's UserData field.
//
//                  * For all PROPSHEETUI_REASON_xxx, the function can set new
//                    pfnPropSheetUI() DWORD result in PROPSHEETUI_INFO data
//                    structure's Result field.
//
//
//  hComPropSheet   - Handle to the COMPROPSHEETPAGE which this function should
//                    used as hComPropSheet parameter when calling
//                    pfnComPropSheet() to add or delete common UI property
//                    sheet pages.  The hComPropSheet is the instance handle to
//                    pfnPropSheetUI() function.
//
//  pfnComPropSheet - Pointer to the common UI callback function which for the
//                    pfnPropSheetUI() to add, delete, set user data, for a
//                    completed set of callback, see CPSFUNC_xxx descriptions
//                    above.
//
//  lParamInit      - The lParam originally passed duning the the first call
//                    reason PROPSHEETUI_REASON_INIT.  The lParamInit will be
//                    passed to each PROPSHEETUI_REASON_xxx calls.
//
//  UserData        - the UserData field is an IN and OUT parameter for each
//                    of the Reason,
//
//                      PROPSHEETUI_REASON_INIT
//
//                           IN: Initial set to zero (0).
//
//                          OUT: Specified new callee's own user data which
//                               will be passed back to other reason calls.
//
//
//                      PROPSHEETUI_REASON_DESTROY
//                      PROPSHEETUI_REASON_SET_RESULT
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//
//                           IN: The UserData specified at time when returned
//                               from the previous PROPSHEETUI_REASON_xxx
//
//                          OUT: Specified new callee's own user data which
//                               will be passed back to other reason calls.
//
//
// Result           - The Result field is an IN and OUT parameter for each of
//                    the reason.
//
//                      PROPSHEETUI_REASON_INIT
//
//                           IN: Set to zero (0).
//
//                          OUT: Set to default result of this PropSheetUI()
//                               function.
//
//
//                      PROPSHEETUI_REASON_DESTROY
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//                      PROPSHEETUI_REASON_SET_RESULT
//
//                           IN: The current 'Result' returned from previous
//                               PROPSHEETUI_REASON_xxx function.
//
//                          OUT: Set the new result of this PropSheetUI()
//                               function.
//
//


#define PSUIHDRF_OBSOLETE       0x0001
#define PSUIHDRF_NOAPPLYNOW     0x0002
#define PSUIHDRF_PROPTITLE      0x0004
#define PSUIHDRF_USEHICON       0x0008
#define PSUIHDRF_DEFTITLE       0x0010
#define PSUIHDRF_EXACT_PTITLE   0x0020

typedef struct _PROPSHEETUI_INFO_HEADER {
    WORD                    cbSize;
    WORD                    Flags;
    LPTSTR                  pTitle;
    HWND                    hWndParent;
    HINSTANCE               hInst;
    union {
        HICON               hIcon;
        ULONG_PTR           IconID;
        } DUMMYUNIONNAME;
    } PROPSHEETUI_INFO_HEADER, *PPROPSHEETUI_INFO_HEADER;

//
// PROPSHEETUI_INFO_HEADER
//
//  This data structure is used when common UI ready to pop-up the property
//  sheet page dialog boxes and it asked caller to provide more information.
//
//  Common property sheet UI passed this data structure as lParam when it call
//  provided pfnPropSheetUI() with PROPSHEETUI_REASON_GET_INFO_HEADER reason.
//
//
//  cbSize      - size of this structure
//
//  Flags       - PSUIHDRF_xxxx flags
//
//                  PSUIHDRF_OBSOLETE
//
//                      Not used, must not set this bit
//
//
//                  PSUIHDRF_NOAPPLYNOW
//
//                      Remove 'Apply Now' button.
//
//
//                  PSUIHDRF_PROPTITLE
//
//                      Automatically include 'Properties' in the title bar
//
//
//                  PSUIHDRF_USEHICON
//
//                      If this bit is specified then hIcon union field is
//                      a valid handle to the icon otherwise the IconID is
//                      the either caller's resource ID or common UI standard
//                      icon ID.
//
//                  PSUIHDRF_DEFTITLE
//
//                      Automatically include 'Default' in the title bar, the
//                      'Default' always added right after pTitle and before
//                      'Properties' if PSUIHDRF_PROPTITLE flag is set.
//
//                  PSUIHDRF_EXACT_PTITLE
//
//                      This flag indicate the pTitle set in this structure
//                      will be use without any modification by the compstui
//                      ie. compstui will not modified pTitle in any way and
//                      it will ignored PSUIHDRF_PROPTITLE, PSUIHDRF_DEFTITLE
//
//
//  pTitle      - Pointer to the NULL terminated caption name for the
//                property sheets.
//
//                  ** See LPTSTR typedef description above
//
//  hWndParent  - The handle of the window which will be parent of the common
//                UI property sheets, if NULL then current active window for
//                the calling thread is used.
//
//  hInst       - the caller's handle to its instance.  Commom UI use this
//                handle to load caller's icon and other resources.
//
//  hIcon
//  IconID      - Specified the icon which put on the title bar, it either a
//                handle to the icon or a icon resource ID depends on the
//                PSUIHDRF_USEHICON flag.
//



//
// LONG
// CommonPropertySheetUI(
//     HWND            hWndOwner,
//     PFNPROPSHEETUI  pfnPropSheetUI,
//     LPARAM          lParam,
//     LPDWORD         pResult
//     );
//
//
// The CommonPropSheetUI is the main entry point for the common property sheet
// user interface.   The original caller that wish to using common UI to pop-up
// property sheet will call this function and passed its own PFNPROPSHEETUI
// function address and a long parameter.
//
// If pfnPropSheetUI function return a LONG number greater than zero (0) then
// common UI will pop-up the property sheet page dialog boxes, when Property
// sheet pages is finished. (either hit Ok or Cancel) it will return the
// result of CPSUI_xxxx back to the caller.
//
// If pfnPropSheetUI function return a LONG number equal or less than zero (0)
// then it will return the CPSUI_CANCEL back to caller without pop-up the
// property sheet page dialog boxes.
//
//
//  Parameters:
//
//      hWndOwner       - Window handle for the owner of this proerty sheet
//                        pages dialog boxes.
//
//      pfnPropSheetUI  - a PFNPROPSHEETUI function pointer which is used by
//                        the caller to add its property sheet pages.
//
//      lParam          - a long parameter will be passed to the pfnPropSheetUI
//                        funciton.  The common UI called the pfnPropSheetUI as
//
//                          PROPSHEETUI_INFO    PSUIInfo;
//
//                          pfnPropSheetUI(&PSUIInfo, lParam);
//
//                        The caller must use pfnComPropSheet() to add/delete
//                        pages.  When it is done adding pages, it retuned
//                        greater than zero to indicate successful, and return
//                        less or equal to zero to indicate failure.
//
//      pResult         - a pointer to DWORD which received the final result
//                        of pfnPropSheetUI() funciton, this result is a copy
//                        from Result field of PROPSHEETUI_INFO data structure
//                        which passed to the pfnPropSheetUI() as the first
//                        parameter.  The pResult only will be set if the
//                        returned value from CommonPropertySheetUI() is not
//                        ERR_CPSUI_xxx.
//
//                        if pResult is NULL then common UI will not return
//                        pfnPropSheetUI()'s result back.
//
//
//  Return Value:
//
//      LONG    - < 0                   - property page does not displayed and
//                                        ERR_CPSUI_xxx is the error code
//                CPSUI_OK              - property page displayed.
//                CPSUI_RESTARTWINDOWS  - property page displayed and need to
//                                        restart window to take effect
//                CPSUI_REBOOTSYSTEM    - property page dispalyed and need
//                                        to reboot system to take effect
//
//


LONG
APIENTRY
CommonPropertySheetUIA(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );

LONG
APIENTRY
CommonPropertySheetUIW(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );


#ifdef UNICODE
#define CommonPropertySheetUI   CommonPropertySheetUIW
#else
#define CommonPropertySheetUI   CommonPropertySheetUIA
#endif



//
// GetCPSUIUserData() and SetCPSUIUserData() is used for the pages added
// by the CPSFUNC_ADD_PCOMPROPSHEETUI.  The caller add this function and has
// sub class dialog procedure should not set DWLP_USERDATA but calling these
// function instead, otherwise the system can failed.
//

ULONG_PTR
APIENTRY
GetCPSUIUserData(
    HWND    hDlg
    );

BOOL
APIENTRY
SetCPSUIUserData(
    HWND        hDlg,
    ULONG_PTR   CPSUIUserData
    );


#define CPSUI_CANCEL                        0
#define CPSUI_OK                            1
#define CPSUI_RESTARTWINDOWS                2
#define CPSUI_REBOOTSYSTEM                  3

#define ERR_CPSUI_GETLASTERROR              -1
#define ERR_CPSUI_ALLOCMEM_FAILED           -2
#define ERR_CPSUI_INVALID_PDATA             -3
#define ERR_CPSUI_INVALID_LPARAM            -4
#define ERR_CPSUI_NULL_HINST                -5
#define ERR_CPSUI_NULL_CALLERNAME           -6
#define ERR_CPSUI_NULL_OPTITEMNAME          -7
#define ERR_CPSUI_NO_PROPSHEETPAGE          -8
#define ERR_CPSUI_TOO_MANY_PROPSHEETPAGES   -9
#define ERR_CPSUI_CREATEPROPPAGE_FAILED     -10
#define ERR_CPSUI_MORE_THAN_ONE_TVPAGE      -11
#define ERR_CPSUI_MORE_THAN_ONE_STDPAGE     -12
#define ERR_CPSUI_INVALID_PDLGPAGE          -13
#define ERR_CPSUI_INVALID_DLGPAGE_CBSIZE    -14
#define ERR_CPSUI_TOO_MANY_DLGPAGES         -15
#define ERR_CPSUI_INVALID_DLGPAGEIDX        -16
#define ERR_CPSUI_SUBITEM_DIFF_DLGPAGEIDX   -17
#define ERR_CPSUI_NULL_POPTITEM             -18
#define ERR_CPSUI_INVALID_OPTITEM_CBSIZE    -19
#define ERR_CPSUI_INVALID_OPTTYPE_CBSIZE    -20
#define ERR_CPSUI_INVALID_OPTTYPE_COUNT     -21
#define ERR_CPSUI_NULL_POPTPARAM            -22
#define ERR_CPSUI_INVALID_OPTPARAM_CBSIZE   -23
#define ERR_CPSUI_INVALID_EDITBOX_PSEL      -24
#define ERR_CPSUI_INVALID_EDITBOX_BUF_SIZE  -25
#define ERR_CPSUI_INVALID_ECB_CBSIZE        -26
#define ERR_CPSUI_NULL_ECB_PTITLE           -27
#define ERR_CPSUI_NULL_ECB_PCHECKEDNAME     -28
#define ERR_CPSUI_INVALID_DMPUBID           -29
#define ERR_CPSUI_INVALID_DMPUB_TVOT        -30
#define ERR_CPSUI_CREATE_TRACKBAR_FAILED    -31
#define ERR_CPSUI_CREATE_UDARROW_FAILED     -32
#define ERR_CPSUI_CREATE_IMAGELIST_FAILED   -33
#define ERR_CPSUI_INVALID_TVOT_TYPE         -34
#define ERR_CPSUI_INVALID_LBCB_TYPE         -35
#define ERR_CPSUI_SUBITEM_DIFF_OPTIF_HIDE   -36
#define ERR_CPSUI_INVALID_PUSHBUTTON_TYPE   -38
#define ERR_CPSUI_INVALID_EXTPUSH_CBSIZE    -39
#define ERR_CPSUI_NULL_EXTPUSH_DLGPROC      -40
#define ERR_CPSUI_NO_EXTPUSH_DLGTEMPLATEID  -41
#define ERR_CPSUI_NULL_EXTPUSH_CALLBACK     -42
#define ERR_CPSUI_DMCOPIES_USE_EXTPUSH      -43
#define ERR_CPSUI_ZERO_OPTITEM              -44


#define ERR_CPSUI_FUNCTION_NOT_IMPLEMENTED  -9999
#define ERR_CPSUI_INTERNAL_ERROR            -10000

#endif  // (!defined(RC_INVOKED))



//
//****************************************************************************
//*                                                                          *
//*      Common Property Sheet UI resource ID for the ICONs and STRINGs      *
//*                                                                          *
//* The Resource ID from 64000 to 65535 are reserved for common UI and must  *
//* not used as caller resource ID else the string, icon loading will not be *
//* correct.                                                                 *
//*                                                                          *
//****************************************************************************
//


//
// Common UI standard 32x32, 16x16 color and monochrome Icon IDs
//

#define IDI_CPSUI_ICONID_FIRST          64000

#define IDI_CPSUI_EMPTY                 64000
#define IDI_CPSUI_SEL_NONE              64001
#define IDI_CPSUI_WARNING               64002
#define IDI_CPSUI_NO                    64003
#define IDI_CPSUI_YES                   64004
#define IDI_CPSUI_FALSE                 64005
#define IDI_CPSUI_TRUE                  64006
#define IDI_CPSUI_OFF                   64007
#define IDI_CPSUI_ON                    64008
#define IDI_CPSUI_PAPER_OUTPUT          64009
#define IDI_CPSUI_ENVELOPE              64010
#define IDI_CPSUI_MEM                   64011
#define IDI_CPSUI_FONTCARTHDR           64012
#define IDI_CPSUI_FONTCART              64013
#define IDI_CPSUI_STAPLER_ON            64014
#define IDI_CPSUI_STAPLER_OFF           64015
#define IDI_CPSUI_HT_HOST               64016
#define IDI_CPSUI_HT_DEVICE             64017
#define IDI_CPSUI_TT_PRINTASGRAPHIC     64018
#define IDI_CPSUI_TT_DOWNLOADSOFT       64019
#define IDI_CPSUI_TT_DOWNLOADVECT       64020
#define IDI_CPSUI_TT_SUBDEV             64021
#define IDI_CPSUI_PORTRAIT              64022
#define IDI_CPSUI_LANDSCAPE             64023
#define IDI_CPSUI_ROT_LAND              64024
#define IDI_CPSUI_AUTOSEL               64025
#define IDI_CPSUI_PAPER_TRAY            64026
#define IDI_CPSUI_PAPER_TRAY2           64027
#define IDI_CPSUI_PAPER_TRAY3           64028
#define IDI_CPSUI_TRANSPARENT           64029
#define IDI_CPSUI_COLLATE               64030
#define IDI_CPSUI_DUPLEX_NONE           64031
#define IDI_CPSUI_DUPLEX_HORZ           64032
#define IDI_CPSUI_DUPLEX_VERT           64033
#define IDI_CPSUI_RES_DRAFT             64034
#define IDI_CPSUI_RES_LOW               64035
#define IDI_CPSUI_RES_MEDIUM            64036
#define IDI_CPSUI_RES_HIGH              64037
#define IDI_CPSUI_RES_PRESENTATION      64038
#define IDI_CPSUI_MONO                  64039
#define IDI_CPSUI_COLOR                 64040
#define IDI_CPSUI_DITHER_NONE           64041
#define IDI_CPSUI_DITHER_COARSE         64042
#define IDI_CPSUI_DITHER_FINE           64043
#define IDI_CPSUI_DITHER_LINEART        64044
#define IDI_CPSUI_SCALING               64045
#define IDI_CPSUI_COPY                  64046
#define IDI_CPSUI_HTCLRADJ              64047
#define IDI_CPSUI_HALFTONE_SETUP        64048
#define IDI_CPSUI_WATERMARK             64049
#define IDI_CPSUI_ERROR                 64050
#define IDI_CPSUI_ICM_OPTION            64051
#define IDI_CPSUI_ICM_METHOD            64052
#define IDI_CPSUI_ICM_INTENT            64053
#define IDI_CPSUI_STD_FORM              64054
#define IDI_CPSUI_OUTBIN                64055
#define IDI_CPSUI_OUTPUT                64056
#define IDI_CPSUI_GRAPHIC               64057
#define IDI_CPSUI_ADVANCE               64058
#define IDI_CPSUI_DOCUMENT              64059
#define IDI_CPSUI_DEVICE                64060
#define IDI_CPSUI_DEVICE2               64061
#define IDI_CPSUI_PRINTER               64062
#define IDI_CPSUI_PRINTER2              64063
#define IDI_CPSUI_PRINTER3              64064
#define IDI_CPSUI_PRINTER4              64065
#define IDI_CPSUI_OPTION                64066
#define IDI_CPSUI_OPTION2               64067
#define IDI_CPSUI_STOP                  64068
#define IDI_CPSUI_NOTINSTALLED          64069
#define IDI_CPSUI_WARNING_OVERLAY       64070
#define IDI_CPSUI_STOP_WARNING_OVERLAY  64071
#define IDI_CPSUI_GENERIC_OPTION        64072
#define IDI_CPSUI_GENERIC_ITEM          64073
#define IDI_CPSUI_RUN_DIALOG            64074
#define IDI_CPSUI_QUESTION              64075
#define IDI_CPSUI_FORMTRAYASSIGN        64076
#define IDI_CPSUI_PRINTER_FOLDER        64077
#define IDI_CPSUI_INSTALLABLE_OPTION    64078
#define IDI_CPSUI_PRINTER_FEATURE       64079
#define IDI_CPSUI_DEVICE_FEATURE        64080
#define IDI_CPSUI_FONTSUB               64081
#define IDI_CPSUI_POSTSCRIPT            64082
#define IDI_CPSUI_TELEPHONE             64083
#define IDI_CPSUI_DUPLEX_NONE_L         64084
#define IDI_CPSUI_DUPLEX_HORZ_L         64085
#define IDI_CPSUI_DUPLEX_VERT_L         64086
#define IDI_CPSUI_LF_PEN_PLOTTER        64087
#define IDI_CPSUI_SF_PEN_PLOTTER        64088
#define IDI_CPSUI_LF_RASTER_PLOTTER     64089
#define IDI_CPSUI_SF_RASTER_PLOTTER     64090
#define IDI_CPSUI_ROLL_PAPER            64091
#define IDI_CPSUI_PEN_CARROUSEL         64092
#define IDI_CPSUI_PLOTTER_PEN           64093
#define IDI_CPSUI_MANUAL_FEED           64094
#define IDI_CPSUI_FAX                   64095
#define IDI_CPSUI_PAGE_PROTECT          64096
#define IDI_CPSUI_ENVELOPE_FEED         64097
#define IDI_CPSUI_FONTCART_SLOT         64098
#define IDI_CPSUI_LAYOUT_BMP_PORTRAIT   64099
#define IDI_CPSUI_LAYOUT_BMP_ARROWL     64100
#define IDI_CPSUI_LAYOUT_BMP_ARROWS     64101
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETL   64102
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETP   64103
#define IDI_CPSUI_ICONID_LAST           64103

//
// Common UI standard String IDs
//


#define IDS_CPSUI_STRID_FIRST           64700

#define IDS_CPSUI_SETUP                 64700
#define IDS_CPSUI_MORE                  64701
#define IDS_CPSUI_CHANGE                64702
#define IDS_CPSUI_OPTION                64703
#define IDS_CPSUI_OF                    64704
#define IDS_CPSUI_RANGE_FROM            64705
#define IDS_CPSUI_TO                    64706
#define IDS_CPSUI_COLON_SEP             64707
#define IDS_CPSUI_LEFT_ANGLE            64708
#define IDS_CPSUI_RIGHT_ANGLE           64709
#define IDS_CPSUI_SLASH_SEP             64710
#define IDS_CPSUI_PERCENT               64711
#define IDS_CPSUI_LBCB_NOSEL            64712
#define IDS_CPSUI_PROPERTIES            64713
#define IDS_CPSUI_DEFAULTDOCUMENT       64714
#define IDS_CPSUI_DOCUMENT              64715
#define IDS_CPSUI_ADVANCEDOCUMENT       64716
#define IDS_CPSUI_PRINTER               64717
#define IDS_CPSUI_AUTOSELECT            64718
#define IDS_CPSUI_PAPER_OUTPUT          64719
#define IDS_CPSUI_GRAPHIC               64720
#define IDS_CPSUI_OPTIONS               64721
#define IDS_CPSUI_ADVANCED              64722
#define IDS_CPSUI_STDDOCPROPTAB         64723
#define IDS_CPSUI_STDDOCPROPTVTAB       64724
#define IDS_CPSUI_DEVICEOPTIONS         64725
#define IDS_CPSUI_FALSE                 64726
#define IDS_CPSUI_TRUE                  64727
#define IDS_CPSUI_NO                    64728
#define IDS_CPSUI_YES                   64729
#define IDS_CPSUI_OFF                   64730
#define IDS_CPSUI_ON                    64731
#define IDS_CPSUI_DEFAULT               64732
#define IDS_CPSUI_ERROR                 64733
#define IDS_CPSUI_NONE                  64734
#define IDS_CPSUI_NOT                   64735
#define IDS_CPSUI_EXIST                 64736
#define IDS_CPSUI_NOTINSTALLED          64737
#define IDS_CPSUI_ORIENTATION           64738
#define IDS_CPSUI_SCALING               64739
#define IDS_CPSUI_NUM_OF_COPIES         64740
#define IDS_CPSUI_SOURCE                64741
#define IDS_CPSUI_PRINTQUALITY          64742
#define IDS_CPSUI_RESOLUTION            64743
#define IDS_CPSUI_COLOR_APPERANCE       64744
#define IDS_CPSUI_DUPLEX                64745
#define IDS_CPSUI_TTOPTION              64746
#define IDS_CPSUI_FORMNAME              64747
#define IDS_CPSUI_ICM                   64748
#define IDS_CPSUI_ICMMETHOD             64749
#define IDS_CPSUI_ICMINTENT             64750
#define IDS_CPSUI_MEDIA                 64751
#define IDS_CPSUI_DITHERING             64752
#define IDS_CPSUI_PORTRAIT              64753
#define IDS_CPSUI_LANDSCAPE             64754
#define IDS_CPSUI_ROT_LAND              64755
#define IDS_CPSUI_COLLATE               64756
#define IDS_CPSUI_COLLATED              64757
#define IDS_CPSUI_PRINTFLDSETTING       64758
#define IDS_CPSUI_DRAFT                 64759
#define IDS_CPSUI_LOW                   64760
#define IDS_CPSUI_MEDIUM                64761
#define IDS_CPSUI_HIGH                  64762
#define IDS_CPSUI_PRESENTATION          64763
#define IDS_CPSUI_COLOR                 64764
#define IDS_CPSUI_GRAYSCALE             64765
#define IDS_CPSUI_MONOCHROME            64766
#define IDS_CPSUI_SIMPLEX               64767
#define IDS_CPSUI_HORIZONTAL            64768
#define IDS_CPSUI_VERTICAL              64769
#define IDS_CPSUI_LONG_SIDE             64770
#define IDS_CPSUI_SHORT_SIDE            64771
#define IDS_CPSUI_TT_PRINTASGRAPHIC     64772
#define IDS_CPSUI_TT_DOWNLOADSOFT       64773
#define IDS_CPSUI_TT_DOWNLOADVECT       64774
#define IDS_CPSUI_TT_SUBDEV             64775
#define IDS_CPSUI_ICM_BLACKWHITE        64776
#define IDS_CPSUI_ICM_NO                64777
#define IDS_CPSUI_ICM_YES               64778
#define IDS_CPSUI_ICM_SATURATION        64779
#define IDS_CPSUI_ICM_CONTRAST          64780
#define IDS_CPSUI_ICM_COLORMETRIC       64781
#define IDS_CPSUI_STANDARD              64782
#define IDS_CPSUI_GLOSSY                64783
#define IDS_CPSUI_TRANSPARENCY          64784
#define IDS_CPSUI_REGULAR               64785
#define IDS_CPSUI_BOND                  64786
#define IDS_CPSUI_COARSE                64787
#define IDS_CPSUI_FINE                  64788
#define IDS_CPSUI_LINEART               64789
#define IDS_CPSUI_ERRDIFFUSE            64790
#define IDS_CPSUI_HALFTONE              64791
#define IDS_CPSUI_HTCLRADJ              64792
#define IDS_CPSUI_USE_HOST_HT           64793
#define IDS_CPSUI_USE_DEVICE_HT         64794
#define IDS_CPSUI_USE_PRINTER_HT        64795
#define IDS_CPSUI_OUTBINASSIGN          64796
#define IDS_CPSUI_WATERMARK             64797
#define IDS_CPSUI_FORMTRAYASSIGN        64798
#define IDS_CPSUI_UPPER_TRAY            64799
#define IDS_CPSUI_ONLYONE               64800
#define IDS_CPSUI_LOWER_TRAY            64801
#define IDS_CPSUI_MIDDLE_TRAY           64802
#define IDS_CPSUI_MANUAL_TRAY           64803
#define IDS_CPSUI_ENVELOPE_TRAY         64804
#define IDS_CPSUI_ENVMANUAL_TRAY        64805
#define IDS_CPSUI_TRACTOR_TRAY          64806
#define IDS_CPSUI_SMALLFMT_TRAY         64807
#define IDS_CPSUI_LARGEFMT_TRAY         64808
#define IDS_CPSUI_LARGECAP_TRAY         64809
#define IDS_CPSUI_CASSETTE_TRAY         64810
#define IDS_CPSUI_DEFAULT_TRAY          64811
#define IDS_CPSUI_FORMSOURCE            64812
#define IDS_CPSUI_MANUALFEED            64813
#define IDS_CPSUI_PRINTERMEM_KB         64814
#define IDS_CPSUI_PRINTERMEM_MB         64815
#define IDS_CPSUI_PAGEPROTECT           64816
#define IDS_CPSUI_HALFTONE_SETUP        64817
#define IDS_CPSUI_INSTFONTCART          64818
#define IDS_CPSUI_SLOT1                 64819
#define IDS_CPSUI_SLOT2                 64820
#define IDS_CPSUI_SLOT3                 64821
#define IDS_CPSUI_SLOT4                 64822
#define IDS_CPSUI_LEFT_SLOT             64823
#define IDS_CPSUI_RIGHT_SLOT            64824
#define IDS_CPSUI_STAPLER               64825
#define IDS_CPSUI_STAPLER_ON            64826
#define IDS_CPSUI_STAPLER_OFF           64827
#define IDS_CPSUI_STACKER               64828
#define IDS_CPSUI_MAILBOX               64829
#define IDS_CPSUI_COPY                  64830
#define IDS_CPSUI_COPIES                64831
#define IDS_CPSUI_TOTAL                 64832
#define IDS_CPSUI_MAKE                  64833
#define IDS_CPSUI_PRINT                 64834
#define IDS_CPSUI_FAX                   64835
#define IDS_CPSUI_PLOT                  64836
#define IDS_CPSUI_SLOW                  64837
#define IDS_CPSUI_FAST                  64838
#define IDS_CPSUI_ROTATED               64839
#define IDS_CPSUI_RESET                 64840
#define IDS_CPSUI_ALL                   64841
#define IDS_CPSUI_DEVICE                64842
#define IDS_CPSUI_SETTINGS              64843
#define IDS_CPSUI_REVERT                64844
#define IDS_CPSUI_CHANGES               64845
#define IDS_CPSUI_CHANGED               64846
#define IDS_CPSUI_WARNING               64847
#define IDS_CPSUI_ABOUT                 64848
#define IDS_CPSUI_VERSION               64849
#define IDS_CPSUI_NO_NAME               64850
#define IDS_CPSUI_SETTING               64851
#define IDS_CPSUI_DEVICE_SETTINGS       64852
#define IDS_CPSUI_STDDOCPROPTAB1        64853
#define IDS_CPSUI_STDDOCPROPTAB2        64854
#define IDS_CPSUI_PAGEORDER             64855
#define IDS_CPSUI_FRONTTOBACK           64856
#define IDS_CPSUI_BACKTOFRONT           64857
#define IDS_CPSUI_QUALITY_SETTINGS      64858
#define IDS_CPSUI_QUALITY_DRAFT         64859
#define IDS_CPSUI_QUALITY_BETTER        64860
#define IDS_CPSUI_QUALITY_BEST          64861
#define IDS_CPSUI_QUALITY_CUSTOM        64862
#define IDS_CPSUI_OUTPUTBIN             64863
#define IDS_CPSUI_NUP                   64864
#define IDS_CPSUI_NUP_NORMAL            64865
#define IDS_CPSUI_NUP_TWOUP             64866
#define IDS_CPSUI_NUP_FOURUP            64867
#define IDS_CPSUI_NUP_SIXUP             64868
#define IDS_CPSUI_NUP_NINEUP            64869
#define IDS_CPSUI_NUP_SIXTEENUP         64870
#define IDS_CPSUI_SIDE1                 64871
#define IDS_CPSUI_SIDE2                 64872
#define IDS_CPSUI_BOOKLET               64873

#define IDS_CPSUI_STRID_LAST            64873


#ifdef __cplusplus
}
#endif

#endif      // _COMPSTUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\spooler\wpnpinst\exe\globals.h ===
/*----------------------------------------------------------------------------*\
| MODULE: globals.h
|
|   Globals header file.
|
|   Copyright (C) 1997 Microsoft
|   Copyright (C) 1997 Hewlett Packard
|
| history:
|   26-Aug-1997 <rbkunz> Created.
|
\*----------------------------------------------------------------------------*/

extern HINSTANCE g_hInstance;

// Misc Character constants
//
extern CONST TCHAR g_chBackslash;
extern CONST TCHAR g_chDot;
extern CONST TCHAR g_chDoubleQuote;

// Misc String Constants
//
extern CONST TCHAR g_szDotEXE[];
extern CONST TCHAR g_szDotDLL[];
extern CONST TCHAR g_szFNFmt [];
extern CONST TCHAR g_szTNFmt [];


// Wide char parm string to pass to PrintUIEntryW
//
extern CONST WCHAR g_wszParmString[];


// Module and entry point constants
//
extern CONST TCHAR g_szPrintUIMod   [];
extern CONST CHAR  g_szPrintUIEntryW[];

// Error strings
//
extern LPTSTR g_szErrorFormat;
extern LPTSTR g_szError;
extern LPTSTR g_szEGeneric;
extern LPTSTR g_szEBadCAB;
extern LPTSTR g_szEInvalidParameter;
extern LPTSTR g_szENoMemory;
extern LPTSTR g_szEInvalidCABName;
extern LPTSTR g_szENoDATFile;
extern LPTSTR g_szECABExtract;
extern LPTSTR g_szEUserVerifyFail;
extern LPTSTR g_szENoPrintUI;
extern LPTSTR g_szENoPrintUIEntry;
extern LPTSTR g_szEPrintUIEntryFail;
extern LPTSTR g_szENotSupported;


// Error Return Codes
//
#define SUCCESS_EXITCODE            0xFFFFFFFF

#define ERR_NONE                    0x00000000
#define ERR_GENERIC                 0x80000000
#define ERR_AUTHENTICODE            0xC0000000

#define ERR_BAD_CAB                 0x80000001
#define ERR_INVALID_PARAMETER       0x80000002
#define ERR_NO_MEMORY               0x80000004
#define ERR_INVALID_CAB_NAME        0x80000008
#define ERR_NO_DAT_FILE             0x80000010
#define ERR_CAB_EXTRACT             0x80000020
#define ERR_NO_PRINTUI              0x80000040
#define ERR_NO_PRINTUIENTRY         0x80000080
#define ERR_PRINTUIENTRY_FAIL       0x80000100
#define ERR_PLATFORM_NOT_SUPPORTED  0x80000200

#define FILETABLESIZE               40

typedef struct _ERROR_MAPPING {
    DWORD    dwErrorCode;
    LPTSTR*  lpszError;
} ERROR_MAPPING, *LPERROR_MAPPING;

typedef struct _FAKEFILE {
    HANDLE      hFile;
    BOOL        bAvailable;
} FAKEFILE, *PFAKEFILE;

extern FAKEFILE g_FileTable[FILETABLESIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\publish\lmon.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation
All rights reserved

Module Name:

    lmon.h

--*/


typedef struct _PORT_INFO_FFA {
    LPSTR   pName;
    DWORD   cbMonitorData;
    LPBYTE  pMonitorData;
} PORT_INFO_FFA, *PPORT_INFO_FFA, *LPPORT_INFO_FFA;

typedef struct _PORT_INFO_FFW {
    LPWSTR  pName;
    DWORD   cbMonitorData;
    LPBYTE  pMonitorData;
} PORT_INFO_FFW, *PPORT_INFO_FFW, *LPPORT_INFO_FFW;

#ifdef UNICODE
#define PORT_INFO_FF PORT_INFO_FFW
#define PPORT_INFO_FF PPORT_INFO_FFW
#define LPPORT_INFO_FF LPPORT_INFO_FFW
#else
#define PORT_INFO_FF PORT_INFO_FFA
#define PPORT_INFO_FF PPORT_INFO_FFA
#define LPPORT_INFO_FF LPPORT_INFO_FFA
#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\publish\pdrvver.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pdrvver.h

Abstract:

    Printer Driver Version Resource File

Environment:

    Windows NT printer drivers

Revision History:


--*/

//
// Printer Driver Version Resource File
// This file describes a template for the versioning scheme for printer drivers. 
// It is recommended that this file be modified and included in every 
// printer driver DLL resource file, even for monolithic printer drivers, 
// which are not Unidrv-based minidrivers. 
//
// The versioning scheme:
// The versioning scheme is defined in detail in the DDK documentation. 
// Please refer to it for more information.
//

#include <ntverp.h>

//
// The following field sets the type of DLL. For printer drivers it should 
// always be set to VFT_DRV. Don't change this field.
//

#define VER_FILETYPE                VFT_DRV

//
// If the DLL is of type VFT_DRV then the following field contains a more 
// specific description of the driver. For versioned printer drivers it should 
// always be set to VFT2_DRV_VERSIONED_PRINTER. Don't change this field.
//

#define VER_FILESUBTYPE             VFT2_DRV_VERSIONED_PRINTER

//
// For a versioned printer driver, the following field indicates the File 
// Version of the DLL. The file version consists of four 16-bit (WORD) numbers. 
// The description of each of them is as follows. From left to right,
//
//      First WORD  :   Reserved. Should be set to 0.
//      Second WORD :   Major version of the driver. For user-mode drivers, set
//                      this to 3. For kernel-mode drivers, set this to 2.
//      Third WORD  :   Feature set number. 
//                      The high byte of this number represents the major 
//                      feature set and should always be incremented with the
//                      next major release. A newer release is assumed to 
//                      have a superset of the functionality of the previous 
//                      release. 
//                      The low byte represents minor releases - 
//                      new releases from the same code base or the 
//                      same architecture. The low byte should be 
//                      incremented with each new minor release.
//      Fourth WORD :   Bug fix number or service pack number. This field 
//                      represents the releases of major feature set 
//                      binaries for bugs or service packs and should always
//                      be incremented with each minor release.
//
// Example     :   0, 3, 0x0100, 0x0000
// In the above example the third number shows that the DLL belongs to the first
// major release of the driver. After fixing some bugs in this binary the
// version should be changed to  0, 3, 0x0100, 0x0001. For the next minor 
// release of the driver, which is a superset of the previous release, the 
// version  should be changed to 0, 3, 0x0101, 0x0001. In this case the low 
// byte of the feature set was changed instead of the high byte. This allows 
// more control on the versions. It is recommended that the high byte be used 
// to describe different code bases or major architecture changes and the low 
// byte be used for new releases from the same code base or from the same 
// architecture.
//
// Basically the Feature set and Bug Fix numbers should be used in such a way
// that when they are combined (Feature set = HIWORD, Bug fix = LOWORD) in a 
// 32-bit quantity (DWORD), the new number represents all the features of the
// DLL. A larger number represents newer versions, which are supersets of 
// functionality and bug fixes with respect to all previous releases.
//
// This field needs to be changed per the description above.
//
//

#define VER_FILEVERSION             0, 3, 0, 0

//
// The following field describes the driver. It should include a specific name,
// which identifies the driver.
//
// This field needs to be changed.
//

#define VER_FILEDESCRIPTION_STR     "Sample Printer Driver Resource DLL"

//
// The following field specifies the internal name of the file. For more 
// information, refer to the SDK documentation.
//
// This field needs to be changed.
//

#define VER_INTERNALNAME_STR        "SAMPLERES.DLL"

//
// The following field specifies the original name of the file, not including a 
// path. For more information refer to the SDK documentation.
//
// This field needs to be changed.
//

#define VER_ORIGINALFILENAME_STR    "SAMPLERES.DLL"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\publish\makefile.inc ===
#
# winsprlp.h, winspool.h, winspool.x
#

$(O)\winspool.x $(O)\winsprlp.h: winspool.w
    hsplit -e -o $(O)\winspool.x $(O)\winsprlp.h winspool.w

$(O)\winspool.h : $(O)\winspool.x
    wcshdr < $? > $@

$(WINDOWS_INC_PATH)\winsprlp.h: $(O)\winsprlp.h
    $(PUBLISH_CMD) {$?=$@}

$(SDK_INC_PATH)\winspool.h : $(O)\winspool.h
    $(PUBLISH_CMD) {$?=$@}

$(PROJECT_INC_PATH)\winprtp.h : $(O)\winprtp.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\winprtp.h : winprtp.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\printui.h : $(O)\printui.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\printui.h : printui.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\splapip.h : $(O)\splapip.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\splapip.h : splapip.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\splsetup.h : $(O)\splsetup.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\splsetup.h : splsetup.w
    $(CLEANSE_PUBLISHED_HDR) $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\publish\prcomoem.h ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    prcomoem.h

Abstract:

    Interface declaration for Windows NT printer driver OEM plugins

--*/

#ifndef _PRCOMOEM_H_
#define _PRCOMOEM_H_

//
// This file has to be included after printoem.h. We also need to inlude
// objbase.h or comcat.h from sdk\inc.
//

//
// Each dll/exe must initialize the GUIDs once.If you are not using precompiled
// headers for the file(s) which initializes the GUIDs, define INITGUID before
// including objbase.h.
//

//
// Class ID for OEM rendering component. All OEM rendering plugin need to use this ID.
//
// {6d6abf26-9f38-11d1-882a-00c04fb961ec}
//

DEFINE_GUID(CLSID_OEMRENDER, 0x6d6abf26, 0x9f38, 0x11d1, 0x88, 0x2a, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Class ID for OEM UI component. All OEM UI plugin need to use this ID.
//
// {abce80d7-9f46-11d1-882a-00c04fb961ec}
//

DEFINE_GUID(CLSID_OEMUI, 0xabce80d7, 0x9f46, 0x11d1, 0x88, 0x2a, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemCommon Interface
//
// {7f42285e-91d5-11d1-8820-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemCommon, 0x7f42285e, 0x91d5, 0x11d1, 0x88, 0x20, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemEngine Interface
//
// {63d17590-91d8-11d1-8820-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemEngine, 0x63d17590, 0x91d8, 0x11d1, 0x88, 0x20, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemUI Interface
//
// {C6A7A9D0-774C-11d1-947F-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemUI, 0xc6a7a9d0, 0x774c, 0x11d1, 0x94, 0x7f, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemUI2 Interface
//
// {292515F9-B54B-489B-9275-BAB56821395E}
//

DEFINE_GUID(IID_IPrintOemUI2, 0x292515f9, 0xb54b, 0x489b, 0x92, 0x75, 0xba, 0xb5, 0x68, 0x21, 0x39, 0x5e);

//
// Interface ID for IPrintOemDriverUI interface
//
// {92B05D50-78BC-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemDriverUI, 0x92b05d50, 0x78bc, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintCoreUI2 interface
//
// {085CCFCA-3ADF-4c9e-B491-D851A6EDC997}
//

DEFINE_GUID(IID_IPrintCoreUI2, 0x85ccfca, 0x3adf, 0x4c9e, 0xb4, 0x91, 0xd8, 0x51, 0xa6, 0xed, 0xc9, 0x97);

//
// Interface ID for IPrintOemPS Interface
//
// {688342b5-8e1a-11d1-881f-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemPS, 0x688342b5, 0x8e1a, 0x11d1, 0x88, 0x1f, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemPS2 Interface
//
// {BECF7F34-51B3-46c9-8A1C-18679BD21F36}
//

DEFINE_GUID(IID_IPrintOemPS2, 0xbecf7f34, 0x51b3, 0x46c9, 0x8a, 0x1c, 0x18, 0x67, 0x9b, 0xd2, 0x1f, 0x36);

//
// Interface ID for IPrintOemDriverPS interface
//
// {d90060c7-8e1a-11d1-881f-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemDriverPS, 0xd90060c7, 0x8e1a, 0x11d1, 0x88, 0x1f, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintCorePS2 interface
//
// {CDBB0B0B-A917-40d7-9FBF-483B3BE7EF22}

DEFINE_GUID(IID_IPrintCorePS2, 0xcdbb0b0b, 0xa917, 0x40d7, 0x9f, 0xbf, 0x48, 0x3b, 0x3b, 0xe7, 0xef, 0x22);

//
// Interface ID for IPrintOemUni Interface
//
// {D67EBBF0-78BF-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemUni, 0xd67ebbf0, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemUni2 Interface
//
// {B91220AC-15CC-4e7a-A21E-9591F34D6F6C}
//

DEFINE_GUID(IID_IPrintOemUni2, 0xb91220ac, 0x15cc, 0x4e7a, 0xa2, 0x1e, 0x95, 0x91, 0xf3, 0x4d, 0x6f, 0x6c);

//
// Interface ID for IPrintOemDriverUni interface
//
// {D67EBBF1-78BF-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemDriverUni, 0xd67ebbf1, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

#undef IUnknown

#ifdef __cplusplus
extern "C" {
#endif

//
//****************************************************************************
//  IPrintOemCommon interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemCommon
DECLARE_INTERFACE_(IPrintOemCommon, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;
};

#ifndef KERNEL_MODE

//
// Definitions used by user interface module only.
// Make sure the macro KERNEL_MODE is not defined.
//

//
//****************************************************************************
//  IPrintOemUI interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUI
DECLARE_INTERFACE_(IPrintOemUI, IPrintOemCommon)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemUI methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface) (THIS_ IUnknown *pIUnknown) PURE;


    //
    // CommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_
            DWORD  dwMode,
            POEMCUIPPARAM   pOemCUIPParam
            )PURE;

    //
    // DocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;

    //
    // DevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;


    //
    // DevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            )PURE;

    //
    // DeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            )PURE;

    //
    // UpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            )PURE;

    //
    // PrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            )PURE;

    //
    // DriverEvent
    //

    STDMETHOD(DriverEvent) (THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            )PURE;

    //
    // QueryColorProfile
    //

    STDMETHOD(QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData
            )PURE;

    //
    // FontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            )PURE;

    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
           )PURE;
};


//
//****************************************************************************
//  IPrintOemUI2 interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUI2
DECLARE_INTERFACE_(IPrintOemUI2, IPrintOemUI)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemUI methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface) (THIS_ IUnknown *pIUnknown) PURE;


    //
    // CommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_
            DWORD  dwMode,
            POEMCUIPPARAM   pOemCUIPParam
            )PURE;

    //
    // DocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;

    //
    // DevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;


    //
    // DevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            )PURE;

    //
    // DeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            )PURE;

    //
    // UpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            )PURE;

    //
    // PrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            )PURE;

    //
    // DriverEvent
    //

    STDMETHOD(DriverEvent) (THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            )PURE;

    //
    // QueryColorProfile
    //

    STDMETHOD(QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData
            )PURE;

    //
    // FontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            )PURE;

    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
           )PURE;

    //
    // IPrintOemUI2 methods
    //

    //
    // QueryJobAttributes
    //

    STDMETHOD(QueryJobAttributes)  (THIS_
            HANDLE      hPrinter,
            PDEVMODE    pDevmode,
            DWORD       dwLevel,
            LPBYTE      lpAttributeInfo
           )PURE;

    //
    // Hide Standard UI
    //

    STDMETHOD(HideStandardUI)  (THIS_
            DWORD       dwMode
           )PURE;

    //
    // DocumentEvent
    //

    STDMETHOD(DocumentEvent) (THIS_
            HANDLE      hPrinter,
            HDC         hdc,
            INT         iEsc,
            ULONG       cbIn,
            PVOID       pvIn,
            ULONG       cbOut,
            PVOID       pvOut,
            PINT        piResult
           )PURE;
};


//
//****************************************************************************
//  IPrintOemDriverUI interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemDriverUI
DECLARE_INTERFACE_(IPrintOemDriverUI, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemDriverUI methods
    //

    //
    // Helper function to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_
                        PVOID   pci,
                        PCSTR   Feature,
                        PVOID   pOutput,
                        DWORD   cbSize,
                        PDWORD  pcbNeeded,
                        PDWORD  pdwOptionsReturned
                        )PURE;

    //
    // Helper function to allow OEM plugins upgrade private registry
    // settings. This function should be called only by OEM's UpgradePrinter()
    //

    STDMETHOD(DrvUpgradeRegistrySetting) (THIS_
                        HANDLE   hPrinter,
                        PCSTR    pFeature,
                        PCSTR    pOption
                        )PURE;

    //
    // Helper function to allow OEM plugins to update the driver UI
    // settings and show constraints. This function should be called only when
    // the UI is present.
    //

    STDMETHOD(DrvUpdateUISetting) (THIS_
                        PVOID    pci,
                        PVOID    pOptItem,
                        DWORD    dwPreviousSelection,
                        DWORD    dwMode
                        )PURE;
};

//
//****************************************************************************
//  IPrintCoreUI2 interface
//
//  This is the revised core driver helper interface OEM UI plugin can call.
//  It supercedes the old helper interface IPrintOemDriverUI.
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintCoreUI2
DECLARE_INTERFACE_(IPrintCoreUI2, IPrintOemDriverUI)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemDriverUI methods
    //

    //
    // Helper function to get driver settings. This function is only supported
    // for UI plugins that do not fully replace core driver's standard UI.
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_
                        PVOID   pci,
                        PCSTR   Feature,
                        PVOID   pOutput,
                        DWORD   cbSize,
                        PDWORD  pcbNeeded,
                        PDWORD  pdwOptionsReturned
                        )PURE;

    //
    // Helper function to allow OEM plugins upgrade private registry
    // settings. This function is supported for any UI plugins and should be
    // called only by OEM's UpgradePrinter.
    //

    STDMETHOD(DrvUpgradeRegistrySetting) (THIS_
                        HANDLE   hPrinter,
                        PCSTR    pFeature,
                        PCSTR    pOption
                        )PURE;

    //
    // Helper function to allow OEM plugins to update the driver UI settings.
    // This function is only supported for UI plugins that do not fully replace
    // core driver's standard UI. It should be called only when the UI is present.
    //

    STDMETHOD(DrvUpdateUISetting) (THIS_
                        PVOID    pci,
                        PVOID    pOptItem,
                        DWORD    dwPreviousSelection,
                        DWORD    dwMode
                        )PURE;

    //
    // IPrintCoreUI2 new methods
    //

    //
    // Following four helper functions are only supported for UI plugins that fully
    // replace core driver's standard UI. They should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet callback
    // functions.
    //
    // Helper function to retrieve driver's current setting as a list of
    // feature/option keyword pairs.
    //

    STDMETHOD(GetOptions) (THIS_
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeaturesRequested,
                           IN  DWORD      cbIn,
                           OUT PSTR       pmszFeatureOptionBuf,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to change driver's setting using a list of feature/option
    // keyword pairs.
    //

    STDMETHOD(SetOptions) (THIS_
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeatureOptionBuf,
                           IN  DWORD      cbIn,
                           OUT PDWORD     pdwResult) PURE;

    //
    // Helper function to retrieve the option(s) of a given feature that are
    // constrained in driver's current setting.
    //

    STDMETHOD(EnumConstrainedOptions) (THIS_
                                       IN  POEMUIOBJ  poemuiobj,
                                       IN  DWORD      dwFlags,
                                       IN  PCSTR      pszFeatureKeyword,
                                       OUT PSTR       pmszConstrainedOptionList,
                                       IN  DWORD      cbSize,
                                       OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to retrieve a list of feature/option keyword pairs from
    // driver's current setting that conflict with the given feature/option pair.
    //

    STDMETHOD(WhyConstrained) (THIS_
                               IN  POEMUIOBJ  poemuiobj,
                               IN  DWORD      dwFlags,
                               IN  PCSTR      pszFeatureKeyword,
                               IN  PCSTR      pszOptionKeyword,
                               OUT PSTR       pmszReasonList,
                               IN  DWORD      cbSize,
                               OUT PDWORD     pcbNeeded) PURE;

    //
    // Following five helper functions are supported for any UI plugins.
    //
    // Helper function to retrieve global attribute.
    //

    STDMETHOD(GetGlobalAttribute) (THIS_
                                   IN  POEMUIOBJ  poemuiobj,
                                   IN  DWORD      dwFlags,
                                   IN  PCSTR      pszAttribute,
                                   OUT PDWORD     pdwDataType,
                                   OUT PBYTE      pbData,
                                   IN  DWORD      cbSize,
                                   OUT PDWORD     pcbNeeded) PURE;


    //
    // Helper function to retrieve attribute of a given feature.
    //

    STDMETHOD(GetFeatureAttribute) (THIS_
                                    IN  POEMUIOBJ  poemuiobj,
                                    IN  DWORD      dwFlags,
                                    IN  PCSTR      pszFeatureKeyword,
                                    IN  PCSTR      pszAttribute,
                                    OUT PDWORD     pdwDataType,
                                    OUT PBYTE      pbData,
                                    IN  DWORD      cbSize,
                                    OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to retrieve attribute of a given feature/option selection.
    //

    STDMETHOD(GetOptionAttribute) (THIS_
                                   IN  POEMUIOBJ  poemuiobj,
                                   IN  DWORD      dwFlags,
                                   IN  PCSTR      pszFeatureKeyword,
                                   IN  PCSTR      pszOptionKeyword,
                                   IN  PCSTR      pszAttribute,
                                   OUT PDWORD     pdwDataType,
                                   OUT PBYTE      pbData,
                                   IN  DWORD      cbSize,
                                   OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to retrieve the list of feature keyword.
    //

    STDMETHOD(EnumFeatures) (THIS_
                             IN  POEMUIOBJ  poemuiobj,
                             IN  DWORD      dwFlags,
                             OUT PSTR       pmszFeatureList,
                             IN  DWORD      cbSize,
                             OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to retrieve the list of options keyword of a given feature.
    //

    STDMETHOD(EnumOptions) (THIS_
                            IN  POEMUIOBJ  poemuiobj,
                            IN  DWORD      dwFlags,
                            IN  PCSTR      pszFeatureKeyword,
                            OUT PSTR       pmszOptionList,
                            IN  DWORD      cbSize,
                            OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to query system simulation support
    //

    STDMETHOD(QuerySimulationSupport) (THIS_
                                       IN  HANDLE  hPrinter,
                                       IN  DWORD   dwLevel,
                                       OUT PBYTE   pCaps,
                                       IN  DWORD   cbSize,
                                       OUT PDWORD  pcbNeeded) PURE;
};

#else   // KERNEL_MODE

//
// Definitions used by rendering module only.
// Make sure the macro KERNEL_MODE is defined.
//

//
//****************************************************************************
//  IPrintOemEngine interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemEngine
DECLARE_INTERFACE_(IPrintOemEngine, IPrintOemCommon)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;
};

//
//****************************************************************************
//  IPrintOemPS interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemPS
DECLARE_INTERFACE_(IPrintOemPS, IPrintOemEngine)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemPS methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_  IUnknown *pIUnknown) PURE;

    //
    // Method for OEM to generate output at specific injection point
    //

    STDMETHOD(Command) (THIS_   PDEVOBJ     pdevobj,
                                DWORD       dwIndex,
                                PVOID       pData,
                                DWORD       cbSize,
                                OUT DWORD   *pdwResult) PURE;
};

//
//****************************************************************************
//  IPrintOemPS2 interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemPS2
DECLARE_INTERFACE_(IPrintOemPS2, IPrintOemPS)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemPS methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_  IUnknown *pIUnknown) PURE;

    //
    // Method for OEM to generate output at specific injection point
    //

    STDMETHOD(Command) (THIS_   PDEVOBJ     pdevobj,
                                DWORD       dwIndex,
                                PVOID       pData,
                                DWORD       cbSize,
                                OUT DWORD   *pdwResult) PURE;

    //
    // IPrintOemPS2 methods
    //

    //
    // Method for plugin to hook out spooler's WritePrinter API so it
    // can get access to output data PostScript driver is generating
    //
    // At DrvEnablePDEV time, PostScript driver will call this function with
    // pdevobj = NULL, pBuf = NULL, cbBuffer = 0 to detect if the plugin
    // implements this function. Plugin should return S_OK to indicate it is
    // implementing this function, or return E_NOTIMPL otherwise.
    //
    // In pcbWritten, plugins should return the number of bytes written to the
    // spooler's WritePrinter function. Zero doesn't carry a special meaning,
    // errors must be reported through the returned HRESULT.
    //

    STDMETHOD(WritePrinter) (THIS_   PDEVOBJ    pdevobj,
                                     PVOID      pBuf,
                                     DWORD      cbBuffer,
                                     PDWORD     pcbWritten) PURE;

    //
    // Method for plugin to implement if it wants to be called to get the chance
    // to override some PDEV settings such as paper margins.
    // Plugins that recognize the adjustment type should return S_OK.
    // If the adjustment type is unrecognized, they should return S_FALSE
    // and not E_NOTIMPL, this code should be reserved for the COM meaning.
    // If the plugin fails the call, it should return E_FAIL.
    // The chain of plugins will be called until a plugin returns S_OK or
    // any failure code other than E_NOTIMPL, in other words, until the first
    // plugin that is designed to handle the adjustment is found.
    //

    STDMETHOD(GetPDEVAdjustment) (THIS_ PDEVOBJ    pdevobj,
                                        DWORD      dwAdjustType,
                                        PVOID      pBuf,
                                        DWORD      cbBuffer,
                                        OUT BOOL  *pbAdjustmentDone) PURE;
};

//
//****************************************************************************
//  IPrintOemDriverPS interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemDriverPS
DECLARE_INTERFACE_(IPrintOemDriverPS, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemDriverPS methods
    //

    //
    // Method for OEM to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_   PVOID   pdriverobj,
                                            PCSTR   Feature,
                                            PVOID   pOutput,
                                            DWORD   cbSize,
                                            PDWORD  pcbNeeded,
                                            PDWORD  pdwOptionsReturned) PURE;

    //
    // Method for OEM to write to spooler buffer
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            OUT DWORD   *pdwResult) PURE;
};

//
//****************************************************************************
//  IPrintCorePS2 interface
//
//  This is the revised core driver helper interface OEM PS render plugin can
//  call. It supercedes the old helper interface IPrintOemDriverPS.
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintCorePS2
DECLARE_INTERFACE_(IPrintCorePS2, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintCorePS2 methods
    //

    //
    // Method for OEM to write to spooler buffer.
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_
                           IN  PDEVOBJ  pdevobj,
                           IN  PVOID    pBuffer,
                           IN  DWORD    cbSize,
                           OUT DWORD    *pdwResult) PURE;

    //
    // Helper function to retrieve driver's current setting as a list of
    // feature/option keyword pairs.
    //

    STDMETHOD(GetOptions) (THIS_
                           IN  PDEVOBJ  pdevobj,
                           IN  DWORD    dwFlags,
                           IN  PCSTR    pmszFeaturesRequested,
                           IN  DWORD    cbIn,
                           OUT PSTR     pmszFeatureOptionBuf,
                           IN  DWORD    cbSize,
                           OUT PDWORD   pcbNeeded) PURE;

    //
    // Helper function to retrieve global attribute.
    //

    STDMETHOD(GetGlobalAttribute) (THIS_
                                   IN  PDEVOBJ  pdevobj,
                                   IN  DWORD    dwFlags,
                                   IN  PCSTR    pszAttribute,
                                   OUT PDWORD   pdwDataType,
                                   OUT PBYTE    pbData,
                                   IN  DWORD    cbSize,
                                   OUT PDWORD   pcbNeeded) PURE;


    //
    // Helper function to retrieve attribute of a given feature.
    //

    STDMETHOD(GetFeatureAttribute) (THIS_
                                    IN  PDEVOBJ  pdevobj,
                                    IN  DWORD    dwFlags,
                                    IN  PCSTR    pszFeatureKeyword,
                                    IN  PCSTR    pszAttribute,
                                    OUT PDWORD   pdwDataType,
                                    OUT PBYTE    pbData,
                                    IN  DWORD    cbSize,
                                    OUT PDWORD   pcbNeeded) PURE;

    //
    // Helper function to retrieve attribute of a given feature/option selection.
    //

    STDMETHOD(GetOptionAttribute) (THIS_
                                   IN  PDEVOBJ  pdevobj,
                                   IN  DWORD    dwFlags,
                                   IN  PCSTR    pszFeatureKeyword,
                                   IN  PCSTR    pszOptionKeyword,
                                   IN  PCSTR    pszAttribute,
                                   OUT PDWORD   pdwDataType,
                                   OUT PBYTE    pbData,
                                   IN  DWORD    cbSize,
                                   OUT PDWORD   pcbNeeded) PURE;

    //
    // Helper function to retrieve the list of feature keyword.
    //

    STDMETHOD(EnumFeatures) (THIS_
                             IN  PDEVOBJ  pdevobj,
                             IN  DWORD    dwFlags,
                             OUT PSTR     pmszFeatureList,
                             IN  DWORD    cbSize,
                             OUT PDWORD   pcbNeeded) PURE;

    //
    // Helper function to retrieve the list of options keyword of a given feature.
    //

    STDMETHOD(EnumOptions) (THIS_
                            IN  PDEVOBJ  pdevobj,
                            IN  DWORD    dwFlags,
                            IN  PCSTR    pszFeatureKeyword,
                            OUT PSTR     pmszOptionList,
                            IN  DWORD    cbSize,
                            OUT PDWORD   pcbNeeded) PURE;
};

//
//****************************************************************************
//  IPrintOemUni interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUni
DECLARE_INTERFACE_(IPrintOemUni, IPrintOemEngine)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemUni methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown) PURE;

    //
    // Method for getting OEM implemented methods.
    // Returns S_OK if the given method is implemented.
    // Returns S_FALSE if the given method is not implemented.
    //
    //

    STDMETHOD(GetImplementedMethod) (THIS_  PSTR    pMethodName) PURE;

    //
    // DriverDMS
    //

    STDMETHOD(DriverDMS)(THIS_  PVOID   pDevObj,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;

    //
    // CommandCallback
    //

    STDMETHOD(CommandCallback)(THIS_    PDEVOBJ     pdevobj,
                                        DWORD       dwCallbackID,
                                        DWORD       dwCount,
                                        PDWORD      pdwParams,
                                        OUT INT     *piResult) PURE;


    //
    // ImageProcessing
    //

    STDMETHOD(ImageProcessing)(THIS_    PDEVOBJ             pdevobj,
                                        PBYTE               pSrcBitmap,
                                        PBITMAPINFOHEADER   pBitmapInfoHeader,
                                        PBYTE               pColorTable,
                                        DWORD               dwCallbackID,
                                        PIPPARAMS           pIPParams,
                                        OUT PBYTE           *ppbResult) PURE;

    //
    // FilterGraphics
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen) PURE;

    //
    // Compression
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult) PURE;

    //
    // HalftonePattern
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize) PURE;

    //
    // MemoryUsage
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage) PURE;

    //
    // TTYGetInfo
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded
                                    ) PURE;
    //
    // DownloadFontheader
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // DownloadCharGlyph
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult) PURE;


    //
    // TTDownloadMethod
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // OutputCharStr
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph) PURE;

    //
    // SendFontCmd
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv) PURE;

    //
    // TextOutAsBitmap
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix) PURE;
};

//
//****************************************************************************
//  IPrintOemUni2 interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUni2
DECLARE_INTERFACE_(IPrintOemUni2, IPrintOemUni)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemUni methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown) PURE;

    //
    // Method for getting OEM implemented methods.
    // Returns S_OK if the given method is implemented.
    // Returns S_FALSE if the given method is not implemented.
    //
    //

    STDMETHOD(GetImplementedMethod) (THIS_  PSTR    pMethodName) PURE;

    //
    // DriverDMS
    //

    STDMETHOD(DriverDMS)(THIS_  PVOID   pDevObj,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;

    //
    // CommandCallback
    //

    STDMETHOD(CommandCallback)(THIS_    PDEVOBJ     pdevobj,
                                        DWORD       dwCallbackID,
                                        DWORD       dwCount,
                                        PDWORD      pdwParams,
                                        OUT INT     *piResult) PURE;


    //
    // ImageProcessing
    //

    STDMETHOD(ImageProcessing)(THIS_    PDEVOBJ             pdevobj,
                                        PBYTE               pSrcBitmap,
                                        PBITMAPINFOHEADER   pBitmapInfoHeader,
                                        PBYTE               pColorTable,
                                        DWORD               dwCallbackID,
                                        PIPPARAMS           pIPParams,
                                        OUT PBYTE           *ppbResult) PURE;

    //
    // FilterGraphics
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen) PURE;

    //
    // Compression
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult) PURE;

    //
    // HalftonePattern
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize) PURE;

    //
    // MemoryUsage
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage) PURE;

    //
    // TTYGetInfo
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded
                                    ) PURE;
    //
    // DownloadFontheader
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // DownloadCharGlyph
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult) PURE;


    //
    // TTDownloadMethod
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // OutputCharStr
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph) PURE;

    //
    // SendFontCmd
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv) PURE;

    //
    // TextOutAsBitmap
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix) PURE;

    //
    // IPrintOemUni2 methods
    //

    //
    // Method for plugin to hook out spooler's WritePrinter API so it
    // can get access to output data Universal driver is generating
    //
    // At DrvEnablePDEV time, Universal driver will call this function with
    // pdevobj = NULL, pBuf = NULL, cbBuffer = 0 to detect if the plugin
    // implements this function. Plugin should return S_OK to indicate it is
    // implementing this function, or return E_NOTIMPL otherwise.
    //
    // In pcbWritten, plugins should return the number of bytes written to the
    // spooler's WritePrinter function. Zero doesn't carry a special meaning,
    // errors must be reported through the returned HRESULT.
    //

    STDMETHOD(WritePrinter) (THIS_   PDEVOBJ    pdevobj,
                                     PVOID      pBuf,
                                     DWORD      cbBuffer,
                                     PDWORD     pcbWritten) PURE;
};


//
//****************************************************************************
//  IPrintOemDriverUni interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemDriverUni
DECLARE_INTERFACE_(IPrintOemDriverUni, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemDriverUni methods
    //

    //
    // Function to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_   PVOID   pdriverobj,
                                            PCSTR   Feature,
                                            PVOID   pOutput,
                                            DWORD   cbSize,
                                            PDWORD  pcbNeeded,
                                            PDWORD  pdwOptionsReturned) PURE;

    //
    // Common to both Unidrv & Pscript
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // Unidrv specific XMoveTo and YMoveTo. Returns E_NOT_IMPL in Pscript
    //

    STDMETHOD(DrvXMoveTo)(THIS_     PDEVOBJ     pdevobj,
                                    INT         x,
                                    DWORD       dwFlags,
                                    OUT INT     *piResult) PURE;

    STDMETHOD(DrvYMoveTo)(THIS_     PDEVOBJ     pdevobj,
                                    INT         y,
                                    DWORD       dwFlags,
                                    OUT INT     *piResult) PURE;
    //
    // Unidrv specific. To get the standard variable value.
    //

    STDMETHOD(DrvGetStandardVariable)(THIS_     PDEVOBJ     pdevobj,
                                                DWORD       dwIndex,
                                                PVOID       pBuffer,
                                                DWORD       cbSize,
                                                PDWORD      pcbNeeded) PURE;

    //
    // Unidrv specific.  To Provide OEM plugins access to GPD data.
    //

    STDMETHOD (DrvGetGPDData)(THIS_  PDEVOBJ     pdevobj,
                                     DWORD       dwType,     // Type of the data
                                     PVOID         pInputData,   // reserved. Should be set to 0
                                     PVOID          pBuffer,     // Caller allocated Buffer to be copied
                                     DWORD       cbSize,     // Size of the buffer
                                     PDWORD      pcbNeeded   // New Size of the buffer if needed.
                             ) PURE;


    //
    // Unidrv specific. To do the TextOut.
    //

    STDMETHOD(DrvUniTextOut)(THIS_    SURFOBJ    *pso,
                                      STROBJ     *pstro,
                                      FONTOBJ    *pfo,
                                      CLIPOBJ    *pco,
                                      RECTL      *prclExtra,
                                      RECTL      *prclOpaque,
                                      BRUSHOBJ   *pboFore,
                                      BRUSHOBJ   *pboOpaque,
                                      POINTL     *pptlBrushOrg,
                                      MIX         mix) PURE;

    //
    //   Warning!!!  new method!!  must place at end of
    //   interface - else major incompatibility with previous oem plugins
    //

    STDMETHOD(DrvWriteAbortBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            DWORD       dwWait  //  pause data transmission for this many millisecs.
                               ) PURE;
};

#endif  // !KERNEL_MODE

#ifdef __cplusplus
}
#endif

#endif  // !_PRCOMOEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\publish\minidrv.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    minidrv.h

Abstract:

    Common header file for Plug-in minidrivers.

Environment:

    Windows NT printer drivers

Revision History:


--*/


#ifndef _MINIDRV_H_
#define _MINIDRV_H_

#include <stddef.h>
#include <stdlib.h>

#include <objbase.h>

#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>
#include <tchar.h>
#include <excpt.h>

//
// defined(KERNEL_MODE) Rendering module DLL in either kernel mode or user mode.
// defined(KERNEL_MODE) & defined(USERMODE_DRIVER) User mode rendering DLL
// !defined(KERNEL_MODE) UI module
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
// Kernel mode rendering DLL
#include "winsplkm.h"
#else
// User mode DLL
#include <winspool.h>
#endif

#if !defined(KERNEL_MODE)
// UI DLL
#include <windows.h>
#include <compstui.h>
#include <winddiui.h>
#endif

#if defined(USERMODE_DRIVER) || !defined(KERNEL_MODE)
// UI DLL or User mode rendering DLL
#include <stdio.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifdef WINNT_40
//
// The LONG_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. ULONG_PTR is
//

typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef int INT_PTR, *PINT_PTR;
typedef unsigned int UINT_PTR, *PUINT_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;


#define HandleToUlong( h ) ((ULONG) (h) )
#define PtrToUlong( p )    ((ULONG) (p) )
#define PtrToLong( p )     ((LONG) (p) )
#define PtrToUshort( p )   ((unsigned short) (p) )
#define PtrToShort( p )    ((short) (p) )

#define GWLP_USERDATA       GWL_USERDATA
#define DWLP_USER           DWL_USER
#define DWLP_MSGRESULT      0
#define SetWindowLongPtr    SetWindowLong
#define GetWindowLongPtr    GetWindowLong

#endif // WINNT_40

#include <printoem.h>
#include <prntfont.h>

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5

#if DBG

extern INT giDebugLevel;

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

extern VOID DbgPrint(PCSTR, ...);
#define DbgBreakPoint EngDebugBreak

#else

extern ULONG _cdecl DbgPrint(PCSTR, ...);
extern VOID DbgBreakPoint(VOID);

#endif

#define DBGMSG(level, prefix, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint("%s %s (%d): ", prefix, __FILE__, __LINE__); \
                DbgPrint msg; \
            } \
        }

#define DBGPRINT(level, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint msg; \
            } \
        }

#define VERBOSE(msg) DBGPRINT(DBG_VERBOSE, msg)
#define TERSE(msg) DBGPRINT(DBG_TERSE, msg)
#define WARNING(msg) DBGMSG(DBG_WARNING, "WRN", msg)
#define ERR(msg) DBGMSG(DBG_ERROR, "ERR", msg)

#ifndef __MDT__                 // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond) { \
            if (! (cond)) { \
                RIP(("\n")); \
            } \
        }
#endif

#define ASSERTMSG(cond, msg) { \
            if (! (cond)) { \
                RIP(msg); \
            } \
        }

#define RIP(msg) { \
            DBGMSG(DBG_RIP, "RIP", msg); \
            DbgBreakPoint(); \
        }


#else // !DBG

#define VERBOSE(msg)
#define TERSE(msg)
#define WARNING(msg)
#define ERR(msg)

#ifndef __MDT__                 // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond)
#endif

#define ASSERTMSG(cond, msg)
#define RIP(msg)
#define DBGMSG(level, prefix, msg)
#define DBGPRINT(level, msg)

#endif

//
// The following macros let you enable tracing on per-file and per-function level.
// To use these macros in a file, here is what you should do:
//
// At the beginning of the file (after header includes):
//
//  Define a bit constant for each function you want to trace
//  Add the following line
//      DEFINE_FUNCTION_TRACE_FLAGS(flags);
//  where flags is a bit-wise OR of the functions you want to trace, e.g.
//      TRACE_FLAG_FUNC1 | TRACE_FLAG_FUNC2 | ...
//
//  To generate trace inside each function you want to trace, use:
//      FUNCTION_TRACE(FunctionTraceFlag, (args));
//

#if DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags) \
        static DWORD gdwFunctionTraceFlags = (flags)

#define FUNCTION_TRACE(flag, args) { \
            if (gdwFunctionTraceFlags & (flag)) { \
                DbgPrint args; \
            } \
        }

#else // !DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags)
#define FUNCTION_TRACE(flag, args)

#endif // !DBG


//
// Memory allocation function macros
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }


//
// DBCS CharSet handling macros
//
//
// 128: SHIFTJIS_CHARSET
// 129: HANGEUL_CHARSET
// 130: JOHAB_CHARSET (defined if WINVER >= 0x0400)
// 134: GB2312_CHARSET
// 136: CHINESEBIG5_CHARSET

#define IS_DBCSCHARSET(j) \
    (((j) == SHIFTJIS_CHARSET)    || \
    ((j) == HANGEUL_CHARSET)     || \
    ((j) == JOHAB_CHARSET)       || \
    ((j) == GB2312_CHARSET)      || \
    ((j) == CHINESEBIG5_CHARSET))

//  932: Japan
//  936: Chinese (PRC, Singapore)
//  949: Korean
//  950: Chinese (China, Hong Kong SAR, Taiwan)
// 1361: Korean (Johab)

#define IS_DBCSCODEPAGE(j) \
    (((j) == 932)   || \
    ((j) == 936)   || \
    ((j) == 949)   || \
    ((j) == 950)   || \
    ((j) == 1361))


//
//  The following are the resource types used in minidrivers and
//  used in the .rc file.
//

#define RC_TABLES      257
#define RC_FONT        258
#define RC_TRANSTAB    259

//
// 5.0 resource types
//

#define RC_UFM         260
#define RC_GTT         261
#define RC_HTPATTERN   264
//
// Internal resource type
//

#define RC_FD_GLYPHSET 262

#ifdef __cplusplus
}
#endif

#endif //_MINIDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\publish\printoem.h ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    printoem.h

Abstract:

    Declarations for Windows NT printer driver OEM plugins

--*/


#ifndef _PRINTOEM_
#define _PRINTOEM_

#ifdef __cplusplus
extern "C" {
#endif

//
// Current OEM plugin interface version number
//

#define PRINTER_OEMINTF_VERSION 0x00010000

#define OEM_MODE_PUBLISHER      0x00000001

typedef struct _PUBLISHERINFO {

    DWORD dwMode;           // flags for publisher
    WORD  wMinoutlinePPEM;  // min size to download as Type1
    WORD  wMaxbitmapPPEM;   // max size to download as Type3

} PUBLISHERINFO, *PPUBLISHERINFO;

#define OEMGI_GETSIGNATURE        1
#define OEMGI_GETINTERFACEVERSION 2
#define OEMGI_GETVERSION          3
#define OEMGI_GETPUBLISHERINFO    4

//
// OEMGetInfo
//
BOOL APIENTRY
OEMGetInfo(
    IN  DWORD  dwMode,
    OUT PVOID  pBuffer,
    IN  DWORD  cbSize,
    OUT PDWORD pcbNeeded
    );

BOOL APIENTRY
OEMDriverDMS(
    PVOID    pDevObj,
    PVOID    pBuffer,
    DWORD    cbSize,
    PDWORD   pcbNeeded
    );

//
// OEMDevMode
//

#define OEMDM_SIZE     1
#define OEMDM_DEFAULT  2
#define OEMDM_CONVERT  3
#define OEMDM_MERGE    4

typedef struct _OEMDMPARAM {

    DWORD    cbSize;        // size of OEM_DEVMODEPARAM
    PVOID    pdriverobj;    // reference to driver data structure
    HANDLE   hPrinter;      // PRINTER handle
    HANDLE   hModule;       // OEM module handle
    PDEVMODE pPublicDMIn;   // public devmode in
    PDEVMODE pPublicDMOut;  // public devmode out
    PVOID    pOEMDMIn;      // OEM private devmode in
    PVOID    pOEMDMOut;     // OEM private devmode out
    DWORD    cbBufSize;     // output size of pOEMDMOut buffer

} OEMDMPARAM, *POEMDMPARAM;

typedef struct _OEM_DMEXTRAHEADER {

    DWORD   dwSize;         // size of OEM extra data
    DWORD   dwSignature;    // Unique OEM signature
    DWORD   dwVersion;      // OEM DLL version number

} OEM_DMEXTRAHEADER, *POEM_DMEXTRAHEADER;

//
// USERDATA for OPTITEM.UserData
//

typedef struct _USERDATA {

    DWORD       dwSize;                 // Size of this structure
    ULONG_PTR    dwItemID;               // XXX_ITEM or pointer to FEATURE
    PSTR        pKeyWordName;           // Keyword name
    DWORD       dwReserved[8];
} USERDATA, *PUSERDATA;


BOOL APIENTRY
OEMDevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam
    );

//
// Callback function provided by the driver to
// allow OEM plugins access/set/update to driver private settings
//

typedef BOOL (APIENTRY *PFN_DrvGetDriverSetting)(
        PVOID   pdriverobj,
        PCSTR   Feature,
        PVOID   pOutput,
        DWORD   cbSize,
        PDWORD  pcbNeeded,
        PDWORD  pdwOptionsReturned
        );

//
// Callback function provided by the driver to
// allow OEM plugins upgrade private registry settings.
//

typedef BOOL (APIENTRY *PFN_DrvUpgradeRegistrySetting)(
        HANDLE   hPrinter,
        PCSTR    pFeature,
        PCSTR    pOption
        );

//
// Callback function provided by the driver UI to
// allow OEM plugins to update the driver UI settings and
// shows constraint. This function is called only when the UI is present.
//

typedef BOOL (APIENTRY *PFN_DrvUpdateUISetting)(
        PVOID    pdriverobj,
        PVOID    pOptItem,
        DWORD    dwPreviousSelection,
        DWORD    dwMode
        );



// Predefined feature indices used for accessing driver private settings

#define OEMGDS_MIN_DOCSTICKY        1
#define OEMGDS_PSDM_FLAGS           1       // DWORD - misc. flag bits
#define OEMGDS_PSDM_DIALECT         2       // INT - PS output option
#define OEMGDS_PSDM_TTDLFMT         3       // INT - TrueType font downloading option
#define OEMGDS_PSDM_NUP             4       // INT - N-up option
#define OEMGDS_PSDM_PSLEVEL         5       // INT - target language level
#define OEMGDS_PSDM_CUSTOMSIZE      6       // 5*DWORD - custom page size parameters

#define OEMGDS_UNIDM_GPDVER         0x4000  // WORD - GPD Version
#define OEMGDS_UNIDM_FLAGS          0x4001  // DWORD - misc flag bits

// Indices for private devmode fields - start at 0x4000

#define OEMGDS_MIN_PRINTERSTICKY    0x8000
#define OEMGDS_PRINTFLAGS           0x8000  // DWORD - misc. flag bits
#define OEMGDS_FREEMEM              0x8001  // DWORD - amount of VM, ps only
#define OEMGDS_JOBTIMEOUT           0x8002  // DWORD - job timeout, ps only
#define OEMGDS_WAITTIMEOUT          0x8003  // DWORD - wait timeout, ps only
#define OEMGDS_PROTOCOL             0x8004  // WORD - output protocol, ps only
#define OEMGDS_MINOUTLINE           0x8005  // WORD - min outline font size, ps only
#define OEMGDS_MAXBITMAP            0x8006  // WORD - max bitmap font size, ps only

#define OEMGDS_MAX                  0x10000


// dwType  flags for use with     STDMETHOD (DrvGetGPDData)
#define GPD_OEMCUSTOMDATA           1


/*******************************************************************************
 *
 * Definitions used by kernel-mode rendering module only:
 *  Make sure the macro KERNEL_MODE is defined and
 *  the header file winddi.h is included before this file.
 */

#ifdef KERNEL_MODE

//
// OEMEnableDriver
//

BOOL APIENTRY
OEMEnableDriver(
    DWORD           dwOemIntfVersion,
    DWORD           cbSize,
    PDRVENABLEDATA  pded
    );

typedef struct _DEVOBJ *PDEVOBJ;
typedef PVOID PDEVOEM;

typedef DWORD (APIENTRY *PFN_DrvWriteSpoolBuf)(
    PDEVOBJ pdevobj,
    PVOID   pBuffer,
    DWORD   cbSize
    );

typedef DWORD (APIENTRY *PFN_DrvWriteAbortBuf)(
    PDEVOBJ pdevobj,
    PVOID   pBuffer,
    DWORD   cbSize,
    DWORD       dwWait

    );

typedef INT (APIENTRY *PFN_DrvXMoveTo)(
    PDEVOBJ pdevobj,
    INT     x,
    DWORD   dwFlags
    );

typedef INT (APIENTRY *PFN_DrvYMoveTo)(
    PDEVOBJ pdevobj,
    INT     y,
    DWORD   dwFlags
    );

typedef BOOL (APIENTRY *PFN_DrvGetStandardVariable)(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded
    );

typedef enum _STDVARIABLEINDEX{

        SVI_NUMDATABYTES,          // "NumOfDataBytes"
        SVI_WIDTHINBYTES,          // "RasterDataWidthInBytes"
        SVI_HEIGHTINPIXELS,        // "RasterDataHeightInPixels"
        SVI_COPIES,                // "NumOfCopies"
        SVI_PRINTDIRECTION,        // "PrintDirInCCDegrees"
        SVI_DESTX,                 // "DestX"
        SVI_DESTY,                 // "DestY"
        SVI_DESTXREL,              // "DestXRel"
        SVI_DESTYREL,              // "DestYRel"
        SVI_LINEFEEDSPACING,       // "LinefeedSpacing"
        SVI_RECTXSIZE,             // "RectXSize"
        SVI_RECTYSIZE,             // "RectYSize"
        SVI_GRAYPERCENT,           // "GrayPercentage"
        SVI_NEXTFONTID,            // "NextFontID"
        SVI_NEXTGLYPH,             // "NextGlyph"
        SVI_PHYSPAPERLENGTH,       // "PhysPaperLength"
        SVI_PHYSPAPERWIDTH,        // "PhysPaperWidth"
        SVI_FONTHEIGHT,            // "FontHeight"
        SVI_FONTWIDTH,             // "FontWidth"
        SVI_FONTMAXWIDTH,             // "FontMaxWidth"
        SVI_FONTBOLD,              // "FontBold"
        SVI_FONTITALIC,            // "FontItalic"
        SVI_FONTUNDERLINE,         // "FontUnderline"
        SVI_FONTSTRIKETHRU,        // "FontStrikeThru"
        SVI_CURRENTFONTID,         // "CurrentFontID"
        SVI_TEXTYRES,              // "TextYRes"
        SVI_TEXTXRES,              // "TextXRes"
        SVI_GRAPHICSYRES,              // "GraphicsYRes"
        SVI_GRAPHICSXRES,              // "GraphicsXRes"
        SVI_ROP3,                  // "Rop3"
        SVI_REDVALUE,              // "RedValue"
        SVI_GREENVALUE,            // "GreenValue"
        SVI_BLUEVALUE,             // "BlueValue"
        SVI_PALETTEINDEXTOPROGRAM, // "PaletteIndexToProgram"
        SVI_CURRENTPALETTEINDEX,   // "CurrentPaletteIndex"
        SVI_PATTERNBRUSH_TYPE,     // "PatternBrushType"
        SVI_PATTERNBRUSH_ID,       // "PatternBrushID"
        SVI_PATTERNBRUSH_SIZE,     // "PatternBrushSize"
        SVI_CURSORORIGINX,           //  "CursorOriginX"
        SVI_CURSORORIGINY,           //  "CursorOriginY"
                //  this is in MasterUnits and in the coordinates of the currently selected orientation.
                //  this value is defined as ImageableOrigin - CursorOrigin
        SVI_PAGENUMBER,  //  "PageNumber"
                //  this value tracks number of times DrvStartBand has been called since
                //  StartDoc.

        SVI_MAX             //  Just a placeholder do not use.
}STDVARIABLEINDEX;

typedef BOOL (APIENTRY *PFN_DrvUnidriverTextOut)(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlBrushOrg,
    MIX         mix
    );

//
// bit fields defined for dwFlags
//
// Note:  The following Bit values are reserved for an internal use!
//  0x4000
//  0x8000
//
//
#define MV_UPDATE       0x0001
#define MV_RELATIVE     0x0002
#define MV_GRAPHICS     0x0004
#define MV_PHYSICAL     0x0008
#define MV_SENDXMOVECMD     0x0010
#define MV_SENDYMOVECMD     0x0020

typedef struct _DRVPROCS {

    PFN_DrvWriteSpoolBuf    DrvWriteSpoolBuf;   // common to both pscript and unidrv
    PFN_DrvXMoveTo          DrvXMoveTo;         // unidrv specific
    PFN_DrvYMoveTo          DrvYMoveTo;         // unidrv specific
    PFN_DrvGetDriverSetting DrvGetDriverSetting;// common to both pscript and unidrv
    PFN_DrvGetStandardVariable BGetStandardVariable; // unidrv specific
    PFN_DrvUnidriverTextOut    DrvUnidriverTextOut;  // unidrv specific
    PFN_DrvWriteAbortBuf    DrvWriteAbortBuf;   // unidrv specific

} DRVPROCS, *PDRVPROCS;

typedef struct _DEVOBJ {

    DWORD       dwSize;       // size of DEVOBJ structure
    PDEVOEM     pdevOEM;      // pointer to OEM's device data
    HANDLE      hEngine;      // GDI handle for current printer
    HANDLE      hPrinter;     // spooler handle for current printer
    HANDLE      hOEM;         // handle to OEM dll
    PDEVMODE    pPublicDM;    // public devmode
    PVOID       pOEMDM;       // OEM private devmode
    PDRVPROCS   pDrvProcs;    // pointer to kernel mode helper function table

} DEVOBJ;

//
// OEMDisableDriver
//

VOID APIENTRY
OEMDisableDriver(
    VOID
    );

//
// OEMEnablePDEV
//

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded
    );

//
// OEMDisablePDEV
//

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj
    );

//
// OEMResetPDEV
//

BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    );

//
// OEMCommand - PSCRIPT only
//

DWORD APIENTRY
OEMCommand(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pData,
    DWORD   cbSize
    );

INT APIENTRY
OEMCommandCallback(
    PDEVOBJ         pdevobj,
    DWORD           dwCallbackID,
    DWORD           dwCount,
    PDWORD          pdwParams
    );

//
// OEMImageProcessing - UNIDRV only
//

typedef struct {
    DWORD dwSize;
    POINT ptOffset;
    PSTR  pHalftoneOption;
    BOOL  bBanding;
    BOOL  bBlankBand;
} IPPARAMS, *PIPPARAMS;

PBYTE APIENTRY
OEMImageProcessing(
    PDEVOBJ     pdevobj,
    PBYTE       pSrcBitmap,
    PBITMAPINFOHEADER pBitmapInfoHeader,
    PBYTE       pColorTable,
    DWORD       dwCallbackID,
    PIPPARAMS   pIPParams
    );

//
// OEMFilterGraphics - UNIDRV only
//

BOOL APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE   pBuf,
    DWORD   dwLen
    );

//
// OEMCompression - UNIDRV only
//
INT APIENTRY
OEMCompression(
    PDEVOBJ pdevobj,
    PBYTE   pInBuf,
    PBYTE   pOutBuf,
    DWORD   dwInLen,
    DWORD   dwOutLen
    );

//
// OEMHalftone - UNIDRV only
//

BOOL APIENTRY
OEMHalftonePattern(
    PDEVOBJ pdevobj,
    PBYTE   pHTPattern,
    DWORD   dwHTPatternX,
    DWORD   dwHTPatternY,
    DWORD   dwHTNumPatterns,
    DWORD   dwCallbackID,
    PBYTE   pResource,
    DWORD   dwResourceSize
    );

//
// OEMMemoryUsage - UNIDRV only
//

typedef struct {
    DWORD   dwFixedMemoryUsage;
    DWORD   dwPercentMemoryUsage;
    DWORD   dwMaxBandSize;
} OEMMEMORYUSAGE, *POEMMEMORYUSAGE;

VOID APIENTRY
OEMMemoryUsage(
    PDEVOBJ pdevobj,
    POEMMEMORYUSAGE pMemoryUsage
    );

//
// OEMTTYGetInfo - UNIDRV only
//
INT APIENTRY
OEMTTYGetInfo(
    PDEVOBJ pdevobj,
    DWORD   dwInfoIndex,
    PVOID   pOutputBuf,
    DWORD   dwSize,
    DWORD   *pcbcNeeded
    );

#define OEMTTY_INFO_MARGINS     1
#define OEMTTY_INFO_CODEPAGE    2
#define OEMTTY_INFO_NUM_UFMS    3
#define OEMTTY_INFO_UFM_IDS     4

//
// UNIDRV font callback
//

typedef BOOL (*PFNGETINFO)(struct _UNIFONTOBJ*, DWORD, PVOID, DWORD, PDWORD);

typedef struct _UNIFONTOBJ {
    ULONG       ulFontID;
    DWORD       dwFlags;     // General flags
    IFIMETRICS *pIFIMetrics; // Pointer to IFIMETRICS
    PFNGETINFO  pfnGetInfo;  // Pointer to UNIFONTOBJ_GetInfo callback
} UNIFONTOBJ, *PUNIFONTOBJ;

//
// UNIFONTOBJ.dwFlags
//

#define UFOFLAG_TTFONT               0x00000001
#define UFOFLAG_TTDOWNLOAD_BITMAP    0x00000002
#define UFOFLAG_TTDOWNLOAD_TTOUTLINE 0x00000004
#define UFOFLAG_TTOUTLINE_BOLD_SIM   0x00000008
#define UFOFLAG_TTOUTLINE_ITALIC_SIM 0x00000010
#define UFOFLAG_TTOUTLINE_VERTICAL   0x00000020
#define UFOFLAG_TTSUBSTITUTED        0x00000040

//
// UNIFONTOBJ callback ID
//

#define UFO_GETINFO_FONTOBJ     1
#define UFO_GETINFO_GLYPHSTRING 2
#define UFO_GETINFO_GLYPHBITMAP 3
#define UFO_GETINFO_GLYPHWIDTH  4
#define UFO_GETINFO_MEMORY      5
#define UFO_GETINFO_STDVARIABLE 6

//
// UFO_GETINFO_FONTOBJ callback structure
//

typedef struct _GETINFO_FONTOBJ {
    DWORD    dwSize;   // Size of this structure
    FONTOBJ *pFontObj; // Pointer to the FONTOBJ
} GETINFO_FONTOBJ, *PGETINFO_FONTOBJ;

//
// UFO_GETINFO_FONTOBJ callback structure
//

typedef struct _GETINFO_GLYPHSTRING {
    DWORD dwSize;    // Size of this structure
    DWORD dwCount;   // Count of glyphs in pGlyphIn
    DWORD dwTypeIn;  // Glyph type of pGlyphIn, TYPE_GLYPHID/TYPE_HANDLE.
    PVOID pGlyphIn;  // Pointer to the input glyph string
    DWORD dwTypeOut; // Glyph type of pGlyphOut, TYPE_UNICODE/TYPE_TRANSDATA.
    PVOID pGlyphOut; // Pointer to the output glyph string
    DWORD dwGlyphOutSize; // The size of pGlyphOut buffer
} GETINFO_GLYPHSTRING, *PGETINFO_GLYPHSTRING;

//
// UFO_GETINFO_GLYPHBITMAP
//

typedef struct _GETINFO_GLYPHBITMAP {
    DWORD       dwSize;    // Size of this structure
    HGLYPH      hGlyph;    // Glyph hangle passed in OEMDownloadCharGlyph
    GLYPHDATA *pGlyphData; // Pointer to the GLYPHDATA data structure
} GETINFO_GLYPHBITMAP, *PGETINFO_GLYPHBITMAP;

//
// UFO_GETINFO_GLYPHWIDTH
//

typedef struct _GETINFO_GLYPHWIDTH {
    DWORD dwSize;  // Size of this structure
    DWORD dwType;  // Type of glyph stirng in pGlyph, TYPE_GLYPHHANDLE/GLYPHID.
    DWORD dwCount; // Count of glyph in pGlyph
    PVOID pGlyph;  // Pointer to a glyph string
    PLONG plWidth; // Pointer to the buffer of width table.
                   // Minidriver has to prepare this.
} GETINFO_GLYPHWIDTH, *PGETINFO_GLYPHWIDTH;

//
// UFO_GETINFO_MEMORY
//

typedef struct _GETINFO_MEMORY {
    DWORD dwSize;
    DWORD dwRemainingMemory;
} GETINFO_MEMORY, PGETINFO_MEMROY;

//
// UFO_GETINFO_STDVARIABLE
//
// OEM DLL has to prepare all StdVar buffer and set ID in dwStdVarID.
//

typedef struct _GETINFO_STDVAR {
    DWORD dwSize;
    DWORD dwNumOfVariable;
    struct {
        DWORD dwStdVarID;
        LONG  lStdVariable;
    } StdVar[1];
} GETINFO_STDVAR, *PGETINFO_STDVAR;


#define FNT_INFO_PRINTDIRINCCDEGREES  0 // PrintDirInCCDegrees
#define FNT_INFO_GRAYPERCENTAGE       1 // GrayPercentage
#define FNT_INFO_NEXTFONTID           2 // NextfontID
#define FNT_INFO_NEXTGLYPH            3 // NextGlyph
#define FNT_INFO_FONTHEIGHT           4 // FontHeight
#define FNT_INFO_FONTWIDTH            5 // FontWidth
#define FNT_INFO_FONTBOLD             6 // FontBold
#define FNT_INFO_FONTITALIC           7 // FontItalic
#define FNT_INFO_FONTUNDERLINE        8 // FontUnderline
#define FNT_INFO_FONTSTRIKETHRU       9 // FontStrikeThru
#define FNT_INFO_CURRENTFONTID       10 // Current
#define FNT_INFO_TEXTYRES            11 // TextYRes
#define FNT_INFO_TEXTXRES            12 // TextXRes
#define FNT_INFO_FONTMAXWIDTH        13 // FontMaxWidth
#define FNT_INFO_MAX                 14

//
// OEMDownloadFontheader - UNIDRV only
//

DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    );

//
// OEMDownloadCharGlyph - UNIDRV only
//

DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth
    );

//
// OEMTTDownloadMethod - UNIDRV only
//

DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    );

#define TTDOWNLOAD_DONTCARE  0
#define TTDOWNLOAD_GRAPHICS  1
#define TTDOWNLOAD_BITMAP    2
#define TTDOWNLOAD_TTOUTLINE 3

//
// OEMOutputCharStr - UNIDRV only
//

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph
    );

#define TYPE_UNICODE      1
#define TYPE_TRANSDATA    2
#define TYPE_GLYPHHANDLE  3
#define TYPE_GLYPHID      4

//
// OEMSendFontCmd - UNIDRV only
//

typedef struct _FINVOCATION {
    DWORD dwCount;    // Size of command
    PBYTE pubCommand; // Pointer to font selection command
} FINVOCATION, *PFINVOCATION;

VOID APIENTRY
OEMSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv
    );

//
// OEMTextOutAsBitmap - UNIDRV only
//
BOOL APIENTRY
OEMTextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

//
// OEMBitBlt
//

BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    );

//
// OEMStretchBlt
//

BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

//
// OEMCopyBits
//

BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    );

//
// OEMTextOut
//

BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

//
// OEMStrokePath
//

BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    );

//
// OEMFillPath
//

BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    );

//
// OEMStrokeAndFillPath
//

BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    );

//
// OEMRealizeBrush
//

BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    );

//
// OEMStartPage
//

BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso
    );

//
// OEMSendPage
//

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso
    );

//
// OEMEscape
//

ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

//
// OEMStartDoc
//

BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    );

//
// OEMEndDoc
//

BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    );

//
// OEMQueryFont
//

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG_PTR   *pid
    );

//
// OEMQueryFontTree
//

PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR   *pid
    );

//
// OEMQueryFontData
//

LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

//
// OEMQueryAdvanceWidths
//

BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    );

//
// OEMFontManagement
//

ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

//
// OEMGetGlyphMode
//

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    );

BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    );

BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    );

ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    );

BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    );

BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    );

#ifndef WINNT_40

//
// OEMStretchBltROP
//

BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    );

//
// OEMPlgBlt
//

BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    );

//
// OEMAlphaBlend
//

BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    );

//
// OEMGradientFill
//

BOOL APIENTRY
OEMGradientFill(
    SURFOBJ    *psoDest,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode
    );

//
// OEMIcmCreateTransform
//

HANDLE APIENTRY
OEMIcmCreateColorTransform(
    DHPDEV           dhpdev,
    LPLOGCOLORSPACEW pLogColorSpace,
    PVOID            pvSourceProfile,
    ULONG            cjSourceProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile,
    DWORD            dwReserved
    );

//
// OEMIcmDeleteTransform
//

BOOL APIENTRY
OEMIcmDeleteColorTransform(
    DHPDEV dhpdev,
    HANDLE hcmXform
    );

//
// OEMQueryDeviceSupport
//

BOOL APIENTRY
OEMQueryDeviceSupport(
    SURFOBJ    *pso,
    XLATEOBJ   *pxlo,
    XFORMOBJ   *pxo,
    ULONG      iType,
    ULONG      cjIn,
    PVOID      pvIn,
    ULONG      cjOut,
    PVOID      pvOut
    );

//
// OEMTransparentBlt
//

BOOL APIENTRY
OEMTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
    );

#endif // !WINNT_40

//
// Function prototype define's for the driver hooks.
//
// NOTE: These are only needed for NT4. For NT5, they are defined in winddi.h.
//

#ifdef WINNT_40

typedef BOOL (APIENTRY  *LPFNDLLINITIALIZE)(
    ULONG           ulReason
    );

typedef BOOL (APIENTRY *PFN_DrvBitBlt)(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    );

typedef BOOL (APIENTRY *PFN_DrvStretchBlt)(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

typedef BOOL (APIENTRY *PFN_DrvCopyBits)(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    );

typedef BOOL (APIENTRY *PFN_DrvTextOut)(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

typedef BOOL (APIENTRY *PFN_DrvStrokePath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    );

typedef BOOL (APIENTRY *PFN_DrvFillPath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    );

typedef BOOL (APIENTRY *PFN_DrvStrokeAndFillPath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    );

typedef BOOL (APIENTRY *PFN_DrvRealizeBrush)(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    );

typedef BOOL (APIENTRY *PFN_DrvStartPage)(
    SURFOBJ    *pso
    );

typedef BOOL (APIENTRY *PFN_DrvSendPage)(
    SURFOBJ    *pso
    );

typedef ULONG (APIENTRY *PFN_DrvEscape)(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

typedef BOOL (APIENTRY *PFN_DrvStartDoc)(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    );

typedef BOOL (APIENTRY *PFN_DrvEndDoc)(
    SURFOBJ    *pso,
    FLONG       fl
    );

typedef PIFIMETRICS (APIENTRY *PFN_DrvQueryFont)(
    DHPDEV      dhpdev,
    ULONG_PTR    iFile,
    ULONG       iFace,
    ULONG_PTR   *pid
    );

typedef PVOID (APIENTRY *PFN_DrvQueryFontTree)(
    DHPDEV      dhpdev,
    ULONG_PTR    iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR   *pid
    );

typedef LONG (APIENTRY *PFN_DrvQueryFontData)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

typedef BOOL (APIENTRY *PFN_DrvQueryAdvanceWidths)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    );

typedef ULONG (APIENTRY *PFN_DrvFontManagement)(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

typedef ULONG (APIENTRY *PFN_DrvGetGlyphMode)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    );

typedef BOOL (APIENTRY *PFN_DrvNextBand)(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef BOOL (APIENTRY *PFN_DrvStartBanding)(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef ULONG (APIENTRY *PFN_DrvDitherColor)(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    );

typedef BOOL (APIENTRY *PFN_DrvPaint)(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    );

typedef BOOL (APIENTRY *PFN_DrvLineTo)(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    );

#endif // WINNT_40

//
// for the IPrintOemPS2::GetPDEVAdjustment call
//
#define PDEV_ADJUST_PAPER_MARGIN_TYPE 1

typedef struct _PDEV_ADJUST_PAPER_MARGIN {

    RECTL   rcImageableArea;    // contains the imageable area in 0.001 mm units

} PDEV_ADJUST_PAPER_MARGIN;

#define PDEV_HOSTFONT_ENABLED_TYPE 2

typedef struct _PDEV_HOSTFONT_ENABLED {

    BOOL bHostfontEnabled;

} PDEV_HOSTFONT_ENABLED;

#define PDEV_USE_TRUE_COLOR_TYPE 3

typedef struct _PDEV_USE_TRUE_COLOR {

    BOOL bUseTrueColor;

} PDEV_USE_TRUE_COLOR;

#endif // KERNEL_MODE


/*******************************************************************************
 *
 * Definitions used by user-mode UI module only:
 *  Make sure the macro KERNEL_MODE is NOT defined and
 *  the header file winddiui.h is included before this file.
 *
 */

#ifndef KERNEL_MODE

//
// Reports capability of simulated features
//
typedef struct _SIMULATE_CAPS_1 {
    DWORD     dwLevel;
    DWORD     dwPageOrderFlags;         // Reverse page order
    DWORD     dwNumberOfCopies;         // Max number of copies
    DWORD     dwCollate;                // Collate support
    DWORD     dwNupOptions;             // The (1-base) bit set represents the N-up option available.
                                        // 0x0001 means 1-up
                                        // 0x0002 means 2-up
                                        // 0x0008 means 4-up
                                        // 0x812B means (1,2,4,6,9,16)
} SIMULATE_CAPS_1, *PSIMULATE_CAPS_1;

//
// Reference to driver data structure. This is passed to
// most of the OEM UI DLL entrypoints.
//

typedef struct _OEMUIPROCS {

    PFN_DrvGetDriverSetting DrvGetDriverSetting;
    PFN_DrvUpdateUISetting  DrvUpdateUISetting;

} OEMUIPROCS, *POEMUIPROCS;

typedef struct _OEMUIOBJ {

    DWORD       cbSize;             // size of this structure
    POEMUIPROCS pOemUIProcs;        // pointer to user mode helper function table

} OEMUIOBJ, *POEMUIOBJ;


//
// OEMCommonUIProp
//

typedef struct _OEMCUIPPARAM *POEMCUIPPARAM;
typedef LONG (APIENTRY *OEMCUIPCALLBACK)(PCPSUICBPARAM, POEMCUIPPARAM);

typedef struct _OEMCUIPPARAM {

    DWORD           cbSize;         // size of this structure
    POEMUIOBJ       poemuiobj;      // reference to driver data structure
    HANDLE          hPrinter;       // handle to the current printer
    PWSTR           pPrinterName;   // name of current printer
    HANDLE          hModule;        // instance handle to OEM DLL
    HANDLE          hOEMHeap;       // handle to the OEM memory heap
    PDEVMODE        pPublicDM;      // public devmode
    PVOID           pOEMDM;         // OEM private devmode
    DWORD           dwFlags;        // misc. flag bits
    POPTITEM        pDrvOptItems;   // pointer to driver items
    DWORD           cDrvOptItems;   // number of driver items
    POPTITEM        pOEMOptItems;   // pointer to OEM items
    DWORD           cOEMOptItems;   // number of OEM items
    PVOID           pOEMUserData;   // pointer to OEM private data
    OEMCUIPCALLBACK  OEMCUIPCallback; // address of callback function

} OEMCUIPPARAM;

BOOL APIENTRY
OEMCommonUIProp(
    DWORD           dwMode,
    POEMCUIPPARAM   pOemCUIPParam
    );

//
// OEMCommonUIProp dwMode parameter value
//
#define OEMCUIP_DOCPROP       1
#define OEMCUIP_PRNPROP       2

//
// OEMDocumentPropertySheets
//

LRESULT APIENTRY
OEMDocumentPropertySheets(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam
    );

//
// OEMDevicePropertySheets
//

LRESULT APIENTRY
OEMDevicePropertySheets(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam
    );

//
// pPSUIInfo->lParamInit is a pointer to _OEMUIPSPARAM structure defined below.
//
typedef struct _OEMUIPSPARAM {

    DWORD           cbSize;         // size of this structure
    POEMUIOBJ       poemuiobj;      // reference to driver data structure
    HANDLE          hPrinter;       // handle to the current printer
    PWSTR           pPrinterName;   // name of current printer
    HANDLE          hModule;        // instance handle to OEM DLL
    HANDLE          hOEMHeap;       // handle to the OEM memory heap
    PDEVMODE        pPublicDM;      // public devmode
    PVOID           pOEMDM;         // OEM private devmode
    PVOID           pOEMUserData;   // pointer to OEM private data
    DWORD           dwFlags;        // misc. flag bits
    PVOID           pOemEntry;

} OEMUIPSPARAM, *POEMUIPSPARAM;

//
// OEMDevQueryPrintEx
//

BOOL APIENTRY
OEMDevQueryPrintEx(
    POEMUIOBJ           poemuiobj,
    PDEVQUERYPRINT_INFO pDQPInfo,
    PDEVMODE            pPublicDM,
    PVOID               pOEMDM
    );

//
// OEMDeviceCapabilities
//

DWORD APIENTRY
OEMDeviceCapabilities(
    POEMUIOBJ   poemuiobj,
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    PDEVMODE    pPublicDM,
    PVOID       pOEMDM,
    DWORD       dwLastResult
    );

//
// OEMUpgradePrinter
//

BOOL APIENTRY
OEMUpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo
    );

//
// OEMUpgradeRegistry
//

BOOL APIENTRY
OEMUpgradeRegistry(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo,
    PFN_DrvUpgradeRegistrySetting pfnUpgrade
    );


//
// OEMPrinterEvent
//

BOOL APIENTRY
OEMPrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam
    );

//
// OEMDriverEvent
//

BOOL APIENTRY
OEMPDriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam
    );


//
// OEMQueryColorProfile
//

BOOL APIENTRY
OEMQueryColorProfile(
    HANDLE      hPrinter,
    POEMUIOBJ   poemuiobj,
    PDEVMODE    pPublicDM,
    PVOID       pOEMDM,
    ULONG       ulQueryMode,
    VOID       *pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
    );

//
// Font Installer dialog proc
//

INT_PTR CALLBACK
OEMFontInstallerDlgProc(
    HWND    hWnd,
    UINT    usMsg,
    WPARAM  wParam,
    LPARAM  lParam
    );


BOOL CALLBACK
OEMUpdateExternalFonts(
    HANDLE  hPrinter,
    HANDLE  hHeap,
    PWSTR   pwstrCartridges
   );


#endif // !KERNEL_MODE

//
// Datatypes for attributes plugin can get by calling core driver's
// following helper functions:
//
// GetGlobalAttribute, GetFeatureAttribute, GetOptionAttribute
//

typedef enum _EATTRIBUTE_DATATYPE {

    kADT_UNKNOWN,
    kADT_BOOL,
    kADT_INT,
    kADT_LONG,
    kADT_DWORD,
    kADT_ASCII,              // NULL terminated ASCII string
    kADT_UNICODE,            // NULL terminated Unicode string
    kADT_BINARY,             // binary blob
    kADT_SIZE,
    kADT_RECT,
    kADT_CUSTOMSIZEPARAMS,   // array of CUSTOMSIZEPARAM structures

} EATTRIBUTE_DATATYPE;

//
// Data structure for storing information about PPD's *ParamCustomPageSize entries
//

#define CUSTOMPARAM_WIDTH        0
#define CUSTOMPARAM_HEIGHT       1
#define CUSTOMPARAM_WIDTHOFFSET  2
#define CUSTOMPARAM_HEIGHTOFFSET 3
#define CUSTOMPARAM_ORIENTATION  4
#define CUSTOMPARAM_MAX          5

typedef struct _CUSTOMSIZEPARAM {

    LONG    dwOrder;                // order value
    LONG    lMinVal;                // min value (in microns)
    LONG    lMaxVal;                // max value (in microns)

} CUSTOMSIZEPARAM, *PCUSTOMSIZEPARAM;

//
// constants for SetOptions helper function
//
// SetOptions flag
//

#define SETOPTIONS_FLAG_RESOLVE_CONFLICT       0x00000001
#define SETOPTIONS_FLAG_KEEP_CONFLICT          0x00000002

//
// SetOptions result code
//

#define SETOPTIONS_RESULT_NO_CONFLICT          0
#define SETOPTIONS_RESULT_CONFLICT_RESOLVED    1
#define SETOPTIONS_RESULT_CONFLICT_REMAINED    2

#ifdef __cplusplus
}
#endif

#endif  // !_PRINTOEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\publish\prntfont.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    prntfont.h

Abstract:

    Declarations for Windows NT printer driver font metrics and glyphset data
    *.UFF, *.UFM and *.GTT file data structure definition

--*/

#ifndef _PRNTFONT_H_
#define _PRNTFONT_H_



//
//
// F O N T  M E T R I C S  ( U F M )
//
//

//
// NOTE: To include this header file, it is necessary to include 
//       winddi.h, that has a definition of IFIMETRICS, FD_KERNINGPAIR
//
//


//
// UNIFM
//
// Universal printer driver (UNIDRV) font file header.
//

#define UNIFM_VERSION_1_0 0x00010000

typedef struct _UNIFM_HDR
{
    DWORD      dwSize;             // a total size of this font file
    DWORD      dwVersion;          // a version number of this font file
    ULONG      ulDefaultCodepage;  // this font's default codepage
    LONG       lGlyphSetDataRCID;  // a resource ID of GLYPHDATA
    DWORD      loUnidrvInfo;       // offset to UNIDRVINFO
    DWORD      loIFIMetrics;       // offset to IFIMETRICS
    DWORD      loExtTextMetric;    // offset to EXTTEXTMETRIC
    DWORD      loWidthTable;       // offset to WIDTHTABLE
    DWORD      loKernPair;         // offset to KERNPAIR
    DWORD      dwReserved[2];
} UNIFM_HDR, *PUNIFM_HDR;

#define GET_UNIDRVINFO(pUFM)    \
        ((PUNIDRVINFO)((PBYTE)(pUFM) + (pUFM)->loUnidrvInfo))
#define GET_IFIMETRICS(pUFM)    \
        ((IFIMETRICS*)((PBYTE)(pUFM) + (pUFM)->loIFIMetrics))
#define GET_EXTTEXTMETRIC(pUFM) \
        ((EXTTEXTMETRIC*)((PBYTE)(pUFM) + (pUFM)->loExtTextMetric))
#define GET_WIDTHTABLE(pUFM)    \
        ((PWIDTHTABLE)((PBYTE)(pUFM) + (pUFM)->loWidthTable))
#define GET_KERNDATA(pUFM)      \
        ((PKERNDATA)((PBYTE)(pUFM) + (pUFM)->loKernPair))

//
// UNIDRVINFO
//
// UNIDRVINFO is used to define printer specific information.
//

typedef struct _INVOC {
        DWORD  dwCount;     // the number of bytes in the invocation string
        DWORD  loOffset;    // byte-offset to the beginning of the array
} INVOC, *PINVOC;

typedef struct _UNIDRVINFO
{
    DWORD   dwSize;
    DWORD   flGenFlags;
    WORD    wType;
    WORD    fCaps;
    WORD    wXRes;
    WORD    wYRes;
    short   sYAdjust;
    short   sYMoved;
    WORD    wPrivateData; 
    short   sShift; 
    INVOC   SelectFont;
    INVOC   UnSelectFont;
    WORD    wReserved[4];
}  UNIDRVINFO, *PUNIDRVINFO;

#define GET_SELECT_CMD(pUni)    \
        ((PCHAR)(pUni) + (pUni)->SelectFont.loOffset)
#define GET_UNSELECT_CMD(pUni)  \
        ((PCHAR)(pUni) + (pUni)->UnSelectFont.loOffset)

//
// flGenFlags
//

#define UFM_SOFT        0x00000001 // Softfont, thus needs downloading 
#define UFM_CART        0x00000002 // This is a cartridge font
#define UFM_SCALABLE    0x00000004 // Font is scalable

//
// wType
//

#define DF_TYPE_HPINTELLIFONT         0     // HP's Intellifont
#define DF_TYPE_TRUETYPE              1     // HP's PCLETTO fonts on LJ4
#define DF_TYPE_PST1                  2     // Lexmark PPDS scalable fonts
#define DF_TYPE_CAPSL                 3     // Canon CAPSL scalable fonts
#define DF_TYPE_OEM1                  4     // OEM scalable font type 1
#define DF_TYPE_OEM2                  5     // OEM scalable font type 2

//
// fCaps
//

#define DF_NOITALIC             0x0001  // Cannot italicize via FONTSIMULATION
#define DF_NOUNDER              0x0002  // Cannot underline via FONTSIMULATION
#define DF_XM_CR                0x0004  // send CR after using this font
#define DF_NO_BOLD              0x0008  // Cannot bold via FONTSIMULATION
#define DF_NO_DOUBLE_UNDERLINE  0x0010  // Cannot double underline via 
                                        // FONTSIMU ATION
#define DF_NO_STRIKETHRU        0x0020  // Cannot strikethru via FONTSIMULATION
#define DF_BKSP_OK              0x0040  // Can use backspace char, see spec 
                                        // for details

//
// EXTTEXTMETRIC
//
// The EXTTEXTMETRIC structure provides extended-metric information for a font. 
// All the measurements are given in the specified units, 
// regardless of the current mapping mode of the display context.
//

#ifndef _EXTTEXTMETRIC_
#define _EXTTEXTMETRIC_

typedef struct _EXTTEXTMETRIC
    {
    short   emSize;
    short   emPointSize;
    short   emOrientation;
    short   emMasterHeight;
    short   emMinScale;
    short   emMaxScale;
    short   emMasterUnits;
    short   emCapHeight;
    short   emXHeight;
    short   emLowerCaseAscent;
    short   emLowerCaseDescent;
    short   emSlant;
    short   emSuperScript;
    short   emSubScript;
    short   emSuperScriptSize;
    short   emSubScriptSize;
    short   emUnderlineOffset;
    short   emUnderlineWidth;
    short   emDoubleUpperUnderlineOffset;
    short   emDoubleLowerUnderlineOffset;
    short   emDoubleUpperUnderlineWidth;
    short   emDoubleLowerUnderlineWidth;
    short   emStrikeOutOffset;
    short   emStrikeOutWidth;
    WORD    emKernPairs;
    WORD    emKernTracks;
} EXTTEXTMETRIC, *PEXTTEXTMETRIC;

#endif // _EXTTEXTMETRIC_


//
// WIDTHTABLE
//
// This data structure represents the character width table. 
// This width table is a continuous GLYPHHANDLE base, 
// not Unicode nor codepage/character code base. 
// GLYPHANDLE information is in the GLYPHDATA.
//

typedef struct _WIDTHRUN
{
    WORD    wStartGlyph;       // index of the first glyph handle
    WORD    wGlyphCount;       // number of glyphs covered
    DWORD   loCharWidthOffset; // glyph width table
} WIDTHRUN, *PWIDTHRUN;

typedef struct _WIDTHTABLE
{
    DWORD   dwSize;        // the size of this structure including every run
    DWORD   dwRunNum;      // the number of widthrun
    WIDTHRUN WidthRun[1];  // width run array
} WIDTHTABLE, *PWIDTHTABLE;

//
// The array has wGlyphCount elements and each element is the char width 
// for a single glyph. The first width corresponds to glyph index wStartGlyph 
// and so on. The byte offset is relative to the beginning of WIDTHTABLE
// structure and must be WORD-aligned.
// In case of Western device font, proportional font has all varibal pitch
// characters. This means that dwRunNum is set to 1 and loCharWidthOffset
// would be an offset from the top of WIDTHTABLE to a width vector of all 
// characters.
// In case of Far Eastern device font, basically IFIMETRICS.fwdAveCharWidth and
// IFIMETRICS.fwdMaxCharWidth are used for single byte and double byte character
// width. If a font is proportional, a UFM has a WIDTHTABLE which represents
// only the proportional pitch characters. Other characters use fdwAveCharWidth
// and fwdMaxCharInc for single and double byte characters.
//

//
// KERNDATA
// This data structure represents kerning pair information.
// This kerning pair table is a Unicode base.
//

typedef struct _KERNDATA
{
    DWORD dwSize;               // the size of this structure including array
    DWORD dwKernPairNum;        // the number of kerning pair
    FD_KERNINGPAIR KernPair[1]; // FD_KERNINGPAIR array
} KERNDATA, *PKERNDATA;



//
//
// G L Y P H  S E T D A T A  ( G T T )
//
//

//
// UNI_GLYPHSETDATA
//
// GLYPHSETDATA data structure represents a character encoding information 
// of printer device font. 
//

typedef struct _UNI_GLYPHSETDATA {
        DWORD   dwSize;
        DWORD   dwVersion;
        DWORD   dwFlags;
        LONG    lPredefinedID;
        DWORD   dwGlyphCount;
        DWORD   dwRunCount;
        DWORD   loRunOffset;
        DWORD   dwCodePageCount;
        DWORD   loCodePageOffset;
        DWORD   loMapTableOffset;
        DWORD   dwReserved[2];
} UNI_GLYPHSETDATA, *PUNI_GLYPHSETDATA;

#define UNI_GLYPHSETDATA_VERSION_1_0    0x00010000

#define GET_GLYPHRUN(pGTT)     \
    ((PGLYPHRUN) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loRunOffset))
#define GET_CODEPAGEINFO(pGTT) \
    ((PUNI_CODEPAGEINFO) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loCodePageOffset))
#define GET_MAPTABLE(pGTT) \
    ((PMAPTABLE) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loMapTableOffset))

//
// UNI_CODEPAGEINFO
//
// This UNI_CODEPAGEINFO dats structure has a list of Codepage values 
// which are supported by this UNI_GLYPHSETDATA.
//

typedef struct _UNI_CODEPAGEINFO {
    DWORD dwCodePage;
    INVOC SelectSymbolSet;
    INVOC UnSelectSymbolSet;
} UNI_CODEPAGEINFO, *PUNI_CODEPAGEINFO;

//
// GLYPHRUN
//
// GLYPHRUN dats structure represents the conversion table from Unicode to 
// UNI_GLYPHSETDATA specific glyph handle. Glyph handle is continuous number 
// starting from zero.
//

typedef struct _GLYPHRUN {
    WCHAR   wcLow;
    WORD    wGlyphCount;
} GLYPHRUN, *PGLYPHRUN;


//
// MAPTABLE and TRANSDATA
//
// This MAPTABLE data structure represents a conversion table fron glyph handle
// to codepage/character code.
//

typedef struct _TRANSDATA {
    BYTE  ubCodePageID; // Codepage index to CODEPAGENFO data structure array
    BYTE  ubType;       // a type of TRANSDATA
    union
    {
        SHORT   sCode;
        BYTE    ubCode;
        BYTE    ubPairs[2];
    } uCode;
} TRANSDATA, *PTRANSDATA;

typedef struct _MAPTABLE {
    DWORD     dwSize;     // the size of MAPTABLE including TRANSDATA array
    DWORD     dwGlyphNum; // the number of glyphs supported in MAPTABLE
    TRANSDATA Trans[1];   // an array of TRANSDATA
} MAPTABLE, *PMAPTABLE;

//
// ubType flags
//
// One of following three can be specified for the type of uCode.
//

#define MTYPE_FORMAT_MASK 0x07
#define MTYPE_COMPOSE   0x01 // wCode is an array of 16-bit offsets from the
                             // beginning of the MAPTABLE pointing to the
                             // strings to use for translation.
                             // bData representes thelength of the translated
                             // string.
#define MTYPE_DIRECT    0x02 // wCode is a byte data of one-to-one translation
#define MTYPE_PAIRED    0x04 // wCode contains a word data to emit.

//
// One of following tow can be specified for Far East multibyte character.
//

#define MTYPE_DOUBLEBYTECHAR_MASK   0x18
#define MTYPE_SINGLE    0x08 // wCode contains a single byte character code in
                             // multi byte character string.
#define MTYPE_DOUBLE    0x10 // wCode contains a double byte character code in
                             // multi byte character string.
//
// One of following three can be specified for replace/add/disable system 
// predefined GTT.
//

#define MTYPE_PREDEFIN_MASK   0xe0
#define MTYPE_REPLACE   0x20 // wCode contains a data to replace predefined one.
#define MTYPE_ADD       0x40 // wCode contains a data to add to predefiend one.
#define MTYPE_DISABLE   0x80 // wCode contains a data to remove from predefined.


//
// System predefined character conversion
//
// UNIDRV is going to support  following system predefined character conversion.
// By speciffying these number in UNIFM.dwGlyphSetDataRCID;
//

#define CC_NOPRECNV 0x0000FFFF // Not use predefined

//
// ANSI
//
#define CC_DEFAULT  0 // Default Character Conversion
#define CC_CP437   -1 // Unicode to IBM Codepage 437
#define CC_CP850   -2 // Unicode to IBM Codepage 850
#define CC_CP863   -3 // Unicode to IBM Codepage 863

//
// Far East
//

#define CC_BIG5     -10 // Unicode to Chinese Big 5. Codepage 950.
#define CC_ISC      -11 // Unicode to Korean Industrial Standard. Codepage 949.
#define CC_JIS      -12 // Unicode to JIS X0208. Codepage 932.
#define CC_JIS_ANK  -13 // Unicode to JIS X0208 except ANK. Codepage 932.
#define CC_NS86     -14 // Big-5 to National Standstand conversion. Codepage 950
#define CC_TCA      -15 // Big-5 to Taipei Computer Association. Codepage 950.
#define CC_GB2312   -16 // Unicode to GB2312. Codepage 936
#define CC_SJIS     -17 // Unicode to Shift-JIS. Codepage 932.
#define CC_WANSUNG  -18 // Unicode to Extented Wansung. Codepage 949.


//
//
// U N I V E R S A L  F O N T  F O R M A T  ( U F F )
//
//

//
// Font file header
//

typedef struct _UFF_FILEHEADER {
    DWORD       dwSignature;            // File magic number
    DWORD       dwVersion;              // UFF file format version number
    DWORD       dwSize;                 // Size of this structure

    DWORD       nFonts;                 // Count of fonts in directory
    DWORD       nGlyphSets;             // Count of glyph set data
    DWORD       nVarData;               // Count of variable data

    DWORD       offFontDir;             // Offset of font directory
    DWORD       dwFlags;                // Miscellaneous flags
    DWORD       dwReserved[4];          // Reserved, set to zero
} UFF_FILEHEADER, *PUFF_FILEHEADER;

//
// Values used in the file header
//

#define UFF_FILE_MAGIC      '1FFU'
#define UFF_VERSION_NUMBER  0x00010001

#define FONT_DIR_SORTED     0x00000001

//
// Font directory structure
//

typedef struct _UFF_FONTDIRECTORY {
    DWORD       dwSignature;            // Signature of font metrics record
    WORD        wSize;                  // Size of this structure
    WORD        wFontID;                // Unique font ID
    SHORT       sGlyphID;               // Associated glyph ID. 0 is default.
                                        // -ve values are predefined IDs
    WORD        wFlags;                 // Miscellaneous flags
    DWORD       dwInstallerSig;         // Signature of installer that installed this font
    DWORD       offFontName;            // Offset to name of font
    DWORD       offCartridgeName;       // Offset to name of font cartridge
    DWORD       offFontData;            // Offset to font data record
    DWORD       offGlyphData;           // Offset to glyph set data
    DWORD       offVarData;             // Offset to softfont data
} UFF_FONTDIRECTORY, *PUFF_FONTDIRECTORY;

#define FONT_REC_SIG            'CERF'  // font metrics record signature

#define WINNT_INSTALLER_SIG     'IFTN'  // NT font installer

//
// Flags used in font directory
//

#define FONT_FL_UFM             0x0001
#define FONT_FL_IFI             0x0002
#define FONT_FL_SOFTFONT        0x0004
#define FONT_FL_PERMANENT_SF    0x0008
#define FONT_FL_DEVICEFONT      0x0010
#define FONT_FL_GLYPHSET_GTT    0x0020
#define FONT_FL_GLYPHSET_RLE    0x0040
#define FONT_FL_RESERVED        0x8000

//
// Data header
//

typedef struct _DATA_HEADER {
    DWORD       dwSignature;            // Signature of data type
    WORD        wSize;                  // Size of this structure
    WORD        wDataID;                // Identifier number for data
    DWORD       dwDataSize;             // Size of data excluding structure
    DWORD       dwReserved;             // Reserved, set to zero
} DATA_HEADER, *PDATA_HEADER;

//
// Data signatures
//

#define DATA_UFM_SIG        'MFUD'
#define DATA_IFI_SIG        'IFID'
#define DATA_GTT_SIG        'TTGD'
#define DATA_CTT_SIG        'TTCD'
#define DATA_VAR_SIG        'RAVD'

//
// Structure passed to font installer dialog proc through LPARAM
//

typedef struct _OEMFONTINSTPARAM {
    DWORD   cbSize;
    HANDLE  hPrinter;
    HANDLE  hModule;
    HANDLE  hHeap;
    DWORD   dwFlags;
    PWSTR   pFontInstallerName;
} OEMFONTINSTPARAM, *POEMFONTINSTPARAM;

#define FG_CANCHANGE        0x00080    // Have access to change data

#define WM_FI_FILENAME      900        // To get the font installer name.



#endif //_PRNTFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\publish\winsplp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    WinSplp.h

Abstract:

    Internal Header file for Print APIs

Author:

Revision History:

--*/

#ifndef _WINSPLP_
#define _WINSPLP_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


#define PRINTER_NOTIFY_STATUS_ENDPOINT 1
#define PRINTER_NOTIFY_STATUS_POLL     2
#define PRINTER_NOTIFY_STATUS_INFO     4


#define ROUTER_UNKNOWN      0
#define ROUTER_SUCCESS      1
#define ROUTER_STOP_ROUTING 2

#ifndef __ATTRIBUTE_INFO_3__
#define __ATTRIBUTE_INFO_3__
typedef struct _ATTRIBUTE_INFO_3 {
    DWORD    dwJobNumberOfPagesPerSide;
    DWORD    dwDrvNumberOfPagesPerSide;
    DWORD    dwNupBorderFlags;
    DWORD    dwJobPageOrderFlags;
    DWORD    dwDrvPageOrderFlags;
    DWORD    dwJobNumberOfCopies;
    DWORD    dwDrvNumberOfCopies;
    DWORD    dwColorOptimization;           // Added for monochrome optimization
    short    dmPrintQuality;                // Added for monochrome optimization
    short    dmYResolution;                 // Added for monochrome optimization
} ATTRIBUTE_INFO_3, *PATTRIBUTE_INFO_3;

#endif

typedef struct _PRINTER_NOTIFY_INIT {
    DWORD Size;
    DWORD Reserved;
    DWORD PollTime;
} PRINTER_NOTIFY_INIT, *PPRINTER_NOTIFY_INIT, *LPPRINTER_NOTIFY_INIT;

typedef struct _SPLCLIENT_INFO_1{
    DWORD       dwSize;
    LPWSTR      pMachineName;
    LPWSTR      pUserName;
    DWORD       dwBuildNum;
    DWORD       dwMajorVersion;
    DWORD       dwMinorVersion;
    WORD        wProcessorArchitecture;
} SPLCLIENT_INFO_1, *PSPLCLIENT_INFO_1, *LPSPLCLIENT_INFO_1;

// This definition is used in the private spooler RPC interface (RpcSplOpenPrinter)
// The handle returned in the struct is the Server Side hPrinter which will used in
// making direct API calls from the client to the server side w/o the overhead of
// RPC. The performance boost is observed mainly in calls to Read/WritePrinter made from
// within the spooler (gdi32.dll during playback)
//
//
typedef struct _SPLCLIENT_INFO_2{

#ifdef _WIN64
    DWORD64 hSplPrinter;      // Server side handle to be used for direct calls
#else
    DWORD32 hSplPrinter;      // Server side handle to be used for direct calls
#endif

} SPLCLIENT_INFO_2, *PSPLCLIENT_INFO_2, *LPSPLCLIENT_INFO_2;

typedef struct _PRINTPROVIDOR {

   BOOL (*fpOpenPrinter)(LPWSTR   pPrinterName,
                         LPHANDLE phPrinter,
                         LPPRINTER_DEFAULTS pDefault);

   BOOL (*fpSetJob)(HANDLE hPrinter,
                    DWORD JobId,
                    DWORD Level,
                    LPBYTE pJob,
                    DWORD Command);

   BOOL (*fpGetJob)(HANDLE   hPrinter,
                    DWORD    JobId,
                    DWORD    Level,
                    LPBYTE   pJob,
                    DWORD    cbBuf,
                    LPDWORD  pcbNeeded);

   BOOL (*fpEnumJobs)(HANDLE  hPrinter,
                      DWORD   FirstJob,
                      DWORD   NoJobs,
                      DWORD   Level,
                      LPBYTE  pJob,
                      DWORD   cbBuf,
                      LPDWORD pcbNeeded,
                      LPDWORD pcReturned);

   HANDLE (*fpAddPrinter)(LPWSTR  pName,
                          DWORD   Level,
                          LPBYTE  pPrinter);

   BOOL (*fpDeletePrinter)(HANDLE   hPrinter);

   BOOL (*fpSetPrinter)(HANDLE  hPrinter,
                        DWORD   Level,
                        LPBYTE  pPrinter,
                        DWORD   Command);

   BOOL (*fpGetPrinter)(HANDLE  hPrinter,
                        DWORD   Level,
                        LPBYTE  pPrinter,
                        DWORD   cbBuf,
                        LPDWORD pcbNeeded);

   BOOL (*fpEnumPrinters)(DWORD   Flags,
                          LPWSTR  Name,
                          DWORD   Level,
                          LPBYTE  pPrinterEnum,
                          DWORD   cbBuf,
                          LPDWORD pcbNeeded,
                          LPDWORD pcReturned);

   BOOL (*fpAddPrinterDriver)(LPWSTR  pName,
                              DWORD   Level,
                              LPBYTE  pDriverInfo);

   BOOL (*fpEnumPrinterDrivers)(LPWSTR  pName,
                                LPWSTR  pEnvironment,
                                DWORD   Level,
                                LPBYTE  pDriverInfo,
                                DWORD   cbBuf,
                                LPDWORD pcbNeeded,
                                LPDWORD pcReturned);

   BOOL (*fpGetPrinterDriver)(HANDLE  hPrinter,
                              LPWSTR  pEnvironment,
                              DWORD   Level,
                              LPBYTE  pDriverInfo,
                              DWORD   cbBuf,
                              LPDWORD pcbNeeded);

   BOOL (*fpGetPrinterDriverDirectory)(LPWSTR  pName,
                                       LPWSTR  pEnvironment,
                                       DWORD   Level,
                                       LPBYTE  pDriverDirectory,
                                       DWORD   cbBuf,
                                       LPDWORD pcbNeeded);

   BOOL (*fpDeletePrinterDriver)(LPWSTR   pName,
                                 LPWSTR   pEnvironment,
                                 LPWSTR   pDriverName);

   BOOL (*fpAddPrintProcessor)(LPWSTR  pName,
                               LPWSTR  pEnvironment,
                               LPWSTR  pPathName,
                               LPWSTR  pPrintProcessorName);

   BOOL (*fpEnumPrintProcessors)(LPWSTR  pName,
                                 LPWSTR  pEnvironment,
                                 DWORD   Level,
                                 LPBYTE  pPrintProcessorInfo,
                                 DWORD   cbBuf,
                                 LPDWORD pcbNeeded,
                                 LPDWORD pcReturned);

   BOOL (*fpGetPrintProcessorDirectory)(LPWSTR  pName,
                                        LPWSTR  pEnvironment,
                                        DWORD   Level,
                                        LPBYTE  pPrintProcessorInfo,
                                        DWORD   cbBuf,
                                        LPDWORD pcbNeeded);

   BOOL (*fpDeletePrintProcessor)(LPWSTR  pName,
                                  LPWSTR  pEnvironment,
                                  LPWSTR  pPrintProcessorName);

   BOOL (*fpEnumPrintProcessorDatatypes)(LPWSTR  pName,
                                         LPWSTR  pPrintProcessorName,
                                         DWORD   Level,
                                         LPBYTE  pDataypes,
                                         DWORD   cbBuf,
                                         LPDWORD pcbNeeded,
                                         LPDWORD pcReturned);

   DWORD (*fpStartDocPrinter)(HANDLE  hPrinter,
                             DWORD   Level,
                             LPBYTE  pDocInfo);

   BOOL (*fpStartPagePrinter)(HANDLE  hPrinter);

   BOOL (*fpWritePrinter)(HANDLE  hPrinter,
                          LPVOID  pBuf,
                          DWORD   cbBuf,
                          LPDWORD pcWritten);

   BOOL (*fpEndPagePrinter)(HANDLE   hPrinter);

   BOOL (*fpAbortPrinter)(HANDLE   hPrinter);

   BOOL (*fpReadPrinter)(HANDLE  hPrinter,
                         LPVOID  pBuf,
                         DWORD   cbBuf,
                         LPDWORD pNoBytesRead);

   BOOL (*fpEndDocPrinter)(HANDLE   hPrinter);

   BOOL (*fpAddJob)(HANDLE  hPrinter,
                    DWORD   Level,
                    LPBYTE  pData,
                    DWORD   cbBuf,
                    LPDWORD pcbNeeded);

   BOOL (*fpScheduleJob)(HANDLE  hPrinter,
                         DWORD   JobId);

   DWORD (*fpGetPrinterData)(HANDLE   hPrinter,
                             LPWSTR   pValueName,
                             LPDWORD  pType,
                             LPBYTE   pData,
                             DWORD    nSize,
                             LPDWORD  pcbNeeded);

   DWORD (*fpSetPrinterData)(HANDLE  hPrinter,
                             LPWSTR  pValueName,
                             DWORD   Type,
                             LPBYTE  pData,
                             DWORD   cbData);

   DWORD (*fpWaitForPrinterChange)(HANDLE hPrinter, DWORD Flags);

   BOOL (*fpClosePrinter)(HANDLE hPrinter);

   BOOL (*fpAddForm)(HANDLE  hPrinter,
                     DWORD   Level,
                     LPBYTE  pForm);

   BOOL (*fpDeleteForm)(HANDLE  hPrinter,
                        LPWSTR  pFormName);

   BOOL (*fpGetForm)(HANDLE  hPrinter,
                     LPWSTR  pFormName,
                     DWORD   Level,
                     LPBYTE  pForm,
                     DWORD   cbBuf,
                     LPDWORD pcbNeeded);

   BOOL (*fpSetForm)(HANDLE  hPrinter,
                     LPWSTR  pFormName,
                     DWORD   Level,
                     LPBYTE  pForm);

   BOOL (*fpEnumForms)(HANDLE  hPrinter,
                       DWORD   Level,
                       LPBYTE  pForm,
                       DWORD   cbBuf,
                       LPDWORD pcbNeeded,
                       LPDWORD pcReturned);

   BOOL (*fpEnumMonitors)(LPWSTR  pName,
                          DWORD   Level,
                          LPBYTE  pMonitors,
                          DWORD   cbBuf,
                          LPDWORD pcbNeeded,
                          LPDWORD pcReturned);

   BOOL (*fpEnumPorts)(LPWSTR  pName,
                       DWORD   Level,
                       LPBYTE  pPorts,
                       DWORD   cbBuf,
                       LPDWORD pcbNeeded,
                       LPDWORD pcReturned);

   BOOL (*fpAddPort)(LPWSTR  pName,
                     HWND    hWnd,
                     LPWSTR  pMonitorName);

   BOOL (*fpConfigurePort)(LPWSTR  pName,
                           HWND    hWnd,
                           LPWSTR  pPortName);

   BOOL (*fpDeletePort)(LPWSTR  pName,
                        HWND    hWnd,
                        LPWSTR  pPortName);

   HANDLE (*fpCreatePrinterIC)(HANDLE  hPrinter,
                               LPDEVMODEW   pDevMode);

   BOOL (*fpPlayGdiScriptOnPrinterIC)(HANDLE  hPrinterIC,
                                      LPBYTE  pIn,
                                      DWORD   cIn,
                                      LPBYTE  pOut,
                                      DWORD   cOut,
                                      DWORD   ul);

   BOOL (*fpDeletePrinterIC)(HANDLE  hPrinterIC);

   BOOL (*fpAddPrinterConnection)(LPWSTR  pName);

   BOOL (*fpDeletePrinterConnection)(LPWSTR pName);

   DWORD (*fpPrinterMessageBox)(HANDLE  hPrinter,
                                DWORD   Error,
                                HWND    hWnd,
                                LPWSTR  pText,
                                LPWSTR  pCaption,
                                DWORD   dwType);

   BOOL (*fpAddMonitor)(LPWSTR  pName,
                        DWORD   Level,
                        LPBYTE  pMonitorInfo);

   BOOL (*fpDeleteMonitor)(LPWSTR  pName,
                           LPWSTR  pEnvironment,
                           LPWSTR  pMonitorName);

   BOOL (*fpResetPrinter)(HANDLE hPrinter,
                          LPPRINTER_DEFAULTS pDefault);

   BOOL (*fpGetPrinterDriverEx)(HANDLE  hPrinter,
                              LPWSTR  pEnvironment,
                              DWORD   Level,
                              LPBYTE  pDriverInfo,
                              DWORD   cbBuf,
                              LPDWORD pcbNeeded,
                              DWORD   dwClientMajorVersion,
                              DWORD   dwClientMinorVersion,
                              PDWORD  pdwServerMajorVersion,
                              PDWORD  pdwServerMinorVersion);

   BOOL (*fpFindFirstPrinterChangeNotification)(
            HANDLE hPrinter,
            DWORD fdwFlags,
            DWORD fdwOptions,
            HANDLE hNotify,
            PDWORD pfdwStatus,
            PVOID pPrinterNotifyOptions,
            PVOID pPrinterNotifyInit);

   BOOL (*fpFindClosePrinterChangeNotification)(HANDLE hPrinter);


   BOOL (*fpAddPortEx)(LPWSTR   pName,
                       DWORD    Level,
                       LPBYTE   lpBuffer,
                       LPWSTR   lpMonitorName);

   BOOL (*fpShutDown)(LPVOID pvReserved);

   BOOL (*fpRefreshPrinterChangeNotification)(HANDLE hPrinter,
                                              DWORD  Reserved,
                                              PVOID pvReserved,
                                              PVOID pPrinterNotifyInfo);

   BOOL (*fpOpenPrinterEx)(LPWSTR     pPrinterName,
                           LPHANDLE   phPrinter,
                           LPPRINTER_DEFAULTS pDefault,
                           LPBYTE     pClientInfo,
                           DWORD      Level);

   HANDLE (*fpAddPrinterEx)(LPWSTR  pName,
                            DWORD   Level,
                            LPBYTE  pPrinter,
                            LPBYTE  pClientInfo,
                            DWORD   ClientInfoLevel);

   BOOL (*fpSetPort)(LPWSTR     pName,
                     LPWSTR     pPortName,
                     DWORD      Level,
                     LPBYTE     pPortInfo);

   DWORD (*fpEnumPrinterData)(HANDLE   hPrinter,
                              DWORD    dwIndex,
                              LPWSTR   pValueName,
                              DWORD    cbValueName,
                              LPDWORD  pcbValueName,
                              LPDWORD  pType,
                              LPBYTE   pData,
                              DWORD    cbData,
                              LPDWORD  pcbData);

   DWORD (*fpDeletePrinterData)(HANDLE   hPrinter,
                                LPWSTR   pValueName);

   DWORD (*fpClusterSplOpen)( LPCTSTR pszServer,
                              LPCTSTR pszResource,
                              PHANDLE phSpooler,
                              LPCTSTR pszName,
                              LPCTSTR pszAddress );


   DWORD (*fpClusterSplClose)( HANDLE hSpooler );

   DWORD (*fpClusterSplIsAlive)( HANDLE hSpooler );

   DWORD (*fpSetPrinterDataEx)(  HANDLE  hPrinter,
                                 LPCWSTR pKeyName,
                                 LPCWSTR pValueName,
                                 DWORD   Type,
                                 LPBYTE  pData,
                                 DWORD   cbData);

   DWORD (*fpGetPrinterDataEx)(HANDLE   hPrinter,
                               LPCWSTR  pKeyName,
                               LPCWSTR  pValueName,
                               LPDWORD  pType,
                               LPBYTE   pData,
                               DWORD    nSize,
                               LPDWORD  pcbNeeded);

   DWORD (*fpEnumPrinterDataEx)(  HANDLE  hPrinter,
                                  LPCWSTR pKeyName,
                                  LPBYTE  pEnumValues,
                                  DWORD   cbEnumValues,
                                  LPDWORD pcbEnumValues,
                                  LPDWORD pnEnumValues);

   DWORD (*fpEnumPrinterKey)( HANDLE   hPrinter,
                              LPCWSTR  pKeyName,
                              LPWSTR   pSubkey,
                              DWORD    cbSubkey,
                              LPDWORD  pcbSubkey);

   DWORD (*fpDeletePrinterDataEx)(  HANDLE  hPrinter,
                                    LPCWSTR pKeyName,
                                    LPCWSTR pValueName);

   DWORD (*fpDeletePrinterKey)(  HANDLE  hPrinter,
                                 LPCWSTR pKeyName);

   BOOL (*fpSeekPrinter)( HANDLE hPrinter,
                          LARGE_INTEGER liDistanceToMove,
                          PLARGE_INTEGER pliNewPointer,
                          DWORD dwMoveMethod,
                          BOOL bWrite );

   BOOL (*fpDeletePrinterDriverEx)(LPWSTR   pName,
                                   LPWSTR   pEnvironment,
                                   LPWSTR   pDriverName,
                                   DWORD    dwDeleteFlag,
                                   DWORD    dwVersionNum);

   BOOL (*fpAddPerMachineConnection)(LPCWSTR    pServer,
                                     LPCWSTR    pPrinterName,
                                     LPCWSTR    pPrintServer,
                                     LPCWSTR    pProvider);

   BOOL (*fpDeletePerMachineConnection)(LPCWSTR   pServer,
                                        LPCWSTR   pPrinterName);

   BOOL (*fpEnumPerMachineConnections)(LPCWSTR    pServer,
                                       LPBYTE     pPrinterEnum,
                                       DWORD      cbBuf,
                                       LPDWORD    pcbNeeded,
                                       LPDWORD    pcReturned);

   BOOL (*fpXcvData)(   HANDLE  hXcv,
                        LPCWSTR pszDataName,
                        PBYTE   pInputData,
                        DWORD   cbInputData,
                        PBYTE   pOutputData,
                        DWORD   cbOutputData,
                        PDWORD  pcbOutputNeeded,
                        PDWORD  pdwStatus
                        );

   BOOL (*fpAddPrinterDriverEx)(LPWSTR  pName,
                                DWORD   Level,
                                LPBYTE  pDriverInfo,
                                DWORD   dwFileCopyFlags);

   BOOL (*fpSplReadPrinter)(HANDLE hPrinter,
                            LPBYTE *pBuf,
                            DWORD  cbBuf);

   BOOL (*fpDriverUnloadComplete)(LPWSTR  pDriverFile);

   BOOL (*fpGetSpoolFileInfo)(HANDLE    hPrinter,
                              LPWSTR    *pSpoolDir,
                              LPHANDLE  phFile,
                              HANDLE    hSpoolerProcess,
                              HANDLE    hAppProcess);

   BOOL (*fpCommitSpoolData)(HANDLE  hPrinter,
                             DWORD   cbCommit);

   BOOL (*fpCloseSpoolFileHandle)(HANDLE  hPrinter);

   BOOL (*fpFlushPrinter)(HANDLE  hPrinter,
                          LPBYTE  pBuf,
                          DWORD   cbBuf,
                          LPDWORD pcWritten,
                          DWORD   cSleep);
   DWORD (*fpSendRecvBidiData)(HANDLE                    hPrinter,
                               LPCWSTR                   pAction,
                               PBIDI_REQUEST_CONTAINER   pReqData,
                               PBIDI_RESPONSE_CONTAINER* ppResData);

   BOOL (*fpAddDriverCatalog)(HANDLE  hPrinter,
                              DWORD   dwLevel,
                              VOID    *pvDriverInfCatInfo,
                              DWORD   dwCatalogCopyFlags);

} PRINTPROVIDOR, *LPPRINTPROVIDOR;

BOOL
InitializePrintProvidor(
   LPPRINTPROVIDOR  pPrintProvidor,
   DWORD    cbPrintProvidor,
   LPWSTR   pFullRegistryPath
);

typedef struct _PRINTPROCESSOROPENDATA {
    PDEVMODE  pDevMode;
    LPWSTR    pDatatype;
    LPWSTR    pParameters;
    LPWSTR    pDocumentName;
    DWORD     JobId;
    LPWSTR    pOutputFile;
    LPWSTR    pPrinterName;
} PRINTPROCESSOROPENDATA, *PPRINTPROCESSOROPENDATA, *LPPRINTPROCESSOROPENDATA;

HANDLE
OpenPrintProcessor(
    LPWSTR  pPrinterName,
    PPRINTPROCESSOROPENDATA pPrintProcessorOpenData
);

BOOL
PrintDocumentOnPrintProcessor(
    HANDLE  hPrintProcessor,
    LPWSTR  pDocumentName
);

BOOL
ClosePrintProcessor(
    HANDLE  hPrintProcessor
);

BOOL
ControlPrintProcessor(
    HANDLE  hPrintProcessor,
    DWORD   Command
);

DWORD
GetPrintProcessorCapabilities(
    LPTSTR   pValueName,
    DWORD    dwAttributes,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);

BOOL
GetJobAttributes(
    LPWSTR            pPrinterName,
    LPDEVMODEW        pDevmode,
    PATTRIBUTE_INFO_3 pAttributeInfo
    );

BOOL
InitializeMonitor(
    LPWSTR  pRegistryRoot
);

BOOL
OpenPort(
    LPWSTR  pName,
    PHANDLE pHandle
);

BOOL
WritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
);

BOOL
ReadPort(
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuffer,
    LPDWORD pcbRead
);

BOOL
ClosePort(
    HANDLE  hPort
);


BOOL
XcvOpenPort(
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
);

DWORD
XcvDataPort(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
);

BOOL
XcvClosePort(
    HANDLE  hXcv
);


BOOL
AddPortUI
(
    PCWSTR  pszServer,
    HWND    hWnd,
    PCWSTR  pszMonitorNameIn,
    PWSTR  *ppszPortNameOut
);

BOOL
ConfigurePortUI
(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszPortName
);

BOOL
DeletePortUI
(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszPortName
);


BOOL
SplDeleteSpoolerPortStart(
    PCWSTR pPortName
);

BOOL
SplDeleteSpoolerPortEnd(
    PCWSTR pName,
    BOOL   bDeletePort
);

typedef struct _MONITORREG {

    DWORD cbSize;

    LONG
    (WINAPI *fpCreateKey)(
        HANDLE hcKey,
        LPCTSTR pszSubKey,
        DWORD dwOptions,
        REGSAM samDesired,
        PSECURITY_ATTRIBUTES pSecurityAttributes,
        PHANDLE phckResult,
        PDWORD pdwDisposition,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpOpenKey)(
        HANDLE hcKey,
        LPCTSTR pszSubKey,
        REGSAM samDesired,
        PHANDLE phkResult,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpCloseKey)(
        HANDLE hcKey,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpDeleteKey)(
        HANDLE hcKey,
        LPCTSTR pszSubKey,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpEnumKey)(
        HANDLE hcKey,
        DWORD dwIndex,
        LPTSTR pszName,
        PDWORD pcchName,
        PFILETIME pftLastWriteTime,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpQueryInfoKey)(
        HANDLE hcKey,
        PDWORD pcSubKeys,
        PDWORD pcbKey,
        PDWORD pcValues,
        PDWORD pcbValue,
        PDWORD pcbData,
        PDWORD pcbSecurityDescriptor,
        PFILETIME pftLastWriteTime,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpSetValue)(
        HANDLE hcKey,
        LPCTSTR pszValue,
        DWORD dwType,
        const BYTE* pData,
        DWORD cbData,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpDeleteValue)(
        HANDLE hcKey,
        LPCTSTR pszValue,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpEnumValue)(
        HANDLE hcKey,
        DWORD dwIndex,
        LPTSTR pszValue,
        PDWORD pcbValue,
        PDWORD pType,
        PBYTE pData,
        PDWORD pcbData,
        HANDLE hSpooler
        );

    LONG
    (WINAPI *fpQueryValue)(
        HANDLE hcKey,
        LPCTSTR pszValue,
        PDWORD pType,
        PBYTE pData,
        PDWORD pcbData,
        HANDLE hSpooler
        );

} MONITORREG, *PMONITORREG;


typedef struct _MONITORINIT {
    DWORD cbSize;
    HANDLE hSpooler;
    HANDLE hckRegistryRoot;
    PMONITORREG pMonitorReg;
    BOOL bLocal;
    LPCWSTR pszServerName;
} MONITORINIT, *PMONITORINIT;


typedef struct _MONITOR
{
    BOOL (WINAPI *pfnEnumPorts)
    (
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    );

    BOOL (WINAPI *pfnOpenPort)
    (
    LPWSTR  pName,
    PHANDLE pHandle
    );

    BOOL (WINAPI *pfnOpenPortEx)
    (
    LPWSTR  pPortName,
    LPWSTR  pPrinterName,
    PHANDLE pHandle,
    struct _MONITOR FAR *pMonitor
    );


    BOOL (WINAPI *pfnStartDocPort)
    (
    HANDLE  hPort,
    LPWSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
    );

    BOOL (WINAPI *pfnWritePort)
    (
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
    );

    BOOL (WINAPI *pfnReadPort)
    (
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuffer,
    LPDWORD pcbRead
    );

    BOOL (WINAPI *pfnEndDocPort)
    (
    HANDLE   hPort
    );

    BOOL (WINAPI *pfnClosePort)
    (
        HANDLE  hPort
    );

    BOOL (WINAPI *pfnAddPort)
    (
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
    );

    BOOL (WINAPI *pfnAddPortEx)
    (
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   lpBuffer,
    LPWSTR   lpMonitorName
    );

    BOOL (WINAPI *pfnConfigurePort)
    (
    LPWSTR   pName,
    HWND  hWnd,
    LPWSTR pPortName
    );

    BOOL (WINAPI *pfnDeletePort)
    (
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    );

    BOOL (WINAPI *pfnGetPrinterDataFromPort)
    (
    HANDLE  hPort,
    DWORD   ControlID,
    LPWSTR  pValueName,
    LPWSTR  lpInBuffer,
    DWORD   cbInBuffer,
    LPWSTR  lpOutBuffer,
    DWORD   cbOutBuffer,
    LPDWORD lpcbReturned
    );

    BOOL (WINAPI *pfnSetPortTimeOuts)
    (
    HANDLE  hPort,
    LPCOMMTIMEOUTS lpCTO,
    DWORD   reserved    // must be set to 0
    );

    BOOL (WINAPI *pfnXcvOpenPort)
    (
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    );

    DWORD (WINAPI *pfnXcvDataPort)
    (
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    );

    BOOL (WINAPI *pfnXcvClosePort)
    (
    HANDLE  hXcv
    );


} MONITOR, FAR *LPMONITOR;

typedef struct _MONITOREX
{
    DWORD       dwMonitorSize;
    MONITOR     Monitor;

} MONITOREX, FAR *LPMONITOREX;


typedef struct _MONITOR2
{
    DWORD cbSize;
    BOOL (WINAPI *pfnEnumPorts)
    (
    HANDLE  hMonitor,
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    );

    BOOL (WINAPI *pfnOpenPort)
    (
    HANDLE  hMonitor,
    LPWSTR  pName,
    PHANDLE pHandle
    );

    BOOL (WINAPI *pfnOpenPortEx)
    (
    HANDLE  hMonitor,
    HANDLE  hMonitorPort,
    LPWSTR  pPortName,
    LPWSTR  pPrinterName,
    PHANDLE pHandle,
    struct _MONITOR2 FAR *pMonitor2
    );


    BOOL (WINAPI *pfnStartDocPort)
    (
    HANDLE  hPort,
    LPWSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
    );

    BOOL (WINAPI *pfnWritePort)
    (
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
    );

    BOOL (WINAPI *pfnReadPort)
    (
    HANDLE hPort,
    LPBYTE pBuffer,
    DWORD  cbBuffer,
    LPDWORD pcbRead
    );

    BOOL (WINAPI *pfnEndDocPort)
    (
    HANDLE   hPort
    );

    BOOL (WINAPI *pfnClosePort)
    (
    HANDLE  hPort
    );

    BOOL (WINAPI *pfnAddPort)
    (
    HANDLE   hMonitor,
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pMonitorName
    );

    BOOL (WINAPI *pfnAddPortEx)
    (
    HANDLE   hMonitor,
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   lpBuffer,
    LPWSTR   lpMonitorName
    );

    BOOL (WINAPI *pfnConfigurePort)
    (
    HANDLE  hMonitor,
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    );

    BOOL (WINAPI *pfnDeletePort)
    (
    HANDLE  hMonitor,
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    );

    BOOL (WINAPI *pfnGetPrinterDataFromPort)
    (
    HANDLE  hPort,
    DWORD   ControlID,
    LPWSTR  pValueName,
    LPWSTR  lpInBuffer,
    DWORD   cbInBuffer,
    LPWSTR  lpOutBuffer,
    DWORD   cbOutBuffer,
    LPDWORD lpcbReturned
    );

    BOOL (WINAPI *pfnSetPortTimeOuts)
    (
    HANDLE  hPort,
    LPCOMMTIMEOUTS lpCTO,
    DWORD   reserved    // must be set to 0
    );

    BOOL (WINAPI *pfnXcvOpenPort)
    (
    HANDLE  hMonitor,
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    );

    DWORD (WINAPI *pfnXcvDataPort)
    (
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    );

    BOOL (WINAPI *pfnXcvClosePort)
    (
    HANDLE  hXcv
    );

    VOID (WINAPI *pfnShutdown)
    (
    HANDLE hMonitor
    );

    DWORD (WINAPI *pfnSendRecvBidiDataFromPort)
    (
    HANDLE                    hPort,
    DWORD                     dwAccessBit,
    LPCWSTR                   pAction,
    PBIDI_REQUEST_CONTAINER   pReqData,
    PBIDI_RESPONSE_CONTAINER* ppResData
    );

} MONITOR2, *PMONITOR2, FAR *LPMONITOR2;

#define MONITOR2_SIZE_WIN2K ( sizeof(DWORD) + (sizeof(PVOID)*18) )

typedef struct _MONITORUI
{
    DWORD   dwMonitorUISize;

    BOOL (WINAPI *pfnAddPortUI)
    (
        PCWSTR pszServer,
        HWND   hWnd,
        PCWSTR pszMonitorNameIn,
        PWSTR  *ppszPortNameOut
    );

    BOOL (WINAPI *pfnConfigurePortUI)
    (
        PCWSTR  pName,
        HWND    hWnd,
        PCWSTR  pPortName
    );

    BOOL (WINAPI *pfnDeletePortUI)
    (
        PCWSTR pszServer,
        HWND   hWnd,
        PCWSTR pszPortName
    );

} MONITORUI, FAR *PMONITORUI;


HANDLE
CreatePrinterIC(
    HANDLE  hPrinter,
    LPDEVMODEW  pDevMode
);

BOOL
PlayGdiScriptOnPrinterIC(
    HANDLE  hPrinterIC,
    LPBYTE  pIn,
    DWORD   cIn,
    LPBYTE  pOut,
    DWORD   cOut,
    DWORD   ul
);

BOOL
DeletePrinterIC(
    HANDLE  hPrinterIC
);

BOOL
DevQueryPrint(
    HANDLE      hPrinter,
    LPDEVMODE   pDevMode,
    DWORD      *pResID
);

HANDLE
RevertToPrinterSelf(
    VOID
);

BOOL
ImpersonatePrinterClient(
    HANDLE  hToken
);

BOOL
ReplyPrinterChangeNotification(
    HANDLE hNotify,
    DWORD fdwFlags,
    PDWORD pdwResult,
    PVOID pPrinterNotifyInfo
);

BOOL
PartialReplyPrinterChangeNotification(
    HANDLE hNotify,
    PPRINTER_NOTIFY_INFO_DATA pInfoDataSrc
);

PPRINTER_NOTIFY_INFO
RouterAllocPrinterNotifyInfo(
    DWORD cPrinterNotifyInfoData
);

BOOL
RouterFreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo
);


PBIDI_RESPONSE_CONTAINER
RouterAllocBidiResponseContainer(
    DWORD Count
);

PVOID
RouterAllocBidiMem (
    IN size_t NumBytes
);

VOID
RouterFreeBidiMem (
    IN PVOID pMemPointer
);



#define PRINTER_NOTIFY_INFO_DATA_COMPACT 1

BOOL
AppendPrinterNotifyInfoData(
    PPRINTER_NOTIFY_INFO pInfoDest,
    PPRINTER_NOTIFY_INFO_DATA pInfoDataSrc,
    DWORD fdwFlags
);


DWORD
CallRouterFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PVOID pvReserved);

BOOL
ProvidorFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PVOID pvReserved0,
    PVOID pvReserved1);

BOOL
ProvidorFindClosePrinterChangeNotification(
    HANDLE hPrinter);



BOOL
SpoolerFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    PHANDLE phEvent,
    PVOID pPrinterNotifyOptions,
    PVOID pvReserved);

BOOL
SpoolerFindNextPrinterChangeNotification(
    HANDLE hPrinter,
    LPDWORD pfdwChange,
    PVOID pvReserved0,
    PVOID ppPrinterNotifyInfo);

VOID
SpoolerFreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pInfo);

BOOL
SpoolerFindClosePrinterChangeNotification(
    HANDLE hPrinter);

LPMONITOR2
WINAPI
InitializePrintMonitor2(
    PMONITORINIT pMonitorInit,
    PHANDLE phMonitor
);

BOOL
WINAPI
InitializeMonitorEx(
    LPWSTR      pRegistryRoot,
    LPMONITOR   pMonitor
);

LPMONITOREX
WINAPI
InitializePrintMonitor(
    LPWSTR      pRegistryRoot
);

PMONITORUI
WINAPI
InitializePrintMonitorUI(
    VOID
);


//
//  The following is added for new point-and-print support which allows
//  specific files to be associated with a print queue (instead of a printer
//  driver) using SetPrinterDataEx under the key "CopyFiles"
//
#define COPYFILE_EVENT_SET_PRINTER_DATAEX           1
#define COPYFILE_EVENT_DELETE_PRINTER               2
#define COPYFILE_EVENT_ADD_PRINTER_CONNECTION       3
#define COPYFILE_EVENT_DELETE_PRINTER_CONNECTION    4
#define COPYFILE_EVENT_FILES_CHANGED                5


BOOL
WINAPI
SpoolerCopyFileEvent(
    LPWSTR  pszPrinterName,
    LPWSTR  pszKey,
    DWORD   dwCopyFileEvent
    );

#define COPYFILE_FLAG_CLIENT_SPOOLER            0x00000001
#define COPYFILE_FLAG_SERVER_SPOOLER            0x00000002


DWORD
WINAPI
GenerateCopyFilePaths(
    IN      LPCWSTR     pszPrinterName,
    IN      LPCWSTR     pszDirectory,
    IN      LPBYTE      pSplClientInfo,
    IN      DWORD       dwLevel,
    IN OUT  LPWSTR      pszSourceDir,
    IN OUT  LPDWORD     pcchSourceDirSize,
    IN OUT  LPWSTR      pszTargetDir,
    IN OUT  LPDWORD     pcchTargetDirSize,
    IN      DWORD       dwFlags
    );


typedef enum {
    kMessageBox = 0    
} UI_TYPE;

typedef struct {
    DWORD       cbSize;     // sizeof(MESSAGEBOX_PARAMS)
    LPWSTR      pTitle;     // Pointer to a null-terminated string for the title bar of the message box.
    LPWSTR      pMessage;   // Pointer to a null-terminated string containing the message to display. 	
    DWORD       Style;      // Specifies the contents and behavior of the message box
    DWORD       dwTimeout;  // If bWait is TRUE, Timeout specifies the time, in seconds, that the function waits for the user's response.
    BOOL        bWait;      // If TRUE, SplPromptUIInUsersSession does not return until the user responds or the time-out interval elapses. 
                            // If Timeout is zero, SplPromptUIInUsersSession doesn't return until the user responds. 
                            // If FALSE, the function returns immediately and pResponse returns IDASYNC. 
 
} MESSAGEBOX_PARAMS, *PMESSAGEBOX_PARAMS;

typedef struct {

    UI_TYPE  UIType;

    union {

        MESSAGEBOX_PARAMS   MessageBoxParams;
    };
	
} SHOWUIPARAMS, *PSHOWUIPARAMS;

BOOL
SplPromptUIInUsersSession(
    IN  HANDLE          hPrinter,
    IN  DWORD           JobId,
    IN  PSHOWUIPARAMS   pUIParams,
    OUT DWORD           *pResponse
);

DWORD
SplIsSessionZero(
    IN  HANDLE  hPrinter,
    IN  DWORD   JobId,
    OUT BOOL    *pIsSessionZero
);

#ifdef __cplusplus
}                   /* End of extern "C" { */
#endif              /* __cplusplus */

#endif // _WINSPLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uienv.inc ===
##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1997-1999
#   All Rights Reserved.
#
##########################################################################

#
# Common include file 'sources' files in the imagein project.
#
#
# These definitions are required in your sources file:
#
#     FREEBUILD
#        Set by makefile.def file for you.  One of the following:
#          0      - build debug
#          1      - build retail
#
# Definitions used if defined:
#
#     CHICAGO_PRODUCT
#        Build component explicitly for the Win95 platform.  If this is
#        not defined, default is NT or both.
#
#     TARGET_BOTH
#        Build component to run on both platforms.
#
#     NO_PRIVATE_HEADERS
#        If set to 1, this is defined as a manifest constant, so the
#        stub headers in shell\inc\stubs do not include the private
#        companion headers.
#
# Environment Variables and their meanings
#
#     ATL_DEBUG_QI
#        When set to 1, debug builds will also have _ATL_DEBUG_QI
#        defined.  ATL code spews a bunch of debug stuff during QueryInterface.
#
#     ATL_DEBUG_REFCOUNT
#        When set to 1, debug builds will also have _ATL_DEBUG_REFCOUNT
#        defined.  ATL code spews a bunch of debug stuff during AddRef
#        and Release.
#
#     MAXDEBUG
#        If set to 1, then debug builds will also have MAXDEBUG defined.
#        Retail builds unaffected.  This is highly encouraged for regular
#        development purposes.  Not to be set or used by the build labs.
#
#     MEASURE_PERF
#        If set to 1, enables performance timing code for both debug and
#        retail builds.  This code squirts the timings for interesting
#        events to the debug terminal.
#

#
# As this include file is used only for user mode windows components - set
# components IDs appropriately
#
MAJORCOMP=printscan
MINORCOMP=ui



#
# Set imagedir placement correctly
#
WIA_DIR = $(PROJECT_ROOT)\wia
UI_DIR  = $(PROJECT_ROOT)\ui

!IF "$(BUILD_PRODUCT)"=="millen"
CHICAGO_PRODUCT=1
!ENDIF

#
# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
#
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

#
# Necessary for gdiplus
#
C_DEFINES=$(C_DEFINES) \
    -DDCR_USE_NEW_105760 \
    -DDCR_USE_NEW_125467 \
    -DDCR_USE_NEW_127084 \
    -DDCR_USE_NEW_135429 \
    -DDCR_USE_NEW_137252 \
    -DDCR_USE_NEW_140782 \
    -DDCR_USE_NEW_140855 \
    -DDCR_USE_NEW_140857 \
    -DDCR_USE_NEW_140861 \
    -DDCR_USE_NEW_145135 \
    -DDCR_USE_NEW_145138 \
    -DDCR_USE_NEW_145139 \
    -DDCR_USE_NEW_145804 \
    -DDCR_USE_NEW_146933 \
    -DDCR_USE_NEW_152154 \
    -DDCR_USE_NEW_168772 \
    -DDCR_USE_NEW_174340 \
    -DDCR_USE_NEW_175866 \
    -DDCR_USE_NEW_186091 \
    -DDCR_USE_NEW_186151 \
    -DDCR_USE_NEW_186764 \
    -DDCR_USE_NEW_188922 \
    -DDCR_USE_NEW_197819 \
    -DDCR_USE_NEW_202903 \
    -DDCR_USE_NEW_235072 \
    -DDCR_USE_NEW_250932 \
    -DDCR_USE_NEW_284635 \
    -DDCR_USE_NEW_284841 \
    -DDCR_USE_NEW_293849 \
    -DDCR_USE_NEW_299162


#
# Pick up the latest common controls
#
C_DEFINES=$(C_DEFINES) -DUXCTRL_VERSION=0x0100

#
# Set private paths
#
INCLUDES        = .;..;\
    $(PROJECT_ROOT)\publish\inc;\
    $(PROJECT_ROOT)\inc;\
    $(WIA_DIR)\inc;\
    $(UI_DIR)\inc;\
    $(SHELL_INC_PATH);\
    $(UI_DIR)\uicommon;\
    $(SDK_INC_PATH)\gdiplus;\
    $(PROJECT_ROOT)\inc\psutil; \
    $(WINDOWS_INC_PATH)\DUser;\
    $(INCLUDES)

#
# Set platform dependent settings
#
#  PLATFORM_SUFFIX is used for generating platform specific static libs path , a la public\sdk\lib\win98
#
!if defined(CHICAGO_PRODUCT)

NOT_UNICODE =1

# (use 'chicago' since that is already used in the NT tree)

LIBRARY_PLATFORM_PATH   = $(SDK_LIB_DEST)\chicago
ALT_PROJECT_TARGET      = chicago\$(_OBJ_DIR)
USE_MAPSYM              = 1

# Where to put static libraries
PLATFORM_SUFFIX=chicago

#
# Cheat on version for Millenium
#
WIN32_WIN95_VERSION=0x500


#
# VC5 libs not shipped yet
#
USE_MSVCRT=1
#USE_MSVCRT40=1
#USE_LIBCMT=1

#
# Indicate target is not supporting robust RPC validation
#
MIDL_NO_ROBUST=1

#
# Indicate we fully support DCOM
#
C_DEFINES       = $(C_DEFINES) -D_WIN32_DCOM
##-D_WIN32_WINDOWS

!else

#
# Require v500 to use NT5 specific APIs
#

WIN32_WINNT_VERSION=$(LATEST_WIN32_WINNT_VERSION)

LIBRARY_PLATFORM_PATH   = $(SDK_LIB_DEST)

PLATFORM_SUFFIX=.

USE_MSVCRT=1

!endif

#
# Include and lib directories private to the PrintScan project
#

PRV_INC_PATH=$(PROJECT_ROOT)\inc
!if $(386)
PRV_LIB_PATH=$(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\i386
!elseif $(IA64)
PRV_LIB_PATH=$(PROJECT_ROOT)\lib\ia64
!elseif $(AXP64)
PRV_LIB_PATH=$(PROJECT_ROOT)\lib\axp64
!elseif $(ALPHA)
PRV_LIB_PATH=$(PROJECT_ROOT)\lib\alpha
!endif

#
# Set common options
#

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1


# user mode executable type
UMTYPE          = windows

# Don't link to NTDLL if this runs on both platforms
!ifdef TARGET_BOTH
NO_NTDLL=1
!endif

#
# Additional compiler flags
#

C_DEFINES       = $(C_DEFINES) -DWIN32 -D_WIN32 -D_NTSDK

!ifdef USE_ICECAP
C_DEFINES = $(C_DEFINES) -DPRODUCT_PROF
!endif

!if !defined(CHICAGO_PRODUCT )

C_DEFINES       = $(C_DEFINES) -DNT -DWINNT

! if !defined(NOT_UNICODE)
UNICODE=1
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
! endif

!else

UNICODE=0

C_DEFINES       = $(C_DEFINES) -DWIN9X

!endif


# ------ Debug Only Defines --------


#
# make us completely self contained
#
COFFBASE_TXT_FILE=$(UI_DIR)\coffbase.txt
BINPLACE_PLACEFILE=$(UI_DIR)\placefil.txt


#
# Commonly used libraries
#
!if !defined(DONT_DO_COMMON_LIBS)
!if !defined(CHICAGO_PRODUCT)
TARGETLIBS=$(TARGETLIBS)\
        $(LIBRARY_PATH)\advapi32.lib                                \
        $(LIBRARY_PATH)\cfgmgr32.lib                                \
        $(LIBRARY_PATH)\gdi32.lib                                   \
        $(LIBRARY_PATH)\gdiplus.lib                                 \
        $(LIBRARY_PATH)\kernel32.lib                                \
        $(LIBRARY_PATH)\msimg32.lib                                 \
        $(LIBRARY_PATH)\msvcrt.lib                                  \
        $(LIBRARY_PATH)\ole32.lib                                   \
        $(LIBRARY_PATH)\oleaut32.lib                                \
        $(LIBRARY_PATH)\rpcns4.lib                                  \
        $(LIBRARY_PATH)\rpcrt4.lib                                  \
        $(LIBRARY_PATH)\setupapi.lib                                \
        $(LIBRARY_PATH)\shell32.lib                                 \
        $(LIBRARY_PATH)\shlwapi.lib                                 \
        $(LIBRARY_PATH)\sti.lib                                     \
        $(LIBRARY_PATH)\user32.lib                                  \
        $(LIBRARY_PATH)\uuid.lib                                    \
        $(LIBRARY_PATH)\winmm.lib                                   \
        $(SHELL_LIB_PATH)\shell32p.lib                              \
        $(SHELL_LIB_PATH)\shlwapip.lib                              \
        $(SDK_LIB_DEST)\$(PLATFORM_SUFFIX)\*\wiaguid.lib            \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\$(O)\psutil.lib      \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\$(O)\uicommon.lib

# people who use shfusion cannot link to comdlg32
!if !defined(USE_SHFUSION)
TARGETLIBS=$(TARGETLIBS)\
        $(LIBRARY_PATH)\comdlg32.lib
!endif

!else
TARGETLIBS=$(TARGETLIBS)\
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\cfgmgr32.lib  \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\setupapi.lib  \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\iprop.lib     \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\psutil.lib         \
        $(LIBRARY_PLATFORM_PATH)\*\ADVAPI32.lib \
        $(LIBRARY_PLATFORM_PATH)\*\KERNEL32.lib \
        $(LIBRARY_PLATFORM_PATH)\*\user32.lib   \
        $(LIBRARY_PATH)\GDI32.lib     \
        $(LIBRARY_PATH)\oleaut32.lib  \
        $(LIBRARY_PATH)\shlwapi.lib   \
        $(LIBRARY_PATH)\ole32.lib     \
        $(LIBRARY_PATH)\rpcns4.lib    \
        $(LIBRARY_PATH)\rpcrt4.lib    \
        $(LIBRARY_PATH)\uuid.lib
!endif
!endif

#
# Skip these files when determining dependencies
#
CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
                  atlbase.h  \
                  atlcom.h   \
                  atlconv.h  \
                  atlctl.h   \
                  atlctl.cpp \
                  atliface.h \
                  atlimpl.cpp \
                  atlwin.h   \
                  atlwin.cpp \
                  ia64inst.h \
                  macapi.h   \
                  macname1.h \
                  macname2.h \
                  macocidl.h \
                  macpub.h   \
                  macwin32.h \
                  mainwin.h  \
                  mwversion.h \
                  penwin.h \
                  pshpck16.h \
                  rpcerr.h   \
                  rpcmac.h   \
                  setupx.h   \
                  skbapi.h   \
                  statreg.h  \
                  statreg.cpp \
                  unixstuff.h \
                  version.h  \
                  winwlm.h   \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\annotlib\annot.h ===
#ifndef _ANNOT_H_
#define _ANNOT_H_

#include <windows.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <gdiplus.h>
using namespace Gdiplus;
#include <shimgdata.h>
// This file defines classes used to render and edit TIFF 6.0 annotations.
// These annotations are stored in tag #32932. The specification for these annotations
// is defined by Eastman Software, the spec version is 1.00.06.

#define ANNOTATION_IMAGE_TAG 32932

// These structures define the in-file layout of the annotations.
// Note that most of the structs are variable-sized.
// The annotation parser reads the annotations into these structures, wraps them in a descriptor
// and passes the descriptor to the annotation factory object to construct
// CAnnotationMark-derived classes that implement
// the rendering, editing, and saving of the different types of marks.

// MT_* used in ANNOTATIONMARK::uType
#define MT_IMAGEEMBED         1
#define MT_IMAGEREF           2
#define MT_STRAIGHTLINE       3
#define MT_FREEHANDLINE       4
#define MT_HOLLOWRECT         5
#define MT_FILLRECT           6
#define MT_TYPEDTEXT          7
#define MT_FILETEXT           8
#define MT_STAMP              9
#define MT_ATTACHANOTE       10
#define MT_FORM              11
#define MT_OCR               12 // unsupported

// ANNOTATIONMARK is fixed size and exists for every mark in the file
// We only support files with 4 byte integers
// this struct is not declared as UNALIGNED because we never typecast a variable
// as this type.
struct ANNOTATIONMARK
{
    UINT uType;                 /* The type of the mark (or operation).
                                    This will be ignored for sets.*/
    RECT lrBounds;             /* Rect in FULLSIZE units.
                                    This could be a rect or 2 points.*/
    RGBQUAD rgbColor1;          /* This is the main color. (Example: This is the
                                    color of all lines, rects, and stand alone
                                    text.*/
    RGBQUAD rgbColor2;          /* This is the secondary color. (Example: This
                                    is the color of the text of an ATTACH_A_NOTE.)*/
    BOOL bHighlighting;         /* TRUE = The mark will be drawn highlighted.
                                    This attribute is currently only valid
                                    for lines, rectangles, and freehand.*/
    BOOL bTransparent;          /* TRUE = The mark will be drawn transparent.
                                    If the mark is drawn transparent, then white
                                    pixels are not drawn (ie. there is nothing
                                    drawn for this mark where it contains white
                                    pixels. This attribute is currently only
                                    available for images. This attribute being
                                    set to TRUE will cause significant
                                    performance reduction.*/
    UINT uLineSize;             /* The size of the line etc. This is passed
                                    onto Windows and is currently in logical
                                    pixels for lines and rectangles.*/
    UINT uStartingPoint;        /* The shape put on the starting of a
                                    line (arrow, circle, square, etc).
                                    For this release, this must be set to 0.*/
    UINT uEndPoint;             /* The shape put on the end of a
                                    line (arrow, circle, square, etc).
                                    For this release, this must be set to 0.*/
    LOGFONTA lfFont;             /* The font information for the text. */
    BOOL bMinimizable;          /* TRUE = This mark can be minimized
                                    by the user. This flag is only used for
                                    marks that have a minimizable
                                    characteristic such as ATTACH_A_NOTE.*/
    UINT  Time;                /* The time that the mark was first saved.
                                    in seconds from 00:00:00 1-1-1970 (GMT).*/
    BOOL bVisible;              /* TRUE means that the layer is currently set
                                    to be visible.*/
    DWORD dwPermissions;        /* Reserved. Must be set to 0x0ff83f */
    UINT lReserved[10];         /* Reserved for future expansion.
                                    For this release these must be set to 0.*/
};


// ANNOTATIONHEADER is the first 4 bytes of data in the annotation property.
struct _ANNOTATIONHEADER
{
    BYTE reserved[4];
    UINT IntIs32Bit;
};

typedef UNALIGNED struct _ANNOTATIONHEADER ANNOTATIONHEADER;
//
// for OiAnoDat
//
struct _ANPOINTS
{
    int nMaxPoints;
    int nPoints;
    POINT ptPoint[1];
};

typedef UNALIGNED struct _ANPOINTS ANPOINTS;

struct _ANROTATE
{
    int rotation;
    int scale;
    int nHRes;
    int nVRes;
    int nOrigHRes;
    int nOrigVRes;
    BOOL bReserved1;
    BOOL bReserved2;
    int nReserved[6];
};

typedef UNALIGNED struct _ANROTATE ANROTATE;
// for OiFilNam
struct _ANNAME
{
    char szName[1];
};

typedef UNALIGNED struct _ANNAME ANNAME;
// for OiDIB
struct _ANIMAGE
{
    BYTE dibInfo[1]; // standard memory DIB
};

typedef UNALIGNED struct _ANIMAGE ANIMAGE;
// for OiAnText
struct _ANTEXTPRIVDATA
{
    int nCurrentOrientation;
    UINT uReserved1; // always 1000 when writing, ignore when reading
    UINT uCreationScale; // always 72000 divided by the vertical resolution of the base image when writing.
                         // Used to modify the Attributes.lfFont.lfHeight variable for display
    UINT uAnoTextLength; // 64k byte limit, except 255 byte limit for text stamp
    char szAnoText[1];
};

typedef UNALIGNED struct _ANTEXTPRIVDATA ANTEXTPRIVDATA;

// These structures provide descriptors for the data read from the annotation property blob.
// The extra data includes the size of each annotation structure
// _NAMEDBLOCK is our in-memory representation
struct _NAMEDBLOCK
{
    UINT cbSize;
    char szType[9];
    BYTE data[1];
};

typedef UNALIGNED struct _NAMEDBLOCK NAMEDBLOCK;

// _FILENAMEDBLOCK is what the namedblock looks like in the file
struct _FILENAMEDBLOCK
{
    char szType[8];
    UINT cbSize;
    BYTE data[1];
};

typedef UNALIGNED struct _FILENAMEDBLOCK FILENAMEDBLOCK;

struct ANNOTATIONDESCRIPTOR
{
    UINT cbSize;
    ANNOTATIONMARK mark;
    BYTE blocks[1];
};

// Define a base class for the various annotation types
class CAnnotation
{
public:
    static CAnnotation* CreateAnnotation(UINT type, ULONG uCreationScale);
    static CAnnotation* CreateAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
    virtual ~CAnnotation();

    // render to the given rectangle in window client coordinates.
    virtual void Render(HDC hdc) { return; }
    // return the in-file representation of this annotation, as well as its total size
    HRESULT GetBlob(SIZE_T &cbSize, LPBYTE pBuffer, LPCSTR szDefaultGroup, LPCSTR szNextIndex);
    // return our image coordinates
    virtual void GetRect(RECT &rect) {rect = _mark.lrBounds;}
    // return the type of Annotation Mark used to change the selection handles for straight lines
    virtual UINT GetType() { return _mark.uType; }
    // moves the annotation on the page by the specified offset
    virtual void Move(SIZE sizeOffset) { OffsetRect(&_mark.lrBounds, sizeOffset.cx, sizeOffset.cy); }
    // return true if the object can be resized (true for every thing but freehand lines and images)
    virtual BOOL CanResize() { return true; }
    // resizes the annotation on the page to the new rect specified
    virtual void Resize(RECT rectNewSize);

    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

    virtual BOOL HasWidth() { return true; }
    virtual UINT GetWidth() { return _mark.uLineSize; }
    virtual void SetWidth(UINT nWidth) { _mark.uLineSize = nWidth; }

    virtual BOOL HasTransparent() { return true; }
    virtual BOOL GetTransparent() { return _mark.bHighlighting; }
    virtual void SetTransparent(BOOL bTransparent) { _mark.bHighlighting = bTransparent; }

    virtual BOOL HasColor() { return true; }
    virtual COLORREF GetColor() { return RGB(_mark.rgbColor1.rgbRed, _mark.rgbColor1.rgbGreen, _mark.rgbColor1.rgbBlue); }
    virtual void SetColor(COLORREF crColor) { _mark.rgbColor1.rgbRed = GetRValue(crColor); _mark.rgbColor1.rgbGreen = GetGValue(crColor); _mark.rgbColor1.rgbBlue = GetBValue(crColor); }

    virtual BOOL HasFont() { return true; }
    virtual void GetFont(LOGFONTA& lfFont) { CopyMemory (&lfFont, &_mark.lfFont, sizeof(lfFont)); }
    virtual void GetFont(LOGFONTW& lfFont);
    virtual void SetFont(LOGFONTA& lfFont) { CopyMemory (&_mark.lfFont, &lfFont, sizeof(lfFont)); }
    virtual void SetFont(LOGFONTW& lfFont);
    virtual LONG GetFontHeight(HDC hdc) { return _mark.lfFont.lfHeight; }

    virtual COLORREF GetFontColor() { return RGB(_mark.rgbColor1.rgbRed, _mark.rgbColor1.rgbGreen, _mark.rgbColor1.rgbBlue); }
    virtual void SetFontColor(COLORREF crColor) { _mark.rgbColor1.rgbRed = GetRValue(crColor); _mark.rgbColor1.rgbGreen = GetGValue(crColor); _mark.rgbColor1.rgbBlue = GetBValue(crColor); }

protected:
    CAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor);
    NAMEDBLOCK *_FindNamedBlock (LPCSTR szName, ANNOTATIONDESCRIPTOR *pDesc);
    virtual HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer) {return E_NOTIMPL;};
    // define helper functions for writing the different named block types
    SIZE_T _WriteStringBlock(LPBYTE pBuffer, UINT uType, LPCSTR szName, LPCSTR szData, SIZE_T len);
    SIZE_T _WritePointsBlock(LPBYTE pBuffer, UINT uType, const POINT *ppts, int nPoints, int nMaxPoints);
    SIZE_T _WriteRotateBlock(LPBYTE pBuffer, UINT uType, const ANROTATE *pRotate);
    SIZE_T _WriteTextBlock(LPBYTE pBuffer, UINT uType, int nOrient, UINT uScale, LPCSTR szText, int nMaxLen);
    SIZE_T _WriteImageBlock(LPBYTE pBuffer, UINT uType, LPBYTE pDib, SIZE_T cbDib);

    ANNOTATIONMARK _mark;
    LPSTR          _szGroup;
    FILENAMEDBLOCK *   _pUGroup;
};

class CRectMark : public CAnnotation
{
public:
    CRectMark (ANNOTATIONDESCRIPTOR *pDescriptor);
    void Render (HDC hdc);

    virtual BOOL HasWidth() { return (_mark.uType == MT_HOLLOWRECT); }
    virtual BOOL HasFont() { return false; }
};

class CImageMark : public CAnnotation
{
public:
    CImageMark (ANNOTATIONDESCRIPTOR *pDescriptor, bool bEmbedded);
    ~CImageMark();
    void Render (HDC hdc);
    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);
    virtual BOOL CanResize() { return false; };
    virtual void Resize(RECT rectNewSize) { return; };

private:
    HANDLE _hDibSection; // cached image for quicker render
    LPBYTE _pDib;        // the DIB data from the annotation. If NULL, this is a reference mark
    ANROTATE _rotation;  // rotation info
    LPSTR    _szFilename;  // image file name from the annotation
    bool     _bRotate; //REVIEW_SDK: Shouldn't there just be a known blank rotation value? If I rotate something 0 degrees shouldn't just not write the rotation record?
    SIZE_T   _cbDib;
};

class CLineMark : public CAnnotation
{
public:
    CLineMark(ANNOTATIONDESCRIPTOR *pDescriptor, bool bFreehand);
    ~CLineMark();
    void Render(HDC hdc);
    void GetRect(RECT &rect);
    void SetPoints(POINT* pPoints, int cPoints);
    void GetPointsRect(RECT &rect);
    virtual void Move(SIZE sizeOffset);
    virtual BOOL CanResize() { return (_nPoints == 2); };
    virtual void Resize(RECT rectNewSize);
    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

    virtual BOOL HasFont() { return false; }

    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);

private:
    int    _iMaxPts;
    int    _nPoints;
    POINT *_points; // 2 points for a straight line, more for a freehand line
};

// all text annotations render and initialize the same way so use a common base class
class CTextAnnotation : public CAnnotation
{
public:
    CTextAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale, UINT nMaxText=65536, bool _bUseColor2=false);
    void Render(HDC hdc);
    virtual ~CTextAnnotation();
    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);

    virtual BOOL HasWidth() { return false; }
    virtual BOOL HasTransparent() { return false; }
    virtual BOOL HasColor() { return false; }
    virtual LONG GetFontHeight(HDC hdc);
    virtual int GetOrientation() { return _nCurrentOrientation; }

    BSTR GetText();
    void SetText(BSTR bstrText);

    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

private:
    int _nCurrentOrientation;
    UINT _uCreationScale;
    UINT _uAnoTextLength;
    UINT _nMaxText;
    LPSTR _szText;
    bool _bUseColor2;
};

class CTypedTextMark : public CTextAnnotation
{
public:
    CTypedTextMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CFileTextMark : public CTextAnnotation
{
public:
    CFileTextMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CTextStampMark : public CTextAnnotation
{
public:
    CTextStampMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CAttachNoteMark : public CTextAnnotation
{
public:
    CAttachNoteMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
    virtual BOOL HasColor() { return true; }
    virtual COLORREF GetFontColor() { return RGB(_mark.rgbColor2.rgbRed, _mark.rgbColor2.rgbGreen, _mark.rgbColor2.rgbBlue); }
    virtual void SetFontColor(COLORREF crColor) { _mark.rgbColor2.rgbRed = GetRValue(crColor); _mark.rgbColor2.rgbGreen = GetGValue(crColor); _mark.rgbColor2.rgbBlue = GetBValue(crColor); }
};

class CAnnotationSet
{
public:
    CAnnotationSet ();
    ~CAnnotationSet ();

    // Draw all the marks
    void RenderAllMarks (HDC hdc);
    // construct annotation set from raw data
    HRESULT BuildAllMarksFromData( LPVOID pData, UINT cbSize, ULONG xDPI, ULONG yDPI );
    // Return the annotation at this point in image coordinates
    CAnnotation* GetAnnotation (INT_PTR nIndex);
    // Add a new annotation to the list. Should only be called from a CAnnotation
    BOOL AddAnnotation(CAnnotation *pMark);
    // Remove an annotation from the list. Should only be called from a CAnnotation
    BOOL RemoveAnnotation (CAnnotation *pMark);
    // Save the current set of annotations to the image
    HRESULT CommitAnnotations (IShellImageData *pimg);
    // Forget our old annotations and load new ones
    void SetImageData (IShellImageData *pimg);
    INT_PTR GetCount ()
    {
        if (_dpaMarks)
            return DPA_GetPtrCount(_dpaMarks);
        return 0;
    };

    UINT GetCreationScale();
    void ClearAllMarks();


private:
    HDPA    _dpaMarks;
    LPBYTE  _pDefaultData;
    SIZE_T  _cbDefaultData;
    ULONG   _xDPI;
    ULONG   _yDPI;

    static int CALLBACK _FreeMarks(LPVOID pMark, LPVOID pUnused);
    void   _ClearMarkList ();
    void   _BuildMarkList (IShellImageData *pimg);
    void   _BuildListFromData (LPVOID pData, UINT cbSize);
    INT    _NamedBlockDataSize (UINT uType, LPBYTE pData, LPBYTE pEOD);
    LPBYTE _MakeAnnotationBlob ();
    HRESULT _SaveAnnotationProperty(IShellImageData *pimg, LPBYTE pData, SIZE_T cbBuffer);
    ANNOTATIONDESCRIPTOR *_ReadMark (LPBYTE pMark, LPBYTE *ppNext, LPBYTE pEOD);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\annotlib\makefile.inc ===
$(PROJECT_INC_PATH)\annotlib.h : annot.h
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\annotlib\annot.cpp ===
#include "annotlib.h"
#include "assert.h"
#include "shlwapi.h"
#pragma hdrstop

#if !defined(ARRAYSIZE)
#define ARRAYSIZE(x)  (sizeof((x))/sizeof((x)[0]))
#endif
// Private definitions of tag types and values

//
// Each entry in the annotation has a type
//
#define DEFAULTDATA    2
#define ANNOTMARK      5
#define MARKBLOCK      6

// Reserved names for named blocks. case sensitive
static const char c_szAnoDat[] = "OiAnoDat";
static const char c_szFilNam[] = "OiFilNam";
static const char c_szDIB[] = "OiDIB";
static const char c_szGroup[] = "OiGroup";
static const char c_szIndex[] = "OiIndex";
static const char c_szAnText[] = "OiAnText";
static const char c_szHypLnk[] = "OiHypLnk";
static const char c_szDefaultGroup[] = "[Untitled]";

#define CBHEADER      8 // unused 4 bytes plus int size specifier
#define CBDATATYPE    8 // type specifier plus data size
#define CBNAMEDBLOCK 12 // name of block + sizeof block
#define CBINDEX      10 // length of the index string
#define CBBLOCKNAME   8 // length of the name of the named block

static const SIZE_T c_cbDefaultData = 144;
static const BYTE c_pDefaultData[] = {
0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x4f, 0x69, 0x55, 0x47, 0x72, 0x6f, 0x75, 0x70,
0x2a, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x5b, 0x55, 0x6e, 0x74, 0x69, 0x74, 0x6c, 0x65,
0x64, 0x5d, 0x00, 0x00, 0x5b, 0x00, 0x55, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00,
0x6c, 0x00, 0x65, 0x00, 0x64, 0x00, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x4f, 0x69, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x00, 0x0c, 0x00,
0x00, 0x00, 0x5b, 0x55, 0x6e, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x64, 0x5d, 0x00, 0x00, 0x02, 0x00,
0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x4f, 0x69, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x00, 0x1e, 0x00,
0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE c_pDefaultUGroup [] = {
0x4f, 0x69, 0x55, 0x47, 0x72, 0x6f, 0x75, 0x70,
0x2a, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x5b, 0x55, 0x6e, 0x74, 0x69, 0x74, 0x6c, 0x65,
0x64, 0x5d, 0x00, 0x00, 0x5b, 0x00, 0x55, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00,
0x6c, 0x00, 0x65, 0x00, 0x64, 0x00, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const INT AnnotHeader[] =
{
    0, 1
};

void NormalizeRect (RECT *prect)
{
    int nTemp;
    if (prect->left > prect->right)
    {
        nTemp = prect->left;
        prect->left = prect->right;
        prect->right = nTemp;
    }
    if (prect->top > prect->bottom)
    {
        nTemp = prect->top;
        prect->top = prect->bottom;
        prect->bottom = nTemp;
    }
}

static void RotateHelper(LPPOINT ppoint, int cSize, int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    int nNewX, nNewY;
    for(int i=0;i<cSize;i++)
    {
        if (bClockwise)
        {
            nNewX = nNewImageWidth - ppoint[i].y;
            nNewY = ppoint[i].x;
        }
        else
        {
            nNewX = ppoint[i].y;
            nNewY = nNewImageHeight - ppoint[i].x;
        }
        ppoint[i].x = nNewX;
        ppoint[i].y = nNewY;
    }
}

CAnnotationSet::CAnnotationSet()
    : _dpaMarks(NULL)
{
    _pDefaultData = (LPBYTE)c_pDefaultData;
    _cbDefaultData = c_cbDefaultData;
}

CAnnotationSet::~CAnnotationSet()
{
    _ClearMarkList ();
}

void CAnnotationSet::RenderAllMarks(HDC hdc)
{
    CAnnotation *pCur;

    if(_dpaMarks == NULL)
        return;

    for (INT_PTR i=0;i<DPA_GetPtrCount(_dpaMarks);i++)
    {
        pCur = (CAnnotation*)DPA_GetPtr(_dpaMarks, i);
        if (pCur)
        {
            pCur->Render (hdc);
        }
    }
}

CAnnotation* CAnnotationSet::GetAnnotation(INT_PTR nIndex)
{
    if(_dpaMarks == NULL)
        return NULL;

    if (nIndex >= 0 && nIndex < DPA_GetPtrCount(_dpaMarks))
    {
        CAnnotation *pCur;
        pCur = (CAnnotation *)DPA_GetPtr(_dpaMarks, nIndex);
        return pCur;
    }
    return NULL;
}

BOOL CAnnotationSet::AddAnnotation(CAnnotation *pMark)
{
    DPA_AppendPtr(_dpaMarks, pMark);
    return true;
}

BOOL CAnnotationSet::RemoveAnnotation(CAnnotation *pMark)
{
    CAnnotation *pCur;

    if(_dpaMarks == NULL)
        return true;

    for (int i=0;i<DPA_GetPtrCount(_dpaMarks);i++)
    {
        pCur = (CAnnotation*)DPA_GetPtr(_dpaMarks, i);
        if (pCur == pMark)
        {
            DPA_DeletePtr(_dpaMarks, i);
            return true;
        }
    }
    return false;
}

void CAnnotationSet::SetImageData(IShellImageData *pimg)
{
    GUID guidFmt;
    pimg->GetRawDataFormat(&guidFmt);
    _ClearMarkList();
    if (ImageFormatTIFF == guidFmt)
    {        
        _BuildMarkList(pimg);
    }
}

//
// This function reassembles the in-file representation of the current
// annotations and writes it to the IPropertyStorage
//
HRESULT CAnnotationSet::CommitAnnotations(IShellImageData * pSID)
{
    HRESULT hr = E_OUTOFMEMORY;
    SIZE_T cbItem;
    CAnnotation *pItem;
    LPBYTE pData;

    if (NULL == _dpaMarks || DPA_GetPtrCount(_dpaMarks) == 0)
    {
        hr = _SaveAnnotationProperty(pSID, NULL, 0);
        return hr;
    }

    //
    // First, calculate the size of the buffer needed
    // Begin with the header and the size of the default data
    //
    SIZE_T cbBuffer = CBHEADER+_cbDefaultData;
    //
    // Now query the individual items' sizes
    //
    for (INT_PTR i=0;i<DPA_GetPtrCount(_dpaMarks);i++)
    {
        pItem = (CAnnotation*)DPA_GetPtr(_dpaMarks, i);
        if (pItem)
        {
            if (SUCCEEDED(pItem->GetBlob(cbItem, NULL, c_szDefaultGroup, NULL)))
            {
                // cbItem includes the named blocks of the item as well
                // as the ANNOTATIONMARK struct
                cbBuffer += CBDATATYPE + cbItem;
            }
        }
    }
    //
    // Allocate the buffer to hold the annotations
    //
    pData = new BYTE[cbBuffer];
    if (pData)
    {
        LPBYTE pCur = pData;
        //
        // Copy in the header and the int size
        //
        CopyMemory(pCur, AnnotHeader, CBHEADER);
        pCur+=CBHEADER;
        //
        // Copy in the default data
        //
        CopyMemory(pCur, _pDefaultData, _cbDefaultData);
        pCur+=_cbDefaultData;
        //
        // Scan through the items again and have them copy in their data
        //
        for (INT_PTR i=0;i<DPA_GetPtrCount(_dpaMarks);i++)
        {
            pItem = (CAnnotation*)DPA_GetPtr(_dpaMarks, i);
            if (pItem)
            {
                UINT nIndex = (UINT)i;
                CHAR szIndex[11];
                ZeroMemory(szIndex, 11);

                wnsprintfA(szIndex, ARRAYSIZE(szIndex), "%d", nIndex );

                if (SUCCEEDED(pItem->GetBlob(cbItem, pCur+CBDATATYPE, c_szDefaultGroup, szIndex)))
                {
                    *(UNALIGNED UINT *)pCur = ANNOTMARK; // next item is an ANNOTATIONMARK
                    *(UNALIGNED UINT *)(pCur+4) = sizeof(ANNOTATIONMARK); // size of the mark
                    pCur+=CBDATATYPE + cbItem;
                }
            }
        }
        //
        // Now save the annotation blob as a property
        //
        hr = _SaveAnnotationProperty(pSID, pData, cbBuffer);
    }
    delete [] pData;
    return hr;
}

void CAnnotationSet::ClearAllMarks()
{
    _ClearMarkList();
}

//
// _BuildMarkList reads the PROPVARIANT for tag 32932 from the image.
// It walks through the data building a list of CAnnotation-derived objects
//
void CAnnotationSet::_BuildMarkList(IShellImageData * pSID)
{
    if(!pSID)
    {
        return;
    }

    pSID->GetResolution(&_xDPI, &_yDPI);

    IPropertySetStorage * pss;
    if(SUCCEEDED(pSID->GetProperties(STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pss)))
    {
        IPropertyStorage * pstg;
        if(SUCCEEDED( pss->Open(FMTID_ImageProperties, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, &pstg)))
        {
            _dpaMarks = DPA_Create(16);

            PROPVARIANT pv = {0};
            PROPSPEC ps;
            ps.propid = ANNOTATION_IMAGE_TAG;
            ps.ulKind = PRSPEC_PROPID;
            if(S_OK == pstg->ReadMultiple(1, &ps, &pv))
            {
                if (pv.vt != VT_NULL && pv.vt != VT_EMPTY)
                {
                    LPVOID pData = NULL;
                    long lUBound;
                    //
                    // This property is a SAFEARRAY of bytes
                    //
                    assert(pv.vt ==(VT_UI1 | VT_ARRAY));
                    SafeArrayGetUBound(pv.parray, 1, &lUBound);
                    SafeArrayAccessData(pv.parray, &pData);
                    if(pData)
                    {
                        _BuildListFromData(pData, SafeArrayGetElemsize(pv.parray)*(lUBound+1));
                    }
                    SafeArrayUnaccessData(pv.parray);                    
                }
                PropVariantClear (&pv);
            }
            pstg->Release();
        }
        pss->Release();
    }
}

// Given the raw annotation data, do set up and then call _BuildListFromData
HRESULT CAnnotationSet::BuildAllMarksFromData(LPVOID pData, UINT cbSize, ULONG xDPI, ULONG yDPI)
{
    // check for bad params
    if (!pData)
    {
        return E_INVALIDARG;
    }

    // First, clear out any old marks...
    _ClearMarkList();

    // Set up DPI info
    _xDPI = xDPI;
    _yDPI = yDPI;

    //  Create DPA if it doesn't exist
    if (!_dpaMarks)
    {
        _dpaMarks = DPA_Create(16);

        if (!_dpaMarks)
        {
            return E_OUTOFMEMORY;
        }
    }

    // build list of marks
    _BuildListFromData(pData,cbSize);

    return S_OK;

}

// Given the raw annotation data, swizzle it to in-memory CAnnotation objects
// and add those object pointers to our list
void CAnnotationSet::_BuildListFromData(LPVOID pData, UINT cbSize)
{
    ANNOTATIONDESCRIPTOR *pDesc;
    LPBYTE   pNextData =(LPBYTE)pData;
    LPBYTE  pDefaultData;
    CAnnotation *pMark;

    if(!_dpaMarks)
    {
        return;
    }
    // Skip the 4 byte header
    pNextData += 4;
    // Make sure the int size is 32 bits
    if(!((UNALIGNED int *)*pNextData))
    {
        return;
    }
    // skip the int size marker
    pNextData += 4;
    pDefaultData = pNextData;
    // skip the default data. It gets stored for future use, as it will be appended to all
    // new marks the user creates on this image.
    pNextData += _NamedBlockDataSize(2,pNextData,(LPBYTE)pData+cbSize);
    _cbDefaultData = (SIZE_T)(pNextData-pDefaultData);
    _pDefaultData = new BYTE[_cbDefaultData];
    if(_pDefaultData)
    {
        CopyMemory(_pDefaultData, pDefaultData, _cbDefaultData);
    }
    // pNextData now points to the first mark in the data.
    do
    {
        // Create a descriptor from the raw mark data
        pDesc = _ReadMark(pNextData, &pNextData,(LPBYTE)pData+cbSize);
        if(pDesc)
        {
            // Now create a CAnnotation from the descriptor and add it to the list
            pMark = CAnnotation::CreateAnnotation(pDesc, _yDPI);
            if(pMark)
            {
                DPA_AppendPtr(_dpaMarks, pMark);
            }
            delete pDesc;
        }       
    }while(pNextData &&(((LPBYTE)pData+cbSize) > pNextData) );
}

#define CHECKEOD if(pCur>pEOD)return -1;

INT CAnnotationSet::_NamedBlockDataSize(UINT uType, LPBYTE pData, LPBYTE pEOD)
{
    LPBYTE pCur = pData;
    UINT cbSkip=0;

    while(pCur < pEOD && *(UNALIGNED UINT*)pCur == uType)
    {
        pCur+=4;
        CHECKEOD
        // skip type and size
        cbSkip +=8+*(UNALIGNED UINT*)pCur;
        pCur+=4;
        //skip name
        pCur+=8;
        CHECKEOD
        // skip size plus the actual data
        cbSkip+=*(UNALIGNED UINT*)pCur;
        pCur+=4+*(UNALIGNED UINT*)pCur;        
    }
    return cbSkip;
}

ANNOTATIONDESCRIPTOR *CAnnotationSet::_ReadMark(LPBYTE pMark, LPBYTE *ppNext, LPBYTE pEOD)
{
    assert(*(UNALIGNED UINT*)pMark == 5);
    LPBYTE pBegin;
    UINT cbMark;                // size of the ANNOTATIONMARK in pMark
    UINT cbNamedBlocks= -1;         // size of the named blocks in pMark
    UINT cbDesc = sizeof(UINT); // size of the ANNOTATIONDESCRIPTOR
    ANNOTATIONDESCRIPTOR *pDesc = NULL;

    *ppNext = NULL;
    if (5 != *(UNALIGNED UINT*)pMark)
    {
        return pDesc;
    }

    if (pMark+8+sizeof(ANNOTATIONMARK)+sizeof(UINT) < pEOD)
    {
        // skip the type
        pMark+=4;
        //point pBegin at the ANNOTATIONMARK struct
        pBegin=pMark+4;
        cbMark = *(UNALIGNED UINT*)pMark;
        assert(cbMark == sizeof(ANNOTATIONMARK));
        if (sizeof(ANNOTATIONMARK) == cbMark)
        {
            cbDesc+=cbMark;
            pMark+=4+cbMark;
            cbNamedBlocks = _NamedBlockDataSize(6, pMark, pEOD);
        }
    }
    if (-1 != cbNamedBlocks)
    {
        cbDesc+=cbNamedBlocks;
        // Allocate the descriptor
        pDesc =(ANNOTATIONDESCRIPTOR *)new BYTE[cbDesc];
    }
    if (pDesc)
    {
        BOOL bFailed = FALSE;
        UINT uOffset = 0;
        // populate the descriptor
        pDesc->cbSize = cbDesc;
        CopyMemory(&pDesc->mark, pBegin, sizeof(pDesc->mark));
        // Set pBegin at the beginning of the named blocks and read them in
        pBegin+=cbMark;
        NAMEDBLOCK *pBlock =(NAMEDBLOCK*)(&pDesc->blocks);
        while(!bFailed && uOffset < cbNamedBlocks)
        {
            assert(*(UNALIGNED UINT*)(pBegin+uOffset) == 6);
            if (6 == *(UNALIGNED UINT*)(pBegin+uOffset))
            {
                uOffset += 4;
                assert(*(UNALIGNED UINT*)(pBegin+uOffset) == 12); // name plus data size
                if (12 == *(UNALIGNED UINT*)(pBegin+uOffset))
                {
                    uOffset+=4;
                    // Copy in the name of the block
                    lstrcpynA(pBlock->szType,(LPCSTR)(pBegin+uOffset), ARRAYSIZE(pBlock->szType));
                    uOffset+=8;
                    cbMark = *(UNALIGNED UINT*)(pBegin+uOffset);
                    // Calculate the total size of the NAMEDBLOCK structure
                    pBlock->cbSize = sizeof(pBlock->cbSize)+sizeof(pBlock->szType)+cbMark;
                    uOffset+=4;
                    CopyMemory(&pBlock->data,pBegin+uOffset, cbMark);
                    uOffset+=cbMark;
                    // move our block pointer to the next chunk
                    pBlock =(NAMEDBLOCK*)((LPBYTE)pBlock+pBlock->cbSize);
                }
                else
                {
                    bFailed = TRUE;
                }
            }
            else
            {
                bFailed = TRUE;
            }
        }
        if (!bFailed)
        {
            *ppNext =(LPBYTE)(pBegin+cbNamedBlocks);
        }
        else // annotations are malformed, don't try to load them
        {
            delete [] (BYTE*) pDesc;
            pDesc = NULL;
        }
    }
    return pDesc;
}

void CAnnotationSet::_ClearMarkList()
{
    if(_dpaMarks)
    {
        DPA_DestroyCallback(_dpaMarks, _FreeMarks, NULL);
        _dpaMarks = NULL;
    }
    if (_pDefaultData != c_pDefaultData)
    {
       delete[] _pDefaultData;
    }
    _pDefaultData = (LPBYTE)c_pDefaultData;
    _cbDefaultData = c_cbDefaultData;
}

int CALLBACK CAnnotationSet::_FreeMarks(LPVOID pMark, LPVOID pUnused)
{
    delete (CAnnotation*)pMark;
    return 1;
}

HRESULT CAnnotationSet::_SaveAnnotationProperty(IShellImageData * pSID, LPBYTE pData, SIZE_T cbBuffer)
{
    IPropertySetStorage * pss;
    HRESULT hr = pSID->GetProperties(STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pss);
    if (SUCCEEDED(hr))
    {
        IPropertyStorage * pstg;
        hr = pss->Open(FMTID_ImageProperties, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, &pstg);
        if (SUCCEEDED(hr))
        {
            PROPVARIANT pv;
            static PROPSPEC ps = {PRSPEC_PROPID, ANNOTATION_IMAGE_TAG};
            SAFEARRAYBOUND bound;
            bound.cElements = (ULONG)cbBuffer;
            bound.lLbound = 0;
            PropVariantInit(&pv);
            if (pData != NULL)
            {
                pv.vt = VT_UI1 | VT_ARRAY;
                pv.parray = SafeArrayCreate(VT_UI1,1,&bound);
                if (pv.parray)
                {
                    LPVOID pBits;
                    hr = SafeArrayAccessData(pv.parray, &pBits);
                    if (SUCCEEDED(hr))
                    {
                        CopyMemory(pBits, pData, cbBuffer);
                        SafeArrayUnaccessData(pv.parray);
                        if (S_OK != pstg->WriteMultiple(1, &ps, &pv, 1024))
                        {
                            hr = E_FAIL;
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                pv.vt = VT_NULL;
                if (S_OK != pstg->WriteMultiple(1, &ps, &pv, 1024))
                {
                    hr = E_FAIL;
                }
            }
            PropVariantClear(&pv);
            pstg->Release();
        }
        pss->Release();
    }
    return hr;
}

CAnnotation::CAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor)
{
    NAMEDBLOCK *pb;

    CopyMemory(&_mark, &pDescriptor->mark, sizeof(_mark));
    // every annotation read from the image should have a group name
    // and an index

    _szGroup = NULL;
    pb = _FindNamedBlock("OiGroup", pDescriptor);
    if(pb)
    {
        _szGroup = new char[pb->cbSize-sizeof(pb->szType)];
        if(_szGroup)
        {
            lstrcpynA(_szGroup,(LPCSTR)(pb->data),pb->cbSize-sizeof(pb->szType));
        }
    }
    _pUGroup = (FILENAMEDBLOCK*)c_pDefaultUGroup;
    pb = _FindNamedBlock("OiUGroup", pDescriptor);
    if (pb)
    {
        _pUGroup = (FILENAMEDBLOCK*)new BYTE[pb->cbSize-1];
        if (_pUGroup)
        {
            CopyMemory(_pUGroup->szType, pb->szType, ARRAYSIZE(_pUGroup->szType));
            _pUGroup->cbSize = pb->cbSize-CBNAMEDBLOCK-1;
            CopyMemory(_pUGroup->data, pb->data, _pUGroup->cbSize);
        }
        else
        {
            _pUGroup = (FILENAMEDBLOCK*)c_pDefaultUGroup;
        }
    }
}

// return a blank annotation object
CAnnotation *CAnnotation::CreateAnnotation(UINT type, ULONG uCreationScale)
{
    ANNOTATIONDESCRIPTOR desc;
    ZeroMemory(&desc, sizeof(desc));
    desc.cbSize = sizeof(desc.cbSize)+sizeof(desc.mark)+sizeof(desc.blocks);
    desc.mark.uType = type;
    // MSDN mentions this required permission value
    desc.mark.dwPermissions = 0x0ff83f;
    desc.mark.bVisible = 1;
    return CreateAnnotation(&desc, uCreationScale);
}

CAnnotation *CAnnotation::CreateAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
{

    CAnnotation *pNew = NULL;
    switch(pDescriptor->mark.uType)
    {
        case MT_IMAGEEMBED:
        case MT_IMAGEREF:
            pNew = new CImageMark(pDescriptor, pDescriptor->mark.uType == MT_IMAGEEMBED);
            break;
        case MT_STRAIGHTLINE:
        case MT_FREEHANDLINE:
            pNew = new CLineMark(pDescriptor, pDescriptor->mark.uType == MT_FREEHANDLINE);
            break;
        case MT_FILLRECT:
        case MT_HOLLOWRECT:
            pNew = new CRectMark(pDescriptor);
            break;
        case MT_TYPEDTEXT:
            pNew = new CTypedTextMark(pDescriptor, uCreationScale);
            break;
        case MT_FILETEXT:
            pNew = new CFileTextMark(pDescriptor, uCreationScale);
            break;
        case MT_STAMP:
            pNew = new CTextStampMark(pDescriptor, uCreationScale);
            break;
        case MT_ATTACHANOTE:
            pNew = new CAttachNoteMark(pDescriptor, uCreationScale);
            break;
        default:

            break;
    }
    return pNew;
}

void CAnnotation::Resize(RECT rectNewSize)
{
    _mark.lrBounds = rectNewSize;
    NormalizeRect(&_mark.lrBounds);
}

NAMEDBLOCK *CAnnotation::_FindNamedBlock(LPCSTR szName, ANNOTATIONDESCRIPTOR *pDescriptor)
{
    NAMEDBLOCK *pCur;
    NAMEDBLOCK *pRet = NULL;
    UINT uOffset;
    LPBYTE pb =(LPBYTE)pDescriptor;
    uOffset = sizeof(pDescriptor->cbSize)+sizeof(pDescriptor->mark);
    while(!pRet && uOffset < pDescriptor->cbSize)
    {
        pCur =(NAMEDBLOCK*)(pb+uOffset);
        if(!lstrcmpA(pCur->szType, szName))
        {
            pRet = pCur;
        }
        else
        {
            if (pCur->cbSize == 0)
                return NULL;

            uOffset+=pCur->cbSize;
        }
    }
    return pRet;
}

CAnnotation::~CAnnotation()
{
    if(_szGroup)
    {
        delete _szGroup;
    }
    if (_pUGroup && _pUGroup != (FILENAMEDBLOCK*)c_pDefaultUGroup)
    {
        delete [] (BYTE*)_pUGroup;
    }
}

// GetBlob writes out the ANNOTATIONMARK plus the group and index blocks
// It then queries the subclass through a virtual function to get
// extra named blocks
//
HRESULT CAnnotation::GetBlob(SIZE_T &cbSize, LPBYTE pBuffer, LPCSTR szDefaultGroup, LPCSTR szNextIndex)
{
    SIZE_T cbExtra = 0;
    HRESULT hr = S_OK;
    LPCSTR szGroup = _szGroup;
    if (szGroup == NULL)
        szGroup = szDefaultGroup;

    // add in the ANNOTATIONMARK
    cbSize = sizeof(_mark);
    // for the group and index, add in the
    cbSize += 2*(CBDATATYPE+CBNAMEDBLOCK);
    // add in the length of the group name
    cbSize += lstrlenA(szGroup)+1;
    // add in the size of the index string
    cbSize += CBINDEX;
    if (_pUGroup)
    {
        cbSize += CBDATATYPE+CBNAMEDBLOCK+_pUGroup->cbSize;
    }
    // Add in the size of any named blocks from the subclass
    _WriteBlocks(cbExtra, NULL);
    cbSize += cbExtra;
    if (pBuffer)
    {
        // now write the data
        CopyMemory (pBuffer, &_mark, sizeof(_mark));
        pBuffer += sizeof(_mark);
        // write the mark-specific blocks before the group and index blocks
        if (cbExtra)
        {
            if (SUCCEEDED(_WriteBlocks(cbExtra, pBuffer)))
            {
                pBuffer+=cbExtra;
            }
        }
        // write the group and index blocks
        if (_pUGroup)
        {
            *(UNALIGNED UINT*)pBuffer = 6;
            *(UNALIGNED UINT*)(pBuffer + 4) = CBNAMEDBLOCK;
            CopyMemory(pBuffer+CBDATATYPE,_pUGroup, CBNAMEDBLOCK+_pUGroup->cbSize);
            pBuffer += CBDATATYPE + CBNAMEDBLOCK+_pUGroup->cbSize;
        }
        pBuffer += _WriteStringBlock(pBuffer, 6, c_szGroup, szGroup, lstrlenA(szGroup)+1);
        pBuffer += _WriteStringBlock(pBuffer, 6, c_szIndex, szNextIndex, CBINDEX);
    }
    return hr;
}

void CAnnotation::Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    RECT rect = _mark.lrBounds;
    RotateHelper((LPPOINT)&rect, 2, nNewImageWidth, nNewImageHeight, bClockwise);
    NormalizeRect(&rect);
    _mark.lrBounds = rect;
}

void CAnnotation::GetFont(LOGFONTW& lfFont)
{
    lfFont.lfHeight = _mark.lfFont.lfHeight;
    lfFont.lfWidth = _mark.lfFont.lfWidth;
    lfFont.lfEscapement = _mark.lfFont.lfEscapement;
    lfFont.lfOrientation = _mark.lfFont.lfOrientation;
    lfFont.lfWeight = _mark.lfFont.lfWeight;
    lfFont.lfItalic = _mark.lfFont.lfItalic;
    lfFont.lfUnderline = _mark.lfFont.lfUnderline;
    lfFont.lfStrikeOut = _mark.lfFont.lfStrikeOut;
    lfFont.lfCharSet = _mark.lfFont.lfCharSet;
    lfFont.lfOutPrecision = _mark.lfFont.lfOutPrecision;
    lfFont.lfClipPrecision = _mark.lfFont.lfClipPrecision;
    lfFont.lfQuality = _mark.lfFont.lfQuality;
    lfFont.lfPitchAndFamily = _mark.lfFont.lfPitchAndFamily;

    ::MultiByteToWideChar(CP_ACP, 0, _mark.lfFont.lfFaceName, ARRAYSIZE(_mark.lfFont.lfFaceName), lfFont.lfFaceName, ARRAYSIZE(lfFont.lfFaceName));
}

void CAnnotation::SetFont(LOGFONTW& lfFont)
{
    _mark.lfFont.lfHeight = lfFont.lfHeight;
    _mark.lfFont.lfWidth = lfFont.lfWidth;
    _mark.lfFont.lfEscapement = lfFont.lfEscapement;
    _mark.lfFont.lfOrientation = lfFont.lfOrientation;
    _mark.lfFont.lfWeight = lfFont.lfWeight;
    _mark.lfFont.lfItalic = lfFont.lfItalic;
    _mark.lfFont.lfUnderline = lfFont.lfUnderline;
    _mark.lfFont.lfStrikeOut = lfFont.lfStrikeOut;
    _mark.lfFont.lfCharSet = lfFont.lfCharSet;
    _mark.lfFont.lfOutPrecision = lfFont.lfOutPrecision;
    _mark.lfFont.lfClipPrecision = lfFont.lfClipPrecision;
    _mark.lfFont.lfQuality = lfFont.lfQuality;
    _mark.lfFont.lfPitchAndFamily = lfFont.lfPitchAndFamily;

    ::WideCharToMultiByte(CP_ACP, 0, lfFont.lfFaceName, ARRAYSIZE(lfFont.lfFaceName), _mark.lfFont.lfFaceName, ARRAYSIZE(_mark.lfFont.lfFaceName), NULL, NULL);
}

SIZE_T CAnnotation::_WriteStringBlock(LPBYTE pBuffer, UINT uType, LPCSTR szName, LPCSTR szData, SIZE_T len)
{
    if (pBuffer)
    {
        *(UNALIGNED UINT*)pBuffer = uType;
        *(UNALIGNED UINT*)(pBuffer + 4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), szName, CBNAMEDBLOCK+1); // named block name
        *(UNALIGNED UINT*)(pBuffer + CBDATATYPE + 8) = (UINT)len; // the named block name isn't null terminated
        CopyMemory(pBuffer + CBDATATYPE + CBNAMEDBLOCK, szData, len);
    }
    return CBDATATYPE + CBNAMEDBLOCK + len;
}

SIZE_T CAnnotation::_WritePointsBlock(LPBYTE pBuffer, UINT uType, const POINT *ppts, int nPoints, int nMaxPoints)
{
    UINT cbAnPoints = sizeof(int)+sizeof(int)+nPoints*sizeof(POINT);
    if (pBuffer)
    {
        *(UNALIGNED UINT *)pBuffer = uType;
        *(UNALIGNED UINT *)(pBuffer + 4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), c_szAnoDat, CBNAMEDBLOCK+1);
        pBuffer += CBDATATYPE + 8;
        *(UNALIGNED UINT *)pBuffer = cbAnPoints;
        pBuffer+=4;
        // Write out the ANPOINTS equivalent
        *(UNALIGNED int*)pBuffer = nMaxPoints;
        *(UNALIGNED int*)(pBuffer+4) = nPoints;
        CopyMemory(pBuffer+8, ppts, nPoints*sizeof(POINT));
    }
    return CBDATATYPE + CBNAMEDBLOCK + cbAnPoints;
}

SIZE_T CAnnotation::_WriteRotateBlock(LPBYTE pBuffer, UINT uType, const ANROTATE *pRotate)
{
    if (pBuffer)
    {
        *(UNALIGNED UINT *)pBuffer = uType;
        *(UNALIGNED UINT *)(pBuffer + 4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), c_szAnoDat, CBNAMEDBLOCK+1);
        *(UNALIGNED UINT *)(pBuffer + CBDATATYPE + 8) = sizeof(ANROTATE);
        CopyMemory(pBuffer + CBDATATYPE + CBNAMEDBLOCK, pRotate, sizeof(ANROTATE));
    }
    return CBDATATYPE + CBNAMEDBLOCK + sizeof(ANROTATE);
}


SIZE_T CAnnotation::_WriteTextBlock(LPBYTE pBuffer, UINT uType, int nOrient, UINT uScale, LPCSTR szText, int nMaxLen)
{
    LPCSTR pText = szText ? szText : "";
    UINT cbString =  min(lstrlenA(pText)+1, nMaxLen);
    UINT cbPrivData = sizeof(ANTEXTPRIVDATA)+cbString;
    if (pBuffer)
    {
        *(UNALIGNED UINT *)pBuffer = uType;
        *(UNALIGNED UINT *)(pBuffer + 4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), c_szAnText, CBNAMEDBLOCK+1);
        *(UNALIGNED UINT *)(pBuffer + CBDATATYPE + 8) = cbPrivData;
        // write out the ANTEXTPRIVDATA equivalent
        pBuffer += CBDATATYPE + CBNAMEDBLOCK;
        *(UNALIGNED int*)pBuffer = nOrient;
        *(UNALIGNED UINT *)(pBuffer+4) = 1000;
        *(UNALIGNED UINT *)(pBuffer+8) = uScale;
        *(UNALIGNED UINT *)(pBuffer+12) = cbString;
        lstrcpynA((LPSTR)(pBuffer+16), pText, nMaxLen);
    }
    return CBDATATYPE + CBNAMEDBLOCK + cbPrivData;
}

SIZE_T CAnnotation::_WriteImageBlock(LPBYTE pBuffer, UINT uType, LPBYTE pDib, SIZE_T cbDib)
{
    if (pBuffer)
    {
        *(UNALIGNED UINT *)pBuffer = uType;
        *(UNALIGNED UINT *)(pBuffer+4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), c_szAnText, CBNAMEDBLOCK+1);


/* REVIEW_SDK
        Now that I think about it, it might make sense to define a struct that could make this more clear.
        Something like:

        struct AnnoBlock
        {
                UINT uBlockType;
                UINT uBlockSize;
                CHAR sName[8]; // Not NULL terminated
                UINT uVariableDataSize;
                BYTE Data[];
        };

*/
        *(UNALIGNED UINT *)(pBuffer + CBDATATYPE + 8) = (UINT)cbDib;
        CopyMemory(pBuffer + CBDATATYPE + CBNAMEDBLOCK, pDib, cbDib);
    }
    return CBDATATYPE + CBNAMEDBLOCK + cbDib;
}

CRectMark::CRectMark(ANNOTATIONDESCRIPTOR *pDescriptor)
    : CAnnotation(pDescriptor)
{
    // rects have no named blocks to read
}

void CRectMark::Render(HDC hdc)
{
    int nROP = R2_COPYPEN;
    if (_mark.bHighlighting)
        nROP = R2_MASKPEN;

    int nOldROP = ::SetROP2(hdc, nROP);

    HPEN hPen = NULL;
    HPEN hOldPen = NULL;
    HBRUSH hBrush = NULL;
    HBRUSH hOldBrush = NULL;

    if (_mark.uType == MT_HOLLOWRECT)
    {
        hPen = ::CreatePen(PS_INSIDEFRAME, max(1, _mark.uLineSize),
                          RGB(_mark.rgbColor1.rgbRed,
                              _mark.rgbColor1.rgbGreen,
                              _mark.rgbColor1.rgbBlue));
        if(hPen)
            hOldPen =(HPEN)::SelectObject(hdc, hPen);

        hOldBrush = (HBRUSH)::SelectObject(hdc, ::GetStockObject(NULL_BRUSH));
    }
    else
    {
        hBrush = CreateSolidBrush(RGB(_mark.rgbColor1.rgbRed,
                                    _mark.rgbColor1.rgbGreen,
                                    _mark.rgbColor1.rgbBlue));
        if (hBrush)
            hOldBrush = (HBRUSH)::SelectObject(hdc, hBrush);

        hOldPen =(HPEN)::SelectObject(hdc, GetStockObject(NULL_PEN));
    }

    ::Rectangle(hdc, _mark.lrBounds.left, _mark.lrBounds.top, _mark.lrBounds.right, _mark.lrBounds.bottom);

    if (hOldPen)
        ::SelectObject(hdc, hOldPen);

    if (hOldBrush)
        ::SelectObject(hdc, hOldBrush);

    if (hPen)
        ::DeleteObject(hPen);

    if (hBrush)
        ::DeleteObject(hBrush);

    ::SetROP2(hdc, nOldROP);
}

CImageMark::CImageMark(ANNOTATIONDESCRIPTOR *pDescriptor, bool bEmbedded) :
    CAnnotation(pDescriptor), _hDibSection(NULL), _pDib(NULL)
{
    ZeroMemory(&_rotation, sizeof(_rotation));
    NAMEDBLOCK *pb = _FindNamedBlock(c_szAnoDat, pDescriptor);
    UINT cb;
    _cbDib = 0;
    _bRotate = false;
    if (pb)
    {
        CopyMemory(&_rotation, pb->data, sizeof(_rotation));
    }
    pb= _FindNamedBlock(c_szFilNam, pDescriptor);
    if (pb)
    {
        cb = pb->cbSize-sizeof(pb->cbSize)-sizeof(pb->szType);
        _szFilename = new char[cb+1];
        if (_szFilename)
        {
            lstrcpynA (_szFilename, (LPCSTR)(pb->data), cb+1);
        }
    }
    pb = _FindNamedBlock(c_szDIB, pDescriptor);
    if (pb)
    {
        assert (bEmbedded);
        cb = pb->cbSize-sizeof(pb->cbSize)-sizeof(pb->szType);
        _pDib = new BYTE[cb];
        if (_pDib)
        {
            CopyMemory (_pDib, pb->data, cb);
            _cbDib = cb;
        }
        // what do we do if allocation fails?
    }
    // If an image has IoAnoDat, the structure is a rotation structure
    pb = _FindNamedBlock(c_szAnoDat, pDescriptor);
    if (pb)
    {
        assert(pb->cbSize-sizeof(pb->cbSize)-sizeof(pb->szType) == sizeof(_rotation));
        _bRotate = true;
        CopyMemory(&_rotation, pb->data, sizeof(_rotation));
    }
}

CImageMark::~CImageMark()
{
    if (_pDib)
    {
        delete [] _pDib;
    }
    if (_szFilename)
    {
        delete [] _szFilename;
    }
}

HRESULT CImageMark::_WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer)
{
    cbSize = 0;
    if (_szFilename)
    {
        cbSize += _WriteStringBlock(pBuffer, 6, c_szFilNam, _szFilename, lstrlenA(_szFilename)+1);
    }
    if (_pDib)
    {
        cbSize += _WriteImageBlock(pBuffer, 6, _pDib, _cbDib);
    }
    if (_bRotate)
    {
        cbSize += _WriteRotateBlock(pBuffer, 6, &_rotation);
    }
    return S_OK;
}

void CImageMark::Render(HDC hdc)
{

}

CLineMark::CLineMark(ANNOTATIONDESCRIPTOR *pDescriptor, bool bFreehand)
    : CAnnotation(pDescriptor)
{
    NAMEDBLOCK *pb=_FindNamedBlock(c_szAnoDat, pDescriptor);
    _points = NULL;
    _nPoints = 0;
    if (pb)
    {
        ANPOINTS *ppts = (ANPOINTS*)&pb->data;
        _iMaxPts = bFreehand ? ppts->nMaxPoints : 2;

        assert(_nPoints > 2?bFreehand:TRUE);
        _points = new POINT[_iMaxPts];
        if (_points)
        {
            _nPoints = ppts->nPoints;
            CopyMemory (_points, &ppts->ptPoint, sizeof(POINT)*_nPoints);
            // each point is relative to the upper left cornder of _mark.lrBounds
            for (int i=0;i<_nPoints;i++)
            {
                _points[i].x += _mark.lrBounds.left;
                _points[i].y += _mark.lrBounds.top;
            }
        }
    }
}

CLineMark::~CLineMark()
{
    if (_points)
    {
        delete [] _points;
    }
}

void CLineMark::SetPoints(POINT* pPoints, int cPoints)
{
    assert(_mark.uType == MT_FREEHANDLINE);

    if (_points != NULL)
        delete[] _points;

    _points = pPoints;
    _nPoints = cPoints;
    _iMaxPts = _nPoints;

    RECT rect;
    rect.left = _points[0].x;
    rect.top =  _points[0].y;
    rect.right = _points[0].x;
    rect.bottom= _points[0].y;

    for(int i = 1; i < _nPoints; i++)
    {
        if (rect.left > _points[i].x)
            rect.left = _points[i].x;
        else if (rect.right < _points[i].x)
            rect.right = _points[i].x;

        if (rect.top > _points[i].y)
            rect.top = _points[i].y;
        else if (rect.bottom < _points[i].y)
            rect.bottom = _points[i].y;
    }

    _mark.lrBounds = rect;
}

void CLineMark::Render(HDC hdc)
{
    int nROP = R2_COPYPEN;
    if (_mark.bHighlighting)
        nROP = R2_MASKPEN;

    int nOldROP = ::SetROP2(hdc, nROP);

    HPEN hPen = NULL;
    HPEN hOldPen = NULL;

    hPen = ::CreatePen(PS_SOLID, max(1, _mark.uLineSize),
                      RGB(_mark.rgbColor1.rgbRed,
                          _mark.rgbColor1.rgbGreen,
                          _mark.rgbColor1.rgbBlue));
    if(hPen)
        hOldPen =(HPEN)::SelectObject(hdc, hPen);

    ::Polyline(hdc, _points, _nPoints);

    if (hOldPen)
        ::SelectObject(hdc, hOldPen);

    if (hPen)
        ::DeleteObject(hPen);

    ::SetROP2(hdc, nOldROP);
}

void CLineMark::GetRect(RECT &rect)
{
    
    int nPadding = (_mark.uLineSize / 2) + 6; 
    // one because LineTo is inclusive
    // one for rounding error on odd line widths
    // one for rounding error in scaling large files
    // and three more just so we don't have to tweak this again
    
    rect = _mark.lrBounds;
    InflateRect(&rect, nPadding , nPadding);
}

// Usually we are interested in the bounding rect of the line above
// but if we are directly manipulating the line we need a way to get
// to the unadjusted points (left, top) and (right, bottom)
void CLineMark::GetPointsRect(RECT &rect)
{
    if (_nPoints != 2)
        return;

    rect.top = _points[0].y;
    rect.left = _points[0].x;
    rect.bottom = _points[1].y;
    rect.right = _points[1].x;
}

void CLineMark::Move(SIZE sizeOffset)
{
    _points[0].x += sizeOffset.cx;
    _points[0].y += sizeOffset.cy;

    RECT rect;
    rect.left = _points[0].x;
    rect.top =  _points[0].y;
    rect.right = _points[0].x;
    rect.bottom = _points[0].y;
    for(int i = 1; i < _nPoints; i++)
    {
        _points[i].x += sizeOffset.cx;
        if (rect.left > _points[i].x)
            rect.left = _points[i].x;
        else if (rect.right < _points[i].x)
            rect.right = _points[i].x;

        _points[i].y += sizeOffset.cy;
        if (rect.top > _points[i].y)
            rect.top = _points[i].y;
        else if (rect.bottom < _points[i].y)
            rect.bottom = _points[i].y;
    }

    _mark.lrBounds = rect;
}

void CLineMark::Resize(RECT rectNewSize)
{
    if ((_points == NULL) && (_mark.uType == MT_STRAIGHTLINE))
    {
      _iMaxPts = _nPoints = 2;
      _points = new POINT[_iMaxPts];
    }

    if ((_nPoints == 2) && (_points != NULL))
    {
        _points[0].y = rectNewSize.top;
        _points[0].x = rectNewSize.left;
        _points[1].y = rectNewSize.bottom;
        _points[1].x = rectNewSize.right;

        _mark.lrBounds = rectNewSize;
        NormalizeRect(&_mark.lrBounds);
    }
}

void CLineMark::Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    RotateHelper(_points, _nPoints, nNewImageWidth, nNewImageHeight, bClockwise);

    RECT rect;
    rect.left = _points[0].x;
    rect.top =  _points[0].y;
    rect.right = _points[0].x;
    rect.bottom= _points[0].y;
    for(int i = 1; i < _nPoints; i++)
    {
        if (rect.left > _points[i].x)
            rect.left = _points[i].x;
        else if (rect.right < _points[i].x)
            rect.right = _points[i].x;

        if (rect.top > _points[i].y)
            rect.top = _points[i].y;
        else if (rect.bottom < _points[i].y)
            rect.bottom = _points[i].y;
    }

    _mark.lrBounds = rect;
}

HRESULT CLineMark::_WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer)
{
    if (_points)
    {
        for (int i=0;i<_nPoints;i++)
        {
            _points[i].x -= _mark.lrBounds.left;
            _points[i].y -= _mark.lrBounds.top;
        }

        cbSize = _WritePointsBlock(pBuffer, 6, _points, _nPoints, _iMaxPts);

        for (int i=0;i<_nPoints;i++)
        {
            _points[i].x += _mark.lrBounds.left;
            _points[i].y += _mark.lrBounds.top;
        }
    }

    return S_OK;
}

CTextAnnotation::CTextAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale, UINT nMaxLen, bool bUseColor2 )
    : CAnnotation(pDescriptor)
{
    NAMEDBLOCK *pb = _FindNamedBlock(c_szAnText, pDescriptor);
    _nCurrentOrientation  = 0;
    _uCreationScale = 0;
    _uAnoTextLength = 0;
    _szText = NULL;
    _nMaxText = nMaxLen;
    _bUseColor2 = bUseColor2;
    if (pb)
    {
        ANTEXTPRIVDATA *pData = (ANTEXTPRIVDATA*)&pb->data;
        _szText = new char[pData->uAnoTextLength+1];
        if (_szText)
        {
            _nCurrentOrientation = pData->nCurrentOrientation;
            _uCreationScale = pData->uCreationScale;
            _uAnoTextLength = pData->uAnoTextLength;
            lstrcpynA (_szText, pData->szAnoText, _uAnoTextLength+1);
        }
    }
    if (_uCreationScale == 0)
    {
        _uCreationScale = 72000 / uCreationScale;
    }
}

CTextAnnotation::~CTextAnnotation()
{
    if (_szText)
    {
        delete [] _szText;
    }
}

void CTextAnnotation::Render(HDC hdc)
{
    COLORREF crOld;
    int nOldROP = ::SetROP2(hdc, R2_COPYPEN);

    if (_mark.uType == MT_ATTACHANOTE)
    {
        HPEN hOldPen =(HPEN)::SelectObject(hdc, GetStockObject(NULL_PEN));
        HBRUSH hBrush = ::CreateSolidBrush(RGB(_mark.rgbColor1.rgbRed,
                                              _mark.rgbColor1.rgbGreen,
                                              _mark.rgbColor1.rgbBlue));
        if (hBrush != NULL)
        {
            HBRUSH hOldBrush = (HBRUSH)::SelectObject(hdc, hBrush);

            ::Rectangle(hdc, _mark.lrBounds.left, _mark.lrBounds.top, _mark.lrBounds.right, _mark.lrBounds.bottom);

            ::SelectObject(hdc, hOldBrush);
            ::DeleteObject(hBrush);
        }
        ::SelectObject(hdc, hOldPen);

        crOld = ::SetTextColor(hdc, RGB(_mark.rgbColor2.rgbRed,
                                      _mark.rgbColor2.rgbGreen,
                                      _mark.rgbColor2.rgbBlue));
    }
    else
    {
        crOld = ::SetTextColor(hdc, RGB(_mark.rgbColor1.rgbRed,
                                      _mark.rgbColor1.rgbGreen,
                                      _mark.rgbColor1.rgbBlue));
    }

    int nOldBkMode = ::SetBkMode(hdc, TRANSPARENT);

    LOGFONT lf;
    GetFont(lf);

    lf.lfHeight = GetFontHeight(hdc);

    HFONT hFont = CreateFontIndirect(&lf);
    HFONT hOldFont = NULL;
    if (hFont != NULL)
        hOldFont = (HFONT)::SelectObject(hdc, hFont);

    BSTR bstrText = GetText();

    // Handle angle of orientation in 1/10s of a degree
    if (_nCurrentOrientation != 0)
    {
        XFORM xForm;
        RECT rectSource = _mark.lrBounds;
        ::LPtoDP(hdc, (LPPOINT)&rectSource, 2);

        if (_nCurrentOrientation == 900)
        {
            xForm.eM11 = (FLOAT)0.0;
            xForm.eM12 = (FLOAT)-1.0;
            xForm.eM21 = (FLOAT)1.0;
            xForm.eM22 = (FLOAT)0.0;
            // Rotate Source (left, top) to (left, bottom)
            int nTmp = rectSource.bottom;
            rectSource.bottom = rectSource.top;
            rectSource.top = nTmp;
        }
        else if (_nCurrentOrientation == 1800)
        {
            xForm.eM11 = (FLOAT)-1.0;
            xForm.eM12 = (FLOAT)0.0;
            xForm.eM21 = (FLOAT)0.0;
            xForm.eM22 = (FLOAT)-1.0;
            // Rotate Source (left, top) to (right, bottom)
            int nTmp = rectSource.right;
            rectSource.right = rectSource.left;
            rectSource.left = nTmp;
            nTmp = rectSource.bottom;
            rectSource.bottom = rectSource.top;
            rectSource.top = nTmp;
        }
        else
        {
            xForm.eM11 = (FLOAT)0.0;
            xForm.eM12 = (FLOAT)1.0;
            xForm.eM21 = (FLOAT)-1.0;
            xForm.eM22 = (FLOAT)0.0;
            // Rotate Source (left, top) to (right, top)
            int nTmp = rectSource.right;
            rectSource.right = rectSource.left;
            rectSource.left = nTmp;
        }

        xForm.eDx = (FLOAT)0.0;
        xForm.eDy = (FLOAT)0.0;

        int nOldGraphicsMode = ::SetGraphicsMode(hdc, GM_ADVANCED);
        ::SetWorldTransform(hdc, &xForm);

        RECT rectTarget = rectSource;
        ::DPtoLP(hdc, (LPPOINT)&rectTarget, 2);

        ::DrawText(hdc, bstrText, -1, &rectTarget, DT_LEFT | DT_EDITCONTROL | DT_NOPREFIX | DT_WORDBREAK);

        ::ModifyWorldTransform(hdc, &xForm, MWT_IDENTITY);
        ::SetGraphicsMode(hdc, nOldGraphicsMode);
    }
    else
    {
        ::DrawText(hdc, bstrText, -1, &_mark.lrBounds, DT_LEFT | DT_EDITCONTROL | DT_NOPREFIX | DT_WORDBREAK);
    }

    if (hFont != NULL)
    {
        ::SelectObject(hdc, hOldFont);
        ::DeleteObject(hFont);
    }

    if (nOldBkMode != 0)
        ::SetBkMode(hdc, nOldBkMode);

    if (crOld != CLR_INVALID)
        ::SetTextColor (hdc, crOld);

    ::SetROP2(hdc, nOldROP);
    if (bstrText)
    {
        SysFreeString(bstrText);
    }
}

LONG CTextAnnotation::GetFontHeight(HDC hdc)
{
    LONG lHeight = MulDiv(_mark.lfFont.lfHeight, 96, 72);
//> REVIEW : This needs work, the 1000 below is rather random and should be fixed after Beta1
    lHeight = MulDiv(lHeight, 1000, _uCreationScale);
    lHeight = max(lHeight, 2);

    return lHeight;
}

BSTR CTextAnnotation::GetText()
{
    if (_szText == NULL)
        return NULL;

    int nLen = ::MultiByteToWideChar(CP_ACP, 0, _szText, -1, NULL, NULL);

    BSTR bstrResult = ::SysAllocStringLen(NULL, nLen);
    if (bstrResult != NULL)
    {
        ::MultiByteToWideChar(CP_ACP, 0, _szText, -1, bstrResult, nLen);
    }
    return bstrResult;
}

void CTextAnnotation::SetText(BSTR bstrText)
{
    UINT nLen = ::WideCharToMultiByte(CP_ACP, 0, bstrText, -1, NULL, 0, NULL, NULL);
    if (nLen > _nMaxText)
        return;

    if (nLen > _uAnoTextLength)
    {
        if (_szText != NULL)
        {
            delete [] _szText;
        }
        _uAnoTextLength = nLen - 1;
        _szText = new char[_uAnoTextLength+1];
    }

    if (_szText)
        ::WideCharToMultiByte(CP_ACP, 0, bstrText, -1, _szText, nLen, NULL, NULL);
}

void CTextAnnotation::Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    RECT rect = _mark.lrBounds;
    RotateHelper((LPPOINT)&rect, 2, nNewImageWidth, nNewImageHeight, bClockwise);
    _mark.lrBounds = rect;
    NormalizeRect(&_mark.lrBounds);
    if (bClockwise)
        _nCurrentOrientation += 2700;
    else
        _nCurrentOrientation += 900;

    _nCurrentOrientation = _nCurrentOrientation % 3600;
}

HRESULT CTextAnnotation::_WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer)
{
    cbSize = _WriteTextBlock(pBuffer,
                             6,
                             _nCurrentOrientation,
                             _uCreationScale,
                             _szText,
                             _nMaxText);
    return S_OK;
}

CTypedTextMark::CTypedTextMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
    : CTextAnnotation(pDescriptor, uCreationScale)
{
}


CFileTextMark::CFileTextMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
    : CTextAnnotation(pDescriptor, uCreationScale)
{
}


CTextStampMark::CTextStampMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
    : CTextAnnotation(pDescriptor, uCreationScale, 255)
{
}

CAttachNoteMark::CAttachNoteMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
    : CTextAnnotation(pDescriptor, uCreationScale, 65536, true)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\camdlg\sources.inc ===
!include $(PROJECT_ROOT)\ui\uienv.inc

TARGETNAME=camdlg
TARGETTYPE=LIBRARY
TARGETPATHLIB = $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\$(_OBJ_DIR)

ATL_VER         = 30
USE_STATIC_ATL  = 1

TARGETPATH=$(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\$(_OBJ_DIR)

SOURCES=    ..\camdlg.cpp \
            ..\wiacamd.cpp

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\camdlg\camdlg.h ===
#ifndef __CAMDLG_H_INCLUDED
#define __CAMDLG_H_INCLUDED

#include <windows.h>
#include "wia.h"
#include "wiadevd.h"
#include "citemlst.h"
#include "simarray.h"
#include "bkthread.h"
#include "gwiaevnt.h"
#include "createtb.h"

#define DEF_PICTURE_ICON 0
#define DEF_FOLDER_ICON 1
#define DEF_PARENT_ICON 2

class CCameraAcquireDialog
{
private:
    enum
    {
        MULTISEL_MODE  = 1,
        SINGLESEL_MODE = 2,
        BOTH_MODES     = 3
    };


private:
    HWND                              m_hWnd;
    bool                              m_bPreviewActive;
    SIZE                              m_sizeMinimumWindow;
    SIZE                              m_sizeThumbnails;
    PDEVICEDIALOGDATA                 m_pDeviceDialogData;
    SIZE                              m_CurrentAspectRatio;
    CCameraItemList                   m_CameraItemList;
    CCameraItem                      *m_pCurrentParentItem;
    CThreadMessageQueue              *m_pThreadMessageQueue;
    CSimpleEvent                      m_CancelEvent;
    bool                              m_bFirstTime;
    HANDLE                            m_hBackgroundThread;
    HIMAGELIST                        m_hImageList;
    HFONT                             m_hBigFont;
    DWORD                             m_nDialogMode;
    int                               m_nParentFolderImageListIndex;
    HACCEL                            m_hAccelTable;
    int                               m_nListViewWidth;
    HICON                             m_hIconLarge;
    HICON                             m_hIconSmall;
    CComPtr<IUnknown>                 m_DisconnectEvent;
    CComPtr<IUnknown>                 m_DeleteItemEvent;
    CComPtr<IUnknown>                 m_CreateItemEvent;
    bool                              m_bTakePictureIsSupported;
    ToolbarHelper::CToolbarBitmapInfo m_ToolbarBitmapInfo;

private:
    // No implementation
    CCameraAcquireDialog(void);
    CCameraAcquireDialog &operator=( const CCameraAcquireDialog & );
    CCameraAcquireDialog( const CCameraAcquireDialog & );
private:
    CCameraAcquireDialog( HWND hWnd );
protected:
    HWND CreateCameraDialogToolbar(VOID);
    VOID ResizeAll(VOID);
    HRESULT EnumerateItems( CCameraItem *pCurrentParent, IEnumWiaItem *pIWiaEnumItem );
    HRESULT EnumerateAllCameraItems(void);
    bool PopulateList( CCameraItem *pOldParent=NULL );
    HBITMAP CreateDefaultThumbnail( HDC hDC, HFONT hFont, int nWidth, int nHeight, LPCWSTR pszTitle, int nType );
    void CreateThumbnails( bool bForce=false );
    bool FindMaximumThumbnailSize(void);
    int GetSelectionIndices( CSimpleDynamicArray<int> &aIndices );
    CCameraItem *GetListItemNode( int nIndex );
    bool ChangeFolder( CCameraItem *pNode );
    bool ChangeToSelectedFolder(void);
    bool IsAFolderSelected(void);
    bool SetSelectedListItem( int nIndex );
    int FindItemInList( CCameraItem *pItem );
    void RequestThumbnails( CCameraItem *pRoot );
    void UpdatePreview(void);
    CCameraItem *GetCurrentPreviewItem(void);
    bool SetCurrentPreviewImage( const CSimpleString &strFilename, const CSimpleString &strTitle = TEXT("") );
    LRESULT OnEnterSizeMove( WPARAM, LPARAM );
    LRESULT OnExitSizeMove( WPARAM, LPARAM );
    void CancelAllPreviewRequests( CCameraItem *pRoot );
    void MarkItemDeletePending( int nIndex, bool bSet );
    void DeleteItem( CCameraItem *pItemNode );
    void HandleSelectionChange(void);

    void CreateThumbnails( CCameraItem *pRoot, HIMAGELIST hImageList, bool bForce );
    void CreateThumbnail( CCameraItem *pCurr, HIMAGELIST hImageList, bool bForce );
    void OnItemCreatedEvent( CGenericWiaEventHandler::CEventMessage *pEventMessage );

    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnSize( WPARAM, LPARAM );
    LRESULT OnShow( WPARAM, LPARAM );
    LRESULT OnGetMinMaxInfo( WPARAM, LPARAM );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnDblClkImageList( WPARAM, LPARAM );
    LRESULT OnImageListItemChanged( WPARAM, LPARAM );
    LRESULT OnImageListKeyDown( WPARAM, LPARAM );
    LRESULT OnTimer( WPARAM, LPARAM );
    LRESULT OnHelp( WPARAM, LPARAM );
    LRESULT OnContextMenu( WPARAM, LPARAM );
    LRESULT OnSysColorChange( WPARAM, LPARAM );

    LRESULT OnChangeToParent( WPARAM, LPARAM );
    LRESULT OnPostInit( WPARAM, LPARAM );

    LRESULT OnThumbnailStatus( WPARAM, LPARAM );
    LRESULT OnPreviewStatus( WPARAM, LPARAM );
    LRESULT OnPreviewPercent( WPARAM, LPARAM );
    LRESULT OnItemDeleted( WPARAM, LPARAM );
    LRESULT OnWiaEvent( WPARAM, LPARAM );

    VOID OnParentDir( WPARAM, LPARAM );
    VOID OnPreviewMode( WPARAM, LPARAM );
    VOID OnIconMode( WPARAM, LPARAM );
    VOID OnDelete( WPARAM, LPARAM );
    VOID OnOK( WPARAM, LPARAM );
    VOID OnCancel( WPARAM, LPARAM );
    VOID OnProperties( WPARAM, LPARAM );
    VOID OnSelectAll( WPARAM, LPARAM );
    VOID OnTakePicture( WPARAM, LPARAM );

    LRESULT OnNotify( WPARAM wParam, LPARAM lParam );
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam );

    // Hook procedure and static variables used to handle accelerators
    static HWND s_hWndDialog;
    static HHOOK s_hMessageHook;
    static LRESULT CALLBACK DialogHookProc( int nCode, WPARAM wParam, LPARAM );

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

public: // For now
    static BOOL WINAPI OnThreadDestroy( CThreadMessage *pMsg );
    static BOOL WINAPI OnGetThumbnail( CThreadMessage *pMsg );
    static BOOL WINAPI OnGetPreview( CThreadMessage *pMsg );
    static BOOL WINAPI OnThreadDeleteItem( CThreadMessage *pMsg );
};

#endif //__CAMDLG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\camdlg\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for camera dialog
 *
 *****************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <atlbase.h>
#include <commctrl.h>
#include <objbase.h>
#include <propidl.h>
#include <wia.h>
#include <wiadef.h>

#include "camdlg.rh"
#include "wiadebug.h"
#include "wianew.h"
#include "wiadevd.h"

#include "pshelper.h"
#include "uicommon.h"
#include "miscutil.h"

#include "simcrack.h"
#include "simstr.h"
#include "simbstr.h"
#include "simevent.h"

#include "multistr.h"
#include "pviewids.h"
#include "dlgunits.h"
#include "waitcurs.h"

extern HINSTANCE g_hInstance;

#include <shfusion.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\camdlg\wiacamd.cpp ===
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <commctrl.h>
#include <objbase.h>
#include "wiadebug.h"
#include "wiadevd.h"
#include "camdlg.rh"
#include "camdlg.h"
#include "pviewids.h"
#include "wiatextc.h"
#include "wiacamd.h"

HRESULT WINAPI CameraDeviceDialog( PDEVICEDIALOGDATA pDialogDeviceData )
{
    HRESULT hr = E_FAIL;
    if (pDialogDeviceData && pDialogDeviceData->cbSize == sizeof(DEVICEDIALOGDATA))
    {
        InitCommonControls();
        RegisterWiaPreviewClasses( g_hInstance );
        CWiaTextControl::RegisterClass(g_hInstance);
        hr = (HRESULT)DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_CAMERA), pDialogDeviceData->hwndParent, CCameraAcquireDialog::DialogProc, (LPARAM)pDialogDeviceData );
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\camdlg\wiacamd.h ===
#ifndef __WIACAMD_H_INCLUDED
#define __WIACAMD_H_INCLUDED

#include <windows.h>
#include "wiadevd.h"

HRESULT WINAPI CameraDeviceDialog( PDEVICEDIALOGDATA pDialogDeviceData );

#endif //__WIACAMD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\camdlg\camdlg.cpp ===
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <wia.h>
#include <wiadef.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <propidl.h>
#include "simstr.h"
#include "camdlg.h"
#include "camdlg.rh"
#include "simcrack.h"
#include "pviewids.h"
#include "dlgunits.h"
#include "miscutil.h"
#include "waitcurs.h"
#include "movewnd.h"
#include "simrect.h"
#include "simbstr.h"
#include "uiexthlp.h"
#include "gwiaevnt.h"
#include "wiacsh.h"
#include "wiadevdp.h"

//
// Thread queue messages
//
#define TQ_DESTROY      (WM_USER+1)
#define TQ_GETTHUMBNAIL (WM_USER+2)
#define TQ_GETPREVIEW   (WM_USER+3)
#define TQ_DELETEITEM   (WM_USER+4)

//
// Control ids
//
#define IDC_TOOLBAR         1112
#define IDC_SIZEBOX         1113

//
// The UI thread will notify us that it took ownership of the data.
// otherwise, it will be deleted in the worker thread
//
#define HANDLED_THREAD_MESSAGE  1000

//
// Help IDs
//
static const DWORD g_HelpIDs[] =
{
    IDC_CAMDLG_BIG_TITLE,     -1,
    IDC_CAMDLG_SUBTITLE,      -1,
    IDC_TOOLBAR_FRAME,        IDH_WIA_BUTTONS,
    IDC_TOOLBAR,              IDH_WIA_BUTTONS,
    IDOK,                     IDH_WIA_GET_PICS,
    IDC_THUMBNAILLIST,        IDH_WIA_PIC_LIST,
    IDC_YOU_CAN_ALSO,         IDH_WIA_VIEW_PIC_INFO,
    IDC_CAMDLG_PROPERTIES,    IDH_WIA_VIEW_PIC_INFO,
    IDC_PREVIEW,              IDH_WIA_PREVIEW_DETAIL,
    IDC_INNER_PREVIEW_WINDOW, IDH_WIA_PREVIEW_DETAIL,
    IDCANCEL,                 IDH_CANCEL,
    0, 0
};

//
// Update timer
//
#define IDT_UPDATEPREVIEW     1000
#define UPDATE_PREVIEW_DELAY   500

//
// Number of milliseconds between percent display updates
//
#define PERCENT_UPDATE_GRANULARITY 1000

//
// Private messages
//
#define PWM_POSTINIT         (WM_USER+1)
#define PWM_CHANGETOPARENT   (WM_USER+2)
#define PWM_THUMBNAILSTATUS  (WM_USER+3)
#define PWM_PREVIEWSTATUS    (WM_USER+4)
#define PWM_PREVIEWPERCENT   (WM_USER+5)
#define PWM_ITEMDELETED      (WM_USER+6)
#define PWM_WIAEVENT         (WM_USER+7)


//
// Thumbnail whitespace: the space in between images and their selection rectangles
// These values were discovered by trail and error.  For instance, if you reduce
// c_nAdditionalMarginY to 20, you get really bizarre spacing problems in the list view
// in vertical mode.  These values could become invalid in future versions of the listview.
//
static const int c_nAdditionalMarginX = 10;
static const int c_nAdditionalMarginY = 6;

static int c_nMinThumbnailWidth  = 90;
static int c_nMinThumbnailHeight = 90;

static int c_nMaxThumbnailWidth  = 120;
static int c_nMaxThumbnailHeight = 120;

//
// Button bar button bitmap sizes
//
static const int c_nButtonBitmapSizeX = 16;
static const int c_nButtonBitmapSizeY = 16;

//
// Button bar button sizes
//
static const int c_nButtonSizeX = 300;  // Ridiculously large size to compensate for BTNS_AUTOSIZE bug.
static const int c_nButtonSizeY = 16;

//
// Default preview mode list width
//
static const int c_nDefaultListViewWidth = 120;

//
// These defines let me compile with pre-nt5 headers
//
#ifndef BTNS_SEP
#define BTNS_SEP TBSTYLE_SEP
#endif

#ifndef BTNS_BUTTON
#define BTNS_BUTTON TBSTYLE_BUTTON
#endif

#ifndef ListView_SetExtendedListViewStyleEx
#define ListView_SetExtendedListViewStyleEx( h, m, s )
#endif


class CGlobalInterfaceTableThreadMessage : public CNotifyThreadMessage
{
private:
    DWORD m_dwGlobalInterfaceTableCookie;

private:
    //
    // No implementation
    //
    CGlobalInterfaceTableThreadMessage(void);
    CGlobalInterfaceTableThreadMessage &operator=( const CGlobalInterfaceTableThreadMessage & );
    CGlobalInterfaceTableThreadMessage( const CGlobalInterfaceTableThreadMessage & );

public:
    CGlobalInterfaceTableThreadMessage( int nMessage, HWND hWndNotify, DWORD dwGlobalInterfaceTableCookie )
      : CNotifyThreadMessage( nMessage, hWndNotify ),
        m_dwGlobalInterfaceTableCookie(dwGlobalInterfaceTableCookie)
    {
    }
    DWORD GlobalInterfaceTableCookie(void) const
    {
        return(m_dwGlobalInterfaceTableCookie);
    }
};


class CThumbnailThreadMessage : public CGlobalInterfaceTableThreadMessage
{
private:
    SIZE  m_sizeThumb;

private:
    //
    // No implementation
    //
    CThumbnailThreadMessage(void);
    CThumbnailThreadMessage &operator=( const CThumbnailThreadMessage & );
    CThumbnailThreadMessage( const CThumbnailThreadMessage & );

public:
    CThumbnailThreadMessage( HWND hWndNotify, DWORD dwGlobalInterfaceTableCookie, const SIZE &sizeThumb )
      : CGlobalInterfaceTableThreadMessage( TQ_GETTHUMBNAIL, hWndNotify, dwGlobalInterfaceTableCookie ),
        m_sizeThumb(sizeThumb)
    {
    }
    const SIZE &ThumbSize(void) const
    {
        return(m_sizeThumb);
    }
};

class CDeleteThreadMessage : public CGlobalInterfaceTableThreadMessage
{
private:
    //
    // No implementation
    //
    CDeleteThreadMessage(void);
    CDeleteThreadMessage &operator=( const CDeleteThreadMessage & );
    CDeleteThreadMessage( const CDeleteThreadMessage & );

public:
    CDeleteThreadMessage( HWND hWndNotify, DWORD dwGlobalInterfaceTableCookie )
      : CGlobalInterfaceTableThreadMessage( TQ_DELETEITEM, hWndNotify, dwGlobalInterfaceTableCookie )
    {
    }
};


class CPreviewThreadMessage : public CGlobalInterfaceTableThreadMessage
{
private:
    CSimpleEvent m_CancelEvent;

private:
    //
    // No implementation
    //
    CPreviewThreadMessage(void);
    CPreviewThreadMessage &operator=( const CPreviewThreadMessage & );
    CPreviewThreadMessage( const CPreviewThreadMessage & );

public:
    CPreviewThreadMessage( HWND hWndNotify, DWORD dwGlobalInterfaceTableCookie, HANDLE hCancelEvent )
      : CGlobalInterfaceTableThreadMessage( TQ_GETPREVIEW, hWndNotify, dwGlobalInterfaceTableCookie ),
        m_CancelEvent(hCancelEvent)
    {
    }
    CSimpleEvent &CancelEvent(void)
    {
        return(m_CancelEvent);
    }
};


BOOL WINAPI CCameraAcquireDialog::OnThreadDestroy( CThreadMessage * )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnThreadDestroy"));
    return(FALSE);
}

BOOL WINAPI CCameraAcquireDialog::OnThreadDeleteItem( CThreadMessage *pMsg )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnThreadDeleteItem"));
    CDeleteThreadMessage *pDeleteMsg = (CDeleteThreadMessage *)(pMsg);
    if (pDeleteMsg)
    {
        CComPtr<IGlobalInterfaceTable> pGlobalInterfaceTable;
        HRESULT hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&pGlobalInterfaceTable);
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pIWiaItem;
            hr = pGlobalInterfaceTable->GetInterfaceFromGlobal( pDeleteMsg->GlobalInterfaceTableCookie(), IID_IWiaItem, (void**)&pIWiaItem );
            if (SUCCEEDED(hr))
            {
                hr = WiaUiUtil::DeleteItemAndChildren(pIWiaItem);
                WIA_TRACE((TEXT("********************* pIWiaItem->DeleteItem returned %08X"), hr ));
                PostMessage( pDeleteMsg->NotifyWindow(), PWM_ITEMDELETED, pDeleteMsg->GlobalInterfaceTableCookie(), SUCCEEDED(hr) );
            }
        }
    }
    return(TRUE);
}

class CWiaDataCallback : public IWiaDataCallback
{
private:
    ULONG                   m_cRef;
    HWND                    m_hWndNotify;
    DWORD                   m_dwGlobalInterfaceTableCookie;
    CSimpleEvent            m_CancelEvent;
    DWORD                   m_dwPreviousTickCount;
    int                     m_nPercentGranularity;
public:
    CWiaDataCallback();
    ~CWiaDataCallback();

    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

    HRESULT _stdcall Initialize( HWND hWndNotify, DWORD dwGlobalInterfaceTableCookie, HANDLE hCancelEvent );

    HRESULT _stdcall BandedDataCallback(
                                       LONG lReason,
                                       LONG lStatus,
                                       LONG lPercentComplete,
                                       LONG lOffset,
                                       LONG lLength,
                                       LONG lReserved,
                                       LONG lResLength,
                                       BYTE *pbBuffer );
};




HRESULT _stdcall CWiaDataCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IWiaDataCallback)
    {
        *ppv = (IWiaDataCallback*)this;
    }
    else
    {
        return(E_NOINTERFACE);
    }

    AddRef();
    return(S_OK);
}

ULONG _stdcall CWiaDataCallback::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return(m_cRef);
}

ULONG _stdcall CWiaDataCallback::Release()
{
    ULONG ulRefCount = m_cRef - 1;
    if (InterlockedDecrement((long*) &m_cRef) == 0)
    {
        delete this;
        return(0);
    }
    return(ulRefCount);
}

CWiaDataCallback::CWiaDataCallback()
  : m_cRef(0),
    m_hWndNotify(NULL)
{
}


CWiaDataCallback::~CWiaDataCallback()
{
}


HRESULT _stdcall CWiaDataCallback::Initialize( HWND hWndNotify, DWORD dwGlobalInterfaceTableCookie, HANDLE hCancelEvent )
{
    m_hWndNotify = hWndNotify;
    m_dwGlobalInterfaceTableCookie = dwGlobalInterfaceTableCookie;
    m_CancelEvent = hCancelEvent;
    m_dwPreviousTickCount = 0xFFFFFF;
    m_nPercentGranularity = 3;
    return(S_OK);
}



HRESULT _stdcall CWiaDataCallback::BandedDataCallback(
                                                     LONG lMessage,
                                                     LONG lStatus,
                                                     LONG lPercentComplete,
                                                     LONG lOffset,
                                                     LONG lLength,
                                                     LONG lReserved,
                                                     LONG lResLength,
                                                     BYTE * /* pbBuffer */
                                                     )
{
    WIA_TRACE((TEXT("BandedDataCallback: lMessage: %d, lStatus: %d, lPercentComplete: %d, lOffset: %d, lLength: %d, lReserved: %d, lResLength: %d"), lMessage, lStatus, lPercentComplete, lOffset, lLength, lReserved, lResLength ));
    if (m_CancelEvent.Signalled())
        return(S_FALSE);
    switch (lMessage)
    {
    case IT_MSG_DATA_HEADER:
        {
        } // IT_MSG_DATA_HEADER

    case IT_MSG_DATA:
        {
        } // IT_STATUS_TRANSFER_TO_CLIENT
        break;

    case IT_MSG_STATUS:
        {
            // Don't send status messages too frequently.  Limit to one per PERCENT_UPDATE_GRANULARITY ms
            DWORD dwTickCount = GetTickCount();
            if ((dwTickCount - m_dwPreviousTickCount >= PERCENT_UPDATE_GRANULARITY) || (m_dwPreviousTickCount > dwTickCount))
            {
                m_dwPreviousTickCount = dwTickCount;
                PostMessage( m_hWndNotify, PWM_PREVIEWPERCENT, (WPARAM)m_dwGlobalInterfaceTableCookie, (LPARAM)MAKELPARAM((WORD)lPercentComplete,(WORD)lStatus));
            }
        } // IT_MSG_STATUS
        break;

    case IT_MSG_TERMINATION:
        {
        } // IT_MSG_TERMINATION
        break;
    }
    return(S_OK);
}


BOOL WINAPI CCameraAcquireDialog::OnGetPreview( CThreadMessage *pMsg )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnGetThumbnail"));
    CSimpleStringWide strwImageName(L"");
    CPreviewThreadMessage *pPreviewMsg = (CPreviewThreadMessage *)(pMsg);
    if (pPreviewMsg)
    {
        CComPtr<IGlobalInterfaceTable> pGlobalInterfaceTable;
        HRESULT hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IGlobalInterfaceTable,
                                       (void **)&pGlobalInterfaceTable);
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pIWiaItem;
            hr = pGlobalInterfaceTable->GetInterfaceFromGlobal( pPreviewMsg->GlobalInterfaceTableCookie(), IID_IWiaItem, (void**)&pIWiaItem );
            if (SUCCEEDED(hr))
            {
                CComPtr<IWiaDataTransfer> pIBandedTran;
                WIA_TRACE((TEXT("Preparing to call pIWiaItem->QueryInterface for IID_IWiaDataTransfer")));
                hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void**)&pIBandedTran);
                if (SUCCEEDED(hr))
                {
                    if (PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPA_FORMAT, WiaImgFmt_BMP, WIA_IPA_FIRST ) &&
                        PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPA_TYMED, TYMED_FILE, WIA_IPA_FIRST ))
                    {
                        CWiaDataCallback* pCDataCB = new CWiaDataCallback();
                        WIA_TRACE((TEXT("Preparing to call pCDataCB->Initialize")));
                        if (pCDataCB)
                        {
                            hr = pCDataCB->Initialize( pPreviewMsg->NotifyWindow(), pPreviewMsg->GlobalInterfaceTableCookie(), pPreviewMsg->CancelEvent().Event() );
                            if (SUCCEEDED(hr))
                            {
                                WIA_TRACE((TEXT("Preparing to call pCDataCB->QueryInterface on IID_IWiaDataCallback")));
                                CComPtr<IWiaDataCallback> pIWiaDataCallback;
                                hr = pCDataCB->QueryInterface(IID_IWiaDataCallback,(void **)&pIWiaDataCallback);
                                if (SUCCEEDED(hr))
                                {
                                    STGMEDIUM StgMedium;
                                    StgMedium.tymed          = TYMED_FILE;
                                    StgMedium.pUnkForRelease = NULL;
                                    StgMedium.hGlobal        = NULL;
                                    StgMedium.lpszFileName   = NULL;

                                    WIA_TRACE((TEXT("Preparing to call pIBandedTran->ibtGetData")));
                                    hr = pIBandedTran->idtGetData( &StgMedium, pIWiaDataCallback );
                                    if (SUCCEEDED(hr) && S_FALSE != hr)
                                    {
                                        strwImageName = StgMedium.lpszFileName;
                                        WIA_TRACE((TEXT("pIBandedTran->ibtGetData returned %s"),StgMedium.lpszFileName));
                                    }
                                    else
                                    {
                                        WIA_PRINTHRESULT((hr,TEXT("CCameraAcquireDialog::OnGetPreview, ibtGetData failed")));
                                    }
                                    //
                                    // Prevent leaks by freeing the filename.  We don't call ReleaseStgMeduim, because
                                    // it deletes the file as well.
                                    //
                                    if (SUCCEEDED(hr) && StgMedium.lpszFileName)
                                    {
                                        CoTaskMemFree(StgMedium.lpszFileName);
                                    }
                                }
                                else
                                {
                                    WIA_PRINTHRESULT((hr,TEXT("CCameraAcquireDialog::OnGetPreview, QI of IID_IWiaDataCallback failed")));
                                }
                            }
                            else
                            {
                                WIA_PRINTHRESULT((hr,TEXT("pCDataCB->Initialize failed")));
                            }
                        }
                        else
                        {
                            WIA_ERROR((TEXT("CCameraAcquireDialog::OnGetPreview, new on CWiaDataCallback failed")));
                        }
                    }
                    else
                    {
                        hr = MAKE_HRESULT(3,FACILITY_WIN32,ERROR_INVALID_DATA);
                        WIA_ERROR((TEXT("SetProperty on TYMED or FORMAT failed")));
                    }
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("CCameraAcquireDialog::OnGetPreview, QI of IID_IWiaDataTransfer failed")));
                }
                WIA_TRACE((TEXT("End CCameraAcquireDialog::OnGetPreviewBandedTransfer")));
            }
        }
        
        //
        // Allocate the filename string to return to the UI thread
        //
        CSimpleString *pstrDibFilename = new CSimpleString( CSimpleStringConvert::NaturalString(strwImageName) );

        //
        // Send the message to the UI thread
        //
        LRESULT lRes = SendMessage( pPreviewMsg->NotifyWindow(), PWM_PREVIEWSTATUS, pPreviewMsg->GlobalInterfaceTableCookie(), reinterpret_cast<LPARAM>(pstrDibFilename));

        //
        // If it fails for any reason, we will clean up to avoid leaks and orphaned temp files
        //
        if (HANDLED_THREAD_MESSAGE != lRes)
        {
            DeleteFile(CSimpleStringConvert::NaturalString(strwImageName));
            if (pstrDibFilename)
            {
                delete pstrDibFilename;
            }
        }

    }

    return(TRUE);
}

BOOL WINAPI CCameraAcquireDialog::OnGetThumbnail( CThreadMessage *pMsg )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnGetThumbnail"));
    HBITMAP hBmpThumbnail = NULL;
    CThumbnailThreadMessage *pThumbMsg = (CThumbnailThreadMessage *)(pMsg);
    if (pThumbMsg)
    {
        CComPtr<IGlobalInterfaceTable> pGlobalInterfaceTable;
        HRESULT hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IGlobalInterfaceTable,
                                       (void **)&pGlobalInterfaceTable);
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pIWiaItem;
            hr = pGlobalInterfaceTable->GetInterfaceFromGlobal( pThumbMsg->GlobalInterfaceTableCookie(), IID_IWiaItem, (void**)&pIWiaItem );
            if (SUCCEEDED(hr))
            {
#if defined(DBG)
                CSimpleStringWide strItemName;
                PropStorageHelpers::GetProperty( pIWiaItem, WIA_IPA_FULL_ITEM_NAME, strItemName );
                WIA_TRACE((TEXT("Getting thumbnail for %ws (0x%d, 0x%p)"), strItemName.String(), pThumbMsg->GlobalInterfaceTableCookie(), pIWiaItem.p ));
#endif
                CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
                hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropertyStorage);
                if (SUCCEEDED(hr))
                {
                    PROPVARIANT PropVar[3];
                    PROPSPEC PropSpec[3];

                    PropSpec[0].ulKind = PRSPEC_PROPID;
                    PropSpec[0].propid = WIA_IPC_THUMB_WIDTH;

                    PropSpec[1].ulKind = PRSPEC_PROPID;
                    PropSpec[1].propid = WIA_IPC_THUMB_HEIGHT;

                    PropSpec[2].ulKind = PRSPEC_PROPID;
                    PropSpec[2].propid = WIA_IPC_THUMBNAIL;
                    hr = pIWiaPropertyStorage->ReadMultiple(ARRAYSIZE(PropSpec),PropSpec,PropVar );
                    if (SUCCEEDED(hr))
                    {
                        WIA_TRACE((TEXT("Attempting to get the thumbnail for GIT entry: %08X, %08X, %08X, %08X"),pThumbMsg->GlobalInterfaceTableCookie(),PropVar[0].vt,PropVar[1].vt,PropVar[2].vt));
                        if ((PropVar[0].vt == VT_I4 || PropVar[0].vt == VT_UI4) &&
                            (PropVar[1].vt == VT_I4 || PropVar[1].vt == VT_UI4) &&
                            (PropVar[2].vt == (VT_UI1|VT_VECTOR)))
                        {
                            UINT nBitmapDataSize = WiaUiUtil::Align(PropVar[0].ulVal*3,sizeof(DWORD)) * PropVar[1].ulVal;
                            if (nBitmapDataSize  <= PropVar[2].caub.cElems)
                            {
                                BITMAPINFO bmi = {0};
                                bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
                                bmi.bmiHeader.biWidth           = PropVar[0].ulVal;
                                bmi.bmiHeader.biHeight          = PropVar[1].ulVal;
                                bmi.bmiHeader.biPlanes          = 1;
                                bmi.bmiHeader.biBitCount        = 24;
                                bmi.bmiHeader.biCompression     = BI_RGB;
                                bmi.bmiHeader.biSizeImage       = 0;
                                bmi.bmiHeader.biXPelsPerMeter   = 0;
                                bmi.bmiHeader.biYPelsPerMeter   = 0;
                                bmi.bmiHeader.biClrUsed         = 0;
                                bmi.bmiHeader.biClrImportant    = 0;

                                HDC hDC = GetDC(NULL);
                                if (hDC)
                                {
                                    PBYTE *pBits;
                                    HBITMAP hDibSection = CreateDIBSection( hDC, &bmi, DIB_RGB_COLORS, (PVOID*)&pBits, NULL, 0 );
                                    if (hDibSection)
                                    {
                                        WIA_TRACE((TEXT("pBits: 0x%p, PropVar[2].caub.pElems: 0x%p, PropVar[2].caub.cElems: %d"), pBits, PropVar[2].caub.pElems, PropVar[2].caub.cElems));
                                        CopyMemory( pBits, PropVar[2].caub.pElems, nBitmapDataSize );
                                        hr = ScaleImage( hDC, hDibSection, hBmpThumbnail, pThumbMsg->ThumbSize());
                                        if (SUCCEEDED(hr))
                                        {
                                            WIA_TRACE((TEXT("Sending this image (%p) to the notification window: %p"), hBmpThumbnail, pThumbMsg->NotifyWindow() ));
                                        }
                                        else hBmpThumbnail = NULL;
                                        DeleteObject(hDibSection);
                                    }
                                    else
                                    {
                                        WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("CreateDIBSection failed")));
                                    }
                                    ReleaseDC(NULL,hDC);
                                }
                                else
                                {
                                    WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("GetDC failed")));
                                }
                            }
                            else
                            {
                                WIA_ERROR((TEXT("nBitmapDataSize <= PropVar[2].caub.cElems was FALSE (%d, %d)"), nBitmapDataSize, PropVar[2].caub.cElems ));
                            }
                        }
                        PropVariantClear(&PropVar[0]);
                        PropVariantClear(&PropVar[1]);
                        PropVariantClear(&PropVar[2]);
                    }
                    else
                    {
                        WIA_PRINTHRESULT((hr,TEXT("pIWiaPropertyStorage->ReadMultiple failed")));
                    }
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("QueryInterface failed on IID_IWiaPropertyStorage")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("GetInterfaceFromGlobal failed on %08X"), pThumbMsg->GlobalInterfaceTableCookie() ));
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("CoCreateInstance failed on CLSID_StdGlobalInterfaceTable")));
        }
        
        //
        // Send the message to the UI thread
        //
        LRESULT lRes = SendMessage( pThumbMsg->NotifyWindow(), PWM_THUMBNAILSTATUS, (WPARAM)pThumbMsg->GlobalInterfaceTableCookie(), (LPARAM)hBmpThumbnail );

        //
        // If it fails for any reason, we will clean up to avoid leaks
        //
        if (HANDLED_THREAD_MESSAGE != lRes)
        {
            if (hBmpThumbnail)
            {
                DeleteObject( hBmpThumbnail );
            }
        }
    }
    else
    {
        WIA_ERROR((TEXT("pThumbMsg")));
    }
    return(TRUE);
}


int CCameraAcquireDialog::FindItemInList( CCameraItem *pItem )
{
    WIA_PUSH_FUNCTION((TEXT("CCameraAcquireDialog::FindItemInList( %08X )"), pItem ));
    if (pItem)
    {
        HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
        if (hwndList)
        {
            for (int i=0;i<ListView_GetItemCount(hwndList);i++)
            {
                CCameraItem *pCurrItem = GetListItemNode(i);
                if (pCurrItem)
                {
                    WIA_TRACE((TEXT("Comparing %08X and %08X [%ws] [%ws]"), pCurrItem, pItem, pCurrItem->FullItemName().String(), pItem->FullItemName().String() ));
                    if (*pCurrItem == *pItem)
                    {
                        return i;
                    }
                }
            }
        }
    }
    return(-1);
}

CCameraItem *CCameraAcquireDialog::GetCurrentPreviewItem(void)
{
    CSimpleDynamicArray<int> aSelIndices;
    GetSelectionIndices(aSelIndices);
    if (0 == aSelIndices.Size())
        return(NULL);
    if (1 == aSelIndices.Size())
        return(GetListItemNode(aSelIndices[0]));
    return(NULL);
}

bool CCameraAcquireDialog::SetCurrentPreviewImage( const CSimpleString &strFilename, const CSimpleString &strTitle )
{
    CWaitCursor wc;
    bool bResult = true;
    SendDlgItemMessage( m_hWnd, IDC_PREVIEW, WM_SETTEXT, 0, (LPARAM)strTitle.String() );
    SIZE sizeSavedAspectRatio = m_CurrentAspectRatio;
    // Set up a reasonable default
    m_CurrentAspectRatio.cx = 4;
    m_CurrentAspectRatio.cy = 3;
    if (strFilename.Length())
    {
        HBITMAP hBmp = (HBITMAP)LoadImage( g_hInstance, strFilename.String(), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION|LR_LOADFROMFILE );
        if (hBmp)
        {
            BITMAP bm;
            if (GetObject( hBmp, sizeof(BITMAP), &bm ))
            {
                m_CurrentAspectRatio.cx = bm.bmWidth;
                m_CurrentAspectRatio.cy = bm.bmHeight;
            }
        }
        SendDlgItemMessage( m_hWnd, IDC_PREVIEW, PWM_SETBITMAP, MAKEWPARAM(FALSE,FALSE), (LPARAM)hBmp );
        if (memcmp(&sizeSavedAspectRatio,&m_CurrentAspectRatio,sizeof(SIZE)))
            ResizeAll();
        bResult = (hBmp != NULL);
    }
    else
    {
        if (SendDlgItemMessage( m_hWnd, IDC_PREVIEW, PWM_GETBITMAP, 0, 0 ))
            SendDlgItemMessage( m_hWnd, IDC_PREVIEW, PWM_SETBITMAP, MAKEWPARAM(FALSE,FALSE), 0 );
        if (memcmp(&sizeSavedAspectRatio,&m_CurrentAspectRatio,sizeof(SIZE)))
            ResizeAll();
    }
    InvalidateRect( GetDlgItem( m_hWnd, IDC_PREVIEW ), NULL, FALSE );
    UpdateWindow( GetDlgItem( m_hWnd, IDC_PREVIEW ) );
    return(bResult);
}

// wParam = GIT cookie
// lParam = nPercent
LRESULT CCameraAcquireDialog::OnPreviewPercent( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnPreviewPercent"));
    CCameraItem *pCameraItem = m_CameraItemList.Find( (DWORD)wParam );
    if (pCameraItem)
    {
        pCameraItem->CurrentPreviewPercentage((int)LOWORD(lParam));
        CCameraItem *pCurrSel = GetCurrentPreviewItem();
        if (pCameraItem == pCurrSel)
        {
            UpdatePreview();
        }
    }
    return(0);
}

// wParam = GIT cookie
// lParam = HBITMAP
LRESULT CCameraAcquireDialog::OnPreviewStatus( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnPreviewStatus"));
    CSimpleString *pstrFilename = reinterpret_cast<CSimpleString*>(lParam);
    if (pstrFilename)
    {
        CCameraItem *pCameraItem = m_CameraItemList.Find( static_cast<DWORD>(wParam) );
        if (pCameraItem)
        {
            if (!pCameraItem->CancelQueueEvent().Signalled())
            {
                // If we weren't cancelled, set the filename
                pCameraItem->PreviewFileName(*pstrFilename);
            }
            pCameraItem->CloseCancelEvent();

            CCameraItem *pCurrSel = GetCurrentPreviewItem();
            if (pCameraItem == pCurrSel)
            {
                SetCurrentPreviewImage( pCameraItem->PreviewFileName() );
            }
        }
        delete pstrFilename;
    }

    return HANDLED_THREAD_MESSAGE;
}

LRESULT CCameraAcquireDialog::OnThumbnailStatus( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnThumbnailStatus"));
    WIA_TRACE((TEXT("Looking for the item with the ID %08X"),wParam));
    CCameraItem *pCameraItem = m_CameraItemList.Find( (DWORD)wParam );
    if (pCameraItem)
    {
        WIA_TRACE((TEXT("Found a CameraItem * (%08X)"),pCameraItem));
        HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
        if (hwndList)
        {
            WIA_TRACE((TEXT("Got the list control")));
            HIMAGELIST hImageList = ListView_GetImageList( hwndList, LVSIL_NORMAL );
            if (hImageList)
            {
                WIA_TRACE((TEXT("Got the image list")));
                if ((HBITMAP)lParam)
                {
                    WIA_TRACE((TEXT("hBitmap = %p"), lParam));
                    if (ImageList_Replace( hImageList, pCameraItem->ImageListIndex(), reinterpret_cast<HBITMAP>(lParam), NULL ))
                    {
                        WIA_TRACE((TEXT("Replaced the image in the list")));
                        int nItem = FindItemInList(pCameraItem);
                        if (nItem >= 0)
                        {
                            WIA_TRACE((TEXT("Found the item in the list")));
                            //
                            // Set the image to a dummy image
                            //
                            LV_ITEM lvItem;
                            ::ZeroMemory(&lvItem,sizeof(LV_ITEM));
                            lvItem.iItem = nItem;
                            lvItem.mask = LVIF_IMAGE;
                            lvItem.iImage = -1;
                            ListView_SetItem( hwndList, &lvItem );

                            //
                            // Then set the image to the real image
                            //
                            ::ZeroMemory(&lvItem,sizeof(LV_ITEM));
                            lvItem.iItem = nItem;
                            lvItem.mask = LVIF_IMAGE;
                            lvItem.iImage = pCameraItem->ImageListIndex();
                            ListView_SetItem( hwndList, &lvItem );
                        }
                    }
                }
            }
        }
    }

    //
    // Clean up the bitmap, regardless of any other failures, to avoid memory leaks
    //
    HBITMAP hBmpThumb = reinterpret_cast<HBITMAP>(lParam);
    if (hBmpThumb)
    {
        DeleteObject(hBmpThumb);
    }
    return HANDLED_THREAD_MESSAGE;
}

static CThreadMessageMap g_MsgMap[] =
{
    { TQ_DESTROY, CCameraAcquireDialog::OnThreadDestroy },
    { TQ_GETTHUMBNAIL, CCameraAcquireDialog::OnGetThumbnail },
    { TQ_GETPREVIEW, CCameraAcquireDialog::OnGetPreview },
    { TQ_DELETEITEM, CCameraAcquireDialog::OnThreadDeleteItem },
    { 0, NULL}
};

//
// Sole constructor
//
CCameraAcquireDialog::CCameraAcquireDialog( HWND hWnd )
  : m_hWnd(hWnd),
    m_bPreviewActive(false),
    m_pCurrentParentItem(NULL),
    m_bFirstTime(true),
    m_hBackgroundThread(NULL),
    m_hBigFont(NULL),
    m_nDialogMode(0),
    m_hAccelTable(NULL),
    m_nListViewWidth(0),
    m_hIconLarge(NULL),
    m_hIconSmall(NULL),
    m_pThreadMessageQueue(NULL),
    m_bTakePictureIsSupported(false),
    m_ToolbarBitmapInfo( g_hInstance, IDB_TOOLBAR )
{
    m_pThreadMessageQueue = new CThreadMessageQueue;
    if (m_pThreadMessageQueue)
    {
        //
        // Note that CBackgroundThread takes ownership of m_pThreadMessageQueue, and it doesn't have to be deleted in this thread
        //
        m_hBackgroundThread = CBackgroundThread::Create( m_pThreadMessageQueue, g_MsgMap, m_CancelEvent.Event(), g_hInstance );
    }
    m_sizeThumbnails.cx = c_nMaxThumbnailWidth;
    m_sizeThumbnails.cy = c_nMaxThumbnailHeight;
    m_CurrentAspectRatio.cx = 4;
    m_CurrentAspectRatio.cy = 3;
    WIA_ASSERT(m_hBackgroundThread != NULL);
}

HWND CCameraAcquireDialog::CreateCameraDialogToolbar(VOID)
{
    ToolbarHelper::CButtonDescriptor aSingleSelModeButtons[] =
    {
        { 0, IDC_ICONMODE,     TBSTATE_ENABLED|TBSTATE_CHECKED, BTNS_AUTOSIZE|BTNS_BUTTON|BTNS_CHECK, true, NULL, IDS_ICONMODE },
        { 1, IDC_PREVIEWMODE,  TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON|BTNS_CHECK, true, NULL, IDS_PREVIEWMODE },
        { 2, IDC_TAKEPICTURE,  TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON, true, &m_bTakePictureIsSupported, IDS_TAKEPICTURE },
        { 4, IDC_DELETE,       TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON, false, NULL, IDS_DELETE_SINGULAR }
    };
    ToolbarHelper::CButtonDescriptor aMultiSelModeButtons[] =
    {
        { 0, IDC_ICONMODE,     TBSTATE_ENABLED|TBSTATE_CHECKED, BTNS_AUTOSIZE|BTNS_BUTTON|BTNS_CHECK, true, NULL, IDS_ICONMODE },
        { 1, IDC_PREVIEWMODE,  TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON|BTNS_CHECK, true, NULL, IDS_PREVIEWMODE },
        { 2, IDC_TAKEPICTURE,  TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON, true, &m_bTakePictureIsSupported, IDS_TAKEPICTURE },
        { 3, IDC_SELECTALL,    TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON, true, NULL, IDS_SELECTALL },
        { 4, IDC_DELETE,       TBSTATE_ENABLED,                 BTNS_AUTOSIZE|BTNS_BUTTON, false, NULL, IDS_DELETE }
    };
    
    ToolbarHelper::CButtonDescriptor *pButtonDescriptors = aSingleSelModeButtons;
    int nButtonDescriptorCount = ARRAYSIZE(aSingleSelModeButtons);
    if (m_nDialogMode & MULTISEL_MODE)
    {
        pButtonDescriptors = aMultiSelModeButtons;
        nButtonDescriptorCount = ARRAYSIZE(aMultiSelModeButtons);
    }
    
    return ToolbarHelper::CreateToolbar( m_hWnd, GetDlgItem( m_hWnd, IDC_CAMDLG_SUBTITLE ), GetDlgItem( m_hWnd, IDC_TOOLBAR_FRAME ), ToolbarHelper::AlignLeft|ToolbarHelper::AlignTop, IDC_TOOLBAR, m_ToolbarBitmapInfo, pButtonDescriptors, nButtonDescriptorCount );
}


HRESULT CCameraAcquireDialog::EnumerateItems( CCameraItem *pCurrentParent, IEnumWiaItem *pIEnumWiaItem )
{
    WIA_PUSHFUNCTION(TEXT("CCameraItemList::EnumerateItems"));
    HRESULT hr = E_FAIL;
    if (pIEnumWiaItem != NULL)
    {
        hr = pIEnumWiaItem->Reset();
        while (hr == S_OK)
        {
            CComPtr<IWiaItem> pIWiaItem;
            hr = pIEnumWiaItem->Next(1, &pIWiaItem, NULL);
            if (hr == S_OK)
            {
                CCameraItem *pNewCameraItem = new CCameraItem( pIWiaItem );
                if (pNewCameraItem && pNewCameraItem->Item())
                {
                    LONG ItemType = 0;
                    hr = pNewCameraItem->Item()->GetItemType(&ItemType);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // If it is an image, add it to the list
                        //
                        if (ItemType & WiaItemTypeImage)
                        {
                            //
                            // Add it to the list
                            //
                            m_CameraItemList.Add( pCurrentParent, pNewCameraItem );
                            WIA_TRACE((TEXT("Found an image")));
                        }

                        //
                        // If it is a folder, enumerate its child items and recurse
                        //
                        else if (ItemType & WiaItemTypeFolder)
                        {
                            //
                            // Add this folder to the list
                            //
                            m_CameraItemList.Add( pCurrentParent, pNewCameraItem );

                            //
                            // Enumerate the child items
                            //
                            CComPtr <IEnumWiaItem> pIEnumChildItem;
                            if (S_OK == pIWiaItem->EnumChildItems(&pIEnumChildItem))
                            {
                                EnumerateItems( pNewCameraItem, pIEnumChildItem );
                            }
                        }
                        else
                        {
                            //
                            // Delete this item, since we didn't add it to the list
                            //
                            delete pNewCameraItem;
                            WIA_TRACE((TEXT("Found something that is NOT an image")));
                        }
                    }
                }
            }
        }
    }
    return hr;
}



HRESULT CCameraAcquireDialog::EnumerateAllCameraItems(void)
{
    CComPtr<IEnumWiaItem> pIEnumItem;
    HRESULT hr = m_pDeviceDialogData->pIWiaItemRoot->EnumChildItems(&pIEnumItem);
    if (hr == S_OK)
    {
        hr = EnumerateItems( NULL, pIEnumItem );
    }
    return(hr);
}

void CCameraAcquireDialog::OnItemCreatedEvent( CGenericWiaEventHandler::CEventMessage *pEventMessage )
{
    //
    // Get the listview, which we'll need later
    //
    HWND hwndListview = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (hwndListview)
    {
        //
        // Get the image list
        //
        HIMAGELIST hImageList = ListView_GetImageList( hwndListview, LVSIL_NORMAL );
        if (hImageList)
        {
            //
            // Make sure we don't already have this item
            //
            CCameraItem *pCreatedItem = m_CameraItemList.Find(CSimpleBStr(pEventMessage->FullItemName()));
            if (!pCreatedItem)
            {
                //
                // Get the IWiaItem* for this item
                //
                CComPtr<IWiaItem> pWiaItem;
                HRESULT hr = m_pDeviceDialogData->pIWiaItemRoot->FindItemByName(0,CSimpleBStr(pEventMessage->FullItemName()).BString(),&pWiaItem);
                if (SUCCEEDED(hr) && pWiaItem.p)
                {
                    //
                    // Create an item wrapper
                    //
                    CCameraItem *pNewCameraItem = new CCameraItem( pWiaItem );
                    if (pNewCameraItem && pNewCameraItem->Item())
                    {
                        //
                        // Add it to the list
                        //
                        m_CameraItemList.Add( NULL, pNewCameraItem );

                        //
                        // Generate a thumbnail
                        //
                        CreateThumbnail( pNewCameraItem, hImageList, false );

                        //
                        // If this item is in the current folder, add it to the listview
                        //
                        if (m_pCurrentParentItem == pNewCameraItem->Parent())
                        {
                            int nListViewCount = ListView_GetItemCount(hwndListview);

                            //
                            // Add the item
                            //
                            LVITEM lvItem = {0};
                            lvItem.iItem = nListViewCount;
                            lvItem.mask = LVIF_IMAGE|LVIF_PARAM;
                            lvItem.iImage = pNewCameraItem->ImageListIndex();
                            lvItem.lParam = reinterpret_cast<LPARAM>(pNewCameraItem);
                            int nIndex = ListView_InsertItem( hwndListview, &lvItem );

                            //
                            // Make sure the new item is visible
                            //
                            if (nIndex >= 0)
                            {
                                ListView_EnsureVisible( hwndListview, nIndex, FALSE );
                            }
                        }

                        //
                        // Request a thumbnail from the background thread
                        //
                        m_pThreadMessageQueue->Enqueue( new CThumbnailThreadMessage( m_hWnd, pNewCameraItem->GlobalInterfaceTableCookie(), m_sizeThumbnails ) );
                    }
                }
            }
        }
    }
}


bool CCameraAcquireDialog::PopulateList( CCameraItem *pOldParent )
{
    //
    // Which item should be selected?
    //
    int nSelItem = 0;

    //
    // Get the list view control
    //
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (hwndList)
    {
        //
        // Empty the list
        //
        ListView_DeleteAllItems( hwndList );

        //
        // Where to insert the current item
        //
        int nCurrentItem = 0;


        CCameraItem *pCurr;

        //
        // If this is a child directory...
        //
        if (m_pCurrentParentItem)
        {
            //
            // Start adding children
            //
            pCurr = m_pCurrentParentItem->Children();

            //
            // Insert a dummy item that the user can use to switch to the parent directory
            //
            LVITEM lvItem;
            ZeroMemory( &lvItem, sizeof(lvItem) );
            lvItem.iItem = nCurrentItem++;
            lvItem.mask = LVIF_IMAGE|LVIF_PARAM;
            lvItem.iImage = m_nParentFolderImageListIndex;
            lvItem.lParam = 0;
            ListView_InsertItem( hwndList, &lvItem );
        }
        //
        // Otherwise, we are at the root
        //
        else pCurr = m_CameraItemList.Root();

        //
        // Iterate through this list of images, and add each one
        //
        while (pCurr)
        {
            //
            // If this is the last parent directory, we want it to be selected instead of the first image
            //
            if (pOldParent && *pCurr == *pOldParent)
            {
                nSelItem = nCurrentItem;
            }

            //
            // If this image hasn't been deleted
            //
            if (pCurr->DeleteState() != CCameraItem::Delete_Deleted)
            {
                //
                // Add the item
                //
                LVITEM lvItem = {0};
                lvItem.iItem = nCurrentItem++;
                lvItem.mask = LVIF_IMAGE|LVIF_PARAM;
                lvItem.iImage = pCurr->ImageListIndex();
                lvItem.lParam = reinterpret_cast<LPARAM>(pCurr);
                int nIndex = ListView_InsertItem( hwndList, &lvItem );

                if (nIndex >= 0 && pCurr->DeleteState() == CCameraItem::Delete_Pending)
                {
                    MarkItemDeletePending(nIndex,true);
                }
            }

            //
            // Advance
            //
            pCurr = pCurr->Next();
        }
    }

    //
    // If we've not calculated the width of the list in preview mode, attempt to do it
    //
    if (!m_nListViewWidth)
    {
        RECT rcItem;
        if (ListView_GetItemRect( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ), 0, &rcItem, LVIR_ICON ))
        {
            m_nListViewWidth = (rcItem.right-rcItem.left) + rcItem.left * 2 + GetSystemMetrics(SM_CXHSCROLL)  + c_nAdditionalMarginX;
        }
    }

    //
    // Set the selected item to either the previous directory, or the first image
    //
    SetSelectedListItem(nSelItem);
    return(true);
}

void CCameraAcquireDialog::CreateThumbnail( CCameraItem *pCurr, HIMAGELIST hImageList, bool bForce )
{
    //
    // Make sure we have a valid item
    //
    if (pCurr && (pCurr->ImageListIndex()<0 || bForce))
    {
        //
        // Get the item name
        //
        CSimpleStringWide strItemName;
        PropStorageHelpers::GetProperty( pCurr->Item(), WIA_IPA_ITEM_NAME, strItemName );

        //
        // Create the title for the icon
        //
        CSimpleString strIconTitle;
        if (pCurr->IsFolder())
        {
            strIconTitle = CSimpleStringConvert::NaturalString(strItemName);
        }
        else if (strItemName.Length())
        {
            strIconTitle.Format( IDS_DOWNLOADINGTHUMBNAIL, g_hInstance, CSimpleStringConvert::NaturalString(strItemName).String() );
        }

        //
        // Create the thumbnail
        //
        HBITMAP hBmp = WiaUiUtil::CreateIconThumbnail( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ), m_sizeThumbnails.cx, m_sizeThumbnails.cy, g_hInstance, pCurr->IsImage()?IDI_UNAVAILABLE:IDI_FOLDER, strIconTitle );
        if (hBmp)
        {
            //
            // If we don't have an image yet, add it
            //
            if (pCurr->ImageListIndex()<0)
            {
                pCurr->ImageListIndex(ImageList_Add( hImageList, hBmp, NULL ));
            }

            //
            // Otherwise, replace it
            //
            else
            {
                pCurr->ImageListIndex(ImageList_Replace( hImageList, pCurr->ImageListIndex(), hBmp, NULL ));
            }

            //
            // Delete it, since the imagelist makes a copy
            //
            DeleteObject(hBmp);
        }
    }
}

void CCameraAcquireDialog::CreateThumbnails( CCameraItem *pRoot, HIMAGELIST hImageList, bool bForce )
{
    CCameraItem *pCurr = pRoot;
    while (pCurr)
    {
        //
        // Create the thumbnail
        //
        CreateThumbnail( pCurr, hImageList, bForce );

        //
        // If there are children, recurse into that list
        //
        CreateThumbnails( pCurr->Children(), hImageList, bForce );

        //
        // Advance
        //
        pCurr = pCurr->Next();
    }
}


void CCameraAcquireDialog::RequestThumbnails( CCameraItem *pRoot )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::RequestThumbnails"));
    CCameraItem *pCurr = pRoot;
    while (pCurr)
    {
        if (pCurr->IsImage())
        {
            m_pThreadMessageQueue->Enqueue( new CThumbnailThreadMessage( m_hWnd, pCurr->GlobalInterfaceTableCookie(), m_sizeThumbnails ) );
        }
        if (pCurr->Children())
        {
            RequestThumbnails( pCurr->Children() );
        }
        pCurr = pCurr->Next();
    }
}


void CCameraAcquireDialog::CreateThumbnails( bool bForce )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (hwndList)
    {
        HIMAGELIST hImageList = ListView_GetImageList( hwndList, LVSIL_NORMAL );
        if (hImageList)
        {
            //
            // Create the parent folder image
            //
            HBITMAP hParentBitmap = WiaUiUtil::CreateIconThumbnail( hwndList, m_sizeThumbnails.cx, m_sizeThumbnails.cy, g_hInstance, IDI_PARENTFOLDER, TEXT("(..)") );
            if (hParentBitmap)
            {
                m_nParentFolderImageListIndex = ImageList_Add( hImageList, hParentBitmap, NULL );
                DeleteObject(hParentBitmap);
            }
            CCameraAcquireDialog::CreateThumbnails( m_CameraItemList.Root(), hImageList, bForce );
        }
    }
}

bool CCameraAcquireDialog::FindMaximumThumbnailSize(void)
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::FindMaximumThumbnailSize"));
    bool bResult = false;
    if (m_pDeviceDialogData && m_pDeviceDialogData->pIWiaItemRoot)
    {
        LONG nWidth, nHeight;
        if (PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPC_THUMB_WIDTH, nWidth ) &&
            PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPC_THUMB_WIDTH, nHeight ))
        {
            m_sizeThumbnails.cx = max(c_nMinThumbnailWidth,min(nWidth,c_nMaxThumbnailWidth));
            m_sizeThumbnails.cy = max(c_nMinThumbnailHeight,min(nHeight,c_nMaxThumbnailHeight));
        }
        else WIA_TRACE((TEXT("FindMaximumThumbnailSize: Unable to retrieve thumbnail size for device")));
    }
    return(bResult && m_sizeThumbnails.cx && m_sizeThumbnails.cy);
}

//
// Hook procedure and static variables used to handle accelerators
//
LRESULT CALLBACK CCameraAcquireDialog::DialogHookProc( int nCode, WPARAM wParam, LPARAM lParam )
{
    if (nCode < 0) 
        return CallNextHookEx( s_hMessageHook, nCode, wParam, lParam );
    if (nCode == MSGF_DIALOGBOX)
    {
        MSG *pMsg = reinterpret_cast<MSG*>(lParam);
        if (pMsg)
        {
            if (pMsg->hwnd == s_hWndDialog || (s_hWndDialog && IsChild(s_hWndDialog,pMsg->hwnd)))
            {
                CCameraAcquireDialog *pCameraAcquireDialog = reinterpret_cast<CCameraAcquireDialog*>(GetWindowLongPtr(s_hWndDialog,DWLP_USER));
                if (pCameraAcquireDialog && pCameraAcquireDialog->m_hAccelTable)
                {
                    if (TranslateAccelerator(s_hWndDialog,pCameraAcquireDialog->m_hAccelTable,pMsg))
                        return 1; // Ensure the window won't process the message
                }
            }
        }
    }
    return CallNextHookEx( s_hMessageHook, nCode, wParam, lParam );
}


LRESULT CCameraAcquireDialog::OnInitDialog( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnInitDialog"));
    CWaitCursor wc;

    //
    // Make sure the background queue was successfully created
    //
    if (!m_pThreadMessageQueue)
    {
        WIA_ERROR((TEXT("CAMDLG: unable to start background queue")));
        EndDialog( m_hWnd, E_OUTOFMEMORY );
        return(0);
    }

    m_pDeviceDialogData = (PDEVICEDIALOGDATA)lParam;

    // Save the window handle for the hook
    s_hWndDialog = m_hWnd;

    // Install the message hook, which we use for accelerator support
    s_hMessageHook = SetWindowsHookEx( WH_MSGFILTER, DialogHookProc, g_hInstance, GetCurrentThreadId() );
    if (!s_hMessageHook)
    {
        WIA_ERROR((TEXT("CAMDLG: Unable to set thread msg hook")));
        EndDialog( m_hWnd, HRESULT_FROM_WIN32(GetLastError()));
        return(0);
    }

    // Make sure we have valid arguments
    if (!m_pDeviceDialogData)
    {
        WIA_ERROR((TEXT("CAMDLG: Invalid paramater: PDEVICEDIALOGDATA")));
        EndDialog( m_hWnd, E_INVALIDARG );
        return(0);
    }

    // Initialialize our return stuff
    if (m_pDeviceDialogData)
    {
        m_pDeviceDialogData->lItemCount = 0;
        m_pDeviceDialogData->ppWiaItems = NULL;
    }

    // Make sure we have valid a valid device
    if (!m_pDeviceDialogData->pIWiaItemRoot)
    {
        WIA_ERROR((TEXT("CAMDLG: Invalid paramaters: pIWiaItem")));
        EndDialog( m_hWnd, E_INVALIDARG );
        return(0);
    }

    //
    // Find out if Take Picture is supported
    //
    m_bTakePictureIsSupported = WiaUiUtil::IsDeviceCommandSupported( m_pDeviceDialogData->pIWiaItemRoot, WIA_CMD_TAKE_PICTURE );

    // Prevent multiple selection
    if (m_pDeviceDialogData->dwFlags & WIA_DEVICE_DIALOG_SINGLE_IMAGE)
    {
        LONG_PTR lStyle = GetWindowLongPtr( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ), GWL_STYLE );
        SetWindowLongPtr( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ), GWL_STYLE, lStyle | LVS_SINGLESEL );

        // Set the single sel titles
        CSimpleString( IDS_TITLE_SINGLE_SEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMDLG_BIG_TITLE ) );
        CSimpleString( IDS_SUBTITLE_SINGLE_SEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMDLG_SUBTITLE ) );
        CSimpleString( IDS_OK_SINGLE_SEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDOK ) );
        m_nDialogMode = SINGLESEL_MODE;
    }
    else
    {
        // Set the multi sel subtitle
        CSimpleString( IDS_TITLE_MULTI_SEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMDLG_BIG_TITLE ) );
        CSimpleString( IDS_SUBTITLE_MULTI_SEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMDLG_SUBTITLE ) );
        CSimpleString( IDS_OK_MULTI_SEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDOK ) );
        m_nDialogMode = MULTISEL_MODE;
    }


    // Make the lovely font
    m_hBigFont = WiaUiUtil::CreateFontWithPointSizeFromWindow( GetDlgItem(m_hWnd,IDC_CAMDLG_BIG_TITLE), 14, false, false );
    if (m_hBigFont)
        SendDlgItemMessage( m_hWnd, IDC_CAMDLG_BIG_TITLE, WM_SETFONT, reinterpret_cast<WPARAM>(m_hBigFont), MAKELPARAM(TRUE,0));


    // Create the Tool Bar and resize the dialog to accommodate it
    (void)CreateCameraDialogToolbar();

    // Get the minimum size of the dialog
    RECT rcWindow;
    GetWindowRect( m_hWnd, &rcWindow );
    m_sizeMinimumWindow.cx = rcWindow.right - rcWindow.left;
    m_sizeMinimumWindow.cy = rcWindow.bottom - rcWindow.top;

    // Initialize the preview control
    WiaPreviewControl_AllowNullSelection( GetDlgItem( m_hWnd, IDC_PREVIEW ), TRUE );
    WiaPreviewControl_ClearSelection( GetDlgItem( m_hWnd, IDC_PREVIEW ) );
    WiaPreviewControl_DisableSelection( GetDlgItem( m_hWnd, IDC_PREVIEW ), TRUE );
    WiaPreviewControl_SetBorderSize( GetDlgItem( m_hWnd, IDC_PREVIEW ), FALSE, FALSE, 0 );
    WiaPreviewControl_SetBgAlpha( GetDlgItem( m_hWnd, IDC_PREVIEW ), FALSE, 0xFF );

    // Set the lovely title
    CSimpleStringWide strwDeviceName;
    if (PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DIP_DEV_NAME, strwDeviceName ))
    {
        CSimpleString().Format( IDS_CAMERADLG_TITLE, g_hInstance, strwDeviceName.String() ).SetWindowText( m_hWnd );
    }

    // Create the sizing control
    (void)CreateWindowEx( 0, TEXT("scrollbar"), TEXT(""),
        WS_CHILD|WS_VISIBLE|SBS_SIZEGRIP|WS_CLIPSIBLINGS|SBS_SIZEBOXBOTTOMRIGHTALIGN|SBS_BOTTOMALIGN|WS_GROUP,
        CSimpleRect(m_hWnd).Width()-GetSystemMetrics(SM_CXVSCROLL),
        CSimpleRect(m_hWnd).Height()-GetSystemMetrics(SM_CYHSCROLL),
        GetSystemMetrics(SM_CXVSCROLL),
        GetSystemMetrics(SM_CYHSCROLL),
        m_hWnd, reinterpret_cast<HMENU>(IDC_SIZEBOX),
        g_hInstance, NULL );

    // Reposition all the controls
    ResizeAll();

    // Center the window over its parent
    WiaUiUtil::CenterWindow( m_hWnd, GetParent(m_hWnd) );

    // Get the device icons and set the window icons
    CSimpleStringWide strwDeviceId, strwClassId;
    LONG nDeviceType;
    if (PropStorageHelpers::GetProperty(m_pDeviceDialogData->pIWiaItemRoot,WIA_DIP_UI_CLSID,strwClassId) &&
        PropStorageHelpers::GetProperty(m_pDeviceDialogData->pIWiaItemRoot,WIA_DIP_DEV_ID,strwDeviceId) &&
        PropStorageHelpers::GetProperty(m_pDeviceDialogData->pIWiaItemRoot,WIA_DIP_DEV_TYPE,nDeviceType))
    {
        //
        // Register for disconnect event
        //
        CGenericWiaEventHandler::RegisterForWiaEvent( strwDeviceId.String(), WIA_EVENT_DEVICE_DISCONNECTED, &m_DisconnectEvent, m_hWnd, PWM_WIAEVENT );
        CGenericWiaEventHandler::RegisterForWiaEvent( strwDeviceId.String(), WIA_EVENT_ITEM_DELETED, &m_DeleteItemEvent, m_hWnd, PWM_WIAEVENT );
        CGenericWiaEventHandler::RegisterForWiaEvent( strwDeviceId.String(), WIA_EVENT_ITEM_CREATED, &m_CreateItemEvent, m_hWnd, PWM_WIAEVENT );

        if (SUCCEEDED(WiaUiExtensionHelper::GetDeviceIcons( CSimpleBStr(strwClassId), nDeviceType, &m_hIconSmall, &m_hIconLarge )))
        {
            if (m_hIconSmall)
            {
                SendMessage( m_hWnd, WM_SETICON, ICON_SMALL, reinterpret_cast<LPARAM>(m_hIconSmall) );
            }
            if (m_hIconLarge)
            {
                SendMessage( m_hWnd, WM_SETICON, ICON_BIG, reinterpret_cast<LPARAM>(m_hIconLarge) );
            }
        }
    }

    int nAcceleratorCount = 0;
    ACCEL Accelerators[10];
    //
    // Load the accelerator table resource and convert it to an ACCEL array
    //
    HACCEL hAccel = LoadAccelerators( g_hInstance, MAKEINTRESOURCE(IDR_CAMERA_ACCEL) );
    if (hAccel)
    {
        //
        // Copy the accelerator table to an array of ACCEL
        //
        nAcceleratorCount = CopyAcceleratorTable( hAccel, Accelerators, ARRAYSIZE(Accelerators) );

        //
        // Free the accelerator table
        //
        DestroyAcceleratorTable( hAccel );
    }

    //
    // Create the accelerator table for the toolbar
    //
    nAcceleratorCount += ToolbarHelper::GetButtonBarAccelerators( GetDlgItem( m_hWnd, IDC_TOOLBAR ), Accelerators+nAcceleratorCount, ARRAYSIZE(Accelerators)-nAcceleratorCount );
    if (nAcceleratorCount)
    {
        m_hAccelTable = CreateAcceleratorTable( Accelerators, nAcceleratorCount );
        if (!m_hAccelTable)
        {
            WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("CreateAcceleratorTable failed")));
        }
    }

    SetForegroundWindow(m_hWnd);

    //
    // Make sure the listview has the focus
    //
    SetFocus( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ) );

    return (TRUE);
}

VOID CCameraAcquireDialog::ResizeAll(VOID)
{
    CSimpleRect rcClient(m_hWnd);
    CMoveWindow mw;
    CDialogUnits dialogUnits(m_hWnd);

    // Resize the big title
    mw.Size( GetDlgItem( m_hWnd, IDC_CAMDLG_BIG_TITLE ),
             rcClient.Width() - dialogUnits.StandardMargin().cx * 2,
             0,
             CMoveWindow::NO_SIZEY );

    // Resize the subtitle
    mw.Size( GetDlgItem( m_hWnd, IDC_CAMDLG_SUBTITLE ),
             rcClient.Width() - dialogUnits.StandardMargin().cx * 2,
             0,
             CMoveWindow::NO_SIZEY );

    int nToolBarHeight = (int)(HIWORD((DWORD)(SendMessage(GetDlgItem( m_hWnd, IDC_TOOLBAR ), TB_GETBUTTONSIZE, 0,0))));

    // Resize the toolbar frame
    mw.Size( GetDlgItem(m_hWnd,IDC_TOOLBAR_FRAME),
             rcClient.Width() - dialogUnits.StandardMargin().cx * 2,
             nToolBarHeight + 4,
             0 );

    // Get the dialog's client coordinates of the toolbar frame's client rect
    CSimpleRect rcToolbarFrameInside( GetDlgItem(m_hWnd,IDC_TOOLBAR_FRAME), CSimpleRect::ClientRect );
    rcToolbarFrameInside = rcToolbarFrameInside.ClientToScreen(GetDlgItem(m_hWnd,IDC_TOOLBAR_FRAME));
    rcToolbarFrameInside = rcToolbarFrameInside.ScreenToClient(m_hWnd);

    // Move and resize the toolbar
    mw.SizeMove( GetDlgItem( m_hWnd, IDC_TOOLBAR ),
                 rcToolbarFrameInside.left + 2,
                 rcToolbarFrameInside.top + 2,
                 rcClient.Width() - dialogUnits.StandardMargin().cx * 2 - 4,
                 nToolBarHeight,
                 0 );

    // Save the bottom of this control for later
    int nBottomOfToolbarFrame = CSimpleRect( GetDlgItem(m_hWnd,IDC_TOOLBAR_FRAME), CSimpleRect::WindowRect ).ScreenToClient(m_hWnd).top + nToolBarHeight + 4;


    // Move the Properties control
    mw.SizeMove( GetDlgItem( m_hWnd, IDC_CAMDLG_PROPERTIES ),
                 0,
                 rcClient.Height() - dialogUnits.StandardMargin().cy - dialogUnits.Y(8) + 2,
                 dialogUnits.StandardMargin().cx,
                 dialogUnits.Y(8) + 2,
                 CMoveWindow::NO_MOVEX|CMoveWindow::NO_SIZEX );

    // Move the static text above it
    mw.Move( GetDlgItem( m_hWnd, IDC_YOU_CAN_ALSO ),
             dialogUnits.StandardMargin().cx,
             rcClient.Height() - dialogUnits.StandardMargin().cy - dialogUnits.Y(8) - 2 - dialogUnits.Y(8)
           );


    CSimpleRect rcOK( GetDlgItem( m_hWnd, IDOK ), CSimpleRect::WindowRect );
    CSimpleRect rcCancel( GetDlgItem( m_hWnd, IDOK ), CSimpleRect::WindowRect );

    // Move the OK button
    mw.Move( GetDlgItem( m_hWnd, IDOK ),
             rcClient.Width() - dialogUnits.StandardMargin().cx - dialogUnits.StandardButtonMargin().cx - rcCancel.Width() - rcOK.Width(),
             rcClient.Height() - dialogUnits.StandardMargin().cy - rcOK.Height(),
             0 );

    // Move the cancel button
    mw.Move( GetDlgItem( m_hWnd, IDCANCEL ),
             rcClient.Width() - dialogUnits.StandardMargin().cx - rcCancel.Width(),
             rcClient.Height() - dialogUnits.StandardMargin().cy - rcCancel.Height(),
             0 );

    // Move the resizing handle
    mw.Move( GetDlgItem( m_hWnd, IDC_SIZEBOX ),
             rcClient.Width() - GetSystemMetrics(SM_CXVSCROLL),
             rcClient.Height() - GetSystemMetrics(SM_CYHSCROLL)
             );

    int nHeightOfBottomControls =
        dialogUnits.Y(8) + 2 +            // Highlight control
        dialogUnits.Y(8) +                // Static description text
        dialogUnits.StandardMargin().cy;  // Top of these controls

    CSimpleRect rcAvailableArea(
        dialogUnits.StandardMargin().cx,
        nBottomOfToolbarFrame + dialogUnits.StandardMargin().cy,
        rcClient.right - dialogUnits.StandardMargin().cx,
        rcClient.bottom - nHeightOfBottomControls - dialogUnits.StandardMargin().cy
        );

    if (m_bPreviewActive)
    {
        // If we've already calculated the actual width of the preview mode list, use it, otherwise use the default
        int nListViewWidth = m_nListViewWidth ? m_nListViewWidth : c_nDefaultListViewWidth;

        // Move the thumbnail list
        mw.SizeMove( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ),
                     rcAvailableArea.left,
                     rcAvailableArea.top,
                     nListViewWidth,
                     rcAvailableArea.Height()
                   );

        // Remove the rect of the list view from the preview area
        rcAvailableArea.left += nListViewWidth + dialogUnits.StandardMargin().cx;

        // Use up the remaining area
        mw.SizeMove( GetDlgItem( m_hWnd, IDC_PREVIEW ),
                     rcAvailableArea.left,
                     rcAvailableArea.top,
                     rcAvailableArea.Width(),
                     rcAvailableArea.Height() );

    }
    else
    {
        // Move the thumbnail list
        mw.SizeMove( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ),
                     rcAvailableArea.left,
                     rcAvailableArea.top,
                     rcAvailableArea.Width(),
                     rcAvailableArea.Height()
                   );

    }

    // Explicitly apply the moves, because the toolbar frame doesn't get painted properly
    mw.Apply();

    if (m_bPreviewActive)
    {
        // Show the preview in case it isn't visible
        mw.Show( GetDlgItem( m_hWnd, IDC_PREVIEW ) );
    }
    else
    {
        // Hide the preview in case it is visible
        mw.Hide( GetDlgItem( m_hWnd, IDC_PREVIEW ) );
    }

    //
    // Update the dialog's background to remove any weird stuff left behind
    //
    InvalidateRect( m_hWnd, NULL, FALSE );
    UpdateWindow( m_hWnd );
}


LRESULT CCameraAcquireDialog::OnItemDeleted( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnItemDeleted"));
    CCameraItem *pDeletedItem = m_CameraItemList.Find((DWORD)wParam);
    if (pDeletedItem)
    {
        BOOL bSuccess = (BOOL)lParam;
        pDeletedItem->DeleteState( bSuccess ? CCameraItem::Delete_Deleted : CCameraItem::Delete_Visible );
        if (pDeletedItem == m_pCurrentParentItem)
        {
            ChangeFolder(m_pCurrentParentItem->Parent());
        }

        int nIndex = FindItemInList(pDeletedItem);
        if (nIndex >= 0)
        {
            if (bSuccess)
            {
                // Remove the item from the list
                ListView_DeleteItem(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ),nIndex);

                // Make sure we leave something selected
                if (!ListView_GetSelectedCount(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST )))
                {
                    int nItemCount = ListView_GetItemCount(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ));
                    if (nItemCount)
                    {
                        if (nIndex >= nItemCount)
                            nIndex = nItemCount-1;
                        SetSelectedListItem(nIndex);
                    }
                }
                else
                {
                    // Make sure we update control's state when the list is empty
                    HandleSelectionChange();
                }
            }
            else
            {
                // If the delete failed, remove the deleted state
                MarkItemDeletePending(nIndex,false);

                // Tell the user
                MessageBeep( MB_ICONASTERISK );
            }
        }
    }
    return (0);
}

LRESULT CCameraAcquireDialog::OnWiaEvent( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnWiaEvent"));
    CGenericWiaEventHandler::CEventMessage *pEventMessage = reinterpret_cast<CGenericWiaEventHandler::CEventMessage *>(lParam);
    if (pEventMessage)
    {
        if (pEventMessage->EventId() == WIA_EVENT_DEVICE_DISCONNECTED)
        {
            WIA_TRACE((TEXT("Received disconnect event")));
            EndDialog( m_hWnd, WIA_ERROR_OFFLINE );
        }
        else if (pEventMessage->EventId() == WIA_EVENT_ITEM_CREATED)
        {
            OnItemCreatedEvent( pEventMessage );
        }
        else if (pEventMessage->EventId() == WIA_EVENT_ITEM_DELETED)
        {
            WIA_TRACE((TEXT("Received deleted item event")));

            CCameraItem *pDeletedItem = m_CameraItemList.Find(CSimpleBStr(pEventMessage->FullItemName()));
            if (pDeletedItem)
            {
                //
                // If we're deleting the current parent item,
                // select a new one.
                //
                if (pDeletedItem == m_pCurrentParentItem)
                {
                    ChangeFolder(m_pCurrentParentItem->Parent());
                }

                int nIndex = FindItemInList(pDeletedItem);
                if (nIndex >= 0)
                {
                    //
                    // Remove the item from the listview
                    //
                    ListView_DeleteItem(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ),nIndex);

                    //
                    // Make sure we leave something selected
                    //
                    if (!ListView_GetSelectedCount(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST )))
                    {
                        int nItemCount = ListView_GetItemCount(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ));
                        if (nItemCount)
                        {
                            if (nIndex >= nItemCount)
                            {
                                nIndex = nItemCount-1;
                            }

                            SetSelectedListItem(nIndex);
                        }
                    }
                    else
                    {
                        //
                        // Make sure we update control's state when the list is empty
                        //
                        HandleSelectionChange();
                    }
                }
                else
                {
                    WIA_ERROR((TEXT("FindItemInList coulnd't find the item")));
                }

                //
                // Mark the item as deleted.
                //
                pDeletedItem->DeleteState( CCameraItem::Delete_Deleted );

            }
            else
            {
                WIA_ERROR((TEXT("The item could not be found in m_CameraItemList")));
            }
        }
        delete pEventMessage;
    }
    return HANDLED_EVENT_MESSAGE;
}


LRESULT CCameraAcquireDialog::OnEnterSizeMove( WPARAM, LPARAM )
{
    SendDlgItemMessage( m_hWnd, IDC_PREVIEW, WM_ENTERSIZEMOVE, 0, 0 );
    return(0);
}


LRESULT CCameraAcquireDialog::OnExitSizeMove( WPARAM, LPARAM )
{
    SendDlgItemMessage( m_hWnd, IDC_PREVIEW, WM_EXITSIZEMOVE, 0, 0 );
    return(0);
}


LRESULT CCameraAcquireDialog::OnSize( WPARAM, LPARAM )
{
    ResizeAll();
    return(0);
}


LRESULT CCameraAcquireDialog::OnShow( WPARAM, LPARAM )
{
    if (m_bFirstTime)
    {
        PostMessage( m_hWnd, PWM_POSTINIT, 0, 0 );
        m_bFirstTime = false;
    }
    return(0);
}


LRESULT CCameraAcquireDialog::OnGetMinMaxInfo( WPARAM, LPARAM lParam )
{
    LPMINMAXINFO pMinMaxInfo = (LPMINMAXINFO)lParam;
    pMinMaxInfo->ptMinTrackSize.x = m_sizeMinimumWindow.cx;
    pMinMaxInfo->ptMinTrackSize.y = m_sizeMinimumWindow.cy;
    return(0);
}


LRESULT CCameraAcquireDialog::OnDestroy( WPARAM, LPARAM )
{
    //
    // Get rid of all preview requests
    //
    CancelAllPreviewRequests( m_CameraItemList.Root() );

    //
    // Tell the background thread to destroy itself
    //
    m_pThreadMessageQueue->Enqueue( new CThreadMessage(TQ_DESTROY),CThreadMessageQueue::PriorityUrgent);

    //
    // Set the window icon to NULL
    //
    SendMessage( m_hWnd, WM_SETICON, ICON_BIG, 0 );
    SendMessage( m_hWnd, WM_SETICON, ICON_SMALL, 0 );

    //
    // Clear the image list and list view.  This should be unnecessary, but BoundsChecker
    // complains if I don't do it.
    //
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (hwndList)
    {
        ListView_DeleteAllItems(hwndList);

        HIMAGELIST hImgList = ListView_SetImageList( hwndList, NULL, LVSIL_NORMAL );
        if (hImgList)
        {
            ImageList_Destroy(hImgList);
        }
    }


    //
    // Delete resources
    //
    if (m_hBigFont)
    {
        DeleteObject(m_hBigFont);
        m_hBigFont = NULL;
    }
    if (m_hImageList)
    {
        m_hImageList = NULL;
    }
    if (m_hAccelTable)
    {
        DestroyAcceleratorTable(m_hAccelTable);
        m_hAccelTable = NULL;
    }
    if (s_hMessageHook)
    {
        UnhookWindowsHookEx(s_hMessageHook);
        s_hMessageHook = NULL;
    }
    if (m_hIconLarge)
    {
        DestroyIcon(m_hIconLarge);
        m_hIconLarge = NULL;
    }
    if (m_hIconSmall)
    {
        DestroyIcon(m_hIconSmall);
        m_hIconSmall = NULL;
    }
    if (m_hBackgroundThread)
    {
        CloseHandle(m_hBackgroundThread);
        m_hBackgroundThread = NULL;
    }
    return(0);
}



VOID CCameraAcquireDialog::OnPreviewMode( WPARAM, LPARAM )
{
    m_bPreviewActive = true;
    SendDlgItemMessage( m_hWnd, IDC_TOOLBAR, TB_SETSTATE, IDC_PREVIEWMODE, MAKELONG(TBSTATE_ENABLED|TBSTATE_CHECKED,0) );
    SendDlgItemMessage( m_hWnd, IDC_TOOLBAR, TB_SETSTATE, IDC_ICONMODE, MAKELONG(TBSTATE_ENABLED,0) );
    ResizeAll();
    UpdatePreview();
}

VOID CCameraAcquireDialog::OnTakePicture( WPARAM, LPARAM )
{
    //
    // Tell the device to snap a picture
    //
    if (m_pDeviceDialogData->pIWiaItemRoot && m_bTakePictureIsSupported)
    {
        CWaitCursor wc;
        CComPtr<IWiaItem> pNewWiaItem;
        m_pDeviceDialogData->pIWiaItemRoot->DeviceCommand(0,&WIA_CMD_TAKE_PICTURE,&pNewWiaItem);
    }
}

VOID CCameraAcquireDialog::OnIconMode( WPARAM, LPARAM )
{
    m_bPreviewActive = false;
    SendDlgItemMessage( m_hWnd, IDC_TOOLBAR, TB_SETSTATE, IDC_ICONMODE, MAKELONG(TBSTATE_ENABLED|TBSTATE_CHECKED,0) );
    SendDlgItemMessage( m_hWnd, IDC_TOOLBAR, TB_SETSTATE, IDC_PREVIEWMODE, MAKELONG(TBSTATE_ENABLED,0) );
    ResizeAll();
    UpdatePreview();
}

LRESULT CCameraAcquireDialog::OnPostInit( WPARAM, LPARAM )
{
    //
    // Create the progress dialog
    //
    CComPtr<IWiaProgressDialog> pWiaProgressDialog;
    HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&pWiaProgressDialog );
    if (SUCCEEDED(hr))
    {
        //
        // Initialize the progress dialog
        //
        pWiaProgressDialog->Create( m_hWnd, WIA_PROGRESSDLG_ANIM_CAMERA_COMMUNICATE|WIA_PROGRESSDLG_NO_PROGRESS|WIA_PROGRESSDLG_NO_CANCEL|WIA_PROGRESSDLG_NO_TITLE );
        pWiaProgressDialog->SetTitle( CSimpleStringConvert::WideString(CSimpleString(IDS_CAMDLG_PROGDLG_TITLE,g_hInstance)));
        pWiaProgressDialog->SetMessage( CSimpleStringConvert::WideString(CSimpleString(IDS_CAMDLG_PROGDLG_MESSAGE,g_hInstance)));

        //
        // Show the progress dialog
        //
        pWiaProgressDialog->Show();

        //
        // Find all of the images in the camera
        //
        EnumerateAllCameraItems();

        //
        // Find the largest possible thumbnail
        //
        FindMaximumThumbnailSize();

        //
        // Initialize Thumbnail Listview control
        //
        HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
        if (hwndList)
        {
            //
            // Get rid of the border and icon labels
            //
            ListView_SetExtendedListViewStyleEx( hwndList, LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|LVS_EX_DOUBLEBUFFER, LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|LVS_EX_DOUBLEBUFFER );

            //
            // Create the large image list
            //
            m_hImageList = ImageList_Create( m_sizeThumbnails.cx, m_sizeThumbnails.cy, ILC_COLOR24|ILC_MIRROR, 50, 50 );
            if (m_hImageList)
            {

                //
                // Set the image list
                //
                ListView_SetImageList( hwndList, m_hImageList, LVSIL_NORMAL );
            }

            //
            // Set the icon spacing
            //
            ListView_SetIconSpacing( hwndList, m_sizeThumbnails.cx + c_nAdditionalMarginX, m_sizeThumbnails.cy + c_nAdditionalMarginY );
        }

        //
        // Create all of the initial thumbnails
        //
        CreateThumbnails();

        //
        // This causes the list to be populated
        //
        ChangeFolder(NULL);

        //
        // Force a selection change
        //
        HandleSelectionChange();

        //
        // Download all of the thumbnails
        //
        RequestThumbnails( m_CameraItemList.Root() );

        //
        // Close the progress dialog
        //
        pWiaProgressDialog->Destroy();
    }
    return(0);
}

LRESULT CCameraAcquireDialog::OnChangeToParent( WPARAM, LPARAM )
{
    if (m_pCurrentParentItem)
        ChangeFolder(m_pCurrentParentItem->Parent());
    return(0);
}

VOID CCameraAcquireDialog::OnParentDir( WPARAM, LPARAM )
{
    if (m_pCurrentParentItem && m_pCurrentParentItem->Parent())
        ChangeFolder(m_pCurrentParentItem->Parent());
    else ChangeFolder(NULL);
}

void CCameraAcquireDialog::MarkItemDeletePending( int nIndex, bool bSet )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (hwndList)
    {
        ListView_SetItemState( hwndList, nIndex, bSet ? LVIS_CUT : 0, LVIS_CUT );
    }
}

// Recursively delete items
void CCameraAcquireDialog::DeleteItem( CCameraItem *pItemNode )
{
    if (pItemNode)
    {
        CCameraItem *pChild = pItemNode->Children();
        while (pChild)
        {
            DeleteItem(pChild);
            pChild = pChild->Next();
        }
        if (pItemNode->DeleteState() == CCameraItem::Delete_Visible)
        {
            int nIndex = FindItemInList( pItemNode );
            if (nIndex >= 0)
            {
                //
                // Mark it pending in the UI
                //
                MarkItemDeletePending(nIndex,true);
            }
            //
            // Mark it pending
            //
            pItemNode->DeleteState( CCameraItem::Delete_Pending );

            //
            // Fire off the request
            //
            m_pThreadMessageQueue->Enqueue( new CDeleteThreadMessage(m_hWnd, pItemNode->GlobalInterfaceTableCookie()), CThreadMessageQueue::PriorityHigh );
        }
    }
}


VOID CCameraAcquireDialog::OnDelete( WPARAM, LPARAM )
{
    CSimpleDynamicArray<int> aSelIndices;
    if (GetSelectionIndices( aSelIndices ))
    {
        //
        // We only want to show the confirm dialog once
        //
        bool bShowConfirmDialog = true;
        for (int i=0;i<aSelIndices.Size();i++)
        {
            CCameraItem *pItemNode = GetListItemNode(aSelIndices[i]);

            //
            // If we haven't already deleted this image, do so
            //
            if (pItemNode && pItemNode->DeleteState() == CCameraItem::Delete_Visible && pItemNode->ItemRights() & WIA_ITEM_CAN_BE_DELETED)
            {
                if (bShowConfirmDialog)
                {
                    bShowConfirmDialog = false;
                    if (IDYES!=MessageBox( m_hWnd, CSimpleString( IDS_DELETE_CONFIRM, g_hInstance ), CSimpleString( IDS_DELETE_CONFIRM_TITLE, g_hInstance ), MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2 ))
                    {
                        break;
                    }
                }
                DeleteItem( pItemNode );
            }
        }
    }
}


int CCameraAcquireDialog::GetSelectionIndices( CSimpleDynamicArray<int> &aIndices )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (!hwndList)
        return(0);
    int iCount = ListView_GetItemCount(hwndList);
    for (int i=0;i<iCount;i++)
        if (ListView_GetItemState(hwndList,i,LVIS_SELECTED) & LVIS_SELECTED)
            aIndices.Append(i);
    return(aIndices.Size());
}

bool CCameraAcquireDialog::SetSelectedListItem( int nIndex )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (!hwndList)
        return(false);
    int iCount = ListView_GetItemCount(hwndList);
    for (int i=0;i<iCount;i++)
        ListView_SetItemState(hwndList,i,LVIS_SELECTED|LVIS_FOCUSED,0);
    ListView_SetItemState(hwndList,nIndex,LVIS_SELECTED|LVIS_FOCUSED,LVIS_SELECTED|LVIS_FOCUSED);
    ListView_EnsureVisible(hwndList,nIndex,FALSE);
    return(true);
}

CCameraItem *CCameraAcquireDialog::GetListItemNode( int nIndex )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_THUMBNAILLIST );
    if (!hwndList)
        return(NULL);
    LV_ITEM lvItem;
    ::ZeroMemory(&lvItem,sizeof(LV_ITEM));
    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = nIndex;
    if (!ListView_GetItem( hwndList, &lvItem ))
        return(NULL);
    return((CCameraItem *)lvItem.lParam);
}

bool CCameraAcquireDialog::ChangeFolder( CCameraItem *pNode )
{
    CCameraItem *pOldParent = m_pCurrentParentItem;
    m_pCurrentParentItem = pNode;
    return(PopulateList(pOldParent));
}

bool CCameraAcquireDialog::ChangeToSelectedFolder(void)
{
    CSimpleDynamicArray<int> aSelIndices;
    if (GetSelectionIndices(aSelIndices))
    {
        //
        // Find out if only folders are selected
        //
        bool bOnlyFoldersSelected = true;
        for (int i=0;i<aSelIndices.Size();i++)
        {
            CCameraItem *pItemNode = GetListItemNode(aSelIndices[i]);
            if (pItemNode && !pItemNode->IsFolder())
            {
                bOnlyFoldersSelected = false;
                break;
            }
        }

        WIA_TRACE((TEXT("bOnlyFoldersSelected = %d"),bOnlyFoldersSelected));

        //
        // If only folders are selected, switch to the first selected folder
        //
        if (bOnlyFoldersSelected && aSelIndices.Size())
        {
            CCameraItem *pItemNode = GetListItemNode(aSelIndices[0]);
            if (!pItemNode)
            {
                //
                // NULL item node == parent folder
                //
                SendMessage( m_hWnd, PWM_CHANGETOPARENT, 0, 0 );
                return(true);
            }
            if (pItemNode && pItemNode->IsFolder() && pItemNode->DeleteState() == CCameraItem::Delete_Visible)
            {
                if (ChangeFolder(pItemNode))
                {
                    return(true);
                }
            }
        }
    }
    return(false);
}

VOID CCameraAcquireDialog::OnOK( WPARAM, LPARAM )
{
    if (!ChangeToSelectedFolder())
    {
        HRESULT hr = S_OK;
        m_pDeviceDialogData->lItemCount = 0;
        m_pDeviceDialogData->ppWiaItems = NULL;
        CSimpleDynamicArray<int> aIndices;
        GetSelectionIndices( aIndices );
        if (aIndices.Size())
        {
            int nArraySizeInBytes = sizeof(IWiaItem*) * aIndices.Size();
            m_pDeviceDialogData->ppWiaItems = (IWiaItem**)CoTaskMemAlloc(nArraySizeInBytes);
            if (m_pDeviceDialogData->ppWiaItems)
            {
                ZeroMemory( m_pDeviceDialogData->ppWiaItems, nArraySizeInBytes );
                int nCurrItem = 0;
                for (int i=0;i<aIndices.Size();i++)
                {
                    CCameraItem *pItem = GetListItemNode(aIndices[i]);

                    //
                    // Add the item to the list if it is both a valid picture item and it hasn't been deleted
                    //
                    if (pItem && pItem->Item() && pItem->IsImage() && pItem->DeleteState() == CCameraItem::Delete_Visible)
                    {
                        m_pDeviceDialogData->ppWiaItems[nCurrItem] = pItem->Item();
                        m_pDeviceDialogData->ppWiaItems[nCurrItem]->AddRef();
                        nCurrItem++;
                    }
                }
                m_pDeviceDialogData->lItemCount = nCurrItem;
            }
            else
            {
                // Unable to alloc mem
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            return;
        }
        EndDialog( m_hWnd, hr );
    }
}


VOID CCameraAcquireDialog::OnCancel( WPARAM, LPARAM )
{
    EndDialog( m_hWnd, S_FALSE );
}

VOID CCameraAcquireDialog::OnSelectAll( WPARAM, LPARAM )
{
    ListView_SetItemState( GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ), -1, LVIS_SELECTED, LVIS_SELECTED );
}

VOID CCameraAcquireDialog::OnProperties( WPARAM, LPARAM )
{
    CSimpleDynamicArray<int> aSelIndices;
    if (GetSelectionIndices( aSelIndices ))
    {
        if (aSelIndices.Size() == 1)
        {
            CCameraItem *pItemNode = GetListItemNode(aSelIndices[0]);
            if (pItemNode && pItemNode->Item())
            {
                m_pThreadMessageQueue->Pause();
                HRESULT hr = WiaUiUtil::SystemPropertySheet( g_hInstance, m_hWnd, pItemNode->Item(), CSimpleString( IDS_CAMDLG_PROPERTIES_TITLE, g_hInstance ) );
                if (!SUCCEEDED(hr))
                {
                    if (PROP_SHEET_ERROR_NO_PAGES == hr)
                    {
                        MessageBox( m_hWnd, CSimpleString( IDS_CAMDLG_PROPSHEETNOPAGES, g_hInstance ), CSimpleString( IDS_CAMDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
                    }
                    else
                    {
                        MessageBox( m_hWnd, CSimpleString( IDS_CAMDLG_PROPSHEETERROR, g_hInstance ), CSimpleString( IDS_CAMDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
                    }
                    WIA_PRINTHRESULT((hr,TEXT("SystemPropertySheet failed")));
                }
                m_pThreadMessageQueue->Resume();
            }
        }
    }
}

LRESULT CCameraAcquireDialog::OnDblClkImageList( WPARAM, LPARAM )
{
    SendMessage( m_hWnd, WM_COMMAND, MAKEWPARAM(IDOK,0), 0 );
    return(0);
}

void CCameraAcquireDialog::CancelAllPreviewRequests( CCameraItem *pRoot )
{
    CCameraItem *pCurr = pRoot;
    while (pCurr)
    {
        if (pCurr->PreviewRequestPending())
            pCurr->SetCancelEvent();
        if (pCurr->Children())
            CancelAllPreviewRequests( pCurr->Children() );
        pCurr = pCurr->Next();
    }
}

void CCameraAcquireDialog::UpdatePreview(void)
{
    if (m_bPreviewActive)
    {
        CCameraItem *pCurrPreviewItem = GetCurrentPreviewItem();
        if (pCurrPreviewItem && pCurrPreviewItem->IsImage())
        {
            // If we're not already downloading this preview image...
            if (!pCurrPreviewItem->PreviewRequestPending())
            {
                // Cancel all other preview requests
                CancelAllPreviewRequests( m_CameraItemList.Root() );

                if (pCurrPreviewItem->PreviewFileName().Length())
                {
                    // Set the preview if we've got it cached
                    SetCurrentPreviewImage( pCurrPreviewItem->PreviewFileName() );
                }
                else
                {
                    CSimpleString strPct;
                    strPct.Format( IDS_DOWNLOADINGPREVIEW, g_hInstance, 0 );

                    // Clear the preview window
                    SetCurrentPreviewImage( TEXT(""), strPct );

                    // Create our cancel event
                    pCurrPreviewItem->CreateCancelEvent();
                    // Reset it, just in case
                    pCurrPreviewItem->ResetCancelEvent();
                    // Make the request
                    m_pThreadMessageQueue->Enqueue( new CPreviewThreadMessage( m_hWnd, pCurrPreviewItem->GlobalInterfaceTableCookie(), pCurrPreviewItem->CancelQueueEvent().Event() ), CThreadMessageQueue::PriorityHigh );
                }
            }
            else
            {
                CSimpleString strPct;
                strPct.Format( IDS_DOWNLOADINGPREVIEW, g_hInstance, pCurrPreviewItem->CurrentPreviewPercentage() );

                SetCurrentPreviewImage( TEXT(""), strPct );
            }
        }
        else
        {
            SetCurrentPreviewImage( TEXT("") );
            CancelAllPreviewRequests( m_CameraItemList.Root() );
        }
    }
    else
    {
        CancelAllPreviewRequests( m_CameraItemList.Root() );
        SetCurrentPreviewImage( TEXT("") );
    }
}

LRESULT CCameraAcquireDialog::OnTimer( WPARAM wParam, LPARAM )
{
    switch (wParam)
    {
    case IDT_UPDATEPREVIEW:
        {
            KillTimer( m_hWnd, IDT_UPDATEPREVIEW );
            UpdatePreview();
        }
        break;
    }
    return(0);
}

// Avoids unnecessary state changes
static inline void MyEnableWindow( HWND hWnd, BOOL bEnable )
{
    if (bEnable && !IsWindowEnabled(hWnd))
        EnableWindow(hWnd,TRUE);
    else if (!bEnable && IsWindowEnabled(hWnd))
        EnableWindow(hWnd,FALSE);
}

// Avoids unnecessary state changes
static inline void MyEnableToolbarButton( HWND hWnd, int nId, BOOL bEnable )
{
    LRESULT nState = SendMessage( hWnd, TB_GETSTATE, nId, 0 );
    if (nState < 0)
        return;
    if ((nState & TBSTATE_ENABLED) && !bEnable)
        SendMessage( hWnd, TB_ENABLEBUTTON, nId, nState & ~TBSTATE_ENABLED);
    else if (!(nState & TBSTATE_ENABLED) && bEnable)
        SendMessage( hWnd, TB_ENABLEBUTTON, nId, nState | TBSTATE_ENABLED );
}


void CCameraAcquireDialog::HandleSelectionChange(void)
{
    CWaitCursor wc;
    int nSelCount = ListView_GetSelectedCount(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ) );
    int nItemCount = ListView_GetItemCount(GetDlgItem( m_hWnd, IDC_THUMBNAILLIST ) );

    //
    // Properties should be disabled for multiple items
    // and parent folder icons
    //
    bool bDisableProperties = true;
    if (nSelCount == 1)
    {
        CSimpleDynamicArray<int> aIndices;
        if (CCameraAcquireDialog::GetSelectionIndices( aIndices ))
        {
            if (CCameraAcquireDialog::GetListItemNode( aIndices[0] ))
            {
                bDisableProperties = false;
            }
        }
    }

    MyEnableWindow( GetDlgItem(m_hWnd,IDC_CAMDLG_PROPERTIES), !bDisableProperties );

    // OK should be disabled for 0 items
    MyEnableWindow( GetDlgItem(m_hWnd,IDOK), nSelCount != 0 );

    // Select all should be disabled for 0 items
    MyEnableToolbarButton( GetDlgItem(m_hWnd,IDC_TOOLBAR), IDC_SELECTALL, nItemCount != 0 );

    //
    // Decide whether or not delete should be enabled
    // If any of the selected items are deletable, then delete is enabled
    //
    bool bEnableDelete = false;

    //
    // Get the selected items
    //
    CSimpleDynamicArray<int> aSelIndices;
    if (GetSelectionIndices( aSelIndices ))
    {
        //
        // Loop through all of the selected items.  Break out if we find a reason
        // to enable delete.
        //
        for (int i=0;i<aSelIndices.Size() && !bEnableDelete;i++)
        {
            //
            // Get the item
            //
            CCameraItem *pItemNode = GetListItemNode(aSelIndices[i]);

            //
            // If we don't have an item, it is a parent folder
            //
            if (pItemNode)
            {
                //
                // If the access rights include the right to delete items,
                // break out.
                //
                if (pItemNode->ItemRights() & WIA_ITEM_CAN_BE_DELETED)
                {
                    //
                    // Found one, so we are done.
                    //
                    bEnableDelete = true;
                    break;
                }
            }
        }
    }

    MyEnableToolbarButton( GetDlgItem(m_hWnd,IDC_TOOLBAR), IDC_DELETE, bEnableDelete );

    KillTimer( m_hWnd, IDT_UPDATEPREVIEW );
    SetTimer( m_hWnd, IDT_UPDATEPREVIEW, UPDATE_PREVIEW_DELAY, NULL );
}


LRESULT CCameraAcquireDialog::OnImageListItemChanged( WPARAM, LPARAM )
{
    HandleSelectionChange();
    return(0);
}

LRESULT CCameraAcquireDialog::OnImageListKeyDown( WPARAM, LPARAM lParam )
{
    LPNMLVKEYDOWN pnkd = reinterpret_cast<LPNMLVKEYDOWN>(lParam);
    if (pnkd)
    {
        bool bAlt = ((GetKeyState(VK_MENU) & 0x8000) != 0);
        bool bControl = ((GetKeyState(VK_CONTROL) & 0x8000) != 0);
        bool bShift = ((GetKeyState(VK_SHIFT) & 0x8000) != 0);
        if (VK_LEFT == pnkd->wVKey && bAlt && !bControl && !bShift)
        {
            SendMessage( m_hWnd, PWM_CHANGETOPARENT, 0, 0 );
        }
        else if (VK_BACK == pnkd->wVKey && !bAlt && !bControl && !bShift)
        {
            SendMessage( m_hWnd, PWM_CHANGETOPARENT, 0, 0 );
        }
        else if (VK_DELETE == pnkd->wVKey)
        {
            SendMessage( m_hWnd, WM_COMMAND, IDC_DELETE, 0 );
        }
    }
    return (0);
}

LRESULT CCameraAcquireDialog::OnHelp( WPARAM wParam, LPARAM lParam )
{
    return WiaHelp::HandleWmHelp( wParam, lParam, g_HelpIDs );
}

LRESULT CCameraAcquireDialog::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    return WiaHelp::HandleWmContextMenu( wParam, lParam, g_HelpIDs );
}

LRESULT CCameraAcquireDialog::OnSysColorChange( WPARAM wParam, LPARAM lParam )
{
    WiaPreviewControl_SetBkColor( GetDlgItem( m_hWnd, IDC_PREVIEW ), TRUE, TRUE, GetSysColor(COLOR_WINDOW) );
    WiaPreviewControl_SetBkColor( GetDlgItem( m_hWnd, IDC_PREVIEW ), TRUE, FALSE, GetSysColor(COLOR_WINDOW) );
    SendDlgItemMessage( m_hWnd, IDC_THUMBNAILLIST, WM_SYSCOLORCHANGE, wParam, lParam );
    SendDlgItemMessage( m_hWnd, IDC_TOOLBAR, WM_SYSCOLORCHANGE, wParam, lParam );
    SendDlgItemMessage( m_hWnd, IDC_CAMDLG_PROPERTIES, WM_SYSCOLORCHANGE, wParam, lParam );
    m_ToolbarBitmapInfo.ReloadAndReplaceBitmap();
    return 0;
}

LRESULT CCameraAcquireDialog::OnNotify( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
    {
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL( NM_DBLCLK, IDC_THUMBNAILLIST, OnDblClkImageList );
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL( LVN_ITEMCHANGED, IDC_THUMBNAILLIST, OnImageListItemChanged );
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL( LVN_KEYDOWN, IDC_THUMBNAILLIST, OnImageListKeyDown );
    }
    SC_END_NOTIFY_MESSAGE_HANDLERS();
}

// WM_COMMAND Handler
LRESULT CCameraAcquireDialog::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
        SC_HANDLE_COMMAND(IDOK,OnOK);
        SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
        SC_HANDLE_COMMAND(IDC_CAMDLG_PROPERTIES,OnProperties);
        SC_HANDLE_COMMAND(IDC_PREVIEWMODE,OnPreviewMode);
        SC_HANDLE_COMMAND(IDC_TAKEPICTURE,OnTakePicture);
        SC_HANDLE_COMMAND(IDC_ICONMODE,OnIconMode);
        SC_HANDLE_COMMAND(IDC_DELETE,OnDelete);
        SC_HANDLE_COMMAND(IDC_SELECTALL,OnSelectAll);
    }
    SC_END_COMMAND_HANDLERS();
}

INT_PTR CALLBACK CCameraAcquireDialog::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CCameraAcquireDialog)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_SIZE, OnSize );
        SC_HANDLE_DIALOG_MESSAGE( WM_SHOWWINDOW, OnShow );
        SC_HANDLE_DIALOG_MESSAGE( WM_ENTERSIZEMOVE, OnEnterSizeMove );
        SC_HANDLE_DIALOG_MESSAGE( WM_EXITSIZEMOVE, OnExitSizeMove );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        SC_HANDLE_DIALOG_MESSAGE( WM_GETMINMAXINFO, OnGetMinMaxInfo );
        SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
        SC_HANDLE_DIALOG_MESSAGE( WM_DESTROY, OnDestroy );
        SC_HANDLE_DIALOG_MESSAGE( PWM_POSTINIT, OnPostInit );
        SC_HANDLE_DIALOG_MESSAGE( PWM_CHANGETOPARENT, OnChangeToParent );
        SC_HANDLE_DIALOG_MESSAGE( PWM_THUMBNAILSTATUS, OnThumbnailStatus );
        SC_HANDLE_DIALOG_MESSAGE( PWM_PREVIEWSTATUS, OnPreviewStatus );
        SC_HANDLE_DIALOG_MESSAGE( PWM_PREVIEWPERCENT, OnPreviewPercent );
        SC_HANDLE_DIALOG_MESSAGE( PWM_ITEMDELETED, OnItemDeleted );
        SC_HANDLE_DIALOG_MESSAGE( PWM_WIAEVENT, OnWiaEvent );
        SC_HANDLE_DIALOG_MESSAGE( WM_TIMER, OnTimer );
        SC_HANDLE_DIALOG_MESSAGE( WM_HELP, OnHelp );
        SC_HANDLE_DIALOG_MESSAGE( WM_CONTEXTMENU, OnContextMenu );
        SC_HANDLE_DIALOG_MESSAGE( WM_SYSCOLORCHANGE, OnSysColorChange );
    }
    SC_END_DIALOG_MESSAGE_HANDLERS();
}

// Static hook-related data
HWND CCameraAcquireDialog::s_hWndDialog = NULL;
HHOOK CCameraAcquireDialog::s_hMessageHook = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\convert.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    convert.h


Abstract:

    This module contains all previous version data


Author:

    10-Oct-1995 Tue 19:27:36 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/


LONG
InitMYDLGPAGE(
    PMYDLGPAGE  pMyDP,
    PDLGPAGE    pDP,
    UINT        cDP
    );

LONG
GetCurCPSUI(
    PTVWND          pTVWnd,
    POIDATA         pOIData,
    PCOMPROPSHEETUI pCPSUIFrom
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\convert.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    convert.c


Abstract:

    This module contains all version conversion function


Author:

    10-Oct-1995 Tue 19:24:43 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma  hdrstop


#define DBG_CPSUIFILENAME   DbgConvert


DEFINE_DBGVAR(0);




LONG
InitMYDLGPAGE(
    PMYDLGPAGE  pMyDP,
    PDLGPAGE    pDP,
    UINT        cDP
    )

/*++

Routine Description:

    Copy the DLGPAGE data to the internal MYDLGPAGE structure

Arguments:

    pMyDP   - pointer to MYDLGPAGE structure
    pDP     - pointer to DLGPAGE structure
    cDP     - number of DLGPAGE structure stored in pDP

Return Value:

    Return how many DLGPAGE data have been stored.

Author:

    10-Oct-1995 Tue 19:45:47 created  -by-  Daniel Chou (danielc)

Revision History:


--*/


{
    LONG    Result = 0;

    while (cDP--) {

        pMyDP->ID = MYDP_ID;

        CopyMemory(&(pMyDP->DlgPage),
                   pDP,
                   (pDP->cbSize > sizeof(DLGPAGE)) ? sizeof(DLGPAGE) :
                                                      pDP->cbSize);
        ++Result;

        pMyDP++;
        pDP++;
    }

    return(Result);
}



LONG
GetCurCPSUI(
    PTVWND          pTVWnd,
    POIDATA         pOIData,
    PCOMPROPSHEETUI pCPSUIFrom
    )

/*++

Routine Description:

    Set the OIEXT structure for each OPTITEM in pOIData, there is a 
    default OIEXT for the items. If the item doesn't specify one, then 
    the default one. 

Arguments:

    pTVWnd      - pointer to the treeview window structure
    pOIData     - pointer to the OIDATA structure to be stored
    pCPSUIFrom  - pointer to the COMPROPSHEETUI coming from caller function

Return Value:

    Return the number of how many non-default OIEXT data have been converted.

Author:

    10-Oct-1995 Tue 19:56:15 created  -by-  Daniel Chou (danielc)

Revision History:


--*/

{
    POPTITEM    pItem;
    POIEXT      pOIExt;
    OIEXT       OIExt;
    UINT        cItem;
    LONG        cConvert = 0;


    CopyMemory(&pTVWnd->ComPropSheetUI,
               pCPSUIFrom,
               (pCPSUIFrom->cbSize > sizeof(COMPROPSHEETUI)) ?
                                sizeof(COMPROPSHEETUI) : pCPSUIFrom->cbSize);

    //
    // This is the default OIEXT
    //

    OIExt.cbSize      = sizeof(OIEXT);
    OIExt.Flags       = (pTVWnd->Flags & TWF_ANSI_CALL) ? OIEXTF_ANSI_STRING :
                                                          0;
    OIExt.hInstCaller = pTVWnd->ComPropSheetUI.hInstCaller;
    OIExt.pHelpFile   = pTVWnd->ComPropSheetUI.pHelpFile;
    pItem             = pTVWnd->ComPropSheetUI.pOptItem;
    cItem             = pTVWnd->ComPropSheetUI.cOptItem;

    while (cItem--) {

        pItem->wReserved = 0;

        ZeroMemory(&(pItem->dwReserved[0]),
                   sizeof(OPTITEM) - FIELD_OFFSET(OPTITEM, dwReserved));


        if ((pItem->Flags & OPTIF_HAS_POIEXT)   &&
            (pOIExt = pItem->pOIExt)            &&
            (pOIExt->cbSize >= sizeof(OIEXT))) {

            cConvert++;

        } else {

            pOIExt = &OIExt;
        }

        pOIData->OIExtFlags  = pOIExt->Flags;
        pOIData->hInstCaller = pOIExt->hInstCaller ? pOIExt->hInstCaller : OIExt.hInstCaller;
        pOIData->pHelpFile   = pOIExt->pHelpFile;
        _OI_POIDATA(pItem)   = pOIData;

        pOIData++;
        pItem++;
    }

    return(cConvert);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\apilayer.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    apilayer.h


Abstract:

    This module contains all API layer's definiton


Author:

    02-Jan-1996 Tue 13:28:08 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/

#ifndef CPSUI_APILAYER
#define CPSUI_APILAYER


//================= Internal Data structures =============================
//


#define TABTABLE_COUNT          (MAXPROPPAGES + 3)

#define TAB_MODE_INIT           0
#define TAB_MODE_FIND           1
#define TAB_MODE_INSERT         2
#define TAB_MODE_DELETE         3
#define TAB_MODE_DELETE_ALL     4

#define GET_REAL_INSIDX(ptbl)  ((ptbl)->TabInfo[(ptbl)->InsIdx].OrgInsIdx)

#define DP_STD_INT_TVPAGE       DP_STD_RESERVED_START

#define COUNT_POSTSETCURSEL     32

typedef struct _TABINFO {
    SHORT   OrgInsIdx;
    WORD    HandleIdx;
    HWND    hDlg;
    } TABINFO, *PTABINFO;

#define TTF_POST_SETCURSEL      0x0001

typedef struct _TABTABLE {
    struct _TABTABLE    *pTabTable;
    HWND                hPSDlg;
    HWND                hWndTab;
    WNDPROC             WndProc;
    WORD                cPostSetCurSel;
    SHORT               iPostSetCurSel;
    WORD                cTab;
    WORD                CurSel;
    WORD                InsIdx;
    WORD                HandleIdx;
    TABINFO             TabInfo[TABTABLE_COUNT];
    } TABTABLE, *PTABTABLE;


#define CPSUIPAGE_ID            0x43444955

#define CPF_ROOT                0x00000001
#define CPF_PARENT              0x00000002
#define CPF_PFNPROPSHEETUI      0x00000004
#define CPF_COMPROPSHEETUI      0x00000008
#define CPF_USER_GROUP          0x00000010
#define CPF_DLL                 0x00000020
#define CPF_CALLER_HPSPAGE      0x00000040
#define CPF_ANSI_CALL           0x00000080
#define CPF_DONE_PROPSHEET      0x00000100
#define CPF_DONE_PROPSHEETPROC  0x00000200
#define CPF_SHOW_PROPSHEET      0x00000400
#define CPF_DOCPROP             0x00000800
#define CPF_ADVDOCPROP          0x00001000
#define CPF_PRINTERPROP         0x00002000
#define CPF_CALL_TV_DIRECT      0x00004000
#define CPF_NO_PSN_APPLY        0x00008000
#define CPF_HAS_CPSUI           0x00010000
#define CPF_NO_APPLY_BUTTON     0x00020000
#define CPF_ACTIVATED           0x00040000
#define CPF_DLGPROC_CHANGED     0x00080000
#define CPF_PSZ_PSTARTPAGE      0x00100000

typedef struct _CPSUIPAGE;


typedef struct _MYDATABLOCK {
    struct _MYDATABLOCK *pNext;
    DWORD               ID;
    DWORD               cb;
    } MYDATABLOCK, *PMYDATABLOCK;

typedef struct _ROOTINFO {
    HWND                hDlg;
    LPDWORD             pResult;
    PTABTABLE           pTabTable;
    struct _CPSUIPAGE   *pStartPage;
    WORD                cPage;
    WORD                cCPSUIPage;
    DWORD               DMPubHideBits;
    PMYDATABLOCK        pMyDB;
    } ROOTINFO, *PROOTINFO;

typedef struct _PFNINFO {
    HINSTANCE       hInst;
    PFNPROPSHEETUI  pfnPSUI;
    LPARAM          lParamInit;
    ULONG_PTR       UserData;
    ULONG_PTR       Result;
    } PFNINFO, *PPFNINFO;

typedef struct _CPSUIINFO {
    PTVWND  pTVWnd;
    LONG    Result;
    LONG    TVPageIdx;
    LONG    StdPageIdx1;
    LONG    StdPageIdx2;
    } CPSUIINFO, PCPSUIINFO;

typedef struct _HPAGEINFO {
    HWND                hDlg;
    DLGPROC             DlgProc;
    LPFNPSPCALLBACK     pspCB;
    LPARAM              lParam;
    HICON               hIcon;
    DWORD               dwSize;
    } HPAGEINFO, *PHPAGEINFO;


typedef struct _CPSUIPAGE {
    DWORD                   ID;
    DWORD                   cLock;
    DWORD                   Flags;
    HANDLE                  hCPSUIPage;
    HANDLE                  hActCtx;
    struct _CPSUIPAGE       *pParent;
    struct _CPSUIPAGE       *pPrev;
    struct _CPSUIPAGE       *pNext;
    union {
        struct _CPSUIPAGE   *pChild;
        HPROPSHEETPAGE      hPage;
        } DUMMYUNIONNAME;
    union {
        ROOTINFO            RootInfo;
        PFNINFO             pfnInfo;
        CPSUIINFO           CPSUIInfo;
        HPAGEINFO           hPageInfo;
        } DUMMYUNIONNAME2;
    } CPSUIPAGE, *PCPSUIPAGE;


typedef BOOL (CALLBACK *CPSUIPAGEENUMPROC)(PCPSUIPAGE   pRootPage,
                                           PCPSUIPAGE   pCPSUIPage,
                                           LPARAM       lParam);


#define SET_APPLY_BUTTON(pTVWnd, hDlg)                                      \
{                                                                           \
    if (!(*((pTVWnd)->pRootFlags) & CPF_NO_APPLY_BUTTON)) {                 \
                                                                            \
        if (CountRevertOptItem((pTVWnd),                                    \
                               NULL,                                        \
                               TreeView_GetRoot((pTVWnd)->hWndTV),          \
                               0)) {                                        \
                                                                            \
            PropSheet_Changed(GetParent(hDlg), hDlg);                       \
                                                                            \
        } else {                                                            \
                                                                            \
            PropSheet_UnChanged(GetParent(hDlg), hDlg);                     \
        }                                                                   \
    }                                                                       \
}

#define HINSPSUIPAGE_2_IDX(h)           ((UINT)LOWORD(LODWORD(h)))
#define ARRAYSIZE(x)                    (sizeof(x)/sizeof(x[0]))

//
// Local structure
//

typedef struct _PSPEX {
    PROPSHEETPAGE   psp;
    PSPINFO         pspInfo;
    } PSPEX, *PPSPEX;

typedef struct _PSHINFO {
    WCHAR   CaptionName[MAX_RES_STR_CHARS];
    } PSHINFO, *PPSHINFO;

typedef struct _PAGEPROCINFO {
    PTABTABLE       pTabTable;
    HPROPSHEETPAGE  *phPage;
    HANDLE          *pHandle;
    WORD            cPage;
    WORD            iPage;
    } PAGEPROCINFO, *PPAGEPROCINFO;


typedef struct _INSPAGEIDXINFO {
    PCPSUIPAGE  pCPSUIPage;
    PTABTABLE   pTabTable;
    } INSPAGEIDXINFO, *PINSPAGEIDXINFO;


//
// Function prototypes
//


DWORD
FilterException(
    HANDLE                  hPage,
    LPEXCEPTION_POINTERS    pExceptionPtr
    );


BOOL
CALLBACK
SetInsPageIdxProc(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pCPSUIPage,
    LPARAM      lParam
    );

LONG_PTR
CALLBACK
CPSUICallBack(
    HANDLE  hComPropSheet,
    UINT    Function,
    LPARAM  lParam1,
    LPARAM  lParam2
    );

LONG
AddComPropSheetPage(
    PCPSUIPAGE  pCPSUIPage,
    UINT        PageIdx
    );

BOOL
EnumCPSUIPagesSeq(
    PCPSUIPAGE          pRootPage,
    PCPSUIPAGE          pCPSUIPage,
    CPSUIPAGEENUMPROC   CPSUIPageEnumProc,
    LPARAM              lParam
    );


BOOL 
GetPageActivationContext(
    PCPSUIPAGE      pCPSUIPage, 
    HANDLE         *phActCtx
    );

#endif  // CPSUI_APILAYER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\compstui.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    compstui.c


Abstract:

    This module contains all major entry porint for the common printer
    driver UI


Author:

    28-Aug-1995 Mon 16:19:45 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma  hdrstop


#define DBG_CPSUIFILENAME   DbgComPtrUI


#define DBG_DLLINIT         0x00000001


DEFINE_DBGVAR(0);


HINSTANCE   hInstDLL = NULL;
DWORD       TlsIndex = 0xFFFFFFFF;

DWORD
WINAPI
DllMain(
    HMODULE hModule,
    ULONG   Reason,
    LPVOID  Reserved
    )

/*++

Routine Description:

    This function is DLL main entry point, at here we will save the module
    handle, in the future we will need to do other initialization stuff.

Arguments:

    hModule     - Handle to this moudle when get loaded.

    Reason      - may be DLL_PROCESS_ATTACH

    Reserved    - reserved

Return Value:

    Always return 1L


Author:

    07-Sep-1995 Thu 12:43:45 created  -by-  Daniel Chou (danielc)


Revision History:



--*/

{
    LPVOID  pv;
    WORD    cWait;
    WORD    Idx;


    UNREFERENCED_PARAMETER(Reserved);



    CPSUIDBG(DBG_DLLINIT,
            ("\n!! DllMain: ProcesID=%ld, ThreadID=%ld !!",
            GetCurrentProcessId(), GetCurrentThreadId()));

    switch (Reason) {

    case DLL_PROCESS_ATTACH:

        CPSUIDBG(DBG_DLLINIT, ("DLL_PROCESS_ATTACH"));

        // initialize fusion
        if (!SHFusionInitializeFromModule(hModule)) {

            CPSUIERR(("SHFusionInitializeFromModule Failed, DLL Initialzation Failed"));
            return (0);
        }

        if ((TlsIndex = TlsAlloc()) == 0xFFFFFFFF) {

            CPSUIERR(("TlsAlloc() Failed, Initialzation Failed"));
            return(0);
        }

        if (!HANDLETABLE_Create()) {

            TlsFree(TlsIndex);
            TlsIndex = 0xFFFFFFFF;

            CPSUIERR(("HANDLETABLE_Create() Failed, Initialzation Failed"));

            return(0);
        }

        hInstDLL = (HINSTANCE)hModule;

        //
        // Fall through to do the per thread initialization
        //

    case DLL_THREAD_ATTACH:

        if (Reason == DLL_THREAD_ATTACH) {

            CPSUIDBG(DBG_DLLINIT, ("DLL_THREAD_ATTACH"));
        }

        TlsSetValue(TlsIndex, (LPVOID)MK_TLSVALUE(0, 0));

        break;

    case DLL_PROCESS_DETACH:

        CPSUIDBG(DBG_DLLINIT, ("DLL_PROCESS_DETACH"));

        //
        // Fall through to de-initialize
        //

    case DLL_THREAD_DETACH:

        if (Reason == DLL_THREAD_DETACH) {

            CPSUIDBG(DBG_DLLINIT, ("DLL_THREAD_DETACH"));
        }

        pv = TlsGetValue(TlsIndex);

        if (cWait = TLSVALUE_2_CWAIT(pv)) {

            CPSUIERR(("Thread=%ld: Some (%ld) mutex owned not siginaled, do it now",
                        GetCurrentThreadId(), cWait));

            while (cWait--) {

                UNLOCK_CPSUI_HANDLETABLE();
            }
        }

        if (Reason == DLL_PROCESS_DETACH) {

            TlsFree(TlsIndex);
            HANDLETABLE_Destroy();
        }

        if (DLL_PROCESS_DETACH == Reason) {

            // shutdown fusion
            SHFusionUninitialize();
        }

        break;

    default:

        CPSUIDBG(DBG_DLLINIT, ("DLLINIT UNKNOWN"));
        return(0);
    }

    return(1);
}



ULONG_PTR
APIENTRY
GetCPSUIUserData(
    HWND    hDlg
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Oct-1995 Wed 23:13:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PMYDLGPAGE  pMyDP;


    if ((pMyDP = GET_PMYDLGPAGE(hDlg)) && (pMyDP->ID == MYDP_ID)) {

        return(pMyDP->CPSUIUserData);

    } else {

        CPSUIERR(("GetCPSUIUserData: Invalid hDlg=%08lx", hDlg));
        return(0);
    }
}




BOOL
APIENTRY
SetCPSUIUserData(
    HWND        hDlg,
    ULONG_PTR   CPSUIUserData
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Oct-1995 Wed 23:13:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PMYDLGPAGE  pMyDP;


    if ((pMyDP = GET_PMYDLGPAGE(hDlg)) && (pMyDP->ID == MYDP_ID)) {

        CPSUIINT(("SetCPSUIUserData: DlgPageIdx=%ld, UserData=%p",
                    pMyDP->PageIdx, CPSUIUserData));

        pMyDP->CPSUIUserData = CPSUIUserData;
        return(TRUE);

    } else {

        CPSUIERR(("SetCPSUIUserData: Invalid hDlg=%08lx", hDlg));

        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\dialogs.h ===
#define STDPAGE1_TAB                65533
#define STDPAGE2_TAB                65534
#define TREEVIEW_TAB                65535
#define STDPAGE1_TEST               65530
#define DLGABOUT                    65510

#define IDD_TRAY_GROUP              1199
#define IDD_DEFSOURCE_GROUP         1200
#define IDD_DEFSOURCE_TEXT          1201
#define IDD_DEFSOURCE               1202
#define IDD_DEFSOURCE_ICON          1203
#define IDD_DEFSOURCE_ECB           1204
#define IDD_DEFSOURCE_ECBV_ICON     1205

#define IDD_OUTPUTBIN_GROUP         1210
#define IDD_OUTPUTBIN_TEXT          1211
#define IDD_OUTPUTBIN               1212
#define IDD_OUTPUTBIN_ICON          1213
#define IDD_OUTPUTBIN_ECB           1214
#define IDD_OUTPUTBIN_ECB_ICON      1215

#define IDD_MEDIATYPE_GROUP         1220
#define IDD_MEDIATYPE_TEXT          1221
#define IDD_MEDIATYPE               1222
#define IDD_MEDIATYPE_ICON          1223
#define IDD_MEDIATYPE_ECB           1224
#define IDD_MEDIATYPE_ECB_ICON      1225

#define IDD_ORIENT_GROUP            1230
#define IDD_ORIENT_TEXT             1231
#define IDD_ORIENT_S1               1232
#define IDD_ORIENT_S1_ICON          1233
#define IDD_ORIENT_S2               1234
#define IDD_ORIENT_S2_ICON          1235
#define IDD_ORIENT_S3               1236
#define IDD_ORIENT_S3_ICON          1237
#define IDD_ORIENT_ECB              1238
#define IDD_ORIENT_ECB_ICON         1239

#define IDD_COPIES_GROUP            1240
#define IDD_COPIES_TEXT             1241
#define IDD_COPIES                  1242
#define IDD_COPIES_ICON             1243
#define IDD_COPIES_POSTFIX          1244
#define IDD_COPIES_HELP             1245
#define IDD_COPIES_UDARROW          1246
#define IDD_COPIES_ECB              1247
#define IDD_COPIES_ECB_ICON         1248

#define IDD_COLOR_GROUP             1260
#define IDD_COLOR_TEXT              1261
#define IDD_COLOR_S1                1262
#define IDD_COLOR_S1_ICON           1263
#define IDD_COLOR_S2                1264
#define IDD_COLOR_S2_ICON           1265
#define IDD_COLOR_ECB               1266
#define IDD_COLOR_ECB_ICON          1267

#define IDD_DUPLEX_GROUP            1270
#define IDD_DUPLEX_TEXT             1271
#define IDD_DUPLEX_S1               1272
#define IDD_DUPLEX_S1_ICON          1273
#define IDD_DUPLEX_S2               1274
#define IDD_DUPLEX_S2_ICON          1275
#define IDD_DUPLEX_S3               1276
#define IDD_DUPLEX_S3_ICON          1277
#define IDD_DUPLEX_ECB              1278
#define IDD_DUPLEX_ECB_ICON         1279

#define IDD_QUALITY_GROUP           1290
#define IDD_QUALITY_TEXT            1291
#define IDD_QUALITY_S1              1292
#define IDD_QUALITY_S1_ICON         1293
#define IDD_QUALITY_S2              1294
#define IDD_QUALITY_S2_ICON         1295
#define IDD_QUALITY_S3              1296
#define IDD_QUALITY_S3_ICON         1297
#define IDD_QUALITY_ECB             1298
#define IDD_QUALITY_ECB_ICON        1299


#define IDD_PAGEORDER_GROUP         1400
#define IDD_PAGEORDER_TEXT          1401
#define IDD_PAGEORDER_S1            1402
#define IDD_PAGEORDER_S1_ICON       1403
#define IDD_PAGEORDER_S2            1404
#define IDD_PAGEORDER_S2_ICON       1405
#define IDD_PAGEORDER_ECB           1406
#define IDD_PAGEORDER_ECB_ICON      1407

#define IDD_NUP_GROUP               1450
#define IDD_NUP_TEXT                1451
#define IDD_NUP                     1452
#define IDD_NUP_ICON                1453
#define IDD_NUP_ECB                 1454
#define IDD_NUP_ECB_ICON            1455

#define IDD_ADVANCED_PUSH1          1500
#define IDD_ADVANCED_PUSH2          1502
#define IDD_LAYOUT_PICTURE_GROUP    1503
#define IDD_LAYOUT_PICTURE          1504
 
#define IDD_TV_UDARROW              9000
#define IDD_TV_UDARROW_EDIT         9001
#define IDD_TV_UDARROW_HELP         9002
#define IDD_TV_UDARROW_ENDTEXT      9003

#define IDD_TV_PUSH                 9020
#define IDD_TV_OPTION               9030
#define IDD_TV_LB                   9040

#define IDD_TV_EDIT_EDIT            9050
#define IDD_TV_EDIT_ENDTEXT         9051
#define IDD_TV_EDIT_HELP            9052

#define IDD_TV_CB                   9060

#define IDD_TV_ICON                 9070
#define IDD_TV_BMP                  9071

#define IDD_TV_MSAA_NAME            9080

#define IDD_3STATES_1               9090
#define IDD_3STATES_2               9092
#define IDD_3STATES_3               9094

#define IDD_TV_WND                  9110

#define IDD_TV_TRACKBAR             9120

#define IDD_TV_SB                   9130
#define IDD_TV_SB_LOW               9131
#define IDD_TV_SB_HIGH              9132

#define IDD_TV_CHKBOX               9140
#define IDD_TV_EXTCHKBOX            9150
#define IDD_TV_ECB_ICON             9151
#define IDD_TV_HDR_PUSH_ICON        9160
#define IDD_TV_EXTPUSH              9170


#define IDS_INT_CPSUI_AV1           20000
#define IDS_INT_CPSUI_AV2           20001
#define IDS_INT_CPSUI_AV3           20002
#define IDS_INT_CPSUI_AV4           20003
#define IDS_INT_CPSUI_HELPFILE      20004


#define IDS_INT_CPSUI_ABOUT         20100
#define IDS_INT_CPSUI_SETUP         20101
#define IDS_INT_CPSUI_UNDO_OPT      20102
#define IDS_INT_CPSUI_UNDO_OPTS     20103
#define IDS_INT_CPSUI_VERSION       20104
#define IDS_INT_CPSUI_DOC_SET       20105
#define IDS_INT_CPSUI_ADVDOC_SET    20106
#define IDS_INT_CPSUI_DEVICE_SET    20107
#define IDS_INT_CPSUI_SETTINGS      20108

#define IDS_INT_CPSUI_OPTIONS       20109
#define IDS_INT_CPSUI_CHANGE_SET    20110
#define IDS_INT_CPSUI_RANGE         20111
#define IDS_INT_CPSUI_SPACE_CHAR    20112
#define IDS_INT_CPSUI_DEFAULT       20113
#define IDS_INT_CPSUI_DOCUMENT      20114
#define IDS_INT_CPSUI_DEFDOCUMENT   20115
#define IDS_INT_CPSUI_ADVDOCUMENT   20116
#define IDS_INT_CPSUI_ADVDOCOPTION  20117
#define IDS_INT_CPSUI_WHATISTHIS    20118

#define IDS_ABOUT_COMPANY           30000
#define IDS_ABOUT_PRODUCT           30005
#define IDS_ABOUT_CALLER            30010
#define IDS_ABOUT_COPYRIGHT         30015
#define IDS_ABOUT_OPTITEM           30020
#define IDI_ABOUT_ICON              30050

#define ADVANCED_PUSH               8000
#define IDOK                        1
#define TREEVIEW_TAB_CLOSE          65520
#define TV_EDIT_DLG                 100
#define TREEVIEW_TAB_CLOSE_TMP      200
#define TREEVIEW_TAB_TMP            300
#define TREEVIEW_TAB_CLOSE_TMP2     400
#define TREEVIEW_TAB_TMP2           500
#define TREEVIEW_TAB_CLOSE_TMP1     600
#define TMP_WND_HOLDER              160
#define IDD_PRE_EDIT                40000
#define IDD_POST_EDIT               40001

#define IDD_TMP_ABOUT_WND           40050

#define ID_CMD_ABOUT                40100
#define ID_CMD_HELP                 40101
#define ID_CMD_UNDO                 40102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\apilayer.c ===
/**++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    apilayer.c


Abstract:

    This module contains functions for the common UI api layer. this layer
    managed all property sheet page handles, create, destroy and inter-page
    communications.


Author:

    28-Dec-1995 Thu 16:02:12 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma  hdrstop


#define DBG_CPSUIFILENAME   DbgApilayer


#define DBG_PAGEDLGPROC         0x00000001
#define DBG_SHOWPAGE            0x00000002
#define DBG_DEL_PROC            0x00000004
#define DBG_GET_PAGE            0x00000008
#define DBG_ADD_CPSUIPAGE       0x00000010
#define DBG_ADD_PSPAGE          0x00000020
#define DBG_ADDCOMPAGE          0x00000040
#define DBG_ADD_CPSUI           0x00000080
#define DBG_PFNCOMPROPSHEET     0x00000100
#define DBG_GETSETREG           0x00000200
#define DBG_DOCOMPROPSHEET      0x00000400
#define DBG_DO_CPSUI            0x00000800
#define DBG_CALLPFN             0x00001000
#define DBG_SETHSTARTPAGE       0x00002000
#define DBG_PAGE_PROC           0x00004000
#define DBG_TCMPROC             0x00008000
#define DBG_TABTABLE            0x00010000
#define DBG_INSPAGE             0x00020000
#define DBG_PSPCB               0x00040000
#define DBG_DMPUBHIDEBITS       0x00080000
#define DBG_APPLYDOC            0x00100000
#define DBG_GET_PAGEHWND        0x00200000
#define DBG_GET_TABWND          0x00400000
#define DBG_ALWAYS_APPLYNOW     0x80000000
#define DBG_IGNORE_PSN_APPLY    0x40000000

DEFINE_DBGVAR(0);

#define REGDPF_TVPAGE           0x00000001
#define REGDPF_EXPAND_OPTIONS   0x00000002
#define REGDPF_STD_P1           0x00000004
#define REGDPF_MASK             0x00000007
#define REGDPF_DEFAULT          0x00000000


extern HINSTANCE        hInstDLL;
extern DWORD            TlsIndex;


static const WCHAR  szCPSUIRegKey[] = L"Software\\Microsoft\\ComPstUI";
static const WCHAR  szDocPropKeyName[] = L"DocPropFlags";


#if DBG

LPSTR  pszCPSFUNC[] = { "CPSFUNC_ADD_HPROPSHEETPAGE",
                        "CPSFUNC_ADD_PROPSHEETPAGE",
                        "CPSFUNC_ADD_PCOMPROPSHEETUIA",
                        "CPSFUNC_ADD_PCOMPROPSHEETUIW",
                        "CPSFUNC_ADD_PFNPROPSHEETUIA",
                        "CPSFUNC_ADD_PFNPROPSHEETUIW",
                        "CPSFUNC_DELETE_HCOMPROPSHEET",
                        "CPSFUNC_SET_HSTARTPAGE",
                        "CPSFUNC_GET_PAGECOUNT",
                        "CPSFUNC_SET_RESULT",
                        "CPSFUNC_GET_HPSUIPAGES",
                        "CPSFUNC_LOAD_CPSUI_STRINGA",
                        "CPSFUNC_LOAD_CPSUI_STRINGW",
                        "CPSFUNC_LOAD_CPSUI_ICON",
                        "CPSFUNC_GET_PFNPROPSHEETUI_ICON",
                        "CPSFUNC_ADD_PROPSHEETPAGEA",
                        "CPSFUNC_INSERT_PSUIPAGEA",
                        "CPSFUNC_INSERT_PSUIPAGEW",
                        "CPSFUNC_SET_PSUIPAGE_TITLEA",
                        "CPSFUNC_SET_PSUIPAGE_TITLEW",
                        "CPSFUNC_SET_PSUIPAGE_ICON",
                        "CPSFUNC_SET_DATABLOCK",
                        "CPSFUNC_QUERY_DATABLOCK",
                        "CPSFUNC_SET_DMPUB_HIDEBITS",
                        "CPSFUNC_IGNORE_CPSUI_PSN_APPLY",
                        "CPSFUNC_DO_APPLY_CPSUI",
                        "CPSFUNC_SET_FUSION_CONTEXT"
                    };


LPSTR  pszPFNReason[] = { "PROPSHEETUI_REASON_INIT",
                          "PROPSHEETUI_REASON_GET_INFO_HEADER",
                          "PROPSHEETUI_REASON_DESTROY",
                          "PROPSHEETUI_REASON_SET_RESULT",
                          "PROPSHEETUI_REASON_GET_ICON" };

LPSTR  pszTabMode[] = { "TAB_MODE_INIT",
                        "TAB_MODE_FIND",
                        "TAB_MODE_INSERT",
                        "TAB_MODE_DELETE",
                        "TAB_MODE_DELETE_ALL" };

LPSTR   pszInsType[] = { "PSUIPAGEINSERT_GROUP_PARENT",
                         "PSUIPAGEINSERT_PCOMPROPSHEETUI",
                         "PSUIPAGEINSERT_PFNPROPSHEETUI",
                         "PSUIPAGEINSERT_PROPSHEETPAGE",
                         "PSUIPAGEINSERT_HPROPSHEETPAGE",
                         "PSUIPAGEINSERT_DLL" };

#define DBG_SHOW_CPSUIPAGE(pPage, Level)                                            \
{                                                                                   \
    CPSUIDBG(DBG_SHOWPAGE, ("\n\n------ Show Current Page from %08lx, Level=%ld-------", \
                pPage, Level));                                                            \
                                                                                    \
    DbgShowCPSUIPage(pPage, Level);                                                 \
}
#define DBG_SHOW_PTCI(psz, w, ptci)         Show_ptci(psz, w, ptci)


VOID
DbgShowCPSUIPage(
    PCPSUIPAGE  pPage,
    LONG        Level
    )
{
    while (pPage) {

        if (pPage->Flags & CPF_PARENT) {

            if (pPage->Flags & CPF_ROOT) {

                CPSUIDBG(DBG_SHOWPAGE, ("%02ld!%08lx:%08lx: ROOT - Flags=%08lx, hDlg=%08lx, cPage=%ld/%ld, pStartPage=%08lx",
                    Level,
                    pPage, pPage->hPage, pPage->Flags,
                    pPage->RootInfo.hDlg,
                    (DWORD)pPage->RootInfo.cCPSUIPage,
                    (DWORD)pPage->RootInfo.cPage,
                    pPage->RootInfo.pStartPage));

            } else if (pPage->Flags & CPF_PFNPROPSHEETUI) {

                CPSUIDBG(DBG_SHOWPAGE,
                    ("%02ld!%08lx:%08lx: PFN - Flags=%08lx, pfnPSUI=%08lx, UserData=%08lx, Result=%ld",
                    Level, pPage, pPage->hPage, pPage->Flags,
                    pPage->pfnInfo.pfnPSUI, (DWORD)pPage->pfnInfo.UserData,
                    pPage->pfnInfo.Result));

            } else if (pPage->Flags & CPF_COMPROPSHEETUI) {

                CPSUIDBG(DBG_SHOWPAGE, ("%02ld!%08lx:%08lx: CPSUI - Flags=%08lx, pTVWnd=%08lx, lParam=%08lx, TV=%ld, Std1=%ld, Std2=%ld",
                    Level,
                    pPage, pPage->hPage, pPage->Flags,
                    pPage->CPSUIInfo.pTVWnd, pPage->CPSUIInfo.Result,
                    (DWORD)pPage->CPSUIInfo.TVPageIdx,
                    (DWORD)pPage->CPSUIInfo.StdPageIdx1,
                    (DWORD)pPage->CPSUIInfo.StdPageIdx2));

            } else if (pPage->Flags & CPF_USER_GROUP) {

                CPSUIDBG(DBG_SHOWPAGE, ("%02ld!%08lx:%08lx: GROUP_PARENT - Flags=%08lx",
                    Level, pPage, pPage->hPage, pPage->Flags));

            } else {

                CPSUIDBG(DBG_SHOWPAGE, ("%02ld!%08lx:%08lx: UNKNOWN - Flags=%08lx",
                    Level, pPage, pPage->hPage, pPage->Flags));
            }

            DbgShowCPSUIPage(pPage->pChild, Level + 1);

        } else {

            CPSUIDBG(DBG_SHOWPAGE, ("%02ld!%08lx:%08lx: %ws - Flags=%08lx, hDlg=%08lx, DlgProc=%08lx",
                    (LONG)Level,
                    pPage, pPage->hPage,
                    (pPage->Flags & CPF_CALLER_HPSPAGE) ? L"USER_HPAGE" :
                                                        L"PROPSHEETPAGE",
                    pPage->Flags,
                    pPage->hPageInfo.hDlg, pPage->hPageInfo.DlgProc));
        }

        pPage = pPage->pNext;
    }
}



VOID
Show_ptci(
    LPSTR   pszHeader,
    WPARAM  wParam,
    TC_ITEM *ptci
    )
{

    if (ptci) {

        if (pszHeader) {

            CPSUIDBG(DBG_TCMPROC, ("%hs", pszHeader));
        }

        CPSUIDBG(DBG_TCMPROC, ("    IdxItem=%ld", wParam));
        CPSUIDBG(DBG_TCMPROC, ("    Mask=%08lx", ptci->mask));

        if ((ptci->mask & TCIF_TEXT) &&
            (ptci->pszText)) {

            CPSUIDBG(DBG_TCMPROC, ("    pszText=%ws", ptci->pszText));
        }

        CPSUIDBG(DBG_TCMPROC, ("    cchTextMax=%ld", ptci->cchTextMax));
        CPSUIDBG(DBG_TCMPROC, ("    iImage=%ld", ptci->iImage));
    }
}


VOID
SHOW_TABWND(
    LPWSTR      pName,
    PTABTABLE   pTabTable
    )
{
    WORD        w;
    PTABINFO    pTI = pTabTable->TabInfo;


    for (w = 0; w < pTabTable->cTab; w++, pTI++) {

        WORD        Idx = pTI->HandleIdx;
        PCPSUIPAGE  pPage;


        if (((Idx = pTI->HandleIdx) != 0xFFFF)    &&
            (pPage = HANDLETABLE_GetCPSUIPage(WORD_2_HANDLE(Idx)))) {

            TC_ITEM tci;
            WCHAR   wBuf[80];


            tci.mask       = TCIF_TEXT;
            tci.pszText    = wBuf;
            tci.cchTextMax = sizeof(wBuf) / sizeof(WCHAR);

            if (!SendMessage(pTabTable->hWndTab,
                             TCM_GETITEMW,
                             (WPARAM)w,
                             (LPARAM)(TC_ITEM FAR *)&tci)) {

                StringCchPrintfW(wBuf, COUNT_ARRAY(wBuf), L"FAILED TabName");
            }

            CPSUIDBG(DBG_GET_TABWND,
                    ("  %ws: %2ld/%2ld=[%20ws] hDlg=%08lx, DlgProc=%08lx, hIdx=%04lx, hDlg=%08lx, pPage=%08lx",
                        pName, w, pTI->OrgInsIdx, wBuf, pPage->hPageInfo.hDlg,
                        pPage->hPageInfo.DlgProc, Idx, pTI->hDlg, pPage));

            HANDLETABLE_UnGetCPSUIPage(pPage);
        }
    }
}



#else

#define DBG_SHOW_CPSUIPAGE(pPage, Level)
#define DBG_SHOW_PTCI(psz, w, ptci)
#define SHOW_TABWND(pName, pTabTable)

#endif

BOOL 
GetPageActivationContext(
    PCPSUIPAGE      pCPSUIPage,
    HANDLE         *phActCtx
    )
{
    BOOL bRet = FALSE;

    if (phActCtx) {

        //
        // climb up in the hierarchy to the first parent page which has an 
        // activation context properly set.
        //
        while (pCPSUIPage && INVALID_HANDLE_VALUE == pCPSUIPage->hActCtx) {

            pCPSUIPage = pCPSUIPage->pParent;
        }

        if (pCPSUIPage) {

            //
            // we found a parent with an activation context properly set.
            // return success.
            //
            *phActCtx = pCPSUIPage->hActCtx;
            bRet = TRUE;
        }
    }

    return bRet;
}


DWORD
FilterException(
    HANDLE                  hPage,
    LPEXCEPTION_POINTERS    pExceptionPtr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Feb-1996 Tue 09:36:00 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hWnd = NULL;
    PCPSUIPAGE  pPage;
    PCPSUIPAGE  pRootPage = NULL;
    LPSTR       pFormat;
    LPSTR       pMsg = NULL;
    CHAR        Buf[2048];
    UINT        i;
    UINT        IDSLast;


    //
    // Buffer is long enough, reserve MAX_PATH characters for LoadString() and wsprintf()
    //
    if ((pPage = HANDLETABLE_GetCPSUIPage(hPage))       &&
        (pRootPage = HANDLETABLE_GetRootPage(pPage))    &&
        (hWnd = pPage->RootInfo.hDlg)) {

        IDSLast = IDS_INT_CPSUI_AV4;
        i       = GetWindowTextA(pPage->RootInfo.hDlg, Buf, COUNT_ARRAY(Buf) - MAX_PATH);

    } else {

        IDSLast = IDS_INT_CPSUI_AV3;
        i       = GetModuleFileNameA(NULL, Buf, COUNT_ARRAY(Buf) - MAX_PATH);
    }

    pMsg = &Buf[++i];

    i += LoadStringA(hInstDLL, IDS_INT_CPSUI_AV1, &Buf[i], COUNT_ARRAY(Buf)-i);
    StringCchPrintfA(&Buf[i], COUNT_ARRAY(Buf) - i, " 0x%lx ",
                     pExceptionPtr->ExceptionRecord->ExceptionAddress);
    i += lstrlenA(&Buf[i]);
    LoadStringA(hInstDLL, IDS_INT_CPSUI_AV2, &Buf[i], COUNT_ARRAY(Buf)-i);
    i += lstrlenA(&Buf[i]);
    StringCchPrintfA(&Buf[i], COUNT_ARRAY(Buf) - i, " 0x%08lx",
                          pExceptionPtr->ExceptionRecord->ExceptionCode);
    i += lstrlenA(&Buf[i]);
    LoadStringA(hInstDLL, IDSLast, &Buf[i], COUNT_ARRAY(Buf)-i);


    HANDLETABLE_UnGetCPSUIPage(pPage);
    HANDLETABLE_UnGetCPSUIPage(pRootPage);

    CPSUIERR((Buf));
    CPSUIERR((pMsg));

    MessageBoxA(hWnd, pMsg, Buf, MB_ICONSTOP | MB_OK);

    return(EXCEPTION_EXECUTE_HANDLER);
}




LONG
DoTabTable(
    UINT        Mode,
    PTABTABLE   pTabTable,
    SHORT       Idx,
    SHORT       OrgInsIdx
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    12-Feb-1996 Mon 18:18:56 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTABINFO    pTI;
    PTABINFO    pTmp;
    UINT        cTab;
    UINT        i;
    SHORT       CurIdx;
    SHORT       OldIdx;
    SHORT       RetIdx;


    pTI    =
    pTmp   = pTabTable->TabInfo;
    cTab   = (UINT)pTabTable->cTab;
    RetIdx = -1;

    switch (Mode) {

    case TAB_MODE_FIND:

        CPSUIDBG(DBG_TABTABLE, ("TAB_MODE_FIND:  Index=%ld, cTab=%ld", Idx, cTab));

        if ((Idx >= 0) && (Idx < (SHORT)cTab)) {

            for (i = 0; i < cTab; i++, pTI++) {

                CPSUIDBG(DBG_TABTABLE,
                        ("    i=%2ld, Idx=%2ld, cTab=%2ld, OrgIdx=%2ld",
                                    i, Idx, cTab, pTI->OrgInsIdx));

                if (pTI->OrgInsIdx == Idx) {

                    RetIdx = (SHORT)i;

                    CPSUIDBG(DBG_TABTABLE,  ("    FOUND: RetIdx=%ld", RetIdx));

                    break;
                }
            }
        }

        break;

    case TAB_MODE_DELETE_ALL:

        FillMemory(pTI, sizeof(pTabTable->TabInfo), 0xFF);

        pTabTable->cTab           = 0;
        pTabTable->CurSel         =
        pTabTable->InsIdx         =
        pTabTable->HandleIdx      = 0xFFFF;
        pTabTable->cPostSetCurSel = 0;
        pTabTable->iPostSetCurSel = -1;
        RetIdx                    = MAXPROPPAGES;

        break;

    case TAB_MODE_DELETE:

        //
        // Delete the pTabTable->TabInfo[].OrgInsIdx = Idx, reduced every
        // TabInfo[] which is > Idx by one, if pTabTable->TabInfo[] == Idx
        // then overwrite that entry
        //

        if (Idx < (SHORT)cTab) {

            //
            // Remove the one which match to the Idx
            //

            for (i = 0; i < cTab; i++, pTI++) {

                if ((CurIdx = pTI->OrgInsIdx) == Idx) {

                    RetIdx = Idx;

                } else {

                    if (CurIdx > Idx) {

                        --CurIdx;
                    }

                    pTmp->OrgInsIdx = CurIdx;
                    pTmp->HandleIdx = pTI->HandleIdx;

                    ++pTmp;
                }
            }

            if (RetIdx >= 0) {

                RetIdx          = (SHORT)(--(pTabTable->cTab));
                pTmp->OrgInsIdx =
                pTmp->HandleIdx = 0xFFFF;
            }
        }

        break;

    case TAB_MODE_INSERT:

        //
        // Make room for the Idx location, move everything right one space
        // from the Idx, for every pTabTable->TabInfo[].OrgInsIdx if it is
        // greater or eqaul to OrgInsIdx then add it by one, then set the
        // pTabTable->TabInfo[Idx].OrgInsIdx = OrgInsIdx
        //

        CurIdx  = (SHORT)cTab;
        pTI    += cTab;

        if (Idx > CurIdx) {

            Idx = CurIdx;
        }

        do {

            if (CurIdx == Idx) {

                pTI->OrgInsIdx = OrgInsIdx;
                pTI->HandleIdx = 0xFFFF;

            } else {

                if (CurIdx > Idx) {

                    *pTI = *(pTI - 1);
                }

                if (pTI->OrgInsIdx >= OrgInsIdx) {

                    ++pTI->OrgInsIdx;
                }
            }

            pTI--;

        } while (CurIdx--);

        RetIdx = (SHORT)(++(pTabTable->cTab));

        break;
    }

    CPSUIDBG(DBG_TABTABLE,
             ("%hs(0x%lx, %ld, %ld)=%ld",
                pszTabMode[Mode], pTabTable, (LONG)Idx, (LONG)OrgInsIdx,
                (LONG)RetIdx));

    return((LONG)RetIdx);
}



BOOL
CALLBACK
NO_PSN_APPLY_PROC(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
#define pNMHdr      ((NMHDR *)lParam)
#define pPN         ((PSHNOTIFY *)lParam)

    DLGPROC OldDlgProc;


    if (OldDlgProc = (DLGPROC)GetProp(hDlg, CPSUIPROP_WNDPROC)) {

        switch (Msg) {

        case WM_NOTIFY:

            if (pNMHdr->code == PSN_APPLY) {

                //
                // Ignore it
                //

                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);

                CPSUIDBG(DBG_GET_TABWND,
                        ("!!IGNORE NO_PSN_APPLY_PROC(%ld, PSN_APPLY %08lx (%08lx), %ld (%ld), %ld, %ld), hDlg=%08lx",
                        wParam,
                        pNMHdr->hwndFrom, GetParent(hDlg),
                        pNMHdr->idFrom, GetWindowLongPtr(GetParent(hDlg), GWLP_ID),
                        pNMHdr->code, pPN->lParam, hDlg));

                return(TRUE);
            }

            break;

        case WM_DESTROY:

            RemoveProp(hDlg, CPSUIPROP_WNDPROC);
            SetWindowLongPtr(hDlg, DWLP_DLGPROC, (LPARAM)OldDlgProc);

            CPSUIDBG(DBG_GET_TABWND,
                    ("!! NO_PSN_APPLY_PROC(WM_DESTORY): hDlg=%08lx, Change DlgProc back to %08lx",
                            hDlg, OldDlgProc));
            break;
        }

        return((BOOL)CallWindowProc((WNDPROC)OldDlgProc,
                                    hDlg,
                                    Msg,
                                    wParam,
                                    lParam));
    }

    return(TRUE);


#undef pPN
#undef pNMHdr
}




BOOL
CALLBACK
SetIgnorePSNApplyProc(
    PCPSUIPAGE  pPage
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    04-Feb-1998 Wed 22:51:57 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hDlg;
    DLGPROC OldDlgProc;
    BOOL    Ok = FALSE;

    if (hDlg = pPage->hPageInfo.hDlg) {

        if (pPage->Flags & CPF_NO_PSN_APPLY) {

            //
            // Following will prevent us to set it more than once
            //

            if ((!(pPage->Flags & CPF_DLGPROC_CHANGED))                      &&
                (OldDlgProc = (DLGPROC)GetWindowLongPtr(hDlg, DWLP_DLGPROC)) &&
                (OldDlgProc != (DLGPROC)NO_PSN_APPLY_PROC)                   &&
                (!GetProp(hDlg, CPSUIPROP_WNDPROC))                          &&
                (SetProp(hDlg, CPSUIPROP_WNDPROC, (HANDLE)OldDlgProc))       &&
                (SetWindowLongPtr(hDlg,
                                  DWLP_DLGPROC,
                                  (LPARAM)NO_PSN_APPLY_PROC))) {

                Ok            = TRUE;
                pPage->Flags |= CPF_DLGPROC_CHANGED;

                CPSUIDBG(DBG_GET_TABWND,
                            ("SetIgnorePSNApplyProc:  pPage=%08lx, DlgProc: %08lx --> NO_PSN_APPLY_PROC",
                                pPage, OldDlgProc));
            }

        } else {

            if ((pPage->Flags & CPF_DLGPROC_CHANGED)                     &&
                (OldDlgProc = (DLGPROC)GetProp(hDlg, CPSUIPROP_WNDPROC)) &&
                (SetWindowLongPtr(hDlg, DWLP_DLGPROC, (LPARAM)OldDlgProc))) {

                Ok            = TRUE;
                pPage->Flags &= ~CPF_DLGPROC_CHANGED;

                RemoveProp(hDlg, CPSUIPROP_WNDPROC);

                CPSUIDBG(DBG_GET_TABWND,
                            ("SetIgnorePSNApplyProc:  pPage=%08lx, DlgProc: NO_PSN_APPLY_PROC --> %08lx",
                                pPage, OldDlgProc));
            }
        }

    } else {

        CPSUIDBG(DBG_GET_TABWND,
                ("SetIgnorePSNApplyProc:  pPage=%08lx, hDlg=NULL", pPage));
    }

    if (!Ok) {

        CPSUIDBG(DBG_GET_TABWND,
                ("SetIgnorePSNApplyProc:  hDlg=%08lx, pPage=%08lx, Handle=%08lx, FAILED",
                        hDlg, pPage, pPage->hCPSUIPage));
    }

    return(Ok);
}




LRESULT
CALLBACK
TabCtrlWndProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PTABTABLE   pTabTable;
    LRESULT     Result = 0;
    WORD        Idx;


    if ((pTabTable = (PTABTABLE)GetProp(hWnd, CPSUIPROP_TABTABLE))  &&
        (pTabTable->pTabTable == pTabTable)) {

        NULL;

    } else {

        pTabTable = NULL;

        CPSUIERR(("TabCtrlWndProc: pTabTable=%08lx", pTabTable));
    }

    CPSUIDBGBLK(
    {
        if (Msg >= TCM_FIRST) {

            switch (Msg) {

            case TCM_GETCURSEL:

                CPSUIDBG(DBG_TCMPROC, ("TCM_GETCURSEL"));
                break;

            case TCM_HITTEST:

                CPSUIDBG(DBG_TCMPROC, ("TCM_HITTEST"));
                break;

            case TCM_DELETEITEM:

                CPSUIDBG(DBG_TCMPROC, ("TCM_DELETEITEM"));
                break;

            case TCM_GETITEMRECT:

                CPSUIDBG(DBG_TCMPROC, ("TCM_GETITEMRECT"));
                break;

            case TCM_GETITEMA:

                CPSUIDBG(DBG_TCMPROC, ("TCM_GETITEMA"));
                break;

            case TCM_GETITEMW:

                CPSUIDBG(DBG_TCMPROC, ("TCM_GETITEMW"));
                break;

            case TCM_SETITEMA:

                CPSUIDBG(DBG_TCMPROC, ("TCM_SETITEMA"));
                break;

            case TCM_SETITEMW:

                CPSUIDBG(DBG_TCMPROC, ("TCM_SETITEMW"));
                break;

            case TCM_SETCURSEL:

                CPSUIDBG(DBG_TCMPROC, ("TCM_SETCURSEL"));
                break;

            case TCM_INSERTITEMA:

                CPSUIDBG(DBG_TCMPROC, ("TCM_INSERTITEMA"));
                break;

            case TCM_INSERTITEMW:

                CPSUIDBG(DBG_TCMPROC, ("TCM_INSERTITEMW"));
                break;

            case TCM_DELETEALLITEMS:

                CPSUIDBG(DBG_TCMPROC, ("TCM_DELETEALLITEMS"));
                break;

            default:

                CPSUIDBG(DBG_TCMPROC, ("TCM_FIRST + %ld",  Msg - TCM_FIRST));
                break;
            }
        }
    })

    if (pTabTable) {

        TC_ITEM     *ptci;
        WPARAM      OldwParam;
        WORD        wIdx;
        BOOL        CallOldProc;


        ptci        = (TC_ITEM *)lParam;
        OldwParam   = wParam;
        CallOldProc = TRUE;


        switch (Msg) {

        //
        // These are TAB_MODE_INSERT after call
        //

        case TCM_INSERTITEMA:
        case TCM_INSERTITEMW:

            DBG_SHOW_PTCI("!!BEFORE!!", wParam, ptci);

            if (pTabTable->cTab >= MAXPROPPAGES) {

                CPSUIERR(("Too may TABs=%ld, can not add any more.",
                                        pTabTable->cTab));
                return(-1);
            }

            if (OldwParam > pTabTable->cTab) {

                OldwParam = (WPARAM)pTabTable->cTab;
            }

            if ((wIdx = pTabTable->InsIdx) > pTabTable->cTab) {

                wIdx = pTabTable->cTab;
            }

            wParam = (WPARAM)wIdx;

            break;

        //
        // These are TAB_MODE_FIND after call
        //

        case TCM_GETCURSEL:
        case TCM_HITTEST:

            ptci = NULL;

            if ((Result = CallWindowProc(pTabTable->WndProc,
                                         hWnd,
                                         Msg,
                                         wParam,
                                         lParam)) >= 0) {

                if ((Msg == TCM_GETCURSEL)                  &&
                    (pTabTable->CurSel != (WORD)Result)     &&
                    (!(pTabTable->TabInfo[Result].hDlg))) {

                    CPSUIDBG(DBG_GET_TABWND, ("!! TCM_GETCURSEL:  PostMessage(TCM_SETCURSEL=%ld, CurSel=%ld) to Get hDlg/DlgProc",
                                            Result, pTabTable->CurSel));

                    CPSUIDBG(DBG_GET_TABWND,
                            ("TCM_GETCURSEL: MAP TabInfo[%ld]=%d, Handle=%08lx, hDlg=%08lx",
                                Result, pTabTable->TabInfo[Result].OrgInsIdx,
                                pTabTable->TabInfo[Result].HandleIdx,
                                pTabTable->TabInfo[Result].hDlg));

                    pTabTable->cPostSetCurSel = COUNT_POSTSETCURSEL;
                    pTabTable->iPostSetCurSel = (SHORT)Result;

                    PostMessage(hWnd, TCM_SETCURSEL, Result, 0);
                }

                Result = (LONG)pTabTable->TabInfo[Result].OrgInsIdx;
            }

            CallOldProc = FALSE;
            break;

        //
        // These are TAB_MODE_FIND before call, and return TRUE/FALSE
        //

        case TCM_DELETEITEM:
        case TCM_GETITEMRECT:

            ptci = NULL;

        case TCM_GETITEMA:
        case TCM_GETITEMW:
        case TCM_SETITEMA:
        case TCM_SETITEMW:

            DBG_SHOW_PTCI("!!BEFORE!!", wParam, ptci);

            if ((Result = DoTabTable(TAB_MODE_FIND,
                                     pTabTable,
                                     (SHORT)wParam,
                                     0)) >= 0) {

                wParam = (WPARAM)Result;

            } else {

                CallOldProc = FALSE;
            }

            break;

        //
        // These are TAB_MODE_FIND before call, and return Index
        //

        case TCM_SETCURSEL:

            ptci = NULL;

            DBG_SHOW_PTCI("!!BEFORE!!", wParam, ptci);

            CPSUIDBG(DBG_GET_TABWND, ("SETCURSEL: %ld --> %ld, CurSel=%ld",
                wParam, DoTabTable(TAB_MODE_FIND, pTabTable, (SHORT)wParam, 0),
                pTabTable->CurSel));

            if ((Result = DoTabTable(TAB_MODE_FIND,
                                     pTabTable,
                                     (SHORT)wParam,
                                     0)) >= 0) {

                wParam = (WPARAM)Result;

            } else {

                CallOldProc = FALSE;
            }

            break;

        //
        // These are no item index passed
        //

        default:

            ptci = NULL;
            break;
        }

        if (CallOldProc) {

            Result = CallWindowProc(pTabTable->WndProc,
                                    hWnd,
                                    Msg,
                                    wParam,
                                    lParam);

            DBG_SHOW_PTCI("!!AFTER!!", wParam, ptci);
        }

        switch (Msg) {

        case TCM_DELETEALLITEMS:

            if (Result) {

                DoTabTable(TAB_MODE_DELETE_ALL, pTabTable, 0, 0);
            }

            break;

        case TCM_DELETEITEM:

            if (Result) {

                DoTabTable(TAB_MODE_DELETE, pTabTable, (SHORT)OldwParam, 0);

                CPSUIDBG(DBG_GET_TABWND,
                         ("DeleteItem: Result=%ld, OldwParam=%u, Count=%ld",
                                Result, OldwParam, pTabTable->cTab));
                SHOW_TABWND(L"TCM_DELETEITEM", pTabTable);
            }

            break;

        case TCM_GETITEMA:
        case TCM_GETITEMW:

            if (pTabTable->iPostSetCurSel >= 0) {

                pTabTable->cPostSetCurSel = COUNT_POSTSETCURSEL;

                PostMessage(hWnd,
                            TCM_SETCURSEL,
                            (WPARAM)pTabTable->iPostSetCurSel,
                            0);
            }

            break;

        case TCM_INSERTITEMA:
        case TCM_INSERTITEMW:

            if (Result >= 0) {

                DoTabTable(TAB_MODE_INSERT,
                           pTabTable,
                           (SHORT)Result,
                           (SHORT)OldwParam);

                pTabTable->TabInfo[Result].HandleIdx = pTabTable->HandleIdx;

                CPSUIDBG(DBG_GET_TABWND,
                         ("InsertItem: OldwParam=%ld, Result=%ld, Count=%ld, Handle=%08lx",
                                OldwParam, Result, pTabTable->cTab,
                                WORD_2_HANDLE(pTabTable->HandleIdx)));
                SHOW_TABWND(L"TCM_INSERTITEM", pTabTable);
            }

            //
            // Reset to the maximum
            //

            pTabTable->InsIdx    =
            pTabTable->HandleIdx = 0xFFFF;

            break;

        case TCM_SETCURSEL:

            if (Result >= 0) {

                PCPSUIPAGE  pPage;
                HWND        hDlg;
                DLGPROC     DlgProc;
                PTABINFO    pTI;

                //
                // Invert the return value from tab table
                //

                pTI = &(pTabTable->TabInfo[wParam]);

                CPSUIDBG(DBG_GET_TABWND, ("SETCURSEL: Result:OldSel=%ld --> %ld, CurSel=%ld",
                        Result, pTabTable->TabInfo[Result].OrgInsIdx, wParam));

                pTabTable->CurSel = (WORD)wParam;

                if (!pTI->hDlg) {

                    Idx = pTI->HandleIdx;

                    if (hDlg = (HWND)SendMessage(pTabTable->hPSDlg,
                                                 PSM_GETCURRENTPAGEHWND,
                                                 (WPARAM)0,
                                                 (LPARAM)0)) {

                        UINT        i = (UINT)pTabTable->cTab;
                        PTABINFO    pTIChk = pTabTable->TabInfo;

                        //
                        // Find out if we already has this hDlg, if we do
                        // then we are in trouble, since it cannot have two
                        // Tab Pages with same hDlg
                        //

                        while (i--) {

                            if (pTIChk->hDlg == hDlg) {

                                CPSUIASSERT(0, "SetCurSel: Table.hDlg already exist in TabInfo[%ld]",
                                            pTIChk->hDlg != hDlg, UIntToPtr(pTabTable->cTab - i - 1));

                                hDlg = NULL;

                                break;

                            } else {

                                pTIChk++;
                            }
                        }
                    }

                    if ((hDlg)  &&
                        (DlgProc = (DLGPROC)GetWindowLongPtr(hDlg,
                                                             DWLP_DLGPROC)) &&
                        (pPage =
                                HANDLETABLE_GetCPSUIPage(WORD_2_HANDLE(Idx)))) {

                        pTabTable->cPostSetCurSel = 0;
                        pTabTable->iPostSetCurSel = -1;

                        CPSUIDBG(DBG_GET_TABWND,
                                    ("SETCURSEL(%08lx): TabInfo[%u]: Handle=%08lx, hDlg=%08lx (%08lx), DlgProc=%08lx --> %08lx",
                                        pTabTable->hPSDlg,
                                        wParam, WORD_2_HANDLE(Idx),
                                        pPage->hPageInfo.hDlg, hDlg,
                                        pPage->hPageInfo.DlgProc, DlgProc));

                        pTI->hDlg                 =
                        pPage->hPageInfo.hDlg     = hDlg;
                        pPage->hPageInfo.DlgProc  = DlgProc;
                        pPage->Flags             |= CPF_ACTIVATED;

                        if ((pPage->Flags & (CPF_NO_PSN_APPLY |
                                             CPF_DLGPROC_CHANGED)) ==
                                                        CPF_NO_PSN_APPLY) {

                            SetIgnorePSNApplyProc(pPage);
                        }

                        HANDLETABLE_UnGetCPSUIPage(pPage);

                        SHOW_TABWND(L"TCM_SETCURSEL", pTabTable);

                    } else if (pTabTable->cPostSetCurSel) {

                        --(pTabTable->cPostSetCurSel);

                        CPSUIDBG(DBG_GET_TABWND,
                            ("!! FAILED: (Dlg=%08lx, DlgProc=%08lx, pPage=%08lx), PostMessage(TCM_SETCURSEL=%ld)",
                            hDlg, DlgProc, pPage, pTI->OrgInsIdx));

                        PostMessage(hWnd,
                                    TCM_SETCURSEL,
                                    (WPARAM)pTI->OrgInsIdx,
                                    0);

                    } else {

                        pTabTable->iPostSetCurSel = (SHORT)pTI->OrgInsIdx;
                    }

                } else {

                    pTabTable->cPostSetCurSel = 0;
                    pTabTable->iPostSetCurSel = -1;
                }

                Result = (LONG)pTabTable->TabInfo[Result].OrgInsIdx;

                CPSUIDBG(DBG_TCMPROC, ("TCM_SETCURSEL: MAP TabInfo[%ld]=%d (%08lx)",
                        Result, pTabTable->TabInfo[Result].OrgInsIdx,
                        WORD_2_HANDLE(pTabTable->TabInfo[Result].HandleIdx)));
            }

            break;

        case TCM_GETITEMCOUNT:

            if (Result != (LONG)pTabTable->cTab) {

                CPSUIERR(("TCM_GETITEMCOUNT=%ld is not equal to cTab=%ld",
                        Result, (LONG)pTabTable->cTab));
            }

            break;

        case WM_DESTROY:

            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LPARAM)pTabTable->WndProc);
            RemoveProp(hWnd, CPSUIPROP_TABTABLE);
            break;
        }

        if (Msg >= TCM_FIRST) {

            CPSUIDBG(DBG_TCMPROC, ("!! Result=%ld !!\n", Result));
        }
    }

    return(Result);
}



LONG_PTR
SetPSUIPageTitle(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pPage,
    LPWSTR      pTitle,
    BOOL        AnsiCall
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    21-Feb-1996 Wed 14:16:17 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND            hWndTab;
    INSPAGEIDXINFO  InsPageIdxInfo;

    if ((pTitle)                                                    &&
        (InsPageIdxInfo.pCPSUIPage = pPage)                         &&
        (pRootPage->RootInfo.hDlg)                                  &&
        (!(pPage->Flags & CPF_PARENT))                              &&
        (pPage->hPage)                                              &&
        (InsPageIdxInfo.pTabTable = pRootPage->RootInfo.pTabTable)  &&
        (hWndTab = pRootPage->RootInfo.pTabTable->hWndTab)) {

        //
        // The property sheet already displayed
        //

        EnumCPSUIPagesSeq(pRootPage,
                          pRootPage,
                          SetInsPageIdxProc,
                          (LPARAM)&InsPageIdxInfo);

        if (InsPageIdxInfo.pCPSUIPage == NULL) {

            TC_ITEM tcItem;

            tcItem.mask    = TCIF_TEXT;
            tcItem.pszText = pTitle;

            if (SendMessage(hWndTab,
                            (AnsiCall) ? TCM_SETITEMA : TCM_SETITEMW,
                            (WPARAM)GET_REAL_INSIDX(InsPageIdxInfo.pTabTable),
                            (LPARAM)(TC_ITEM FAR*)&tcItem)) {

                return(1);
            }
        }
    }

    return(0);
}



LONG_PTR
SetPSUIPageIcon(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pPage,
    HICON       hIcon
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    21-Feb-1996 Wed 14:16:17 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND            hWndTab;
    INSPAGEIDXINFO  InsPageIdxInfo;

    while ((pPage) && (pPage->Flags & CPF_PARENT)) {

        pPage = pPage->pChild;
    }

    InsPageIdxInfo.pCPSUIPage = pPage;
    if (pPage                                                       &&
        (pRootPage->RootInfo.hDlg)                                  &&
        (!(pPage->Flags & CPF_PARENT))                              &&
        (pPage->hPage)                                              &&
        (InsPageIdxInfo.pTabTable = pRootPage->RootInfo.pTabTable)  &&
        (hWndTab = pRootPage->RootInfo.pTabTable->hWndTab)) {

        //
        // The property sheet already displayed
        //

        EnumCPSUIPagesSeq(pRootPage,
                          pRootPage,
                          SetInsPageIdxProc,
                          (LPARAM)&InsPageIdxInfo);

        if (InsPageIdxInfo.pCPSUIPage == NULL) {

            HIMAGELIST  himi;
            TC_ITEM     tcItem;
            UINT        InsIdx;


            InsIdx = (UINT)GET_REAL_INSIDX(InsPageIdxInfo.pTabTable);
            himi   = TabCtrl_GetImageList(hWndTab);

            if (pPage->hPageInfo.hIcon) {

                //
                // Replace the Image ID icon
                //

                if (!himi) {

                    CPSUIERR(("SetPSUIPageIcon: No Image List in Tab Control"));
                    return(0);
                }

                tcItem.mask = TCIF_IMAGE;

                if (SendMessage(hWndTab,
                                TCM_GETITEMW,
                                (WPARAM)InsIdx,
                                (LPARAM)(TC_ITEM FAR*)&tcItem)) {

                    if (hIcon) {

                        tcItem.iImage = ImageList_ReplaceIcon(himi,
                                                              tcItem.iImage,
                                                              hIcon);

                    } else {

                        //
                        // We need to remove this from image list
                        //

                        ImageList_Remove(himi, tcItem.iImage);
                        tcItem.iImage = -1;
                    }

                } else {

                    tcItem.iImage = -1;
                }

            } else {

                //
                // Add new icon to the image list only if hIcon is not NULL
                //
                //


                if (hIcon) {

                    if (!himi) {

                        if (!(himi = ImageList_Create(16,
                                                      16,
                                                      ILC_COLOR4 | ILC_MASK,
                                                      16,
                                                      16))) {

                            CPSUIERR(("SetPSUIPageIcon: Create Tab Contrl Image List FAILED"));
                            return(0);
                        }

                        if (SendMessage(hWndTab,
                                        TCM_SETIMAGELIST,
                                        0,
                                        (LPARAM)himi)) {

                            CPSUIERR(("SetPSUIPageIcon: ?Has Previous Image list"));
                        }
                    }

                    tcItem.iImage = ImageList_AddIcon(himi, hIcon);

                } else {

                    //
                    // nothing to do
                    //

                    return(1);
                }
            }

            pPage->hPageInfo.hIcon = hIcon;
            tcItem.mask            = TCIF_IMAGE;

            if (SendMessage(hWndTab,
                            TCM_SETITEMW,
                            (WPARAM)InsIdx,
                            (LPARAM)(TC_ITEM FAR*)&tcItem)) {

                return(1);
            }

        }
    }

    return(0);
}



UINT
CALLBACK
PropSheetProc(
    HWND    hWnd,
    UINT    Msg,
    LPARAM  lParam
    )
{
    if (hWnd) {

        PTABTABLE   pTabTable;
        HANDLE      hRootPage;
        PCPSUIPAGE  pRootPage;
        HWND        hWndTab;
        WORD        Idx;

        LOCK_CPSUI_HANDLETABLE();

        Idx       = TLSVALUE_2_IDX(TlsGetValue(TlsIndex));
        hRootPage = WORD_2_HANDLE(Idx);

        CPSUIDBG(DBG_PAGE_PROC, ("ProcessID=%ld, ThreadID=%ld [TIsValue=%08lx]",
                GetCurrentProcessId(), GetCurrentThreadId(),
                TlsGetValue(TlsIndex)));

        if (pRootPage = HANDLETABLE_GetCPSUIPage(hRootPage)) {

            if ((pRootPage->Flags & CPF_ROOT)                   &&
                (pRootPage->RootInfo.hDlg = hWnd)               &&
                (pTabTable = pRootPage->RootInfo.pTabTable)     &&
                (pTabTable->hWndTab == NULL)                    &&
                (pTabTable->hWndTab = hWndTab =
                                            PropSheet_GetTabControl(hWnd))) {

                //
                // Done and remembered so reset it back to 0
                //

                CPSUIDBG(DBG_PAGE_PROC,
                         ("PropSheetProc: hDlg RootPage=%08lx", hWnd));

                pTabTable->hPSDlg  = hWnd;
                pTabTable->WndProc = (WNDPROC)GetWindowLongPtr(hWndTab,
                                                               GWLP_WNDPROC);

                SetProp(hWndTab, CPSUIPROP_TABTABLE, (HANDLE)pTabTable);
                SetWindowLongPtr(hWndTab, GWLP_WNDPROC, (LPARAM)TabCtrlWndProc);
            }

            HANDLETABLE_UnGetCPSUIPage(pRootPage);

        } else {

            CPSUIERR(("PropSheetProc(): Invalid pRootPage=%08lx ???", pRootPage));
        }

        UNLOCK_CPSUI_HANDLETABLE();
    }

    CPSUIDBG(DBG_PAGE_PROC,
             ("hWnd=%08lx, Msg=%ld, lParam=%08lx", hWnd, Msg, lParam));

    return(0);
}




UINT
CALLBACK
CPSUIPSPCallBack(
    HWND            hWnd,
    UINT            Msg,
    LPPROPSHEETPAGE pPSPage
    )

/*++

Routine Description:

    This function trap user supplied PropSheetPageProc callback function to
    fixed up our PROPSHEETPAGE structure's lParam, pfnCallback, pfnDlgProc and
    dwSize.

Arguments:




Return Value:




Author:

    28-Jun-1996 Fri 12:49:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    ULONG_PTR ulCookie = 0;
    BOOL bCtxActivated = FALSE;
    HANDLE hActCtx = INVALID_HANDLE_VALUE;

    if (Msg == PSPCB_CREATE) {

        PCPSUIPAGE          pCPSUIPage;
        DLGPROC             DlgProc;
        LPFNPSPCALLBACK     pspCB;
        DWORD               dwSize;
        UINT                Result;


        pCPSUIPage = (PCPSUIPAGE)pPSPage->lParam;
        DlgProc    = pPSPage->pfnDlgProc;
        pspCB      = pPSPage->pfnCallback;
        dwSize     = pPSPage->dwSize;

        CPSUIDBG(DBG_PAGEDLGPROC,
                 ("PSPCB_CREATE(1): pCPSUIPage=%08lx, DlgProc=%08lx,  lParam=%08lx, pspCB=%08lx, Size=%ld",
                 pCPSUIPage, pPSPage->pfnDlgProc,
                 pPSPage->lParam, pPSPage->pfnCallback, pPSPage->dwSize));

        //
        // fixed up user's pfnDlgProc, lParam, pfnCallback, dwSize
        //

        pPSPage->pfnDlgProc  = pCPSUIPage->hPageInfo.DlgProc;
        pPSPage->lParam      = pCPSUIPage->hPageInfo.lParam;
        pPSPage->pfnCallback = pCPSUIPage->hPageInfo.pspCB;
        pPSPage->dwSize      = pCPSUIPage->hPageInfo.dwSize;

        CPSUIDBG(DBG_PSPCB,
                ("CPSUIPSPCallBack(hWnd=%08lx, Msg=%ld, pPSPage=%08lx)",
                                            hWnd, Msg, pPSPage));

        try {

            if (GetPageActivationContext(pCPSUIPage, &hActCtx)) {

                bCtxActivated = ActivateActCtx(hActCtx, &ulCookie);
            }

            __try {

                Result = pPSPage->pfnCallback(hWnd, Msg, pPSPage);
            } 
            __finally  {

                //
                // we need to deactivate the context, no matter what!
                //
                if (bCtxActivated) {
                    
                    DeactivateActCtx(0, ulCookie);
                }
            }

        } except (FilterException(pCPSUIPage->hCPSUIPage,
                                  GetExceptionInformation())) {

            Result = 0;
        }

        //
        // save back if user change it
        //

        pCPSUIPage->hPageInfo.DlgProc  = pPSPage->pfnDlgProc;
        pCPSUIPage->hPageInfo.lParam   = pPSPage->lParam;
        pCPSUIPage->hPageInfo.pspCB    = pPSPage->pfnCallback;

        CPSUIDBG(DBG_PAGEDLGPROC,
                 ("PSPCB_CREATE(2): pCPSUIPage=%08lx, DlgProc=%08lx,  lParam=%08lx, pspCB=%08lx, Size=%ld",
                 pCPSUIPage, pPSPage->pfnDlgProc,
                 pPSPage->lParam, pPSPage->pfnCallback, pPSPage->dwSize));

        //
        // Now put in original content at this call
        //

        pPSPage->pfnDlgProc  = DlgProc;
        pPSPage->lParam      = (LPARAM)pCPSUIPage;
        pPSPage->pfnCallback = pspCB;
        pPSPage->dwSize      = dwSize;

        CPSUIDBG(DBG_PAGEDLGPROC,
                 ("PSPCB_CREATE(3): pCPSUIPage=%08lx, DlgProc=%08lx,  lParam=%08lx, pspCB=%08lx, Size=%ld",
                 pCPSUIPage, pPSPage->pfnDlgProc,
                 pPSPage->lParam, pPSPage->pfnCallback, pPSPage->dwSize));

        return(Result);

    } else {

        CPSUIERR(("CPSUIPSPCallBack: Invalid Msg=%u passed, return 0", Msg));
        return(0);
    }
}




INT_PTR
CALLBACK
CPSUIPageDlgProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    This function trap for each property sheet page activation for remember
    its hDlg and handle to the property sheet, after we trap the WM_INITDIALOG
    we will release the trap DlgProc.


Arguments:



Return Value:




Author:

    28-Jun-1995 Wed 17:00:44 created  -by-  Daniel Chou (danielc)


Revision History:

    Add original dwSize, pfnCallback trap

--*/

{
    ULONG_PTR ulCookie = 0;
    BOOL bCtxActivated = FALSE;
    HANDLE hActCtx = INVALID_HANDLE_VALUE;

    if (Msg == WM_INITDIALOG) {

        LPPROPSHEETPAGE pPSPage;
        PCPSUIPAGE      pCPSUIPage;
        PCPSUIPAGE      pRootPage;
        LONG            Result;


        pPSPage    = (LPPROPSHEETPAGE)lParam;
        pRootPage  =
        pCPSUIPage = (PCPSUIPAGE)pPSPage->lParam;

        while (pRootPage->pParent) {

            pRootPage = pRootPage->pParent;
        }

        CPSUIASSERT(0, "CPSUIPageDlgProc: No ROOT Page=%08lx",
                    (pRootPage->Flags & CPF_ROOT), pRootPage);

        if (pRootPage->Flags & CPF_ROOT) {

            if (pRootPage->RootInfo.hDlg) {

                CPSUIDBG(DBG_PAGEDLGPROC,
                         ("CPSUIPageDlgProc: Already has a hDlg in ROOT=%08lx",
                            pRootPage->RootInfo.hDlg));

            } else {

                pRootPage->RootInfo.hDlg = GetParent(hDlg);
            }
        }

        //
        // Fixed up user's DlgProc, lParam, pfnCallBack and dwSize and remember
        // this hDlg.  After we call the WM_INITDIALOG, we will not reset it
        // back since we will already trap it and will not need any more of
        // these information, the pfnCallback for the PSPCB_RELEASE will go to
        // the user supplied callback directly if one exist.
        //

        pPSPage->pfnDlgProc         = pCPSUIPage->hPageInfo.DlgProc;
        pPSPage->lParam             = pCPSUIPage->hPageInfo.lParam;
        pPSPage->pfnCallback        = pCPSUIPage->hPageInfo.pspCB;
        pPSPage->dwSize             = pCPSUIPage->hPageInfo.dwSize;
        pCPSUIPage->hPageInfo.hDlg  = hDlg;
        pCPSUIPage->Flags          |= CPF_ACTIVATED;

        CPSUIDBG(DBG_PAGEDLGPROC,
                ("CPSUIPageDlgProc: WM_INITDIALOG: hDlg=%08lx, pCPSUIPage=%08lx, DlgProc=%08lx,  lParam=%08lx, pspCB=%08lx, Size=%ld",
                hDlg, pCPSUIPage, pPSPage->pfnDlgProc,
                pPSPage->lParam, pPSPage->pfnCallback, pPSPage->dwSize));

        SetWindowLongPtr(hDlg, DWLP_DLGPROC, (LPARAM)pPSPage->pfnDlgProc);

        try {

            if (GetPageActivationContext(pCPSUIPage, &hActCtx)) {

                bCtxActivated = ActivateActCtx(hActCtx, &ulCookie);
            }

            __try {

                Result = pPSPage->pfnDlgProc(hDlg, Msg, wParam, lParam) ? TRUE : FALSE;
            } 
            __finally  {

                //
                // we need to deactivate the context, no matter what!
                //
                if (bCtxActivated) {
                    
                    DeactivateActCtx(0, ulCookie);
                }
            }

        } except (FilterException(pRootPage->hCPSUIPage,
                                  GetExceptionInformation())) {

            Result = FALSE;
        }

        return(Result);
    }

    return(FALSE);
}



BOOL
EnumCPSUIPagesSeq(
    PCPSUIPAGE          pRootPage,
    PCPSUIPAGE          pCPSUIPage,
    CPSUIPAGEENUMPROC   CPSUIPageEnumProc,
    LPARAM              lParam
    )

/*++

Routine Description:

    This function enumerate pCPSUIPage and all its children includes header
    page of children.   The enumeration always enumerate in the order of
    Parent first then the children in the sequence of tree.


Arguments:

    pCPSUIPage          - The starting parent page to be enumberated

    CPSUIPageEnumProc   - The caller supplied function for each enumberated
                          page, this fucntion return FALSE to stop enumeration.

    lParam              - a 32-bit parameter passed to the caller supplied
                          enumeration funciton


Return Value:

    BOOLEAN


Author:

    29-Dec-1995 Fri 15:25:01 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL    Ok = TRUE;

    //
    // now enumerate the parent
    //

    LOCK_CPSUI_HANDLETABLE();

    if (CPSUIPageEnumProc(pRootPage, pCPSUIPage, lParam)) {

        if (pCPSUIPage->Flags & CPF_PARENT) {

            //
            // If this a parent then enum all its children first
            //

            PCPSUIPAGE  pCurPage = pCPSUIPage->pChild;
            PCPSUIPAGE  pNext;

            while (pCurPage) {

                pNext = pCurPage->pNext;

                if (!EnumCPSUIPagesSeq(pRootPage,
                                       pCurPage,
                                       CPSUIPageEnumProc,
                                       lParam)) {

                    Ok = FALSE;
                    break;
                }

                pCurPage = pNext;
            }
        }

    } else {

        Ok = FALSE;
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(Ok);
}



BOOL
EnumCPSUIPages(
    PCPSUIPAGE          pRootPage,
    PCPSUIPAGE          pCPSUIPage,
    CPSUIPAGEENUMPROC   CPSUIPageEnumProc,
    LPARAM              lParam
    )

/*++

Routine Description:

    This function enumerate pCPSUIPage and all its children includes header
    page of children.   The enumeration always enumerate in the order of
    children first then the parent.


Arguments:

    pCPSUIPage          - The starting parent page to be enumberated

    CPSUIPageEnumProc   - The caller supplied function for each enumberated
                          page, this fucntion return FALSE to stop enumeration.

    lParam              - a 32-bit parameter passed to the caller supplied
                          enumeration funciton


Return Value:

    BOOLEAN


Author:

    29-Dec-1995 Fri 15:25:01 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL    Ok = TRUE;


    LOCK_CPSUI_HANDLETABLE();

    if (pCPSUIPage->Flags & CPF_PARENT) {

        //
        // If this a parent then enum all its children first
        //

        PCPSUIPAGE  pCurPage = pCPSUIPage->pChild;
        PCPSUIPAGE  pNext;

        while (pCurPage) {

            pNext = pCurPage->pNext;

            if (!EnumCPSUIPages(pRootPage,
                                pCurPage,
                                CPSUIPageEnumProc,
                                lParam)) {

                Ok = FALSE;
                break;
            }

            pCurPage = pNext;
        }
    }

    //
    // now enumerate the parent
    //

    if (Ok) {

        Ok = CPSUIPageEnumProc(pRootPage, pCPSUIPage, lParam);
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(Ok);
}





LONG
CallpfnPSUI(
    PCPSUIPAGE  pCPSUIPage,
    WORD        Reason,
    LPARAM      lParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    31-Jan-1996 Wed 14:27:21 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    ULONG_PTR ulCookie = 0;
    BOOL bCtxActivated = FALSE;
    HANDLE hActCtx = INVALID_HANDLE_VALUE;

    LONG    Result = 0;
    DWORD   dwErr = ERROR_SUCCESS;

    HANDLETABLE_LockCPSUIPage(pCPSUIPage);

    CPSUIDBG(DBG_CALLPFN, ("\n@ CallpfnPSUI(%08lx, %hs, %08lx)", pCPSUIPage,
                (Reason <= MAX_PROPSHEETUI_REASON_INDEX) ?
                        pszPFNReason[Reason] : "??? Unknown Reason",
                (Reason == PROPSHEETUI_REASON_SET_RESULT) ?
                    ((PSETRESULT_INFO)lParam)->Result : lParam));

    CPSUIASSERT(0, "CallpfnPSUI() Invalid Reason=%08lx",
                (Reason <= MAX_PROPSHEETUI_REASON_INDEX), Reason);

    if ((pCPSUIPage)                                &&
        (pCPSUIPage->Flags & CPF_PFNPROPSHEETUI)    &&
        (pCPSUIPage->hCPSUIPage)                    &&
        (pCPSUIPage->pfnInfo.pfnPSUI)) {

        PCPSUIPAGE          pRootPage;
        PROPSHEETUI_INFO    PSUIInfo;

        ZeroMemory(&PSUIInfo, sizeof(PSUIInfo));
        PSUIInfo.cbSize          = sizeof(PROPSHEETUI_INFO);
        PSUIInfo.Version         = PROPSHEETUI_INFO_VERSION;
        PSUIInfo.Flags           = (pCPSUIPage->Flags & CPF_ANSI_CALL) ?
                                                       0 : PSUIINFO_UNICODE;
        PSUIInfo.hComPropSheet   = pCPSUIPage->hCPSUIPage;
        PSUIInfo.pfnComPropSheet = CPSUICallBack;

        if ((PSUIInfo.Reason = Reason) == PROPSHEETUI_REASON_INIT) {

            pCPSUIPage->pfnInfo.lParamInit =
            PSUIInfo.lParamInit            = lParam;
            PSUIInfo.UserData              = 0;
            PSUIInfo.Result                = 0;

        } else {

            PSUIInfo.lParamInit = pCPSUIPage->pfnInfo.lParamInit;
            PSUIInfo.UserData   = pCPSUIPage->pfnInfo.UserData;
            PSUIInfo.Result     = pCPSUIPage->pfnInfo.Result;
        }

        CPSUIDBG(DBG_CALLPFN, ("CallpfnCPSUI: cbSize=%ld", (DWORD)PSUIInfo.cbSize));
        CPSUIDBG(DBG_CALLPFN, ("              Version=%04lx", (DWORD)PSUIInfo.Version));
        CPSUIDBG(DBG_CALLPFN, ("              Reason=%ld", (DWORD)PSUIInfo.Reason));
        CPSUIDBG(DBG_CALLPFN, ("              Flags=%08lx", (DWORD)PSUIInfo.Flags));
        CPSUIDBG(DBG_CALLPFN, ("              hComPropSheet=%08lx", PSUIInfo.hComPropSheet));
        CPSUIDBG(DBG_CALLPFN, ("              pfnComPropSheet=%08lx", PSUIInfo.pfnComPropSheet));
        CPSUIDBG(DBG_CALLPFN, ("              Result=%08lx", PSUIInfo.Result));
        CPSUIDBG(DBG_CALLPFN, ("              UserData=%08lx", PSUIInfo.UserData));

        try {

            if (GetPageActivationContext(pCPSUIPage, &hActCtx)) {

                bCtxActivated = ActivateActCtx(hActCtx, &ulCookie);
            }

            __try {

                Result = pCPSUIPage->pfnInfo.pfnPSUI(&PSUIInfo, lParam);
            } 
            __finally  {

                //
                // we need to deactivate the context, no matter what!
                //
                if (bCtxActivated) {
                    
                    DeactivateActCtx(0, ulCookie);
                }
            }

        } except (FilterException(pCPSUIPage->hCPSUIPage,
                                  GetExceptionInformation())) {

            Result = -1;
        }

        if (Result <= 0) {
            //
            // Something has failed. Save the last error here.
            //
            dwErr = GetLastError();
        }

        //
        // Save the new UserData and Result
        //

        pCPSUIPage->pfnInfo.UserData = PSUIInfo.UserData;
        pCPSUIPage->pfnInfo.Result   = PSUIInfo.Result;

        //
        // If this is the first pfnPropSheetUI() added and it passed a pResult
        // to the CommonPropertySheetUI() then set the result for it too.
        //

        if ((pRootPage = pCPSUIPage->pParent)   &&
            (pRootPage->Flags & CPF_ROOT)       &&
            (pRootPage->RootInfo.pResult)) {

            *(pRootPage->RootInfo.pResult) = (DWORD)PSUIInfo.Result;
        }

        CPSUIDBG(DBG_CALLPFN, ("---------CallpfnCPSUI()=%ld----------", Result));
        CPSUIDBG(DBG_CALLPFN, ("    New Result=%08lx%ws", PSUIInfo.Result,
                ((pRootPage) && (pRootPage->Flags & CPF_ROOT) &&
                 (pRootPage->RootInfo.pResult)) ? L" (== *pResult)" : L""));
        CPSUIDBG(DBG_CALLPFN, ("    New UserData=%08lx\n", PSUIInfo.UserData));

    } else {

        CPSUIERR(("CallpfnPSUI(): Invalid pCPSUIPage=%08lx", pCPSUIPage));
    }

    HANDLETABLE_UnLockCPSUIPage(pCPSUIPage);

    if (ERROR_SUCCESS != dwErr) {
        //
        // Set the preserved last error.
        //
        SetLastError(dwErr);
    }

    return(Result);
}




HICON
pfnGetIcon(
    PCPSUIPAGE  pPage,
    LPARAM      lParam
    )

/*++

Routine Description:

    This function return the hIcon for the pfnPropSheetUI()


Arguments:

    pPage   - The page has CPF_PFNPROPSHEETUI flag set

    lParam  - LOWORD(lParam) = cxIcon
              HIWORD(lParam) = cyIcon

Return Value:




Author:

    11-Feb-1996 Sun 12:18:39 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCPSUIPAGE                  pChild;
    PTVWND                      pTVWnd;
    POPTITEM                    pItem;
    PROPSHEETUI_GETICON_INFO    PSUIGetIconInfo;


    PSUIGetIconInfo.cbSize = sizeof(PSUIGetIconInfo);
    PSUIGetIconInfo.Flags  = 0;

    if (!(PSUIGetIconInfo.cxIcon = LOWORD(lParam))) {

        PSUIGetIconInfo.cxIcon = (WORD)GetSystemMetrics(SM_CXICON);
    }

    if (!(PSUIGetIconInfo.cyIcon = HIWORD(lParam))) {

        PSUIGetIconInfo.cyIcon = (WORD)GetSystemMetrics(SM_CYICON);
    }

    PSUIGetIconInfo.hIcon = NULL;

    //
    // If this is the PFNPROPSHEETUI and it got only one child which is the
    // COMPROPSHEETUI then we can return the Icon for the COMPROPSHEETUI
    // internally
    //

    //
    // Skip to last PFNPROPSHEETUI in the chain
    //

    LOCK_CPSUI_HANDLETABLE();

    while ((pPage->Flags & CPF_PFNPROPSHEETUI)  &&
           (pChild = pPage->pChild)             &&
           (pChild->Flags & CPF_PFNPROPSHEETUI) &&
           (pChild->pNext == NULL)) {

        pPage = pChild;
    }

    if ((pPage->Flags & CPF_PFNPROPSHEETUI)                 &&
        (pChild = pPage->pChild)                            &&
        (pChild->Flags & CPF_COMPROPSHEETUI)                &&
        (pChild->pNext == NULL)                             &&
        (pTVWnd = pChild->CPSUIInfo.pTVWnd)                 &&
        (pItem = PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT))    &&
        (PSUIGetIconInfo.hIcon = MergeIcon(_OI_HINST(pItem),
                                           GETSELICONID(pItem),
                                           MK_INTICONID(0, 0),
                                           (UINT)PSUIGetIconInfo.cxIcon,
                                           (UINT)PSUIGetIconInfo.cyIcon))) {

        UNLOCK_CPSUI_HANDLETABLE();

    } else {

        UNLOCK_CPSUI_HANDLETABLE();

        CallpfnPSUI(pPage,
                    PROPSHEETUI_REASON_GET_ICON,
                    (LPARAM)&PSUIGetIconInfo);
    }

    return(PSUIGetIconInfo.hIcon);

}



LONG_PTR
pfnSetResult(
    HANDLE      hPage,
    ULONG_PTR   Result
    )

/*++

Routine Description:

    This function set the result to the pPage's parent page which has
    CPF_PFNPROPSHEETUI bit set


Arguments:




Return Value:




Author:

    04-Feb-1996 Sun 00:48:40 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCPSUIPAGE      pPage;
    PCPSUIPAGE      pParent;
    SETRESULT_INFO  SRInfo;


    if (!(pPage = HANDLETABLE_GetCPSUIPage(hPage))) {

        CPSUIERR(("pfnSetResult(): Invalid hPage=%08lx", hPage));
        return(-1);
    }

    SRInfo.cbSize    = sizeof(SRInfo);
    SRInfo.wReserved = 0;
    SRInfo.Result    = Result;
    Result           = 0;

    //
    // Finding its Parent first
    //

    HANDLETABLE_UnGetCPSUIPage(pPage);

    LOCK_CPSUI_HANDLETABLE();

    while ((pPage) && (pParent = pPage->pParent)) {

        if (pParent->Flags & CPF_PFNPROPSHEETUI) {

            BOOL    bRet;


            SRInfo.hSetResult = pPage->hCPSUIPage;

            ++Result;

            //
            // We did not unlock the handletable, so if called switch to other
            // thread and callback here then dead lock will occurred
            //

            bRet = (BOOL)(CallpfnPSUI(pParent,
                                      PROPSHEETUI_REASON_SET_RESULT,
                                      (LPARAM)&SRInfo) <= 0);

            if (bRet) {

                break;
            }
        }

        pPage = pParent;
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(Result);
}




LONG_PTR
SethStartPage(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pPage,
    LONG        Index
    )

/*++

Routine Description:

    This function find the index (lParam) page from the pPage

Arguments:




Return Value:




Author:

    06-Feb-1996 Tue 05:33:11 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    Result;


    if (!pPage) {

        CPSUIERR(("SethStartPage(NULL): Invalid Page to set"));
        return(0);

    } else if (pRootPage->Flags & CPF_DONE_PROPSHEET) {

        CPSUIERR(("*Cannot Set StartPage now, Flags=%08lx*", pRootPage->Flags));

        return(0);
    }

    if (pPage->Flags & CPF_PARENT) {

        Result = Index;

        if (pPage->Flags & CPF_COMPROPSHEETUI) {

            switch (Result) {

            case SSP_TVPAGE:

                if ((Result = pPage->CPSUIInfo.TVPageIdx) == PAGEIDX_NONE) {

                    Result = pPage->CPSUIInfo.StdPageIdx1;
                }

                break;

            case SSP_STDPAGE1:

                Result = pPage->CPSUIInfo.StdPageIdx1;
                break;

            case SSP_STDPAGE2:

                Result = pPage->CPSUIInfo.StdPageIdx2;
                break;

            default:

                break;
            }
        }

        if (Result >= 0) {

            pPage = pPage->pChild;

            while ((pPage) && (Result--) && (pPage->pNext)) {

                pPage = pPage->pNext;
            }

        } else {

            Result = 0;
        }

    } else {

        Result = -1;
    }

    CPSUIDBG(DBG_SETHSTARTPAGE, ("SethStartPage: Result=%ld, pPage=%08lx",
                        (LONG)Result, pPage));

    if ((Result == -1) && (pPage)) {

        pRootPage->RootInfo.pStartPage = pPage;
        Result                         = 1;

        if ((pRootPage->Flags & CPF_SHOW_PROPSHEET) &&
            (pRootPage->RootInfo.hDlg)) {

            PropSheet_SetCurSel(pRootPage->RootInfo.hDlg,
                                pPage->hPage,
                                0);
        }

    } else {

        Result = 0;
        CPSUIERR(("SethStartPage: INVALID Index=%ld for pPage=%08lx",
                                Index, pPage));
    }

    return(Result);
}




BOOL
CALLBACK
SetPageProcInfo(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pCPSUIPage,
    LPARAM      lParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    29-Jan-1996 Mon 16:28:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pPageProcInfo   ((PPAGEPROCINFO)lParam)

    if ((!(pCPSUIPage->Flags & CPF_PARENT)) &&
        (pCPSUIPage->hPage)) {

        PTABTABLE   pTabTable;
        WORD        i;

        if ((i = pPageProcInfo->iPage) < pPageProcInfo->cPage) {

            if (pPageProcInfo->phPage) {

                pPageProcInfo->phPage[i] = pCPSUIPage->hPage;
            }

            if (pPageProcInfo->pHandle) {

                pPageProcInfo->pHandle[i] = pCPSUIPage->hCPSUIPage;
            }

            if (pTabTable = pPageProcInfo->pTabTable) {

                pTabTable->cTab++;
                pTabTable->TabInfo[i].hDlg      = NULL;
                pTabTable->TabInfo[i].OrgInsIdx = i;
                pTabTable->TabInfo[i].HandleIdx =
                                        HANDLE_2_IDX(pCPSUIPage->hCPSUIPage);
            }

            pPageProcInfo->iPage++;

        } else {

            return(FALSE);
        }
    }

    return(TRUE);

#undef pPageProcInfo
}




BOOL
CALLBACK
SetInsPageIdxProc(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pCPSUIPage,
    LPARAM      lParam
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    14-Feb-1996 Wed 23:07:51 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PINSPAGEIDXINFO pInsPageIdxInfo = (PINSPAGEIDXINFO)lParam;

    if (pCPSUIPage->Flags & CPF_ROOT) {

        pInsPageIdxInfo->pTabTable->InsIdx = 0;

    } else if ((!(pCPSUIPage->Flags & CPF_PARENT)) &&
               (pCPSUIPage->hPage)) {

        if (pInsPageIdxInfo->pCPSUIPage == pCPSUIPage) {

            pInsPageIdxInfo->pCPSUIPage = NULL;
            return(FALSE);

        } else {

            ++(pInsPageIdxInfo->pTabTable->InsIdx);
        }
    }

    return(TRUE);
}



BOOL
CALLBACK
DeleteCPSUIPageProc(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pCPSUIPage,
    LPARAM      lParam
    )

/*++

Routine Description:

    This function is the enumeration proc for each of page need to be deleted


Arguments:

    pCPSUIPage  - Pointer to the page currently enumerated and need to be
                  deleted.

    lParam      - Pointer to the DWORD to be accumerate the total property
                  sheet pages deleted.


Return Value:

    BOOLEAN


Author:

    29-Dec-1995 Fri 13:43:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    DWORD   dw;

    //
    // Delete the Page, link sibling prev/next together
    //

    if (pCPSUIPage->pNext) {

        pCPSUIPage->pNext->pPrev = pCPSUIPage->pPrev;
    }

    if (pCPSUIPage->pPrev) {

        pCPSUIPage->pPrev->pNext = pCPSUIPage->pNext;
    }

    CPSUIDBG(DBG_DEL_PROC,
            ("DeleteCPSUIPage: Delete pCPSUIPage=%08lx, hCPSUIPage=%08lx, cPage=%ld",
            pCPSUIPage, pCPSUIPage->hCPSUIPage, pRootPage->RootInfo.cPage));

    if ((pCPSUIPage->pParent) &&
        (pCPSUIPage->pParent->pChild == pCPSUIPage)) {

        //
        // We are deleting the first child of the parent, set the next sibling
        // to be its first child.
        //

        CPSUIDBG(DBG_DEL_PROC, ("DeleteCPSUIPage: Delete First child, link head"));

        CPSUIASSERT(0, "DeleteCPSUIPageProc: First Child (%08lx) has pPrev",
                                        pCPSUIPage->pPrev == NULL, pCPSUIPage);

        pCPSUIPage->pParent->pChild = pCPSUIPage->pNext;
    }

    CPSUIASSERT(0, "DeleteCPSUIPageProc: Parent (%08lx) still has children",
                ((pCPSUIPage->Flags & CPF_PARENT) == 0)  ||
                 (pCPSUIPage->pChild == NULL), pCPSUIPage);


    if (pCPSUIPage->Flags & CPF_PARENT) {

        //
        // Clean up the COMPROPSHEETUI stuff if PTVWND exists
        //

        if (pCPSUIPage->Flags & CPF_PFNPROPSHEETUI) {

            CPSUIDBG(DBG_DEL_PROC,
                    ("DeleteCPSUIPage: Destroy CPF_PFNPROPSHEETUI=%08lx",
                    pCPSUIPage));

            CallpfnPSUI(pCPSUIPage,
                        PROPSHEETUI_REASON_DESTROY,
                        (LPARAM)(pRootPage->Flags & CPF_DONE_PROPSHEET));

            if ((pCPSUIPage->Flags & CPF_DLL) &&
                (pCPSUIPage->pfnInfo.hInst)) {

                CPSUIDBG(DBG_DEL_PROC, ("DeleteProc(%08lx): FreeLibrary(%08lx)",
                                    pCPSUIPage, pCPSUIPage->pfnInfo.hInst));

                FreeLibrary(pCPSUIPage->pfnInfo.hInst);
            }

        } else if ((pCPSUIPage->Flags & CPF_COMPROPSHEETUI) &&
                   (pCPSUIPage->CPSUIInfo.pTVWnd)) {

            CPSUIDBG(DBG_DEL_PROC,
                    ("DeleteCPSUIPage: CPF_CPSUI=%08lx, CleanUp/Free pTVWnd=%08lx",
                        pCPSUIPage->CPSUIInfo.pTVWnd));

            CleanUpTVWND(pCPSUIPage->CPSUIInfo.pTVWnd);
            LocalFree((HLOCAL)pCPSUIPage->CPSUIInfo.pTVWnd);
        }

    } else {

        //
        // Do any end processing needed for this page
        //

        if (pCPSUIPage->hPage) {

            if (!(pRootPage->Flags & CPF_DONE_PROPSHEET)) {

                if (pRootPage->RootInfo.hDlg) {

                    //
                    // The Property sheet already displayed
                    //

                    CPSUIDBG(DBG_DEL_PROC,
                        ("DeleteCPSUIPage: REMOVE hPage=%08lx", pCPSUIPage->hPage));

                    PropSheet_RemovePage(pRootPage->RootInfo.hDlg,
                                         0,
                                         pCPSUIPage->hPage);

                } else {

                    CPSUIDBG(DBG_DEL_PROC,
                        ("DeleteCPSUIPage: DESTROY hPage=%08lx", pCPSUIPage->hPage));

                    DestroyPropertySheetPage(pCPSUIPage->hPage);
                }
            }

            pRootPage->RootInfo.cPage--;

            if (lParam) {

                ++(*(LPDWORD)lParam);
            }

        } else if (!(pCPSUIPage->Flags & CPF_CALL_TV_DIRECT)) {

            CPSUIWARN(("DeleteCPSUIPageProc: CHILD (%08lx) but hPage=NULL",
                                                                pCPSUIPage));
        }

        CPSUIDBG(DBG_DEL_PROC, ("DeleteCPSUIPage: Delete pCPSUIPage, cPage=%ld",
                                    pRootPage->RootInfo.cPage));
    }

    //
    // Remove it from the handle table
    //

    if (HANDLETABLE_DeleteHandle(pCPSUIPage->hCPSUIPage)) {

        if ((pCPSUIPage != pRootPage)   &&
            (pRootPage->RootInfo.pStartPage == pCPSUIPage)) {

            pRootPage->RootInfo.pStartPage = NULL;
        }
    }

    return(TRUE);
}



PCPSUIPAGE
AddCPSUIPage(
    PCPSUIPAGE  pParent,
    HANDLE      hInsert,
    BYTE        Mode
    )

/*++

Routine Description:

    This function add a new CPSUIPAGE to the pParent page.  If pParent is NULL
    then it create ROOT page.   The new page always added as last child of the
    pParent.


Arguments:

    pParent     - Pointer to the CPSUIPAGE which will be new child's parent

    hInsert     - Handle to the children page will insert at. The meaning of
                  hInsert depends on the Mode passed.   if pParent is NULL
                  then hInsert is ignored

    Mode        - Mode of insertion, it can be one of the following

                    INSPSUIPAGE_MODE_BEFORE

                        Insert pages before the common property sheet page
                        handle specified by hInsert


                    INSPSUIPAGE_MODE_AFTER

                        Insert pages after the common property sheet page
                        handle specified by hInsert


                    INSPSUIPAGE_MODE_FIRST_CHILD

                        Insert pages as the first child of hComPropSheet
                        parent handle.


                    INSPSUIPAGE_MODE_LAST_CHILD

                        Insert pages as the last child of hComPropSheet
                        parent handle.


                    INSPSUIPAGE_MODE_INDEX

                        Insert pages as a zero base child index of its
                        parent handle specified by hComPropSheet.

                        The hInsert is the zero based index special handle
                        that must generated by HINSPSUIPAGE_INDEX(Index)
                        macro.

Return Value:

    PCPSUIPAGE, if function sucessful, when this function sucessed, it also
    return the hChild handle in hCPSUIPage field.  It return NULL if this
    function failed.

Author:

    02-Jan-1996 Tue 13:49:34 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HANDLE      hChild;
    PCPSUIPAGE  pChild;


    if (!(pChild = (PCPSUIPAGE)LocalAlloc(LPTR, sizeof(CPSUIPAGE)))) {

        CPSUIERR(("AddCPSUIPage: LocalAlloc(CPSUIPAGE) failed"));
        return(NULL);
    }

    LOCK_CPSUI_HANDLETABLE();

    if (hChild = HANDLETABLE_AddCPSUIPage(pChild)) {

        pChild->ID         = CPSUIPAGE_ID;
        pChild->hCPSUIPage = hChild;
        pChild->hActCtx    = INVALID_HANDLE_VALUE;
        pChild->pParent    = pParent;

        if (pParent) {

            PCPSUIPAGE  pCurPage;
            BOOL        Ok = FALSE;

            //
            // Either insert first, or this is the first child
            //

            if ((!(pCurPage = pParent->pChild))         ||
                (Mode == INSPSUIPAGE_MODE_FIRST_CHILD)  ||
                ((Mode == INSPSUIPAGE_MODE_INDEX)   &&
                 (!HINSPSUIPAGE_2_IDX(hInsert)))) {

                //
                // Insert as first child, link to the first one first
                //
                //

                if (pChild->pNext = pCurPage) {

                    pCurPage->pPrev = pChild;
                }

                pParent->pChild = pChild;
                Ok              = TRUE;

            } else {

                PCPSUIPAGE  pNext;
                UINT        i = 0xFFFF;


                switch (Mode) {

                case INSPSUIPAGE_MODE_INDEX:

                    i = HINSPSUIPAGE_2_IDX(hInsert);

                case INSPSUIPAGE_MODE_LAST_CHILD:

                    while ((i--) && (pCurPage)) {

                        if ((!i) || (!(pCurPage->pNext))) {

                            Ok = TRUE;
                            break;
                        }

                        pCurPage = pCurPage->pNext;
                    }

                    break;

                case INSPSUIPAGE_MODE_BEFORE:

                    while (pCurPage) {

                        if ((pNext = pCurPage->pNext)   &&
                            (pNext->hCPSUIPage == hInsert)) {

                            Ok = TRUE;
                            break;
                        }

                        pCurPage = pNext;
                    }

                    break;

                case INSPSUIPAGE_MODE_AFTER:

                    while (pCurPage) {

                        if (pCurPage->hCPSUIPage == hInsert) {

                            Ok = TRUE;
                            break;
                        }

                        pCurPage = pCurPage->pNext;
                    }

                    break;

                default:

                    CPSUIERR(("Invalid inseert Mode = %u passed", Mode));
                    break;
                }

                if (Ok) {

                    pChild->pPrev = pCurPage;

                    if (pChild->pNext = pCurPage->pNext) {

                        pCurPage->pNext->pPrev = pChild;
                    }

                    pCurPage->pNext = pChild;

                } else {

                    //
                    // We never insert after
                    //

                    CPSUIERR(("AddCPSUIPage: Cannot Insert Page: Mode=%ld, hInsert=%08lx, pParent=%08lx",
                                Mode, hInsert, pParent));

                    HANDLETABLE_UnGetCPSUIPage(pChild);
                    HANDLETABLE_DeleteHandle(hChild);
                    pChild = NULL;
                }
            }

        } else {

            //
            // This is the ROOT page
            //

            CPSUIDBG(DBG_ADD_CPSUIPAGE,
                     ("AddCPSUIPage: Add %08lx as ROOT PAGE", pChild));

            pChild->Flags |= (CPF_ROOT | CPF_PARENT);
        }

    } else {

        CPSUIERR(("AddCPSUIPage: HANDLETABLE_AddCPSUIPage(pChild=%08lx) failed",
                    pChild));

        LocalFree((HLOCAL)pChild);
        pChild = NULL;
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(pChild);
}




BOOL
AddPropSheetPage(
    PCPSUIPAGE      pRootPage,
    PCPSUIPAGE      pCPSUIPage,
    LPPROPSHEETPAGE pPSPage,
    HPROPSHEETPAGE  hPSPage
    )

/*++

Routine Description:

    Add this PROPSHEETPAGE page to the property sheet dialog box and associate
    with the pCPSUIPage


Arguments:

    pRootPage   - Pointer to the root page of CPSUIPAGE which this data
                  instance is associated with.

    pCPSUIPage  - Pointer to the CPSUIPAGE which the pPropSheetPage will
                  be associated with.

    pPSPage     - Pointer to the PROPSHEETPAGE data structure of the page to
                  be added, if this is NULL then hPSPage will be used

    hPSPage     - Handle to PROPSHEETPAGE created by the caller to be added


Return Value:




Author:

    03-Jan-1996 Wed 13:28:31 created  -by-  Daniel Chou (danielc)


Revision History:

    17-Dec-1997 Wed 16:21:52 updated  -by-  Daniel Chou (danielc)
        Unlock the handle table when we display the direct treeview page, this
        is done because when handle table is locked, any other thread in the
        current process cannot display anymore cpsui pages.


--*/

{
    PROPSHEETPAGE psp;
    HANDLE  hActCtx = INVALID_HANDLE_VALUE;
    BOOL    Ok = TRUE;


    LOCK_CPSUI_HANDLETABLE();

    if (pRootPage->RootInfo.cPage >= MAXPROPPAGES) {

        CPSUIASSERT(0, "AddPropSheetPage: Too many pages=%08lx", FALSE,
                                            pRootPage->RootInfo.cPage);
        Ok = FALSE;

    } else if (pPSPage) {

        LPBYTE          pData;
        PPSPINFO        pPSPInfo;
        DWORD           dwSize;

        //
        // Create a local copy of the PROPSHEETPAGE and add in our own PSPINFO
        // at end of the structure.
        //

        dwSize = pPSPage->dwSize;

        if (pData = (LPBYTE)LocalAlloc(LPTR, dwSize + sizeof(PSPINFO))) {

            CopyMemory(pData, pPSPage, dwSize);

            pPSPage                       = (LPPROPSHEETPAGE)pData;
            pPSPInfo                      = (PPSPINFO)(pData + dwSize);

            pPSPInfo->cbSize              = sizeof(PSPINFO);
            pPSPInfo->wReserved           = 0;
            pPSPInfo->hComPropSheet       = pCPSUIPage->pParent->hCPSUIPage;
            pPSPInfo->hCPSUIPage          = pCPSUIPage->hCPSUIPage;
            pPSPInfo->pfnComPropSheet     = CPSUICallBack;

            CPSUIDBG(DBG_PAGEDLGPROC,
                     ("AddPropSheetPage: pCPSUIPage=%08lx, DlgProc=%08lx,  lParam=%08lx, pspCB=%08lx, Size=%ld",
                     pCPSUIPage, pPSPage->pfnDlgProc,
                     pPSPage->lParam, pPSPage->pfnCallback, pPSPage->dwSize));

            pCPSUIPage->hPageInfo.DlgProc = pPSPage->pfnDlgProc;
            pCPSUIPage->hPageInfo.lParam  = pPSPage->lParam;
            pCPSUIPage->hPageInfo.pspCB   = pPSPage->pfnCallback;
            pCPSUIPage->hPageInfo.dwSize  = dwSize;
            pPSPage->pfnCallback          = CPSUIPSPCallBack;
            pPSPage->pfnDlgProc           = CPSUIPageDlgProc;
            pPSPage->lParam               = (LPARAM)pCPSUIPage;
            pPSPage->dwSize               = dwSize + sizeof(PSPINFO);

            if (pCPSUIPage->Flags & CPF_CALL_TV_DIRECT) {

                CPSUIDBG(DBG_ADD_PSPAGE,
                         ("AddPropSheetPage(CPF_CALL_TV_DIRECT): cPage=%ld",
                            pRootPage->RootInfo.cPage));

                //
                // We will

                UNLOCK_CPSUI_HANDLETABLE();

                if (DialogBoxParam(hInstDLL,
                                   pPSPage->pszTemplate,
                                   pRootPage->RootInfo.hDlg,
                                   CPSUIPageDlgProc,
                                   (LPARAM)pPSPage) == -1) {

                    CPSUIERR(("DialogBoxParam(CALL_TV_DIRECT), hDlg=%08lx, Template=%08lx, FAILED",
                              pRootPage->RootInfo.hDlg, pPSPage->pszTemplate));
                }

                LocalFree(pData);
                return(FALSE);

            } else {

                CPSUIDBG(DBG_ADD_PSPAGE, ("AddPropSheetPage: Add PROPSHEETPAGE=%08lx",
                                pPSPage));

                if (pPSPage->dwSize <= PROPSHEETPAGE_V2_SIZE) {

                    //
                    // the passed in PROPSHEETPAGE structure is version 2 or less
                    // which means it doesn't have fusion activation context at all
                    // let's thunk to the latest version (V3) so we can provide
                    // proper activation context.
                    //
                    ZeroMemory(&psp, sizeof(psp));

                    // first copy the data from the passed in page
                    CopyMemory(&psp, pPSPage, pPSPage->dwSize);

                    // set the new size (V3) and set pPSPage to point to psp
                    psp.dwSize = sizeof(psp);
                    pPSPage = &psp;
                }

                if (0 == (pPSPage->dwFlags & PSP_USEFUSIONCONTEXT)) {

                    if ((ULONG)(ULONG_PTR)pPSPage->pszTemplate >= DP_STD_RESERVED_START && 
                        (ULONG)(ULONG_PTR)pPSPage->pszTemplate <= DP_STD_TREEVIEWPAGE) {

                        // if the page is standard page or treeview page, we'll force to context 
                        // to V6
                        pPSPage->dwFlags |= PSP_USEFUSIONCONTEXT;
                        pPSPage->hActCtx = g_hActCtx;

                    } else if (GetPageActivationContext(pCPSUIPage, &hActCtx)) {

                        // if the caller did not provide an activation context explicitly
                        // then we set the activation context from the compstui handle (if any)
                        // by climbing up the hierarchy until we find a page with a proper 
                        // activation context set.

                        pPSPage->dwFlags |= PSP_USEFUSIONCONTEXT;
                        pPSPage->hActCtx = hActCtx;
                    }
                }

                if (pCPSUIPage->Flags & CPF_ANSI_CALL) {

                    hPSPage = SHNoFusionCreatePropertySheetPageA((LPPROPSHEETPAGEA)pPSPage);

                } else {

                    hPSPage = SHNoFusionCreatePropertySheetPageW(pPSPage);
                }

                if (!hPSPage) {

                    CPSUIASSERT(0, "AddPropSheetPage: CreatePropertySheetPage(%08lx) failed",
                                FALSE, pPSPage);
                    Ok = FALSE;
                }
            }

            LocalFree((HLOCAL)pData);

        } else {

            Ok = FALSE;

            CPSUIASSERT(0, "AddPropSheetPage: Allocate %08lx bytes failed",
                        FALSE, ULongToPtr(pPSPage->dwSize));
        }

    } else if (hPSPage) {

        CPSUIDBG(DBG_ADD_PSPAGE, ("AddPropSheetPage: Add *HPROPSHEETPAGE*=%08lx",
                            hPSPage));

        pCPSUIPage->Flags |= CPF_CALLER_HPSPAGE;

    } else {

        Ok = FALSE;

        CPSUIASSERT(0, "AddPropSheetPage: hPSPage = NULL", FALSE, 0);
    }

    if (Ok) {

        pCPSUIPage->hPage = hPSPage;

        if (pRootPage->RootInfo.hDlg) {

            INSPAGEIDXINFO  InsPageIdxInfo;

            //
            // The property sheet already displayed
            //

            if (InsPageIdxInfo.pTabTable = pRootPage->RootInfo.pTabTable) {

                InsPageIdxInfo.pCPSUIPage = pCPSUIPage;

                EnumCPSUIPagesSeq(pRootPage,
                                  pRootPage,
                                  SetInsPageIdxProc,
                                  (LPARAM)&InsPageIdxInfo);
            }

            CPSUIDBG(DBG_ADD_PSPAGE,
                     ("AddPropSheetPage: PropSheet_AddPage(%08lx) INSERT Index=%u / %u",
                            hPSPage, (UINT)InsPageIdxInfo.pTabTable->InsIdx,
                            (UINT)pRootPage->RootInfo.cPage));

            InsPageIdxInfo.pTabTable->HandleIdx =
                                        HANDLE_2_IDX(pCPSUIPage->hCPSUIPage);

            if (!PropSheet_AddPage(pRootPage->RootInfo.hDlg, hPSPage)) {

                Ok = FALSE;

                CPSUIASSERT(0, "AddPropSheetPage: PropSheet_AddPage(%08lx) failed",
                            FALSE, hPSPage);
            }
        }
    }

    if (Ok) {

        pRootPage->RootInfo.cPage++;

        CPSUIDBG(DBG_ADD_PSPAGE, ("AddPropSheetPage: cPage=%ld",
                            pRootPage->RootInfo.cPage));

    } else {

        CPSUIERR(("AddPropSheetPage: FAILED"));

        if (pCPSUIPage->hPage) {

            DestroyPropertySheetPage(pCPSUIPage->hPage);
            pCPSUIPage->hPage = NULL;
        }
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(Ok);
}




LONG
AddComPropSheetPage(
    PCPSUIPAGE  pCPSUIPage,
    UINT        PageIdx
    )

/*++

Routine Description:

    This function add the common property sheet UI standard pages to the
    hParent Page passed.

Arguments:

    pCPSUIPage  - pointer to the parent page which child will be added for the
                  common UI

    PageIdx     - Page index to be added. (zero based)


Return Value:

    LONG result, if <= 0 then error occurred, > 0 if sucessful


Author:

    24-Jan-1996 Wed 17:58:15 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTVWND          pTVWnd;
    PMYDLGPAGE      pCurMyDP;
    PROPSHEETPAGE   psp;
    LONG            Result;
    WORD            DlgTemplateID;
    WCHAR           Buf[MAX_RES_STR_CHARS];


    pTVWnd            = pCPSUIPage->CPSUIInfo.pTVWnd;
    pCurMyDP          = pTVWnd->pMyDlgPage + PageIdx;
    pCurMyDP->pTVWnd  = (LPVOID)pTVWnd;
    pCurMyDP->PageIdx = (BYTE)PageIdx;

    //
    // Set default User data for the callback
    //

    pCurMyDP->CPSUIUserData = pTVWnd->pCPSUI->UserData;

    if (pCurMyDP->DlgPage.cbSize != sizeof(DLGPAGE)) {

        return(ERR_CPSUI_INVALID_DLGPAGE_CBSIZE);
    }

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = 0;

    //
    // psp.dwFlags     = (pTVWnd->Flags & TWF_HAS_HELPFILE) ? PSP_HASHELP : 0;
    //

    psp.lParam = (LPARAM)pCurMyDP;

    if (pCurMyDP->DlgPage.Flags & DPF_USE_HDLGTEMPLATE) {

        psp.pResource  = pCurMyDP->DlgPage.hDlgTemplate;
        psp.dwFlags   |= PSP_DLGINDIRECT;
        DlgTemplateID  = 0;

    } else {

        DlgTemplateID   = pCurMyDP->DlgPage.DlgTemplateID;
        psp.pszTemplate = MAKEINTRESOURCE(DlgTemplateID);
    }

    psp.pfnDlgProc  = PropPageProc;
    psp.hInstance   = hInstDLL;

    switch (DlgTemplateID) {

    case DP_STD_INT_TVPAGE:
    case DP_STD_TREEVIEWPAGE:

        CPSUIDBG(DBG_ADDCOMPAGE, ("AddComPropSheetPage: Add TVPage"));

        if (pTVWnd->TVPageIdx == PAGEIDX_NONE) {

            pCPSUIPage->CPSUIInfo.TVPageIdx = (LONG)PageIdx;
            pTVWnd->TVPageIdx               = (BYTE)PageIdx;
            psp.pfnDlgProc                  = TreeViewProc;

        } else {

            return(ERR_CPSUI_MORE_THAN_ONE_TVPAGE);
        }

        break;

    case DP_STD_DOCPROPPAGE1:

        CPSUIDBG(DBG_ADDCOMPAGE, ("AddComPropSheetPage: Add StdPage 1"));

        if (pTVWnd->cDMPub > 0) {

            if (pTVWnd->StdPageIdx1 == PAGEIDX_NONE) {

                pCPSUIPage->CPSUIInfo.StdPageIdx1 = (LONG)PageIdx;
                pTVWnd->StdPageIdx1               = (BYTE)PageIdx;

            } else {

                return(ERR_CPSUI_MORE_THAN_ONE_STDPAGE);
            }

        } else {

            //
            // This page got nothing
            //

            return(0);
        }

        break;


    case DP_STD_DOCPROPPAGE2:

        CPSUIDBG(DBG_ADDCOMPAGE, ("AddComPropSheetPage: Add StdPage 2"));

        if (pTVWnd->cDMPub > 0) {

            if (pTVWnd->StdPageIdx2 == PAGEIDX_NONE) {

                pCPSUIPage->CPSUIInfo.StdPageIdx2= (LONG)PageIdx;
                pTVWnd->StdPageIdx2              = (BYTE)PageIdx;

            } else {

                return(ERR_CPSUI_MORE_THAN_ONE_STDPAGE);
            }

        } else {

            //
            // This page got nothing
            //

            return(0);
        }

        break;


    default:

        psp.hInstance = pTVWnd->hInstCaller;
        break;
    }

    //
    // If we have error counting the page items or the page got not item then
    // return it now
    //

    if ((Result = CountPropPageItems(pTVWnd, (BYTE)PageIdx)) <= 0) {

        return(Result);
    }

    if (pCurMyDP->DlgPage.Flags & DPF_ICONID_AS_HICON) {

        psp.dwFlags |= PSP_USEHICON;
        psp.hIcon    = (HICON)pCurMyDP->DlgPage.IconID;

    } else if (psp.hIcon = GETICON16(pTVWnd->hInstCaller,
                                     pCurMyDP->DlgPage.IconID)) {

        psp.dwFlags     |= PSP_USEHICON;
        pCurMyDP->hIcon  = psp.hIcon;
    }

    Buf[0] = L'\0';

    if (pCPSUIPage->Flags & CPF_CALL_TV_DIRECT) {

        ComposeStrData(pTVWnd->hInstCaller,
                       (WORD)(GBF_PREFIX_OK        |
                              GBF_INT_NO_PREFIX    |
                              ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                       GBF_ANSI_CALL : 0)),
                       Buf,
                       COUNT_ARRAY(Buf),
                       IDS_INT_CPSUI_ADVDOCOPTION,
                       pTVWnd->ComPropSheetUI.pOptItemName,
                       0,
                       0);

    } else {

        GetStringBuffer(pTVWnd->hInstCaller,
                        (WORD)(GBF_PREFIX_OK        |
                               GBF_INT_NO_PREFIX    |
                               ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                        GBF_ANSI_CALL : 0)),
                        L'\0',
                        pCurMyDP->DlgPage.pTabName,
                        Buf,
                        COUNT_ARRAY(Buf));
    }

    if (Buf[0] != L'\0') {

        psp.pszTitle = (LPTSTR)Buf;
        psp.dwFlags |= PSP_USETITLE;
    }

    //
    // Internally we always translate to the UNICODE
    //

    if (CPSUICallBack(pCPSUIPage->hCPSUIPage,
                      CPSFUNC_ADD_PROPSHEETPAGEW,
                      (LPARAM)&psp,
                      (LPARAM)0L)) {

        return(1);

    } else {

        switch (DlgTemplateID) {

        case DP_STD_INT_TVPAGE:
        case DP_STD_TREEVIEWPAGE:

            pCPSUIPage->CPSUIInfo.TVPageIdx = PAGEIDX_NONE;
            pTVWnd->TVPageIdx               = PAGEIDX_NONE;

            break;

        case DP_STD_DOCPROPPAGE1:

            pCPSUIPage->CPSUIInfo.StdPageIdx1 = PAGEIDX_NONE;
            pTVWnd->StdPageIdx1               = PAGEIDX_NONE;

            break;


        case DP_STD_DOCPROPPAGE2:

            pCPSUIPage->CPSUIInfo.StdPageIdx2 = PAGEIDX_NONE;
            pTVWnd->StdPageIdx2               = PAGEIDX_NONE;

            break;
        }

        if (!(pCPSUIPage->Flags & CPF_CALL_TV_DIRECT)) {

            CPSUIERR(("AddComPropSheetPage() FAILED, IdxPage=%ld", PageIdx));
        }

        return(ERR_CPSUI_CREATEPROPPAGE_FAILED);
    }
}




LONG
AddComPropSheetUI(
    PCPSUIPAGE      pRootPage,
    PCPSUIPAGE      pCPSUIPage,
    PCOMPROPSHEETUI pCPSUI
    )

/*++

Routine Description:

    This is the main entry point to the common UI


Arguments:

    pRootPage   - Pointer to the CPSUIPAGE data structure of ROOT

    pCPSUIPage  - Pointer to the CPSUIPAGE which represent the hCPSUIPage

    pCPSUI      - Pointer to the COMPROPSHEETUI data structure to specified
                  how to add common UI pages.


Return Value:

    LONG

    <=0: Error occurred (Error Code of ERR_CPSUI_xxxx)
     >0: Total Pages added


Author:

    24-Jan-1996 Wed 16:54:30 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTVWND  pTVWnd = NULL;
    UINT    cPage = 0;
    LONG    Result = 0;
    DWORD   DMPubHideBits;
    DWORD   CPF_FlagsOr;


    if ((!pCPSUI) ||
        (pCPSUI->cbSize < sizeof(COMPROPSHEETUI))) {

        Result = ERR_CPSUI_INVALID_PDATA;

    } else if (!pCPSUI->hInstCaller) {

        Result = ERR_CPSUI_NULL_HINST;

    } else if (!pCPSUI->cOptItem) {

        Result = ERR_CPSUI_ZERO_OPTITEM;

    } else if (!pCPSUI->pOptItem) {

        Result = ERR_CPSUI_NULL_POPTITEM;

    } else if (!(pTVWnd = (PTVWND)LocalAlloc(LPTR,
                                             sizeof(TVWND) + sizeof(OIDATA) *
                                                        pCPSUI->cOptItem))) {

        Result = ERR_CPSUI_ALLOCMEM_FAILED;

    } else {

        if (pCPSUIPage->Flags & CPF_ANSI_CALL) {

            pTVWnd->Flags |= TWF_ANSI_CALL;
        }

        if (pCPSUI->Flags & CPSUIF_UPDATE_PERMISSION) {

            pTVWnd->Flags |= TWF_CAN_UPDATE;
        }

        //
        // Now convert the pCPSUI to the local buffer
        //

        Result = GetCurCPSUI(pTVWnd, (POIDATA)(pTVWnd + 1), pCPSUI);

        pTVWnd->pCPSUI        = pCPSUI;
        pCPSUI                = &(pTVWnd->ComPropSheetUI);
        pTVWnd->hCPSUIPage    = pCPSUIPage->hCPSUIPage;
        pTVWnd->pRootFlags    = (LPDWORD)&(pRootPage->Flags);
        pTVWnd->hInstCaller   = pCPSUI->hInstCaller;
        pTVWnd->pLastItem     = pCPSUI->pOptItem + pCPSUI->cOptItem - 1;
        pTVWnd->ActiveDlgPage =
        pTVWnd->TVPageIdx     =
        pTVWnd->StdPageIdx1   =
        pTVWnd->StdPageIdx2   = PAGEIDX_NONE;

        if (!pCPSUI->pCallerName) {

            pCPSUI->pCallerName = (LPTSTR)IDS_CPSUI_NO_NAME;
        }

        if (!pCPSUI->pOptItemName) {

            pCPSUI->pOptItemName = (LPTSTR)IDS_CPSUI_NO_NAME;
        }

        pCPSUIPage->CPSUIInfo.pTVWnd     = pTVWnd;
        pCPSUIPage->CPSUIInfo.TVPageIdx  = PAGEIDX_NONE;
        pCPSUIPage->CPSUIInfo.StdPageIdx1= PAGEIDX_NONE;
        pCPSUIPage->CPSUIInfo.StdPageIdx2= PAGEIDX_NONE;
    }

    //
    // Remember this one in the page
    //

    DMPubHideBits = pRootPage->RootInfo.DMPubHideBits;

    switch ((ULONG_PTR)pCPSUI->pDlgPage) {

    case (ULONG_PTR)CPSUI_PDLGPAGE_PRINTERPROP:

        CPF_FlagsOr   = CPF_PRINTERPROP;
        DMPubHideBits = 0;
        break;

    case (ULONG_PTR)CPSUI_PDLGPAGE_DOCPROP:

        CPF_FlagsOr = CPF_DOCPROP;
        break;

    case (ULONG_PTR)CPSUI_PDLGPAGE_ADVDOCPROP:

        CPF_FlagsOr = CPF_ADVDOCPROP;
        break;

    default:

        DMPubHideBits =
        CPF_FlagsOr   = 0;
        break;
    }

    if ((Result >= 0)                                                       &&
        ((Result = AddIntOptItem(pTVWnd)) >= 0)                             &&
        ((Result = SetpMyDlgPage(pTVWnd, pRootPage->RootInfo.cPage)) > 0)   &&
        ((Result = ValidatepOptItem(pTVWnd, DMPubHideBits)) >= 0)) {

        UINT    iPage = 0;

        //
        // Go through each page and add them to the property sheet if the
        // page got item
        //

        while ((iPage < (UINT)pTVWnd->cInitMyDlgPage) && (Result >= 0)) {

            if ((Result = AddComPropSheetPage(pCPSUIPage, iPage++)) > 0) {

                ++cPage;
            }
        }

        if ((cPage == 0) && (pTVWnd->Flags & TWF_HAS_ADVANCED_PUSH)) {

            //
            // If the advance is via push button but we did not add any pages
            // then we need to add the advanced page as default
            //

            pTVWnd->Flags &= ~TWF_HAS_ADVANCED_PUSH;
            pTVWnd->Flags |= TWF_ADVDOCPROP;

            if ((Result = AddComPropSheetPage(pCPSUIPage, iPage++)) > 0) {

                ++cPage;
            }

        } else {

            pTVWnd->cInitMyDlgPage = (BYTE)iPage;
        }
    }

    if (Result >= 0) {

        pCPSUIPage->Flags              |= CPF_FlagsOr;
        pRootPage->Flags               |= CPF_FlagsOr | CPF_HAS_CPSUI;
        pRootPage->RootInfo.cCPSUIPage += (WORD)cPage;

        CPSUIDBG(DBG_ADD_CPSUI, ("\nAddComPropSheetUI: TV=%ld, P1=%ld, p2=%ld, pTVWnd->Flags=%08lx, %08lx->RootFlags=%08lx, (%08lx)",
                    pTVWnd->TVPageIdx, pTVWnd->StdPageIdx1,
                    pTVWnd->StdPageIdx2, pTVWnd->Flags,
                    pRootPage, pRootPage->Flags,
                    pCPSUI->pDlgPage));

        return((LONG)cPage);

    } else {

        CPSUIERR(("AddComPropSheetUI() Failed = %ld", Result));
        return(Result);
    }
}




LONG_PTR
InsertPSUIPage(
    PCPSUIPAGE              pRootPage,
    PCPSUIPAGE              pParentPage,
    HANDLE                  hInsert,
    PINSERTPSUIPAGE_INFO    pInsPageInfo,
    BOOL                    AnsiCall
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    14-Feb-1996 Wed 14:03:20 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL                bCtxActivated = FALSE;
    ULONG_PTR           ulCookie = 0;
    HANDLE              hActCtx = INVALID_HANDLE_VALUE;
    WCHAR               wszDLLName[MAX_PATH];
    PCPSUIPAGE          pCPSUIPage;
    INSERTPSUIPAGE_INFO IPInfo;
    LONG                cPage;
    BOOL                Ok = FALSE;
    DWORD               dwErr = ERROR_SUCCESS;


    if (!pInsPageInfo) {

        CPSUIERR(("InsertPSUIPage: Pass a NULL pInsPageInfo"));
        return(0);

    } else if (pInsPageInfo->cbSize < sizeof(INSERTPSUIPAGE_INFO)) {

        CPSUIERR(("InsertPSUIPage: Invalid cbSize=%u in pInsPageInfo",
                                                    pInsPageInfo->cbSize));
        return(0);
    }

    //
    // Make a local copy
    //

    IPInfo = *pInsPageInfo;

    if (IPInfo.Type > MAX_PSUIPAGEINSERT_INDEX) {

        CPSUIERR(("InsertPSUIPage: Invalid Type=%u in pInsPageInfo",
                                            IPInfo.Type));
        return(0);

    } else if ((IPInfo.Type != PSUIPAGEINSERT_GROUP_PARENT) &&
               (IPInfo.dwData1 == 0)) {

        CPSUIERR(("InsertPSUIPage: dwData1 is NULL in pInsPageInfo"));
        return(0);
    }

    CPSUIDBG(DBG_INSPAGE,
             ("InsertPSUIPage: Type=%hs, Mode=%u, hInsert=%08lx, pInsPageInfo=%08lx%hs",
                    pszInsType[IPInfo.Type], IPInfo.Mode, hInsert, pInsPageInfo,
                    (AnsiCall) ? " (ANSI)" : ""));

    if (!(pCPSUIPage = AddCPSUIPage(pParentPage, hInsert, IPInfo.Mode))) {

        CPSUIERR(("InsertPSUIPage: AddCPSUIPage() failed"));
        return(0);
    }

    if (AnsiCall) {

        pCPSUIPage->Flags |= CPF_ANSI_CALL;
    }

    switch (IPInfo.Type) {

    case PSUIPAGEINSERT_GROUP_PARENT:

        //
        // Nothing to do except setting the flags
        //

        Ok                 = TRUE;
        pCPSUIPage->Flags |= CPF_PARENT | CPF_USER_GROUP;
        break;

    case PSUIPAGEINSERT_PCOMPROPSHEETUI:

        pCPSUIPage->Flags |= (CPF_PARENT | CPF_COMPROPSHEETUI);

        //
        // 20-Jul-1996 Sat 07:58:34 updated  -by-  Daniel Chou (danielc)
        //  Set dwData2 to cPage if sucessful, and dwData=ERR_CPSUI_xxx if
        //  failed
        //
        // This are cases that we want to add 0 page, so only negative value 
        // is falure return.
        //

        if ((cPage = AddComPropSheetUI(pRootPage,
                                       pCPSUIPage,
                                       (PCOMPROPSHEETUI)IPInfo.dwData1)) >= 0) {

            Ok = TRUE;
        }

        pInsPageInfo->dwData2 = (ULONG_PTR)cPage;

        break;

    case PSUIPAGEINSERT_DLL:

        pCPSUIPage->Flags |= (CPF_PARENT | CPF_DLL | CPF_PFNPROPSHEETUI);

        if (AnsiCall) {

            CPSUIDBG(DBG_INSPAGE, ("Loading DLL: %hs", IPInfo.dwData1));

        } else {

            CPSUIDBG(DBG_INSPAGE, ("Loading DLL: %ws", IPInfo.dwData1));
        }

        CPSUIDBG(DBG_INSPAGE, ("Get pfnPropSheetU() = %hs", IPInfo.dwData2));

        if (AnsiCall)
        {
            // convert from ANSI to UNICODE
            SHAnsiToUnicode((LPCSTR)IPInfo.dwData1, wszDLLName, ARRAYSIZE(wszDLLName));
        }
        else
        {
            // just copy the UNICODE name into the buffer
            SHUnicodeToUnicode((LPCWSTR)IPInfo.dwData1, wszDLLName, ARRAYSIZE(wszDLLName));
        }

        //
        // this is a third party DLL and we don't know if it is fusion aware
        // or not, so we just try if there is an external manifest file or 
        // a manifest embedded in the resources.
        //
        if (SUCCEEDED(CreateActivationContextFromExecutable(wszDLLName, &hActCtx)))
        {
            // compstui page takes the ownership of the activation context handle.
            pCPSUIPage->hActCtx = hActCtx;

            // activate the context prior loading the DLL and calling into it.
            bCtxActivated = ActivateActCtx(pCPSUIPage->hActCtx, &ulCookie);
        }

        __try {

            if ((pCPSUIPage->pfnInfo.hInst = LoadLibraryW(wszDLLName)) &&
                (IPInfo.dwData2)                                            &&
                (pCPSUIPage->pfnInfo.pfnPSUI = (PFNPROPSHEETUI)
                                    GetProcAddress(pCPSUIPage->pfnInfo.hInst,
                                                   (LPCSTR)IPInfo.dwData2))) {

                pCPSUIPage->pfnInfo.lParamInit  = IPInfo.dwData3;
                pCPSUIPage->pfnInfo.Result      = 0;

                Ok = (BOOL)((CallpfnPSUI(pCPSUIPage,
                                         PROPSHEETUI_REASON_INIT,
                                         (LPARAM)IPInfo.dwData3) > 0) &&
                            (pCPSUIPage->pChild));
            }
        }
        __finally {

            if (bCtxActivated) {

                //
                // we need to deactivate the context, no matter what!
                //
                DeactivateActCtx(0, ulCookie);
            }
        }

        break;

    case PSUIPAGEINSERT_PFNPROPSHEETUI:

        pCPSUIPage->Flags             |= (CPF_PARENT | CPF_PFNPROPSHEETUI);
        pCPSUIPage->pfnInfo.pfnPSUI    = (PFNPROPSHEETUI)IPInfo.dwData1;
        pCPSUIPage->pfnInfo.lParamInit = IPInfo.dwData2;
        pCPSUIPage->pfnInfo.Result     = 0;

        //
        // If this function successful and it got any pages then
        // we returned ok, else failed it.
        //

        Ok = (BOOL)((CallpfnPSUI(pCPSUIPage,
                                 PROPSHEETUI_REASON_INIT,
                                 (LPARAM)IPInfo.dwData2) > 0) &&
                    (pCPSUIPage->pChild));

        break;

    case PSUIPAGEINSERT_PROPSHEETPAGE:

        //
        // This is set only if we are calling Treeview Page with a seperate
        // dialog box, when calling direct with DialogBoxParam() with treeview
        // at return of AddPropSheetPage() the treeview dialog box already
        // done, so there is no need for error
        //

        pCPSUIPage->Flags |= (pParentPage->Flags & CPF_CALL_TV_DIRECT);

        Ok = AddPropSheetPage(pRootPage,
                              pCPSUIPage,
                              (LPPROPSHEETPAGE)IPInfo.dwData1,
                              NULL);
        break;

    case PSUIPAGEINSERT_HPROPSHEETPAGE:

        Ok = AddPropSheetPage(pRootPage,
                              pCPSUIPage,
                              NULL,
                              (HPROPSHEETPAGE)IPInfo.dwData1);
        break;
    }

    if (!Ok) {
        //
        // Save the last error.
        //
        dwErr = GetLastError();
    }

    HANDLETABLE_UnGetCPSUIPage(pCPSUIPage);

    if (Ok) {

        DBG_SHOW_CPSUIPAGE(pRootPage, 0);

        return((ULONG_PTR)pCPSUIPage->hCPSUIPage);

    } else {

        EnumCPSUIPages(pRootPage, pCPSUIPage, DeleteCPSUIPageProc, 0L);

        if (!(pCPSUIPage->Flags & CPF_CALL_TV_DIRECT)) {

            CPSUIERR(("InsertPSUIPage(): Insertion of %hs failed",
                        pszInsType[IPInfo.Type]));
        }

        SetLastError(dwErr);
        return(0);
    }
}



LONG
CALLBACK
IgnorePSNApplyProc(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pCPSUIPage,
    LPARAM      lParam
    )

/*++

Routine Description:

    This function send the APPLYNOW message to the CPSUIPAGE's page


Arguments:




Return Value:

    FALSE   - Apply done by not successful, the callee need more user changes
    TRUE    - Apply done with sucessful

Author:

    17-Nov-1997 Mon 13:38:18 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{

    if (!(pCPSUIPage->Flags & CPF_PARENT)) {

        DWORD   Flags = pCPSUIPage->Flags;

        if (lParam) {

            pCPSUIPage->Flags |= CPF_NO_PSN_APPLY;

        } else {

            pCPSUIPage->Flags &= ~CPF_NO_PSN_APPLY;
        }

        if ((pCPSUIPage->Flags & CPF_ACTIVATED) &&
            (Flags ^ (pCPSUIPage->Flags & CPF_NO_PSN_APPLY))) {

            SetIgnorePSNApplyProc(pCPSUIPage);
        }

        CPSUIDBG(DBG_GET_TABWND,
                    ("IgnorePSNApplyProc(%u): pPage=%08lx, Handle=%08lx",
                    (pCPSUIPage->Flags & CPF_NO_PSN_APPLY) ? 1 : 0,
                    pCPSUIPage, pCPSUIPage->hCPSUIPage));
    }


    return(TRUE);
}




LONG
CALLBACK
ApplyCPSUIProc(
    PCPSUIPAGE  pRootPage,
    PCPSUIPAGE  pCPSUIPage,
    LPARAM      lParam
    )

/*++

Routine Description:

    This function send the APPLYNOW message to the CPSUIPAGE's page


Arguments:




Return Value:

    FALSE   - Apply done by not successful, the callee need more user changes
    TRUE    - Apply done with sucessful

Author:

    17-Nov-1997 Mon 13:38:18 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hDlg;
    DLGPROC DlgProc;


    if ((!(pCPSUIPage->Flags & CPF_PARENT))     &&
        (hDlg = pCPSUIPage->hPageInfo.hDlg)     &&
        (DlgProc = pCPSUIPage->hPageInfo.DlgProc)) {

        PCPSUIPAGE  pParent;
        PTVWND      pTVWnd = NULL;
        PSHNOTIFY   PN;

        PN.hdr.hwndFrom = pRootPage->RootInfo.hDlg;
        PN.hdr.idFrom   = (UINT)GetWindowLongPtr(PN.hdr.hwndFrom, GWLP_ID);
        PN.hdr.code     = PSN_APPLY;
        PN.lParam       = (lParam & APPLYCPSUI_OK_CANCEL_BUTTON) ? 1 : 0;

        CPSUIDBG(DBG_GET_TABWND,
                 ("*ApplyCPSUIProc(PSN_APPLY): Page=%08lx, Handle=%08lx, hDlg=%08lx, DlgPorc=%08lx",
                    pCPSUIPage, pCPSUIPage->hCPSUIPage, hDlg, DlgProc));

        if ((pParent = pCPSUIPage->pParent)                             &&
            ((pParent->Flags & (CPF_PARENT | CPF_COMPROPSHEETUI)) ==
                               (CPF_PARENT | CPF_COMPROPSHEETUI))       &&
            (pTVWnd = pParent->CPSUIInfo.pTVWnd)) {

            if (lParam & APPLYCPSUI_NO_NEWDEF) {

                pTVWnd->Flags |= TWF_APPLY_NO_NEWDEF;

            } else {

                pTVWnd->Flags &= ~TWF_APPLY_NO_NEWDEF;
            }

            CPSUIDBG(DBG_GET_TABWND,
                    ("*    APPLY ComPropSheetUI, pParent=%08lx: APPLY_NO_NEWDEF=%ld",
                    pParent->hCPSUIPage, (pTVWnd->Flags & TWF_APPLY_NO_NEWDEF) ? 1 : 0));
        }

        if (CallWindowProc((WNDPROC)DlgProc,
                           hDlg,
                           WM_NOTIFY,
                           (WPARAM)PN.hdr.idFrom,
                           (LPARAM)&PN)) {

            CPSUIDBG(DBG_GET_TABWND,
                     ("*ApplyCPSUIProc(PSN_APPLY): Return=%ld",
                        GetWindowLongPtr(hDlg, DWLP_MSGRESULT)));

            switch (GetWindowLongPtr(hDlg, DWLP_MSGRESULT)) {

            case PSNRET_INVALID:
            case PSNRET_INVALID_NOCHANGEPAGE:

                PostMessage(pRootPage->RootInfo.hDlg,
                            PSM_SETCURSEL,
                            (WPARAM)0,
                            (LPARAM)pCPSUIPage->hPage);

                return(FALSE);

            case PSNRET_NOERROR:
            default:

                break;
            }
        }

        if (pTVWnd) {

            pTVWnd->Flags &= ~TWF_APPLY_NO_NEWDEF;
        }
    }

    return(TRUE);
}




LONG_PTR
CALLBACK
CPSUICallBack(
    HANDLE  hComPropSheet,
    UINT    Function,
    LPARAM  lParam1,
    LPARAM  lParam2
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    29-Dec-1995 Fri 11:36:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCPSUIPAGE      pParentPage;
    PCPSUIPAGE      pRootPage = NULL;
    PMYDATABLOCK    pMyDB;
    PCPSUIDATABLOCK pCPSUIDB;
    HCURSOR         hCursor;
    DWORD           Count = 0;
    LONG_PTR        Result = 0;
    DWORD           dwErr = ERROR_SUCCESS;

    CPSUIDBG(DBG_PFNCOMPROPSHEET,
             ("*CPSUICallBack(%08lx, %hs, %08lx, %08lx)",
            hComPropSheet,
            (Function <= MAX_CPSFUNC_INDEX) ? pszCPSFUNC[Function] :
                                              "??? Unknown Function",
            lParam1, lParam2));

    if ((pParentPage = HANDLETABLE_GetCPSUIPage(hComPropSheet)) &&
        ((pParentPage->Flags & CPF_PARENT)  ||
         (pParentPage->pChild))                                 &&
        (pRootPage = HANDLETABLE_GetRootPage(pParentPage))) {

        PCPSUIPAGE          pChildPage = NULL;
        PAGEPROCINFO        PageProcInfo;
        INSERTPSUIPAGE_INFO IPInfo;


        switch (Function) {

        case CPSFUNC_INSERT_PSUIPAGEA:
        case CPSFUNC_INSERT_PSUIPAGEW:

            Result = InsertPSUIPage(pRootPage,
                                    pParentPage,
                                    (HANDLE)lParam1,
                                    (PINSERTPSUIPAGE_INFO)lParam2,
                                    Function == CPSFUNC_INSERT_PSUIPAGEA);
            break;

        case CPSFUNC_ADD_HPROPSHEETPAGE:
        case CPSFUNC_ADD_PROPSHEETPAGEA:
        case CPSFUNC_ADD_PROPSHEETPAGEW:
        case CPSFUNC_ADD_PFNPROPSHEETUIA:
        case CPSFUNC_ADD_PFNPROPSHEETUIW:
        case CPSFUNC_ADD_PCOMPROPSHEETUIA:
        case CPSFUNC_ADD_PCOMPROPSHEETUIW:

            IPInfo.cbSize  = sizeof(IPInfo);
            IPInfo.Mode    = INSPSUIPAGE_MODE_LAST_CHILD;
            IPInfo.dwData1 = (ULONG_PTR)lParam1;
            IPInfo.dwData2 = (ULONG_PTR)lParam2;
            IPInfo.dwData3 = 0;

            switch (Function) {

            case CPSFUNC_ADD_HPROPSHEETPAGE:

                IPInfo.Type = PSUIPAGEINSERT_HPROPSHEETPAGE;
                break;

            case CPSFUNC_ADD_PROPSHEETPAGEA:    IPInfo.dwData3 = 1;
            case CPSFUNC_ADD_PROPSHEETPAGEW:

                Result = 0;
                IPInfo.Type = PSUIPAGEINSERT_PROPSHEETPAGE;
                break;

            case CPSFUNC_ADD_PCOMPROPSHEETUIA:  IPInfo.dwData3 = 1;
            case CPSFUNC_ADD_PCOMPROPSHEETUIW:

                IPInfo.Type = PSUIPAGEINSERT_PCOMPROPSHEETUI;
                break;

            case CPSFUNC_ADD_PFNPROPSHEETUIA:   IPInfo.dwData3 = 1;
            case CPSFUNC_ADD_PFNPROPSHEETUIW:

                IPInfo.Type = PSUIPAGEINSERT_PFNPROPSHEETUI;
                break;
            }

            Result = InsertPSUIPage(pRootPage,
                                    pParentPage,
                                    NULL,
                                    &IPInfo,
                                    (BOOL)IPInfo.dwData3);

            if (!Result) {
                //
                // Save the last error.
                //
                dwErr = GetLastError();
            }

            //
            // 20-Jul-1996 Sat 07:58:34 updated  -by-  Daniel Chou (danielc)
            //  Set dwData2 to cPage if sucessful, and dwData=ERR_CPSUI_xxx if
            //  failed
            //

            if ((IPInfo.Type == PSUIPAGEINSERT_PCOMPROPSHEETUI) &&
                (lParam2)) {

                *(LPDWORD)lParam2 = (DWORD)IPInfo.dwData2;
            }

            break;

        case CPSFUNC_GET_PAGECOUNT:

            PageProcInfo.pTabTable = NULL;
            PageProcInfo.pHandle   = NULL;
            PageProcInfo.phPage    = NULL;
            PageProcInfo.iPage     = 0;
            PageProcInfo.cPage     = (WORD)pRootPage->RootInfo.cPage;

            EnumCPSUIPagesSeq(pRootPage,
                              pParentPage,
                              SetPageProcInfo,
                              (LPARAM)&PageProcInfo);

            Result = (LONG_PTR)PageProcInfo.iPage;
            break;

        case CPSFUNC_GET_HPSUIPAGES:

            if (((LONG)lParam2 > 0)                         &&
                (PageProcInfo.pHandle = (HANDLE *)lParam1)  &&
                (PageProcInfo.cPage   = (WORD)lParam2)) {

                PageProcInfo.iPage     = 0;
                PageProcInfo.phPage    = NULL;
                PageProcInfo.pTabTable = NULL;

                EnumCPSUIPagesSeq(pRootPage,
                                  pParentPage,
                                  SetPageProcInfo,
                                  (LPARAM)&PageProcInfo);

                Result = (LONG_PTR)PageProcInfo.iPage;
            }

            break;

        case CPSFUNC_LOAD_CPSUI_STRINGA:
        case CPSFUNC_LOAD_CPSUI_STRINGW:

            Result = (LONG_PTR)LoadCPSUIString((LPTSTR)lParam1,
                                               LOWORD(lParam2),
                                               HIWORD(lParam2),
                                               Function ==
                                                    CPSFUNC_LOAD_CPSUI_STRINGA);
            break;

        case CPSFUNC_LOAD_CPSUI_ICON:

            if (((LONG)lParam1 >= IDI_CPSUI_ICONID_FIRST)   &&
                ((LONG)lParam1 <= IDI_CPSUI_ICONID_LAST)) {

                Result = lParam1;

                if (!(lParam1 = (LONG)LOWORD(lParam2))) {

                    lParam1 = (LONG)GetSystemMetrics(SM_CXICON);
                }

                if (!(lParam2 = (LONG)HIWORD(lParam2))) {

                    lParam2 = (LONG)GetSystemMetrics(SM_CYICON);
                }

                Result = (LONG_PTR)LoadImage(hInstDLL,
                                             MAKEINTRESOURCE(Result),
                                             IMAGE_ICON,
                                             (INT)lParam1,
                                             (INT)lParam2,
                                             0);

            } else {

                Result = 0;
            }

            break;

        case CPSFUNC_SET_RESULT:

            Result = pfnSetResult((lParam1) ? (HANDLE)lParam1 : hComPropSheet,
                                  (ULONG_PTR)lParam2);
            break;

        case CPSFUNC_SET_FUSION_CONTEXT:

            // check to release the current activation context (if any)
            if (pParentPage->hActCtx && pParentPage->hActCtx != INVALID_HANDLE_VALUE) {

                ReleaseActCtx(pParentPage->hActCtx);
                pParentPage->hActCtx = INVALID_HANDLE_VALUE;
            }

            // attach the new passed in fusion activation context to the compstui page
            pParentPage->hActCtx = (HANDLE)lParam1;

            // check to addref the passed in activation context handle
            if (pParentPage->hActCtx && pParentPage->hActCtx != INVALID_HANDLE_VALUE) {

                AddRefActCtx(pParentPage->hActCtx);
            }

            // indicate success
            Result = 1;

            break;

        case CPSFUNC_SET_HSTARTPAGE:

            //
            // Assume OK first
            //

            Result = 0xFFFF;

            if (pRootPage->Flags & CPF_SHOW_PROPSHEET) {

                break;

            } else if (!lParam1) {

                if (lParam2) {

                    pRootPage->Flags               |= CPF_PSZ_PSTARTPAGE;
                    pRootPage->RootInfo.pStartPage  = (PCPSUIPAGE)lParam2;
                    Result                          = lParam2;
                }

                break;
            }

            //
            // Fall through
            //

        case CPSFUNC_DELETE_HCOMPROPSHEET:
        case CPSFUNC_GET_PFNPROPSHEETUI_ICON:
        case CPSFUNC_SET_PSUIPAGE_TITLEA:
        case CPSFUNC_SET_PSUIPAGE_TITLEW:
        case CPSFUNC_SET_PSUIPAGE_ICON:
        case CPSFUNC_IGNORE_CPSUI_PSN_APPLY:
        case CPSFUNC_DO_APPLY_CPSUI:

            if ((lParam1)                                                   &&
                (pChildPage = HANDLETABLE_GetCPSUIPage((HANDLE)lParam1))    &&
                (HANDLETABLE_IsChildPage(pChildPage, pParentPage))) {

                switch (Function) {

                case CPSFUNC_SET_HSTARTPAGE:

                    Result = SethStartPage(pRootPage,
                                           pChildPage,
                                           (LONG)lParam2);
                    break;

                case CPSFUNC_DELETE_HCOMPROPSHEET:

                    HANDLETABLE_UnGetCPSUIPage(pChildPage);

                    EnumCPSUIPages(pRootPage,
                                   pChildPage,
                                   DeleteCPSUIPageProc,
                                   (LPARAM)&Count);

                    Result     = (LONG_PTR)Count;
                    pChildPage = NULL;

                    break;

                case CPSFUNC_GET_PFNPROPSHEETUI_ICON:

                    Result = (LONG_PTR)pfnGetIcon(pChildPage, lParam2);
                    break;

                case CPSFUNC_SET_PSUIPAGE_TITLEA:
                case CPSFUNC_SET_PSUIPAGE_TITLEW:

                    Result = SetPSUIPageTitle(pRootPage,
                                              pChildPage,
                                              (LPWSTR)lParam2,
                                              Function ==
                                                CPSFUNC_SET_PSUIPAGE_TITLEA);
                    break;

                case CPSFUNC_SET_PSUIPAGE_ICON:

                    Result = SetPSUIPageIcon(pRootPage,
                                             pChildPage,
                                             (HICON)lParam2);
                    break;

                case CPSFUNC_IGNORE_CPSUI_PSN_APPLY:

                    CPSUIDBG(DBG_GET_TABWND,
                         ("*\n\nCPSFUNC_IGNORE_CPSUI_PSN_APPLY: Page=%08lx, lParam2=%08lx, hDlg=%08lx\n",
                            pChildPage, lParam2, pRootPage->RootInfo.hDlg));

                    if (EnumCPSUIPagesSeq(pRootPage,
                                          pChildPage,
                                          IgnorePSNApplyProc,
                                          lParam2)) {

                        Result = 1;
                    }

                    break;


                case CPSFUNC_DO_APPLY_CPSUI:

                    if ((pRootPage->Flags & CPF_SHOW_PROPSHEET) &&
                        (pRootPage->RootInfo.hDlg)) {

                        CPSUIDBG(DBG_GET_TABWND,
                             ("*\n\nCPSFUNC_DO_APPLY_CPSUI: Page=%08lx, lParam2=%08lx, hDlg=%08lx\n",
                                pChildPage, lParam2, pRootPage->RootInfo.hDlg));

                        if (EnumCPSUIPagesSeq(pRootPage,
                                              pChildPage,
                                              ApplyCPSUIProc,
                                              lParam2)) {

                            Result = 1;
                        }
                    }

                    break;

                }
            }

            HANDLETABLE_UnGetCPSUIPage(pChildPage);

            break;

        case CPSFUNC_SET_DATABLOCK:

            LOCK_CPSUI_HANDLETABLE();

            if ((pCPSUIDB = (PCPSUIDATABLOCK)lParam1)   &&
                (lParam2)                               &&
                (pCPSUIDB->cbData)                      &&
                (pCPSUIDB->pbData)                      &&
                (pMyDB = (PMYDATABLOCK)LocalAlloc(LPTR, sizeof(MYDATABLOCK) + pCPSUIDB->cbData))) {

                PMYDATABLOCK    pPrevDB = NULL;
                PMYDATABLOCK    pCurDB = pRootPage->RootInfo.pMyDB;

                //
                // Try to find the old ID and delete it
                //

                while (pCurDB) {

                    if (pCurDB->ID == (DWORD)lParam2) {

                        if (pPrevDB) {

                            pPrevDB->pNext = pCurDB->pNext;

                        } else {

                            //
                            // This is the first one
                            //

                            pRootPage->RootInfo.pMyDB = pCurDB->pNext;
                        }

                        CPSUIDBG(DBG_PFNCOMPROPSHEET,
                                 ("SET_DATABLOCK()=Free ID=%08lx, pCurDB=%08lx (%ld)",
                                            pCurDB->ID, pCurDB, pCurDB->cb));

                        LocalFree((HLOCAL)pCurDB);
                        pCurDB = NULL;

                    } else {

                        pPrevDB = pCurDB;
                        pCurDB  = pCurDB->pNext;
                    }
                }

                //
                // Insert to the front
                //

                pMyDB->pNext              = pRootPage->RootInfo.pMyDB;
                pMyDB->ID                 = (DWORD)lParam2;
                pMyDB->cb                 = pCPSUIDB->cbData;
                pRootPage->RootInfo.pMyDB = pMyDB;
                Result                    = (LONG_PTR)pCPSUIDB->cbData;

                CopyMemory((LPBYTE)(pMyDB + 1),
                           pCPSUIDB->pbData,
                           LODWORD(Result));
            }

            UNLOCK_CPSUI_HANDLETABLE();

            break;

        case CPSFUNC_QUERY_DATABLOCK:

            LOCK_CPSUI_HANDLETABLE();

            if (pMyDB = pRootPage->RootInfo.pMyDB) {

                while (pMyDB) {

                    if (pMyDB->ID == (DWORD)lParam2) {

                        break;

                    } else {

                        pMyDB = pMyDB->pNext;
                    }
                }

                if (pMyDB) {

                    Result = (LONG_PTR)pMyDB->cb;

                    //
                    // Only do it if has a pointer and buffer count is
                    // not zero or the pointer is not NULL
                    //

                    if ((pCPSUIDB = (PCPSUIDATABLOCK)lParam1)   &&
                        (pCPSUIDB->cbData)                      &&
                        (pCPSUIDB->pbData)) {

                        //
                        // Limit to total bytes to copy = min(pCPSUIDB->cbData, Result)
                        //

                        if ((LONG_PTR)Result > (LONG_PTR)pCPSUIDB->cbData) {

                            Result = (LONG_PTR)pCPSUIDB->cbData;
                        }

                        CopyMemory(pCPSUIDB->pbData,
                                   (LPBYTE)(pMyDB + 1),
                                   LODWORD(Result));
                    }
                }
            }

            UNLOCK_CPSUI_HANDLETABLE();

            break;

        case CPSFUNC_SET_DMPUB_HIDEBITS:

            //
            // Only do it when these page is not register yet
            //

            if (!(pRootPage->Flags & (CPF_DOCPROP | CPF_ADVDOCPROP))) {

                (DWORD)lParam1 &= ~((DWORD)0xFFFFFFFF << DMPUB_LAST);

                pRootPage->RootInfo.DMPubHideBits = (DWORD)(Result = lParam1);
            }

            break;

        default:

            CPSUIERR(("CPSUICallBack(%ld) Unknown function index", Function));

            Result = (ULONG_PTR)-1;
            break;
        }
    }

    HANDLETABLE_UnGetCPSUIPage(pParentPage);
    HANDLETABLE_UnGetCPSUIPage(pRootPage);

    CPSUIDBG(DBG_PFNCOMPROPSHEET, ("CPSUICallBack()=%08lx", Result));

    if (dwErr != ERROR_SUCCESS) {
        //
        // Set the last error if preserved.
        //
        SetLastError(dwErr);
    }
    return(Result);
}




DWORD
GetSetCurUserReg(
    HKEY    *phRegKey,
    PTVWND  pTVWnd,
    LPDWORD pdw
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    30-Jan-1996 Tue 13:36:59 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pItem;
    DWORD       dw      = 0;


    if (*phRegKey) {

        if (pTVWnd->ActiveDlgPage == pTVWnd->TVPageIdx) {

            dw = REGDPF_TVPAGE;

        } else if (pTVWnd->ActiveDlgPage == 0) {

            dw = REGDPF_STD_P1;

        } else {

            dw = 0;
        }

        if ((pTVWnd->IntTVOptIdx)                                   &&
            (pItem = PIDX_INTOPTITEM(pTVWnd, pTVWnd->IntTVOptIdx))  &&
            (!(pItem->Flags & OPTIF_COLLAPSE))) {

            dw |= REGDPF_EXPAND_OPTIONS;
        }

        if (dw != *pdw) {

            CPSUIDBG(DBG_GETSETREG, ("GetSetCurUserReg(): Set New DW=%08lx", dw));

            RegSetValueEx(*phRegKey,
                          szDocPropKeyName,
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&dw,
                          sizeof(DWORD));
        }

        RegCloseKey(*phRegKey);
        *phRegKey = NULL;

    } else if (((ULONG_PTR)pTVWnd->ComPropSheetUI.pDlgPage ==
                                        (ULONG_PTR)CPSUI_PDLGPAGE_DOCPROP)   &&
               (RegCreateKey(HKEY_CURRENT_USER,
                             szCPSUIRegKey,
                             phRegKey) == ERROR_SUCCESS)                    &&
               (*phRegKey)) {

        DWORD   Type = REG_DWORD;
        DWORD   Size = sizeof(DWORD);

        if (RegQueryValueEx(*phRegKey,
                            szDocPropKeyName,
                            NULL,
                            &Type,
                            (LPBYTE)pdw,
                            &Size) != ERROR_SUCCESS) {

            *pdw = REGDPF_DEFAULT;
        }

        *pdw &= REGDPF_MASK;

        CPSUIDBG(DBG_GETSETREG, ("GetSetCurUserReg(): Get Cur DW=%08lx", *pdw));

        if ((*pdw & REGDPF_TVPAGE) &&
            (pTVWnd->TVPageIdx != PAGEIDX_NONE)) {

            dw = pTVWnd->TVPageIdx;


        } else if ((*pdw & REGDPF_STD_P1)   &&
                   (pTVWnd->StdPageIdx1 != PAGEIDX_NONE)) {

            dw = pTVWnd->StdPageIdx1;

        } else if (pTVWnd->StdPageIdx2 != PAGEIDX_NONE) {

            dw = pTVWnd->StdPageIdx2;

        } else {

            dw = (DWORD)-1;
        }

        if ((pTVWnd->IntTVOptIdx) &&
            (pItem = PIDX_INTOPTITEM(pTVWnd, pTVWnd->IntTVOptIdx))) {

            if (*pdw & REGDPF_EXPAND_OPTIONS) {

                pItem->Flags &= ~OPTIF_COLLAPSE;

            } else {

                pItem->Flags |= OPTIF_COLLAPSE;
            }
        }
    }

    return(dw);
}


LONG
DoComPropSheet(
    PCPSUIPAGE                  pRootPage,
    PPROPSHEETUI_INFO_HEADER    pPSUIInfoHdr
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    29-Aug-1995 Tue 12:55:41 created  -by-  Daniel Chou (danielc)


Revision History:

    28-Nov-1995 Tue 16:30:29 updated  -by-  Daniel Chou (danielc)
        Remove help button, since all help will be right mouse/question mark
        activated.


--*/

{
    PTVWND          pTVWnd;
    PCPSUIPAGE      pPage = NULL;
    PROPSHEETHEADER psh;
    PPSHINFO        pPSHInfo;
    LPTSTR          pTitle;
    PAGEPROCINFO    PageProcInfo;
    HICON           hIcon = NULL;
    HKEY            hRegKey = NULL;
    DWORD           Data;
    WORD            cWait;
    DWORD           dw;
    UINT            IntFmtStrID;
    LONG            Result;
    WORD            GBFAnsi;
    BOOL            AnsiCall;
    UINT            Idx = 0;


    GBFAnsi  = (WORD)((pRootPage->Flags & CPF_ANSI_CALL) ? GBF_ANSI_CALL : 0);
    Result   = sizeof(PSHINFO) +
               (pRootPage->RootInfo.cPage * sizeof(HPROPSHEETPAGE));

    if ((pRootPage->RootInfo.cPage) &&
        (pPSHInfo = (PPSHINFO)LocalAlloc(LPTR, Result))) {

        PageProcInfo.pTabTable = pRootPage->RootInfo.pTabTable;
        PageProcInfo.pHandle   = NULL;
        PageProcInfo.phPage    = (HPROPSHEETPAGE *)(pPSHInfo + 1);
        PageProcInfo.iPage     = 0;
        PageProcInfo.cPage     = (WORD)pRootPage->RootInfo.cPage;

        EnumCPSUIPagesSeq(pRootPage,
                          pRootPage,
                          SetPageProcInfo,
                          (LPARAM)&PageProcInfo);

        SHOW_TABWND(L"DoComPropSheet", PageProcInfo.pTabTable);

    } else {

        return(ERR_CPSUI_ALLOCMEM_FAILED);
    }

    psh.dwSize  = sizeof(PROPSHEETHEADER);
    psh.dwFlags = 0;

    if (pPSUIInfoHdr->Flags & PSUIHDRF_PROPTITLE) {

        psh.dwFlags |= PSH_PROPTITLE;
    }

    if (pPSUIInfoHdr->Flags & PSUIHDRF_NOAPPLYNOW) {

        psh.dwFlags      |= PSH_NOAPPLYNOW;
        pRootPage->Flags |= CPF_NO_APPLY_BUTTON;
    }

    CPSUIDBGBLK(
    {
        if (DBG_CPSUIFILENAME & DBG_ALWAYS_APPLYNOW) {

            psh.dwFlags      &= ~PSH_NOAPPLYNOW;
            pRootPage->Flags &= ~CPF_NO_APPLY_BUTTON;
        }
    })

    psh.hwndParent  = pPSUIInfoHdr->hWndParent;
    psh.hInstance   = pPSUIInfoHdr->hInst;
    psh.pStartPage  = NULL;
    psh.nPages      = (UINT)pRootPage->RootInfo.cPage;
    psh.phpage      = PageProcInfo.phPage;
    psh.pszCaption  = (LPTSTR)pPSHInfo->CaptionName;

    if (pPSUIInfoHdr->Flags & PSUIHDRF_USEHICON) {

        psh.dwFlags |= PSH_USEHICON;
        psh.hIcon    = pPSUIInfoHdr->hIcon;

    } else {

        if (!(hIcon = GETICON16(pPSUIInfoHdr->hInst, pPSUIInfoHdr->IconID))) {

            hIcon = GETICON16(hInstDLL, IDI_CPSUI_OPTION);
        }

        psh.dwFlags |= PSH_USEHICON;
        psh.hIcon    = hIcon;
    }

    //
    // Set Start page now
    //

    if (pPage = pRootPage->RootInfo.pStartPage) {

        if (pRootPage->Flags & CPF_PSZ_PSTARTPAGE) {

            psh.dwFlags    |= PSH_USEPSTARTPAGE;
            psh.pStartPage  = (LPCTSTR)pPage;

        } else {

            while ((pPage) && (pPage->Flags & CPF_PARENT)) {

                pPage = pPage->pChild;
            }

            if ((pPage)                         &&
                (!(pPage->Flags & CPF_PARENT))  &&
                (pPage->hPage)) {

                while (psh.nStartPage < psh.nPages) {

                    if (psh.phpage[psh.nStartPage] == pPage->hPage) {

                        //
                        // Found it
                        //

                        break;
                    }

                    psh.nStartPage++;
                }
            }
        }
    }

    //
    // Get the internal format string ID for the title bar
    //

    if ((pTitle = pPSUIInfoHdr->pTitle) &&
        (pPSUIInfoHdr->Flags & PSUIHDRF_EXACT_PTITLE)) {

        psh.dwFlags &= ~PSH_PROPTITLE;
        IntFmtStrID  = 0;

    } else {

        IntFmtStrID = (pPSUIInfoHdr->Flags & PSUIHDRF_DEFTITLE) ?
                                                IDS_INT_CPSUI_DEFAULT : 0;

        if ((pRootPage->Flags & (CPF_DOCPROP | CPF_ADVDOCPROP)) &&
            (pRootPage->RootInfo.cPage >= pRootPage->RootInfo.cCPSUIPage)) {

            if (pRootPage->Flags & CPF_ADVDOCPROP) {

                //
                // Can only be 'XXX Advance Document Properties';
                //

                IntFmtStrID  = IDS_INT_CPSUI_ADVDOCUMENT;
                psh.dwFlags |= PSH_PROPTITLE;

            } else if (pRootPage->Flags & CPF_DOCPROP) {

                //
                // Can be 'XXX Document Properties' or
                //        'XXX Default Document Properties'
                //

                IntFmtStrID  = (pPSUIInfoHdr->Flags & PSUIHDRF_DEFTITLE) ?
                                                    IDS_INT_CPSUI_DEFDOCUMENT :
                                                    IDS_INT_CPSUI_DOCUMENT;
                psh.dwFlags |= PSH_PROPTITLE;

                if (!pRootPage->RootInfo.pStartPage) {

                    pPage = pRootPage;

                    while ((pPage) && (pPage->Flags & CPF_PARENT)) {

                        pPage = pPage->pChild;
                    }

                    if ((pPage)                                         &&
                        (pPage->pParent->Flags & CPF_COMPROPSHEETUI)    &&
                        (pTVWnd = pPage->pParent->CPSUIInfo.pTVWnd)) {

                        if ((dw = GetSetCurUserReg(&hRegKey,
                                                   pTVWnd,
                                                   &Data)) != (DWORD)-1) {

                            psh.nStartPage += dw;
                        }
                    }
                }
            }
        }
    }

    //
    // Compose Title, first make sure the title exist, if not then use
    // 'Options' as title
    //

    if ((!pTitle)   ||
        (!GetStringBuffer(pPSUIInfoHdr->hInst,
                          (WORD)(GBF_PREFIX_OK      |
                                 GBF_INT_NO_PREFIX  |
                                 GBFAnsi),
                          L'\0',
                          pTitle,
                          pPSHInfo->CaptionName,
                          COUNT_ARRAY(pPSHInfo->CaptionName)))) {

        GetStringBuffer(hInstDLL,
                        (WORD)(GBF_PREFIX_OK      |
                               GBF_INT_NO_PREFIX  |
                               GBFAnsi),
                        L'\0',
                        pTitle = (LPTSTR)IDS_CPSUI_OPTIONS,
                        pPSHInfo->CaptionName,
                        COUNT_ARRAY(pPSHInfo->CaptionName));
    }

    //
    // If we need to composed with internal format string, then redo it using
    // compose calls, otherwise the CaptionName already has user title
    //

    if (IntFmtStrID) {

        ComposeStrData(pPSUIInfoHdr->hInst,
                       (WORD)(GBF_PREFIX_OK | GBF_INT_NO_PREFIX | GBFAnsi),
                       pPSHInfo->CaptionName,
                       COUNT_ARRAY(pPSHInfo->CaptionName),
                       IntFmtStrID,
                       pTitle,
                       0,
                       0);
    }

    if ((!(psh.dwFlags & PSH_USEPSTARTPAGE))    &&
        (psh.nStartPage >= psh.nPages)) {

        psh.nStartPage = 0;
    }

    CPSUIDBG(DBG_DOCOMPROPSHEET, ("pRootPage=%08lx, RootFlags=%08lx, pPSUIInfoHdr->Flags=%08lx\nCaption(%ld)='%ws', Start Page=%ld (%08lx)",
                    pRootPage, pRootPage->Flags, pPSUIInfoHdr->Flags,
                    (LONG)Idx, pPSHInfo->CaptionName, psh.nStartPage,
                    psh.pStartPage));

    psh.dwFlags     |= PSH_USECALLBACK;
    psh.pfnCallback  = PropSheetProc;

    //
    // Make sure only one person go through the PropertySheet
    //

    LOCK_CPSUI_HANDLETABLE();

    CPSUIDBG(DBG_PAGE_PROC, ("<< ProcessID=%ld, ThreadID=%ld, TIsValue(%ld)=%08lx",
                GetCurrentProcessId(), GetCurrentThreadId(),
                TlsIndex, TlsGetValue(TlsIndex)));

    cWait = TLSVALUE_2_CWAIT(TlsGetValue(TlsIndex));
    Idx   = (UINT)HANDLE_2_IDX(pRootPage->hCPSUIPage);

    TlsSetValue(TlsIndex, ULongToPtr(MK_TLSVALUE(cWait, Idx)));

    UNLOCK_CPSUI_HANDLETABLE();

    DBG_SHOW_CPSUIPAGE(pRootPage, 0);

    if ((Result = (LONG)PropertySheet((LPCPROPSHEETHEADER)&psh)) < 0) {

        Result = ERR_CPSUI_GETLASTERROR;

    } else if (Result == ID_PSRESTARTWINDOWS) {

        Result = CPSUI_RESTARTWINDOWS;

    } else if (Result == ID_PSREBOOTSYSTEM) {

        Result = CPSUI_REBOOTSYSTEM;

    } else {

        Result = CPSUI_OK;
    }

    //
    // Free all the stuff first
    //

    LocalFree((HLOCAL)pPSHInfo);

    if (hIcon) {

        DestroyIcon(hIcon);
    }

    //
    // Save things back to registry if we got one
    //

    if (hRegKey) {

        GetSetCurUserReg(&hRegKey, pTVWnd, &Data);
    }

    CPSUIINT(("PropertySheet() = %ld", Result));

    return(Result);
}



LONG
DoCommonPropertySheetUI(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult,
    BOOL            AnsiCall
    )

/*++

Routine Description:

    The CommonPropSheetUI is the main entry point for the common property sheet
    user interface.   The original caller that wish to using common UI to
    pop-up property sheet will call this function and passed its own
    PFNPROPSHEETUI function address and a long parameter.

    If pfnPropSheetUI function return a LONG number greater than zero (0) then
    common UI will pop-up the property sheet page dialog boxes, when Property
    sheet pages is finished. (either hit Ok or Cancel) it will return the
    result of CPSUI_xxxx back to the caller.

    If pfnPropSheetUI function return a LONG number equal or less than zero (0)
    then it will return the CPSUI_CANCEL back to caller without pop-up the
    property sheet page dialog boxes.



Arguments:


    hWndOwner       - Window handle for the owner of this proerty sheet
                      pages dialog boxes.

    pfnPropSheetUI  - a PFNPROPSHEETUI function pointer which is used by
                      the caller to add its property sheet pages.

    lParam          - a long parameter will be passed to the pfnPropSheetUI
                      funciton.  The common UI called the pfnPropSheetUI as

                        PROPSHEETUI_INFO    PSUIInfo;

                        pfnPropSheetUI(&PSUIInfo, lParam);

                      The caller must use pfnComPropSheet() to add/delete
                      pages.  When it is done adding pages, it retuned
                      greater than zero to indicate successful, and return
                      less or equal to zero to indicate failure.

    pResult         - a pointer to DWORD which received the final result
                      of pfnPropSheetUI() funciton, this result is a copy
                      from Result field of PROPSHEETUI_INFO data structure
                      which passed to the pfnPropSheetUI() as the first
                      parameter.

                      if pResult is NULL then common UI will not return
                      pfnPropSheetUI()'s result back.


Return Value:

    LONG    - < 0                   - Error, ERR_CPSUI_xxxx
              CPSUI_CANCEL          - User hit Cancel.
              CPSUI_OK              - User hit Ok.
              CPSUI_RESTARTWINDOWS  - Ok and need to restart window
              CPSUI_REBOOTSYSTEM    - Ok and need to reboot system


Author:

    04-Feb-1996 Sun 07:52:49 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTABTABLE                   pTabTable = NULL;
    PCPSUIPAGE                  pRootPage;
    PROPSHEETUI_INFO_HEADER     PSUIInfoHdr;
    PMYDATABLOCK                pMyDB;
    LONG                        Result;


    if (!(pRootPage = AddCPSUIPage(NULL, NULL, 0))) {

        CPSUIERR(("DoCommonPropertySheetUI(), Create RootPage failed"));
        return(ERR_CPSUI_ALLOCMEM_FAILED);
    }

    PSUIInfoHdr.cbSize          = sizeof(PROPSHEETUI_INFO_HEADER);
    PSUIInfoHdr.Flags           = 0;
    PSUIInfoHdr.pTitle          = NULL;
    PSUIInfoHdr.hWndParent      = hWndOwner;
    PSUIInfoHdr.hInst           = NULL;
    PSUIInfoHdr.IconID          = IDI_CPSUI_OPTION;
    pRootPage->RootInfo.pResult = pResult;

    CPSUIDBG(DBG_DO_CPSUI, ("DoComPropSheetUI(hWndOwner=%08lx, Active=%08lx, Focus=%08lx)",
                hWndOwner, GetActiveWindow(), GetFocus()));

    if (GetCapture()) {

        CPSUIDBG(DBG_DO_CPSUI, ("DoComPropSheetUI(): MouseCapture=%08lx",
                                GetCapture()));
        ReleaseCapture();
    }

    if (AnsiCall) {

        CPSUIDBG(DBG_DO_CPSUI, ("DoComPropSheetUI(ANSI CALL)"));

        pRootPage->Flags |= CPF_ANSI_CALL;
    }

    if (!CPSUICallBack(pRootPage->hCPSUIPage,
                      (AnsiCall) ? CPSFUNC_ADD_PFNPROPSHEETUIA :
                                   CPSFUNC_ADD_PFNPROPSHEETUIW,
                      (LPARAM)pfnPropSheetUI,
                      (LPARAM)lParam)) {

        CPSUIERR(("DoCommonPropertySheetUI: ADD_PFNPROPSHEETUI failed"));
        Result = ERR_CPSUI_GETLASTERROR;

    } else if (CallpfnPSUI(pRootPage->pChild,
                           PROPSHEETUI_REASON_GET_INFO_HEADER,
                           (LPARAM)&PSUIInfoHdr) <= 0) {

        CPSUIERR(("DoCommonPropertySheetUI: GET_INFO_HEADER, Canceled"));
        Result = CPSUI_CANCEL;

    } else if (!(pRootPage->RootInfo.cPage)) {

        CPSUIERR(("DoCommonPropertySheetUI: RootInfo.cPage=0, Canceled."));
        Result = ERR_CPSUI_NO_PROPSHEETPAGE;

    } else if (!(pTabTable = (PTABTABLE)LocalAlloc(LMEM_FIXED,
                                                   sizeof(TABTABLE)))) {

        CPSUIERR(("DoCommonPropertySheetUI: Allocation of TABTABLE=%ld failed",
                                                sizeof(TABTABLE)));

        Result = ERR_CPSUI_ALLOCMEM_FAILED;

    } else {

        DoTabTable(TAB_MODE_DELETE_ALL, pTabTable, 0, 0);

        pRootPage->RootInfo.pTabTable =
        pTabTable->pTabTable          = pTabTable;
        pTabTable->hWndTab            = NULL;
        pTabTable->WndProc            = NULL;
        pTabTable->hPSDlg             = NULL;
        // pTabTable->hRootPage          = pRootPage->hCPSUIPage;

        pRootPage->Flags |= CPF_SHOW_PROPSHEET;

        Result = DoComPropSheet(pRootPage, &PSUIInfoHdr);

        pRootPage->Flags &= ~CPF_SHOW_PROPSHEET;
        pRootPage->Flags |= CPF_DONE_PROPSHEET;
    }

    if (pTabTable) {

        CPSUIDBG(DBG_PAGE_PROC, ("=+=+ FREE pTableTable=%08lx", pTabTable));
        LocalFree((HLOCAL)pTabTable);
        pTabTable = NULL;
    }

    //
    // Free up the Datablock even if failed, so if misbehave by the caller
    // that register the data block then we should remove it now
    //

    while (pMyDB = pRootPage->RootInfo.pMyDB) {

        pRootPage->RootInfo.pMyDB = pMyDB->pNext;

        CPSUIDBG(DBG_DO_CPSUI,
                 ("Free DataBlock: ID=%08lx, pCurDB=%08lx (%ld)",
                            pMyDB->ID, pMyDB, pMyDB->cb));

        LocalFree((HLOCAL)pMyDB);
    }

    HANDLETABLE_UnGetCPSUIPage(pRootPage);
    EnumCPSUIPages(pRootPage, pRootPage, DeleteCPSUIPageProc, (LPARAM)0);

    if (pResult) {

        CPSUIDBG(DBG_DO_CPSUI, ("DoCommonPropertySheetUI(): Result=%ld, *pResult=%ld",
                    Result, *pResult));

    } else {

        CPSUIDBG(DBG_DO_CPSUI, ("DoCommonPropertySheetUI(): Result=%ld, *pResult=NULL",
                    Result));
    }

    return(Result);
}



LONG
APIENTRY
CommonPropertySheetUIA(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    )

/*++

Routine Description:

    SEE DoCommonPropertySheetUI description


Arguments:

    SEE DoCommonPropertySheetUI description


Return Value:

    SEE DoCommonPropertySheetUI description

Author:

    01-Sep-1995 Fri 12:29:10 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    return(DoCommonPropertySheetUI(hWndOwner,
                                   pfnPropSheetUI,
                                   lParam,
                                   pResult,
                                   TRUE));
}



LONG
APIENTRY
CommonPropertySheetUIW(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    )

/*++

Routine Description:

    SEE DoCommonPropertySheetUI description


Arguments:

    SEE DoCommonPropertySheetUI description

Return Value:

    SEE DoCommonPropertySheetUI description


Author:

    30-Jan-1996 Tue 15:30:41 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    return(DoCommonPropertySheetUI(hWndOwner,
                                   pfnPropSheetUI,
                                   lParam,
                                   pResult,
                                   FALSE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\debug.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    debug.h


Abstract:

    This module contains all debugger definitions


Author:

    30-Aug-1995 Wed 19:02:36 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/



#if DBG

VOID
cdecl
CPSUIDbgPrint(
    LPSTR   pszFormat,
    ...
    );

VOID
CPSUIDbgType(
    INT    Type
    );

VOID
_CPSUIAssert(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    UINT    LineNo,
    LPVOID  Exp,
    BOOL    Stop
    );

VOID
CPSUIDbgShowItem(
    PTVWND      pTVWnd,
    LPSTR       pTitle,
    UINT        Level,
    POPTITEM    pItem
    );


extern BOOL DoCPSUIWarn;
extern BOOL DoDbgMsg;
extern BOOL DoIntMsg;

#define _ISDBG(x)               (((DoIntMsg) && (!(x)))     ||             \
                                 ((DoDbgMsg) && ((x)&DBG_CPSUIFILENAME)))

#define _DBGP(x)                (CPSUIDbgPrint x)
#define DBGP(x)                 if (DoDbgMsg) { _DBGP(x); }

#if 1

#define DEFINE_DBGVAR(x)        DWORD DBG_CPSUIFILENAME=(x)
#else

#define DEFINE_DBGVAR(x)
#endif  // if 1

#define CPSUIDBG(x,y)           if ((DoDbgMsg)&&((x)&DBG_CPSUIFILENAME)){  \
                                    CPSUIDbgType(0);_DBGP(y);}
#define CPSUIDBGBLK(x)          x;
#define CPSUIRECT(x,ps,prc,i,j)                                             \
    if (_ISDBG(x)) { CPSUIDbgType(0);                                       \
        _DBGP(("RECT *%hs* [%ld:%ld]: (%ld, %ld) - (%ld, %ld) = %ld x %ld", \
                (ps), (LONG)(i),(LONG)(j), (prc)->left, (prc)->top,         \
                (prc)->right, (prc)->bottom, (prc)->right - (prc)->left,    \
                (prc)->bottom - (prc)->top)); }
#define CPSUIOPTITEM(x,p,t,l,i) if(_ISDBG(x)) {CPSUIDbgShowItem(p,t,l,i);}
#define CPSUIWARN(x)            if(DoCPSUIWarn) { CPSUIDbgType(1);_DBGP(x); }
#define CPSUIINT(x)             if(DoIntMsg){ CPSUIDbgType(0);_DBGP(x); }
#define CPSUIERR(x)             CPSUIDbgType(-1);_DBGP(x)
#define CPSUIRIP(x)             CPSUIERR(x); DebugBreak()
#define CPSUIASSERT(b,x,e,i)     \
        if (!(e)) { _CPSUIAssert(x,#e,__FILE__,(UINT)__LINE__,(LPVOID)(i),b); }

#else   // DBG

#define CPSUIDBGBLK(x)
#define DEFINE_DBGVAR(x)
#define CPSUIDBG(x,y)
#define CPSUIRECT(x,ps,prc,i,j)
#define CPSUIOPTITEM(x,p,l,t,i)
#define CPSUIWARN(x)
#define CPSUIINT(x)
#define CPSUIERR(x)
#define CPSUIRIP(x)
#define CPSUIASSERT(b,x,e,i)

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\debug.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    debug.c


Abstract:

    This module contains all debugging routines


Author:

    30-Aug-1995 Wed 19:01:07 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#if DBG


BOOL    DoCPSUIWarn = TRUE;
BOOL    DoDbgMsg = TRUE;
BOOL    DoIntMsg = FALSE;


LPSTR   pTVOTName[] = {  "TVOT_2STATES",
                         "TVOT_3STATES",
                         "TVOT_UDARROW",
                         "TVOT_TRACKBAR",
                         "TVOT_SCROLLBAR",
                         "TVOT_LISTBOX",
                         "TVOT_COMBOBOX",
                         "TVOT_EDITBOX",
                         "TVOT_PUSHBUTTON",
                         "TVOT_CHKBOX" };

LPSTR   pDMPubName[] = {  "DMPUB_NONE",
                          "DMPUB_ORIENTATION",
                          "DMPUB_SCALE",
                          "DMPUB_COPIES_COLLATE",
                          "DMPUB_DEFSOURCE",
                          "DMPUB_PRINTQUALITY",
                          "DMPUB_COLOR",
                          "DMPUB_DUPLEX",
                          "DMPUB_TTOPTION",
                          "DMPUB_FORMNAME",
                          "DMPUB_ICMMETHOD",
                          "DMPUB_ICMINTENT",
                          "DMPUB_MEDIATYPE",
                          "DMPUB_DITHERTYPE",
                          "DMPUB_OUTPUTBIN",
                          "DMPUB_QUALITY",
                          "DMPUB_NUP",
                          "DMPUB_PAGEORDER",
                          "<DMPUB_USER>"
                       };



VOID
cdecl
CPSUIDbgPrint(
    LPSTR   pszFormat,
    ...
    )

/*++

Routine Description:

    This fucntion output the debug informat to the debugger


Arguments:

    pszFormat   - format string

    ...         - variable data


Return Value:


    VOID

Author:

    30-Aug-1995 Wed 19:10:34 updated  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    va_list         vaList;
    static WCHAR    OutBuf[768];
    static WCHAR    FormatBuf[256];

    //
    // We assume that UNICODE flag is turn on for the compilation, bug the
    // format string passed to here is ASCII version, so we need to convert
    // it to LPWSTR before the wvsprintf()
    //

    va_start(vaList, pszFormat);

    MultiByteToWideChar(CP_ACP, 0, pszFormat, -1, FormatBuf, ARRAYSIZE(FormatBuf));

    wvnsprintf(OutBuf, ARRAYSIZE(OutBuf) - 1, FormatBuf, vaList);
    va_end(vaList);

    OutputDebugString((LPTSTR)OutBuf);
    OutputDebugString(L"\n");
}




VOID
CPSUIDbgType(
    INT    Type
    )

/*++

Routine Description:

    this function output the ERROR/WARNING message


Arguments:

    Type

Return Value:


Author:

    30-Aug-1995 Wed 19:10:42 updated  -by-  Daniel Chou (danielc)

Revision History:


--*/

{
    static WCHAR    DebugDLLName[] = L"ComPstUI";


    if (Type) {

        OutputDebugString((Type < 0) ? L"ERROR: " : L"WARNING: ");
    }

    OutputDebugString(DebugDLLName);
    OutputDebugString(L": ");
}




VOID
_CPSUIAssert(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    UINT    LineNo,
    LPVOID  Exp,
    BOOL    Stop
    )

/*++

Routine Description:

    This function output assertion message and false expression to the debugger
    then break into the debugger


Arguments:

    pMsg        - Message to displayed

    pFlaseExp   - false expression

    pFilename   - source filename

    LineNo      - line number of the flase expression

Return Value:

    VOID


Author:

    30-Aug-1995 Wed 19:10:49 updated  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    OutputDebugString(L"\n");

    if ((pMsg) && (*pMsg)) {

        CPSUIDbgPrint(pMsg, Exp);
    }

    CPSUIDbgPrint("Assertion failed (%hs) in %hs line %u",
                                        pFalseExp, pFilename, LineNo);

    if (Stop) {

        DebugBreak();
    }
}


VOID
CPSUIDbgShowItem(
    PTVWND      pTVWnd,
    LPSTR       pTitle,
    UINT        Level,
    POPTITEM    pItem
    )
{
    if (pItem) {

        POPTTYPE    pOptType;
        POPTPARAM   pOptParam;
        PEXTCHKBOX  pECB = pItem->pExtChkBox;
        UINT        i;
        GSBUF_DEF(pItem, MAX_RES_STR_CHARS);


        if (pOptType = pItem->pOptType) {

            pOptParam = pOptType->pOptParam;

        } else {

            pOptParam = NULL;
        }

        CPSUIDbgPrint("\n---- %hs OPTITEM = %08lx -----", pTitle, pItem);
        CPSUIDbgPrint("cbSize     = %ld",         (DWORD)pItem->cbSize);
        CPSUIDbgPrint("pOptType   = %08lx",       pItem->pOptType);

        GSBUF_GETSTR(pItem->pName);

        CPSUIDbgPrint("pName      = %ws", GSBUF_BUF);

        GSBUF_RESET;

        if ((pOptType) && (pOptParam)) {

            switch (pOptType->Type) {

            case TVOT_LISTBOX:
            case TVOT_2STATES:
            case TVOT_3STATES:
            case TVOT_COMBOBOX:

                if ((pItem->Sel < 0) || (pItem->Sel > pOptType->Count)) {

                    GSBUF_GETSTR(pTVWnd->OptParamNone.pData);

                } else {

                    GSBUF_GETSTR(pOptParam[pItem->Sel].pData);
                }

                break;

            case TVOT_EDITBOX:

                GSBUF_GETSTR(pItem->pSel);
                break;

            case TVOT_UDARROW:
            case TVOT_TRACKBAR:
            case TVOT_SCROLLBAR:
            case TVOT_PUSHBUTTON:
            case TVOT_CHKBOX:

                break;
            }
        }

        CPSUIDbgPrint("pSel       = %ld, Name:<%ws> [%08lx]", pItem->pSel,
                                                    GSBUF_BUF, pItem->pSel);
        CPSUIDbgPrint("UserData   = %08lx",   pItem->UserData);
        CPSUIDbgPrint("pExtChkBox = %08lx",   pECB);

        if ((Level > 0) && (pECB)) {

            if (pItem->Flags & OPTIF_EXT_IS_EXTPUSH) {

                PEXTPUSH    pEP = (PEXTPUSH)pECB;


                CPSUIDbgPrint("    ---- PEXTPUSH ----");
                CPSUIDbgPrint("    cbSize              = %ld",   (DWORD)pEP->cbSize);
                CPSUIDbgPrint("    Flags               = %02lx", (DWORD)pEP->Flags);

                GSBUF_RESET;
                GSBUF_GETSTR(pEP->pTitle);
                CPSUIDbgPrint("    pTitle              = %ws", GSBUF_BUF);
                CPSUIDbgPrint("    DlgProc/pfnCallBack = %08lx", pEP->DlgProc);
                CPSUIDbgPrint("    IconID              = %0ld", pEP->IconID);
                CPSUIDbgPrint("    DlgTemplateID       = %0ld", pEP->DlgTemplateID);
                CPSUIDbgPrint("    ~~~~~~~~~~~~~~~~~~~~");

            } else {

                CPSUIDbgPrint("    ---- PEXTCHKBOX ----");
                CPSUIDbgPrint("    cbSize        = %ld",   (DWORD)pECB->cbSize);
                CPSUIDbgPrint("    Flags         = %02lx", (DWORD)pECB->Flags);

                GSBUF_RESET;
                GSBUF_GETSTR(pECB->pTitle);
                CPSUIDbgPrint("    pTitle        = %ws", GSBUF_BUF);

                GSBUF_RESET;
                GSBUF_GETSTR(pECB->pSeparator);
                CPSUIDbgPrint("    pSeparator    = %ws", GSBUF_BUF);

                GSBUF_RESET;
                GSBUF_GETSTR(pECB->pCheckedName);
                CPSUIDbgPrint("    pCheckBoxName = %ws", GSBUF_BUF);
                CPSUIDbgPrint("    IconID        = %0ld", pECB->IconID);
                CPSUIDbgPrint("    ~~~~~~~~~~~~~~~~~~~~");
            }
        }

        if ((i = pItem->DMPubID) > DMPUB_LAST) {

            i = DMPUB_LAST + 1;
        }

        CPSUIDbgPrint("Flags      = 0x%08lx", (DWORD)pItem->Flags);
        CPSUIDbgPrint("HelpIndex  = %ld",     (DWORD)pItem->HelpIndex);
        CPSUIDbgPrint("Level      = %ld",     (DWORD)pItem->Level);
        CPSUIDbgPrint("DMPubID    = %hs (%ld)", pDMPubName[i], (DWORD)pItem->DMPubID);
        CPSUIDbgPrint("DlgPageIdx = %ld", (DWORD)pItem->DlgPageIdx);

        CPSUIDbgPrint("HTREEITEM  = %08lx", _OI_HITEM(pItem));
        CPSUIDbgPrint("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");


        if ((Level > 0) && (pOptType)) {

            CPSUIDbgPrint("    ------- OPTTYPE --------");
            CPSUIDbgPrint("    cbSize    = %ld",   (DWORD)pOptType->cbSize);
            CPSUIDbgPrint("    Type      = %hs",   pTVOTName[pOptType->Type]);
            CPSUIDbgPrint("    Flags     = %02lx", (DWORD)pOptType->Flags);
            CPSUIDbgPrint("    Count     = %ld",   (DWORD)pOptType->Count);
            CPSUIDbgPrint("    BegCtrlID = %ld",   (DWORD)pOptType->BegCtrlID);
            CPSUIDbgPrint("    pOptParam = %08lx", pOptParam);
            CPSUIDbgPrint("    Style     = %04lx", (DWORD)pOptType->Style);
            CPSUIDbgPrint("    ~~~~~~~~~~~~~~~~~~~~~~~~");

            if ((Level > 1) && (pOptParam)) {

                i = pOptType->Count;

                for (i = 0; i < (UINT)pOptType->Count; i++, pOptParam++) {

                    GSBUF_RESET;
                    GSBUF_GETSTR(pOptParam->pData);

                    CPSUIDbgPrint("        ------- OPTPARAM %ld -------", (DWORD)i);
                    CPSUIDbgPrint("        cbSize   = %ld ", (DWORD)pOptParam->cbSize);
                    CPSUIDbgPrint("        Flags    = %02lx", (DWORD)pOptParam->Flags);
                    CPSUIDbgPrint("        Style    = %ld",   (DWORD)pOptParam->Style);
                    CPSUIDbgPrint("        pData    = %ws (%08lx)", GSBUF_BUF, pOptParam->pData);
                    CPSUIDbgPrint("        IconID   = %ld", (DWORD)pOptParam->IconID);
                    CPSUIDbgPrint("        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
                }
            }
        }

        CPSUIDbgPrint("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

    } else {

        CPSUIDbgPrint("\n\n---- %hs OPTITEM = %08lx -----", pTitle, pItem);
    }
}



#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\handle.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    handle.c


Abstract:

    This module contains all function which deal with handle table for the
    common UI


Author:

    30-Jan-1996 Tue 16:28:56 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL


[Notes:]


Revision History:


--*/



#include "precomp.h"
#pragma  hdrstop


#define DBG_CPSUIFILENAME   DbgHandle


#define DBG_CPSUI_HTABLE    0x00000001
#define DBG_FINDHANDLE      0x00000002
#define DBG_ADD_DATA        0x00000004
#define DBG_HANDLE_DESTROY  0x00000008
#define DBG_GET_HPSPINFO    0x00000010
#define DBG_SEM             0x00000020

DEFINE_DBGVAR(0);


HANDLE              hCPSUIMutex = NULL;
CPSUIHANDLETABLE    CPSUIHandleTable = { NULL, 0, 0, 0, 0 };
extern DWORD        TlsIndex;




BOOL
LOCK_CPSUI_HANDLETABLE(
    VOID
    )

/*++

Routine Description:

    This function get the lock the object


Arguments:

    VOID

Return Value:

    BOOL


Author:

    27-Mar-1996 Wed 11:27:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL    Ok = FALSE;


    if (hCPSUIMutex) {

        WORD    Idx;

        switch (WaitForSingleObject(hCPSUIMutex, MAX_SEM_WAIT)) {

        case WAIT_OBJECT_0:

            //
            // Signaled, and own it now
            //

            if (!CPSUIHandleTable.cWait++) {

                CPSUIHandleTable.ThreadID = GetCurrentThreadId();
            }

            Idx = TLSVALUE_2_IDX(TlsGetValue(TlsIndex));

            TlsSetValue(TlsIndex,
                        ULongToPtr(MK_TLSVALUE(CPSUIHandleTable.cWait, Idx)));

            CPSUIDBG(DBG_SEM, ("LOCK_CPSUI_HANDLETABLE: ThreadID=%ld, cWait=%ld",
                        GetCurrentThreadId(), CPSUIHandleTable.cWait));

            Ok = TRUE;

            break;

        case WAIT_ABANDONED:

            CPSUIERR(("LockCPSUIObject()= WAIT_ABANDONED"));
            break;

        case WAIT_TIMEOUT:

            CPSUIERR(("LockCPSUIObject()= WAIT_TIMEOUT"));
            break;

        default:

            CPSUIERR(("LockCPSUIObject()= UNKNOWN"));
            break;
        }
    }

    return(Ok);
}



BOOL
UNLOCK_CPSUI_HANDLETABLE(
    VOID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    27-Mar-1996 Wed 11:39:37 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL    Ok = FALSE;


    if (hCPSUIMutex) {

        DWORD   ThreadID = GetCurrentThreadId();
        WORD    Idx;


        CPSUIDBG(DBG_SEM, ("UNLOCK_CPSUI_HANDLETABLE: ThreadID=%ld, cWait=%ld",
                    ThreadID, CPSUIHandleTable.cWait));

        if (ThreadID == CPSUIHandleTable.ThreadID) {

            if (CPSUIHandleTable.cWait) {

                if (--CPSUIHandleTable.cWait == 0) {

                    CPSUIHandleTable.ThreadID = NO_THREADID;
                }


                Idx = TLSVALUE_2_IDX(TlsGetValue(TlsIndex));

                TlsSetValue(TlsIndex,
                            ULongToPtr(MK_TLSVALUE(CPSUIHandleTable.cWait, Idx)));

                ReleaseMutex(hCPSUIMutex);
                Ok = TRUE;

            } else {

                CPSUIERR(("The Thread ID does not match=%ld",
                            CPSUIHandleTable.ThreadID));
            }

        } else {

            CPSUIERR(("The ThreadID=%ld does not own the mutex", ThreadID));
        }
    }

    return(Ok);
}




PCPSUIPAGE
HANDLETABLE_GetCPSUIPage(
    HANDLE      hTable
    )

/*++

Routine Description:

    This function take a handle table and return the pData assoicated with it,
    the pData must already added by HANDLETABLE_AddCPSUIPage()


Arguments:




Return Value:

    pCPSUIPage, NULL if FAILED


Author:

    28-Dec-1995 Thu 17:05:11 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDATATABLE  pDataTable;
    PCPSUIPAGE  pFoundPage = NULL;
    PCPSUIPAGE  pCPSUIPage;
    WORD        Idx;


    LOCK_CPSUI_HANDLETABLE();

    if ((hTable)                                                    &&
        (pDataTable = CPSUIHandleTable.pDataTable)                  &&
        (HANDLE_2_PREFIX(hTable) == HANDLE_TABLE_PREFIX)            &&
        ((Idx = HANDLE_2_IDX(hTable)) < CPSUIHandleTable.MaxCount)  &&
        (pCPSUIPage = pDataTable[Idx].pCPSUIPage)) {

        if (pCPSUIPage->ID != CPSUIPAGE_ID) {

            CPSUIERR(("HANDLETABLE_FindpCPSUIPage(%08lx), pCPSUIPage=%08lx INVALID Internal ID",
                        hTable, pCPSUIPage));

        } else if (pCPSUIPage->hCPSUIPage != hTable) {

            CPSUIERR(("HANDLETABLE_FIndpCPSUIPage(%08lx), pCPSUIPagePage=%08lx, HANDLE not matched",
                    hTable, pCPSUIPage));

        } else {

            pCPSUIPage->cLock++;
            pFoundPage = pCPSUIPage;
        }
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(pFoundPage);
}



DWORD
HANDLETABLE_LockCPSUIPage(
    PCPSUIPAGE  pCPSUIPage
    )

/*++

Routine Description:

    This function decrement the cLock for the Page currently in USE


Arguments:

    pCPSUIPage  - Pointer to the CPSUIPAGE


Return Value:

    BOOL, true if decrment successfully


Author:

    05-Apr-1996 Fri 16:41:46 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    DWORD   cLock = 0;


    if (pCPSUIPage) {

        LOCK_CPSUI_HANDLETABLE();

        cLock = ++(pCPSUIPage->cLock);

        UNLOCK_CPSUI_HANDLETABLE();
    }

    return(cLock);
}



BOOL
HANDLETABLE_UnGetCPSUIPage(
    PCPSUIPAGE  pCPSUIPage
    )

/*++

Routine Description:

    This function decrement the cLock for the Page currently in USE


Arguments:

    pCPSUIPage  - Pointer to the CPSUIPAGE


Return Value:

    BOOL, true if decrment successfully


Author:

    05-Apr-1996 Fri 16:41:46 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL    Ok;


    if (pCPSUIPage) {

        LOCK_CPSUI_HANDLETABLE();

        if (Ok = (BOOL)pCPSUIPage->cLock) {

            --(pCPSUIPage->cLock);

        } else {

            CPSUIERR(("HANDLETABLE_UnlockpCPSUIPage(%08lx), cLock is ZERO",
                            pCPSUIPage));
        }

        UNLOCK_CPSUI_HANDLETABLE();

    } else {

        Ok = FALSE;
    }

    return(Ok);
}



BOOL
HANDLETABLE_IsChildPage(
    PCPSUIPAGE  pChildPage,
    PCPSUIPAGE  pParentPage
    )

/*++

Routine Description:

    This function check if pChildPage is one of the pParentPage's child or
    its decedent child


Arguments:

    pChildPage  - Pointer to the CPSUIPAGE for child

    pParentPage - Pointer to the CPSUIPAGE for parent to be checked

Return Value:

    TRUE, if this is child, otherwise FALSE


Author:

    08-Apr-1996 Mon 12:52:51 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    BOOL    Ok = FALSE;


    LOCK_CPSUI_HANDLETABLE();


    if (pChildPage) {

        while (pChildPage->pParent) {

            if (pChildPage->pParent == pParentPage) {

                Ok = TRUE;
                break;

            } else {

                pChildPage = pChildPage->pParent;
            }
        }
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(Ok);
}






PCPSUIPAGE
HANDLETABLE_GetRootPage(
    PCPSUIPAGE  pCPSUIPage
    )

/*++

Routine Description:

    This function find the root page for pCPSUIPage

Arguments:

    pCPSUIPage  - Pointer to the CPSUIPAGE who's root page to be searched


Return Value:

    PCPSUIPAGE  - Pointer to root page, NULL if failed


Author:

    08-Apr-1996 Mon 12:49:42 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PCPSUIPAGE  pPage;
    PCPSUIPAGE  pRootPage = NULL;


    LOCK_CPSUI_HANDLETABLE();


    pPage = pCPSUIPage;

    //
    // If we need to search for the root page, then try it now
    //

    while ((pPage) && (pPage->pParent)) {

        pPage = pPage->pParent;
    }

    if ((pPage) && (pPage->Flags & CPF_ROOT)) {

        pPage->cLock++;
        pRootPage = pPage;

    } else {

        CPSUIERR(("HANDLETABLE_FindpRootPage(%08lx): No ROOT Page found",
                    pCPSUIPage));
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(pRootPage);
}




HANDLE
HANDLETABLE_AddCPSUIPage(
    PCPSUIPAGE  pCPSUIPage
    )

/*++

Routine Description:

    This function add pData to the handle table, if new


Arguments:

    pCPSUIPage  - Pointer to the CPSUIPAGE to be add to the handle table


Return Value:

    HANDLE, if NULL then it failed, the handle already exists


Author:

    28-Dec-1995 Thu 16:03:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HANDLE      hTable;
    PDATATABLE  pDataTable;


    LOCK_CPSUI_HANDLETABLE();

    if ((!CPSUIHandleTable.pDataTable) ||
        (CPSUIHandleTable.CurCount >= CPSUIHandleTable.MaxCount)) {

        if (!CPSUIHandleTable.pDataTable) {

            CPSUIHandleTable.CurCount =
            CPSUIHandleTable.MaxCount = 0;
        }

        CPSUIDBG(DBG_ADD_DATA,
                ("HANDLETABLE_AddCPSUIPage(%08lx): Table reach LIMIT, Expanded=%ld->%ld",
                CPSUIHandleTable.pDataTable,
                CPSUIHandleTable.CurCount,
                CPSUIHandleTable.CurCount + DATATABLE_BLK_COUNT));

        //
        // Reallocate Table
        //

        if ((CPSUIHandleTable.MaxCount <= DATATABLE_MAX_COUNT)  &&
            (pDataTable = LocalAlloc(LPTR,
                                    (CPSUIHandleTable.MaxCount +
                                                DATATABLE_BLK_COUNT) *
                                                        sizeof(DATATABLE)))) {

            if (CPSUIHandleTable.pDataTable) {

                CopyMemory(pDataTable,
                           CPSUIHandleTable.pDataTable,
                           CPSUIHandleTable.MaxCount * sizeof(DATATABLE));

                LocalFree((HLOCAL)CPSUIHandleTable.pDataTable);
            }

            CPSUIHandleTable.pDataTable  = pDataTable;
            CPSUIHandleTable.MaxCount   += DATATABLE_BLK_COUNT;

        } else {

            CPSUIERR(("HANDLETABLE_AddCPSUIPage(): Expand TABLE failed"));
        }
    }

    hTable = NULL;

    if (pDataTable = CPSUIHandleTable.pDataTable) {

        WORD    Idx;

        for (Idx = 0; Idx < CPSUIHandleTable.MaxCount; Idx++, pDataTable++) {

            if (!pDataTable->pCPSUIPage) {

                hTable                 = WORD_2_HANDLE(Idx);
                pDataTable->pCPSUIPage = pCPSUIPage;
                pCPSUIPage->cLock      = 1;

                CPSUIHandleTable.CurCount++;

                CPSUIDBG(DBG_ADD_DATA, ("HANDLETABLE_AddCPSUIPage(%08lx): Idx=%ld, Cur=%ld, Max=%ld",
                            pCPSUIPage, Idx,
                            CPSUIHandleTable.CurCount,
                            CPSUIHandleTable.MaxCount));

                break;

            } else if (pDataTable->pCPSUIPage == pCPSUIPage) {

                CPSUIERR(("HANDLETABLE_AddCPSUIPage(%08lx): pCPSUIPage exists, Idx=%ld",
                            pCPSUIPage, Idx));
            }
        }
    }

    if (!hTable) {

        CPSUIERR(("HANDLETABLE_AddCPSUIPage(%08lx:%ld) Cannot find empty entry",
                CPSUIHandleTable.pDataTable,
                CPSUIHandleTable.MaxCount));
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(hTable);
}




BOOL
HANDLETABLE_DeleteHandle(
    HANDLE  hTable
    )

/*++

Routine Description:

    This function delete a handle from the handle table


Arguments:

    hTable  - Handle to the handle table to be deleted


Return Value:

    BOOL


Author:

    28-Dec-1995 Thu 17:42:42 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDATATABLE  pDataTable;
    PCPSUIPAGE  pCPSUIPage;
    WORD        Idx;
    BOOL        Ok = FALSE;


    LOCK_CPSUI_HANDLETABLE();

    if ((pDataTable = CPSUIHandleTable.pDataTable)                  &&
        (HANDLE_2_PREFIX(hTable) == HANDLE_TABLE_PREFIX)            &&
        (CPSUIHandleTable.CurCount)                                 &&
        ((Idx = HANDLE_2_IDX(hTable)) < CPSUIHandleTable.MaxCount)  &&
        (pCPSUIPage = (pDataTable += Idx)->pCPSUIPage)) {

        if (pCPSUIPage->cLock) {

            CPSUIERR(("HANDLETABLE_DeleteHandle(%08lx), pCPSUIPage=%08lx, cLock=%ld",
                        hTable, pCPSUIPage, pCPSUIPage->cLock));

        } else {

            // check to release the activation context (if any)
            if (pCPSUIPage->hActCtx && pCPSUIPage->hActCtx != INVALID_HANDLE_VALUE) {

                ReleaseActCtx(pCPSUIPage->hActCtx);
                pCPSUIPage->hActCtx = INVALID_HANDLE_VALUE;
            }

            pDataTable->pCPSUIPage = NULL;
            Ok                     = TRUE;

            //
            // Reduce current count and free the memory
            //

            CPSUIHandleTable.CurCount--;

            LocalFree((HLOCAL)pCPSUIPage);
        }

    } else {

        CPSUIERR(("HANDLETABLE_DeleteHandle(%08lx) not found, Idx=%ld, pDataTable=%08lx",
                        hTable, Idx, pDataTable));
    }

    UNLOCK_CPSUI_HANDLETABLE();

    return(Ok);
}




BOOL
HANDLETABLE_Create(
    VOID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    28-Dec-1995 Thu 16:46:27 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    CPSUIHandleTable.pDataTable = NULL;
    CPSUIHandleTable.MaxCount   =
    CPSUIHandleTable.CurCount   = 0;
    CPSUIHandleTable.ThreadID   = NO_THREADID;
    CPSUIHandleTable.cWait      = 0;

    if (hCPSUIMutex = CreateMutex(NULL, FALSE, NULL)) {

        CPSUIDBG(DBG_CPSUI_HTABLE, ("CREATE: CreateMutex=%08lx", hCPSUIMutex));

        return(TRUE);

    } else {

        CPSUIERR(("CreateMutex() FAILED, Exit"));
        return(FALSE);
    }
}



VOID
HANDLETABLE_Destroy(
    VOID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    28-Dec-1995 Thu 16:48:32 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PDATATABLE  pDataTable;
    WORD        Idx;

    LOCK_CPSUI_HANDLETABLE();

    if (hCPSUIMutex) {

        if (pDataTable = CPSUIHandleTable.pDataTable) {

            for (Idx = 0;
                 Idx < CPSUIHandleTable.MaxCount;
                 Idx++, pDataTable++) {

                if (pDataTable->pCPSUIPage) {

                    CPSUIERR(("HANDLETABLE_Destroy: Idx=%ld, pPage=%08lx, cLock=%ld is not delete yet",
                                    Idx, pDataTable->pCPSUIPage, pDataTable->pCPSUIPage->cLock));

                    LocalFree((HLOCAL)pDataTable->pCPSUIPage);

                    pDataTable->pCPSUIPage = NULL;

                    if (CPSUIHandleTable.CurCount) {

                        --(CPSUIHandleTable.CurCount);

                    } else {

                        CPSUIERR(("HANDLETABLE_Destroy(): Unmatched CurCount"));
                    }
                }
            }

            LocalFree((HLOCAL)CPSUIHandleTable.pDataTable);

            CPSUIHandleTable.pDataTable = NULL;
            CPSUIHandleTable.MaxCount   =
            CPSUIHandleTable.CurCount   = 0;
        }
    }

    UNLOCK_CPSUI_HANDLETABLE();

    CloseHandle(hCPSUIMutex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\dlgctrl.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    dlgctrl.h


Abstract:

    This module contains predefines and prototypes for the dialog box control
    for the commoon UI


Author:

    28-Aug-1995 Mon 12:14:51 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#define CTRLS_FIRST             0x80
#define CTRLS_RADIO             0x80
#define CTRLS_UDARROW           0x81
#define CTRLS_UDARROW_EDIT      0x82
#define CTRLS_TRACKBAR          0x83
#define CTRLS_HSCROLL           0x84
#define CTRLS_VSCROLL           0x85
#define CTRLS_LISTBOX           0x86
#define CTRLS_COMBOBOX          0x87
#define CTRLS_EDITBOX           0x88
#define CTRLS_PUSHBUTTON        0x89
#define CTRLS_CHKBOX            0x8a
#define CTRLS_EXTCHKBOX         0x8b
#define CTRLS_EXTPUSH           0x8c
#define CTRLS_TV_WND            0x8d
#define CTRLS_TV_STATIC         0x8e
#define CTRLS_PROPPAGE_STATIC   0x8f
#define CTRLS_PROPPAGE_ICON     0x90
#define CTRLS_ECBICON           0x91
#define CTRLS_NOINPUT           0x92
#define CTRLS_LAST              0x92


#define INITCF_ENABLE           0x0001
#define INITCF_INIT             0x0002
#define INITCF_SETCTRLDATA      0x0004
#define INITCF_ADDSELPOSTFIX    0x0008
#define INITCF_ICON_NOTIFY      0x0010
#define INITCF_HAS_EXT          0x0020
#define INITCF_TVDLG            0x0040

#define CTRLDATA_ITEMIDX_ADD    11

#define SETCTRLDATA(hCtrl, CtrlStyle, CtrlData)                             \
{                                                                           \
    SetWindowLongPtr((hCtrl),                                               \
                     GWLP_USERDATA,                                         \
                     (LPARAM)MAKELONG(MAKEWORD((CtrlData),(CtrlStyle)),     \
                                      (InitItemIdx+CTRLDATA_ITEMIDX_ADD))); \
}

#define HCTRL_SETCTRLDATA(hCtrl, CtrlStyle, CtrlData)                       \
{                                                                           \
    if ((hCtrl) && (InitFlags & INITCF_SETCTRLDATA)) {                      \
                                                                            \
        SETCTRLDATA(hCtrl, CtrlStyle, CtrlData);                            \
    }                                                                       \
}

#define GETCTRLITEMIDX(dw)      (HIWORD(dw)-CTRLDATA_ITEMIDX_ADD)
#define GETCTRLDATA(dw,i,s,d)   (i)=GETCTRLITEMIDX(dw);                     \
                                (d)=LOBYTE(LOWORD(dw));(s)=HIBYTE(LOWORD(dw))

#define REAL_ECB_CHECKED(pItem, pECB)                                       \
    (BOOL)(((pECB) = (pItem)->pExtChkBox)               &&                  \
           (((pItem)->Flags & (OPTIF_EXT_HIDE | OPTIF_EXT_IS_EXTPUSH |      \
                                OPTIF_ECB_CHECKED)) == OPTIF_ECB_CHECKED))


#define INIT_EXTENDED(pTVWnd,hDlg,pItem,ecbID,epID,IconID,Idx,InitFlags)    \
    ((pItem->Flags & OPTIF_EXT_IS_EXTPUSH) ?                                \
        InitExtPush(pTVWnd,hDlg,pItem,ecbID,epID,IconID,Idx,InitFlags) :    \
        InitExtChkBox(pTVWnd,hDlg,pItem,ecbID,epID,IconID,Idx,InitFlags))


typedef struct _DLGIDINFO {
    HWND        hDlg;
    DWORD       CurID;
    } DLGIDINFO, *PDLGIDINFO;

//
// Prototypes
//

VOID
SetUniqChildID(
    HWND    hDlg
    );

BOOL
hCtrlrcWnd(
    HWND    hDlg,
    HWND    hCtrl,
    RECT    *prc
    );

HWND
CtrlIDrcWnd(
    HWND    hDlg,
    UINT    CtrlID,
    RECT    *prc
    );

BOOL
ChkEditKEYDOWN(
    HWND    hWnd,
    WPARAM  VKey
    );

BOOL
ChkhWndEdit0KEYDOWN(
    HWND    hWnd,
    WPARAM  VKey
    );

DWORD
ReCreateLBCB(
    HWND    hDlg,
    UINT    CtrlID,
    BOOL    IsLB
    );

HWND
CreateTrackBar(
    HWND    hDlg,
    UINT    TrackBarID
    );

HWND
CreateUDArrow(
    HWND    hDlg,
    UINT    EditBoxID,
    UINT    UDArrowID,
    LONG    RangeL,
    LONG    RangeH,
    LONG    Pos
    );

BOOL
SetDlgPageItemName(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem,
    UINT        InitFlags,
    UINT        UDArrowHelpID
    );

BOOL
InitExtPush(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        ExtChkBoxID,
    UINT        ExtPushID,
    UINT        ExtIconID,
    WORD        InitItemIdx,
    WORD        InitFlags
    );

BOOL
InitExtChkBox(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        ExtChkBoxID,
    UINT        ExtPushID,
    UINT        ExtIconID,
    WORD        InitItemIdx,
    WORD        InitFlags
    );

UINT
InitStates(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    POPTTYPE    pOptType,
    UINT        IDState1,
    WORD        InitItemIdx,
    LONG        NewSel,
    WORD        InitFlags
    );

LONG
InitUDArrow(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    POPTPARAM   pOptParam,
    UINT        UDArrowID,
    UINT        EditBoxID,
    UINT        PostfixID,
    UINT        HelpID,
    WORD        InitItemIdx,
    LONG        NewPos,
    WORD        InitFlags
    );

VOID
InitTBSB(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    HWND        hTBSB,
    POPTTYPE    pOptType,
    UINT        PostfixID,
    UINT        RangeLID,
    UINT        RangeHID,
    WORD        InitItemIdx,
    LONG        NewPos,
    WORD        InitFlags
    );

VOID
InitLBCB(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        idLBCB,
    UINT        SetCurSelID,
    POPTTYPE    pOptType,
    WORD        InitItemIdx,
    LONG        NewSel,
    WORD        InitFlags,
    UINT        cyLBCBMax
    );

VOID
InitEditBox(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    POPTPARAM   pOptParam,
    UINT        EditBoxID,
    UINT        PostfixID,
    UINT        HelpID,
    WORD        InitItemIdx,
    LPTSTR      pCurText,
    WORD        InitFlags
    );

VOID
InitPushButton(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    WORD        PushID,
    WORD        InitItemIdx,
    WORD        InitFlags
    );

VOID
InitChkBox(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        ChkBoxID,
    LPTSTR      pTitle,
    WORD        InitItemIdx,
    BOOL        Checked,
    WORD        InitFlags
    );

LONG
DoCallBack(
    HWND                hDlg,
    PTVWND              pTVWnd,
    POPTITEM            pItem,
    LPVOID              pOldSel,
    _CPSUICALLBACK      pfnCallBack,
    HANDLE              hDlgTemplate,
    WORD                DlgTemplateID,
    WORD                Reason
    );

POPTITEM
pItemFromhWnd(
    HWND    hDlg,
    PTVWND  pTVWnd,
    HWND    hCtrl,
    LONG    MousePos
    );

VOID
DoContextMenu(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    LPARAM      Pos
    );

UINT
UpdateInternalDMPUB(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem
    );

VOID
UpdateOptTypeIcon16(
    POPTTYPE    pOptType
    );

BOOL
DrawLBCBItem(
    PTVWND              pTVWnd,
    LPDRAWITEMSTRUCT    pdis
    );

POPTITEM
DlgHScrollCommand(
    HWND    hDlg,
    PTVWND  pTVWnd,
    HWND    hCtrl,
    WPARAM  wParam
    );


LONG
UpdateCallBackChanges(
    HWND    hDlg,
    PTVWND  pTVWnd,
    BOOL    ReInit
    );

BOOL
DoAbout(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItemRoot
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\dlgctrl.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    dlgctrl.c


Abstract:

    This module contains most of dialog control update procedures


Author:

    24-Aug-1995 Thu 19:42:09 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop


#define DBG_CPSUIFILENAME   DbgDlgCtrl



#define DBG_CTB             0x00000001
#define DBG_CUDA            0x00000002
#define DBG_INITTBSB        0x00000004
#define DBG_UCBC            0x00000008
#define DBG_DOCB            0x00000010
#define DBG_DOPB            0x00000020
#define DBG_CS              0x00000040
#define DBG_INITLBCB        0x00000080
#define DBGITEM_CB          0x00000100
#define DBGITEM_PUSH        0x00000200
#define DBGITEM_CS          0x00000400
#define DBG_UDARROW         0x00000800
#define DBG_HELP            0x00001000
#define DBG_FNLC            0x00002000
#define DBG_CLBCB           0x00004000
#define DBG_IFW             0x00008000
#define DBG_SCID            0x00010000
#define DBG_VALIDATE_UD     0x00020000
#define DBG_CB_CY           0x00040000
#define DBG_FOCUS           0x00080000
#define DBG_CBWNDPROC       0x00100000
#define DBG_TMP             0x80000000

DEFINE_DBGVAR(0);

#define SPSF_USE_BUTTON_CY      0x0001
#define SPSF_ALIGN_EXTPUSH      0x0002


#define PUSH_CY_EXTRA           12
#define PUSH_CX_EXTRA_W         2
#define ICON16_CX_SPACE         6

#define LBCBID_DISABLED         0x80000000L
#define LBCBID_FILL             0x40000000L
#define LBCBID_NONE             0x20000000L


#define INTDMPUB_CHANGED        0x0001
#define INTDMPUB_REINIT         0x0002

//
// Following EDF_xxx is used     for Up-Down-Arrow control
//

#define EDF_MINUS_OK            0x80
#define EDF_IN_TVPAGE           0x40
#define EDF_NUMBERS             0x20
#define EDF_BACKSPACE           0x10
#define EDF_BEGIDXMASK          0x07

#define EDF_STATIC_MASK         (EDF_MINUS_OK | EDF_IN_TVPAGE)

#define MAX_UDARROW_TEXT_LEN    7


extern HINSTANCE    hInstDLL;
extern BYTE         cTVOTCtrls[];
extern OPTTYPE      OptTypeHdrPush;
extern EXTPUSH      ExtPushAbout;
extern BYTE         cTVOTCtrls[];


typedef struct _ABOUTINFO {
    PTVWND      pTVWnd;
    HICON       hIcon;
    LPARAM      Pos;
    } ABOUTINFO, *PABOUTINFO;


typedef struct _ABOUTPOS {
    _CPSUICALLBACK  pfnCallBack;
    PCPSUICBPARAM   pCBParam;
    HWND            hFocus;
    LPARAM          Pos;
    } ABOUTPOS, *PABOUTPOS;


extern
LONG
APIENTRY
HTUI_ColorAdjustmentA(
    LPSTR               pDeviceName,
    HANDLE              hDIB,
    LPSTR               pDIBTitle,
    PCOLORADJUSTMENT    pca,
    BOOL                ShowMonoOnly,
    BOOL                UpdatePermission
    );

extern
LONG
APIENTRY
HTUI_ColorAdjustmentW(
    LPWSTR              pDeviceName,
    HANDLE              hDIB,
    LPWSTR              pDIBTitle,
    PCOLORADJUSTMENT    pca,
    BOOL                ShowMonoOnly,
    BOOL                UpdatePermission
    );

extern
LONG
APIENTRY
HTUI_DeviceColorAdjustmentA(
    LPSTR           pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    );

extern
LONG
APIENTRY
HTUI_DeviceColorAdjustmentW(
    LPWSTR          pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    );


#define IS_TVDLG    (InitFlags & INITCF_TVDLG)

#define SHOWCTRL(hCtrl, Enable, swMode)                                     \
{                                                                           \
    EnableWindow(hCtrl, (Enable) && (InitFlags & INITCF_ENABLE));           \
    ShowWindow(hCtrl, (swMode));                                            \
}

#define SETCTRLTEXT(hCtrl, pTitle)                                          \
{                                                                           \
    GSBUF_RESET; GSBUF_GETSTR(pTitle);                                      \
    SetWindowText(hCtrl, GSBUF_BUF);                                        \
}


#define GETHCTRL(i)                                                         \
    if (i) { hCtrl=GetDlgItem(hDlg,(i)); } else { hCtrl=NULL; }
#define HCTRL_TEXT(h,p)     if (h) { SETCTRLTEXT(h,(p)); }
#define HCTRL_STATE(h,e,m)  if (h) { SHOWCTRL((h),(e),(m)); }

#define HCTRL_TEXTSTATE(hCtrl, pTitle, Enable, swMode)                      \
{                                                                           \
    if (hCtrl) {                                                            \
                                                                            \
        SETCTRLTEXT(hCtrl, (pTitle));                                       \
        SHOWCTRL(hCtrl, (Enable), (swMode));                                \
    }                                                                       \
}

#define ID_TEXTSTATE(i,p,e,m)   GETHCTRL(i); HCTRL_TEXTSTATE(hCtrl,p,e,m)

#define SET_EXTICON(IS_ECB)                                                 \
{                                                                           \
    BOOL    swIcon = swMode;                                                \
                                                                            \
    if ((!(hCtrl2 = GetDlgItem(hDlg, ExtIconID)))   ||                      \
        ((!IconResID) && (!(IconMode & MIM_MASK)))) {                       \
                                                                            \
         swIcon = SW_HIDE;                                                  \
         Enable = FALSE;                                                    \
    }                                                                       \
                                                                            \
    HCTRL_STATE(hCtrl2, Enable, swIcon);                                    \
    HCTRL_SETCTRLDATA(hCtrl2, CTRLS_ECBICON, 0xFF);                         \
                                                                            \
    if (swIcon == SW_SHOW) {                                                \
                                                                            \
        SetIcon(_OI_HINST(pItem),                                           \
                hCtrl2,                                                     \
                IconResID,                                                  \
                MK_INTICONID(0, IconMode),                                  \
                (IS_TVDLG) ? pTVWnd->cxcyECBIcon : 32);                     \
    }                                                                       \
                                                                            \
    if (IS_ECB) {                                                           \
                                                                            \
        if (hCtrl2) {                                                       \
                                                                            \
            DWORD   dw = (DWORD)GetWindowLongPtr(hCtrl2, GWL_STYLE);        \
                                                                            \
            if ((swIcon == SW_SHOW) &&                                      \
                (Enable)            &&                                      \
                (InitFlags & INITCF_ENABLE)) {                              \
                                                                            \
                dw |= SS_NOTIFY;                                            \
                                                                            \
            } else {                                                        \
                                                                            \
                dw &= ~SS_NOTIFY;                                           \
            }                                                               \
                                                                            \
            SetWindowLongPtr(hCtrl2, GWL_STYLE, dw);                        \
        }                                                                   \
    }                                                                       \
                                                                            \
    return((BOOL)(swMode == SW_SHOW));                                      \
}


static  const CHAR szHTUIClrAdj[]    = "HTUI_ColorAdjustmentW";
static  const CHAR szHTUIDevClrAdj[] = "HTUI_DeviceColorAdjustmentW";


BOOL
CALLBACK
SetUniqChildIDProc(
    HWND    hWnd,
    LPARAM  lParam
    )
{
    DWORD   dw;
    UINT    DlgID;


    if (GetWindowLongPtr(hWnd, GWLP_ID)) {

        CPSUIDBG(DBG_SCID, ("The hWnd=%08lx has GWLP_ID=%ld, CtrlID=%ld",
                hWnd, GetWindowLongPtr(hWnd, GWLP_ID), GetDlgCtrlID(hWnd)));

    } else {

        HWND        hCtrl;
        DLGIDINFO   DlgIDInfo = *(PDLGIDINFO)lParam;

        while (hCtrl = GetDlgItem(DlgIDInfo.hDlg, DlgIDInfo.CurID)) {

            CPSUIDBG(DBG_SCID, ("The ID=%ld is used by hCtrl=%08lx",
                                DlgIDInfo.CurID, hCtrl));

            --DlgIDInfo.CurID;
        }

        SetWindowLongPtr(hWnd, GWLP_ID, (LONG)DlgIDInfo.CurID);

        CPSUIDBG(DBG_SCID, ("The hWnd=%08lx, GWLP_ID set to %ld",
                            hWnd, DlgIDInfo.CurID));
    }

    return(TRUE);
}



VOID
SetUniqChildID(
    HWND    hDlg
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Nov-1995 Wed 15:40:38 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    DLGIDINFO   DlgIDInfo;

    DlgIDInfo.hDlg  = hDlg;
    DlgIDInfo.CurID = 0xFFFF;

    EnumChildWindows(hDlg, SetUniqChildIDProc, (LPARAM)&DlgIDInfo);
}




BOOL
hCtrlrcWnd(
    HWND    hDlg,
    HWND    hCtrl,
    RECT    *prc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Sep-1995 Sun 07:34:41 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    if (hCtrl) {

        GetWindowRect(hCtrl, prc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)prc, 2);
        return(TRUE);

    } else {

        return(FALSE);
    }
}



HWND
CtrlIDrcWnd(
    HWND    hDlg,
    UINT    CtrlID,
    RECT    *prc
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Sep-1995 Sun 07:34:41 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;

    if ((CtrlID) && (hCtrl = GetDlgItem(hDlg, CtrlID))) {

        GetWindowRect(hCtrl, prc);
        MapWindowPoints(NULL, hDlg, (LPPOINT)prc, 2);

        return(hCtrl);

    } else {

        return(NULL);
    }
}




BOOL
ChkhWndEdit0KEYDOWN(
    HWND    hWnd,
    WPARAM  VKey
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Aug-1998 Thu 11:13:41 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTVWND  pTVWnd;


    switch (VKey) {

    case VK_LEFT:
    case VK_BACK:
    case VK_RIGHT:

        if (pTVWnd = (PTVWND)GetProp(hWnd, CPSUIPROP_PTVWND)) {

            switch (VKey) {

            case VK_LEFT:
            case VK_BACK:

                if ((pTVWnd->hWndTV) &&
                    (GetDlgCtrlID(pTVWnd->hWndTV) == IDD_TV_WND)) {

                    SetFocus(pTVWnd->hWndTV);
                    return(TRUE);
                }

                break;

            case VK_RIGHT:

                if (hWnd = pTVWnd->hWndEdit[1]) {

                    SetFocus(hWnd);
                }

                return(TRUE);
            }
        }

        break;
    }

    return(FALSE);
}



LRESULT
CALLBACK
MyCBWndProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    This is the subclass WNDPROC for the numberical edit control, it check
    valid input for the number entered.


Arguments:

    WNDPROC standard


Return Value:

    INT (The original WNDPROC returned), if the entered keys are not valid
    then it return right away without processing


Author:

    20-Mar-1996 Wed 15:36:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hDlg;
    PTVWND      pTVWnd;
    HWND        hWndTV;
    LONG_PTR    SelIdx;
    WNDPROC     OldWndProc;


    if (OldWndProc = (WNDPROC)GetProp(hWnd, CPSUIPROP_WNDPROC)) {

        switch (Msg) {

        case WM_KEYDOWN:

            CPSUIDBG(DBG_CBWNDPROC,
                     ("MyCBWndProc: WM_KEYDOWN, VKey=%ld", wParam));

            if (SendMessage(hWnd, CB_GETDROPPEDSTATE, 0, 0)) {

                //
                // When user hit escape during the drop down box open AND
                // the selection did changed, then we post message to change
                // the selection back to original and post a selection
                // change message (POST since this will be done after CLOSEUP)
                //

                if ((wParam == VK_ESCAPE)                               &&
                    (SelIdx = (LONG_PTR)GetProp(hWnd, CPSUIPROP_CBPRESEL))  &&
                    ((SelIdx - 1) != SendMessage(hWnd, CB_GETCURSEL, 0, 0))) {

                    CPSUIDBG(DBG_CBWNDPROC,
                         ("MyCBWndProc: ESCAPE: Restore SEL from %ld to %ld",
                                (DWORD)SendMessage(hWnd, CB_GETCURSEL, 0, 0),
                                SelIdx - 1));

                    PostMessage(hWnd, CB_SETCURSEL, (WPARAM)(SelIdx - 1), 0L);
                    PostMessage(GetParent(hWnd),
                                WM_COMMAND,
                                MAKEWPARAM(GetDlgCtrlID(hWnd), CBN_SELCHANGE),
                                (LPARAM)hWnd);
                    break;
                }

            } else if (ChkhWndEdit0KEYDOWN(hWnd, wParam)) {

                return(0);
            }

            break;

        case WM_DESTROY:

            CPSUIDBG(DBG_CBWNDPROC, ("MyCBWndProc: WM_DESTROY"));

            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LPARAM)OldWndProc);
            RemoveProp(hWnd, CPSUIPROP_WNDPROC);
            RemoveProp(hWnd, CPSUIPROP_PTVWND);
            RemoveProp(hWnd, CPSUIPROP_CBPRESEL);

            break;

        default:

            break;
        }

        return(CallWindowProc(OldWndProc, hWnd, Msg, wParam, lParam));

    } else {

        CPSUIERR(("MyCBWndProc: GetProc(%08lx) FAILED", hWnd));

        return(0);
    }
}



DWORD
ReCreateLBCB(
    HWND    hDlg,
    UINT    CtrlID,
    BOOL    IsLB
    )

/*++

Routine Description:

    This functon create a new listbox/combobox which has same control ID and
    size of the original one except with the owner draw item

Arguments:

    hDlg    - Handle to the dialog

    CtrlID  - The original control ID for the LB/CB

    IsLB    - True if this is a List box


Return Value:


    BOOL


Author:

    12-Sep-1995 Tue 00:23:17 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hLBCB;
    WORD    cxRet = 0;
    WORD    cyRet = 0;
    RECT    rc;


    if (hLBCB = CtrlIDrcWnd(hDlg, CtrlID, &rc)) {

        HWND    hNewLBCB;
        DWORD   dw;
        RECT    rcDrop;
        WORD    cxSize;
        WORD    cySize;
        BOOL    SetExtUI = FALSE;


        CPSUIDBG(DBG_CLBCB, ("Dropped=(%ld, %ld)-(%ld, %ld), %ld x %ld",
                            rc.left, rc.top, rc.right, rc.bottom,
                            rc.right - rc.left, rc.bottom - rc.top));

        dw = (DWORD)(GetWindowLongPtr(hLBCB, GWL_STYLE) |
                     (WS_VSCROLL | WS_GROUP | WS_TABSTOP | WS_BORDER));

        if ((!IsLB) && (dw & (CBS_DROPDOWNLIST | CBS_DROPDOWN))) {

            SetExtUI = TRUE;

            CPSUIDBG(DBG_TMP, ("Original CB Edit CY=%ld",
                                (LONG)SendMessage(hLBCB,
                                                  CB_GETITEMHEIGHT,
                                                  (WPARAM)-1,
                                                  0)));

            SendMessage(hLBCB, CB_SETEXTENDEDUI, (WPARAM)TRUE, 0L);
            SendMessage(hLBCB, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)&rcDrop);

            CPSUIDBG(DBG_CLBCB, ("Dropped=(%ld, %ld)-(%ld, %ld), %ld x %ld",
                    rcDrop.left, rcDrop.top, rcDrop.right, rcDrop.bottom,
                    rcDrop.right - rcDrop.left, rcDrop.bottom - rcDrop.top));

            rc.bottom += (rcDrop.bottom - rcDrop.top) * 2;
        }

        cxSize = (WORD)(rc.right - rc.left);
        cySize = (WORD)(rc.bottom - rc.top);

        CPSUIDBG(DBG_CLBCB, ("%ws: cxSize=%ld, cySize=%ld",
                (IsLB) ? L"ListBox" : L"ComboBox", cxSize, cySize));

        if (IsLB) {

            dw &= ~LBS_OWNERDRAWVARIABLE;
            dw |= (LBS_OWNERDRAWFIXED       |
                    LBS_HASSTRINGS          |
                    LBS_SORT                |
                    LBS_NOINTEGRALHEIGHT);

        } else {

            dw &= ~(CBS_OWNERDRAWVARIABLE | CBS_NOINTEGRALHEIGHT);
            dw |= (CBS_OWNERDRAWFIXED | CBS_HASSTRINGS | CBS_SORT);
        }

        CPSUIDBG(DBG_CLBCB, ("dwStyle=%08lx", dw));

        if (hNewLBCB = CreateWindowEx(WS_EX_NOPARENTNOTIFY | WS_EX_CLIENTEDGE,
                                      (IsLB) ? L"listbox" : L"combobox",
                                      L"",
                                      dw | WS_CHILD | WS_TABSTOP | WS_GROUP,
                                      rc.left,
                                      rc.top,
                                      rc.right - rc.left,
                                      cySize,
                                      hDlg,
                                      (HMENU)UIntToPtr(CtrlID),
                                      hInstDLL,
                                      0)) {

            SetWindowPos(hNewLBCB,
                         hLBCB,
                         0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);

            SendMessage(hNewLBCB,
                        WM_SETFONT,
                        (WPARAM)SendMessage(hLBCB, WM_GETFONT, 0, 0),
                        TRUE);

            if (SetExtUI) {

                SendMessage(hNewLBCB, CB_SETEXTENDEDUI, (WPARAM)TRUE, 0L);
            }

            DestroyWindow(hLBCB);

            if ((hLBCB = GetDlgItem(hDlg, CtrlID)) == hNewLBCB) {

                cxRet = (WORD)((GetSystemMetrics(SM_CXFIXEDFRAME) * 2) +
                               (GetSystemMetrics(SM_CXEDGE      ) * 2) +
                               (GetSystemMetrics(SM_CXVSCROLL)));

                CPSUIDBG(DBG_CLBCB, ("SM_CXFIXEDFRAME=%ld, SM_CXEDGE=%ld, SM_CXVSCROLL=%ld",
                            GetSystemMetrics(SM_CXFIXEDFRAME),
                            GetSystemMetrics(SM_CXEDGE      ),
                            GetSystemMetrics(SM_CXVSCROLL)));

                if (!IsLB) {

                    WNDPROC OldWndProc;

                    OldWndProc = (WNDPROC)GetWindowLongPtr(hLBCB, GWLP_WNDPROC);

                    if ((ULONG_PTR)OldWndProc != (ULONG_PTR)MyCBWndProc) {

                        SetProp(hLBCB, CPSUIPROP_WNDPROC, (HANDLE)OldWndProc);
                        SetProp(hLBCB,
                                CPSUIPROP_PTVWND,
                                (HANDLE)GET_PTVWND(hDlg));
                        SetWindowLongPtr(hLBCB,
                                         GWLP_WNDPROC,
                                         (LPARAM)MyCBWndProc);
                    }
                }

                cyRet  = cySize;

            } else {

                CPSUIASSERT(0, "Newly Create LBCB's ID=%08lx is different",
                                            hLBCB == hNewLBCB, UIntToPtr(CtrlID));
            }

        } else {

            CPSUIERR(("CreateLBCB: CreateWindowEx() FAILED"));
        }

    } else {

        CPSUIERR(("CreateLBCB: GetDlgItem() failed"));
    }

    return((DWORD)MAKELONG(cxRet, cyRet));
}




HWND
CreateTrackBar(
    HWND    hDlg,
    UINT    TrackBarID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Aug-1995 Thu 19:43:08 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;
    HWND    hTrackBar;
    RECT    rc;


    //
    // Create TrackBar Control
    //

    if (hCtrl = CtrlIDrcWnd(hDlg, TrackBarID, &rc)) {

        CPSUIDBG(DBG_CTB,
                ("\nCreate TrackBar Control=%ld, rc=(%ld, %ld) - (%ld, %ld)",
                            TrackBarID, rc.left, rc.top, rc.right, rc.bottom));

        if (hTrackBar = CreateWindowEx(0,
                                       TRACKBAR_CLASS,
                                       L"",
                                       WS_VISIBLE           |
                                            WS_CHILD        |
                                            WS_TABSTOP      |
                                            WS_GROUP        |
                                            TBS_AUTOTICKS,
                                       rc.left,
                                       rc.top,
                                       rc.right - rc.left,
                                       rc.bottom - rc.top,
                                       hDlg,
                                       (HMENU)UIntToPtr(TrackBarID),
                                       hInstDLL,
                                       0)) {

            SetWindowPos(hTrackBar,
                         hCtrl,
                         0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);

            DestroyWindow(hCtrl);

            SetWindowLongPtr(hTrackBar, GWLP_ID, (LONG)TrackBarID);

            hCtrl = GetDlgItem(hDlg, TrackBarID);

            CPSUIINT(("hDlg=%08lx, hTrackBar=%08lx, TrackBarID=%08lx",
                            hDlg, hTrackBar, hCtrl));
        }

        return(hTrackBar);

    } else {

        return(NULL);
    }
}




BOOL
ChkEditKEYDOWN(
    HWND    hWnd,
    WPARAM  VKey
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    13-Aug-1998 Thu 10:56:21 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PTVWND  pTVWnd;
    LONG    SelBeg;
    LONG    SelEnd;


    switch (VKey) {

    case VK_LEFT:
    case VK_BACK:
    case VK_RIGHT:

        SelEnd = (LONG)SendMessage(hWnd, EM_GETSEL, 0, 0);
        SelBeg = (LONG)LOWORD(SelEnd);
        SelEnd = (LONG)HIWORD(SelEnd);

        CPSUIDBG(DBG_CBWNDPROC,
                 ("ChkEditKEYDOWN: WM_KEYDOWN, VKey=%ld, Sel=%ld-%ld, Len=%ld",
                        VKey, SelBeg, SelEnd, GetWindowTextLength(hWnd)));

        if ((SelBeg == SelEnd)  &&
            (pTVWnd = (PTVWND)GetProp(hWnd, CPSUIPROP_PTVWND))) {

            switch (VKey) {

            case VK_LEFT:
            case VK_BACK:

                //
                // If already at position 0, and a left key go back to
                // treeview
                //

                if ((!SelBeg)   &&
                    (pTVWnd->hWndTV) &&
                    (GetDlgCtrlID(pTVWnd->hWndTV) == IDD_TV_WND)) {

                    SetFocus(pTVWnd->hWndTV);
                    return(TRUE);
                }

                break;

            case VK_RIGHT:

                //
                // If already at end position and there is a extended checkbox
                // or extended push then move a right key move to it
                //

                if ((pTVWnd->hWndEdit[1]) &&
                    (SelEnd == (LONG)GetWindowTextLength(hWnd))) {

                    SetFocus(pTVWnd->hWndEdit[1]);
                    return(TRUE);
                }

                break;
            }
        }
    }

    return(FALSE);
}





LRESULT
CALLBACK
CPSUIUDArrowWndProc(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    This is the subclass WNDPROC for the numberical edit control, it check
    valid input for the number entered.


Arguments:

    WNDPROC standard


Return Value:

    INT (The original WNDPROC returned), if the entered keys are not valid
    then it return right away without processing


Author:

    20-Mar-1996 Wed 15:36:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    WNDPROC OldWndProc;
    WCHAR   wch;
    DWORD   dw;
    LONG    SelBegIdx;
    LONG    SelEndIdx;
    WORD    InitItemIdx;
    BYTE    CtrlData;
    BYTE    CtrlStyle;


    if (OldWndProc = (WNDPROC)GetProp(hWnd, CPSUIPROP_WNDPROC)) {

        CPSUIDBG(DBG_VALIDATE_UD,
                 ("CPSUIUDArrowWndProc: hWnd=%08lx, OldWndProc=%08lx",
                    hWnd, OldWndProc));

        switch (Msg) {

        case WM_KEYDOWN:

            if (ChkEditKEYDOWN(hWnd, (DWORD)wParam)) {

                return(0);
            }

            break;

        case WM_CHAR:

            wch = (WCHAR)wParam;
            dw  = (DWORD)GetWindowLongPtr(hWnd, GWLP_USERDATA);

            GETCTRLDATA(dw, InitItemIdx, CtrlStyle, CtrlData);

            SendMessage(hWnd, EM_GETSEL, (WPARAM)&SelBegIdx, (LPARAM)&SelEndIdx);
            CPSUIDBG(DBG_VALIDATE_UD,
                     ("WM_CHAR=0x%04lx, ItemIdx=%u, Style=0x%02lx, Data=0x%02lx (%ld, %ld)",
                                wch, InitItemIdx, CtrlStyle, CtrlData,
                                SelBegIdx, SelEndIdx));

            CtrlData &= EDF_STATIC_MASK;
            CtrlData |= (BYTE)(SelBegIdx & EDF_BEGIDXMASK);

            if (wch < L' ') {

                if (wch == 0x08) {

                    CtrlData |= EDF_BACKSPACE;
                }

            } else if (((wch == L'-') && (CtrlData & EDF_MINUS_OK)) ||
                       ((wch >= L'0') && (wch <= L'9'))) {

                WCHAR   SelBuf[MAX_UDARROW_TEXT_LEN+1];
                WCHAR   LastCh;
                LONG    Len;

                Len    = (LONG)GetWindowText(hWnd, SelBuf, ARRAYSIZE(SelBuf));
                LastCh = (SelEndIdx >= Len) ? L'\0' : SelBuf[SelEndIdx];

                if ((SelBegIdx == 0) && (LastCh == L'-')) {

                    wch = 0;

                } else if (wch == L'-') {

                    if (SelBegIdx) {

                        wch = 0;
                    }

                } else if (wch == L'0') {

                    if (LastCh) {

                        if (((SelBegIdx == 1) && (SelBuf[0] == L'-'))   ||
                            ((SelBegIdx == 0) && (LastCh != L'-'))) {

                            wch = 0;
                        }
                    }
                }

                if ((wch >= L'0') && (wch <= L'9')) {

                    CtrlData |= EDF_NUMBERS;
                }

            } else {

                wch = 0;
            }

            SETCTRLDATA(hWnd, CtrlStyle, CtrlData);

            if (!wch) {

                MessageBeep(MB_ICONHAND);
                return(0);
            }

            break;

        case WM_DESTROY:

            CPSUIDBG(DBG_VALIDATE_UD, ("UDArrow: WM_DESTROY"));

            SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LPARAM)OldWndProc);
            RemoveProp(hWnd, CPSUIPROP_WNDPROC);
            RemoveProp(hWnd, CPSUIPROP_PTVWND);

            break;

        default:

            break;
        }

        return(CallWindowProc(OldWndProc, hWnd, Msg, wParam, lParam));

    } else {

        CPSUIERR(("CPSUIUDArrowWndProc: GetProc(%08lx) FAILED", hWnd));

        return(0);
    }
}



HWND
CreateUDArrow(
    HWND    hDlg,
    UINT    EditBoxID,
    UINT    UDArrowID,
    LONG    RangeL,
    LONG    RangeH,
    LONG    Pos
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Aug-1995 Thu 18:55:07 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hUDArrow;
    HWND    hCtrl;
    RECT    rc;
    WNDPROC OldWndProc;


    if (hCtrl = CtrlIDrcWnd(hDlg, EditBoxID, &rc)) {

        if (Pos < RangeL) {

            Pos = RangeL;

        } else if (Pos > RangeH) {

            Pos = RangeH;
        }

        CPSUIDBG(DBG_CUDA, ("CreateUDArrow Window, rc=(%ld, %ld) - (%ld, %ld), Range=%ld-%ld (%ld)",
                            rc.left, rc.top, rc.right, rc.bottom,
                            RangeL, RangeH, Pos));

        if (hUDArrow = CreateUpDownControl(WS_BORDER        |
                                            WS_CHILD        |
                                            WS_TABSTOP      |
                                            WS_GROUP        |
                                            UDS_ARROWKEYS   |
                                            UDS_NOTHOUSANDS |
                                            UDS_ALIGNRIGHT  |
                                            UDS_SETBUDDYINT,
                                           rc.right,
                                           rc.top,
                                           rc.bottom - rc.top,
                                           rc.bottom - rc.top,
                                           hDlg,
                                           UDArrowID,
                                           hInstDLL,
                                           hCtrl,
                                           (INT)RangeH,
                                           (INT)RangeL,
                                           (INT)Pos)) {

            SetWindowLongPtr(hUDArrow,
                             GWL_EXSTYLE,
                             GetWindowLongPtr(hUDArrow, GWL_EXSTYLE) |
                                  WS_EX_NOPARENTNOTIFY | WS_EX_CONTEXTHELP);

            SetWindowPos(hUDArrow,
                         hCtrl,
                         0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);

            SendMessage(hUDArrow, UDM_SETBASE, (WPARAM)10, 0L);

            OldWndProc = (WNDPROC)GetWindowLongPtr(hCtrl, GWLP_WNDPROC);

            if ((ULONG_PTR)OldWndProc != (ULONG_PTR)CPSUIUDArrowWndProc) {

                SetProp(hCtrl, CPSUIPROP_WNDPROC, (HANDLE)OldWndProc);
                SetProp(hCtrl, CPSUIPROP_PTVWND, (HANDLE)GET_PTVWND(hDlg));
                SetWindowLongPtr(hCtrl,
                                 GWLP_WNDPROC,
                                 (LPARAM)CPSUIUDArrowWndProc);

                CPSUIDBG(DBG_VALIDATE_UD, ("hUDArrow=%08lx: Save OldWndProc=%08lx",
                                    hUDArrow, OldWndProc));
            }
        }

        return(hUDArrow);

    } else {

        return(NULL);
    }
}




BOOL
SetDlgPageItemName(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem,
    UINT        InitFlags,
    UINT        UDArrowHelpID
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    19-Sep-1995 Tue 18:29:44 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hCtrl = NULL;
    POPTTYPE    pOptType;
    UINT        TitleID;
    BOOL        AddItemSep;
    GSBUF_DEF(pItem, MAX_RES_STR_CHARS * 2);


    if (pOptType = GET_POPTTYPE(pItem)) {

        GSBUF_FLAGS |= GBF_PREFIX_OK;

        if ((TitleID = pOptType->BegCtrlID)      &&
            (hCtrl = GetDlgItem(hDlg, TitleID))) {

            if (pItem->Flags & OPTIF_NO_GROUPBOX_NAME) {

                //
                // If we don't display the group name for TitleID and TitleID 
                // exists in the page, we will enable/disable the group box 
                // depending on InitFlag value. This is mainly for the "Tray 
                // Selection" group, since it has both TitleID and TitleID + 1 
                // in the page.
                //
                SHOWCTRL(hCtrl, TRUE, SW_SHOW);
                AddItemSep = TRUE;
                hCtrl      = GetDlgItem(hDlg, TitleID + 1);

            } else {

                AddItemSep = FALSE;
            }

        } else {

            AddItemSep = TRUE;
            hCtrl      = GetDlgItem(hDlg, TitleID + 1);
        }

        if (hCtrl) {

            POPTPARAM   pOptParam = pOptType->pOptParam;


            //
            // Get the name first, and add in the seperator add needed
            //

            GSBUF_GETSTR(pItem->pName);

            if (InitFlags & INITCF_ADDSELPOSTFIX) {

                GSBUF_GETSTR(IDS_CPSUI_COLON_SEP);
                GSBUF_ADDNUM(pItem->Sel, TRUE);

                if (!(pOptType->Flags & OPTTF_NOSPACE_BEFORE_POSTFIX)) {

                    GSBUF_ADD_SPACE(1);
                }

                GSBUF_GETSTR(pOptParam[0].pData);

            } else if (AddItemSep) {

                GSBUF_GETSTR(IDS_CPSUI_COLON_SEP);
            }

            //
            // If we have the UDARROW Help ID and it does not have control
            // associated it then put the range on the title bar
            //

            if ((UDArrowHelpID) && (!GetDlgItem(hDlg, UDArrowHelpID))) {

                GSBUF_ADD_SPACE(2);

                if (pOptParam[1].pData) {

                    GSBUF_GETSTR(pOptParam[1].pData);

                } else {

                    GSBUF_COMPOSE(IDS_INT_CPSUI_RANGE,
                                  NULL,
                                  pOptParam[1].IconID,
                                  pOptParam[1].lParam);
                }
            }

            //
            // We actually don't want the title enabled because we end up having this problem
            // with the shortcuts. When you have a shortcut to a static label (let's say
            // "Page&s Per Sheet") and you hit Alt-S, but the control this caption is
            // referring to is disabled then the focus goes into the next enabled control
            // in the tab order which has the WS_TABSTOP bit up (in out case this is the
            // "Advanced" button. We don't want this behavior.
            //

            // InitFlags |= INITCF_ENABLE;

            SetWindowText(hCtrl, (LPCTSTR)GSBUF_BUF);
            SHOWCTRL(hCtrl, TRUE, SW_SHOW);

            return(TRUE);
        }
    }

    return(FALSE);
}


#if (DO_IN_PLACE == 0)


VOID
SetPushSize(
    PTVWND  pTVWnd,
    HWND    hPush,
    LPWSTR  pPushText,
    UINT    cPushText,
    UINT    SPSFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    02-Nov-1995 Thu 12:25:49 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hExtPush;
    HDC     hDC;
    HGDIOBJ hOld;
    SIZE    szl;
    LONG    xAdd;
    RECT    rc;

    //
    // Adjust the size of push button
    //

    hOld = SelectObject(hDC = GetWindowDC(hPush),
                        (HANDLE)SendMessage(hPush, WM_GETFONT, 0, 0L));

    GetTextExtentPoint32(hDC, L"W", 1, &szl);
    LPtoDP(hDC, (LPPOINT)&szl, 1);
    xAdd = szl.cx * PUSH_CX_EXTRA_W;

    GetTextExtentPoint32(hDC, pPushText, cPushText, &szl);
    LPtoDP(hDC, (LPPOINT)&szl, 1);

    SelectObject(hDC, hOld);
    ReleaseDC(hPush, hDC);

    hCtrlrcWnd(pTVWnd->hDlgTV, hPush, &rc);

    szl.cx += xAdd;
    szl.cy  = (SPSFlags & SPSF_USE_BUTTON_CY) ? rc.bottom - rc.top :
                                                (szl.cy + PUSH_CY_EXTRA);

    CPSUIINT(("SetPushSize: Text=%ld x %ld, xAdd=%ld, Push=%ld x %ld",
                szl.cx - xAdd, szl.cy, xAdd, szl.cx, szl.cy));

    if ((SPSFlags & SPSF_ALIGN_EXTPUSH)                         &&
        (hExtPush = GetDlgItem(pTVWnd->hDlgTV, IDD_TV_EXTPUSH)) &&
        (hCtrlrcWnd(pTVWnd->hDlgTV, hExtPush, &rc))) {

        if ((xAdd = rc.right - rc.left) > szl.cx) {

            //
            // Increase the CX of the push button
            //

            CPSUIINT(("SetPushSize: Adjust PUSH equal to ExtPush (%ld)", xAdd));

            szl.cx = xAdd;

        } else if (xAdd < szl.cx) {

            //
            // Ext PUSH's CX is smaller, increase the cx
            //

            CPSUIINT(("SetPushSize: Adjust ExtPush equal to PUSH (%ld)", szl.cx));

            SetWindowPos(hExtPush, NULL,
                         0, 0,
                         szl.cx, rc.bottom - rc.top,
                         SWP_NOMOVE | SWP_NOZORDER |
                         SWP_FRAMECHANGED | SWP_DRAWFRAME);
        }
    }

    SetWindowPos(hPush, NULL, 0, 0, szl.cx, szl.cy,
                 SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);
}

#endif


BOOL
InitExtPush(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        ExtChkBoxID,
    UINT        ExtPushID,
    UINT        ExtIconID,
    WORD        InitItemIdx,
    WORD        InitFlags
    )

/*++

Routine Description:

    This fucntion initialize the extended check box, and if will not allowed
    a item to be udpated if TWF_CAN_UPDATE is clear


Arguments:




Return Value:




Author:

    28-Aug-1995 Mon 21:01:35 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;


    if ((InitFlags & INITCF_INIT)   &&
        (ExtChkBoxID)               &&
        (ExtChkBoxID != ExtPushID)  &&
        (hCtrl = GetDlgItem(hDlg, ExtChkBoxID))) {

        EnableWindow(hCtrl, FALSE);
        ShowWindow(hCtrl, SW_HIDE);
    }

    if ((ExtPushID) &&
        (hCtrl =  GetDlgItem(hDlg, ExtPushID))) {

        HWND        hCtrl2;
        PEXTPUSH    pEP;
        BOOL        Enable = FALSE;
        UINT        swMode = SW_SHOW;
        BYTE        CtrlData = 0;
        ULONG_PTR   IconResID = 0;
        WORD        IconMode = 0;
        GSBUF_DEF(pItem, MAX_RES_STR_CHARS);

#if DO_IN_PLACE
        if (!IS_TVDLG) {
#else
        {
#endif
            GSBUF_FLAGS |= GBF_PREFIX_OK;
        }

        if (pItem == PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT)) {

            InitFlags |= INITCF_ENABLE;

        } else if (!(pTVWnd->Flags & TWF_CAN_UPDATE)) {

            InitFlags &= ~INITCF_ENABLE;
        }

        if ((!(pEP = pItem->pExtPush))   ||
            // (!(pItem->pOptType))            ||
            (pItem->Flags & (OPTIF_HIDE | OPTIF_EXT_HIDE))) {

            swMode = SW_HIDE;

        } else if (!(pItem->Flags & (OPTIF_HIDE | OPTIF_EXT_DISABLED))) {

            Enable = TRUE;
        }

#if DO_IN_PLACE
        pTVWnd->hWndEdit[1] = ((IS_TVDLG)  && (swMode == SW_SHOW)) ? hCtrl :
                                                                     NULL;
#endif

        if (pEP) {

            CtrlData = (BYTE)((pEP->Flags & EPF_PUSH_TYPE_DLGPROC) ? 1 : 0);
        }

        HCTRL_SETCTRLDATA(hCtrl,  CTRLS_EXTPUSH, CtrlData);
        HCTRL_STATE(hCtrl,  Enable, swMode);

        if ((InitFlags & INITCF_INIT) && (pEP)) {

            if (pEP == &ExtPushAbout) {

                GSBUF_COMPOSE(IDS_INT_CPSUI_ABOUT,
                              pTVWnd->ComPropSheetUI.pCallerName,
                              0,
                              0);

            } else {

                if (pEP->Flags & EPF_INCL_SETUP_TITLE) {

                    GSBUF_COMPOSE(IDS_INT_CPSUI_SETUP, pEP->pTitle, 0, 0);

                } else {

                    GSBUF_GETSTR(pEP->pTitle);
                }
            }

            if (!(pEP->Flags & EPF_NO_DOT_DOT_DOT)) {

                GSBUF_GETSTR(IDS_CPSUI_MORE);
            }

            if (IS_TVDLG) {

                SIZEL   szlText;

                //
                // Adjust the size of push button
                //

#if DO_IN_PLACE
                szlText.cx = 0;

                GetTextExtentPoint(pTVWnd->hDCTVWnd,
                                   GSBUF_BUF,
                                   GSBUF_COUNT,
                                   &szlText);

                _OI_CXEXT(pItem)    = (WORD)szlText.cx +
                                      (WORD)(pTVWnd->cxSpace * 4);
                _OI_CYEXTADD(pItem) = 0;
#else
                SetPushSize(pTVWnd,
                            hCtrl,
                            GSBUF_BUF,
                            GSBUF_COUNT,
                            SPSF_USE_BUTTON_CY);
#endif
            }

            SetWindowText(hCtrl, GSBUF_BUF);
        }

#if DO_IN_PLACE
        if (IS_TVDLG) {

            return((BOOL)(swMode == SW_SHOW));
        }
#endif
        if (pEP) {

            if (pEP->Flags & EPF_OVERLAY_WARNING_ICON) {

                IconMode |= MIM_WARNING_OVERLAY;
            }

            if (pEP->Flags & EPF_OVERLAY_STOP_ICON) {

                IconMode |= MIM_STOP_OVERLAY;
            }

            if (pEP->Flags & EPF_OVERLAY_NO_ICON) {

                IconMode |= MIM_NO_OVERLAY;
            }

            IconResID = GET_ICONID(pEP, EPF_ICONID_AS_HICON);
        }

        SET_EXTICON(TRUE);

    } else {

        return(FALSE);
    }
}





BOOL
InitExtChkBox(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        ExtChkBoxID,
    UINT        ExtPushID,
    UINT        ExtIconID,
    WORD        InitItemIdx,
    WORD        InitFlags
    )

/*++

Routine Description:

    This fucntion initialize the extended check box, and if will not allowed
    a item to be udpated if TWF_CAN_UPDATE is clear


Arguments:




Return Value:




Author:

    28-Aug-1995 Mon 21:01:35 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;


    if ((InitFlags & INITCF_INIT)   &&
        (ExtPushID)                 &&
        (ExtPushID != ExtChkBoxID)  &&
        (hCtrl = GetDlgItem(hDlg, ExtPushID))) {

        EnableWindow(hCtrl, FALSE);
        ShowWindow(hCtrl, SW_HIDE);
    }

    if ((ExtChkBoxID) &&
        (hCtrl = GetDlgItem(hDlg, ExtChkBoxID))) {

        HWND        hCtrl2;
        PEXTCHKBOX  pECB;
        BOOL        Enable = FALSE;
        UINT        swMode = SW_SHOW;
        ULONG_PTR   IconResID = 0;
        WORD        IconMode = 0;
        GSBUF_DEF(pItem, MAX_RES_STR_CHARS);


#if DO_IN_PLACE
        if (!IS_TVDLG) {
#else
        {
#endif
            GSBUF_FLAGS |= GBF_PREFIX_OK;
        }

        if (pItem == PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT)) {

            InitFlags |= INITCF_ENABLE;

        } else if (!(pTVWnd->Flags & TWF_CAN_UPDATE)) {

            InitFlags &= ~INITCF_ENABLE;
        }

        if ((!(pECB = pItem->pExtChkBox))   ||
            // (!(pItem->pOptType))            ||
            (pItem->Flags & (OPTIF_HIDE | OPTIF_EXT_HIDE))) {

            swMode = SW_HIDE;

        } else if (!(pItem->Flags & OPTIF_EXT_DISABLED)) {

            Enable = TRUE;
        }

#if DO_IN_PLACE
        pTVWnd->hWndEdit[1] = ((IS_TVDLG)  && (swMode == SW_SHOW)) ? hCtrl :
                                                                     NULL;
#endif
        HCTRL_SETCTRLDATA(hCtrl,  CTRLS_EXTCHKBOX, 0);
        HCTRL_STATE(hCtrl,  Enable, swMode);

        if ((InitFlags & INITCF_INIT) && (pECB)) {

            LPTSTR  pTitle;


            if (!(pTitle = pECB->pCheckedName)) {

                pTitle = pECB->pTitle;
            }

            HCTRL_TEXT(hCtrl, pTitle);

#if DO_IN_PLACE
            if (IS_TVDLG) {

                SIZEL   szlText;

                szlText.cx = 0;

                GSBUF_FLAGS &= ~GBF_PREFIX_OK;
                GSBUF_RESET;
                GSBUF_GETSTR(pTitle);

                szlText.cy = (LONG)GSBUF_COUNT;
                pTitle     = &GSBUF_BUF[szlText.cy - 1];

                while (*pTitle == L' ') {

                    --pTitle;
                    --szlText.cy;
                }

                pTitle = GSBUF_BUF;

                while (*pTitle == L' ') {

                    ++pTitle;
                    --szlText.cy;
                }

                GetTextExtentPoint(pTVWnd->hDCTVWnd,
                                   pTitle,
                                   szlText.cy,
                                   &szlText);

                CPSUIINT(("ExtChkBox: '%ws' = %ld", GSBUF_BUF, szlText.cx));

                _OI_CXEXT(pItem)    = (WORD)szlText.cx +
                                      (WORD)GetSystemMetrics(SM_CXSMICON) +
                                      (WORD)pTVWnd->cxSpace * 2;
                _OI_CYEXTADD(pItem) = 0;
            }
#endif
        }

        CheckDlgButton(hDlg,
                       ExtChkBoxID,
                       (pItem->Flags & OPTIF_ECB_CHECKED) ? BST_CHECKED :
                                                            BST_UNCHECKED);
#if DO_IN_PLACE
        if (IS_TVDLG) {

            return((BOOL)(swMode == SW_SHOW));
        }
#endif
        if (pECB) {

            if (pECB->Flags & ECBF_OVERLAY_WARNING_ICON) {

                IconMode |= MIM_WARNING_OVERLAY;
            }

            if (pECB->Flags & ECBF_OVERLAY_STOP_ICON) {

                IconMode |= MIM_STOP_OVERLAY;
            }

            if (pECB->Flags & ECBF_OVERLAY_NO_ICON) {

                IconMode |= MIM_NO_OVERLAY;
            }

            IconResID = GET_ICONID(pECB, ECBF_ICONID_AS_HICON);
        }

        SET_EXTICON(TRUE);

    } else {

        return(FALSE);
    }
}



UINT
InitStates(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    POPTTYPE    pOptType,
    UINT        IDState1,
    WORD        InitItemIdx,
    LONG        NewSel,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Aug-1995 Thu 20:16:29 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hCtrl;
    HWND        hCtrlIcon;
    POPTPARAM   pOP;
    UINT        CtrlID;
    UINT        i;
    UINT        MaxStates;

    MaxStates = (UINT)(pOptType->Count - 1);

    if (InitFlags & INITCF_INIT) {

        for (i = 0, CtrlID = IDState1, pOP = pOptType->pOptParam;
             i <= (UINT)MaxStates;
             i++, CtrlID += 2, pOP++) {

            INT     swMode;
            BOOL    Enable;
            GSBUF_DEF(pItem, MAX_RES_STR_CHARS);


            GSBUF_FLAGS |= GBF_PREFIX_OK;

            //
            // All the radio hide button already hided
            //

            if (pOP->Flags & OPTPF_HIDE) {

                CPSUIASSERT(0, "2/3 States %d: 'Sel' item is OPTPF_HIDE",
                                            NewSel != (LONG)i, UIntToPtr(i + 1));

                if (NewSel == (LONG)i) {

                    if (++NewSel > (LONG)MaxStates) {

                        NewSel = 0;
                    }
                }

            } else {

                hCtrl = NULL;

                if (CtrlID) {

                    hCtrl = GetDlgItem(hDlg, CtrlID);
                }

                hCtrlIcon = GetDlgItem(hDlg, CtrlID + 1);

                if (hCtrl) {

                    HCTRL_SETCTRLDATA(hCtrl, CTRLS_RADIO, i);

                    if (InitFlags & INITCF_INIT) {

                        HCTRL_TEXT(hCtrl, pOP->pData);
                    }

                    Enable = !(BOOL)(pOP->Flags & OPTPF_DISABLED);

                    HCTRL_STATE(hCtrl,
                                !(BOOL)(pOP->Flags & OPTPF_DISABLED),
                                SW_SHOW);
                }

                HCTRL_STATE(hCtrlIcon, TRUE,  SW_SHOW);
            }
        }
    }

    CheckRadioButton(hDlg,
                     IDState1,
                     IDState1 + (WORD)(MaxStates << 1),
                     IDState1 + (DWORD)(NewSel << 1));

    return(NewSel);
}




LONG
InitUDArrow(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    POPTPARAM   pOptParam,
    UINT        UDArrowID,
    UINT        EditBoxID,
    UINT        PostfixID,
    UINT        HelpID,
    WORD        InitItemIdx,
    LONG        NewPos,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Aug-1995 Thu 18:55:07 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hUDArrow;
    HWND    hEdit;
    HWND    hCtrl;
    DWORD   dw;
    LONG    Range[2];
    BYTE    CtrlData;
    GSBUF_DEF(pItem, MAX_RES_STR_CHARS * 2);

    //
    // Create Up/Down Control
    //

    GSBUF_FLAGS |= GBF_PREFIX_OK;

    hUDArrow = (UDArrowID) ? GetDlgItem(hDlg, UDArrowID) : NULL;
    hEdit    = (EditBoxID) ? GetDlgItem(hDlg, EditBoxID) : NULL;

    if ((!hUDArrow) || (!hEdit)) {

        return(ERR_CPSUI_CREATE_UDARROW_FAILED);
    }

    Range[0] = (LONG)pOptParam[1].IconID;
    Range[1] = (LONG)pOptParam[1].lParam;

    if (NewPos < Range[0]) {

        NewPos = Range[0];

    } else if (NewPos > Range[1]) {

        NewPos = Range[1];
    }

    if (InitFlags & INITCF_SETCTRLDATA) {

        CtrlData = ((Range[0] < 0) || (Range[1] < 0)) ? EDF_MINUS_OK : 0;

        if (IS_TVDLG) {

            CtrlData |= EDF_IN_TVPAGE;
        }

        HCTRL_SETCTRLDATA(hEdit, CTRLS_UDARROW_EDIT, CtrlData);
        HCTRL_SETCTRLDATA(hUDArrow, CTRLS_UDARROW, CtrlData);
    }


    if (InitFlags & INITCF_INIT) {

        RECT    rc;

#if DO_IN_PLACE
        PostfixID =
        HelpID    = 0;
#endif
        HCTRL_STATE(hEdit,    FALSE, SW_HIDE);
        HCTRL_STATE(hUDArrow, FALSE, SW_HIDE);

        if ((PostfixID) && (hCtrl = GetDlgItem(hDlg, PostfixID))) {

            GSBUF_RESET;
            GSBUF_GETSTR(pOptParam[0].pData);

            SetWindowText(hCtrl, GSBUF_BUF);
            HCTRL_STATE(hCtrl, TRUE, SW_SHOW);
        }

        if ((HelpID) && (hCtrl = GetDlgItem(hDlg, HelpID))) {

            GSBUF_RESET;

            if (pOptParam[1].pData) {

                GSBUF_GETSTR(pOptParam[1].pData);

            } else {

                GSBUF_COMPOSE(IDS_INT_CPSUI_RANGE,
                              NULL,
                              Range[0],
                              Range[1]);
            }

            SetWindowText(hCtrl, GSBUF_BUF);
            HCTRL_STATE(hCtrl, TRUE, SW_SHOW);
        }

        //
        // Set the style so that it only take numbers v4.0 or later
        //

        SetWindowLongPtr(hEdit,
                         GWL_STYLE,
                         GetWindowLong(hEdit, GWL_STYLE) | ES_NUMBER);

        //
        // Set the UD arrow edit control to maximum 7 characters
        //

        SendMessage(hEdit, EM_SETLIMITTEXT, MAX_UDARROW_TEXT_LEN, 0L);

#if DO_IN_PLACE
        if ((IS_TVDLG) &&
            (TreeView_GetItemRect(pTVWnd->hWndTV,
                                  _OI_HITEM(pItem),
                                  &rc,
                                  TRUE))) {

            LONG    OrgL;

            pTVWnd->ptCur.x = rc.left;
            pTVWnd->ptCur.y = rc.top;

            OrgL     = rc.right;
            rc.left  = rc.right + pTVWnd->cxSelAdd;
            rc.right = rc.left + pTVWnd->cxMaxUDEdit;

            SetWindowPos(pTVWnd->hWndEdit[0] = hEdit,
                         NULL,
                         rc.left,
                         rc.top,
                         rc.right - rc.left,
                         rc.bottom - rc.top + 1,
                         SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);

            //
            // Following code is only for exposing edit box name in MSAA
            //
            {
                TVITEM      tvi;
                TCHAR       szBuf[MAX_RES_STR_CHARS] = {0};

                tvi.hItem       = _OI_HITEM(pItem);
                tvi.mask        = TVIF_TEXT;
                tvi.pszText     = szBuf;
                tvi.cchTextMax  = ARRAYSIZE(szBuf);

                if (TreeView_GetItem(pTVWnd->hWndTV, &tvi) && (hCtrl = GetDlgItem(pTVWnd->hWndTV, IDD_TV_MSAA_NAME)))
                {
                    SetWindowText(hCtrl, tvi.pszText);

                    //
                    // Insert the invisible label ahead of the combo box.
                    //
                    SetWindowPos(hCtrl, hEdit, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);
                    SetWindowPos(hEdit, hCtrl, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);
                }
            }

            DestroyWindow(hUDArrow);

            pTVWnd->hWndEdit[2] =
            hUDArrow            = CreateUDArrow(hDlg,
                                                IDD_TV_UDARROW_EDIT,
                                                IDD_TV_UDARROW,
                                                Range[0],
                                                Range[1],
                                                NewPos);

            HCTRL_SETCTRLDATA(hUDArrow, CTRLS_UDARROW, CtrlData);

            if (pTVWnd->hWndEdit[1]) {

                rc.left  = rc.right + pTVWnd->cxExtAdd;
                rc.right = rc.left + (LONG)_OI_CXEXT(pItem);

                SetWindowPos(pTVWnd->hWndEdit[1],
                             hUDArrow,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top + (LONG)_OI_CYEXTADD(pItem),
                             SWP_FRAMECHANGED | SWP_DRAWFRAME);
            }

            pTVWnd->chWndEdit = 3;
            pTVWnd->cxEdit    = (WORD)(rc.right - OrgL);
            pTVWnd->cxItem    = (WORD)(rc.right - pTVWnd->ptCur.x);



        }
#endif
        SendMessage(hUDArrow,
                    UDM_SETRANGE,
                    (WPARAM)0,
                    (LPARAM)MAKELONG((SHORT)Range[1], (SHORT)Range[0]));

        Range[0] = 0;
        Range[1] = -1;

    } else {

        SendMessage(hEdit, EM_GETSEL, (WPARAM)&Range[0], (LPARAM)&Range[1]);
    }

    HCTRL_STATE(hEdit,    TRUE, SW_SHOW);
    HCTRL_STATE(hUDArrow, TRUE, SW_SHOW);

    SendMessage(hUDArrow, UDM_SETPOS, 0, (LPARAM)MAKELONG(NewPos, 0));
    SendMessage(hEdit, EM_SETSEL, (WPARAM)Range[0], (LPARAM)Range[1]);

    CPSUIDBG(DBG_VALIDATE_UD, ("InitUDArrow: NewPos=%ld, SELECT=%ld / %ld",
                                    NewPos, Range[0], Range[1]));

    return(1);
}





VOID
InitTBSB(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    HWND        hTBSB,
    POPTTYPE    pOptType,
    UINT        PostfixID,
    UINT        RangeLID,
    UINT        RangeHID,
    WORD        InitItemIdx,
    LONG        NewPos,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 14:25:50 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hCtrl;
    POPTPARAM   pOptParam;
    LONG        Range[2];
    LONG        CurRange;
    LONG        MulFactor;
    UINT        i;
    BOOL        IsTB;
    GSBUF_DEF(pItem, MAX_RES_STR_CHARS);



    IsTB      = (BOOL)(GetWindowLongPtr(hTBSB, GWLP_ID) == IDD_TV_TRACKBAR);
    pOptParam = pOptType->pOptParam;
    Range[0]  = (LONG)pOptParam[1].IconID;
    Range[1]  = (LONG)pOptParam[1].lParam;
    MulFactor = (LONG)pOptParam[2].IconID;


    if ((NewPos < Range[0]) || (NewPos > Range[1])) {

        NewPos = Range[0];
    }

    if (InitFlags & INITCF_INIT) {

#if DO_IN_PLACE
        RECT    rc;
        LONG    MaxR;

        GetClientRect(pTVWnd->hWndTV, &rc);

        MaxR = rc.right;
#endif
        CPSUIDBG(DBG_INITTBSB, ("TB/SB Range=%ld to %ld", Range[0], Range[1]));

        //
        // Set Low/High range text
        //

#if DO_IN_PLACE
        if ((IS_TVDLG)  &&
            (TreeView_GetItemRect(pTVWnd->hWndTV,
                                  _OI_HITEM(pItem),
                                  &rc,
                                  TRUE))) {

            LONG    OrgL;

            pTVWnd->ptCur.x = rc.left;
            pTVWnd->ptCur.y = rc.top;

            OrgL           = rc.right;
            rc.left        = rc.right + pTVWnd->cxSelAdd;
            rc.right       = rc.left + (pTVWnd->cxAveChar * 32);

            SetWindowPos(pTVWnd->hWndEdit[0] = hTBSB,
                         NULL,
                         rc.left,
                         rc.top,
                         rc.right - rc.left,
                         rc.bottom - rc.top,
                         SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);

            if (pTVWnd->hWndEdit[1]) {

                pTVWnd->chWndEdit = 2;
                rc.left           = rc.right + pTVWnd->cxExtAdd;
                rc.right          = rc.left + (LONG)_OI_CXEXT(pItem);

                SetWindowPos(pTVWnd->hWndEdit[1],
                             hTBSB,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top + (LONG)_OI_CYEXTADD(pItem),
                             SWP_FRAMECHANGED | SWP_DRAWFRAME);

            } else {

                pTVWnd->chWndEdit = 1;
            }

            pTVWnd->cxEdit = (WORD)(rc.right - OrgL);
            pTVWnd->cxItem = (WORD)(rc.right - pTVWnd->ptCur.x);


            PostfixID    =
            RangeLID     =
            RangeHID     = 0;
            GSBUF_FLAGS |= GBF_PREFIX_OK;
        }
#endif
        if ((PostfixID) && (hCtrl = GetDlgItem(hDlg, PostfixID))) {

            GSBUF_RESET;

            if (!(pOptType->Flags & OPTTF_NOSPACE_BEFORE_POSTFIX)) {

                GSBUF_ADD_SPACE(1);
            }

            GSBUF_GETSTR(pOptParam[0].pData);

            SetWindowText(hCtrl, GSBUF_BUF);
            SHOWCTRL(hCtrl, TRUE, SW_SHOW);
        }

        for (i = 1; i <= 2; i++, RangeLID = RangeHID) {

            if ((RangeLID) && (hCtrl = GetDlgItem(hDlg, RangeLID))) {

                LPTSTR  pRangeText;

                GSBUF_RESET;

                if (pRangeText = pOptParam[i].pData) {

                    GSBUF_GETSTR(pRangeText);

                } else {

                    CurRange = Range[i - 1] * MulFactor;

                    GSBUF_ADDNUM(Range[i - 1] * MulFactor, TRUE);

                    if (!(pOptType->Flags & OPTTF_NOSPACE_BEFORE_POSTFIX)) {

                        GSBUF_ADD_SPACE(1);
                    }

                    GSBUF_GETSTR(pOptParam[0].pData);
                }

                SetWindowText(hCtrl, GSBUF_BUF);
                SHOWCTRL(hCtrl, TRUE, SW_SHOW);
            }
        }

        if (IsTB) {

            SendMessage(hTBSB,
                        TBM_SETRANGE,
                        (WPARAM)TRUE,
                        (LPARAM)MAKELONG((SHORT)Range[0], (SHORT)Range[1]));

            SendMessage(hTBSB,
                        TBM_SETPAGESIZE,
                        (WPARAM)0,
                        (LPARAM)pOptParam[2].lParam);

            CurRange = Range[1] - Range[0];

            if ((!(MulFactor = (LONG)pOptParam[2].lParam)) ||
                ((CurRange / MulFactor) > 25)) {

                MulFactor = CurRange / 25;
            }

            CPSUIINT(("Tick Freq set to %ld, Range=%ld", MulFactor, CurRange));

            SendMessage(hTBSB,
                        TBM_SETTICFREQ,
                        (WPARAM)MulFactor,
                        (LPARAM)NewPos);

        } else {

            SendMessage(hTBSB,
                        SBM_SETRANGE,
                        (WPARAM)(SHORT)Range[0],
                        (LPARAM)(SHORT)Range[1]);
        }
    }

    //
    // Set Static text
    //

    if (IsTB) {

        HCTRL_SETCTRLDATA(hTBSB, CTRLS_TRACKBAR, 0);
        SendMessage(hTBSB, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)NewPos);

    } else {

        HCTRL_SETCTRLDATA(hTBSB, CTRLS_HSCROLL, 0);
        SendMessage(hTBSB, SBM_SETPOS, (WPARAM)NewPos, (LPARAM)TRUE);
    }

    HCTRL_STATE(hTBSB, TRUE, SW_SHOW);
}



VOID
InitLBCB(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        idLBCB,
    UINT        SetCurSelID,
    POPTTYPE    pOptType,
    WORD        InitItemIdx,
    LONG        NewSel,
    WORD        InitFlags,
    UINT        cyLBCBMax
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 14:32:19 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hLBCB;
    DWORD       dw;
    LONG        Ret;
    LONG        CurSel;
    BOOL        IsLB = (BOOL)(SetCurSelID == LB_SETCURSEL);
    GSBUF_DEF(pItem, MAX_RES_STR_CHARS);


    if ((!idLBCB) || (!(hLBCB = GetDlgItem(hDlg, idLBCB)))) {

        return;
    }

    if ((!IsLB)                     &&
        (InitFlags & INITCF_INIT)   &&
        (SendMessage(hLBCB, CB_GETDROPPEDSTATE, 0, 0))) {

        InitFlags &= ~INITCF_INIT;
    }

    if (InitFlags & INITCF_INIT) {

        HWND        hCtrl;
        HDC         hDC;
        HGDIOBJ     hOld;
        POPTPARAM   pOP;
        TEXTMETRIC  tm;
        RECT        rc;
        RECT        rcC;
        INT         InsertID;
        INT         SetItemDataID;
        UINT        i;
        LONG        cxCBEdit = 0;
        LONG        cyCBEdit;
        LONG        cMaxLB = 0;
        LONG        cShow;
        UINT        cyLBCB;
        UINT        cyFrame;
        SIZEL       szlText;


        //
        // Figure we need to draw icon
        //

        _OT_FLAGS(pOptType) &= ~OTINTF_ITEM_HAS_ICON16;

        if (!(pOptType->Style & OTS_LBCB_NO_ICON16_IN_ITEM)) {

            ULONG_PTR   IconID;


            i   = (UINT)pOptType->Count;
            pOP = pOptType->pOptParam;

            if (((DWORD)NewSel >= (DWORD)pOptType->Count)   ||
                (pOptType->Style & OTS_LBCB_INCL_ITEM_NONE)) {

                IconID = pTVWnd->OptParamNone.IconID;

            } else {

                IconID = pOP->IconID;
            }

            while (i--) {

                if (!(pOP->Flags & OPTPF_HIDE)) {

                    if (// (IconID)                ||
                        (IconID != pOP->IconID) ||
                        (pOP->Flags & (OPTPF_OVERLAY_WARNING_ICON   |
                                       OPTPF_OVERLAY_STOP_ICON      |
                                       OPTPF_OVERLAY_NO_ICON))) {

                        _OT_FLAGS(pOptType) |= OTINTF_ITEM_HAS_ICON16;
                        break;
                    }
                }

                pOP++;
            }
        }

        hOld = SelectObject(hDC = GetWindowDC(hLBCB),
                            (HANDLE)SendMessage(hLBCB, WM_GETFONT, 0, 0L));
        GetTextMetrics(hDC, &tm);

        CPSUIINT(("InitLBCB: Font Height=%ld, cyEdge=%ld",
                    tm.tmHeight, GetSystemMetrics(SM_CYEDGE)));

        if ((_OT_FLAGS(pOptType) & OTINTF_ITEM_HAS_ICON16)  &&
            (tm.tmHeight < (LONG)pTVWnd->cyImage)) {

            cyLBCB = (UINT)pTVWnd->cyImage;

        } else {

            cyLBCB = (UINT)tm.tmHeight + 2;
        }

        CPSUIDBG(DBG_TMP, ("CB: cyImage=%ld, cyicon=%ld, tmHeight=%ld",
                pTVWnd->cyImage, CYICON, tm.tmHeight));

#if DO_IN_PLACE
        //
        // If it is in Treeview then we need to have exact tmHeight, otherwise
        // we need to add 2 for focus rect and another two to compensate the
        // cyImage, 16+2+2=20=CYICON, at dialog box template we need to add
        // one dialog box unit for the spacing.
        //

        cyCBEdit = tm.tmHeight + ((IS_TVDLG) ? 0 : 4);
#else
        cyCBEdit = (LONG)cyLBCB;
#endif

        tm.tmHeight = (LONG)cyLBCB;

        CPSUIDBG(DBG_CB_CY, ("cyCBEdit=%ld, ItemHeight=%ld",
                                            cyCBEdit, tm.tmHeight));

        SendMessage(hLBCB, WM_SETREDRAW, (WPARAM)FALSE, 0L);

        if (IsLB) {

            //
            // Resize the listbox based on the height
            //

            hCtrlrcWnd(hDlg, hLBCB, &rc);
            GetClientRect(hLBCB, &rcC);

            cyLBCB  = (UINT)(rc.bottom - rc.top);
            cyFrame = (UINT)(cyLBCB - rcC.bottom);
            i       = (UINT)((cyLBCBMax - cyFrame) % tm.tmHeight);

            CPSUIRECT(0, "  rcLBCB", &rc, cyLBCB, cyFrame);
            CPSUIRECT(0, "rcClient", &rcC, i,
                                (UINT)((cyLBCBMax - cyFrame) / tm.tmHeight));

            if ((IS_TVDLG) || (!(InitFlags & INITCF_ENABLE))) {

                cMaxLB  = -(LONG)((cyLBCBMax - cyFrame) / tm.tmHeight);
            }

            cyLBCB = cyLBCBMax - i;

            if (IS_TVDLG) {

                rc.top = pTVWnd->tLB;
            }

            SetWindowPos(hLBCB, NULL,
                         rc.left, rc.top += (i / 2),
                         rc.right - rc.left, cyLBCB,
                         SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);

            CPSUIINT(("LB: Frame=%ld, cyLBCB=%ld, Count=%ld, %ld less pels",
                        cyFrame, cyLBCB, cMaxLB, tm.tmHeight - i));


            InsertID = (pOptType->Style & OTS_LBCB_SORT) ? LB_ADDSTRING :
                                                           LB_INSERTSTRING;
            SendMessage(hLBCB, LB_SETITEMHEIGHT, 0, MAKELPARAM(tm.tmHeight,0));
            SendMessage(hLBCB, LB_RESETCONTENT, 0, 0L);

            SetItemDataID = LB_SETITEMDATA;

            HCTRL_SETCTRLDATA(hLBCB, CTRLS_LISTBOX, pOptType->Type);

        } else {

            InsertID = (pOptType->Style & OTS_LBCB_SORT) ? CB_ADDSTRING :
                                                           CB_INSERTSTRING;

            SendMessage(hLBCB,
                        CB_SETITEMHEIGHT,
                        (WPARAM)-1,
                        MAKELPARAM(cyCBEdit, 0));

            //
            // Aligned the static text with new combox edit field when this
            // combo box is not in treeview page
            //

            if ((!IS_TVDLG)                             &&
                (hCtrl = GetDlgItem(hDlg, idLBCB - 1))  &&
                (hCtrlrcWnd(hDlg, hCtrl, &rcC))         &&
                (hCtrlrcWnd(hDlg, hLBCB, &rc))) {

                SetWindowPos(hCtrl,
                             NULL,
                             rcC.left,
                             rc.top + ((rc.bottom - rc.top) -
                                       (rcC.bottom - rcC.top)) / 2,
                             0, 0,
                             SWP_NOZORDER | SWP_NOSIZE);
            }

            SendMessage(hLBCB,
                        CB_SETITEMHEIGHT,
                        (WPARAM)0,
                        MAKELPARAM(tm.tmHeight, 0));

            SendMessage(hLBCB, CB_RESETCONTENT, 0, 0L);

            SetItemDataID = CB_SETITEMDATA;

            HCTRL_SETCTRLDATA(hLBCB, CTRLS_COMBOBOX, pOptType->Type);
        }

        for (i = 0, cShow = 0, pOP = pOptType->pOptParam;
             i < (UINT)pOptType->Count;
             i++, pOP++) {

            if (!(pOP->Flags & OPTPF_HIDE)) {

                GSBUF_RESET;
                GSBUF_GETSTR(pOP->pData);

                CurSel = (LONG)SendMessage(hLBCB,
                                           InsertID,
                                           (WPARAM)-1,
                                           (LPARAM)GSBUF_BUF);
#if DO_IN_PLACE
                GetTextExtentPoint(hDC, GSBUF_BUF, GSBUF_COUNT,  &szlText);

                if (szlText.cx > cxCBEdit) {

                    cxCBEdit = szlText.cx;
                }
#endif
                dw = (DWORD)i;

                if (pOP->Flags & OPTPF_DISABLED) {

                    dw |= LBCBID_DISABLED;

                } else {

                    ++cShow;
                }

                SendMessage(hLBCB, SetItemDataID, (WPARAM)CurSel, (LPARAM)dw);

                ++cMaxLB;
            }
        }

        if ((!cShow)                                    ||
            ((DWORD)NewSel >= (DWORD)pOptType->Count)   ||
            (pOptType->Style & OTS_LBCB_INCL_ITEM_NONE)) {

            //
            // Always add it to the begnining
            //

            GSBUF_RESET;
            GSBUF_GETSTR(pTVWnd->OptParamNone.pData);

            CurSel = (LONG)SendMessage(hLBCB,
                                       (IsLB) ? LB_INSERTSTRING :
                                                CB_INSERTSTRING,
                                       (WPARAM)0,
                                       (LPARAM)GSBUF_BUF);

#if DO_IN_PLACE
            GetTextExtentPoint(hDC, GSBUF_BUF, GSBUF_COUNT,  &szlText);

            if (szlText.cx > cxCBEdit) {

                cxCBEdit = szlText.cx;
            }
#endif
            SendMessage(hLBCB,
                        SetItemDataID,
                        (WPARAM)CurSel,
                        (LPARAM)LBCBID_NONE);

            ++cShow;
            ++cMaxLB;
        }

        if ((IsLB) && (IS_TVDLG)) {

            if (cMaxLB < 0) {

                //
                // We got some items which is blank, then re-size the LISTBOX
                //

                CPSUIINT(("Resize LB: cMaxLB=%ld, cyLBCB=%ld [%ld]",
                                    cMaxLB, cyLBCB, -cMaxLB * tm.tmHeight));

                cMaxLB = -cMaxLB * tm.tmHeight;

                SetWindowPos(hLBCB, NULL,
                             rc.left, rc.top + (cMaxLB / 2),
                             rc.right - rc.left, cyLBCB - (UINT)cMaxLB,
                             SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);
            }

            cMaxLB = 0;
        }

        while (cMaxLB++ < 0) {

            CurSel = (LONG)SendMessage(hLBCB,
                                       (IsLB) ? LB_INSERTSTRING :
                                                CB_INSERTSTRING,
                                       (WPARAM)-1,
                                       (LPARAM)L"");

            SendMessage(hLBCB,
                        SetItemDataID,
                        (WPARAM)CurSel,
                        (LPARAM)LBCBID_FILL);
        }

        HCTRL_STATE(hLBCB, TRUE, SW_SHOW);
#if DO_IN_PLACE
        if ((!IsLB)                     &&
            (IS_TVDLG)                  &&
            (pTVWnd->hWndTV)            &&
            (TreeView_GetItemRect(pTVWnd->hWndTV,
                                  _OI_HITEM(pItem),
                                  &rc,
                                  TRUE))) {

            LONG    cxReal;
            LONG    OrgL;
            RECT    rcWnd;

            pTVWnd->ptCur.x = rc.left;
            pTVWnd->ptCur.y = rc.top;

            OrgL           = rc.right;
            rc.left        = rc.right + pTVWnd->cxSelAdd;

            if (_OT_FLAGS(pOptType) & OTINTF_ITEM_HAS_ICON16) {

                cxCBEdit += (CXIMAGE + LBCB_ICON_TEXT_X_SEP);
            }

            cxCBEdit += (LBCB_ICON_X_OFF + pTVWnd->cxCBAdd);
            cxReal    = cxCBEdit;

            GetClientRect(pTVWnd->hWndTV, &rcWnd);
            rcWnd.right -= pTVWnd->cxSelAdd;

            if (pTVWnd->hWndEdit[1]) {

                rcWnd.right -= (pTVWnd->cxExtAdd + _OI_CXEXT(pItem));
            }

            if ((cxCBEdit + rc.left) > rcWnd.right && cxCBEdit > (LONG)(pTVWnd->cxAveChar * 20)) {

                cxCBEdit = rcWnd.right - rc.left;

                if (cxCBEdit < (LONG)(pTVWnd->cxAveChar * 20)) {

                    cxCBEdit = (LONG)(pTVWnd->cxAveChar * 20);
                } 
            }

            rc.right = rc.left + cxCBEdit;

            SetWindowPos(pTVWnd->hWndEdit[0] = hLBCB,
                         NULL,
                         rc.left,
                         rc.top,
                         rc.right - rc.left,
                         tm.tmHeight * 14,
                         SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);

            CPSUIINT(("LBCB Combo = (%ld, %ld): %ld x %ld",
                    rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top));

            SendMessage(hLBCB, CB_SETDROPPEDWIDTH, (WPARAM)cxReal, 0);

            //
            // Following code is only for exposing combo box name in MSAA
            //
            {
                TVITEM      tvi;
                TCHAR       szBuf[MAX_RES_STR_CHARS] = {0};

                tvi.hItem       = _OI_HITEM(pItem);
                tvi.mask        = TVIF_TEXT;
                tvi.pszText     = szBuf;
                tvi.cchTextMax  = ARRAYSIZE(szBuf);

                if (TreeView_GetItem(pTVWnd->hWndTV, &tvi) && (hCtrl = GetDlgItem(pTVWnd->hWndTV, IDD_TV_MSAA_NAME)))
                {
                    SetWindowText(hCtrl, tvi.pszText);

                    //
                    // Insert the invisible label ahead of the combo box.
                    //
                    SetWindowPos(hCtrl, hLBCB, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);
                    SetWindowPos(hLBCB, hCtrl, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW);
                }
            }

            if (pTVWnd->hWndEdit[1]) {

                pTVWnd->chWndEdit = 2;

                rc.left  = rc.right + pTVWnd->cxExtAdd;
                rc.right = rc.left + (LONG)_OI_CXEXT(pItem);

                SetWindowPos(pTVWnd->hWndEdit[1],
                             hLBCB,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top + 1,    // (LONG)_OI_CYEXTADD(pItem),
                             SWP_FRAMECHANGED | SWP_DRAWFRAME);

            } else {

                pTVWnd->chWndEdit = 1;
            }

            pTVWnd->cxEdit = (WORD)(rc.right - OrgL);
            pTVWnd->cxItem = (WORD)(rc.right - pTVWnd->ptCur.x);

            CPSUIINT(("!! cxEdit=%ld, cxItem=%ld, cxMaxItem==%ld",
                        pTVWnd->cxEdit, pTVWnd->cxItem, pTVWnd->cxMaxItem));
        }
#endif
        SelectObject(hDC, hOld);
        ReleaseDC(hLBCB, hDC);

        SendMessage(hLBCB, WM_SETREDRAW, (WPARAM)TRUE, 0L);
        InvalidateRect(hLBCB, NULL, FALSE);
    }

    GSBUF_RESET;

    if ((DWORD)NewSel >= (DWORD)pOptType->Count) {

        GSBUF_GETSTR(pTVWnd->OptParamNone.pData);

    } else {

        GSBUF_GETSTR(pOptType->pOptParam[NewSel].pData);
    }

    if (IsLB) {

        if ((CurSel = (LONG)SendMessage(hLBCB,
                                        LB_FINDSTRINGEXACT,
                                        (WPARAM)-1,
                                        (LPARAM)GSBUF_BUF)) == LB_ERR) {

            CurSel = 0;
        }

    } else {

        if ((CurSel = (LONG)SendMessage(hLBCB,
                                        CB_FINDSTRINGEXACT,
                                        (WPARAM)-1,
                                        (LPARAM)GSBUF_BUF)) == CB_ERR) {

            CurSel = 0;
        }
    }

    _OI_LBCBSELIDX(pItem) = (WORD)CurSel;

    if ((InitFlags & INITCF_INIT) && (!IsLB)) {

        CPSUIDBG(DBG_CBWNDPROC, ("CBPreSel=%ld", CurSel));

        SetProp(hLBCB, CPSUIPROP_CBPRESEL, LongToHandle(CurSel + 1));
    }

    if (((Ret = (LONG)SendMessage(hLBCB,
                                  (IsLB) ? LB_GETCURSEL : CB_GETCURSEL,
                                  0,
                                  0)) == LB_ERR)    ||
        (Ret != CurSel)) {

        SendMessage(hLBCB, SetCurSelID, (WPARAM)CurSel, 0);
    }

}




VOID
InitEditBox(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    POPTPARAM   pOptParam,
    UINT        EditBoxID,
    UINT        PostfixID,
    UINT        HelpID,
    WORD        InitItemIdx,
    LPTSTR      pCurText,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 14:44:59 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;


    hCtrl = GetDlgItem(hDlg, EditBoxID);

    HCTRL_SETCTRLDATA(hCtrl, CTRLS_EDITBOX, (BYTE)pOptParam[1].IconID);
    HCTRL_STATE(hCtrl, TRUE, SW_SHOW);

    if (InitFlags & INITCF_INIT) {

        RECT    rc;
        GSBUF_DEF(pItem, MAX_RES_STR_CHARS);


        GSBUF_FLAGS |= GBF_PREFIX_OK;

        if (hCtrl) {

            SendMessageW(hCtrl,
                         EM_SETLIMITTEXT,
                         (WPARAM)pOptParam[1].IconID - 1,
                         0L);

            GSBUF_GETSTR(pCurText);
            SetWindowText(hCtrl, GSBUF_BUF);
        }
#if DO_IN_PLACE
        PostfixID =
        HelpID    = 0;
#endif

#if DO_IN_PLACE
        if ((IS_TVDLG)  &&
            (TreeView_GetItemRect(pTVWnd->hWndTV,
                                  _OI_HITEM(pItem),
                                  &rc,
                                  TRUE))) {

            LONG    cxEdit;
            LONG    OrgL;
            RECT    rcWnd;

            pTVWnd->ptCur.x = rc.left;
            pTVWnd->ptCur.y = rc.top;

            OrgL    = rc.right;
            rc.left = rc.right + pTVWnd->cxSelAdd;

            cxEdit  = (LONG)(pOptParam[1].IconID - 1) * (LONG)pTVWnd->cxAveChar;

            GetClientRect(pTVWnd->hWndTV, &rcWnd);
            rcWnd.right -= pTVWnd->cxSelAdd;

            if (pTVWnd->hWndEdit[1]) {

                rcWnd.right -= (pTVWnd->cxExtAdd + _OI_CXEXT(pItem));
            }

            if ((cxEdit + rc.left) > rcWnd.right) {

                cxEdit = rcWnd.right - rc.left;

                if (cxEdit < (LONG)(pTVWnd->cxAveChar * 16)) {

                    cxEdit = (LONG)(pTVWnd->cxAveChar * 16);
                }
            }

            rc.right = rc.left + cxEdit;

            SetWindowPos(pTVWnd->hWndEdit[0] = hCtrl,
                         NULL,
                         rc.left,
                         rc.top,
                         rc.right - rc.left,
                         rc.bottom - rc.top + 1,
                         SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);

            if (pTVWnd->hWndEdit[1]) {

                pTVWnd->chWndEdit = 2;

                rc.left  = rc.right + pTVWnd->cxExtAdd;
                rc.right = rc.left + _OI_CXEXT(pItem);

                SetWindowPos(pTVWnd->hWndEdit[1],
                             hCtrl,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top + (LONG)_OI_CYEXTADD(pItem),
                             SWP_FRAMECHANGED | SWP_DRAWFRAME);

            } else {

                pTVWnd->chWndEdit = 1;
            }

            pTVWnd->cxEdit = (WORD)(rc.right - OrgL);
            pTVWnd->cxItem = (WORD)(rc.right - pTVWnd->ptCur.x);
        }
#endif
        ID_TEXTSTATE(PostfixID, pOptParam[0].pData, TRUE, SW_SHOW);
        ID_TEXTSTATE(HelpID,    pOptParam[1].pData, TRUE, SW_SHOW);
    }
}




VOID
InitPushButton(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    WORD        PushID,
    WORD        InitItemIdx,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 15:36:54 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hPush;
    RECT    rc;


    if (hPush = CtrlIDrcWnd(hDlg, PushID, &rc)) {

        SETCTRLDATA(hPush, CTRLS_PUSHBUTTON, 0);

        if (InitFlags & INITCF_INIT) {

            POPTTYPE    pOptType;
            GSBUF_DEF(pItem, MAX_RES_STR_CHARS + 40);

#if (DO_IN_PLACE == 0)
            GSBUF_FLAGS |= GBF_PREFIX_OK;
#endif
            if ((IS_HDR_PUSH(pOptType = GET_POPTTYPE(pItem))) &&
                (IS_TVDLG)) {
#if DO_IN_PLACE
                GSBUF_GETSTR(IDS_CPSUI_REVERT);
#else
                GSBUF_GETINTSTR((pTVWnd->Flags & TWF_ONE_REVERT_ITEM) ?
                                    IDS_INT_CPSUI_UNDO_OPT :
                                    IDS_INT_CPSUI_UNDO_OPTS);
#endif
            } else {
#if DO_IN_PLACE
                GSBUF_GETSTR((pOptType->Style & OTS_PUSH_INCL_SETUP_TITLE) ?
                                IDS_CPSUI_SETUP : IDS_CPSUI_PROPERTIES);

                GSBUF_GETSTR(IDS_CPSUI_MORE);
#else
                if (pOptType->Style & OTS_PUSH_INCL_SETUP_TITLE) {

                    GSBUF_COMPOSE(IDS_INT_CPSUI_SETUP, pItem->pName, 0, 0);

                } else {

                    GSBUF_GETSTR(pItem->pName);
                }
#endif
            }

#if (DO_IN_PLACE == 0)
            if (!(pOptType->Style & OTS_PUSH_NO_DOT_DOT_DOT)) {

                GSBUF_GETSTR(IDS_CPSUI_MORE);
            }

            if (IS_TVDLG) {

                //
                // Adjust the size of push button
                //

                SetPushSize(pTVWnd,
                            hPush,
                            GSBUF_BUF,
                            GSBUF_COUNT,
                            SPSF_USE_BUTTON_CY |
                            ((InitFlags & INITCF_HAS_EXT) ?
                                                    SPSF_ALIGN_EXTPUSH : 0));
            }
#endif
            SetWindowText(hPush, GSBUF_BUF);

#if DO_IN_PLACE
            if ((IS_TVDLG)  &&
                (TreeView_GetItemRect(pTVWnd->hWndTV,
                                      _OI_HITEM(pItem),
                                      &rc,
                                      TRUE))) {

                SIZEL   szlText;
                LONG    OrgL;

                pTVWnd->ptCur.x = rc.left;
                pTVWnd->ptCur.y = rc.top;


                OrgL           = rc.right;
                rc.left        = rc.right + pTVWnd->cxSelAdd + 1;

                GetTextExtentPoint(pTVWnd->hDCTVWnd,
                                   GSBUF_BUF,
                                   GSBUF_COUNT,
                                   &szlText);

                rc.right = rc.left + szlText.cx + (LONG)(pTVWnd->cxSpace * 4);

                SetWindowPos(pTVWnd->hWndEdit[0] = hPush,
                             NULL,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top,
                             SWP_NOZORDER | SWP_DRAWFRAME | SWP_FRAMECHANGED);

                if (pTVWnd->hWndEdit[1]) {

                    pTVWnd->chWndEdit = 2;
                    rc.left           = rc.right + pTVWnd->cxExtAdd;
                    rc.right          = rc.left + (LONG)_OI_CXEXT(pItem);

                    SetWindowPos(pTVWnd->hWndEdit[1],
                                 hPush,
                                 rc.left,
                                 rc.top,
                                 rc.right - rc.left,
                                 rc.bottom - rc.top + (LONG)_OI_CYEXTADD(pItem),
                                 SWP_FRAMECHANGED | SWP_DRAWFRAME);

                } else {

                    pTVWnd->chWndEdit = 1;
                }

                pTVWnd->cxEdit = (WORD)(rc.right - OrgL);
                pTVWnd->cxItem = (WORD)(rc.right - pTVWnd->ptCur.x);
            }
#endif
        }

        SHOWCTRL(hPush, TRUE, SW_SHOW);
    }
}



VOID
InitChkBox(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    UINT        ChkBoxID,
    LPTSTR      pTitle,
    WORD        InitItemIdx,
    BOOL        Checked,
    WORD        InitFlags
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 15:41:15 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;
    RECT    rc;


    hCtrl = GetDlgItem(hDlg, ChkBoxID);

    HCTRL_SETCTRLDATA(hCtrl, CTRLS_CHKBOX, 0);

    if (InitFlags & INITCF_INIT) {

        GSBUF_DEF(pItem, MAX_RES_STR_CHARS);

        GSBUF_FLAGS |= GBF_PREFIX_OK;

        HCTRL_TEXT(hCtrl, pTitle);

#if DO_IN_PLACE
        if ((IS_TVDLG)  &&
            (TreeView_GetItemRect(pTVWnd->hWndTV,
                                  _OI_HITEM(pItem),
                                  &rc,
                                  TRUE))) {

            TV_ITEM     tvi;
            TVLP        tvlp;
            LONG        cxChkBox;

            pTVWnd->ptCur.x = rc.left;
            pTVWnd->ptCur.y = rc.top;

            tvi.mask       = TVIF_PARAM | TVIF_TEXT;
            tvi.hItem      = _OI_HITEM(pItem);
            tvi.pszText    = GSBUF_BUF;
            tvi.cchTextMax = MAX_RES_STR_CHARS;

            if (TreeView_GetItem(pTVWnd->hWndTV, &tvi)) {

                HDC     hDC;
                HGDIOBJ hOld;
                SIZEL   szlText;

                hDC = GetWindowDC(pTVWnd->hWndTV);

                if (hDC) {

                    hOld = SelectObject(hDC, (HANDLE)SendMessage(pTVWnd->hWndTV,
                                                                 WM_GETFONT,
                                                                 0,
                                                                 0L));
                    if (hOld) {

                        tvlp  = GET_TVLP(tvi.lParam);

                        GetTextExtentPoint(hDC, tvi.pszText, tvlp.cName,  &szlText);

                        rc.left += szlText.cx;

                        GetTextExtentPoint(hDC, GSBUF_BUF, GSBUF_COUNT, &szlText);
                        cxChkBox = szlText.cx;

                        GetTextExtentPoint(hDC, L"M", 1, &szlText);
                        cxChkBox += szlText.cx;

                        SelectObject(hDC, hOld);
                    }

                    ReleaseDC(pTVWnd->hWndTV, hDC);
                }

            } else {

                cxChkBox = rc.right - rc.left;
            }

            cxChkBox += pTVWnd->cxChkBoxAdd;

            if ((rc.left + cxChkBox) < rc.right) {

                cxChkBox = rc.right - rc.left;
            }

            SetWindowText(hCtrl, L" ");

            SetWindowPos(pTVWnd->hWndEdit[0] = hCtrl,
                         NULL,
                         rc.left,
                         rc.top,
                         cxChkBox,
                         rc.bottom - rc.top,
                         SWP_NOZORDER | SWP_FRAMECHANGED | SWP_DRAWFRAME);

            if (pTVWnd->hWndEdit[1]) {

                pTVWnd->chWndEdit = 2;

                SetWindowPos(pTVWnd->hWndEdit[1],
                             hCtrl,
                             rc.left + cxChkBox + pTVWnd->cxExtAdd,
                             rc.top,
                             (LONG)_OI_CXEXT(pItem),
                             rc.bottom - rc.top + (LONG)_OI_CYEXTADD(pItem),
                             SWP_FRAMECHANGED | SWP_DRAWFRAME);

            } else {

                pTVWnd->chWndEdit = 1;
            }
        }
#endif
    }

    HCTRL_STATE(hCtrl, TRUE, SW_SHOW);
    CheckDlgButton(hDlg, ChkBoxID, (Checked) ? BST_CHECKED : BST_UNCHECKED);
}



BOOL
IsItemChangeOnce(
    PTVWND      pTVWnd,
    POPTITEM    pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    18-Sep-1995 Mon 17:43:35 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTTYPE        pOptType;
    POPTPARAM       pOptParam;
    PDEVHTADJDATA   pDevHTAdjData;


    if (IS_HDR_PUSH(pOptType = GET_POPTTYPE(pItem))) {

        pItem->Flags &= ~OPTIF_CHANGEONCE;
        return(FALSE);

    } else {

        DWORD       FlagsAnd = OPTIF_CHANGEONCE;
        DWORD       FlagsOr  = 0;


        CPSUIINT(("Sel=%08lx, DefSel=%08lx",
                                    pItem->Sel, _OI_PDEFSEL(pItem)));

        switch (pOptType->Type) {

        case TVOT_EDITBOX:

            if (pTVWnd->Flags & TWF_ANSI_CALL) {

                CPSUIINT(("pEdit=%hs, pDefEdit=%hs",
                                pItem->pSel, _OI_PDEFSEL(pItem)));

                if (lstrcmpA((LPSTR)pItem->pSel, (LPSTR)_OI_PDEFSEL(pItem))) {

                    FlagsOr = OPTIF_CHANGEONCE;
                }

            } else {

                CPSUIINT(("pEdit=%s, pDefEdit=%s",
                            pItem->pSel, (LPTSTR)_OI_PDEFSEL(pItem)));

                if (lstrcmp(pItem->pSel, (LPTSTR)_OI_PDEFSEL(pItem))) {

                    FlagsOr = OPTIF_CHANGEONCE;
                }
            }

            break;

        case TVOT_PUSHBUTTON:

            //
            // The push button never changed
            //

            pOptParam = pOptType->pOptParam;

            switch (pOptParam->Style) {

            case PUSHBUTTON_TYPE_HTSETUP:

                pDevHTAdjData = (PDEVHTADJDATA)(pOptParam->pData);

                if (memcmp(_OI_PDEFSEL(pItem),
                           pDevHTAdjData->pAdjHTInfo,
                           sizeof(DEVHTINFO))) {

                    FlagsOr = OPTIF_CHANGEONCE;
                }

                break;

            case PUSHBUTTON_TYPE_HTCLRADJ:

                if (memcmp(_OI_PDEFSEL(pItem),
                           pOptParam->pData,
                           sizeof(COLORADJUSTMENT))) {

                    FlagsOr = OPTIF_CHANGEONCE;
                }

                break;

            default:

                FlagsAnd = 0;
                break;
            }

            break;

        default:

            if (pItem->pSel != (LPVOID)_OI_PDEFSEL(pItem)) {

                FlagsOr = OPTIF_CHANGEONCE;
            }

            break;
        }

        //
        // Now check the extended check box
        //

        if ((pItem->pExtChkBox)                         &&
            (!(pItem->Flags & OPTIF_EXT_IS_EXTPUSH))    &&
            ((pItem->Flags & OPTIF_ECB_MASK) !=
                                (_OI_DEF_OPTIF(pItem) & OPTIF_ECB_MASK))) {

            FlagsOr = OPTIF_CHANGEONCE;
        }

        pItem->Flags &= ~FlagsAnd;
        pItem->Flags |= FlagsOr;

        return((BOOL)FlagsOr);
    }
}




UINT
InternalDMPUB_COPIES_COLLATE(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    18-Sep-1995 Mon 15:11:07 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hCtrl;
    LONG    Sel;
    UINT    CtrlID;
    BOOL    IsTVDlg;


    Sel = pItem->Sel;

    //
    // Now check the copies or copy end text
    //

    if (IsTVDlg = (BOOL)(pTVWnd->Flags & TWF_IN_TVPAGE)) {

        CtrlID = IDD_TV_UDARROW_ENDTEXT;

    } else {

        CtrlID = (UINT)(pItem->pOptType->BegCtrlID + 4);
    }

    if (hCtrl = GetDlgItem(hDlg, CtrlID)) {

        LPTSTR  pData;

        pData = (LPTSTR)((ULONG_PTR)((Sel > 1) ? IDS_CPSUI_COPIES : IDS_CPSUI_COPY));

        if (pData != pItem->pOptType->pOptParam[0].pData) {

            GSBUF_DEF(pItem, MAX_RES_STR_CHARS);

            GSBUF_FLAGS |= GBF_PREFIX_OK;
            GSBUF_GETSTR(pData);

            SetWindowText(hCtrl, GSBUF_BUF);

            //
            // We also have set the ID here
            //

            pItem->pOptType->pOptParam[0].pData = pData;
        }
    }

    //
    // ONLY DO THIS IF THE ITEM IS CHANGABLE
    //

    if ((pTVWnd->Flags & TWF_CAN_UPDATE)        &&
        (!(pItem->Flags & (OPTIF_EXT_HIDE   |
#if DO_IN_PLACE
                            OPTIF_HIDE      |
#else
                            OPTIF_ITEM_HIDE |
#endif
                            OPTIF_DISABLED)))   &&
        (pItem->pExtChkBox)) {

        DWORD   dw;


        dw = (Sel <= 1) ? OPTIF_EXT_DISABLED : 0;

        if ((pItem->Flags & OPTIF_EXT_DISABLED) != dw) {

            pItem->Flags ^= OPTIF_EXT_DISABLED;
            pItem->Flags |= OPTIF_CHANGED;

            CtrlID = (UINT)((IsTVDlg) ? IDD_TV_EXTCHKBOX :
                                        pItem->pOptType->BegCtrlID + 7);

            if (hCtrl = GetDlgItem(hDlg, CtrlID)) {

                EnableWindow(hCtrl, !(BOOL)(pItem->Flags & OPTIF_EXT_DISABLED));
            }

            CPSUIINT(("InternalDMPUB_COPIES_COLLATE(Enable=%u)", (dw) ? 1 : 0));

            return(INTDMPUB_CHANGED);
        }
    }

    CPSUIINT(("InternalDMPUB_COPIES_COLLATE(), NO Changes"));

    return(0);
}




UINT
InternalDMPUB_QUALITY(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pQuality
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    18-Sep-1995 Mon 16:03:45 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    UINT Result = 0;


    if (pTVWnd->Flags & TWF_CAN_UPDATE) {

        POPTPARAM pParam = pQuality->pOptType->pOptParam;
        INT Count = pQuality->pOptType->Count;
        BOOL bChecked = (pQuality->Flags & OPTIF_ECB_CHECKED) ? TRUE: FALSE;

        while (Count--) {

            if (bChecked){

                pParam->Flags |= OPTPF_DISABLED;

            } else {

                if (pParam->dwReserved[0] == FALSE)
                    pParam->Flags &=~OPTPF_DISABLED;

            }

            pParam++;
        }

        pQuality->Flags |= OPTIF_CHANGED;

        Result |= INTDMPUB_CHANGED;

    }

    CPSUIINT(("InternalDMPUB_QUALITY(), Result=%04lx", Result));

    return(Result);

}


UINT
InternalDMPUB_COLOR(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItemColor
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    18-Sep-1995 Mon 16:03:45 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    UINT    Result = 0;


    if (pTVWnd->Flags & TWF_CAN_UPDATE) {

        POPTITEM    pICMItem;
        UINT        DMPubID;
        DWORD       dw;
        UINT        Idx;
        UINT        i;


        dw      = (pItemColor->Sel >= 1) ? 0 : OPTIF_DISABLED;
        i       = 2;
        DMPubID = DMPUB_ICMINTENT;

        while (i--) {

            if (pICMItem = GET_PITEMDMPUB(pTVWnd, DMPubID, Idx)) {

                if ((pICMItem->Flags & OPTIF_DISABLED) != dw) {

                    pICMItem->Flags ^= OPTIF_DISABLED;
                    pICMItem->Flags |= OPTIF_CHANGED;
                    Result          |= INTDMPUB_CHANGED;
                }
            }

            DMPubID = DMPUB_ICMMETHOD;
        }
    }

    CPSUIINT(("InternalDMPUB_COLOR(), Result=%04lx", Result));

    return(Result);
}




UINT
InternalDMPUB_ORIENTATION(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    07-Nov-1995 Tue 12:49:59 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    POPTITEM    pOIDuplex;
    UINT        Idx;
    UINT        Result = 0;
    DWORD       DuplexIcon[] = { IDI_CPSUI_DUPLEX_NONE,
                                 IDI_CPSUI_DUPLEX_HORZ,
                                 IDI_CPSUI_DUPLEX_VERT,
                                 IDI_CPSUI_DUPLEX_NONE_L,
                                 IDI_CPSUI_DUPLEX_HORZ_L,
                                 IDI_CPSUI_DUPLEX_VERT_L };

    if ((pTVWnd->Flags & TWF_CAN_UPDATE) &&
        (pOIDuplex = GET_PITEMDMPUB(pTVWnd, DMPUB_DUPLEX, Idx))) {

        LPDWORD     pdwID1;
        LPDWORD     pdwID2;
        POPTPARAM   pOPDuplex;
        UINT        Count;


        if ((pItem->pOptType->pOptParam + pItem->Sel)->IconID ==
                                                        IDI_CPSUI_PORTRAIT) {
            //
            // Portrait;
            //

            pdwID1 = &DuplexIcon[3];
            pdwID2 = DuplexIcon;

        } else {

            //
            // Landscape;
            //

            pdwID1 = DuplexIcon;
            pdwID2 = &DuplexIcon[3];
        }

        pOPDuplex = pOIDuplex->pOptType->pOptParam;
        Count     = pOIDuplex->pOptType->Count;

        while (Count--) {

            DWORD    IconIDOld;
            DWORD    IconIDCur;

            IconIDOld =
            IconIDCur = (DWORD)pOPDuplex->IconID;

            if (IconIDOld == pdwID1[0]) {

                IconIDCur = pdwID2[0];

            } else if (IconIDOld == pdwID1[1]) {

                IconIDCur = pdwID2[1];

            } else if (IconIDOld == pdwID1[2]) {

                IconIDCur = pdwID2[2];
            }

            if (IconIDCur != IconIDOld) {

                pOPDuplex->IconID  = IconIDCur;
                Result            |= INTDMPUB_REINIT;
            }

            pOPDuplex++;
        }

        if (Result) {

            pOIDuplex->Flags |= OPTIF_CHANGED;
        }
    }

    CPSUIINT(("InternalDMPUB_ORIENTATION(), Result=%04lx", Result));

    return(Result);
}




UINT
UpdateInternalDMPUB(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    18-Sep-1995 Mon 15:52:09 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND    hParent;


    hParent = (pTVWnd->Flags & TWF_IN_TVPAGE) ? pTVWnd->hWndTV : hDlg;

    switch (pItem->DMPubID) {

    case DMPUB_COPIES_COLLATE:

        return(InternalDMPUB_COPIES_COLLATE(hParent, pTVWnd, pItem));

    case DMPUB_COLOR:

        return(InternalDMPUB_COLOR(hParent, pTVWnd, pItem));

    case DMPUB_ORIENTATION:

        return(InternalDMPUB_ORIENTATION(hParent, pTVWnd, pItem));

    case DMPUB_QUALITY:

        return (InternalDMPUB_QUALITY(hParent, pTVWnd, pItem));

    default:

        return(0);
    }
}




LONG
UpdateCallBackChanges(
    HWND    hDlg,
    PTVWND  pTVWnd,
    BOOL    ReInit
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    23-Aug-1995 Wed 19:05:53 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PMYDLGPAGE  pMyDP;
    PMYDLGPAGE  pCurMyDP;
    POPTITEM    pItem;
    WORD        MyDPFlags;
    UINT        cItem;
    UINT        DlgPageIdx;
    UINT        TVPageIdx;
    INT         cUpdated = 0;


    pCurMyDP  = GET_PMYDLGPAGE(hDlg);
    pMyDP     = pTVWnd->pMyDlgPage;
    TVPageIdx = (UINT)pTVWnd->TVPageIdx;
    pItem     = pTVWnd->ComPropSheetUI.pOptItem;
    cItem     = (UINT)pTVWnd->ComPropSheetUI.cOptItem;

    while (cItem--) {

        BYTE    DMPubID;


        if (((DMPubID = pItem->DMPubID) >= DMPUB_FIRST) &&
            (DMPubID <= DMPUB_LAST)) {

            if (UpdateInternalDMPUB(hDlg, pTVWnd, pItem) & INTDMPUB_REINIT) {

                ReInit = TRUE;
            }
        }

        pItem++;
    }

    pItem     = pTVWnd->ComPropSheetUI.pOptItem;
    cItem     = (UINT)pTVWnd->ComPropSheetUI.cOptItem;
    MyDPFlags = MYDPF_CHANGED | MYDPF_CHANGEONCE | ((ReInit) ? MYDPF_REINIT :
                                                               0);

    while (cItem--) {

        if (pItem->Flags & OPTIF_CHANGED) {

            DlgPageIdx               = (UINT)pItem->DlgPageIdx;
            pMyDP[DlgPageIdx].Flags |= MyDPFlags;

            //
            // turn off the CHANGEONCE flags if it change back
            //

            IsItemChangeOnce(pTVWnd, pItem);

            pItem->Flags |= OPTIF_INT_TV_CHANGED;

            if (DlgPageIdx != TVPageIdx) {

                pItem->Flags |= OPTIF_INT_CHANGED;
            }

            pItem->Flags &= ~OPTIF_CHANGED;

            ++cUpdated;
        }

        pItem++;
    }

    if ((cUpdated) && (TVPageIdx != PAGEIDX_NONE)) {

        pMyDP[TVPageIdx].Flags |= MyDPFlags;
    }

    //
    // Now if this page is need to change, then change it now
    //

    if (pCurMyDP->Flags & MYDPF_CHANGED) {

        if (pCurMyDP->PageIdx == TVPageIdx) {

            UpdateTreeView(hDlg, pCurMyDP);

        } else {

            UpdatePropPage(hDlg, pCurMyDP);
        }
    }

    CPSUIDBG(DBG_UCBC, ("CallBack cUpdated=%ld", (DWORD)cUpdated));

    SET_APPLY_BUTTON(pTVWnd, hDlg);

    return((LONG)cUpdated);
}



LRESULT
CALLBACK
AboutPosDlgProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PABOUTPOS   pAP;
    RECT        rc;


    switch(Msg) {

    case WM_INITDIALOG:

        SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

        pAP = (PABOUTPOS)lParam;

        GetWindowRect(hDlg, &rc);

        rc.left = (LONG)LOWORD(pAP->Pos) - ((rc.right - rc.left) / 2);
        rc.top  = (LONG)HIWORD(pAP->Pos) - ((rc.bottom - rc.top) / 2);

        SetWindowPos(hDlg,
                     NULL,
                     rc.left,
                     rc.top,
                     0, 0,
                     SWP_NOSIZE | SWP_NOZORDER);

        pAP->pCBParam->hDlg = hDlg;
        pAP->pfnCallBack(pAP->pCBParam);

        EndDialog(hDlg, 0);
        return(TRUE);
    }

    return(FALSE);
}




LONG
DoCallBack(
    HWND                hDlg,
    PTVWND              pTVWnd,
    POPTITEM            pItem,
    LPVOID              pOldSel,
    _CPSUICALLBACK      pfnCallBack,
    HANDLE              hDlgTemplate,
    WORD                DlgTemplateID,
    WORD                Reason
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 21:09:08 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PMYDLGPAGE  pCurMyDP;
    PPSPINFO    pPSPInfo;
    LONG        Ret = CPSUICB_ACTION_NONE;
    ULONG_PTR   Result;
    BOOL        DoSetResult = FALSE;


    if (!(pCurMyDP = GET_PMYDLGPAGE(hDlg))) {

        CPSUIERR(("hDlg=%08lx, pCurMyDP=NULL", hDlg));

        return(CPSUICB_ACTION_NONE);
    }

    if (!(pPSPInfo = pCurMyDP->pPSPInfo)) {

        CPSUIERR(("hDlg=%08lx, pCurMyDP->pPSPInfo=NULL", hDlg));

        return(CPSUICB_ACTION_NONE);
    }

    if ((!hDlgTemplate) && (!DlgTemplateID)) {

        if (!pfnCallBack) {

            pfnCallBack = pTVWnd->ComPropSheetUI.pfnCallBack;
        }
    }

    if (pfnCallBack) {

        HWND            hFocus;
        POPTTYPE        pOptType;
        CPSUICBPARAM    CBParam;
        BOOL            SetNewDef;


        if (Reason == CPSUICB_REASON_APPLYNOW) {

            SetNewDef = (pItem) ? TRUE : FALSE;
            pItem     = pTVWnd->ComPropSheetUI.pOptItem;
        }

        CPSUIOPTITEM(DBGITEM_CB, pTVWnd, "CallBack Item", 2, pItem);
        CPSUIDBG(DBG_DOCB, ("pfnCallBack=%08lx, CALLBACK READSON=%ld",
                                    pfnCallBack, Reason));

        if (Reason == CPSUICB_REASON_ABOUT) {

            DlgTemplateID = DLGABOUT;
        }

        if (!(hFocus = GetFocus())) {

            hFocus = hDlg;
        }

        pOptType         = GET_POPTTYPE(pItem);
        CBParam.cbSize   = sizeof(CPSUICBPARAM);
        CBParam.Reason   = Reason;
        CBParam.hDlg     = hDlg;
        CBParam.pOptItem = pTVWnd->ComPropSheetUI.pOptItem;
        CBParam.cOptItem = pTVWnd->ComPropSheetUI.cOptItem;
        CBParam.Flags    = pTVWnd->ComPropSheetUI.Flags;
        CBParam.pCurItem = pItem;
        CBParam.pOldSel  = pOldSel;
        CBParam.UserData = pTVWnd->ComPropSheetUI.UserData;
        CBParam.Result   = CPSUI_OK;

        if ((hDlgTemplate)  ||
            (DlgTemplateID)) {

            if (hDlgTemplate) {

                try {

                    DialogBoxIndirectParam(_OI_HINST(pItem),
                                           (LPDLGTEMPLATE)hDlgTemplate,
                                           hDlg,
                                           (DLGPROC)pfnCallBack,
                                           (LPARAM)&CBParam);

                } except (FilterException(pPSPInfo->hComPropSheet,
                                          GetExceptionInformation())) {

                    CPSUIERR(("DialogBoxIndirectParam(%08lx), Exception", pfnCallBack));
                }

            } else {

                if (Reason == CPSUICB_REASON_ABOUT) {

                    ABOUTPOS    AP;

                    AP.pfnCallBack = pfnCallBack;
                    AP.pCBParam    = &CBParam;
                    AP.hFocus      = hFocus;
                    AP.Pos         = pTVWnd->MousePos;

                    CPSUIINT(("AboutPosDlg: Pos=(%ld, %ld), hDlg=%08lx (%ld), hFocus=%08lx (%ld)",
                                (LONG)LOWORD(pTVWnd->MousePos),
                                (LONG)HIWORD(pTVWnd->MousePos),
                                hDlg, GetWindowLongPtr(hDlg, GWLP_ID),
                                hFocus, GetWindowLongPtr(hFocus, GWLP_ID)));

                    try {

                        DialogBoxParam(hInstDLL,
                                       MAKEINTRESOURCE(DLGABOUT),
                                       hDlg,
                                       AboutPosDlgProc,
                                       (LPARAM)&AP);

                    } except (FilterException(pPSPInfo->hComPropSheet,
                                              GetExceptionInformation())) {

                        CPSUIERR(("DialogBoxParam(ABOUTPOS: %08lx), Exception", pfnCallBack));
                    }

                } else {

                    try {

                        DialogBoxParam(_OI_HINST(pItem),
                                       (LPCTSTR)MAKEINTRESOURCE(DlgTemplateID),
                                       hDlg,
                                       (DLGPROC)pfnCallBack,
                                       (LPARAM)&CBParam);

                    } except (FilterException(pPSPInfo->hComPropSheet,
                                              GetExceptionInformation())) {

                        CPSUIERR(("DialogBoxParam(%08lx), Exception", pfnCallBack));
                    }
                }
            }

        } else {

            HCURSOR hCursor;

            if (Reason == CPSUICB_REASON_APPLYNOW) {

                hCursor = SetCursor(LoadCursor(NULL,
                                               (LPCTSTR)(ULONG_PTR)IDC_WAIT));
            }

            try {

                Ret = pfnCallBack(&CBParam);

            } except (FilterException(pPSPInfo->hComPropSheet,
                                      GetExceptionInformation())) {

                CPSUIERR(("pfnCallBack 1=%08lx, Exception", pfnCallBack));
                Ret = CPSUICB_ACTION_NONE;
            }

            if (Reason == CPSUICB_REASON_APPLYNOW) {

                SetCursor(hCursor);

                if (Ret != CPSUICB_ACTION_NO_APPLY_EXIT) {

                    DoSetResult = TRUE;
                    Result      = CBParam.Result;

                    //
                    // Save the new setting to as current default and also call
                    // common UI to set the result to the original caller
                    //

                    if (SetNewDef) {

                        CPSUIDBG(DBG_DOCB,
                                 ("*APPLYNOW=%ld, SET NEW DEFAULT", Ret));

                        SetOptItemNewDef(hDlg, pTVWnd, FALSE);
                    }
                }
            }
        }

        if ((pTVWnd->Flags & TWF_CAN_UPDATE) &&
            ((Ret == CPSUICB_ACTION_OPTIF_CHANGED)  ||
             (Ret == CPSUICB_ACTION_REINIT_ITEMS))) {

            CPSUIDBG(DBG_DOCB, ("CallBack()=OPTIF_CHANGED=%ld", Ret));

            if (((IS_HDR_PUSH(pOptType))    ||
                 (Reason == CPSUICB_REASON_ITEMS_REVERTED)) &&
                (pfnCallBack = pTVWnd->ComPropSheetUI.pfnCallBack)) {

                CPSUIINT(("CPSUICB_REASON_ITEMS_REVERTED CallBack"));

                CBParam.cbSize   = sizeof(CPSUICBPARAM);
                CBParam.Reason   = CPSUICB_REASON_ITEMS_REVERTED;
                CBParam.hDlg     = hDlg;
                CBParam.pOptItem = pTVWnd->ComPropSheetUI.pOptItem;
                CBParam.cOptItem = pTVWnd->ComPropSheetUI.cOptItem;
                CBParam.Flags    = pTVWnd->ComPropSheetUI.Flags;
                CBParam.pCurItem = CBParam.pOptItem;
                CBParam.OldSel   = pTVWnd->ComPropSheetUI.cOptItem;
                CBParam.UserData = pTVWnd->ComPropSheetUI.UserData;
                CBParam.Result   = CPSUI_OK;

                //
                // This is the header push callback, so let the caller know
                //

                try {

                    pfnCallBack(&CBParam);

                } except (FilterException(pPSPInfo->hComPropSheet,
                                          GetExceptionInformation())) {

                    CPSUIERR(("pfnCallBack 2=%08lx, Exception", pfnCallBack));
                    Ret = CPSUICB_ACTION_NONE;
                }

                Ret = CPSUICB_ACTION_REINIT_ITEMS;
            }

            UpdateCallBackChanges(hDlg,
                                  pTVWnd,
                                  Ret == CPSUICB_ACTION_REINIT_ITEMS);
        }

    } else if (Reason == CPSUICB_REASON_APPLYNOW) {

        //
        // If the caller does not hook this, then we will call to set it
        // to its owner's parent ourself
        //

        DoSetResult = TRUE;
        Result      = CPSUI_OK;
    }

    //
    // Now propage the result to the owner
    //

    if (DoSetResult) {

        pPSPInfo->pfnComPropSheet(pPSPInfo->hComPropSheet,
                                  CPSFUNC_SET_RESULT,
                                  (LPARAM)pPSPInfo->hCPSUIPage,
                                  Result);
    }

    return(Ret);
}



INT_PTR
CALLBACK
AboutDlgProc(
    HWND    hDlg,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    ABOUTINFO           AI;
    PTVWND              pTVWnd;
    HICON               hIcon;
    LPVOID              pvAlloc = NULL;
    LPWSTR              pwsz;
    VS_FIXEDFILEINFO    *pvsf;
    WCHAR               wBuf[MAX_RES_STR_CHARS * 2];
    DWORD               dw;
    WORD                Version;
    UINT                cChar;



    switch(Msg) {

    case WM_INITDIALOG:

        AI     =  *(PABOUTINFO)lParam;
        pTVWnd = AI.pTVWnd;
        hIcon  = AI.hIcon;

        GetModuleFileName(pTVWnd->hInstCaller, wBuf, COUNT_ARRAY(wBuf));

        if ((dw = GetFileVersionInfoSize(wBuf, &dw))   &&
            (pvAlloc = (LPVOID)LocalAlloc(LPTR, dw))) {

            GetFileVersionInfo(wBuf, 0, dw, pvAlloc);
        }

        //
        // Compose Caller Name / Version
        //

        cChar         = GetWindowText(hDlg, wBuf, COUNT_ARRAY(wBuf));
        wBuf[cChar++] = L' ';

        cChar += GetStringBuffer(pTVWnd->hInstCaller,
                                 (WORD)(GBF_PREFIX_OK        |
                                        GBF_INT_NO_PREFIX    |
                                        ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                            GBF_ANSI_CALL : 0)),
                                 L'\0',
                                 pTVWnd->ComPropSheetUI.pCallerName,
                                 &wBuf[cChar],
                                 COUNT_ARRAY(wBuf) - cChar - 1);

        SetWindowText(hDlg, wBuf);

        Version = pTVWnd->ComPropSheetUI.CallerVersion;

        cChar = ComposeStrData(pTVWnd->hInstCaller,
                               (WORD)(GBF_PREFIX_OK        |
                                      GBF_INT_NO_PREFIX    |
                                      ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                        GBF_ANSI_CALL : 0)),
                               wBuf,
                               COUNT_ARRAY(wBuf),
                               (Version) ? IDS_INT_CPSUI_VERSION : 0,
                               pTVWnd->ComPropSheetUI.pCallerName,
                               HIBYTE(Version),
                               LOBYTE(Version));

        SetDlgItemText(hDlg, IDS_ABOUT_CALLER, wBuf);

        GetModuleFileName(pTVWnd->hInstCaller, wBuf, COUNT_ARRAY(wBuf));

        if (pvAlloc) {

            VerQueryValue(pvAlloc, L"\\", &pvsf, &dw);

            pwsz = NULL;
            VerQueryValue(pvAlloc,
                          L"\\StringFileInfo\\040904B0\\ProductName",
                          &pwsz,
                          &dw);

            if (pwsz) {
                SetDlgItemText(hDlg, IDS_ABOUT_PRODUCT, pwsz);
            }

            cChar = GetDlgItemText(hDlg,
                                   IDS_ABOUT_CALLER,
                                   wBuf,
                                   COUNT_ARRAY(wBuf));

            StringCchPrintfW(&wBuf[cChar], 
                             COUNT_ARRAY(wBuf) - cChar, 
                             L"  (%u.%u:%u.%u)",
                             HIWORD(pvsf->dwProductVersionMS),
                             LOWORD(pvsf->dwProductVersionMS),
                             HIWORD(pvsf->dwProductVersionLS),
                             LOWORD(pvsf->dwProductVersionLS));

            SetDlgItemText(hDlg, IDS_ABOUT_CALLER, wBuf);

            pwsz = NULL;
            VerQueryValue(pvAlloc,
                          L"\\StringFileInfo\\040904B0\\LegalCopyright",
                          &pwsz,
                          &dw);
            if (pwsz) {
                SetDlgItemText(hDlg, IDS_ABOUT_COPYRIGHT, pwsz);
            }
        }

        //
        // OPTITEM NAME VERSION
        //

        Version  = pTVWnd->ComPropSheetUI.OptItemVersion;

        ComposeStrData(pTVWnd->hInstCaller,
                       (WORD)(GBF_PREFIX_OK        |
                              GBF_INT_NO_PREFIX    |
                              ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                   GBF_ANSI_CALL : 0)),
                       wBuf,
                       COUNT_ARRAY(wBuf),
                       (Version) ? IDS_INT_CPSUI_VERSION : 0,
                       pTVWnd->ComPropSheetUI.pOptItemName,
                       HIBYTE(Version),
                       LOBYTE(Version));

        SetDlgItemText(hDlg, IDS_ABOUT_OPTITEM, wBuf);

        SendMessage(GetDlgItem(hDlg, IDI_ABOUT_ICON),
                    STM_SETIMAGE,
                    (WPARAM)IMAGE_ICON,
                    (LPARAM)hIcon);

        if (pvAlloc) {

            LocalFree(pvAlloc);
        }

        if (AI.Pos) {

            RECT    rc;

            GetWindowRect(hDlg, &rc);

            rc.left = (LONG)LOWORD(AI.Pos) - ((rc.right - rc.left) / 2);
            rc.top  = (LONG)HIWORD(AI.Pos) - ((rc.bottom - rc.top) / 2);

            SetWindowPos(hDlg,
                         NULL,
                         rc.left,
                         rc.top,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER);
        }

        return(TRUE);

    case WM_COMMAND:

        switch (LOWORD(wParam)) {

        case IDOK:
        case IDCANCEL:

            EndDialog(hDlg, 0);
            return(TRUE);

        }

        break;

    }

    return(FALSE);
}




BOOL
DoAbout(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItemRoot
    )

/*++

Routine Description:

    This function pop up the about dialog box


Arguments:




Return Value:




Author:

    09-Oct-1995 Mon 13:10:41 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HICON       hIcon;
    HICON       hIconLoad = NULL;
    ABOUTINFO   AI;
    ULONG_PTR   IconID;
    BOOL        bRet;



    if (pTVWnd->ComPropSheetUI.Flags & CPSUIF_ABOUT_CALLBACK) {

        DoCallBack(hDlg,
                   pTVWnd,
                   pTVWnd->ComPropSheetUI.pOptItem,
                   (LPVOID)pTVWnd->pCPSUI,
                   NULL,
                   NULL,
                   0,
                   CPSUICB_REASON_ABOUT);

        return(TRUE);
    }

    IconID = GETSELICONID(pItemRoot);

    if (VALID_PTR(IconID)) {

        hIcon = GET_HICON(IconID);

    } else {

        hIconLoad =
        hIcon     = GETICON(_OI_HINST(pItemRoot), LODWORD(IconID));
    }

    AI.pTVWnd = pTVWnd;
    AI.hIcon  = hIcon;
    AI.Pos    = pTVWnd->MousePos;

    bRet = DialogBoxParam(hInstDLL,
                          MAKEINTRESOURCE(DLGABOUT),
                          hDlg,
                          AboutDlgProc,
                          (LPARAM)&AI) ? TRUE : FALSE;

    if (hIconLoad) {

        DestroyIcon(hIconLoad);
    }

    return(bRet);
}





LONG
DoPushButton(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    25-Aug-1995 Fri 20:57:42 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    ULONG_PTR       ulCookie = 0;
    PMYDLGPAGE      pCurMyDP;
    PPSPINFO        pPSPInfo;
    HINSTANCE       hInst = NULL;
    FARPROC         farproc;
    POPTTYPE        pOptType;
    POPTPARAM       pOptParam;
    DEVHTADJDATA    DevHTAdjData;
    LONG            Ret;
    UINT            Idx;
    BOOL            IsColor;
    GSBUF_DEF(pItem, MAX_RES_STR_CHARS);


    if (!(pCurMyDP = GET_PMYDLGPAGE(hDlg))) {

        CPSUIERR(("hDlg=%08lx, pCurMyDP=NULL", hDlg));

        return(0);
    }

    if (!(pPSPInfo = pCurMyDP->pPSPInfo)) {

        CPSUIERR(("hDlg=%08lx, pCurMyDP->pPSPInfo=NULL", hDlg));

        return(0);
    }

    pOptType  = GET_POPTTYPE(pItem);
    pOptParam = pOptType->pOptParam;
    Ret       = pItem->Sel;

    switch(pOptParam[0].Style) {

    case PUSHBUTTON_TYPE_DLGPROC:

        if (pOptParam[0].pData) {

            Ret = DoCallBack(hDlg,
                             pTVWnd,
                             pItem,
                             pItem->pSel,
                             (_CPSUICALLBACK)pOptParam[0].pData,
                             (pOptParam[0].Flags & OPTPF_USE_HDLGTEMPLATE) ?
                                        (HANDLE)pOptParam[0].lParam : NULL,
                             (WORD)pOptParam[0].lParam,
                             CPSUICB_REASON_DLGPROC);
        }

        break;

    case PUSHBUTTON_TYPE_CALLBACK:

        DoCallBack(hDlg,
                   pTVWnd,
                   pItem,
                   pItem->pSel,
                   (_CPSUICALLBACK)pOptParam[0].pData,
                   NULL,
                   0,
                   CPSUICB_REASON_PUSHBUTTON);

        break;

    case PUSHBUTTON_TYPE_HTCLRADJ:

        //
        // HTUI.DLL is part of the OS, so we need to make sure 
        // it always gets loaded into V6 context.
        //
        ulCookie = 0;
        if (SHActivateContext(&ulCookie)) {

            __try {

                IsColor = (BOOL)((pItem = GET_PITEMDMPUB(pTVWnd, DMPUB_COLOR, Idx)) &&
                                 (pItem->Sel >= 1));

                CPSUIDBG(DBG_DOPB, ("ColorAdj: IsColor=%ld, Update=%ld",
                            (DWORD)IsColor, (DWORD)pTVWnd->Flags & TWF_CAN_UPDATE));

                GSBUF_RESET;
                GSBUF_FLAGS |= GBF_PREFIX_OK;
                GSBUF_GETSTR(pTVWnd->ComPropSheetUI.pOptItemName);

                if ((hInst = LoadLibrary(TEXT("htui"))) &&
                    (farproc = GetProcAddress(hInst, (LPCSTR)szHTUIClrAdj))) {

                    try {

                        Ret = (LONG)(*farproc)((LPWSTR)GSBUF_BUF,
                                               NULL,
                                               NULL,
                                               (PCOLORADJUSTMENT)pOptParam[0].pData,
                                               !IsColor,
                                               pTVWnd->Flags & TWF_CAN_UPDATE);

                    } except (FilterException(pPSPInfo->hComPropSheet,
                                              GetExceptionInformation())) {

                        CPSUIERR(("Halftone Proc=%hs, Exception", szHTUIClrAdj));
                        Ret = 0;
                    }
                }
            }
            __finally {

                //
                // we need to deactivate the context, no matter what!
                //
                SHDeactivateContext(ulCookie);
            }
        }

        break;

    case PUSHBUTTON_TYPE_HTSETUP:

        //
        // HTUI.DLL is part of the OS, so we need to make sure 
        // it always gets loaded into V6 context.
        //
        ulCookie = 0;
        if (SHActivateContext(&ulCookie)) {

            __try {

                DevHTAdjData = *(PDEVHTADJDATA)(pOptParam[0].pData);

                if (!(pTVWnd->Flags & TWF_CAN_UPDATE)) {

                    DevHTAdjData.pDefHTInfo = DevHTAdjData.pAdjHTInfo;
                }

                GSBUF_RESET;
                GSBUF_FLAGS |= GBF_PREFIX_OK;
                GSBUF_GETSTR(pTVWnd->ComPropSheetUI.pOptItemName);

                if ((hInst = LoadLibrary(TEXT("htui"))) &&
                    (farproc = GetProcAddress(hInst, (LPCSTR)szHTUIDevClrAdj))) {

                    try {

                        Ret = (LONG)(*farproc)((LPWSTR)GSBUF_BUF, &DevHTAdjData);

                    } except (FilterException(pPSPInfo->hComPropSheet,
                                              GetExceptionInformation())) {

                        CPSUIERR(("Halftone Proc=%hs, Exception", szHTUIDevClrAdj));

                        Ret = 0;
                    }
                }
            }
            __finally {

                //
                // we need to deactivate the context, no matter what!
                //
                SHDeactivateContext(ulCookie);
            }
        }

        break;
    }

    if (hInst) {

        FreeLibrary(hInst);
    }

    CPSUIOPTITEM(DBGITEM_PUSH, pTVWnd, "PUSHBUTTON:", 0, pItem);

    return(Ret);
}






POPTITEM
pItemFromhWnd(
    HWND    hDlg,
    PTVWND  pTVWnd,
    HWND    hCtrl,
    LONG    MousePos
    )

/*++

Routine Description:

    This function take a hWnd and return a pItem associate with it



Arguments:

    hDlg        - Handle to the dialog box page

    pTVWnd      - Our instance handle

    hCtrl       - the handle to the focus window

    MousePos    - MAKELONG(x, y) of current mouse position


Return Value:

    POPTITEM, null if failed


Author:

    26-Sep-1995 Tue 12:24:36 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    DWORD   dw;


    if ((!hCtrl) || (hCtrl == hDlg)) {

        POINT   pt;

        pt.x = LOWORD(MousePos);
        pt.y = HIWORD(MousePos);

        ScreenToClient(hDlg, (LPPOINT)&pt);

        if ((MousePos == -1)                                                   ||
            (!(hCtrl = ChildWindowFromPointEx(hDlg, pt, CWP_SKIPINVISIBLE)))   ||
            (hCtrl == hDlg)) {

            CPSUIDBG(DBG_IFW, ("hDlg=%08lx, No hWnd From  from Mouse Pos=(%ld, %ld)",
                                    hDlg, pt.x, pt.y));

            return(NULL);
        }
    }

    CPSUIDBG(DBG_IFW, ("!! Find The hCtrl=%08lx", hCtrl));

    if (dw = (DWORD)GetWindowLongPtr(hCtrl, GWLP_USERDATA)) {

        WORD    ItemIdx;


        if (pTVWnd->Flags & TWF_IN_TVPAGE) {

            return(pTVWnd->pCurTVItem);
        }

        ItemIdx = (WORD)GETCTRLITEMIDX(dw);

        CPSUIDBG(DBG_IFW, ("ID=%ld, Idx=%ld, dw=%08lx",
                (DWORD)GetDlgCtrlID(hCtrl), (DWORD)ItemIdx, dw));

        //
        // Validate what we got
        //

        if (ItemIdx >= INTIDX_FIRST) {

            return(PIDX_INTOPTITEM(pTVWnd, ItemIdx));

        } else if (ItemIdx < pTVWnd->ComPropSheetUI.cOptItem) {

            return(pTVWnd->ComPropSheetUI.pOptItem + ItemIdx);
        }

    } else {

        CPSUIINT(("pItemFromhWnd: hCtrl=%08lx, GWLP_USERDATA=%08lx", hCtrl, dw));
    }

    CPSUIINT(("pItemFromhWnd: NONE"));

    return(NULL);
}




VOID
DoContextMenu(
    PTVWND      pTVWnd,
    HWND        hDlg,
    POPTITEM    pItem,
    LPARAM      Pos
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    17-Feb-1998 Tue 17:59:20 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HMENU   hMenu;
    UINT    cMenu = 0;
    UINT    cChar;
    WCHAR   wBuf[MAX_RES_STR_CHARS + 40];

    if (hMenu = CreatePopupMenu()) {

        pTVWnd->pMouseItem = pItem;
        pTVWnd->MousePos   = Pos;

        CPSUIINT(("Create PopUpMenu=%08lx, pItem=%08lx, hFocus=%08lx (%ld)",
                hMenu, pItem, GetFocus(), GetWindowLongPtr(GetFocus(), GWLP_ID)));

        if ((pItem) &&
            (cChar = CountRevertOptItem(pTVWnd, pItem, _OI_HITEM(pItem), 0))) {

            if (cMenu++) {

                AppendMenu(hMenu,
                           MF_SEPARATOR,
                           0,
                           NULL);
            }

            ComposeStrData(pTVWnd->hInstCaller,
                           (WORD)(GBF_PREFIX_OK        |
                                  ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                    GBF_ANSI_CALL : 0)),
                           wBuf,
                           COUNT_ARRAY(wBuf),
                           (UINT)(cChar > 1) ? IDS_INT_CPSUI_UNDO_OPTS :
                                               IDS_INT_CPSUI_UNDO_OPT,
                           pItem->pName,
                           cChar,
                           0);

            AppendMenu(hMenu,
                       MF_ENABLED | MF_STRING,
                       ID_CMD_UNDO,
                       wBuf);
        }

        if (pItem) {

            if (cMenu++) {

                AppendMenu(hMenu,
                           MF_SEPARATOR,
                           0,
                           NULL);
            }

            GetStringBuffer(pTVWnd->hInstCaller,
                            (WORD)(GBF_PREFIX_OK        |
                                   GBF_IDS_INT_CPSUI    |
                                   ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                       GBF_ANSI_CALL : 0)),
                            L'\0',
                            (LPTSTR)IDS_INT_CPSUI_WHATISTHIS,
                            wBuf,
                            COUNT_ARRAY(wBuf) - 1);

            AppendMenu(hMenu,
                       MF_ENABLED | MF_STRING,
                       ID_CMD_HELP,
                       wBuf);
        }

        if (cMenu++) {

            AppendMenu(hMenu,
                       MF_SEPARATOR,
                       0,
                       NULL);
        }

        cChar = ComposeStrData(pTVWnd->hInstCaller,
                               (WORD)(GBF_PREFIX_OK        |
                                      ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                        GBF_ANSI_CALL : 0)),
                               wBuf,
                               COUNT_ARRAY(wBuf),
                               (UINT)IDS_INT_CPSUI_ABOUT,
                               pTVWnd->ComPropSheetUI.pCallerName,
                               0,
                               0);

        GetStringBuffer(pTVWnd->hInstCaller,
                        (WORD)(GBF_PREFIX_OK        |
                               ((pTVWnd->Flags & TWF_ANSI_CALL) ?
                                                   GBF_ANSI_CALL : 0)),
                        L'\0',
                        (LPTSTR)IDS_CPSUI_MORE,
                        &wBuf[cChar],
                        COUNT_ARRAY(wBuf) - cChar - 1);

        AppendMenu(hMenu,
                   MF_ENABLED | MF_STRING,
                   ID_CMD_ABOUT,
                   wBuf);

        if (!pItem) {

            pTVWnd->pMouseItem = PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT);
        }

        TrackPopupMenu(hMenu,
                       TPM_LEFTALIGN | TPM_LEFTBUTTON,
                       LOWORD(Pos),
                       HIWORD(Pos),
                       0,
                       hDlg,
                       NULL);

        CPSUIINT(("DESTROY PopUpMenu=%08lx, cMenu=%08lx", hMenu, cMenu));

        DestroyMenu(hMenu);
    }
}




LONG
FindNextLBCBSel(
    HWND        hLBCB,
    LONG        SelLast,
    LONG        SelNow,
    UINT        IDGetItemData,
    LPDWORD     pItemData
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    10-Sep-1995 Sun 23:58:44 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LONG    Count;
    LONG    SelAdd;
    DWORD   ItemData;


    Count  = (LONG)SendMessage(hLBCB,
                               (IDGetItemData == LB_GETITEMDATA) ?
                                               LB_GETCOUNT : CB_GETCOUNT,
                               0,
                               0L);
    SelAdd = (SelNow >= SelLast) ? 1 : -1;

    while (((SelNow += SelAdd) >= 0) && (SelNow < Count)) {

        ItemData = (DWORD)SendMessage(hLBCB, IDGetItemData, SelNow, 0L);

        if (!(ItemData & LBCBID_DISABLED)) {

            *pItemData = ItemData;
            return(SelNow);
        }
    }

    //
    // We could not find the one which is enabled, so go back to the old one
    //

    *pItemData = (DWORD)SendMessage(hLBCB, IDGetItemData, SelLast, 0L);
    return(SelLast);
}




BOOL
DrawLBCBItem(
    PTVWND              pTVWnd,
    LPDRAWITEMSTRUCT    pdis
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    11-Sep-1995 Mon 18:44:05 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HDC         hDC;
    PLAYOUTBMP  pData;
    POPTITEM    pItem;
    POPTTYPE    pOptType;
    WORD        OPIdx;
    INT         y;
    UINT        ItemState;
    BYTE        CtrlStyle;
    BYTE        CtrlData;
    WORD        ItemIdx;
    WORD        Count;
    WORD        OTFlags;
    DWORD       dw;
    ULONG_PTR   ItemData;
    RECT        rc;
    POINT       TextOff;
    DWORD       OldBkMode;
    COLORREF    OldClr;
    COLORREF    OldBkClr;
    INT         FillIdx;
    INT         TextIdx;
    HBRUSH      hbr;
    BOOL        IsLB = TRUE;
    TEXTMETRIC  tm;
    LRESULT     uLen;
    LPTSTR      pszItem = NULL;

    if (pdis->itemID == -1) {

        return(FALSE);
    }

    switch (pdis->CtlType) {

    case ODT_COMBOBOX:

        IsLB = FALSE;

    case ODT_LISTBOX:

        break;

    case ODT_BUTTON:

        if ((pdis->CtlID == IDD_LAYOUT_PICTURE)     &&
            (pdis->itemAction & (ODA_DRAWENTIRE ))  &&
            (pData = (PLAYOUTBMP)GetProp(pdis->hwndItem,
                                         CPSUIPROP_LAYOUTPUSH))) {

            UpdateLayoutBmp(pdis->hDC, pData);

        }

        return TRUE;

    default:

        return(FALSE);
    }

    if (!(dw = (DWORD)GetWindowLongPtr(pdis->hwndItem, GWLP_USERDATA))) {

        CPSUIDBG(DBG_CS, ("DrawLBCBItem: dw=0, hCtrl=%08lx, CtlID=%08lx",
                                            pdis->hwndItem, pdis->CtlID));
        return(FALSE);
    }

    GETCTRLDATA(dw, ItemIdx, CtrlStyle, CtrlData);


    if ((!(pItem = GetOptions(pTVWnd, MAKELPARAM(ItemIdx, 0)))) ||
        (!(pOptType = GET_POPTTYPE(pItem)))                     ||
        (pItem->Flags & OPTIF_ITEM_HIDE)) {

        CPSUIERR(("DrawLBCB: Invalid Ctrl or ItemIdx=%ld", ItemIdx));
        return(FALSE);
    }

#if (DO_IN_PLACE == 0)
    CPSUIASSERT(0, "DrawLBCB: The type is not LB or CB but [%u]",
                    (pOptType->Type == TVOT_LISTBOX) ||
                    (pOptType->Type == TVOT_COMBOBOX), (UINT)pOptType->Type);
#endif

    OTFlags  = _OT_FLAGS(pOptType);
    hDC      = pdis->hDC;
    rc       = pdis->rcItem;
    ItemData = pdis->itemData;

    //
    // Get the length of this item's text
    //
    uLen = (IsLB) ? LB_ERR : CB_ERR;
    uLen = SendMessage(pdis->hwndItem,
                (IsLB) ? LB_GETTEXTLEN : CB_GETLBTEXTLEN,
                (WPARAM)pdis->itemID,
                (LPARAM)0);
        
    if (uLen > 0)
    {
        //
        // Allocate a buffer for the string
        //
        pszItem = (LPTSTR)LocalAlloc( LPTR,(uLen + 1) * sizeof(TCHAR));
        if (pszItem)
        {
            //
            // Get the string
            //
            SendMessage(pdis->hwndItem,
                (IsLB) ? LB_GETTEXT : CB_GETLBTEXT,
                (WPARAM)pdis->itemID,
                (LPARAM)pszItem);
        }
    }

    switch (pdis->itemAction) {

    case ODA_SELECT:
    case ODA_DRAWENTIRE:

        GetTextMetrics(hDC, &tm);

        ItemState = pdis->itemState;

#if DO_IN_PLACE
        CPSUIINT(("hwndItem=%08lx", pdis->hwndItem));

        if ((ItemState & ODS_COMBOBOXEDIT)          &&
            (pTVWnd->Flags & TWF_IN_TVPAGE)) {

            OTFlags &= ~OTINTF_ITEM_HAS_ICON16;
        }
#endif
        TextOff.x = (OTFlags & OTINTF_ITEM_HAS_ICON16) ?
                        (LBCB_ICON_X_OFF + CXIMAGE + LBCB_ICON_TEXT_X_SEP) :
                        (LBCB_ICON_X_OFF);
        TextOff.y = (rc.bottom + rc.top - tm.tmHeight) / 2;

        //
        // Fill the selection rectangle from the location, this is only
        // happpened if we wre not disabled
        //

        if (ItemState & ODS_DISABLED) {

            if ((ItemState & ODS_SELECTED) && (IsLB)) {

                FillIdx = COLOR_3DSHADOW;
                TextIdx = COLOR_3DFACE;

            } else {

                FillIdx = COLOR_3DFACE;
                TextIdx = COLOR_GRAYTEXT;
            }

        } else {

            if (ItemState & ODS_SELECTED) {

                FillIdx  = COLOR_HIGHLIGHT;
                dw       = COLOR_HIGHLIGHTTEXT;

            } else {

                FillIdx = COLOR_WINDOW;
                dw      = COLOR_WINDOWTEXT;
            }

            if (ItemData & LBCBID_DISABLED) {

                TextIdx = COLOR_GRAYTEXT;

            } else {

                TextIdx = (INT)dw;
            }
        }

        //
        // Fill the background frist
        //

        hbr = CreateSolidBrush(GetSysColor(FillIdx));

        if (hbr) {
            FillRect(hDC, &rc, hbr);
            DeleteObject(hbr);
        }

        if (ItemData & LBCBID_FILL) {

            break;
        }

        //
        // Draw the text using transparent mode
        //

        OldClr    = SetTextColor(hDC, GetSysColor(TextIdx));
        OldBkMode = SetBkMode(hDC, TRANSPARENT);
        
        if (pszItem) {

        TextOut(hDC,
                rc.left + TextOff.x,
                TextOff.y,
                pszItem,
                lstrlen(pszItem));
        }

        SetTextColor(hDC, OldClr);
        SetBkMode(hDC, OldBkMode);

        //
        // Setting any icon if available
        //

        if (OTFlags & OTINTF_ITEM_HAS_ICON16) {

            LPWORD      *pIcon16Idx;
            POPTPARAM   pOptParam;
            HINSTANCE   hInst;


            pOptParam = (ItemData & LBCBID_NONE) ? &pTVWnd->OptParamNone :
                                                   pOptType->pOptParam +
                                                            LOWORD(ItemData);
            hInst = _OI_HINST(pItem);

#if DO_IN_PLACE
            if (dw = GetIcon16Idx(pTVWnd,
                                  hInst,
                                  GET_ICONID(pOptParam,
                                             OPTPF_ICONID_AS_HICON),
                                  IDI_CPSUI_GENERIC_ITEM)) {

                ImageList_Draw(pTVWnd->himi,
                               dw,
                               hDC,
                               rc.left + LBCB_ICON_X_OFF,
                               rc.top,
                               ILD_TRANSPARENT);
            }
#else
            ImageList_Draw(pTVWnd->himi,
                           GetIcon16Idx(pTVWnd,
                                        hInst,
                                        GET_ICONID(pOptParam,
                                                   OPTPF_ICONID_AS_HICON),
                                        IDI_CPSUI_GENERIC_ITEM),
                           hDC,
                           rc.left + LBCB_ICON_X_OFF,
                           rc.top,
                           ILD_TRANSPARENT);
#endif

            //
            // Draw The No/Stop/Warning icon on to it
            //

            if (pOptParam->Flags & OPTPF_OVERLAY_STOP_ICON) {

                ImageList_Draw(pTVWnd->himi,
                               GetIcon16Idx(pTVWnd,
                                            hInst,
                                            0,
                                            IDI_CPSUI_STOP),
                               hDC,
                               rc.left + LBCB_ICON_X_OFF,
                               rc.top,
                               ILD_TRANSPARENT);
            }

            if (pOptParam->Flags & OPTPF_OVERLAY_NO_ICON) {

                ImageList_Draw(pTVWnd->himi,
                               GetIcon16Idx(pTVWnd,
                                            hInst,
                                            0,
                                            IDI_CPSUI_NO),
                               hDC,
                               rc.left + LBCB_ICON_X_OFF,
                               rc.top,
                               ILD_TRANSPARENT);
            }

            if (pOptParam->Flags & OPTPF_OVERLAY_WARNING_ICON) {

                ImageList_Draw(pTVWnd->himi,
                               GetIcon16Idx(pTVWnd,
                                            hInst,
                                            0,
                                            IDI_CPSUI_WARNING_OVERLAY),
                               hDC,
                               rc.left + LBCB_ICON_X_OFF,
                               rc.top,
                               ILD_TRANSPARENT);
            }
        }

        if ((ItemState & (ODS_COMBOBOXEDIT | ODS_SELECTED | ODS_FOCUS))
                            == (ODS_COMBOBOXEDIT | ODS_SELECTED | ODS_FOCUS)) {

            DrawFocusRect(hDC, &pdis->rcItem);
        }

        break;

    case ODA_FOCUS:

        if (!IsLB) {

            DrawFocusRect(hDC, &pdis->rcItem);
            break;
        }

        return(FALSE);
    }

    LocalFree(pszItem);
    return(TRUE);
}



BOOL
ValidateUDArrow(
    HWND    hDlg,
    HWND    hEdit,
    BYTE    CtrlData,
    LONG    *pSel,
    LONG    Min,
    LONG    Max
    )

/*++

Routine Description:

    This function validate current updown arrow edit box selection (numerical)
    and reset the text if invalid, it also has handy cursor selection scheme.


Arguments:

    hDlg        - Handle to the property sheet dialog box

    hEdit       - Handle to the edit control (the NEXTCTRL should be UPDOWN
                  ARROW)

    CtrlData    - CtrlData for the Edit Control, it has EDF_xxxx flags

    pSel        - Pointer to a LONG for the previous selected number

    Min         - Min number for this edit control

    Max         - max number for this edit control



Return Value:

    BOOL    - TRUE if selection number changed, FALSE otherwise


Author:

    19-Sep-1995 Tue 12:35:33 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWSTR  pSelBuf;
    LONG    OldSel;
    LONG    Sel;
    LONG    SelBegIdx;
    LONG    SelEndIdx;
    BOOL    ResetText;
    BOOL    bSign;
    BOOL    bDifSel;
    UINT    Len;
    UINT    cDigit;
    WCHAR   SelBuf[MAX_UDARROW_TEXT_LEN+1];
    WCHAR   ch;


    SelBuf[0] = 0;
    cDigit    = 0;
    bSign     = FALSE;
    Sel       = 0;
    SelBegIdx =
    SelEndIdx = 9999;
    pSelBuf   = SelBuf;
    OldSel    = *pSel;

    if (!(Len = (UINT)GetWindowText(hEdit, pSelBuf, ARRAYSIZE(SelBuf)))) {

        SelBegIdx = 0;
        ResetText = TRUE;

    } else {

        ResetText = FALSE;
    }

    CPSUIDBG(DBG_VALIDATE_UD, ("---------- Validate UDArrow -----------"));
    CPSUIDBG(DBG_VALIDATE_UD, ("UDArrow: CUR Text='%ws' (%ld), OldSel=%ld",
                                                        SelBuf, Len, OldSel));

    while (ch = *pSelBuf++) {

        switch (ch) {

        case L'-':

            if ((bSign)     ||
                (cDigit)    ||
                ((Min >= 0) && (Max >= 0))) {

                ResetText = TRUE;

            } else {

                bSign = TRUE;
            }

            break;

        default:

            if ((ch >= L'0') && (ch <= L'9')) {

                cDigit++;

                Sel = (Sel * 10) + (LONG)(ch - L'0');

            } else {

                ResetText = TRUE;
            }

            break;
        }
    }

    if (bSign) {

        //
        // If we got '-' or '-0' then make it to Min, and not selecting the
        // minus sign
        //

        if (!(Sel = -Sel)) {

            Sel       = Min;
            SelBegIdx = 1;
            ResetText = TRUE;
        }

    } else if (!Sel) {

        SelBegIdx = 0;
    }

    StringCchPrintfW(SelBuf, COUNT_ARRAY(SelBuf), L"%ld", Sel);
    cDigit = lstrlenW(SelBuf);

    if (Sel < Min) {

        ResetText = TRUE;

        if (Sel) {

            SelBegIdx = cDigit;

            if ((SelBegIdx)                 &&
                (CtrlData & EDF_BACKSPACE)  &&
                ((CtrlData & EDF_BEGIDXMASK) <= SelBegIdx)) {

                SelBegIdx--;
            }

            while (Sel < Min) {

                Sel *= 10;
            }

            if (Sel > Max) {

                Sel = 0;
            }
        }

        if (!Sel) {

            Sel       = Min;
            SelBegIdx = 0;
        }

    } else if (Sel > Max) {

        ResetText = TRUE;
        Sel       = Max;
        SelBegIdx = 0;
    }

    *pSel = Sel;

    StringCchPrintfW(SelBuf, COUNT_ARRAY(SelBuf), L"%ld", Sel);
    cDigit = lstrlenW(SelBuf);

    if (cDigit != Len) {

        ResetText = TRUE;

        if (SelBegIdx == 9999) {

            SelBegIdx =
            SelEndIdx = (LONG)(CtrlData & EDF_BEGIDXMASK);
        }
    }

    if (ResetText) {

        CPSUIDBG(DBG_VALIDATE_UD,
                ("UDArrow: NEW Text='%ws' (%ld)", SelBuf, cDigit));

        SendMessage(hEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)SelBuf);

        // SetDlgItemInt(hDlg, GetDlgCtrlID(hEdit), Sel, TRUE);
    }

    if (SelBegIdx != 9999) {

        CPSUIDBG(DBG_VALIDATE_UD, ("UDArrow: NEW SelIdx=(%ld, %ld)",
                        SelBegIdx, SelEndIdx));

        SendMessage(hEdit, EM_SETSEL, SelBegIdx, SelEndIdx);
    }

    CPSUIDBG(DBG_VALIDATE_UD, ("UDArrow: Sel=%ld -> %ld, Change=%hs\n",
                OldSel, Sel, (OldSel == Sel) ? "FALSE" : "TRUE"));

    return(OldSel != Sel);
}




HWND
FindItemFirstFocus(
    HWND        hDlg,
    PTVWND      pTVWnd,
    POPTITEM    pItem
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    05-Mar-1998 Thu 14:39:17 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hFocus;
    POPTITEM    pItemBeg;
    POPTITEM    pItemEnd;
    BYTE        PageIdx;
    BOOL        HasFocus = FALSE;


    PageIdx  = (BYTE)(GET_PMYDLGPAGE(hDlg))->PageIdx;
    pItemBeg = pItem;
    pItemEnd = pTVWnd->pLastItem + 1;

    while ((pItem) && (!HasFocus)) {

        if (pItem->DlgPageIdx == PageIdx) {

            POPTTYPE    pOptType;
            UINT        CtrlID;
            UINT        cCtrls;

            if (pOptType = pItem->pOptType) {

                CtrlID = (UINT)pOptType->BegCtrlID;
                cCtrls = (UINT)cTVOTCtrls[pOptType->Type];

                CPSUIOPTITEM(DBG_FOCUS, pTVWnd, "Find Focus", 1, pItem);

                while ((!HasFocus) && (cCtrls--)) {

                    if ((hFocus = GetDlgItem(hDlg, CtrlID++))    &&
                        ((GetWindowLongPtr(hFocus, GWL_STYLE) &
                                (WS_VISIBLE | WS_DISABLED | WS_TABSTOP)) ==
                                                (WS_VISIBLE | WS_TABSTOP))) {

                        SetFocus(hFocus);

                        if (GetFocus() == hFocus) {

                            CPSUIDBG(DBG_FOCUS,
                                     ("pItem=%08lx (Page=%ld) has Focus=%08lx (%ld), Style=%08lx",
                                        pItem, PageIdx, hFocus,
                                            GetWindowLongPtr(hFocus, GWLP_ID),
                                            GetWindowLongPtr(hFocus, GWL_STYLE)));

                            HasFocus = TRUE;
                        }
                    }
                }

            }
        }

        if (++pItem >= pItemEnd) {

            if (pItemEnd == pItemBeg) {

                pItem = NULL;

            } else {

                pItem    = pTVWnd->ComPropSheetUI.pOptItem;
                pItemEnd = pItemBeg;
            }
        }
    }

    if ((HasFocus) && (hFocus)) {

        return(hFocus);

    } else {

        return(NULL);
    }
}





POPTITEM
DlgHScrollCommand(
    HWND    hDlg,
    PTVWND  pTVWnd,
    HWND    hCtrl,
    WPARAM  wParam
    )

/*++

Routine Description:

    This is a general function to process all WM_COMMAND and WM_HSCROLL
    for the common UI


Arguments:

    hDlg    - Handle to the dialog box

    pTVWnd  - Our instance data

    hCtrl   - The handle to the control

    wParam  - message/data insterested



Return Value:

    POPTITEM    NULL if nothing changed


Author:

    01-Sep-1995 Fri 02:25:18 updated  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HWND        hFocus;
    POPTTYPE    pOptType;
    POPTPARAM   pOptParam;
    POPTITEM    pItem;
    LPTSTR      pSel;
    DWORD       dw;
    BOOL        HasSel = FALSE;
    BYTE        CtrlStyle;
    BYTE        CtrlData;
    BYTE        Type;
    WORD        ItemIdx;
    LONG        NewSel;
    INT_PTR     SelIdx;
    INT         Count;
    UINT        Len;
    WORD        LoW;
    WORD        HiW;
    INT         SelAdd;
    INT         CurSel;
    UINT        IDGetItemData;
    BOOL        IsLB;
    DWORD       BegSel;
    DWORD       EndSel;


    HiW = HIWORD(wParam);
    LoW = LOWORD(wParam);

    if (pItem = pTVWnd->pMouseItem) {

        pTVWnd->pMouseItem = NULL;

        switch (LoW) {

        case ID_CMD_HELP:

            CPSUIINT(("=== GET MENU message = HELP, hFocus=%08lx, hWndTV=%08lx ====",
                    (hDlg == pTVWnd->hDlgTV) ? pTVWnd->hWndTV : GetFocus(),
                        pTVWnd->hWndTV));

            CommonPropSheetUIHelp(hDlg,
                                  pTVWnd,
                                  (hDlg == pTVWnd->hDlgTV) ?
                                        pTVWnd->hWndTV : GetFocus(),
                                  (DWORD)pTVWnd->MousePos,
                                  pItem,
                                  HELP_WM_HELP);

            pTVWnd->MousePos = 0;

            return(NULL);

        case ID_CMD_UNDO:

            hFocus = GetFocus();

            //
            // Revert
            //

            DoCallBack(hDlg,
                       pTVWnd,
                       pItem,
                       pItem->pSel,
                       (_CPSUICALLBACK)InternalRevertOptItem,
                       NULL,
                       0,
                       CPSUICB_REASON_ITEMS_REVERTED);

            if ((hFocus) && (!GetFocus())) {

                dw = (DWORD)GetWindowLongPtr(hFocus, GWL_STYLE);

                CPSUIDBG(DBG_FOCUS,
                         ("\n!!! Original hFocus=%08lx (%ld), Style=%08lx",
                            hFocus, GetWindowLongPtr(hFocus, GWLP_ID), dw));

                //
                // We has a focus, and lost the keyboard focus now
                //

                if ((dw & (WS_VISIBLE | WS_DISABLED)) == WS_VISIBLE) {

                    //
                    // If this window still enable/visble then set to it
                    //

                    CPSUIDBG(DBG_FOCUS,
                             ("  Focus=%08lx (%ld) still ok, set to it",
                                hFocus, GetWindowLongPtr(hFocus, GWLP_ID)));

                    SetFocus(hFocus);

                } else if (hDlg != pTVWnd->hDlgTV) {

                    if (!(hFocus = FindItemFirstFocus(hDlg, pTVWnd, pItem))) {

                        CPSUIDBG(DBG_FOCUS,
                                ("=== Cannot find any more focus goto WM_NEXTDLGCTL ==="));

                        SendMessage(hDlg, WM_NEXTDLGCTL, 1, (LPARAM)FALSE);
                    }
                }
            }

            pTVWnd->MousePos = 0;

            return(pItem);

        case ID_CMD_ABOUT:

            CPSUIINT(("=== GET MENU message = ABOUT ======"));

            if (pItem = PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT)) {

                DoAbout(hDlg, pTVWnd, pItem);
            }

            pTVWnd->MousePos = 0;

            return(NULL);

        default:

            break;
        }
    }


    if (!(dw = (DWORD)GetWindowLongPtr(hCtrl, GWLP_USERDATA))) {

        CPSUIDBG(DBG_CS,
                ("DoDlgCmd: dw=0, wParam=%08lx, lParam=%08lx", wParam, hCtrl));

        return(NULL);
    }

    GETCTRLDATA(dw, ItemIdx, CtrlStyle, CtrlData);

    CPSUIDBG(DBG_CS, ("ID=%ld, LoW=%ld, HiW=%ld, Idx=%ld, Style=0x%02lx, Data=%ld",
            (DWORD)GetDlgCtrlID(hCtrl), (LONG)((SHORT)LoW),
            (LONG)((SHORT)HiW), (DWORD)ItemIdx, (DWORD)CtrlStyle, (DWORD)CtrlData));

    //
    // Validate what we got
    //

    if ((!(pItem = GetOptions(pTVWnd, MAKELPARAM(ItemIdx, 0)))) ||
        (!(pOptType = GET_POPTTYPE(pItem)))                     ||
        ((Type = pOptType->Type) > TVOT_LAST)                   ||
        (pItem->Flags & (OPTIF_DISABLED | OPTIF_ITEM_HIDE))) {

        CPSUIINT(("COMMAND: Invalid hCtrl or disable/hide Idx=%ld", ItemIdx));
        CPSUIINT(("ID=%ld, LoW=%ld, HiW=%ld, CtrlStyle=0x%02lx, CtrlData=%ld",
            (DWORD)GetDlgCtrlID(hCtrl), (LONG)((SHORT)LoW),
            (LONG)((SHORT)HiW), (DWORD)CtrlStyle, (DWORD)CtrlData));

        return(NULL);
    }

    if (!(pTVWnd->Flags & TWF_CAN_UPDATE)) {

        if ((pItem == PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT))   ||
            ((CtrlStyle == CTRLS_PUSHBUTTON) &&
             (pOptType->Flags & OTS_PUSH_ENABLE_ALWAYS))) {

            NULL;

        } else {

            CPSUIINT(("ID=%ld, CtrlStyle=0x%02lx, ENABLE_EVEN_NO_UPDATE=0",
                    (DWORD)GetDlgCtrlID(hCtrl), (DWORD)CtrlStyle));
            return(NULL);
        }
    }

    pOptParam     = pOptType->pOptParam;
    pSel          = pItem->pSel;
    Type          = pOptType->Type;
    IsLB          = TRUE;
    IDGetItemData = LB_GETITEMDATA;

    switch (CtrlStyle) {

    case CTRLS_PROPPAGE_ICON:

        switch (HiW) {

        case STN_CLICKED:
        case STN_DBLCLK:

            CPSUIASSERT(0, "CTRLS_PROPAGE_ICON but TVOT=%ld",
                        (Type == TVOT_2STATES) ||
                        (Type == TVOT_3STATES) ||
                        (Type == TVOT_CHKBOX), Type);

            SetFocus(GetDlgItem(hDlg, LoW - 1));

            if (Type == TVOT_CHKBOX) {

                CtrlStyle = CTRLS_CHKBOX;
                NewSel    = (pItem->Sel) ? 0 : 1;

                CheckDlgButton(hDlg,
                               LoW - 1,
                               (NewSel) ? BST_CHECKED : BST_UNCHECKED);
            } else {

                BegSel    = (DWORD)(pOptType->BegCtrlID + 2);
                EndSel    = BegSel + (DWORD)(((Type - TVOT_2STATES) + 1) << 1);
                CtrlStyle = CTRLS_RADIO;
                NewSel    = (LONG)CtrlData;

                CheckRadioButton(hDlg, BegSel, EndSel, LoW - 1);
            }

            HasSel = TRUE;
        }

        break;

    case CTRLS_ECBICON:

        switch (HiW) {

        case STN_CLICKED:
        case STN_DBLCLK:

            CPSUIASSERT(0, "CTRLS_ECBICON but NO pExtChkBox",
                                                pItem->pExtChkBox, 0);

            //
            // Flip the selection
            //

            NewSel = (pItem->Flags & OPTIF_ECB_CHECKED) ? 0 : 1;

            SetFocus(GetDlgItem(hDlg, LoW - 1));
            CheckDlgButton(hDlg,
                           LoW - 1,
                           (NewSel) ? BST_CHECKED : BST_UNCHECKED);

            CtrlStyle = CTRLS_EXTCHKBOX;
            HasSel    = TRUE;
        }

        break;

    case CTRLS_RADIO:

        CPSUIASSERT(0, "CTRLS_RADIO but TVOT=%ld",
                   (Type == TVOT_2STATES) || (Type == TVOT_3STATES), Type);

        if (HiW == BN_CLICKED) {

            HasSel = TRUE;
            NewSel = CtrlData;
        }

        break;

    case CTRLS_UDARROW_EDIT:
#if (DO_IN_PLACE == 0)
        CPSUIASSERT(0, "CTRLS_UDARROW_EDIT but TVOT=%ld",
                                    (Type == TVOT_UDARROW), Type);
#endif
        CPSUIDBG(DBG_UDARROW, ("UDArrow, hEdit=%08lx (%ld), hUDArrow=%08lx (%ld), CtrlData=0x%02lx",
                hCtrl, GetDlgCtrlID(hCtrl), GetWindow(hCtrl, GW_HWNDNEXT),
                GetDlgCtrlID(GetWindow(hCtrl, GW_HWNDNEXT)), CtrlData));

        switch (HiW) {

        case EN_UPDATE:

            if (_OI_INTFLAGS(pItem) & OIDF_IN_EN_UPDATE) {

                return(NULL);

            } else {

                _OI_INTFLAGS(pItem) |= OIDF_IN_EN_UPDATE;

                NewSel = pItem->Sel;

                if (HasSel = ValidateUDArrow(hDlg,
                                             hCtrl,
                                             CtrlData,
                                             &(pItem->Sel),
                                             (LONG)pOptParam[1].IconID,
                                             (LONG)pOptParam[1].lParam)) {

                    CPSUIINT(("UDARROW: EN_UPDATE: OldSel=%ld, NewSel=%ld",
                                NewSel, pItem->Sel));

                    NewSel     = pItem->Sel;
                    pItem->Sel = ~(DWORD)NewSel;
                }

                _OI_INTFLAGS(pItem) &= ~OIDF_IN_EN_UPDATE;
            }

            break;

        case EN_SETFOCUS:

            PostMessage(hCtrl, EM_SETSEL, 0, -1L);

            break;
        }

        break;

    case CTRLS_TRACKBAR:

        CPSUIASSERT(0, "CTRLS_TRACKBAR but TVOT=%ld",
                                    (Type == TVOT_TRACKBAR), Type);

        switch (LoW) {

        case TB_TOP:
        case TB_BOTTOM:
        case TB_ENDTRACK:
        case TB_LINEDOWN:
        case TB_LINEUP:
        case TB_PAGEDOWN:
        case TB_PAGEUP:

            NewSel = (DWORD)SendMessage(hCtrl, TBM_GETPOS, 0, 0L);
            break;

        case TB_THUMBPOSITION:
        case TB_THUMBTRACK:

            NewSel = (LONG)((SHORT)HiW);
            break;

        default:

            return(NULL);
        }

        HasSel = TRUE;

        break;

    case CTRLS_HSCROLL:

        CPSUIASSERT(0, "CTRLS_HSCROLL but TVOT=%ld",
                                    (Type == TVOT_SCROLLBAR), Type);

        NewSel = (LONG)LODWORD(pSel);

        switch (LoW) {

        case SB_PAGEUP:

            NewSel -= (LONG)(SHORT)pOptParam[2].lParam;
            break;

        case SB_PAGEDOWN:

            NewSel += (LONG)(SHORT)pOptParam[2].lParam;
            break;

        case SB_LINEUP:

            --NewSel;
            break;

        case SB_LINEDOWN:

            ++NewSel;
            break;

        case SB_TOP:

            NewSel = (LONG)pOptParam[1].IconID;
            break;

        case SB_BOTTOM:

            NewSel = (LONG)pOptParam[1].lParam;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:

            NewSel = (LONG)((SHORT)HiW);
            break;

        default:

            return(NULL);
        }

        if (NewSel < (LONG)pOptParam[1].IconID) {

            NewSel = (LONG)pOptParam[1].IconID;

        } else if (NewSel > (LONG)pOptParam[1].lParam) {

            NewSel = (LONG)pOptParam[1].lParam;
        }

        SendMessage(hCtrl, SBM_SETPOS, (WPARAM)NewSel, (LPARAM)TRUE);
        HasSel = TRUE;

        break;

    case CTRLS_COMBOBOX:

        IsLB = FALSE;

        if (HiW == CBN_SELCHANGE) {

            //
            // make CBN_SELCHANGE to LBN_SELCHANGE
            //

            IDGetItemData = CB_GETITEMDATA;
            HiW           = LBN_SELCHANGE;

        } else {

            switch (HiW) {

            case CBN_CLOSEUP:

                //
                // When close up the drop down box, we post another selection
                // message if selection really changed, and then process the
                // CBN_SELCHANGE because the drop down box is closed
                //

                CurSel = (INT)SendMessage(hCtrl, CB_GETCURSEL, 0, 0);
                SelIdx = (INT_PTR)GetProp(hCtrl, CPSUIPROP_CBPRESEL) - 1;

                if (CurSel != SelIdx) {

                    PostMessage(hDlg,
                                WM_COMMAND,
                                MAKEWPARAM(GetDlgCtrlID(hCtrl), CBN_SELCHANGE),
                                (LPARAM)hCtrl);
                }

                break;

            case CBN_DROPDOWN:

                //
                // When combo box is selected, remember what selection we
                // start with
                //

                SelIdx = (INT)SendMessage(hCtrl, CB_GETCURSEL, 0, 0);
                SetProp(hCtrl, CPSUIPROP_CBPRESEL, (HANDLE)(SelIdx + 1));

                CPSUIDBG(DBG_CBWNDPROC, ("CBN_DROPDOWN: SelIdx=%ld", SelIdx));

                break;
            }

            break;
        }

        //
        // Fall through
        //

    case CTRLS_LISTBOX:
#if (DO_IN_PLACE == 0)
        CPSUIASSERT(0, "CTRLS_LISTBOX/CTRLS_COMBOBOX but TVOT=%ld",
                   (Type == TVOT_COMBOBOX) ||
                   (Type == TVOT_LISTBOX)  || (Type == CtrlData), Type);
#endif
        switch (HiW) {

        case LBN_SELCHANGE:

            SelIdx = (INT)SendMessage(hCtrl,
                                      (IsLB) ? LB_GETCURSEL : CB_GETCURSEL,
                                      0,
                                      0);
            dw     = (DWORD)SendMessage(hCtrl, IDGetItemData, SelIdx, 0L);

            if (dw & LBCBID_DISABLED) {

                SelIdx = (INT)FindNextLBCBSel(hCtrl,
                                              (LONG)_OI_LBCBSELIDX(pItem),
                                              (LONG)SelIdx,
                                              IDGetItemData,
                                              &dw);

                PostMessage(hCtrl,
                            (IsLB) ? LB_SETCURSEL : CB_SETCURSEL,
                            (WPARAM)SelIdx,
                            0L);
            }

            if (dw & (LBCBID_NONE | LBCBID_FILL)) {

                NewSel = -1;

            } else if (dw & LBCBID_DISABLED) {

                CPSUIERR(("LBCB: Could not find not disable item"));

            } else {

                NewSel = (LONG)LOWORD(dw);
            }

            _OI_LBCBSELIDX(pItem) = (WORD)SelIdx;

            if (!(HasSel = IsLB)) {

                //
                // If it is a CBN_SELCHANGE then we only really do SELCHAGE
                // when the drop down box is closed, noticed, in compstui when
                // a combobox is selected we always open the drop down box
                //

                if (!SendMessage(hCtrl, CB_GETDROPPEDSTATE, 0, 0)) {

                    HasSel = TRUE;

                    CPSUIDBG(DBG_CBWNDPROC, ("CBN_SELCHANGE: The DropDown Closed, SelIdx=%ld",
                                                SelIdx));
                }
            }

            CPSUIDBG(DBG_CS, ("LBCB Select Changed: SelIdx=%ld, NewSel=%ld",
                                                        SelIdx, NewSel));
            break;

        default:

            return(NULL);
        }

        break;

    case CTRLS_EDITBOX:

        CPSUIASSERT(0, "CTRLS_EDITBOX but TVOT=%ld",
                                    (Type == TVOT_EDITBOX), Type);

        switch (HiW) {

        case EN_CHANGE:

            Len = (UINT)pOptParam[1].IconID;

            if (pTVWnd->Flags & TWF_ANSI_CALL) {

                GetWindowTextA(hCtrl, (LPSTR)pSel, Len);

            } else {

                GetWindowText(hCtrl, (LPTSTR)pSel, Len);
            }

            HasSel      = TRUE;
            NewSel      = 0;

            break;

        case EN_SETFOCUS:

            PostMessage(hCtrl, EM_SETSEL, 0, -1L);
            break;
        }

        break;

    case CTRLS_EXTPUSH:

        CPSUIASSERT(0, "CTRLS_EXTPUSH but is not OPTIF_EXT_IS_EXTPUSH = %ld",
                    pItem->Flags & OPTIF_EXT_IS_EXTPUSH, ULongToPtr(pItem->Flags));

        if (HiW == BN_CLICKED) {

            PEXTPUSH    pEP = pItem->pExtPush;

            if (pItem == PIDX_INTOPTITEM(pTVWnd, INTIDX_TVROOT)) {

                DoAbout(hDlg, pTVWnd, pItem);

            } else {

                HANDLE  hDlgTemplate = NULL;
                WORD    DlgTemplateID = 0;

                if (pEP->Flags & EPF_PUSH_TYPE_DLGPROC) {

                    if (pEP->Flags & EPF_USE_HDLGTEMPLATE) {

                        hDlgTemplate = pEP->hDlgTemplate;

                    } else {

                        DlgTemplateID = pEP->DlgTemplateID;
                    }
                }

                DoCallBack(hDlg,
                           pTVWnd,
                           pItem,
                           pItem->pSel,
                           (_CPSUICALLBACK)pEP->pfnCallBack,
                           hDlgTemplate,
                           DlgTemplateID,
                           CPSUICB_REASON_EXTPUSH);
            }
        }

        break;

    case CTRLS_PUSHBUTTON:

        CPSUIASSERT(0, "CTRLS_PUSHBUTTON but TVOT=%ld",
                                    (Type == TVOT_PUSHBUTTON), Type);

        if (HiW == BN_CLICKED) {

            NewSel = DoPushButton(hDlg, pTVWnd, pItem);

            if ((pOptParam[0].Style != PUSHBUTTON_TYPE_CALLBACK) &&
                (pTVWnd->Flags & TWF_CAN_UPDATE)) {

                HasSel     = TRUE;
                pItem->Sel = (DWORD)~(DWORD)NewSel;
            }
        }

        break;

    case CTRLS_CHKBOX:
    case CTRLS_EXTCHKBOX:

        if (CtrlStyle == CTRLS_CHKBOX) {

            CPSUIASSERT(0, "CTRLS_CHKBOX but TVOT=%ld",
                                        (Type == TVOT_CHKBOX), Type);

        } else {

            CPSUIASSERT(0, "CTRLS_EXTCHKBOX but pExtChkBox=%ld",
                            (pItem->pExtChkBox != NULL), pItem->pExtChkBox);
        }

        if (HiW == BN_CLICKED) {

            HasSel = TRUE;
            NewSel = (LONG)SendMessage(hCtrl, BM_GETCHECK, 0, 0L);
        }

        break;

    case CTRLS_UDARROW:
    case CTRLS_TV_WND:
    case CTRLS_TV_STATIC:
    case CTRLS_PROPPAGE_STATIC:
    case CTRLS_NOINPUT:

        CPSUIINT(("Static CTRLS_xxx = %ld", CtrlStyle));

        return(NULL);

    default:

        CPSUIERR(("\nInternal ERROR: Invalid CTRLS_xxx=%02lx\n", CtrlStyle));
        return(NULL);
    }

    if (HasSel) {

        if (CtrlStyle == CTRLS_EXTCHKBOX) {

            HasSel = (BOOL)((DWORD)(pItem->Flags & OPTIF_ECB_CHECKED) !=
                            (DWORD)((NewSel) ? OPTIF_ECB_CHECKED : 0));

        } else {

            HasSel = (BOOL)(pItem->Sel != NewSel);
        }

        if (HasSel) {

            PMYDLGPAGE  pCurMyDP;
            PMYDLGPAGE  pMyDP;
            BYTE        CurPageIdx;
            BYTE        DlgPageIdx;
            BYTE        TVPageIdx;
            WORD        Reason;


            pCurMyDP   = GET_PMYDLGPAGE(hDlg);
            pMyDP      = pTVWnd->pMyDlgPage;
            CurPageIdx = pCurMyDP->PageIdx;
            DlgPageIdx = pItem->DlgPageIdx;
            TVPageIdx  = pTVWnd->TVPageIdx;

            CPSUIDBG(DBG_CS, ("Item Changed: CurPage=%ld, DlgPage=%ld, TVPageIdx=%ld",
                    (DWORD)CurPageIdx, (DWORD)DlgPageIdx, (DWORD)TVPageIdx));

            //
            // firstable mark current page to changed once.
            //

            pCurMyDP->Flags |= MYDPF_CHANGEONCE;

            //
            // If we are in the treeview page, then set the dirty flag if it
            // belong to the other page
            //

            if (CurPageIdx == TVPageIdx) {

                if (DlgPageIdx != CurPageIdx) {

                    pMyDP[DlgPageIdx].Flags |= (MYDPF_CHANGED |
                                                MYDPF_CHANGEONCE);
                    pItem->Flags            |=  OPTIF_INT_CHANGED;
                }

            } else if (TVPageIdx != PAGEIDX_NONE) {

                //
                // Not in treeview page, so set the dirty bit for treeview
                //

                pMyDP[TVPageIdx].Flags |= (MYDPF_CHANGED | MYDPF_CHANGEONCE);
                pItem->Flags           |= OPTIF_INT_TV_CHANGED;
            }

            if (CtrlStyle == CTRLS_EXTCHKBOX) {

                Reason        = CPSUICB_REASON_ECB_CHANGED;
                pItem->Flags ^= OPTIF_ECB_CHECKED;

            } else {
                
                Reason        = CPSUICB_REASON_SEL_CHANGED;
                if (CtrlStyle != CTRLS_EDITBOX) {

                    //
                    // In the case of CTRLS_EDITBOX, pItem->pSel is already the new value
                    //
                    pItem->Sel    = NewSel;
                }                
            }

            pItem->Flags |= OPTIF_CHANGEONCE;

            //
            // Doing the internal DMPub first,
            //

            if (Len = UpdateInternalDMPUB(hDlg, pTVWnd, pItem)) {

                UpdateCallBackChanges(hDlg, pTVWnd, Len & INTDMPUB_REINIT);
            }

            if ((pItem->Flags & OPTIF_CALLBACK)             &&
                (ItemIdx < pTVWnd->ComPropSheetUI.cOptItem)) {

                DoCallBack(hDlg, pTVWnd, pItem, pSel, NULL, NULL, 0, Reason);
            }

            CPSUIOPTITEM(DBGITEM_CS, pTVWnd, "!! ChangeSelection !!", 1, pItem);

            IsItemChangeOnce(pTVWnd, pItem);

            SET_APPLY_BUTTON(pTVWnd, hDlg);

            return(pItem);
        }
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\help.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    help.c


Abstract:

    This module contains function when user hit help button or F1


Author:

    28-Aug-1995 Mon 14:55:07 created  -by-  Daniel Chou (danielc)


[Environment:]

    NT Windows - Common Printer Driver UI DLL.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop



#define DBG_CPSUIFILENAME   DbgHelp


#define DBG_HELP_MSGBOX     0x00000001


DEFINE_DBGVAR(0);


extern  HINSTANCE   hInstDLL;

WCHAR   CPSUIHelpFile[] = L"compstui.hlp";

#define MAX_HELPFILE_SIZE       300
#define TMP_HELP_WND_ID         0x7fff


#if DBG


INT
HelpMsgBox(
    HWND        hDlg,
    PTVWND      pTVWnd,
    LPTSTR      pHelpFile,
    POPTITEM    pItem,
    UINT        HelpIdx
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    26-Sep-1995 Tue 13:20:25 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    UINT    Count;
    UINT    Style;
    GSBUF_DEF(pItem, 360);


    if (DbgHelp & DBG_HELP_MSGBOX) {

        if (pHelpFile) {

            Style = MB_ICONINFORMATION | MB_OKCANCEL;
            GSBUF_GETSTR(L"HelpFile=");
            GSBUF_GETSTR(pHelpFile);
            GSBUF_GETSTR(L"\nOption=");

        } else {

            GSBUF_GETSTR(L"HelpFile= -None-\nOption=");
            Style = MB_ICONSTOP | MB_OK;
        }

        if ((pItem) && (HelpIdx)) {

            GSBUF_GETSTR(pItem->pName);
            GSBUF_GETSTR(L"HelpIdx=");
            GSBUF_ADDNUM(HelpIdx, FALSE);

        } else {

            GSBUF_GETSTR(L"<NONE, General Help>");
        }

        return(MessageBox(hDlg,
                          GSBUF_BUF,
                          TEXT("DBG: Common Property Sheet UI"),
                          Style));

    } else {

        return(TRUE);
    }
}

#endif




BOOL
CommonPropSheetUIHelp(
    HWND        hDlg,
    PTVWND      pTVWnd,
    HWND        hWndHelp,
    DWORD       MousePos,
    POPTITEM    pItem,
    UINT        HelpCmd
    )

/*++

Routine Description:

    This function initialize/display/end the plotter help system


Arguments:

    hDlg        - Handle to the dialog box need help

    pTVWnd      - Our instance data

    hWndHelp    - the window cause the context help

    MousePos    - Mouse position where the right click happened
                  x=LOWORD(MousePos), y=HIWORD(MousePos)

    pItem       - Pointer to the OPTITEM for the context help

    HelpCmd     - Help type


Return Value:

    VOID


Author:

    28-Aug-1995 Mon 15:24:27 updated  -by-  Daniel Chou (danielc)w


Revision History:


--*/

{
    LPWSTR      pHelpFile = NULL;
    DWORD       HelpIdx;
    BOOL        Ok = FALSE;
    GSBUF_DEF(pItem, MAX_HELPFILE_SIZE);



    if (pItem) {

        if (HelpIdx = (DWORD)_OI_HELPIDX(pItem)) {

            if (!LoadString(hInstDLL,
                            IDS_INT_CPSUI_HELPFILE,
                            pHelpFile = GSBUF_BUF,
                            MAX_HELPFILE_SIZE)) {

                pHelpFile = CPSUIHelpFile;
            }

        } else if (GSBUF_GETSTR(_OI_PHELPFILE(pItem))) {

            pHelpFile = GSBUF_BUF;
            HelpIdx   = pItem->HelpIndex;
        }
    }

    if ((!pHelpFile) &&
        (GSBUF_GETSTR(pTVWnd->ComPropSheetUI.pHelpFile))) {

        pHelpFile = GSBUF_BUF;
        HelpIdx   = 0;
    }

    /*
     *   Quite easy - simply call the WinHelp function with the parameters
     * supplied to us.  If this fails,  then put up a stock dialog box.
     *   BUT the first time we figure out what the file name is.  We know
     * the actual name,  but we don't know where it is located, so we
     * need to call the spooler for that information.
     */

    if (pHelpFile) {

        HWND        hWndTmp;
        POINT       pt;
        DWORD       HelpID[4];
        ULONG_PTR   Data;


        CPSUIDBGBLK(
        {
            if (HelpMsgBox(hDlg,
                           pTVWnd,
                           pHelpFile,
                           pItem,
                           HelpIdx) == IDCANCEL) {

                return(TRUE);
            }
        })

        //
        // Try to pop-up help on the right click position, where we will create
        // a temp button window and do the help, this way we can do context
        // sensitive help on any type of window (static, icon) and even it is
        // disabled.  We need to destroy this temp window before we exit from
        // this fucntion
        //

        pt.x = LOWORD(MousePos);
        pt.y = HIWORD(MousePos);

        ScreenToClient(hDlg, &pt);

        if (hWndTmp = CreateWindowEx(WS_EX_NOPARENTNOTIFY | WS_EX_CONTEXTHELP,
                                     L"button",
                                     L"",
                                     WS_CHILD | BS_CHECKBOX,
                                     pt.x,
                                     pt.y,
                                     1,
                                     1,
                                     hDlg,
                                     (HMENU)TMP_HELP_WND_ID,
                                     hInstDLL,
                                     0)) {

            hWndHelp = hWndTmp;

        } else {

            CPSUIERR(("CommonPropSheetUIHelp: Create temp. help window failed"));
        }

        HelpID[0] = (hWndHelp) ? (DWORD)GetWindowLongPtr(hWndHelp, GWLP_ID) : 0;
        HelpID[1] = HelpIdx;
        HelpID[2] =
        HelpID[3] = 0;

        switch (HelpCmd) {

        case HELP_WM_HELP:

            if ((!HelpID[0]) || (!HelpID[1])) {

                HelpCmd  = HELP_CONTENTS;
                hWndHelp = hDlg;
                Data     = 0;
                break;
            }

        case HELP_CONTEXTMENU:

            SetWindowContextHelpId(hWndHelp, HelpID[1]);
            Data = (ULONG_PTR)&HelpID[0];
            break;

        case HELP_CONTEXT:
        case HELP_CONTEXTPOPUP:

            Data = (ULONG_PTR)HelpID[1];
            break;

        default:

            Data = 0;
            break;
        }

        CPSUIINT(("Help: hWnd=%08lx, Cmd=%ld, ID=[%ld, %ld]",
                        hWndHelp, HelpCmd, HelpID[0], HelpID[1]));

        Ok = WinHelp(hWndHelp, pHelpFile, HelpCmd, Data);

        if (hWndTmp) {

            DestroyWindow(hWndTmp);
        }

    } else {

        CPSUIDBGBLK({ HelpMsgBox(hDlg, pTVWnd, NULL, pItem, HelpIdx); })
    }

    return(Ok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\compstui\help.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    help.h


Abstra