re to zero terminated
    cwchWinPath = GetSystemWindowsDirectoryW(awcWindowsDir, MAX_PATH);

    if ((cwchWinPath == 0) || (cwchWinPath > MAX_PATH))
        return FALSE;

// the cwchWinPath value does not include the terminating zero

    if (awcWindowsDir[cwchWinPath - 1] == L'\\')
    {
        cwchWinPath -= 1;
    }
    awcWindowsDir[cwchWinPath] = L'\0'; // make sure to zero terminated

    lstrcatW(awcWindowsDir, L"\\system32\\");
    lstrcatW(awcWindowsDir, WINNT_GUI_FILE_W);

    dwRet = GetPrivateProfileStringW(
                WINNT_DATA_W,
                WINNT_D_WIN31UPGRADE_W,
                WINNT_A_NO_W,
                Buffer,
                sizeof(Buffer)/sizeof(WCHAR),
                awcWindowsDir
                );

    #if DBGSWEEP
    DbgPrint("\n dwRet = %ld, win31upgrade = %ws\n\n", dwRet, Buffer);
    #endif

    return (BOOL)(dwRet ? (!lstrcmpiW(Buffer,WINNT_A_YES)) : 0);
}


/******************************Public*Routine******************************\
*
* VOID vNullTermWideString (WCHAR *pwcDest, WCHAR *pwcSrc, ULONG ulLength)
*
* Given pwcSrc, which is not necessarily null-terminated, copy ulLength characters
* the into pwcDest and place a null character after it.
*
* History:
*  03-Feb-99 -by- Donald Chinn [dchinn]
* Wrote it.
\**************************************************************************/
VOID vNullTermWideString (WCHAR *pwcDest, WCHAR *pwcSrc, ULONG ulLength)
{
    ULONG index;

    for (index = 0; index < ulLength; index++) {
        *pwcDest++ = *pwcSrc++;
    }
    *pwcDest = '\0';
}


/******************************Public*Routine******************************\
*
* BOOL bCheckFontEntry(WCHAR *pwcName, WCHAR *pwcExtension)
*
* This function assumes that both pwcName and pwcExtension are null-terminated.
*
* History:
*  25-Oct-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL bCheckFontEntry(WCHAR *pwcName, WCHAR *pwcExtension)
{
    BOOL bRet = FALSE;
    LONG cwc = (LONG)wcslen(pwcName) - (LONG)wcslen(pwcExtension);
    if (cwc > 0)
    {
        bRet = !_wcsicmp(&pwcName[cwc], pwcExtension);
    }
    return bRet;

}



/******************************Public*Routine******************************\
*   Process win.ini line
*
* History:
*  24-Oct-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define EXT_TRUETYPE  L"(TrueType)"
#define EXT_FOT       L".FOT"


VOID vProcessFontEntry(
    HKEY   hkey,
    WCHAR *pwcValueName,
    ULONG ulValueNameLength,
    WCHAR *pwcFileName,
    ULONG ulFileNameLength
)
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    BOOL  bFot = FALSE;
    WCHAR awcTTF[MAX_PATH];
    WCHAR awcTmpBuf[MAX_PATH];
    WCHAR *pwcTTF;
    FLONG fl, fl2;
    FLONG flEmbed;
    DWORD dwPidTid;
    WCHAR awcValueName[MAX_PATH];  // null-terminated pwcValueName
    WCHAR awcFileName[MAX_PATH];   // null-terminated pwcFileName
    

    // Make sure the ValueName is null-terminated
    ulValueNameLength = min(MAX_PATH - 1, ulValueNameLength);
    vNullTermWideString (awcValueName, pwcValueName, ulValueNameLength);
    
    // Make sure the FileName is null-terminated
    ulFileNameLength = min(MAX_PATH - 1, ulFileNameLength);
    vNullTermWideString (awcFileName, pwcFileName, ulFileNameLength);
    
    if (bCheckFontEntry(awcValueName, EXT_TRUETYPE))
    {
    // This is a tt entry, either .fot or .ttf

        if (bFot = bCheckFontEntry(awcFileName, EXT_FOT))
        {
        // this is an .fot entry, must find ttf pointed to by .fot,
        // but first must get the full path to the .fot file
        // for cGetTTFFromFOT routine expects it. We will also need
        // the full path to the .fot file so that we can delete it
        // eventually.

            if (bMakePathNameW(awcTmpBuf, awcFileName, NULL, &fl2))
            {
                if (cGetTTFFromFOT(awcTmpBuf, MAX_PATH, awcTTF, &fl, &flEmbed, &dwPidTid, TRUE) &&
                    !(fl & FONT_ISNOT_FOT))
                {
                // fix the entry to point to .ttf file. At this point
                // awcTTF points to the FULL path to the .ttf file.
                // However, we will only need a relative path to the
                // .ttf file, when the .ttf file is in the %windir%\system
                // or %windir%\fonts directories. In case the file is in the
                // %windir%\system directory we shall copy it to %windir%\fonts
                // directory and write the relative path to the registry.
                // In case it is in the %windir%\fonts directory we do not
                // touch the file and also just write the relative path to the
                // registry. In any other case we just write the full .ttf
                // path to the registry.

                // first delete the .fot file, it is no longer needed

                    if (bFot && !gbWin31Upgrade)
                    {
                        UserVerify(DeleteFileW(awcTmpBuf));
                    }

                    if ((fl & (FONT_IN_FONTS_DIR | FONT_IN_SYSTEM_DIR)) == 0)
                    {
                    // if ttf file is not in either the system or the fonts
                    // directories, just write the full path to the registry

                        pwcTTF = awcTTF;
                    }
                    else
                    {
                    // find the bare file part, this is what will be written
                    // in the registry

                        pwcTTF = &awcTTF[wcslen(awcTTF) - 1];
                        while ((pwcTTF >= awcTTF) && (*pwcTTF != L'\\') && (*pwcTTF != L':'))
                            pwcTTF--;
                        pwcTTF++;

                        if (fl & FONT_IN_SYSTEM_DIR)
                        {
                        // need to move the ttf to fonts dir, can reuse the
                        // buffer on the stack:

                            wcscpy(awcTmpBuf, gpwcFontsDir);
                            lstrcatW(awcTmpBuf, L"\\");
                            lstrcatW(awcTmpBuf, pwcTTF);

                        // note that MoveFile should succeed, for if there was
                        // a ttf file of the same file name in %windir%\fonts dir
                        // we would not have been in this code path.

                                RIPMSG2(RIP_VERBOSE, "Moving %ws to %ws", awcTTF, awcTmpBuf);
                                if (!gbWin31Upgrade)
                                {
                                    UserVerify(MoveFileW(awcTTF, awcTmpBuf));
                                }
                                else
                                {
                                // Boolean value TRUE means "do not copy if target exists"

                                    UserVerify(CopyFileW(awcTTF, awcTmpBuf, TRUE));
                                }
                        }
                    }

                    RIPMSG2(RIP_VERBOSE, "writing to the registry:\n    %ws=%ws", pwcValueName, pwcTTF);
                    RtlInitUnicodeString(&UnicodeString, awcValueName);
                    Status = NtSetValueKey(hkey,
                                           &UnicodeString,
                                           0,
                                           REG_SZ,
                                           pwcTTF,
                                           (wcslen(pwcTTF)+1) * sizeof(WCHAR));
                    UserAssert(NT_SUCCESS(Status));
                }
                #if DBG
                else
                {
                    RIPMSG1(RIP_WARNING, "Could not locate ttf pointed to by %ws", awcTmpBuf);
                }
                #endif
            }
            #if DBG
            else
            {
                RIPMSG1(RIP_WARNING, "Could not locate .fot:  %ws", awcFileName);
            }
            #endif
        }
    }
    else
    {
    // not a true type case. little bit simpler,
    // we will use awcTTF buffer for the full path name, and pwcTTF
    // as local variable even though these TTF names are misnomer
    // for these are not tt fonts

        if (bMakePathNameW(awcTTF, awcFileName,NULL, &fl))
        {
        // At this point
        // awcTTF points to the FULL path to the font file.

        // If the font is in the system subdirectory we will just move it
        // to the fonts subdirectory. If the path in the registry is relative
        // we will leave it alone. If it is an absolute path, we shall
        // fix the registry entry to only contain relative path, the
        // absolute path is redundant.

            if (fl & (FONT_IN_SYSTEM_DIR | FONT_IN_FONTS_DIR))
            {
            // find the bare file part, this is what will be written
            // in the registry

                pwcTTF = &awcTTF[wcslen(awcTTF) - 1];
                while ((pwcTTF >= awcTTF) && (*pwcTTF != L'\\') && (*pwcTTF != L':'))
                    pwcTTF--;
                pwcTTF++;

                if (fl & FONT_IN_SYSTEM_DIR)
                {
                // need to move the font to fonts dir, can reuse the
                // buffer on the stack to build the full destination path

                    wcscpy(awcTmpBuf, gpwcFontsDir);
                    lstrcatW(awcTmpBuf, L"\\");
                    lstrcatW(awcTmpBuf, pwcTTF);

                // note that MoveFile should succeed, for if there was
                // a font file of the same file name in %windir%\fonts dir
                // we would not have been in this code path. The only time
                // it could fail if the path in the registry is absolute.

                    RIPMSG2(RIP_VERBOSE, "Moving %ws to %ws", awcTTF, awcTmpBuf);
                    if (!gbWin31Upgrade)
                    {
                        UserVerify(MoveFileW(awcTTF, awcTmpBuf));
                    }
                    else
                    {
                    // Boolean value TRUE means "do not copy if target exists"

                        UserVerify(CopyFileW(awcTTF, awcTmpBuf, TRUE));
                    }
                }

            // check if the file path in the registry is absolute,
            // if so make it relative:

                if (!(fl & FONT_RELATIVE_PATH))
                {
                    RIPMSG2(RIP_VERBOSE, "writing to the registry:\n    %ws=%ws", pwcValueName, pwcTTF);
                    RtlInitUnicodeString(&UnicodeString, awcValueName);
                    Status = NtSetValueKey(hkey,
                                           &UnicodeString,
                                           0,
                                           REG_SZ,
                                           pwcTTF,
                                           (wcslen(pwcTTF)+1) * sizeof(WCHAR));
                    UserAssert(NT_SUCCESS(Status));
                }
            }
        }
    }
}


/******************************Public*Routine******************************\
*
* VOID vMoveFileFromSystemToFontsDir(WCHAR *pwcFile)
*
* History:
*  24-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




VOID vMoveFileFromSystemToFontsDir(WCHAR *pwcFile)
{
    WCHAR awcTmpBuf[MAX_PATH];
    WCHAR awcTmp[MAX_PATH];
    FLONG fl;
    WCHAR *pwcTmp;

#if DBG
    BOOL  bOk;
#endif

    if (bMakePathNameW(awcTmp, pwcFile,NULL, &fl))
    {
    // If the font is in the system subdirectory we will just move it
    // to the fonts subdirectory. The path in the registry is relative
    // and we will leave it alone.

        if
        (
            (fl & (FONT_IN_SYSTEM_DIR | FONT_RELATIVE_PATH)) ==
            (FONT_IN_SYSTEM_DIR | FONT_RELATIVE_PATH)
        )
        {
        // find the bare file part, this is what will be written
        // in the registry

            pwcTmp = &awcTmp[wcslen(awcTmp) - 1];
            while ((pwcTmp >= awcTmp) && (*pwcTmp != L'\\') && (*pwcTmp != L':'))
                pwcTmp--;

            if (pwcTmp > awcTmp)
                pwcTmp++;

        // need to move the font to fonts dir, can reuse the
        // buffer on the stack to build the full destination path

            wcscpy(awcTmpBuf, gpwcFontsDir);
            lstrcatW(awcTmpBuf, L"\\");
            lstrcatW(awcTmpBuf, pwcTmp);

        // note that MoveFile should succeed, for if there was
        // a font file of the same file name in %windir%\fonts dir
        // we would not have been in this code path.

            #if DBG
                bOk =
            #endif
                MoveFileW(awcTmp, awcTmpBuf);

            RIPMSG3(RIP_VERBOSE,
                    "move %ws to %ws %s",
                    awcTmp,
                    awcTmpBuf,
                    (bOk) ? "succeeded" : "failed");
        }
        #if DBG
        else
        {
            RIPMSG2(RIP_WARNING,
                    "File %ws not in system directory, fl = 0x%lx\n",
                    awcTmp, fl);
        }
        #endif

    }
    #if DBG
    else
    {
        RIPMSG1(RIP_WARNING, "Could not locate %ws", pwcFile);
    }
    #endif
}



/******************************Public*Routine******************************\
*
* VOID vProcessType1FontEntry
*
*
* Effects: All this routine does is to check if pwcPFM and pwcPFB pointed to
*          by pwcValueData point to files in the %windir%system directory
*          and if so copies these type 1 files to %windir%\fonts directory
*
* History:
*  20-Nov-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vProcessType1FontEntry(
    HKEY   hkey,
    WCHAR *pwcValueName,
    ULONG ulValueNameLength,
    WCHAR *pwcValueData,
    ULONG ulValueDataLength
)
{
    WCHAR *pwcPFM, *pwcPFB;

    UNREFERENCED_PARAMETER(hkey);
    UNREFERENCED_PARAMETER(pwcValueName);
    UNREFERENCED_PARAMETER(ulValueNameLength);
    UNREFERENCED_PARAMETER(ulValueDataLength);

// skip unused boolean value in this multi reg_sz string:

    if ((pwcValueData[0] != L'\0') && (pwcValueData[1] == L'\0'))
    {
        pwcPFM = &pwcValueData[2];
        pwcPFB = pwcPFM + wcslen(pwcPFM) + 1; // add 1 for zero separator

        vMoveFileFromSystemToFontsDir(pwcPFM);
        vMoveFileFromSystemToFontsDir(pwcPFB);
    }
}


/******************************Public*Routine******************************\
*
* VOID vAddRemote/LocalType1Font
*
* History:
*  25-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vAddType1Font(
    WCHAR *pwcValueData,
    DWORD  dwFlags
)
{
    WCHAR *pwcPFM, *pwcPFB, *pwcMMM;

    #if DBG
    int iRet;
    #endif

// skip unused boolean value in this multi reg_sz string:

    if ((pwcValueData[0] != L'\0') && (pwcValueData[1] == L'\0'))
    {
        pwcPFM = &pwcValueData[2];
        pwcPFB = pwcPFM + wcslen(pwcPFM) + 1; // add 1 for zero separator
        pwcMMM = pwcPFB + wcslen(pwcPFB) + 1; // may of may not be there.

    // replace space by separator and call addfontresourcew

        pwcPFB[-1] = PATH_SEPARATOR;

    // if this is a multiple master font, need one more separator:

        if (pwcMMM[0] != L'\0')
            pwcMMM[-1] = PATH_SEPARATOR;

        #if DBG
            iRet =
        #endif

        GdiAddFontResourceW(pwcPFM, dwFlags, NULL);

        #if DBGSWEEP
            DbgPrint("%ld = GdiAddFontResourceW(%ws, 0x%lx);\n",
                iRet, pwcPFM, dwFlags);
        #endif
    }
}


VOID vAddRemoteType1Font(
    HKEY   hkey,
    WCHAR *pwcValueName,
    ULONG ulValueNameLength,
    WCHAR *pwcValueData,
    ULONG ulValueDataLength
)
{
    UNREFERENCED_PARAMETER(hkey);
    UNREFERENCED_PARAMETER(pwcValueName);
    UNREFERENCED_PARAMETER(ulValueNameLength);
    UNREFERENCED_PARAMETER(ulValueDataLength);
    vAddType1Font(pwcValueData, AFRW_ADD_REMOTE_FONT);
}

VOID vAddLocalType1Font(
    HKEY   hkey,
    WCHAR *pwcValueName,
    ULONG ulValueNameLength,
    WCHAR *pwcValueData,
    ULONG ulValueDataLength
)
{
    UNREFERENCED_PARAMETER(hkey);
    UNREFERENCED_PARAMETER(pwcValueName);
    UNREFERENCED_PARAMETER(ulValueNameLength);
    UNREFERENCED_PARAMETER(ulValueDataLength);
    vAddType1Font(pwcValueData, AFRW_ADD_LOCAL_FONT);
}


typedef  VOID (*PFNENTRY)(HKEY hkey, WCHAR *, ULONG, WCHAR *, ULONG);


/******************************Public*Routine******************************\
*
* VOID vFontSweep()
*
* This is the main routine in this module. Checks if the fonts need to be
* "sweeped" and does so if need be.
*
* History:
*  27-Oct-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vSweepFonts(
    PCWSTR   pwszFontListKey,       // font list key
    PCWSTR   pwszFontSweepKey,      // the corresponding sweep key
    PFNENTRY pfnProcessFontEntry,   // function that processes individual entry
    BOOL     bForceEnum             // force enumeration
    )
{
    DWORD      cjMaxValueName;
    DWORD      iFont;
    NTSTATUS   Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjA;
    KEY_FULL_INFORMATION KeyInfo;
    DWORD      dwReturnLength;

    PKEY_VALUE_FULL_INFORMATION KeyValueInfo;
    BYTE       *pjValueData;

    HKEY       hkey = NULL;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION;
        LARGE_INTEGER;
    } SweepValueInfo;
    LARGE_INTEGER LastSweepTime;
    BOOL       bSweep = FALSE;

    HKEY       hkeyLastSweep;
    DWORD      cjData;

    if (!bForceEnum)
    {
    // first check if anything needs to be done, that is, if anybody
    // touched the [Fonts] section of the registry since the last time we sweeped it.
    // get the time of the last sweep of the fonts section of the registry:

        RtlInitUnicodeString(&UnicodeString, pwszFontSweepKey);
        InitializeObjectAttributes(&ObjA,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
        Status = NtOpenKey(&hkeyLastSweep,
                           KEY_READ | KEY_WRITE,
                           &ObjA);

        if (!NT_SUCCESS(Status))
        {
            DWORD  dwDisposition;

        // We are running for the first time, we need to create the key
        // for it does not exist as yet at this time

            bSweep = TRUE;

        // Create the key, open it for writing, since we will have to
        // store the time when the [Fonts] section of the registry was last swept

            Status = NtCreateKey(&hkeyLastSweep,
                                 KEY_WRITE,
                                 &ObjA,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 &dwDisposition);

            if (!NT_SUCCESS(Status))
                return;
        }
        else
        {
            RtlInitUnicodeString(&UnicodeString, LAST_SWEEP_TIME);
            Status = NtQueryValueKey(hkeyLastSweep,
                                     &UnicodeString,
                                     KeyValuePartialInformation,
                                     &SweepValueInfo,
                                     sizeof(SweepValueInfo),
                                     &dwReturnLength);
            if (!NT_SUCCESS(Status))
            {
                bSweep = TRUE; // force sweep, something is suspicious
            }
            else
            {
                UserAssert(SweepValueInfo.Type == REG_BINARY);
                UserAssert(SweepValueInfo.DataLength == sizeof(LastSweepTime));
                RtlCopyMemory(&LastSweepTime, &SweepValueInfo.Data, sizeof(LastSweepTime));
            }
        }
    }
    else
    {
        bSweep = TRUE;
    }

// now open the Fonts key and get the time the key last changed:
// now get the time of the time of the last change is bigger than
// the time of last sweep, must sweep again:

    RtlInitUnicodeString(&UnicodeString, pwszFontListKey);
    InitializeObjectAttributes(&ObjA,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&hkey,
                       KEY_READ | KEY_WRITE,
                       &ObjA);

    if (NT_SUCCESS(Status))
    {
    // get the number of entries in the [Fonts] section

        Status = NtQueryKey(hkey,
                    KeyFullInformation,
                    &KeyInfo,
                    sizeof(KeyInfo),
                    &dwReturnLength);

        if (NT_SUCCESS(Status) && KeyInfo.Values)
        {
            UserAssert(!(KeyInfo.ClassLength | KeyInfo.SubKeys | KeyInfo.MaxNameLen | KeyInfo.MaxClassLen));

        // now let us check if the fonts need to be sweeped. This is the case
        // when the registry last write time is bigger than the last sweep time

            if (!bSweep)
            {
                if (KeyInfo.LastWriteTime.QuadPart != LastSweepTime.QuadPart ) {
                    bSweep = TRUE;
                }
            }

        // init system dir, we will need it:

            if (bSweep &&
                bInitSystemAndFontsDirectoriesW(&gpwcSystemDir, &gpwcFontsDir))
            {
            // alloc buffer big enough to hold the biggest ValueName and ValueData

                cjMaxValueName = DWORDALIGN(KeyInfo.MaxValueNameLen + sizeof(WCHAR));

            // allocate temporary buffer into which we are going to pull the contents
            // of the registry

                KeyInfo.MaxValueDataLen = DWORDALIGN(KeyInfo.MaxValueDataLen);
                cjData = cjMaxValueName +    // space for the value name
                         KeyInfo.MaxValueDataLen ;    // space for the value data

                if (KeyValueInfo = UserLocalAlloc(0, sizeof(*KeyValueInfo) + cjData))
                {
                    for (iFont = 0; iFont < KeyInfo.Values; iFont++)
                    {
                        Status = NtEnumerateValueKey(
                                    hkey,
                                    iFont,
                                    KeyValueFullInformation,
                                    KeyValueInfo,
                                    sizeof(*KeyValueInfo) + cjData,
                                    &dwReturnLength);

                        if (NT_SUCCESS(Status))
                        {
                            UserAssert(KeyValueInfo->NameLength <= KeyInfo.MaxValueNameLen);
                            UserAssert(KeyValueInfo->DataLength <= KeyInfo.MaxValueDataLen);
                            UserAssert((KeyValueInfo->Type == REG_SZ) || (KeyValueInfo->Type == REG_MULTI_SZ));

                        // data goes into the second half of the buffer

                            pjValueData = (BYTE *)KeyValueInfo + KeyValueInfo->DataOffset;

                        // see if the font files are where the registry claims they are.
                        // It is unfortunate we have to do this because SearchPathW
                        // is slow because it touches the disk.

                            (*pfnProcessFontEntry)(hkey,
                                                   KeyValueInfo->Name,
                                                   KeyValueInfo->NameLength / sizeof(WCHAR),
                                                   (WCHAR *)pjValueData,
                                                   KeyValueInfo->DataLength / sizeof(WCHAR));
                        }
                    }

                    if (!bForceEnum)
                    {
                    // now that the sweep is completed, get the last write time
                    // and store it as the LastSweepTime at the appropriate location

                        Status = NtQueryKey(hkey,
                                    KeyFullInformation,
                                    &KeyInfo,
                                    sizeof(KeyInfo),
                                    &dwReturnLength);
                        UserAssert(NT_SUCCESS(Status));

                    // now remember the result

                        RtlInitUnicodeString(&UnicodeString, LAST_SWEEP_TIME);
                        Status = NtSetValueKey(hkeyLastSweep,
                                               &UnicodeString,
                                               0,
                                               REG_BINARY,
                                               &KeyInfo.LastWriteTime,
                                               sizeof(KeyInfo.LastWriteTime));
                        UserAssert(NT_SUCCESS(Status));
                    }

                // free the memory that will be no longer needed

                    UserLocalFree(KeyValueInfo);
                }
            }
        }
        NtClose(hkey);
    }

    if (!bForceEnum)
    {
        NtClose(hkeyLastSweep);
    }
}


/******************************Public*Routine******************************\
*
* BOOL bLoadableFontDrivers()
*
* open the font drivers key and check if there are any entries, if so
* return true. If that is the case we will call AddFontResourceW on
* Type 1 fonts at boot time, right after user had logged on
* PostScript printer drivers are not initialized at this time yet,
* it is safe to do it at this time.
* Effects:
*
* Warnings:
*
* History:
*  24-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL bLoadableFontDrivers()
{
    NTSTATUS             Status;
    UNICODE_STRING       UnicodeString;
    OBJECT_ATTRIBUTES    ObjA;
    KEY_FULL_INFORMATION KeyInfo;
    DWORD                dwReturnLength;
    HKEY                 hkey = NULL;
    BOOL                 bRet = FALSE;

// open the font drivers key and check if there are any entries, if so
// return true. If that is the case we will call AddFontResourceW on
// Type 1 fonts at boot time, right after user had logged on
// PostScript printer drivers are not initialized at this time yet,
// it is safe to do it at this time.

    RtlInitUnicodeString(&UnicodeString, pwszFontDrivers);
    InitializeObjectAttributes(&ObjA,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&hkey,
                       KEY_READ,
                       &ObjA);

    if (NT_SUCCESS(Status))
    {
    // get the number of entries in the [Fonts] section

        Status = NtQueryKey(hkey,
                    KeyFullInformation,
                    &KeyInfo,
                    sizeof(KeyInfo),
                    &dwReturnLength);

        if (NT_SUCCESS(Status) && KeyInfo.Values)
        {
            UserAssert(!(KeyInfo.ClassLength | KeyInfo.SubKeys | KeyInfo.MaxNameLen | KeyInfo.MaxClassLen));

        // externally loadable drivers are present, force sweep

            bRet = TRUE;
        }

        NtClose(hkey);
    }
    return bRet;
}



/***********************Public*Routine******************************\
*
* BOOL bCheckAndDeleteTTF()
*
* Checks whether there is a converted TTF corresponding to
* a Type1 font. Delete the TTF file and the reg entry if there is.
*
* History:
*  29-Jan-1998 -by- Xudong Wu [TessieW]
* Wrote it.
\*******************************************************************/
BOOL bCheckAndDeleteTTF
(
    HKEY    hkey,
    PKEY_FULL_INFORMATION pKeyInfo,
    PKEY_VALUE_FULL_INFORMATION KeyValueInfo,
    PKEY_VALUE_BASIC_INFORMATION KeyValueBasicInfo,
    DWORD   cjData
)
{
    NTSTATUS    Status;
    UNICODE_STRING UnicodeString;
    DWORD       dwReturnLength;
    ULONG       iFont;
    WCHAR       awcTmp[MAX_PATH], *pFontName, *pType1Name, *pwcFile;
    BOOL        bDelTTFfile, bRet = TRUE;
    FLONG       fl;
    WCHAR       awcType1Name[MAX_PATH];  // null-terminated pType1Name
    WCHAR       awcFontName[MAX_PATH];   // null-terminated pFontName
    WCHAR       awcFile[MAX_PATH];       // null-terminated pwcFile

    // pKeyInfo holds the full info on the key "Fonts"
    for (iFont = 0; iFont < pKeyInfo->Values; iFont++)
    {
        RtlZeroMemory(KeyValueInfo->Name, cjData);
        Status = NtEnumerateValueKey(
                    hkey,
                    iFont,
                    KeyValueFullInformation,
                    KeyValueInfo,
                    sizeof(*KeyValueInfo) + cjData,
                    &dwReturnLength);

        if (NT_SUCCESS(Status))
        {
            UserAssert(KeyValueInfo->NameLength <= pKeyInfo->MaxValueNameLen);
            UserAssert(KeyValueInfo->DataLength <= pKeyInfo->MaxValueDataLen);
            UserAssert(KeyValueInfo->Type == REG_SZ);

            bDelTTFfile = FALSE;

            // Make sure we use null-terminated strings
            vNullTermWideString (awcType1Name,
                                 KeyValueBasicInfo->Name,
                                 KeyValueBasicInfo->NameLength / sizeof(WCHAR));
            vNullTermWideString (awcFontName,
                                 KeyValueInfo->Name,
                                 KeyValueInfo->NameLength / sizeof(WCHAR));
            vNullTermWideString (awcFile,
                                 (WCHAR *) ((BYTE *)KeyValueInfo + KeyValueInfo->DataOffset),
                                 KeyValueInfo->DataLength / sizeof(WCHAR));
            pType1Name = awcType1Name;
            pFontName = awcFontName;
            pwcFile = awcFile;

            while((*pType1Name) && (*pType1Name++ == *pFontName++))
                ;

            // if the font name match the type1 name
            // check whether this is a ttf font
            if ((*pType1Name == 0) && (*pFontName++ == L' '))
            {
                WCHAR *pTrueType = L"(TrueType)";

                while(*pTrueType && (*pTrueType++ == *pFontName++))
                    ;
                if (*pTrueType == 0)
                {
                    bDelTTFfile = TRUE;
                }
            }

            if (bDelTTFfile)
            {
                // delete the converted TTF file
                if (bRet = bMakePathNameW(awcTmp, pwcFile, NULL, &fl))
                {
                    UserVerify((bRet = DeleteFileW(awcTmp)));
                }

                // remove the reg entry
                *pFontName = 0;
                RtlInitUnicodeString(&UnicodeString, awcFontName);
                Status = NtDeleteValueKey(hkey, (PUNICODE_STRING)&UnicodeString);

                // decrement the number of values under [Fonts]
                if (NT_SUCCESS(Status))
                    pKeyInfo->Values--;
                else
                    bRet = FALSE;

                break;
            }
        }
        else
        {
            bRet = FALSE;
            break;
        }
    }

    return bRet;
}


/***********************Public*Routine**************************\
*
* BOOL bCleanConvertedTTFs()
*
* Enumerate each entry under "Upgrade Type1" key, call
* bCheckAndDeleteTTF() to remove the coverted TTFs.
*
* History:
*  29-Jan-1998 -by- Xudong Wu [TessieW]
* Wrote it.
\***************************************************************/
BOOL bCleanConvertedTTFs()
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS    Status;
    HKEY        hkeyFonts = NULL, hkeyType1 = NULL;
    DWORD       dwReturnLength;
    DWORD       iFontT1, cjData;
    DWORD       cjMaxValueNameT1, cjMaxValueNameFonts;
    BOOL        bRet = FALSE, bError = FALSE;

    KEY_FULL_INFORMATION KeyInfoType1, KeyInfoFonts;
    PKEY_VALUE_BASIC_INFORMATION KeyValueBasicInfo;
    PKEY_VALUE_FULL_INFORMATION KeyValueInfo;

    // Open and query the value from the "Type1 Fonts" key
    // No need to continue if not succeed or no Type1 font listed
    RtlInitUnicodeString(&UnicodeString, pwszType1Key);
    InitializeObjectAttributes(&ObjA,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

    Status = NtOpenKey(&hkeyType1,
                    KEY_READ | KEY_WRITE,
                    &ObjA);

    if (NT_SUCCESS(Status))
    {
        Status = NtQueryKey(hkeyType1,
                    KeyFullInformation,
                    &KeyInfoType1,
                    sizeof(KeyInfoType1),
                    &dwReturnLength);

        if (NT_SUCCESS(Status) && KeyInfoType1.Values)
        {
            UserAssert(!(KeyInfoType1.ClassLength | KeyInfoType1.SubKeys |
                         KeyInfoType1.MaxNameLen | KeyInfoType1.MaxClassLen));

            cjMaxValueNameT1 = DWORDALIGN(KeyInfoType1.MaxValueNameLen + sizeof(WCHAR));

            // Alloc buffer big enough to hold the longest Name
            if (KeyValueBasicInfo = UserLocalAlloc(0, sizeof(*KeyValueBasicInfo) + cjMaxValueNameT1))
            {
                RtlInitUnicodeString(&UnicodeString, pwszFontsKey);
                InitializeObjectAttributes(&ObjA,
                                           &UnicodeString,
                                           OBJ_CASE_INSENSITIVE,
                                           NULL,
                                           NULL);
                Status = NtOpenKey(&hkeyFonts,
                                   KEY_READ | KEY_WRITE,
                                   &ObjA);
                if (NT_SUCCESS(Status)) {
                    Status = NtQueryKey(hkeyFonts,
                                        KeyFullInformation,
                                        &KeyInfoFonts,
                                        sizeof(KeyInfoFonts),
                                        &dwReturnLength);
                    if (NT_SUCCESS(Status) && KeyInfoFonts.Values) {
                        UserAssert(!(KeyInfoFonts.ClassLength | KeyInfoFonts.SubKeys |
                                     KeyInfoFonts.MaxNameLen | KeyInfoFonts.MaxClassLen));

                        cjMaxValueNameFonts = DWORDALIGN(KeyInfoFonts.MaxValueNameLen + sizeof(WCHAR));
                        KeyInfoFonts.MaxValueDataLen = DWORDALIGN(KeyInfoFonts.MaxValueDataLen);
                        cjData = cjMaxValueNameFonts + KeyInfoFonts.MaxValueDataLen;

                        // Alloc buffer big enough to hold the longest Name and Value
                        if (KeyValueInfo = UserLocalAlloc(0, sizeof(*KeyValueInfo) + cjData))
                        {
                            // Enum the "Type1 Fonts" key
                            for (iFontT1 = 0; iFontT1 < KeyInfoType1.Values; iFontT1++)
                            {
                                RtlZeroMemory(KeyValueBasicInfo->Name, cjMaxValueNameT1);
                                Status = NtEnumerateValueKey(
                                            hkeyType1,
                                            iFontT1,
                                            KeyValueBasicInformation,
                                            KeyValueBasicInfo,
                                            sizeof(*KeyValueBasicInfo) + cjMaxValueNameT1,
                                            &dwReturnLength);

                                if (NT_SUCCESS(Status))
                                {
                                    UserAssert(KeyValueBasicInfo->NameLength <= KeyInfoType1.MaxValueNameLen);
                                    UserAssert(KeyValueBasicInfo->Type == REG_MULTI_SZ);

                                    // For each Type1 font, check to see whether
                                    // there is corresponding converted TTF
                                    // Delete the TTF file and reg entry if any

                                    bRet = bCheckAndDeleteTTF(hkeyFonts, &KeyInfoFonts, KeyValueInfo,
                                                            KeyValueBasicInfo, cjData);
                                    if (!bRet)
                                    {
                                        bError = TRUE;
                                    }
                                }
                            }
                            UserLocalFree(KeyValueInfo);
                            // no type1 fonts installed
                            if (KeyInfoType1.Values == 0)
                            {
                                bRet = TRUE;
                            }
                        }
                    }
                    NtClose(hkeyFonts);
                }  // NtOpenKey (hkeyFonts)
                UserLocalFree(KeyValueBasicInfo);
            }
        }  // NtQueryKey (hkeyType1)
        NtClose(hkeyType1);
    }

    return (bRet && !bError);
}


/***********************Public*Routine******************************\
*
* VOID vCleanConvertedTTFs()
*
* Delete the converted TTFs and clean the registry if there is any
* TTFs generated from Type1 fonts.
*
* History:
*  29-Jan-1998 -by- Xudong Wu [TessieW]
* Wrote it.
\*******************************************************************/
VOID vCleanConvertedTTFs()
{
    BOOL    bNeedUpgrade = FALSE;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjA;
    DWORD      dwReturnLength;
    NTSTATUS   Status;
    HKEY       hkeyUpgradeType1 = NULL;

    struct {
        KEY_VALUE_PARTIAL_INFORMATION;
        LARGE_INTEGER;
    } UpgradeValueInfo;
    DWORD      UpgradeValue = 0;

    RtlInitUnicodeString(&UnicodeString, pwszUpdType1Key);
    InitializeObjectAttributes(&ObjA,
                           &UnicodeString,
                           OBJ_CASE_INSENSITIVE,
                           NULL,
                           NULL);

    Status = NtOpenKey(&hkeyUpgradeType1,
                   KEY_READ | KEY_WRITE,
                   &ObjA);

    if (!NT_SUCCESS(Status))
    {
        // Key doesn't exist, run for the first time
        // Create the key, open it for writing

        DWORD  dwDisposition;

        Status = NtCreateKey(&hkeyUpgradeType1,
                         KEY_WRITE,
                         &ObjA,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &dwDisposition);
        if (NT_SUCCESS(Status))
        {
            bNeedUpgrade = TRUE;
        }
    }
    else
    {
        RtlInitUnicodeString(&UnicodeString, UPGRADED_TYPE1);
        Status = NtQueryValueKey(hkeyUpgradeType1,
                         &UnicodeString,
                         KeyValuePartialInformation,
                         &UpgradeValueInfo,
                         sizeof(UpgradeValueInfo),
                         &dwReturnLength);

        if (NT_SUCCESS(Status))
        {
            UserAssert(UpgradeValueInfo.Type == REG_DWORD);
            UserAssert(UpgradeValueInfo.DataLength == sizeof(UpgradeValue));
            RtlCopyMemory(&UpgradeValue, &UpgradeValueInfo.Data, sizeof(UpgradeValue));

            // Done if the value is non-zero.
            if (UpgradeValue == 0)
            {
               bNeedUpgrade = TRUE;
            }
        }
    }

    if (bNeedUpgrade)
    {
        if (bCleanConvertedTTFs())
        {
            UpgradeValue = 1;
        }

        RtlInitUnicodeString(&UnicodeString, UPGRADED_TYPE1);
        Status = NtSetValueKey(hkeyUpgradeType1,
              &UnicodeString,
              0,
              REG_DWORD,
              &UpgradeValue,
              sizeof(UpgradeValue));
        UserAssert(NT_SUCCESS(Status));
    }

    if (hkeyUpgradeType1)
    {
        NtClose(hkeyUpgradeType1);
    }
}


/******************************Public*Routine******************************\
*
* VOID vFontSweep()
*
* Effects: The main routine, calls vSweepFonts to sweep "regular" fonts
*          and then to sweep type 1 fonts
*
* History:
*  20-Nov-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/
VOID vFontSweep(
    VOID)
{
    /*
     * Check if shared windows directory installation.
     */
    gbWin31Upgrade = bCheckIfDualBootingWithWin31();

    /*
     * Before we sweep the files to the Fonts directory, check whether the
     * 'converted' TTFs have been removed.
     */
    vCleanConvertedTTFs();

    /*
     * Sweep fonts in the [Fonts] key.
     */
    vSweepFonts(pwszFontsKey, pwszSweepKey, vProcessFontEntry, FALSE);

    /*
     * Now sweep type 1 fonts, if any.
     */
    vSweepFonts(pwszType1Key, pwszSweepType1Key, vProcessType1FontEntry, FALSE);

    if (gpwcSystemDir) {
        UserLocalFree(gpwcSystemDir);
        gpwcSystemDir = NULL;
    }
}


/******************************Public*Routine******************************\
* vLoadLT1Fonts
*
* History:
*  30-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/
VOID vLoadT1Fonts(
    PFNENTRY pfnProcessFontEntry)
{
    if (bLoadableFontDrivers()) {
        /*
         * Now enum and add remote type1 fonts if any.
         */
        vSweepFonts(pwszType1Key, pwszSweepType1Key, pfnProcessFontEntry, TRUE);

        if (gpwcSystemDir) {
            UserLocalFree(gpwcSystemDir);
            gpwcSystemDir = NULL;
        }
    }
}

VOID vLoadLocalT1Fonts(
    VOID)
{
    vLoadT1Fonts(vAddLocalType1Font);
}

VOID vLoadRemoteT1Fonts(
    VOID)
{
    vLoadT1Fonts(vAddRemoteType1Font);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\getsetc.c ===
/****************************** Module Header ******************************\
* Module Name: getsetc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains window manager information routines
*
* History:
* 10-Mar-1993 JerrySh   Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* _GetWindowWord (supports the GetWindowWord API)
*
* Return a window word.  Positive index values return application window words
* while negative index values return system window words.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 11-26-90 darrinm      Wrote.
\***************************************************************************/

WORD _GetWindowWord(
    PWND pwnd,
    int index)
{
    if (GETFNID(pwnd) != 0) {
        if ((index >= 0) && (index <
                (int)(CBFNID(pwnd->fnid)-sizeof(WND)))) {

            switch (GETFNID(pwnd)) {
            case FNID_MDICLIENT:
                if (index == 0)
                    break;
                goto DoDefault;

            case FNID_BUTTON:
                /*
                 * CorelDraw does a get/set on the first button window word.
                 * Allow it to.
                 */
                if (index == 0) {
                    /*
                     *  Since we now use a lookaside buffer for the control's
                     *  private data, we need to indirect into this structure.
                     */
                    PBUTN pbutn = ((PBUTNWND)pwnd)->pbutn;
                    if (!pbutn || (LONG_PTR)pbutn == (LONG_PTR)-1) {
                        return 0;
                    } else {
                        return (WORD)(pbutn->buttonState);
                    }
                }
                goto DoDefault;

            case FNID_DIALOG:
                if (index == DWLP_USER)
                    return LOWORD(((PDIALOG)pwnd)->unused);
                if (index == DWLP_USER+2)
                    return HIWORD(((PDIALOG)pwnd)->unused);
                goto DoDefault;

            default:
DoDefault:
                RIPERR3(ERROR_INVALID_INDEX,
                        RIP_WARNING,
                        "GetWindowWord: Trying to read private server data pwnd=(%#p) index=(%ld) fnid=(%lX)",
                        pwnd, index, (DWORD)pwnd->fnid);
                return 0;
                break;
            }
        }
    }

    if (index == GWLP_USERDATA)
        return (WORD)pwnd->dwUserData;

    if ((index < 0) || ((UINT)index + sizeof(WORD) > (UINT)pwnd->cbwndExtra)) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return 0;
    } else {
        return *((WORD UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pwnd + 1) + index));
    }
}

ULONG_PTR GetWindowData(PWND pwnd, int index, BOOL bAnsi);

/***************************************************************************\
* _GetWindowLong (supports GetWindowLongA/W API)
*
* Return a window long.  Positive index values return application window longs
* while negative index values return system window longs.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 11-26-90 darrinm      Wrote.
\***************************************************************************/

ULONG_PTR _GetWindowLongPtr(
    PWND pwnd,
    int index,
    BOOL bAnsi)
{
    ULONG_PTR           dwProc;
    DWORD              dwCPDType = 0;
    ULONG_PTR UNALIGNED * KPTR_MODIFIER pudw;

    /*
     * If it's a dialog window, only a few indices are permitted.
     */
    if (GETFNID(pwnd) != 0) {
        if (TestWF(pwnd, WFDIALOGWINDOW)) {
            switch (index) {
            case DWLP_DLGPROC:    // See similar case GWLP_WNDGPROC

                /*
                 * Hide the window proc from other processes
                 */
                if (!TestWindowProcess(pwnd)) {
                    RIPERR1(ERROR_ACCESS_DENIED,
                            RIP_WARNING,
                            "Access denied to \"pwnd\" (%#p) in _GetWindowLong",
                            pwnd);

                    return 0;
                }

                dwProc = (ULONG_PTR)PDLG(pwnd)->lpfnDlg;

                /*
                 * If a proc exists check it to see if we need a translation
                 */
                if (dwProc) {

                    /*
                     * May need to return a CallProc handle if there is an
                     * Ansi/Unicode transition
                     */
                    if (bAnsi != ((PDLG(pwnd)->flags & DLGF_ANSI) ? TRUE : FALSE)) {
                        dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
                    }

                    if (dwCPDType) {
                        ULONG_PTR cpd;

                        cpd = GetCPD(pwnd, dwCPDType | CPD_DIALOG, dwProc);

                        if (cpd) {
                            dwProc = cpd;
                        } else {
                            RIPMSG0(RIP_WARNING, "GetWindowLong unable to alloc CPD returning handle\n");
                        }
                    }
                }

                /*
                 * return proc (or CPD handle)
                 */
                return dwProc;

            case DWLP_MSGRESULT:
                 return (ULONG_PTR)((PDIALOG)pwnd)->resultWP;

            case DWLP_USER:
                 return (ULONG_PTR)((PDIALOG)pwnd)->unused;

            default:
                if (index >= 0 && index < DLGWINDOWEXTRA) {
                    RIPERR0(ERROR_PRIVATE_DIALOG_INDEX, RIP_VERBOSE, "");
                    return 0;
                }
            }
        } else {
            if (index >= 0 &&
                    (index < (int)(CBFNID(pwnd->fnid)-sizeof(WND)))) {
                switch (GETFNID(pwnd)) {
                case FNID_MDICLIENT:
                    /*
                     * Allow the 0 index (which is reserved) to be set/get.
                     * Quattro Pro 1.0 uses this index!
                     */
                    if (index != 0)
                        break;

                    goto GetData;
                    break;

                case FNID_EDIT:

                    if (index != 0)
                        break;

                    /*
                     * If we get to this point we need to return the first
                     * entry in the lookaside.  This will provide backward
                     * compatibilty for 3.51 that allowed edit-controls to
                     * do this.  PeachTree is one app which required this.
                     */
                    pudw = (ULONG_PTR UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pwnd + 1));

                    /*
                     * Do not dereference the pointer if we are not in
                     *  the proper address space. Apps like Spyxx like to
                     *  do this on other process' windows
                     */
                    return (TestWindowProcess(pwnd) ? *(ULONG_PTR UNALIGNED *)*pudw : (ULONG_PTR)pudw);

                }

                RIPERR3(ERROR_INVALID_INDEX,
                        RIP_WARNING,
                        "GetWindowLong: Trying to read private server data pwnd=(%#p) index=(%ld) fnid (%lX)",
                        pwnd, index, (DWORD)pwnd->fnid);
                return 0;
            }
        }
    }

    if (index < 0) {
        return GetWindowData(pwnd, index, bAnsi);
    } else {
        if ((UINT)index + sizeof(ULONG_PTR) > (UINT)pwnd->cbwndExtra) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return 0;
        } else {

GetData:
            pudw = (ULONG_PTR UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pwnd + 1) + index);
            return *pudw;
        }
    }
}


#ifdef _WIN64
DWORD _GetWindowLong(
    PWND pwnd,
    int index,
    BOOL bAnsi)
{
    DWORD UNALIGNED * KPTR_MODIFIER pudw;

    /*
     * If it's a dialog window, only a few indices are permitted.
     */
    if (GETFNID(pwnd) != 0) {
        if (TestWF(pwnd, WFDIALOGWINDOW)) {
            switch (index) {
            case DWLP_DLGPROC:    // See similar case GWLP_WNDPROC
                RIPERR1(ERROR_INVALID_INDEX, RIP_WARNING, "GetWindowLong: invalid index %d", index);
                return 0;

            case DWLP_MSGRESULT:
                 return (DWORD)((PDIALOG)pwnd)->resultWP;

            case DWLP_USER:
                 return (DWORD)((PDIALOG)pwnd)->unused;

            default:
                if (index >= 0 && index < DLGWINDOWEXTRA) {
                    RIPERR0(ERROR_PRIVATE_DIALOG_INDEX, RIP_VERBOSE, "");
                    return 0;
                }
            }
        } else {
            if (index >= 0 &&
                    (index < (int)(CBFNID(pwnd->fnid)-sizeof(WND)))) {
                switch (GETFNID(pwnd)) {
                case FNID_MDICLIENT:
                    /*
                     * Allow the 0 index (which is reserved) to be set/get.
                     * Quattro Pro 1.0 uses this index!
                     */
                    if (index != 0)
                        break;

                    goto GetData;
                    break;

                case FNID_EDIT:

                    if (index != 0)
                        break;

                    /*
                     * If we get to this point we need to return the first
                     * entry in the lookaside.  This will provide backward
                     * compatibilty for 3.51 that allowed edit-controls to
                     * do this.  PeachTree is one app which required this.
                     */
                    pudw = (DWORD UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pwnd + 1));

                    /*
                     * Do not dereference the pointer if we are not in
                     *  the proper address space. Apps like Spyxx like to
                     *  do this on other process' windows
                     */
                    return (TestWindowProcess(pwnd) ? *(DWORD UNALIGNED *)*(ULONG_PTR UNALIGNED *)pudw : PtrToUlong(pudw));


                }

                RIPERR3(ERROR_INVALID_INDEX,
                        RIP_WARNING,
                        "GetWindowLong: Trying to read private server data pwnd=(%#p) index=(%ld) fnid (%lX)",
                        pwnd, index, (DWORD)pwnd->fnid);
                return 0;
            }
        }
    }

    if (index < 0) {
        if ((index != GWL_STYLE) && (index != GWL_EXSTYLE) && (index != GWL_ID) && (index != GWLP_USERDATA)) {
            RIPERR1(ERROR_INVALID_INDEX, RIP_WARNING, "GetWindowLong: invalid index %d", index);
            return 0;
        }
        return (DWORD)GetWindowData(pwnd, index, bAnsi);
    } else {
        if ((UINT)index + sizeof(DWORD) > (UINT)pwnd->cbwndExtra) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return 0;
        } else {

GetData:
            pudw = (DWORD UNALIGNED * KPTR_MODIFIER)((KPBYTE)(pwnd + 1) + index);
            return *pudw;
        }
    }
}
#endif


/***************************************************************************\
* GetWindowData
*
* History:
* 11-26-90 darrinm      Wrote.
\***************************************************************************/

ULONG_PTR GetWindowData(
    PWND pwnd,
    int index,
    BOOL bAnsi)
{
    KERNEL_ULONG_PTR dwProc;
    DWORD dwCPDType = 0;
    PWND pwndParent;

    switch (index) {
    case GWLP_USERDATA:
        return KERNEL_ULONG_PTR_TO_ULONG_PTR(pwnd->dwUserData);

    case GWL_EXSTYLE:
        /*
         * Apps should not mess with unused bits.  We use them privately
         */
        return pwnd->ExStyle & WS_EX_ALLVALID;

    case GWL_STYLE:
        return pwnd->style;

    case GWLP_ID:
        if (TestwndChild(pwnd)) {
            return (ULONG_PTR)pwnd->spmenu;
        } else if (pwnd->spmenu != NULL) {
            PMENU pmenu;

            pmenu = REBASEALWAYS(pwnd, spmenu);
            return (ULONG_PTR)PtoH(pmenu);
        }
        return 0;

    case GWLP_HINSTANCE:
        return (ULONG_PTR)pwnd->hModule;

    case GWLP_WNDPROC: // See similar case DWLP_DLGPROC
        /*
         * Hide the window proc from other processes
         */
        if (!TestWindowProcess(pwnd)) {
            RIPERR1(ERROR_ACCESS_DENIED, RIP_WARNING, "Can not subclass another process's window %#p", pwnd);
            return 0;
        }

        /*
         * If the client queries a server-side winproc we return the
         * address of the client-side winproc (expecting ANSI or Unicode
         * depending on bAnsi)
         */
        if (TestWF(pwnd, WFSERVERSIDEPROC)) {
            dwProc = MapServerToClientPfn((KERNEL_ULONG_PTR)pwnd->lpfnWndProc, bAnsi);
            if (dwProc == 0)
                RIPMSG1(RIP_WARNING, "GetWindowLong: GWL_WNDPROC: Kernel-side wndproc can't be mapped for pwnd=%#p", pwnd);
        } else {

            /*
             * Keep edit control behavior compatible with NT 3.51.
             */
            if (GETFNID(pwnd) == FNID_EDIT) {
                dwProc = (ULONG_PTR)MapKernelClientFnToClientFn(pwnd->lpfnWndProc);
                goto CheckAnsiUnicodeMismatch;
            } else {
                PCLS pcls = REBASEALWAYS(pwnd, pcls);
                dwProc = MapClientNeuterToClientPfn(pcls, (KERNEL_ULONG_PTR)pwnd->lpfnWndProc, bAnsi);
            }

            /*
             * If the client mapping didn't change the window proc then see if
             * we need a callproc handle.
             */
            if (dwProc == (KERNEL_ULONG_PTR)pwnd->lpfnWndProc) {
CheckAnsiUnicodeMismatch:
                /*
                 * Need to return a CallProc handle if there is an Ansi/Unicode mismatch
                 */
                if (bAnsi != (TestWF(pwnd, WFANSIPROC) ? TRUE : FALSE)) {
                    dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
                }
            }

            if (dwCPDType) {
                ULONG_PTR cpd;

                cpd = GetCPD(pwnd, dwCPDType | CPD_WND, KERNEL_ULONG_PTR_TO_ULONG_PTR(dwProc));

                if (cpd) {
                    dwProc = cpd;
                } else {
                    RIPMSG0(RIP_WARNING, "GetWindowLong unable to alloc CPD returning handle\n");
                }
            }
        }

        /*
         * return proc (or CPD handle)
         */
        return KERNEL_ULONG_PTR_TO_ULONG_PTR(dwProc);

    case GWLP_HWNDPARENT:

        /*
         * If the window is the desktop window, return
         * NULL to keep it compatible with Win31 and
         * to prevent any access to the desktop owner
         * window.
         */
        if (GETFNID(pwnd) == FNID_DESKTOP) {
            return 0;
        }

        /*
         * Special case for pre-1.1 versions of Windows
         * Set/GetWindowWord(GWL_HWNDPARENT) needs to be mapped
         * to the hwndOwner for top level windows.
         *
         * Note that we find the desktop window through the
         * pti because the PWNDDESKTOP macro only works in
         * the server.
         */

        /*
         * Remove this test when we later add a test for WFDESTROYED
         * in Client handle validation.
         */
        if (pwnd->spwndParent == NULL) {
            return 0;
        }
        pwndParent = REBASEALWAYS(pwnd, spwndParent);
        if (GETFNID(pwndParent) == FNID_DESKTOP) {
            pwnd = REBASEPWND(pwnd, spwndOwner);
            return (ULONG_PTR)HW(pwnd);
        }

        return (ULONG_PTR)HW(pwndParent);

    /*
     * WOW uses a pointer straight into the window structure.
     */
    case GWLP_WOWWORDS:
        return (ULONG_PTR) &pwnd->state;

    }

    RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
    return 0;
}

#ifdef GENERIC_INPUT

FUNCLOG3(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, GetRawInputBuffer, PRAWINPUT, pData, PUINT, pcbSize, UINT, cbSizeHeader)
UINT GetRawInputBuffer(PRAWINPUT pData, PUINT pcbSize, UINT cbSizeHeader)
{
    CLIENTTHREADINFO *pcti;

    pcti = GETCLIENTTHREADINFO();

    // Validate parameters
    if (pcbSize == NULL || cbSizeHeader != sizeof(RAWINPUTHEADER)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        return -1;
    }

    // Don't even go into the kernel if there's no reason to
    if (pcti == NULL || (pcti->fsWakeBits & QS_RAWINPUT) == 0) {
        *pcbSize = 0;
        return 0;
    }

    return NtUserGetRawInputBuffer(pData, pcbSize, cbSizeHeader);
}
#endif // GENERIC_INPUT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\globals.h ===
/****************************** Module Header ******************************\
* Module Name: globals.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all of USER.DLL's global variables.  These are all
* instance-specific, i.e. each client has his own copy of these.  In general,
* there shouldn't be much reason to create instance globals.
*
* History:
* 10-18-90 DarrinM      Created.
\***************************************************************************/

#ifndef _GLOBALS_
#define _GLOBALS_

#ifdef LAZY_CLASS_INIT
extern BOOL gbClassesRegistered;
#endif

extern CONST ALWAYSZERO gZero;

extern int gcWheelDelta;

extern WORD gDispatchTableValues;

extern WCHAR awchSlashStar[];
extern CHAR achSlashStar[];

extern PSERVERINFO gpsi;
extern SHAREDINFO gSharedInfo;

extern HMODULE hmodUser;            // USER.DLL's hmodule
extern ULONG_PTR gHighestUserAddress;

extern BOOL gfServerProcess;        // USER is linked on the CSR server side.
extern BOOL gfSystemInitialized;    // System has been initialized
extern ACCESS_MASK gamWinSta;       // ACCESS_MASK for the current WindowStation

extern PVOID pUserHeap;

extern CONST CFNSCSENDMESSAGE gapfnScSendMessage[];

extern WCHAR szUSER32[];
extern CONST WCHAR szNull[];
extern CONST WCHAR szOneChar[];
extern WCHAR szSLASHSTARDOTSTAR[];

extern CONST BYTE mpTypeCcmd[];
extern CONST BYTE mpTypeIich[];
extern CONST UINT SEBbuttons[];
extern CONST BYTE rgReturn[];

extern ATOM atomMDIActivateProp;

#ifdef LAME_BUTTON
extern ATOM gatomLameButton;
#endif
extern ATOM gatomReaderMode;

extern CRITICAL_SECTION gcsLookaside;
extern CRITICAL_SECTION gcsHdc;
extern CRITICAL_SECTION gcsClipboard;
extern CRITICAL_SECTION gcsAccelCache;

#ifdef _JANUS_
extern BOOL gfEMIEnable;
extern DWORD gdwEMIControl;
extern BOOL gfDMREnable;
extern HANDLE gEventSource;
#endif

extern HDC    ghdcBits2;
extern HDC    ghdcGray;
extern HFONT  ghFontSys;
extern HBRUSH ghbrWindowText;
extern int    gcxGray;
extern int    gcyGray;

extern LPWSTR pwcHighContrastScheme;
extern LPSTR  pcHighContrastScheme;


/*
 * LATER: client-side user needs to use moveable memory objects for
 * WOW compatibility (at least until/if/when we copy all the edit control
 * code into 16-bit space);  that's also why we can't just party with
 * handles like LMHtoP does... -JeffPar
 */
#ifndef RC_INVOKED       // RC can't handle #pragmas
#undef  LHND
#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)

#undef  LMHtoP
#define LMHtoP(handle)      // Don't use this macro
#endif

/*
 * WOW HACK - apps can pass a global handle as the hInstance on a call
 * to CreateWindow for an edit control and expect allocations for the
 * control to come out of that global block. (MSJ 1/91 p.122)
 * WOW needs this hInstance during the LocalAlloc callback to set up
 * the DS for the LocalAlloc, so we pass hInstance as an 'extra' parameter.
 * !!! this is dependent on calling convention !!!
 * (SAS 6-18-92) added hack for all macros
 */

#define LOCALALLOC(dwFlags, dwBytes, hInstance)         \
                            (*pfnLocalAlloc)(dwFlags, dwBytes, hInstance)
#define LOCALREALLOC(hMem, dwBytes, dwFlags, hInstance, ppv) \
                            (*pfnLocalReAlloc)(hMem, dwBytes, dwFlags, hInstance, ppv)
#define LOCALLOCK(hMem, hInstance)                      \
                            (*pfnLocalLock)(hMem, hInstance)
#define LOCALUNLOCK(hMem, hInstance)                    \
                            (*pfnLocalUnlock)(hMem, hInstance)
#define LOCALSIZE(hMem, hInstance)                      \
                            (*pfnLocalSize)(hMem, hInstance)
#define LOCALFREE(hMem, hInstance)                      \
                            (*pfnLocalFree)(hMem, hInstance)

extern PFNFINDA             pfnFindResourceExA;
extern PFNFINDW             pfnFindResourceExW;
extern PFNLOAD              pfnLoadResource;
extern PFNLOCK              pfnLockResource;
extern PFNUNLOCK            pfnUnlockResource;
extern PFNFREE              pfnFreeResource;
extern PFNSIZEOF            pfnSizeofResource;
extern PFNLALLOC            pfnLocalAlloc;
extern PFNLREALLOC          pfnLocalReAlloc;
extern PFNLLOCK             pfnLocalLock;
extern PFNLUNLOCK           pfnLocalUnlock;
extern PFNLSIZE             pfnLocalSize;
extern PFNLFREE             pfnLocalFree;
extern PFNGETEXPWINVER      pfnGetExpWinVer;
extern PFN16GALLOC          pfn16GlobalAlloc;
extern PFN16GFREE           pfn16GlobalFree;
extern PFNGETMODFNAME       pfnGetModFileName;
extern PFNEMPTYCB           pfnWowEmptyClipBoard;
extern PFNWOWWNDPROCEX      pfnWowWndProcEx;
extern PFNWOWDLGPROCEX      pfnWowDlgProcEx;
extern PFNWOWEDITNEXTWORD   pfnWowEditNextWord;
extern PFNWOWCBSTOREHANDLE  pfnWowCBStoreHandle;
extern PFNGETPROCMODULE16   pfnWowGetProcModule;
extern PFNWOWTELLWOWTHEHDLG pfnWOWTellWOWThehDlg;
extern PFNWOWMSGBOXINDIRECTCALLBACK pfnWowMsgBoxIndirectCallback;
extern PFNWOWILSTRCMP       pfnWowIlstrcmp;
extern PFNWOWTASK16SCHEDNOTIFY pfnWowTask16SchedNotify;

extern UNICODE_STRING strRootDirectory;

/*
 * UserApiHook
 */
extern BYTE                 grgbDwpLiteHookMsg[(WM_USER + 7) / 8];
extern BYTE                 grgbWndLiteHookMsg[(WM_USER + 7) / 8];
extern BYTE                 grgbDlgLiteHookMsg[(WM_USER + 7) / 8];
extern HMODULE              ghmodUserApiHook;   // the module containing the UserApiHook hooks
extern USERAPIHOOK          guah;               // Dynamic function pointers
extern BOOL                 gfUserApiHook;      // Set TRUE if should use the UAH
extern LONG                 gcCallUserApiHook;  // reference count of ongoing calls to UserApiHook hooks
extern LONG                 gcLoadUserApiHook;  // reference count of UserApiHook module loads
extern RTL_CRITICAL_SECTION gcsUserApiHook;     // CS for UAH DLL load / unload
extern INITUSERAPIHOOK      gpfnInitUserApi;    // UserApiHook callback

#ifdef MESSAGE_PUMP_HOOK

/*
 * MessagePumpHook
 */
extern BOOL                 gfMessagePumpHook;  // Set TRUE if should use the MPH
extern LONG                 gcLoadMPH;          // reference count of MPH Init
extern MESSAGEPUMPHOOK      gmph;               // Dynamic function pointers
extern RTL_CRITICAL_SECTION gcsMPH;             // CS for MPH DLL load / unload
extern INITMESSAGEPUMPHOOK  gpfnInitMPH;        // MessagePumpHook callback

#endif


/*
 * Menu Drag and Drop
 */
extern HINSTANCE ghinstOLE;
extern FARPROC gpfnOLEOleUninitialize;
extern FARPROC gpfnOLERegisterDD;
extern FARPROC gpfnOLERevokeDD;
extern FARPROC gpfnOLEDoDD;

/*
 * Accelerator table resources list.
 */
extern PACCELCACHE gpac;

/*
 * IME Window Handling.
 */
extern DWORD gfConIme;
#define UNKNOWN_CONIME ~0

extern UNICODE_STRING strRootDirectory;

extern BOOL gfLogonProcess;
#if DBG
extern USERDBGGLOBALS gDbgGlobals;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\hsz.c ===
/****************************** Module Header ******************************\
* Module Name: hsz.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* HSZ.C - DDEML String handle functions
*
* History:
* 10-28-91 Sanfords Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* DdeCreateStringHandle (DDEML API)
*
* Description:
* Create an HSZ from a string.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, HSZ, DUMMYCALLINGTYPE, DdeCreateStringHandleA, DWORD, idInst, LPCSTR, psz, int, iCodePage)
HSZ DdeCreateStringHandleA(
DWORD idInst,
LPCSTR psz,
int iCodePage)
{
    if (iCodePage == 0) {
        iCodePage = CP_WINANSI;
    }
    return (InternalDdeCreateStringHandle(idInst, (PVOID)psz, iCodePage));
}



FUNCLOG3(LOG_GENERAL, HSZ, DUMMYCALLINGTYPE, DdeCreateStringHandleW, DWORD, idInst, LPCWSTR, psz, int, iCodePage)
HSZ DdeCreateStringHandleW(
DWORD idInst,
LPCWSTR psz,
int iCodePage)
{
    if (iCodePage == 0) {
        iCodePage = CP_WINUNICODE;
    }
    return (InternalDdeCreateStringHandle(idInst, (PVOID)psz, iCodePage));
}



HSZ InternalDdeCreateStringHandle(
DWORD idInst,
PVOID psz,
int iCodePage)
{
    PCL_INSTANCE_INFO pcii;
    HSZ hszRet = 0;

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    switch (iCodePage) {
    case CP_WINANSI:
        if (*(LPSTR)psz == '\0') {
            goto Exit;
        }
        hszRet = NORMAL_HSZ_FROM_LATOM(AddAtomA((LPSTR)psz));
        break;

    case CP_WINUNICODE:
        if (*(LPWSTR)psz == L'\0') {
            goto Exit;
        }
        hszRet = NORMAL_HSZ_FROM_LATOM(AddAtomW((LPWSTR)psz));
        break;
    
    default:
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        break;
    }
    MONHSZ(pcii, hszRet, MH_CREATE);

Exit:
    LeaveDDECrit;
    return (hszRet);
}



/***************************************************************************\
* DdeQueryString (DDEML API)
*
* Description:
* Recall the string associated with an HSZ.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG5(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, DdeQueryStringA, DWORD, idInst, HSZ, hsz, LPSTR, psz, DWORD, cchMax, INT, iCodePage)
DWORD DdeQueryStringA(
DWORD idInst,
HSZ hsz,
LPSTR psz,
DWORD cchMax,
INT iCodePage)
{
    if (iCodePage == 0) {
        iCodePage = CP_WINANSI;
    }
    return (InternalDdeQueryString(idInst, hsz, psz, cchMax, iCodePage));
}



FUNCLOG5(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, DdeQueryStringW, DWORD, idInst, HSZ, hsz, LPWSTR, psz, DWORD, cchMax, INT, iCodePage)
DWORD DdeQueryStringW(
DWORD idInst,
HSZ hsz,
LPWSTR psz,
DWORD cchMax,
INT iCodePage)
{
    if (iCodePage == 0) {
        iCodePage = CP_WINUNICODE;
    }
    return (InternalDdeQueryString(idInst, hsz, psz, cchMax * sizeof(WCHAR), iCodePage));
}


DWORD InternalDdeQueryString(
DWORD idInst,
HSZ hsz,
PVOID psz,
DWORD cbMax,
INT iCodePage)
{
    PCL_INSTANCE_INFO pcii;
    DWORD dwRet = 0;
    WCHAR szw[256];
// BOOL fDefUsed; // LATER

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (ValidateHSZ(hsz) == HSZT_INVALID) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (LATOM_FROM_HSZ(hsz) == 0) {
        if (iCodePage == CP_WINUNICODE) {
            if (psz != NULL) {
                *(LPWSTR)psz = L'\0';
            }
            dwRet = sizeof(WCHAR);
            goto Exit;
        } else {
            if (psz != NULL) {
                *(LPSTR)psz = '\0';
            }
            dwRet = sizeof(CHAR);
            goto Exit;
        }
    }

    if (psz == NULL) {
        cbMax = sizeof(szw);
        psz = (PVOID)szw;
    }

    switch (iCodePage) {
    case CP_WINANSI:
        dwRet = GetAtomNameA(LATOM_FROM_HSZ(hsz), psz, cbMax);
        break;

    default:
        dwRet = GetAtomNameW(LATOM_FROM_HSZ(hsz), (LPWSTR)psz, cbMax / sizeof(WCHAR));
        if (iCodePage != CP_WINUNICODE) {

            /*
             * convert psz to the appropriate codepage and count the
             * characters(ie BYTES for DBCS!) to alter dwRet.
             */
#ifdef LATER
            // Does this routine work in place? (i.e. input and output buffer the same).
            WideCharToMultiByte((UINT)iCodePage, 0, szw,
                    sizeof(szw) /  sizeof(WCHAR),
                    (LPSTR)psz, cbMax, NULL, &fDefUsed);
#endif
            dwRet = cbMax + 1;
        }
        break;
    }

Exit:
    LeaveDDECrit;
    return (dwRet);
}



/***************************************************************************\
* DdeFreeStringHandle (DDEML API)
*
* Description:
* Decrement the use count of an HSZ.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeFreeStringHandle, DWORD, idInst, HSZ, hsz)
BOOL DdeFreeStringHandle(
DWORD idInst,
HSZ hsz)
{
    PCL_INSTANCE_INFO pcii;
    BOOL fRet = FALSE;

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (ValidateHSZ(hsz) == HSZT_INVALID) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    MONHSZ(pcii, hsz, MH_DELETE);
    fRet = TRUE;
    if (LATOM_FROM_HSZ(hsz) != 0) {
        if (DeleteAtom(LATOM_FROM_HSZ(hsz))) {
            SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
            fRet = FALSE;
        }
    }

Exit:
    LeaveDDECrit;
    return (fRet);
}



/***************************************************************************\
* DdeKeepStringHandle (DDEML API)
*
* Description:
* Increments the use count of an HSZ.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeKeepStringHandle, DWORD, idInst, HSZ, hsz)
BOOL DdeKeepStringHandle(
DWORD idInst,
HSZ hsz)
{
    PCL_INSTANCE_INFO pcii;
    BOOL fRet = FALSE;

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (ValidateHSZ(hsz) == HSZT_INVALID) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    if (LATOM_FROM_HSZ(hsz) == 0) {
        fRet = TRUE;
        goto Exit;
    }
    MONHSZ(pcii, hsz, MH_KEEP);
    fRet = IncLocalAtomCount(LATOM_FROM_HSZ(hsz)) ? TRUE : FALSE;

Exit:
    LeaveDDECrit;
    return (fRet);
}



/***************************************************************************\
* DdeCmpStringHandles (DDEML API)
*
* Description:
* Useless comparison of hszs. Provided for case sensitivity expandability.
* Direct comparison of hszs would be a case sensitive comparison while
* using this function would be case-insensitive. For now both ways are ==.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, int, DUMMYCALLINGTYPE, DdeCmpStringHandles, HSZ, hsz1, HSZ, hsz2)
int DdeCmpStringHandles(
HSZ hsz1,
HSZ hsz2)
{
    if (hsz2 > hsz1) {
        return (-1);
    } else if (hsz2 < hsz1) {
        return (1);
    } else {
        return (0);
    }
}


/***************************************************************************\
* ValidateHSZ
*
* Description:
* Verifies the probability of a reasonable hsz
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
DWORD ValidateHSZ(
HSZ hsz)
{
    if (hsz == 0) {
        return (HSZT_NORMAL);
    }
    if (LOWORD((ULONG_PTR)hsz) < 0xC000) {
        return (HSZT_INVALID);
    }
    if (HIWORD((ULONG_PTR)hsz) == 0) {
        return (HSZT_NORMAL);
    }
    if (HIWORD((ULONG_PTR)hsz) == 1) {
        return (HSZT_INST_SPECIFIC);
    }
    return (HSZT_INVALID);
}

/***************************************************************************\
* MakeInstSpecificAtom
*
* Description:
* Creates a new atom that has hwnd imbeded into it.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
LATOM MakeInstSpecificAtom(
LATOM la,
HWND hwnd)
{
    WCHAR sz[256];
    LPWSTR psz;

    if (GetAtomName(la, sz, 256) == 0) {
        return (0);
    }
#ifdef UNICODE
    psz = sz + wcslen(sz);
#else
    psz = sz + strlen(sz);
#endif
    wsprintf(psz, TEXT("(%#p)"), hwnd);
    la = AddAtom(sz);
    return (la);
}



/***************************************************************************\
* ParseInstSpecificAtom
*
* Description:
* Extracts the hwnd value out of the atom.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
HWND ParseInstSpecificAtom(
LATOM la,
LATOM *plaNormal)
{
    CHAR sz[256];
    LPSTR pszHwnd;
    HWND hwnd;

    /*
     * LATER- NEED TO MAKE THIS UNICODE BASED WHEN WE GET A SCANF WE CAN USE
     */
    if (GetAtomNameA(la, sz, 256) == 0) {
        return (0);
    }
    pszHwnd = strrchr(sz, '(');
    if (pszHwnd == NULL) {
        return (0);
    }
    if (sscanf(pszHwnd, "(%#p)", &hwnd) != 1) {
        return (0);
    }
    if (plaNormal != NULL) {
        *pszHwnd = '\0';
        *plaNormal = AddAtomA(sz);
    }
    return (hwnd);
}




/***************************************************************************\
* LocalToGlobalAtom
*
* Description:
* Converts a Local Atom to a Global Atom
*
* History:
* 12-1-91 sanfords Created.
\***************************************************************************/
GATOM LocalToGlobalAtom(
LATOM la)
{
    WCHAR sz[256];

    if (la == 0) {
        return (0);
    }
    if (GetAtomName((ATOM)la, sz, 256) == 0) {
        RIPMSG0(RIP_WARNING, "LocalToGlobalAtom out of memory");
        return (0);
    }
    return ((GATOM)GlobalAddAtom(sz));
}



/***************************************************************************\
* GlobalToLocalAtom
*
* Description:
* Converts a Global Atom to a Local Atom
*
* History:
* 12-1-91 sanfords Created.
\***************************************************************************/
LATOM GlobalToLocalAtom(
GATOM ga)
{
    WCHAR sz[256];

    if (ga == 0) {
        return (0);
    }
    if (GlobalGetAtomName((ATOM)ga, sz, 256) == 0) {
        RIPMSG0(RIP_WARNING, "GlobalToLocalAtom out of memory");
        return (0);
    }
    return ((LATOM)AddAtom(sz));
}


/***************************************************************************\
* IncGlobalAtomCount
*
* Description:
* Duplicates an atom.
*
*
* History:
* 1-22-91 sanfords Created.
\***************************************************************************/
GATOM IncGlobalAtomCount(
GATOM ga)
{
    WCHAR sz[256];

    if (ga == 0) {
        return (0);
    }
    if (GlobalGetAtomName(ga, sz, 256) == 0) {
        RIPMSG0(RIP_WARNING, "IncGlobalAtomCount out of memory");
        return (0);
    }
    return ((GATOM)GlobalAddAtom(sz));
}


/***************************************************************************\
* IncGlobalAtomCount
*
* Description:
* Duplicates an atom.
*
*
* History:
* 1-22-91 sanfords Created.
\***************************************************************************/
LATOM IncLocalAtomCount(
LATOM la)
{
    WCHAR sz[256];

    if (la == 0) {
        return (0);
    }
    if (GetAtomName(la, sz, 256) == 0) {
        RIPMSG0(RIP_WARNING, "IncLocalAtomCount out of memory");
        return (0);
    }
    return ((LATOM)AddAtom(sz));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\help.c ===
/**************************************************************************\
* Module Name: help.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 23-May-95 BradG   Created to consolidate client-side help routines.
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define MAX_ATTEMPTS    5       // maximum -1 id controls to search through
char szDefaultHelpFileA[] = "windows.hlp";

CONST WCHAR szEXECHELP[] = TEXT("\\winhlp32.exe");
CONST WCHAR szMS_WINHELP[] =     L"MS_WINHELP";    // Application class
CONST WCHAR szMS_POPUPHELP[] =   L"MS_POPUPHELP";  // Popup class
CONST WCHAR szMS_TCARDHELP[] =   L"MS_TCARDHELP";  // Training card class

CONST WCHAR gawcWinhelpFlags[] = {
    L'x',     // Execute WinHelp as application help
    L'p',     // Execute WinHelp as a popup
    L'c',     // Execute WinHelp as a training card
};


/***************************************************************************\
* SendWinHelpMessage
*
* Attempts to give the winhelp process the right to take the foreground (it
* will fail if the calling processs doesn't have the right itself). Then it
* sends the WM_WINHELP message.
*
* History:
* 02-10-98 GerardoB     Created
\***************************************************************************/
LRESULT SendWinHelpMessage(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam)
{
    DWORD dwProcessId = 0;

    GetWindowThreadProcessId(hwnd, &dwProcessId);
    AllowSetForegroundWindow(dwProcessId);

    return SendMessage(hwnd, WM_WINHELP, wParam, lParam);
}

/***************************************************************************\
* HFill
*
* Builds a data block for communicating with help
*
* LATER 13 Feb 92 GregoryW
* This needs to stay ANSI until we have a Unicode help engine
*
* History:
* 04-15-91 JimA Ported.
* 03-24-95 BradG - YAP of Win95 code.  Added code to prevent memory
*                  overwrite on bad ulData == 0 parameter.
\***************************************************************************/
LPHLP HFill(
    LPCSTR lpszHelp,
    DWORD  ulCommand,        // HELP_ constant
    ULONG_PTR ulData)
{
    DWORD   cb;     // Size of the data block
    DWORD   cbStr;  // Length of the help file name
    DWORD   cbData; // Size of the dwData parameter in bytes (0 if not used)
    LPHLP   phlp;   // Pointer to data block
    BYTE    bType;  // dwData parameter type

    /*
     * Get the length of the help file name
     */
    cbStr = (lpszHelp) ? strlen(lpszHelp) + 1 : 0;

    /*
     * Get the length of any dwData parameters
     */
    bType = HIBYTE(LOWORD(ulCommand));
    if (ulData) {
        switch (bType) {
        case HIBYTE(HELP_HB_STRING):
            /*
             * ulData is an ANSI string, so compute its length
             */
            cbData = strlen((LPSTR)ulData) + 1;
            break;

        case HIBYTE(HELP_HB_STRUCT):
            /*
             * ulData points to a structure who's first member is an int
             * that contains the size of the structure in bytes.
             */
            cbData = *((int *)ulData);
            break;

        default:
            /*
             * dwData has no parameter.
             */
            cbData = 0;
        }
    } else {
        /*
         * No parameter is present.
         */
        cbData = 0;
    }

    /*
     * Calculate size.
     */
    cb = sizeof(HLP) + cbStr + cbData;

    /*
     * Get data block.
     */
    if ((phlp = (LPHLP)UserLocalAlloc(HEAP_ZERO_MEMORY, cb)) == NULL) {
        return NULL;
    }

    /*
     * Fill in info.
     */
    phlp->cbData = (WORD)cb;
    phlp->usCommand = (WORD)ulCommand;

    /*
     * Fill in file name.
     */
    if (lpszHelp) {
        phlp->offszHelpFile = sizeof(HLP);
        strcpy((LPSTR)(phlp + 1), lpszHelp);
    }

    /*
     * Fill in data
     */
    switch (bType) {
    case HIBYTE(HELP_HB_STRING):
        if (cbData) {
            phlp->offabData = (WORD)(sizeof(HLP) + cbStr);
            strcpy((LPSTR)phlp + phlp->offabData, (LPSTR)ulData);
        }
        break;

    case HIBYTE(HELP_HB_STRUCT):
        if (cbData) {
            phlp->offabData = (WORD)(sizeof(HLP) + cbStr);
            RtlCopyMemory((LPBYTE)phlp + phlp->offabData,
                          (PVOID)ulData,
                          *((int*)ulData));
        }
        break;

    default:
        phlp->ulTopic = ulData;
        break;
    }

    return phlp;
}

/***************************************************************************\
* LaunchHelp
*
* This function launches the WinHlp32 executable with the correct command
* line arguments.
*
* History:
* 03/23/1995 BradG     YAP of new changes from Win95
* 03/01/2002 JasonSch  Changed to only look for winhlp32.exe in %windir%.
\***************************************************************************/
BOOL LaunchHelp(
    DWORD dwType)
{
    WCHAR *pwszPath, wszCommandLine[16];
    BOOL bRet;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    ULONG cChars;

    /*
     * Return value of GetSystemWindowsDirectory does not include the
     * terminating NULL, so + 1.
     */
    cChars = GetSystemWindowsDirectoryW(NULL, 0) + 1;
    pwszPath = UserLocalAlloc(0, (cChars + ARRAY_SIZE(szEXECHELP)) * sizeof(WCHAR));
    if (pwszPath == NULL) {
        return FALSE;
    }

    GetSystemWindowsDirectoryW(pwszPath, cChars);
    wcscat(pwszPath, szEXECHELP);
    wsprintf(wszCommandLine, L"%ws -%wc", szEXECHELP + 1, gawcWinhelpFlags[dwType]);

    /*
     * Launch winhelp.
     */
    RtlZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.wShowWindow = SW_SHOW;
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_FORCEONFEEDBACK;

    bRet = CreateProcessW(pwszPath,
                          wszCommandLine,
                          NULL,
                          NULL,
                          FALSE,
                          NORMAL_PRIORITY_CLASS,
                          NULL,
                          NULL,
                          &StartupInfo,
                          &ProcessInformation);
    if (bRet) {
        WaitForInputIdle(ProcessInformation.hProcess, 10000);
        NtClose(ProcessInformation.hProcess);
        NtClose(ProcessInformation.hThread);
    }

    UserLocalFree(pwszPath);

    return bRet;
}


/***************************************************************************\
* GetNextDlgHelpItem
*
* This is a reduced version of the GetNextDlgTabItem function that does not
* skip disabled controls.
*
* History:
* 3/25/95 BradG     Ported from Win95
\***************************************************************************/
PWND GetNextDlgHelpItem(
    PWND pwndDlg,
    PWND pwnd)
{
    PWND pwndSave;

    if (pwnd == pwndDlg) {
        pwnd = NULL;
    } else {
        pwnd = _GetChildControl(pwndDlg, pwnd);
        if (pwnd) {
            if (!_IsDescendant(pwndDlg, pwnd))
                return NULL;
        }
    }

    /*
     *  BACKWARD COMPATIBILITY
     *
     *  Note that the result when there are no tabstops of
     *  IGetNextDlgTabItem(hwndDlg, NULL, FALSE) was the last item, now
     *  will be the first item.  We could put a check for fRecurse here
     *  and do the old thing if not set.
     */

    /*
     *  We are going to bug out if we hit the first child a second time.
     */
    pwndSave = pwnd;
    pwnd = _NextControl(pwndDlg, pwnd, CWP_SKIPINVISIBLE);

    while ((pwnd != pwndSave) && (pwnd != pwndDlg))
    {
        UserAssert(pwnd);

        if (!pwndSave)
            pwndSave = pwnd;

        if ((pwnd->style & (WS_TABSTOP | WS_VISIBLE))  == (WS_TABSTOP | WS_VISIBLE))
            /*
             *  Found it.
             */
            break;

        pwnd = _NextControl(pwndDlg, pwnd, CWP_SKIPINVISIBLE);
    }

    return pwnd;
}


/***************************************************************************\
* HelpMenu
*
* History:
* 01-Feb-1994 mikeke    Ported.
\***************************************************************************/
UINT HelpMenu(
    HWND hwnd,
    PPOINT ppt)
{
    INT     cmd;
    HMENU   hmenu = LoadMenu( hmodUser, MAKEINTRESOURCE(ID_HELPMENU));

    if (hmenu != NULL) {
        cmd = TrackPopupMenu( GetSubMenu(hmenu, 0),
              TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON,
              ppt->x, ppt->y, 0, hwnd, NULL);
        NtUserDestroyMenu(hmenu);
        return cmd;
    }

    return (UINT)-1;
}

/***************************************************************************\
* FindWinHelpWindow
*
* This function attempts to locate the help window.  If it fails, it attempts
* to launch WinHlp32.exe and then look for its window.
*
* History:
* 03/24/95 BradG   Created by extracting code from xxxWinHelpA
\***************************************************************************/
HWND FindWinHelpWindow(
    LPCWSTR lpwstrHelpWindowClass,
    DWORD   dwType,
    BOOL    bLaunchIt)
{
    HWND    hwndHelp;

    /*
     * Find the current help window. If not found, try and launch
     * the WinHlp32 application. We are interested only in 32 bit help.
     *
     * Note that 16 bit apps don't walk this path, ntvdm takes care of
     * starting the 16 bit help for them.
     */
    hwndHelp = InternalFindWindowExW(NULL, NULL, lpwstrHelpWindowClass, NULL, FW_32BIT);

    if (hwndHelp == NULL) {
        if (bLaunchIt) {
            /*
             * Can't find it --> see if we want to launch it.
             */
            if (LaunchHelp(dwType) == FALSE ||
                (hwndHelp = FindWindowW(lpwstrHelpWindowClass, NULL)) == NULL) {
                /*
                 * Can't find help, or not enough memory to load help.
                 * hwndHelp will be NULL at this point.
                 */
                RIPMSG0(RIP_WARNING, "LaunchHelp or FindWindow failed.");
            }
        }
    }

    return hwndHelp;
}


/*
 *  HWND version of Enumeration function to find controls while
 *  ignoring group boxes but not disabled controls.
 */
BOOL CALLBACK EnumHwndDlgChildProc(
    HWND hwnd,
    LPARAM lParam)
{
    PWND pwnd;
    BOOL bResult;

    if (pwnd = ValidateHwnd(hwnd)) {
        bResult = EnumPwndDlgChildProc(pwnd, lParam);
    } else {
        bResult = TRUE;
    }

    return bResult;
}


/***************************************************************************\
* WinHelp
*
* Displays help
*
* History:
* 04-15-91 JimA             Ported.
* 01-29-92 GregoryW         Neutral version.
* 05-22-92 SanfordS         Added support for help structures
* 03-24-95 BradG            Moved from Client side WinHelpA to server side
*                           xxxWinHelpA because of changes in Win95. The
*                           function xxxServerWinHelp was merged.
\***************************************************************************/
BOOL WinHelpA(
    HWND hwnd,
    LPCSTR lpszHelp,
    UINT uCommand,
    ULONG_PTR dwData)
{
    LPCWSTR lpwstrHelpWindowClass;
    LPHLP lpHlp = NULL;
    DWORD dwType;
    PWND pwnd;
    HWND hwndHelp = NULL;    /* Handle of help's main window         */
    PWND pwndTop = NULL;     /* Top level window that WinHelp uses.  */
    PWND pwndMain;           /* pointer to main help control         */
    LRESULT lResult;
    POINT ptCur;
    BOOL bResult = TRUE;

    pwnd = ValidateHwnd(hwnd);

    if (uCommand & HELP_TCARD) {
        /*
         * For Training Cards, the HELP_TCARD bit is set.  We need to
         * set our help window class to szMS_TCARDHELP and then remove
         * the HELP_TCARD bit.
         */
        lpwstrHelpWindowClass = szMS_TCARDHELP;
        uCommand &= ~HELP_TCARD;    // mask out the tcard flag
        dwType = TYPE_TCARD;
    } else {
        if (uCommand == HELP_CONTEXTMENU || uCommand == HELP_CONTEXTPOPUP ||
            uCommand == HELP_SETPOPUP_POS || uCommand == HELP_WM_HELP) {
            /*
             * Popups should be connected to a valid window.  pwndMain has
             * already been validated as a real window handle or NULL, so we
             * just need to check the NULL case here.
             */
            if (pwnd == NULL) {
                RIPERR1(ERROR_INVALID_PARAMETER,
                        RIP_WARNING,
                        "WinHelpA: NULL hWnd invalid for this type of help command (0x%x)",
                        uCommand);

                bResult = FALSE;
                goto Exit_WinHelp;
            }
            dwType = TYPE_POPUP;
            lpwstrHelpWindowClass = szMS_POPUPHELP;
        } else {
            dwType = TYPE_NORMAL;
            lpwstrHelpWindowClass = szMS_WINHELP;
        }
    }

    /*
     * Get the cursor's current location  This is where we assume the user
     * clicked.  We will use this position to search for a child window and
     * to set the context sensitive help popup window's location.
     *
     * If the last input was a keyboard one, use the point in the center
     * of the focus window rectangle. MCostea #249270
     */
    if (TEST_SRVIF(SRVIF_LASTRITWASKEYBOARD)) {
        HWND hWndFocus = GetFocus();
        RECT rcWindow;

        if (GetWindowRect(hWndFocus, &rcWindow)) {
            ptCur.x = (rcWindow.left + rcWindow.right)/2;
            ptCur.y = (rcWindow.top + rcWindow.bottom)/2;
        } else {
            goto getCursorPos;
        }
    } else {
getCursorPos:
        GetCursorPos(&ptCur);
    }

    /*
     * If we are handling the HELP_CONTEXTMENU command, see if we
     * can determine the correct child window.
     */
    if (uCommand == HELP_CONTEXTMENU && FIsParentDude(pwnd)) {
        LONG        lPt;
        int         nHit;
        DLGENUMDATA DlgEnumData;

        /*
         *  If the user really clicked on the caption or the system menu,
         *  then we want the context menu for the window, not help for a
         *  control.  This makes it consistent across all 3.x and 4.0
         *  windows.
         */
        lPt = MAKELONG(ptCur.x,ptCur.y);
        nHit = FindNCHit(pwnd, lPt);
        if ((nHit == HTCAPTION) || (nHit == HTSYSMENU))
            DefWindowProc(hwnd, WM_CONTEXTMENU, (WPARAM)hwnd, lPt);

        /*
         * If this is a dialog class, then one of three things has
         * happened:
         *
         *  o   This is a disabled control
         *  o   This is a static text control
         *  o   This is the background of the dialog box.
         *
         * What we do is enumerate the child windows and see if
         * any of them contain the current cursor point. If they do,
         * change our window handle and continue on. Otherwise,
         * return doing nothing -- we don't want context-sensitive
         * help for a dialog background.
         *
         * If this is a group box, then we might have clicked on a
         * disabled control, so we enumerate child windows to see
         * if we get another control.
         */
        DlgEnumData.pwndDialog = pwnd;
        DlgEnumData.pwndControl = NULL;
        DlgEnumData.ptCurHelp = ptCur;
        EnumChildWindows(hwnd, (WNDENUMPROC)EnumHwndDlgChildProc, (LPARAM)&DlgEnumData);
        if (DlgEnumData.pwndControl == NULL) {
            /*
             * Can't find a control, so nothing to do.
             */
            goto Exit_WinHelp;
        } else {
            /*
             * Remember this control because it will be used as the
             * control for context sensitive help.
             */
            pwndMain = DlgEnumData.pwndControl;
        }
    } else {
        /*
         * We will use pwnd as our main control.  No need to lock it
         * because it is already locked.
         */
        pwndMain = pwnd;
    }

    /*
     * For HELP_CONTEXTPOPUP and HELP_WM_HELP, see if we can derive the
     * context id by looking at the array of double word ID pairs that
     * have been passed in in dwData.
     */
    if (uCommand == HELP_CONTEXTMENU || uCommand == HELP_WM_HELP) {
        int     id;
        int     i;
        LPDWORD pid;

        /*
         * Be careful about the cast below.  We need the ID, which is stored
         * in the LOWORD of spmenu to be sign extended to an int.
         * Don't sign extend so IDs like 8008 work
         */
        id = (DWORD)(PTR_TO_ID(pwndMain->spmenu));   // get control id
        pid = (LPDWORD) dwData;

        /*
         * Is the control's ID -1?
         */
        if ((SHORT)id == -1) {
            /*
             * This is a static (i.e., ID'less) control
             */
            PWND pwndCtrl;
            int cAttempts = 0;

            /*
             * If the control is a group box, with an ID of -1, bail out
             * as the UI specs decided to have no context help
             * for these cases.  MCostea
             */
            if ((TestWF(pwndMain, BFTYPEMASK) == BS_GROUPBOX) &&
                IS_BUTTON(pwndMain)) {
                goto Exit_WinHelp;
            }

            /*
             * For non-id controls (typically static controls), step
             * through to the next tab item. Keep finding the next tab
             * item until we find a valid id, or we have tried
             * MAX_ATTEMPTS times.
             */
            do {
                pwndCtrl = GetNextDlgHelpItem(REBASEPWND(pwndMain,spwndParent), pwndMain);

                /*
                 * pwndCtrl will be NULL if hwndMain doesn't have a parent,
                 * or if there are no tab stops.
                 */
                if (!pwndCtrl) {
                    /*
                     * Remember to unlock the control
                     */
                    bResult = FALSE;
                    goto Exit_WinHelp;
                }

                /*
                 * Be careful about the cast below.  We need the ID, which is
                 * stored in the LOWORD of spmenu to be sign extended to an int.
                 * Don't sign extend so IDs like 8008 work
                 */
                id = (DWORD)(PTR_TO_ID(pwndCtrl->spmenu));

            } while (((SHORT)id == -1) && (++cAttempts < MAX_ATTEMPTS));
        }

        if ((SHORT)id == -1) {
            id = -1;
        }

        /*
         * Find the id value in array of id/help context values
         */
        for (i = 0; pid[i]; i += 2) {
            if ((int)pid[i] == id) {
                break;
            }
        }

        /*
         * Since no help was specified for the found control, see if
         * the control is one of the known ID (i.e., OK, Cancel...)
         */
        if (!pid[i]) {
            /*
             * Help for the standard controls is in the default
             * help file windows.hlp.  Switch to this file.
             */
            lpszHelp = szDefaultHelpFileA;

            switch (id) {
            case IDOK:
                dwData = IDH_OK;
                break;

            case IDCANCEL:
                dwData = IDH_CANCEL;
                break;

            case IDHELP:
                dwData = IDH_HELP;
                break;

            default:
                /*
                 * Unknown control, give a generic missing context info
                 * popup message in windows.hlp.
                 */
                dwData = IDH_MISSING_CONTEXT;
            }
        } else {
            dwData = pid[i + 1];
            if (dwData == (DWORD)-1) {
                /*
                 * Remember, to unlock the control
                 */
                goto Exit_WinHelp;     // caller doesn't want help after all
            }
        }

        /*
         * Now that we know the caller wants help for this control, display
         * the help menu.
         */
        if (uCommand == HELP_CONTEXTMENU) {
            int cmd;

            cmd = HelpMenu(HW(pwndMain), &ptCur);
            if (cmd <= 0) {
                /*
                 * Probably means user cancelled the menu.
                 */
                goto Exit_WinHelp;
            }
        }

        /*
         * Create WM_WINHELP's HLP data structure for HELP_SETPOPUP_POS
         */
        if (!(lpHlp = HFill(lpszHelp, HELP_SETPOPUP_POS,
                MAKELONG(pwndMain->rcWindow.left, pwndMain->rcWindow.top)))) {
            bResult = FALSE;
            goto Exit_WinHelp;
        }

        /*
         * Tell WinHelp where to put the popup.  This is different than Win95
         * because we try and avoid a recursive call here.  So, we find the
         * WinHlp32 window and send the HELP_SETPOPUP_POS.  No recursion.
         */
        hwndHelp = FindWinHelpWindow(lpwstrHelpWindowClass, dwType, TRUE);
        if (hwndHelp == NULL) {
            /*
             * Uable to communicate with WinHlp32.exe.
             * Remember to unlock the control
             */
            bResult = FALSE;
            goto Exit_WinHelp;
        }

        /*
         * Send the WM_WINHELP message to WinHlp32's window.
         */
        lResult = SendWinHelpMessage(hwndHelp, (WPARAM)HW(pwndMain), (LPARAM)lpHlp);
        UserLocalFree(lpHlp);
        lpHlp = NULL;

        if (!lResult) {
            /*
             * WinHlp32 couldn't process the command. Bail out!
             */
            bResult = FALSE;
            goto Exit_WinHelp;
        }

        /*
         * Make HELP_WM_HELP and HELP_CONTEXTMENU act like HELP_CONTEXTPOPUP
         */
        uCommand = HELP_CONTEXTPOPUP;
    }


    if (uCommand == HELP_CONTEXTPOPUP) {
        /*
         * If no help file was specified, use windows.hlp
         */
        if (lpszHelp == NULL || *lpszHelp == '\0') {
            lpszHelp = szDefaultHelpFileA;  // default: use windows.hlp
        }

        /*
         * WINHELP.EXE will call SetForegroundWindow on the hwnd that we pass
         * to it below. We really want to pass the parent dialog hwnd of the
         * control so that focus will properly be restored to the dialog and
         * not the control that wants help.
         */
        pwndTop = GetTopLevelWindow(pwndMain);
    } else {
        pwndTop = pwndMain;
    }


    /*
     * Move Help file name to a handle.
     */
    if (!(lpHlp = HFill(lpszHelp, uCommand, dwData))) {
        /*
         * Can't allocate memory.
         */
        bResult = FALSE;
        goto Exit_WinHelp;
    }

    /*
     * Get a pointer to the help window.
     */
    hwndHelp = FindWinHelpWindow(lpwstrHelpWindowClass,
                                 dwType,
                                 (uCommand != HELP_QUIT));
    if (hwndHelp == NULL) {
        if (uCommand != HELP_QUIT)
            /*
             * Can't find Winhlp.
             */
            bResult = FALSE;
        goto Exit_WinHelp;
    }

    /*
     * Send the WM_WINHELP message to WinHlp32's window
     * Must ThreadLock pwndHelp AND pwndMain (because pwndMain may have been
     * reassigned above).
     */
    SendWinHelpMessage(hwndHelp, (WPARAM)HW(pwndTop), (LPARAM)lpHlp);

    /*
     * Free the help info data structure (if not already free).
     */
Exit_WinHelp:
    if (lpHlp != NULL) {
        UserLocalFree(lpHlp);
    }

    return bResult;
}


/***************************************************************************\
* WinHelpW
*
* Calls WinHelpA after doing any necessary translation. Our help engine is
* ASCII only.
\***************************************************************************/
BOOL WinHelpW(
    HWND hwndMain,
    LPCWSTR lpwszHelp,
    UINT uCommand,
    ULONG_PTR dwData)
{
    BOOL fSuccess = FALSE;
    LPSTR lpAnsiHelp = NULL;
    LPSTR lpAnsiKey = NULL;
    PMULTIKEYHELPA pmkh = NULL;
    PHELPWININFOA phwi = NULL;
    NTSTATUS Status;

    /*
     * First convert the string.
     */
    if (lpwszHelp != NULL && !WCSToMB(lpwszHelp, -1, &lpAnsiHelp, -1, TRUE)) {
        return FALSE;
    }

    /*
     * Then convert dwData if needed
     */
    switch (uCommand) {
    case HELP_MULTIKEY:
        if (!WCSToMB(((PMULTIKEYHELPW)dwData)->szKeyphrase, -1, &lpAnsiKey,
                -1, TRUE)) {
            goto FreeAnsiHelp;
        }

        pmkh = UserLocalAlloc(HEAP_ZERO_MEMORY,
                              sizeof(MULTIKEYHELPA) + strlen(lpAnsiKey));
        if (pmkh == NULL) {
            goto FreeAnsiKeyAndHelp;
        }

        pmkh->mkSize = sizeof(MULTIKEYHELPA) + strlen(lpAnsiKey);
        Status = RtlUnicodeToMultiByteN((LPSTR)&pmkh->mkKeylist, sizeof(CHAR),
                NULL, (LPWSTR)&((PMULTIKEYHELPW)dwData)->mkKeylist,
                sizeof(WCHAR));
        strcpy(pmkh->szKeyphrase, lpAnsiKey);
        if (!NT_SUCCESS(Status)) {
            goto FreeAnsiKeyAndHelp;
        }

        dwData = (ULONG_PTR)pmkh;
        break;

    case HELP_SETWINPOS:
        if (!WCSToMB(((PHELPWININFOW)dwData)->rgchMember, -1, &lpAnsiKey,
                -1, TRUE)) {
            goto FreeAnsiKeyAndHelp;
        }

        phwi = UserLocalAlloc(HEAP_ZERO_MEMORY,
                              ((PHELPWININFOW)dwData)->wStructSize);
        if (phwi == NULL) {
            goto FreeAnsiKeyAndHelp;
        }

        *phwi = *((PHELPWININFOA)dwData);   // copies identical parts
        strcpy(phwi->rgchMember, lpAnsiKey);
        dwData = (ULONG_PTR)phwi;
        break;

    case HELP_KEY:
    case HELP_PARTIALKEY:
    case HELP_COMMAND:
        if (!WCSToMB((LPCTSTR)dwData, -1, &lpAnsiKey, -1, TRUE)) {
            goto FreeAnsiKeyAndHelp;
        }

        dwData = (ULONG_PTR)lpAnsiKey;
        break;
    }

    /*
     * Call the Ansi version
     */
    fSuccess = WinHelpA(hwndMain, lpAnsiHelp, uCommand, dwData);

    if (pmkh) {
        UserLocalFree(pmkh);
    }

    if (phwi) {
        UserLocalFree(phwi);
    }

FreeAnsiKeyAndHelp:
    if (lpAnsiKey) {
        UserLocalFree(lpAnsiKey);
    }


FreeAnsiHelp:
    if (lpAnsiHelp) {
        UserLocalFree(lpAnsiHelp);
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\imectl.c ===
/**************************************************************************\
* Module Name: imectl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IME Window Handling Routines
*
* History:
* 20-Dec-1995 wkwok
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <intlshar.h>

#define LATE_CREATEUI 1

CONST WCHAR szIndicDLL[] = L"indicdll.dll";

FARPROC gpfnGetIMEMenuItemData = NULL;
BOOL IMEIndicatorGetMenuIDData(PUINT puMenuID, PDWORD pdwData);

/*
 * Local Routines.
 */
LONG ImeWndCreateHandler(PIMEUI, LPCREATESTRUCT);
void ImeWndDestroyHandler(PIMEUI);
LRESULT ImeSystemHandler(PIMEUI, UINT, WPARAM, LPARAM);
LONG ImeSelectHandler(PIMEUI, UINT, WPARAM, LPARAM);
LRESULT ImeControlHandler(PIMEUI, UINT, WPARAM, LPARAM, BOOL);
LRESULT ImeSetContextHandler(PIMEUI, UINT, WPARAM, LPARAM);
LRESULT ImeNotifyHandler(PIMEUI, UINT, WPARAM, LPARAM);
HWND CreateIMEUI(PIMEUI, HKL);
VOID DestroyIMEUI(PIMEUI);
LRESULT SendMessageToUI(PIMEUI, UINT, WPARAM, LPARAM, BOOL);
VOID SendOpenStatusNotify(PIMEUI, HWND, BOOL);
VOID ImeSetImc(PIMEUI, HIMC);
VOID FocusSetIMCContext(HWND, BOOL);
BOOL ImeBroadCastMsg(PIMEUI, UINT, WPARAM, LPARAM);
VOID ImeMarkUsedContext(HWND, HIMC);
BOOL ImeIsUsableContext(HWND, HIMC);
BOOL GetIMEShowStatus(void);

/*
 * Common macros for IME UI, HKL and IMC handlings
 */
#define GETHKL(pimeui)        (KHKL_TO_HKL(pimeui->hKL))
#define SETHKL(pimeui, hkl)   (pimeui->hKL=(hkl))
#define GETIMC(pimeui)        (KHIMC_TO_HIMC(pimeui->hIMC))
#define SETIMC(pimeui, himc)  (ImeSetImc(pimeui, KHIMC_TO_HIMC(himc)))
#define GETUI(pimeui)         (KHWND_TO_HWND(pimeui->hwndUI))
#define SETUI(pimeui, hwndui) (pimeui->hwndUI=(hwndui))

LOOKASIDE ImeUILookaside;

/***************************************************************************\
* NtUserBroadcastImeShowStatusChange(), NtUserCheckImeShowStatusInThread()
*
* Stub for kernel mode routines
*
\***************************************************************************/

_inline void NtUserBroadcastImeShowStatusChange(HWND hwndDefIme, BOOL fShow)
{
    NtUserCallHwndParamLock(hwndDefIme, fShow, SFI_XXXBROADCASTIMESHOWSTATUSCHANGE);
}

_inline void NtUserCheckImeShowStatusInThread(HWND hwndDefIme)
{
    NtUserCallHwndLock(hwndDefIme, SFI_XXXCHECKIMESHOWSTATUSINTHREAD);
}

/***************************************************************************\
* ImeWndProc
*
* WndProc for IME class
*
* History:
\***************************************************************************/

LRESULT APIENTRY ImeWndProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND        hwnd = HWq(pwnd);
    PIMEUI      pimeui;
    static BOOL fInit = TRUE;

    CheckLock(pwnd);

    VALIDATECLASSANDSIZE(pwnd, FNID_IME);
    INITCONTROLLOOKASIDE(&ImeUILookaside, IMEUI, spwnd, 8);

#ifdef CUAS_ENABLE
    if (IS_CICERO_ENABLED()) {
        LRESULT lRet;
        lRet = fpCtfImmDispatchDefImeMessage(hwnd, message, wParam, lParam);
        if (lRet)
            return lRet;
    }
#endif

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_IME))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);

    /*
     * Get the pimeui for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,0,pimeui) when
     * we initially created the IME control.
     */
    pimeui = ((PIMEWND)pwnd)->pimeui;

    if (pimeui == NULL) {
        /*
         * Further processing not needed
         */
        RIPMSG0(RIP_WARNING, "ImeWndProcWorker: pimeui == NULL\n");
        return 0L;
    }

    /*
     * This is necessary to avoid recursion call from IME UI.
     */
    UserAssert(pimeui->nCntInIMEProc >= 0);

    if (pimeui->nCntInIMEProc > 0) {
        TAGMSG5(DBGTAG_IMM, "ImeWndProcWorker: Recursive for pwnd=%08p, msg=%08x, wp=%08x, lp=%08x, fAnsi=%d\n",
                pwnd, message, wParam, lParam, fAnsi);
        switch (message) {
        case WM_IME_SYSTEM:
            switch (wParam) {
            case IMS_ISACTIVATED:
            case IMS_SETOPENSTATUS:
//          case IMS_SETCONVERSIONSTATUS:
            case IMS_SETSOFTKBDONOFF:
                /*
                 * Because these will not be pass to UI.
                 * We can do it.
                 */
                break;

            default:
                return 0L;
            }
            break;

        case WM_IME_STARTCOMPOSITION:
        case WM_IME_ENDCOMPOSITION:
        case WM_IME_COMPOSITION:
        case WM_IME_SETCONTEXT:
#if !defined(CUAS_ENABLE)
        case WM_IME_NOTIFY:
#endif
        case WM_IME_CONTROL:
        case WM_IME_COMPOSITIONFULL:
        case WM_IME_SELECT:
        case WM_IME_CHAR:
        case WM_IME_REQUEST:
            return 0L;

#ifdef CUAS_ENABLE
        case WM_IME_NOTIFY:
            if (wParam >= IMN_PRIVATE &&
                ! IS_IME_KBDLAYOUT(GETHKL(pimeui)) && IS_CICERO_ENABLED()) {
                //
                // CUAS: IMN_PRIVATE always call UI window.
                //
                break;
            }
            return 0L;
#endif

        default:
            return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
        }
    }

    if (TestWF(pwnd, WFINDESTROY) || TestWF(pwnd, WFDESTROYED)) {
        switch (message) {
        case WM_DESTROY:
        case WM_NCDESTROY:
        case WM_FINALDESTROY:
            break;
        default:
            RIPMSG1(RIP_WARNING, "ImeWndProcWorker: message %x is sent to destroyed window.", message);
            return 0L;
        }
    }

    switch (message) {
    case WM_ERASEBKGND:
        return (LONG)TRUE;

    case WM_PAINT:
        break;

    case WM_CREATE:

        return ImeWndCreateHandler(pimeui, (LPCREATESTRUCT)lParam);

    case WM_DESTROY:
        /*
         * We are destroying the IME window, destroy
         * any UI window that it owns.
         */
        ImeWndDestroyHandler(pimeui);
        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        if (pimeui) {
            Unlock(&pimeui->spwnd);
            FreeLookasideEntry(&ImeUILookaside, pimeui);
        }
        NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);
        goto CallDWP;

    case WM_IME_SYSTEM:
        UserAssert(pimeui->spwnd == pwnd);
        return ImeSystemHandler(pimeui, message, wParam, lParam);

    case WM_IME_SELECT:
        return ImeSelectHandler(pimeui, message, wParam, lParam);

    case WM_IME_CONTROL:
        return ImeControlHandler(pimeui, message, wParam, lParam, fAnsi);

    case WM_IME_SETCONTEXT:
        return ImeSetContextHandler(pimeui, message, wParam, lParam);

    case WM_IME_NOTIFY:
        return ImeNotifyHandler(pimeui, message, wParam, lParam);

    case WM_IME_REQUEST:
        return 0;

    case WM_IME_COMPOSITION:
    case WM_IME_ENDCOMPOSITION:
    case WM_IME_STARTCOMPOSITION:
        return SendMessageToUI(pimeui, message, wParam, lParam, fAnsi);

    default:
CallDWP:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }

    return 0L;
}


LRESULT WINAPI ImeWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    return ImeWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}


LRESULT WINAPI ImeWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    return ImeWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}


LONG ImeWndCreateHandler(
    PIMEUI pimeui,
    LPCREATESTRUCT lpcs)
{
    PWND pwndParent;
    HIMC hImc;
    PWND pwndIme = pimeui->spwnd;
#if _DBG
    static DWORD dwFirstWinlogonThreadId;
#endif

#if _DBG
    /*
     * For Winlogon, only the first thread can have IME processing.
     */
    if (gfLogonProcess) {
        UserAssert(dwFirstWinLogonThreadId == 0);
        dwFirstWinlogonThreadId = GetCurrentThreadId();
    }
#endif

    if (!TestWF(pwndIme, WFPOPUP) || !TestWF(pwndIme, WFDISABLED)) {
        RIPMSG0(RIP_WARNING, "IME window should have WS_POPUP and WS_DISABLE!!");
        return -1L;
    }

    /*
     * Check with parent window, if exists, try to get IMC.
     * If this is top level window, wait for first WM_IME_SETCONTEXT.
     */
    if ((pwndParent = ValidateHwndNoRip(lpcs->hwndParent)) != NULL) {
        hImc = KHIMC_TO_HIMC(pwndParent->hImc);
        if (hImc != NULL_HIMC && ImeIsUsableContext(HWq(pwndIme), hImc)) {
            /*
             * Store it for later use.
             */
            SETIMC(pimeui, hImc);
        }
        else {
            SETIMC(pimeui, NULL_HIMC);
        }
    }
    else {
        SETIMC(pimeui, NULL_HIMC);
    }

    /*
     * Initialize status window show state
     * The status window is not open yet.
     */
    pimeui->fShowStatus = 0;
    pimeui->nCntInIMEProc = 0;
    pimeui->fActivate = 0;
    pimeui->fDestroy = 0;
    pimeui->hwndIMC = NULL;
    pimeui->hKL = THREAD_HKL();
    pimeui->fCtrlShowStatus = TRUE;

#if !defined(CUAS_ENABLE)  // move to LoadThreadLayout
    /*
     * Load up the IME DLL of current keyboard layout.
     */
    fpImmLoadIME(GETHKL(pimeui));

#ifdef LATE_CREATEUI
    SETUI(pimeui, NULL);
#else
    SETUI(pimeui, CreateIMEUI(pimeui, pimeui->hKL));
#endif

#else

    // Cicero
    pimeui->dwPrevToolbarStatus = 0;

#endif // CUAS_ENABLE // move to LoadThreadLayout

    return 0L;
}

void ImeWndDestroyHandler(
    PIMEUI pimeui)
{
    DestroyIMEUI(pimeui);
}


#ifdef CUAS_ENABLE

VOID
CtfLoadThreadLayout(
    PIMEUI pimeui)
{
#if 1
    /*
     * Cicero Unaware Support. Activate Thread Input Manager.
     */
    fpCtfImmTIMActivate(pimeui->hKL);

    /*
     * Load up the IME DLL of current keyboard layout.
     */
    pimeui->hKL = THREAD_HKL();        // Reload thread hKL if TIM activated, hKL changed.
    fpImmLoadIME(GETHKL(pimeui));

#ifdef LATE_CREATEUI
    SETUI(pimeui, NULL);
#else
    SETUI(pimeui, CreateIMEUI(pimeui, pimeui->hKL));
#endif

#else
    UNREFERENCED_PARAMETER(pimeui);
#endif
}

#endif // CUAS_ENABLE

/***************************************************************************\
*  GetSystemModulePath
*
\***************************************************************************/

#define SYSTEM_DIR  0
#define WINDOWS_DIR 1

UINT GetSystemModulePath(DWORD dir, LPWSTR psz, DWORD cch, CONST WCHAR* pszModuleName)
{
    UINT   uRet;

    if (! psz || ! pszModuleName || cch == 0) {
        return 0;
    }
    if (! pszModuleName[0]) {
        return 0;
    }

    if (dir == SYSTEM_DIR) {
        uRet = GetSystemDirectory(psz, cch);
    }
    else {
        uRet = GetSystemWindowsDirectory(psz, cch);
    }
    if (uRet >= cch) {
        uRet = 0;
        psz[0] = L'\0';
    }
    else if (uRet) {
        UINT uLen;

        if (psz[uRet - 1] != L'\\') {
            psz[uRet] = L'\\';
            uRet++;
        }

        if (uRet >= cch) {
            uRet = 0;
            psz[0] = L'\0';
        }
        else {
            uLen = wcslen(pszModuleName);
            if (cch - uRet > uLen) {
                wcsncpy(&psz[uRet],
                        pszModuleName,
                        cch - uRet);
                uRet += uLen;
            }
            else {
                uRet = 0;
                psz[0] = L'\0';
            }
        }
    }

    return uRet;
}

/***************************************************************************\
* ImeRunHelp
*
* Display Help file (HLP and CHM).
*
* History:
* 27-Oct-98 Hiroyama
\***************************************************************************/

void ImeRunHelp(LPWSTR wszHelpFile)
{
    static const WCHAR wszHelpFileExt[] = L".HLP";
    UINT cchLen = wcslen(wszHelpFile);

    if (cchLen > 4 && _wcsicmp(wszHelpFile + cchLen - 4, wszHelpFileExt) == 0) {
#ifdef FYI
        WinHelpW(NULL, wszHelpFile, HELP_CONTENTS, 0);
#else
        WinHelpW(NULL, wszHelpFile, HELP_FINDER, 0);
#endif
    } else {
        //
        // If it's not HLP file, try to run hh.exe, HTML based
        // help tool. It should be in %windir%\hh.exe.
        //
        static const WCHAR wszHH[] = L"hh.exe ";
        WCHAR wszCmdLine[MAX_PATH * 2];
        DWORD               idProcess;
        STARTUPINFO         StartupInfo;
        PROCESS_INFORMATION ProcessInformation;
        UINT i;
        WCHAR wszAppName[MAX_PATH + 1];

        if (! (i=GetSystemModulePath(WINDOWS_DIR, wszAppName, ARRAYSIZE(wszAppName), wszHH)))
        {
            return;
        }

        if (i + cchLen >= ARRAYSIZE(wszCmdLine))
        {
            return;
        }

        wcsncpy(wszCmdLine,
                wszAppName,
                ARRAYSIZE(wszCmdLine));
        wcsncpy(&wszCmdLine[i],
                wszHelpFile,
                ARRAYSIZE(wszCmdLine) - i);

        /*
         *  Launch HTML Help.
         */
        RtlZeroMemory(&StartupInfo, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.wShowWindow = SW_SHOW;
        StartupInfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_FORCEONFEEDBACK;

        TAGMSG2(DBGTAG_IMM, "Invoking help with '%S %S'", wszAppName, wszHelpFile);

        idProcess = (DWORD)CreateProcessW(wszAppName, wszCmdLine,
                NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &StartupInfo,
                &ProcessInformation);

        if (idProcess) {
            WaitForInputIdle(ProcessInformation.hProcess, 10000);
            NtClose(ProcessInformation.hProcess);
            NtClose(ProcessInformation.hThread);
        }
    }
}

LRESULT ImeSystemHandler(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    PINPUTCONTEXT pInputContext;
    HIMC          hImc = GETIMC(pimeui);
    LRESULT       dwRet = 0L;

    UNREFERENCED_PARAMETER(message);

    switch (wParam) {

    case IMS_SETOPENCLOSE:
        if (hImc != NULL_HIMC)
            fpImmSetOpenStatus(hImc, (BOOL)lParam);
        break;

    case IMS_WINDOWPOS:
        if (hImc != NULL_HIMC) {
            BOOL f31Hidden = FALSE;

            if ((pInputContext = fpImmLockIMC(hImc)) != NULL) {
                f31Hidden = (pInputContext->fdw31Compat & F31COMPAT_MCWHIDDEN);
                fpImmUnlockIMC(hImc);
            }

            if (IsWindow(KHWND_TO_HWND(pimeui->hwndIMC))) {
                int i;

                if (!f31Hidden) {
                    COMPOSITIONFORM cof;

                    if (fpImmGetCompositionWindow(hImc, &cof) && cof.dwStyle != CFS_DEFAULT) {
                        fpImmSetCompositionWindow(hImc, &cof);
                    }
                }

                for (i = 0; i < 4 ; i++) {
                    CANDIDATEFORM caf;

                    if (fpImmGetCandidateWindow(hImc, (DWORD)i, &caf) && caf.dwStyle != CFS_DEFAULT) {
                        fpImmSetCandidateWindow(hImc, &caf);
                    }
                }
            }
        }
        break;

    case IMS_ACTIVATECONTEXT:
        FocusSetIMCContext((HWND)(lParam), TRUE);
        break;

    case IMS_DEACTIVATECONTEXT:
        FocusSetIMCContext((HWND)(lParam), FALSE);
        break;

#ifdef CUAS_ENABLE
    case IMS_LOADTHREADLAYOUT:
        CtfLoadThreadLayout(pimeui);
        break;
#endif // CUAS_ENABLE

    case IMS_UNLOADTHREADLAYOUT:
        return (LONG)(fpImmFreeLayout((DWORD)lParam));

    case IMS_ACTIVATETHREADLAYOUT:
        return (LONG)(fpImmActivateLayout((HKL)lParam));

    case IMS_SETCANDIDATEPOS:
        if ( (pInputContext = fpImmLockIMC( hImc )) != NULL ) {
            LPCANDIDATEFORM lpcaf;
            DWORD dwIndex = (DWORD)lParam;

            lpcaf = &(pInputContext->cfCandForm[dwIndex]);
            fpImmSetCandidateWindow( hImc, lpcaf );
            fpImmUnlockIMC( hImc );
        }
        break;

    case IMS_SETCOMPOSITIONWINDOW:
        if ( (pInputContext = fpImmLockIMC( hImc )) != NULL ) {
            LPCOMPOSITIONFORM lpcof;

            lpcof = &(pInputContext->cfCompForm);
            pInputContext->fdw31Compat |= F31COMPAT_CALLFROMWINNLS;
            fpImmSetCompositionWindow( hImc, lpcof);
            fpImmUnlockIMC( hImc );
        }
        break;

    case IMS_SETCOMPOSITIONFONT:
        if ( (pInputContext = fpImmLockIMC( hImc )) != NULL ) {
            LPLOGFONT lplf;

            lplf = &(pInputContext->lfFont.W);
            fpImmSetCompositionFont( hImc, lplf );
            fpImmUnlockIMC( hImc );
        }
        break;

    case IMS_CONFIGUREIME:
        fpImmConfigureIMEW( (HKL)lParam, KHWND_TO_HWND(pimeui->hwndIMC), IME_CONFIG_GENERAL, NULL);
        break;

    case IMS_CHANGE_SHOWSTAT:
        // Private message from internat.exe
        // Before it reaches here, the registry is already updated.
        if (GetIMEShowStatus() == !lParam) {
#if 1
            NtUserBroadcastImeShowStatusChange(HW(pimeui->spwnd), !!lParam);
#else
            SystemParametersInfo(SPI_SETSHOWIMEUI, lParam, NULL, FALSE);
#endif
        }
        break;

    case IMS_GETCONVERSIONMODE:
    {
        DWORD dwConv = 0;
        DWORD dwTemp;

        fpImmGetConversionStatus(hImc, &dwConv, &dwTemp);
        return (dwConv);
        break;
    }

    case IMS_SETSOFTKBDONOFF:
        fpImmEnumInputContext(0, SyncSoftKbdState, lParam);
        break;

    case IMS_GETIMEMENU:
        // new in NT50
        // IMS_GETIEMMENU is used to handle Inter Process GetMenu.
        // NOTE: This operation is only intended to internat.exe
        return fpImmPutImeMenuItemsIntoMappedFile((HIMC)lParam);

    case IMS_IMEHELP:
        dwRet = IME_ESC_GETHELPFILENAME;
        dwRet = fpImmEscapeW(GETHKL(pimeui), GETIMC(pimeui), IME_ESC_QUERY_SUPPORT, (LPVOID)&dwRet);
        if (lParam) {
            // try to run WinHelp
            WCHAR wszHelpFile[MAX_PATH];

            if (dwRet) {
                if (fpImmEscapeW(GETHKL(pimeui), GETIMC(pimeui), IME_ESC_GETHELPFILENAME,
                        (LPVOID)wszHelpFile)) {
                    ImeRunHelp(wszHelpFile);
                }
            }
        }
        return dwRet;

    case IMS_GETCONTEXT:
        dwRet = (ULONG_PTR)fpImmGetContext((HWND)lParam);
        return dwRet;

    case IMS_ENDIMEMENU:
        // New in NT5.0: Special support for Internat.exe
        if (IsWindow((HWND)lParam)) {
            HIMC hImc;
            UINT uID;
            DWORD dwData;

            hImc = fpImmGetContext((HWND)lParam);

            if (hImc != NULL) {
                //
                // Call Indicator to get IME menu data.
                //
                if (IMEIndicatorGetMenuIDData(&uID, &dwData)) {
                    fpImmNotifyIME(hImc, NI_IMEMENUSELECTED, uID, dwData);
                }
                fpImmReleaseContext((HWND)lParam, hImc);
            }
        }
        break;

    case IMS_SENDNOTIFICATION:
    case IMS_FINALIZE_COMPSTR:
        dwRet = fpImmSystemHandler(hImc, wParam, lParam);
        break;

#ifdef CUAS_ENABLE
    case IMS_SETLANGBAND:
    case IMS_RESETLANGBAND:
        dwRet = fpImmSystemHandler(hImc, wParam, lParam);
        break;
#endif // CUAS_ENABLE

    default:
        break;
    }

    return dwRet;
}


LONG ImeSelectHandler(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndUI;

    /*
     * Deliver this message to other IME windows in this thread.
     */
    if (pimeui->fDefault)
        ImeBroadCastMsg(pimeui, message, wParam, lParam);

    /*
     * We must re-create UI window of newly selected IME.
     */
    if ((BOOL)wParam == TRUE) {
        UserAssert(!IsWindow(GETUI(pimeui)));

        SETHKL(pimeui, (HKL)lParam);

#ifdef LATE_CREATEUI
        if (!pimeui->fActivate)
            return 0L;
#endif

        hwndUI = CreateIMEUI(pimeui, (HKL)lParam);

        SETUI(pimeui, hwndUI);

        if (hwndUI != NULL) {
            SetWindowLongPtr(hwndUI, IMMGWLP_IMC, (LONG_PTR)GETIMC(pimeui));
            SendMessageToUI(pimeui, message, wParam, lParam, FALSE);
        }

        if (GetIMEShowStatus() && pimeui->fCtrlShowStatus) {
            if (!pimeui->fShowStatus && pimeui->fActivate &&
                    IsWindow(KHWND_TO_HWND(pimeui->hwndIMC))) {
                /*
                 * This must be sent to an application as an app may want
                 * to hook this message to do its own UI.
                 */
                SendOpenStatusNotify(pimeui, KHWND_TO_HWND(pimeui->hwndIMC), TRUE);
            }
        }
    }
    else {

        if (pimeui->fShowStatus && pimeui->fActivate &&
                IsWindow(KHWND_TO_HWND(pimeui->hwndIMC))) {
            /*
             * This must be sent to an application as an app may want
             * to hook this message to do its own UI.
             */
            SendOpenStatusNotify(pimeui, KHWND_TO_HWND(pimeui->hwndIMC), FALSE);
        }

        SendMessageToUI(pimeui, message, wParam, lParam, FALSE);

        DestroyIMEUI(pimeui);

        SETHKL(pimeui, (HKL)NULL);
    }

    return 0L;
}


LRESULT ImeControlHandler(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL   fAnsi)
{
    HIMC  hImc;
    DWORD dwConversion, dwSentence;

#ifdef CUAS_ENABLE
    if (IS_CICERO_ENABLED()) {
        if (wParam == IMC_OPENSTATUSWINDOW) {
            fpCtfImmRestoreToolbarWnd(pimeui->dwPrevToolbarStatus);
            pimeui->dwPrevToolbarStatus = 0;
        }
        else if (wParam == IMC_CLOSESTATUSWINDOW) {
            pimeui->dwPrevToolbarStatus = fpCtfImmHideToolbarWnd();
        }
    }
#endif // CUAS_ENABLE

    /*
     * Do nothing with NULL hImc.
     */
    if ((hImc = GETIMC(pimeui)) == NULL_HIMC)
        return 0L;

    switch (wParam) {

    case IMC_OPENSTATUSWINDOW:
        if (GetIMEShowStatus() && !pimeui->fShowStatus) {
            pimeui->fShowStatus = TRUE;
            SendMessageToUI(pimeui, WM_IME_NOTIFY,
                    IMN_OPENSTATUSWINDOW, 0L, FALSE);
        }
        pimeui->fCtrlShowStatus = TRUE;
        break;

    case IMC_CLOSESTATUSWINDOW:
        if (GetIMEShowStatus() && pimeui->fShowStatus) {
            pimeui->fShowStatus = FALSE;
            SendMessageToUI(pimeui, WM_IME_NOTIFY,
                    IMN_CLOSESTATUSWINDOW, 0L, FALSE);
        }
        pimeui->fCtrlShowStatus = FALSE;
        break;

    /*
     * ------------------------------------------------
     * IMC_SETCOMPOSITIONFONT,
     * IMC_SETCONVERSIONMODE,
     * IMC_SETOPENSTATUS
     * ------------------------------------------------
     * Don't pass these WM_IME_CONTROLs to UI window.
     * Call Imm in order to process these requests instead.
     * It makes message flows simpler.
     */
    case IMC_SETCOMPOSITIONFONT:
        if (fAnsi) {
            if (!fpImmSetCompositionFontA(hImc, (LPLOGFONTA)lParam))
                return 1L;
        }
        else {
            if (!fpImmSetCompositionFontW(hImc, (LPLOGFONTW)lParam))
                return 1L;
        }
        break;

    case IMC_SETCONVERSIONMODE:
        if (!fpImmGetConversionStatus(hImc, &dwConversion, &dwSentence) ||
            !fpImmSetConversionStatus(hImc, (DWORD)lParam, dwSentence))
            return 1L;
        break;

    case IMC_SETSENTENCEMODE:
        if (!fpImmGetConversionStatus(hImc, &dwConversion, &dwSentence) ||
            !fpImmSetConversionStatus(hImc, dwConversion, (DWORD)lParam))
            return 1L;
        break;

    case IMC_SETOPENSTATUS:
        if (!fpImmSetOpenStatus(hImc, (BOOL)lParam))
            return 1L;
        break;

    case IMC_GETCONVERSIONMODE:
        if (!fpImmGetConversionStatus(hImc,&dwConversion, &dwSentence))
            return 1L;

        return (LONG)dwConversion;

    case IMC_GETSENTENCEMODE:
        if (!fpImmGetConversionStatus(hImc,&dwConversion, &dwSentence))
            return 1L;

        return (LONG)dwSentence;

    case IMC_GETOPENSTATUS:
        return (LONG)fpImmGetOpenStatus(hImc);

    case IMC_GETCOMPOSITIONFONT:
        if (fAnsi) {
            if (!fpImmGetCompositionFontA(hImc, (LPLOGFONTA)lParam))
                return 1L;
        }
        else {
            if (!fpImmGetCompositionFontW(hImc, (LPLOGFONTW)lParam))
                return 1L;
        }
        break;

    case IMC_SETCOMPOSITIONWINDOW:
        if (!fpImmSetCompositionWindow(hImc, (LPCOMPOSITIONFORM)lParam))
            return 1L;
        break;

    case IMC_SETSTATUSWINDOWPOS:
        {
            POINT ppt;

            ppt.x = (LONG)((LPPOINTS)&lParam)->x;
            ppt.y = (LONG)((LPPOINTS)&lParam)->y;

            if (!fpImmSetStatusWindowPos(hImc, &ppt))
                return 1L;
        }
        break;

    case IMC_SETCANDIDATEPOS:
        if (!fpImmSetCandidateWindow(hImc, (LPCANDIDATEFORM)lParam))
            return 1;
        break;

    /*
     * Followings are the messsages to be sent to UI.
     */
    case IMC_GETCANDIDATEPOS:
    case IMC_GETSTATUSWINDOWPOS:
    case IMC_GETCOMPOSITIONWINDOW:
    case IMC_GETSOFTKBDPOS:
    case IMC_SETSOFTKBDPOS:
        return SendMessageToUI(pimeui, message, wParam, lParam, fAnsi);

    default:
        break;
    }

    return 0L;
}



LRESULT ImeSetContextHandler(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND  hwndPrevIMC, hwndFocus;   // focus window in the thread
    HIMC  hFocusImc;                // focus window's IMC
    LRESULT lRet;

    pimeui->fActivate = (BOOL)wParam ? 1 : 0;
    hwndPrevIMC = KHWND_TO_HWND(pimeui->hwndIMC);

    if (wParam) {
        /*
         * if it's being activated
         */
#ifdef LATE_CREATEUI
        if (!GETUI(pimeui))
            SETUI(pimeui, CreateIMEUI(pimeui, GETHKL(pimeui)));
#endif

        /*
         * Check if this process a console IME ?
         */
        if (gfConIme == UNKNOWN_CONIME) {
            gfConIme = (DWORD)NtUserGetThreadState(UserThreadStateIsConImeThread);
            if (gfConIme) {
                RIPMSG0(RIP_VERBOSE, "ImmSetContextHandler: This thread is console IME.\n");
                UserAssert(pimeui);
                // Console IME will never show the IME status window.
                pimeui->fCtrlShowStatus = FALSE;
            }
        }

        if (gfConIme) {
            /*
             * Special handling for Console IME is needed
             */
            PWND pwndOwner;

            UserAssert(pimeui->spwnd);
            pwndOwner = REBASEPWND(pimeui->spwnd, spwndOwner);
            if (pwndOwner != NULL) {
                /*
                 * Set current associated hIMC in IMEUI.
                 */
                SETIMC(pimeui, pwndOwner->hImc);
                /*
                 * Store it to the window memory.
                 */
                if (GETUI(pimeui) != NULL)
                    SetWindowLongPtr(GETUI(pimeui), IMMGWLP_IMC, (LONG_PTR)pwndOwner->hImc);
            }

            hwndFocus = NtUserQueryWindow(HW(pimeui->spwnd), WindowFocusWindow);
            hFocusImc = KHIMC_TO_HIMC(pwndOwner->hImc);
            RIPMSG2(RIP_VERBOSE, "CONSOLE IME: hwndFocus = %x, hFocusImc = %x", hwndFocus, hFocusImc);

            return SendMessageToUI(pimeui, message, wParam, lParam, FALSE);
        }
        else {
            hwndFocus = NtUserQueryWindow(HW(pimeui->spwnd), WindowFocusWindow);
            hFocusImc = fpImmGetContext(hwndFocus);
        }

        /*
         * Cannot share input context with other IME window.
         */
        if (hFocusImc != NULL_HIMC &&
                !ImeIsUsableContext(HW(pimeui->spwnd), hFocusImc)) {
            SETIMC(pimeui, NULL_HIMC);
            return 0L;
        }

        SETIMC(pimeui, hFocusImc);

        /*
         * Store it to the window memory.
         */
        if (GETUI(pimeui) != NULL)
            SetWindowLongPtr(GETUI(pimeui), IMMGWLP_IMC, (LONG_PTR)hFocusImc);

        /*
         * When we're receiving context,
         * it is necessary to set the owner to this window.
         * This is for:
         *     Give the UI moving information.
         *     Give the UI automatic Z-ordering.
         *     Hide the UI when the owner is minimized.
         */
        if (hFocusImc != NULL_HIMC) {
            PINPUTCONTEXT pInputContext;

            /*
             * Get the window who's given the context.
             */
            if ((pInputContext = fpImmLockIMC(hFocusImc)) != NULL) {
                //UserAssert(hwndFocus == pInputContext->hWnd);
                if (hwndFocus != pInputContext->hWnd) {
                    fpImmUnlockIMC(hFocusImc);
                    /*
                     * Pq->spwndFocus has been changed so far...
                     * All we can do is just to bail out.
                     */
                    return 0L;
                }
            }
            else
                return 0L; // the context was broken

            if ((pInputContext->fdw31Compat & F31COMPAT_ECSETCFS) &&
                    hwndPrevIMC != hwndFocus) {
                COMPOSITIONFORM cf;

                /*
                 * Set CFS_DEFAULT....
                 */
                RtlZeroMemory(&cf, sizeof(cf));
                fpImmSetCompositionWindow(hFocusImc, &cf);
                pInputContext->fdw31Compat &= ~F31COMPAT_ECSETCFS;
            }

            fpImmUnlockIMC(hFocusImc);

            if (NtUserSetImeOwnerWindow(HW(pimeui->spwnd), hwndFocus))
                pimeui->hwndIMC = hwndFocus;

        }
        else {
            /*
             * NULL IMC is getting activated
             */
            pimeui->hwndIMC = hwndFocus;

            NtUserSetImeOwnerWindow(HW(pimeui->spwnd), NULL);

        }
    }

    lRet = SendMessageToUI(pimeui, message, wParam, lParam, FALSE);

    if (pimeui->spwnd == NULL) {
        // Unusual case in stress..
        // IME window has been destroyed during the callback
        RIPMSG0(RIP_WARNING, "ImmSetContextHandler: pimeui->spwnd is NULL after SendMessageToUI.");
        return 0L;
    }

    if (pimeui->fCtrlShowStatus && GetIMEShowStatus()) {
        PWND pwndFocus, pwndIMC, pwndPrevIMC;
        HWND hwndActive;

        hwndFocus = NtUserQueryWindow(HWq(pimeui->spwnd), WindowFocusWindow);
        pwndFocus = ValidateHwndNoRip(hwndFocus);

        if ((BOOL)wParam == TRUE) {
            HWND hwndIme;

            /*
             * BOGUS BOGUS
             * The following if statement is still insufficient
             * it needs to think what WM_IME_SETCONTEXT:TRUE should do
             * in the case of WINNLSEnableIME(true) - ref.win95c B#8548.
             */
            UserAssert(pimeui->spwnd);
            if (pwndFocus != NULL && GETPTI(pimeui->spwnd) == GETPTI(pwndFocus)) {

                if (!pimeui->fShowStatus) {
                    /*
                     * We have never sent IMN_OPENSTATUSWINDOW yet....
                     */
                    if (ValidateHwndNoRip(KHWND_TO_HWND(pimeui->hwndIMC))) {
                        SendOpenStatusNotify(pimeui, KHWND_TO_HWND(pimeui->hwndIMC), TRUE);
                    }
                }
                else if ((pwndIMC = ValidateHwndNoRip(KHWND_TO_HWND(pimeui->hwndIMC))) != NULL &&
                         (pwndPrevIMC = ValidateHwndNoRip(hwndPrevIMC)) != NULL &&
                         GetTopLevelWindow(pwndIMC) != GetTopLevelWindow(pwndPrevIMC)) {
                    /*
                     * Because the top level window of IME Wnd was changed.
                     */
                    SendOpenStatusNotify(pimeui, hwndPrevIMC, FALSE);
                    SendOpenStatusNotify(pimeui, KHWND_TO_HWND(pimeui->hwndIMC), TRUE);
                }
            }
            /*
             * There may have other IME windows that have fShowStatus.
             * We need to check the fShowStatus in the window list.
             */
            hwndIme = HW(pimeui->spwnd);
            if (hwndIme) {
                NtUserCheckImeShowStatusInThread(hwndIme);
            }
        }
        else {
            /*
             * When focus was removed from this thread, we close the
             * status window.
             * Because focus was already removed from whndPrevIMC,
             * hwndPrevIMC may be destroyed but we need to close the
             * status window.
             */
            hwndActive = NtUserQueryWindow(HW(pimeui->spwnd), WindowActiveWindow);
            UserAssert(pimeui->spwnd);
            if (pwndFocus == NULL || GETPTI(pimeui->spwnd) != GETPTI(pwndFocus) ||
                    hwndActive == NULL) {

                if (IsWindow(hwndPrevIMC)) {
                    RIPMSG1(RIP_VERBOSE, "ImeSetContextHandler: notifying OpenStatus (FALSE) to hwnd=%p", hwndPrevIMC);
                    SendOpenStatusNotify(pimeui, hwndPrevIMC, FALSE);
                }
                else {
                    RIPMSG1(RIP_VERBOSE, "ImeSetContextHandler: sending IMN_CLOSESTATUSWINDOW to UIwnd=%p", pimeui->hwndUI);
                    pimeui->fShowStatus = FALSE;
                    SendMessageToUI(pimeui, WM_IME_NOTIFY, IMN_CLOSESTATUSWINDOW, 0L, FALSE);
                }
            }
        }
    }

    return lRet;
}


LRESULT ImeNotifyHandler(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndUI;
    LRESULT lRet = 0L;
    HIMC hImc;
    PINPUTCONTEXT pInputContext;

    switch (wParam) {
    case IMN_PRIVATE:
        hwndUI = GETUI(pimeui);
        if (IsWindow(hwndUI))
            lRet = SendMessage(hwndUI, message, wParam, lParam);
        break;

    case IMN_SETCONVERSIONMODE:
    case IMN_SETOPENSTATUS:
        //
        // notify shell and keyboard the conversion mode change
        //
        // if this message is sent from ImmSetOpenStatus or
        // ImmSetConversionStatus, we have already notified
        // kernel the change. This is a little bit redundant.
        //
        // if application has eaten the message, we won't be here.
        // We need to think about the possibility later.
        //
        hImc = GETIMC(pimeui);
        if ((pInputContext = fpImmLockIMC(hImc)) != NULL) {
            if ( IsWindow(KHWND_TO_HWND(pimeui->hwndIMC)) ) {
                NtUserNotifyIMEStatus( KHWND_TO_HWND(pimeui->hwndIMC),
                                       (DWORD)pInputContext->fOpen,
                                       pInputContext->fdwConversion );
            }
            else if (gfConIme == TRUE) {
                /*
                 * Special handling for Console IME is needed
                 */
                if (pimeui->spwnd) {    // If IME window is still there.
                    PWND pwndOwner = REBASEPWND(pimeui->spwnd, spwndOwner);

                    if (pwndOwner != NULL) {
                        NtUserNotifyIMEStatus(HWq(pwndOwner),
                                              (DWORD)pInputContext->fOpen,
                                              pInputContext->fdwConversion);
                    }
                }
            }
            fpImmUnlockIMC(hImc);
        }
        /*** FALL THROUGH ***/
    default:
        TAGMSG4(DBGTAG_IMM, "ImeNotifyHandler: sending to pimeui->ui=%p, msg=%x, wParam=%x, lParam=%x\n", GETUI(pimeui), message, wParam, lParam);
        lRet = SendMessageToUI(pimeui, message, wParam, lParam, FALSE);
    }

    return lRet;
}


HWND CreateIMEUI(
    PIMEUI pimeui,
    HKL    hKL)
{
    PWND      pwndIme = pimeui->spwnd;
    HWND      hwndUI;
    IMEINFOEX iiex;
    PIMEDPI   pimedpi;
    WNDCLASS  wndcls;

    if (!fpImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return (HWND)NULL;

    if ((pimedpi = fpImmLockImeDpi(hKL)) == NULL) {
        RIPMSG1(RIP_WARNING, "CreateIMEUI: ImmLockImeDpi(%lx) failed.", hKL);
        return (HWND)NULL;
    }

    if (!GetClassInfoW(pimedpi->hInst, iiex.wszUIClass, &wndcls)) {
        RIPMSG1(RIP_WARNING, "CreateIMEUI: GetClassInfoW(%ws) failed\n", iiex.wszUIClass);
        fpImmUnlockImeDpi(pimedpi);
        return (HWND)NULL;
    }

    // HACK HACK HACK
    if ((wndcls.style & CS_IME) == 0) {
        RIPMSG1(RIP_ERROR, "CreateIMEUI: the Window Class (%S) does not have CS_IME flag on !!!\n",
                wndcls.lpszClassName);
    }

    if (iiex.ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        /*
         * For Unicode IME, we create an Unicode IME UI window.
         */
        hwndUI = CreateWindowExW(0L,
                        iiex.wszUIClass,
                        iiex.wszUIClass,
                        WS_POPUP|WS_DISABLED,
                        0, 0, 0, 0,
                        HWq(pwndIme), 0, wndcls.hInstance, NULL);
    }
    else {
        /*
         * For ANSI IME, we create an ANSI IME UI window.
         */

        LPSTR pszClass;
        int i;
        i = WCSToMB(iiex.wszUIClass, -1, &pszClass, -1, TRUE);
        if (i == 0) {
            RIPMSG1(RIP_WARNING, "CreateIMEUI: failed in W->A conversion (%S)", iiex.wszUIClass);
            fpImmUnlockImeDpi(pimedpi);
            return (HWND)NULL;
        }
        pszClass[i] = '\0';

        hwndUI = CreateWindowExA(0L,
                        pszClass,
                        pszClass,
                        WS_POPUP|WS_DISABLED,
                        0, 0, 0, 0,
                        HWq(pwndIme), 0, wndcls.hInstance, NULL);

        UserLocalFree(pszClass);
    }

    if (hwndUI)
        NtUserSetWindowLongPtr(hwndUI, IMMGWLP_IMC, (LONG_PTR)GETIMC(pimeui), FALSE);

    fpImmUnlockImeDpi(pimedpi);

    return hwndUI;
}


VOID DestroyIMEUI(
    PIMEUI pimeui)
{
    // This has currently nothing to do except for destroying the UI.
    // Review: Need to notify the UI with WM_IME_SETCONTEXT ?
    // Review: This doesn't support Multiple IME install yet.

    HWND hwndUI = GETUI(pimeui);

    if (IsWindow(hwndUI)) {
        pimeui->fDestroy = TRUE;
        /*
         * We need this verify because the owner might have already
         * killed it during its termination.
         */
        NtUserDestroyWindow(hwndUI);
    }
    pimeui->fDestroy = FALSE;

    /*
     * Reinitialize show status of the IME status window so that
     * notification message will be sent when needed.
     */
    pimeui->fShowStatus = FALSE;

    SETUI(pimeui, NULL);

    return;
}


/***************************************************************************\
* SendMessageToUI
*
* History:
* 09-Apr-1996 wkwok       Created
\***************************************************************************/

LRESULT SendMessageToUI(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL   fAnsi)
{
    PWND  pwndUI;
    LRESULT lRet;

    TAGMSG1(DBGTAG_IMM, "Sending to UI msg[%04X]\n", message);

    pwndUI = ValidateHwndNoRip(GETUI(pimeui));

    if (pwndUI == NULL || pimeui->spwnd == NULL)
        return 0L;

    if (TestWF(pimeui->spwnd, WFINDESTROY) || TestWF(pimeui->spwnd, WFDESTROYED) ||
            TestWF(pwndUI, WFINDESTROY) || TestWF(pwndUI, WFDESTROYED)) {
        return 0L;
    }

    InterlockedIncrement(&pimeui->nCntInIMEProc); // Mark to avoid recursion.

    lRet = SendMessageWorker(pwndUI, message, wParam, lParam, fAnsi);

    InterlockedDecrement(&pimeui->nCntInIMEProc); // Mark to avoid recursion.

    return lRet;
}


/***************************************************************************\
* SendOpenStatusNotify
*
* History:
* 09-Apr-1996 wkwok       Created
\***************************************************************************/

VOID SendOpenStatusNotify(
    PIMEUI pimeui,
    HWND   hwndApp,
    BOOL   fOpen)
{
    WPARAM wParam = fOpen ? IMN_OPENSTATUSWINDOW : IMN_CLOSESTATUSWINDOW;

    pimeui->fShowStatus = fOpen;


    if (Is400Compat(GetClientInfo()->dwExpWinVer)) {
        TAGMSG2(DBGTAG_IMM, "SendOpenStatusNotify: sending to hwnd=%lx, wParam=%d\n", hwndApp, wParam);
        SendMessage(hwndApp, WM_IME_NOTIFY, wParam, 0L);
    }
    else {
        TAGMSG2(DBGTAG_IMM, "SendOpenStatusNotify:sending to imeui->UI=%p, wParam=%d\n", GETUI(pimeui), wParam);
        SendMessageToUI(pimeui, WM_IME_NOTIFY, wParam, 0L, FALSE);
    }

    return;
}


VOID ImeSetImc(
    PIMEUI pimeui,
    HIMC hImc)
{
    HWND hImeWnd = HW(pimeui->spwnd);
    HIMC hOldImc = GETIMC(pimeui);

    /*
     * return if nothing to change.
     */
    if (hImc == hOldImc)
        return;

    /*
     * Unmark the old input context.
     */
    if (hOldImc != NULL_HIMC)
        ImeMarkUsedContext(NULL, hOldImc);

    /*
     * Update the in use input context for this IME window.
     */
    pimeui->hIMC = hImc;

    /*
     * Mark the new input context.
     */
    if (hImc != NULL_HIMC)
        ImeMarkUsedContext(hImeWnd, hImc);
}


/***************************************************************************\
*  FocusSetIMCContext()
*
* History:
* 21-Mar-1996 wkwok       Created
\***************************************************************************/

VOID FocusSetIMCContext(
    HWND hWnd,
    BOOL fActivate)
{
    HIMC hImc;

    if (IsWindow(hWnd)) {
        hImc = fpImmGetContext(hWnd);
        fpImmSetActiveContext(hWnd, hImc, fActivate);
        fpImmReleaseContext(hWnd, hImc);
    }
    else {
        fpImmSetActiveContext(NULL, NULL_HIMC, fActivate);
    }

    return;
}


BOOL ImeBroadCastMsg(
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    UNREFERENCED_PARAMETER(pimeui);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);

    return TRUE;
}

/***************************************************************************\
*  ImeMarkUsedContext()
*
*  Some IME windows can not share the same input context. This function
*  marks the specified hImc to be in used by the specified IME window.
*
* History:
* 12-Mar-1996 wkwok       Created
\***************************************************************************/

VOID ImeMarkUsedContext(
    HWND hImeWnd,
    HIMC hImc)
{
    PIMC pImc;

    pImc = HMValidateHandle((HANDLE)hImc, TYPE_INPUTCONTEXT);
    if (pImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImeMarkUsedContext: Invalid hImc (=%lx).", hImc);
        return;
    }

    UserAssert( ValidateHwndNoRip(pImc->hImeWnd) == NULL || hImeWnd == NULL );

    /*
     * Nothing to change?
     */
    if (pImc->hImeWnd == hImeWnd)
        return;

    NtUserUpdateInputContext(hImc, UpdateInUseImeWindow, (ULONG_PTR)hImeWnd);

    return;
}


/***************************************************************************\
*  ImeIsUsableContext()
*
*  Some IME windows can not share the same input context. This function
*  checks whether the specified hImc can be used (means 'Set activated')
*  by the specified IME window.
*
*  Return: TRUE  - OK to use the hImc by hImeWnd.
*          FALSE - otherwise.
*
* History:
* 12-Mar-1996 wkwok       Created
\***************************************************************************/

BOOL ImeIsUsableContext(
    HWND hImeWnd,
    HIMC hImc)
{
    PIMC pImc;

    UserAssert(hImeWnd != NULL);

    pImc = HMValidateHandle((HANDLE)hImc, TYPE_INPUTCONTEXT);
    if (pImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImeIsUsableContext: Invalid hImc (=%lx).", hImc);
        return FALSE;
    }

    if ( pImc->hImeWnd == NULL     ||
         pImc->hImeWnd == hImeWnd  ||
         ValidateHwndNoRip(pImc->hImeWnd) == NULL )
    {
        return TRUE;
    }


    return FALSE;
}

/***************************************************************************\
* GetIMEShowStatus()
*
* Get the global IME show status from kernel.
*
* History:
* 19-Sep-1996 takaok       Ported from internat.exe.
\***************************************************************************/

BOOL GetIMEShowStatus(void)
{
    return (BOOL)NtUserCallNoParam(SFI__GETIMESHOWSTATUS);
}



/***************************************************************************\
*  IMEIndicatorGetMenuIDData
*
* History:
* 3-Nov-97 Hiroyama
\***************************************************************************/

BOOL IMEIndicatorGetMenuIDData(PUINT puMenuID, PDWORD pdwData)
{
    HANDLE hinstIndic;
    WCHAR  szModule[MAX_PATH + 1];

    if (! GetSystemModulePath(SYSTEM_DIR, szModule, ARRAYSIZE(szModule), szIndicDLL)) {
        gpfnGetIMEMenuItemData = NULL;
        return FALSE;
    }

    hinstIndic = GetModuleHandle(szModule);
    if (hinstIndic == NULL) {
        gpfnGetIMEMenuItemData = NULL;
        return FALSE;
    }

    if (!gpfnGetIMEMenuItemData) {
        gpfnGetIMEMenuItemData = GetProcAddress(hinstIndic, (LPSTR)ORD_GETIMEMENUITEMDATA);
    }
    if (!gpfnGetIMEMenuItemData)
        return FALSE;

    (*(FPGETIMEMENUITEMDATA)gpfnGetIMEMenuItemData)(puMenuID, pdwData);
    return TRUE;
}


BOOL SyncSoftKbdState(
    HIMC hImc,
    LPARAM lParam)
{
    DWORD fdwConversion, fdwSentence, fdwNewConversion;

    fpImmGetConversionStatus(hImc, &fdwConversion, &fdwSentence);

    if (lParam) {
        fdwNewConversion = fdwConversion | IME_CMODE_SOFTKBD;
    } else {
        fdwNewConversion = fdwConversion & ~IME_CMODE_SOFTKBD;
    }

    if (fdwNewConversion != fdwConversion) {
        fpImmSetConversionStatus(hImc, fdwNewConversion, fdwSentence);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\keybrdc.c ===
/****************************** Module Header ******************************\
* Module Name: keybrdc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 11-11-90 DavidPe      Created.
* 13-Feb-1991 mikeke    Added Revalidation code (None)
* 12-Mar-1993 JerrySh   Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/**************************************************************************\
* GetKBCodePage
*
* 28-May-1992 IanJa    Created
\**************************************************************************/

UINT GetKBCodePage(VOID)
{
    return GetOEMCP();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\lboxctl2.c ===
/***************************************************************************\
*
*  LBOXCTL2.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      List box handling routines
*
* 18-Dec-1990 ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define LB_KEYDOWN WM_USER+1
#define NOMODIFIER  0  /* No modifier is down */
#define SHIFTDOWN   1  /* Shift alone */
#define CTLDOWN     2  /* Ctl alone */
#define SHCTLDOWN   (SHIFTDOWN + CTLDOWN)  /* Ctrl + Shift */

/*
 * Variables for incremental type search support
 */
#define MAX_TYPESEARCH  256

BOOL LBGetDC(PLBIV plb);
void LBReleaseDC(PLBIV plb);

/***************************************************************************\
*
*  LBInvalidateRect()
*
*  If the listbox is visible, invalidates a rectangle in the listbox.
*  If the listbox is not visible, sets the defer update flag for the listbox
*
\***************************************************************************/
BOOL xxxLBInvalidateRect(PLBIV plb, LPRECT lprc, BOOL fErase)
{
    CheckLock(plb->spwnd);

    if (IsLBoxVisible(plb)) {
        NtUserInvalidateRect(HWq(plb->spwnd), lprc, fErase);
        return(TRUE);
    }

    if (!plb->fRedraw)
        plb->fDeferUpdate = TRUE;

    return(FALSE);
}

/***************************************************************************\
*
*  LBGetBrush()
*
*  Gets background brush & colors for listbox.
*
\***************************************************************************/
HBRUSH xxxLBGetBrush(PLBIV plb, HBRUSH *phbrOld)
{
    HBRUSH  hbr;
    HBRUSH  hbrOld;
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    SetBkMode(plb->hdc, OPAQUE);

    //
    // Get brush & colors
    //
    if ((plb->spwnd->spwndParent == NULL) ||
        (REBASEPWND(plb->spwnd, spwndParent) == _GetDesktopWindow())) {
        ThreadLock(plb->spwndParent, &tlpwndParent);
        hbr = GetControlColor(HW(plb->spwndParent), HWq(plb->spwnd),
                              plb->hdc, WM_CTLCOLORLISTBOX);
        ThreadUnlock(&tlpwndParent);
    } else
        hbr = GetControlBrush(HWq(plb->spwnd), plb->hdc, WM_CTLCOLORLISTBOX);

    //
    // Select brush into dc
    //
    if (hbr != NULL) {
        hbrOld = SelectObject(plb->hdc, hbr);
        if (phbrOld)
            *phbrOld = hbrOld;
    }

    return(hbr);
}


/***************************************************************************\
*
*  LBInitDC()
*
*  Initializes dc for listbox
*
\***************************************************************************/
void LBInitDC(PLBIV plb)
{
    RECT    rc;

    // Set font
    if (plb->hFont)
        SelectObject(plb->hdc, plb->hFont);

    // Set clipping area
    _GetClientRect(plb->spwnd, &rc);
    IntersectClipRect(plb->hdc, rc.left, rc.top, rc.right, rc.bottom);

    OffsetWindowOrgEx(plb->hdc, plb->xOrigin, 0, NULL);
}


/***************************************************************************\
* LBGetDC
*
* Returns a DC which can be used by a list box even if parentDC is in effect
*
* History:
\***************************************************************************/

BOOL LBGetDC(
    PLBIV plb)
{
    if (plb->hdc)
        return(FALSE);

    plb->hdc = NtUserGetDC(HWq(plb->spwnd));

    LBInitDC(plb);

    return TRUE;
}

/***************************************************************************\
*
*  LBTermDC()
*
*  Cleans up when done with listbox dc.
*
\***************************************************************************/
void LBTermDC(PLBIV plb)
{
    if (plb->hFont)
        SelectObject(plb->hdc, ghFontSys);
}



/***************************************************************************\
* LBReleaseDC
*
* History:
\***************************************************************************/

void LBReleaseDC(
    PLBIV plb)
{
    LBTermDC(plb);
    NtUserReleaseDC(HWq(plb->spwnd), plb->hdc);
    plb->hdc = NULL;
}


/***************************************************************************\
* LBGetItemRect
*
* Return the rectangle that the item will be drawn in with respect to the
* listbox window.  Returns TRUE if any portion of the item's rectangle
* is visible (ie. in the listbox client rect) else returns FALSE.
*
* History:
\***************************************************************************/

BOOL LBGetItemRect(
    PLBIV plb,
    INT sItem,
    LPRECT lprc)
{
    INT sTmp;
    int clientbottom;

    /*
     * Always allow an item number of 0 so that we can draw the caret which
     * indicates the listbox has the focus even though it is empty.

     * FreeHand 3.1 passes in -1 as the itemNumber and expects
     * a non-null rectangle. So we check for -1 specifically.
     * BUGTAG: Fix for Bug #540 --Win95B-- SANKAR -- 2/20/95 --
     */

    if (sItem && (sItem != -1) && ((UINT)sItem >= (UINT)plb->cMac))
    {
        SetRectEmpty(lprc);
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return (LB_ERR);
    }

    _GetClientRect(plb->spwnd, lprc);

    if (plb->fMultiColumn) {

        /*
         * itemHeight * sItem mod number ItemsPerColumn (itemsPerColumn)
         */
        lprc->top = plb->cyChar * (sItem % plb->itemsPerColumn);
        lprc->bottom = lprc->top + plb->cyChar  /*+(plb->OwnerDraw ? 0 : 1)*/;

        UserAssert(plb->itemsPerColumn);

        if (plb->fRightAlign) {
            lprc->right = lprc->right - plb->cxColumn *
                 ((sItem / plb->itemsPerColumn) - (plb->iTop / plb->itemsPerColumn));

            lprc->left = lprc->right - plb->cxColumn;
        } else {
            /*
             * Remember, this is integer division here...
             */
            lprc->left += plb->cxColumn *
                      ((sItem / plb->itemsPerColumn) - (plb->iTop / plb->itemsPerColumn));

            lprc->right = lprc->left + plb->cxColumn;
        }
    } else if (plb->OwnerDraw == OWNERDRAWVAR) {

        /*
         * Var height owner draw
         */
        lprc->right += plb->xOrigin;
        clientbottom = lprc->bottom;

        if (sItem >= plb->iTop) {
            for (sTmp = plb->iTop; sTmp < sItem; sTmp++) {
                lprc->top = lprc->top + LBGetVariableHeightItemHeight(plb, sTmp);
            }

            /*
             * If item number is 0, it may be we are asking for the rect
             * associated with a nonexistant item so that we can draw a caret
             * indicating focus on an empty listbox.
             */
            lprc->bottom = lprc->top + (sItem < plb->cMac ? LBGetVariableHeightItemHeight(plb, sItem) : plb->cyChar);
            return (lprc->top < clientbottom);
        } else {

            /*
             * Item we want the rect of is before plb->iTop.  Thus, negative
             * offsets for the rect and it is never visible.
             */
            for (sTmp = sItem; sTmp < plb->iTop; sTmp++) {
                lprc->top = lprc->top - LBGetVariableHeightItemHeight(plb, sTmp);
            }
            lprc->bottom = lprc->top + LBGetVariableHeightItemHeight(plb, sItem);
            return FALSE;
        }
    } else {

        /*
         * For fixed height listboxes
         */
        if (plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw) && plb->fHorzBar)
            lprc->right += plb->xOrigin + (plb->xRightOrigin - plb->xOrigin);
        else
            lprc->right += plb->xOrigin;
        lprc->top = (sItem - plb->iTop) * plb->cyChar;
        lprc->bottom = lprc->top + plb->cyChar;
    }

    return (sItem >= plb->iTop) &&
            (sItem < (plb->iTop + CItemInWindow(plb, TRUE)));
}


/***************************************************************************\
*
*  LBPrintCallback
*
*  Called back from DrawState()
*
\***************************************************************************/
BOOL CALLBACK LBPrintCallback(
    HDC hdc,
    LPARAM lData,
    WPARAM wData,
    int cx,
    int cy)
{
    LPWSTR  lpstr = (LPWSTR)lData;
    PLBIV   plb = (PLBIV)wData;
    int     xStart;
    UINT    cLen;
    RECT    rc;
    UINT    oldAlign;

    if (!lpstr) {
        return FALSE;
    }

    if (plb->fMultiColumn)
        xStart = 0;
    else
        xStart = 2;

    if (plb->fRightAlign) {
        oldAlign = SetTextAlign(hdc, TA_RIGHT | GetTextAlign(hdc));
        xStart = cx - xStart;
    }

    cLen = wcslen(lpstr);

    if (plb->fUseTabStops) {
        TabTextOut(hdc, xStart, 0, lpstr, cLen,
            (plb->iTabPixelPositions ? plb->iTabPixelPositions[0] : 0),
            (plb->iTabPixelPositions ? (LPINT)&plb->iTabPixelPositions[1] : NULL),
            plb->fRightAlign ? cx : 0, TRUE, GetTextCharset(plb->hdc));
    } else {
        rc.left     = 0;
        rc.top      = 0;
        rc.right    = cx;
        rc.bottom   = cy;

        if (plb->wMultiple)
            ExtTextOut(hdc, xStart, 0, ETO_OPAQUE, &rc, lpstr, cLen, NULL);
        else if (plb->fMultiColumn)
            ExtTextOut(hdc, xStart, 0, ETO_CLIPPED, &rc, lpstr, cLen, NULL);
        else {
            ExtTextOut(hdc, xStart, 0, 0, NULL, lpstr, cLen, NULL);

            /*
             * When the listbox is in the incremental search mode and the item
             * is highlighted (so we only draw in the current item), draw the
             * caret for search indication.
             */
            if ((plb->iTypeSearch != 0) && (plb->OwnerDraw == 0) &&
                    (GetBkColor(hdc) == SYSRGB(HIGHLIGHT))) {
                SIZE size;
                GetTextExtentPointW(hdc, lpstr, plb->iTypeSearch, &size);
                PatBlt(hdc, xStart + size.cx - 1, 1, 1, cy - 2, DSTINVERT);
            }
        }
    }

    if (plb->fRightAlign)
        SetTextAlign(hdc, oldAlign);

    return(TRUE);
}


/***************************************************************************\
* xxxLBDrawLBItem
*
* History:
\***************************************************************************/

void xxxLBDrawLBItem(
    PLBIV plb,
    INT sItem,
    LPRECT lprect,
    BOOL fHilite,
    HBRUSH hbr)
{
    LPWSTR lpstr;
    DWORD rgbSave;
    DWORD rgbBkSave;
    UINT    uFlags;
    HDC     hdc = plb->hdc;
    UINT  oldAlign;

    CheckLock(plb->spwnd);

    /*
     * If the item is selected, then fill with highlight color
     */
    if (fHilite) {
        FillRect(hdc, lprect, SYSHBR(HIGHLIGHT));
        rgbBkSave = SetBkColor(hdc, SYSRGB(HIGHLIGHT));
        rgbSave = SetTextColor(hdc, SYSRGB(HIGHLIGHTTEXT));
    } else {

        /*
         * If fUseTabStops, we must fill the background, because later we use
         * LBTabTheTextOutForWimps(), which fills the background only partially
         * Fix for Bug #1509 -- 01/25/91 -- SANKAR --
         */
        if ((hbr != NULL) && ((sItem == plb->iSelBase) || (plb->fUseTabStops))) {
            FillRect(hdc, lprect, hbr);
        }
    }

    uFlags = DST_COMPLEX;
    lpstr = GetLpszItem(plb, sItem);

    if (TestWF(plb->spwnd, WFDISABLED)) {
        if ((COLORREF)SYSRGB(GRAYTEXT) != GetBkColor(hdc))
            SetTextColor(hdc, SYSRGB(GRAYTEXT));
        else
            uFlags |= DSS_UNION;
    }

    if (plb->fRightAlign)
        uFlags |= DSS_RIGHT;

    if (plb->fRtoLReading)
        oldAlign = SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));

    DrawState(hdc, SYSHBR(WINDOWTEXT),
        LBPrintCallback,
        (LPARAM)lpstr,
        (WPARAM)plb,
        lprect->left,
        lprect->top,
        lprect->right-lprect->left,
        lprect->bottom-lprect->top,
        uFlags);

    if (plb->fRtoLReading)
        SetTextAlign(hdc, oldAlign);

    if (fHilite) {
        SetTextColor(hdc, rgbSave);
        SetBkColor(hdc, rgbBkSave);
    }
}


/***************************************************************************\
*
* LBSetCaret()
*
\***************************************************************************/
void xxxLBSetCaret(PLBIV plb, BOOL fSetCaret)
{
    RECT    rc;
    BOOL    fNewDC;

    if (plb->fCaret && ((BOOL) plb->fCaretOn != !!fSetCaret)) {
        if (IsLBoxVisible(plb)) {
            /* Turn the caret (located at plb->iSelBase) on */
            fNewDC = LBGetDC(plb);

            LBGetItemRect(plb, plb->iSelBase, &rc);

            if (fNewDC) {
                SetBkColor(plb->hdc, SYSRGB(WINDOW));
                SetTextColor(plb->hdc, SYSRGB(WINDOWTEXT));
            }

            if (plb->OwnerDraw) {
                /* Fill in the drawitem struct */
                UINT itemState = (fSetCaret) ? ODS_FOCUS : 0;

                if (IsSelected(plb, plb->iSelBase, HILITEONLY))
                    itemState |= ODS_SELECTED;

                xxxLBoxDrawItem(plb, plb->iSelBase, ODA_FOCUS, itemState, &rc);
            } else if (!TestWF(plb->spwnd, WEFPUIFOCUSHIDDEN)) {
                COLORREF crBk = SetBkColor(plb->hdc, SYSRGB(WINDOW));
                COLORREF crText = SetTextColor(plb->hdc, SYSRGB(WINDOWTEXT));

                DrawFocusRect(plb->hdc, &rc);

                SetBkColor(plb->hdc, crBk);
                SetTextColor(plb->hdc, crText);
            }

            if (fNewDC)
                LBReleaseDC(plb);
        }
        plb->fCaretOn = !!fSetCaret;
    }
}


/***************************************************************************\
* IsSelected
*
* History:
* 16-Apr-1992 beng      The NODATA listbox case
\***************************************************************************/

BOOL IsSelected(
    PLBIV plb,
    INT sItem,
    UINT wOpFlags)
{
    LPBYTE lp;

    if ((sItem >= plb->cMac) || (sItem < 0)) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
//        return LB_ERR;
        return(FALSE);
    }

    if (plb->wMultiple == SINGLESEL) {
        return (sItem == plb->iSel);
    }

    lp = plb->rgpch + sItem +
             (plb->cMac * (plb->fHasStrings
                                ? sizeof(LBItem)
                                : (plb->fHasData
                                    ? sizeof(LBODItem)
                                    : 0)));
    sItem = *lp;

    if (wOpFlags == HILITEONLY) {
        sItem >>= 4;
    } else {
        sItem &= 0x0F;  /* SELONLY */
    }

    return sItem;
}


/***************************************************************************\
* CItemInWindow
*
* Returns the number of items which can fit in a list box.  It
* includes the partially visible one at the bottom if fPartial is TRUE. For
* var height ownerdraw, return the number of items visible starting at iTop
* and going to the bottom of the client rect.
*
* History:
\***************************************************************************/

INT CItemInWindow(
    PLBIV plb,
    BOOL fPartial)
{
    RECT rect;

    if (plb->OwnerDraw == OWNERDRAWVAR) {
        return CItemInWindowVarOwnerDraw(plb, fPartial);
    }

    if (plb->fMultiColumn) {
        return plb->itemsPerColumn * (plb->numberOfColumns + (fPartial ? 1 : 0));
    }

    _GetClientRect(plb->spwnd, &rect);

    /*
     * fPartial must be considered only if the listbox height is not an
     * integral multiple of character height.
     * A part of the fix for Bug #3727 -- 01/14/91 -- SANKAR --
     */
    UserAssert(plb->cyChar);
    return (INT)((rect.bottom / plb->cyChar) +
            ((rect.bottom % plb->cyChar)? (fPartial ? 1 : 0) : 0));
}


/***************************************************************************\
* xxxLBoxCtlScroll
*
* Handles vertical scrolling of the listbox
*
* History:
\***************************************************************************/

void xxxLBoxCtlScroll(
    PLBIV plb,
    INT cmd,
    int yAmt)
{
    INT iTopNew;
    INT cItemPageScroll;
    DWORD dwTime = 0;

    CheckLock(plb->spwnd);

    if (plb->fMultiColumn) {

        /*
         * Don't allow vertical scrolling on a multicolumn list box.  Needed
         * in case app sends WM_VSCROLL messages to the listbox.
         */
        return;
    }

    cItemPageScroll = plb->cItemFullMax;

    if (cItemPageScroll > 1)
        cItemPageScroll--;

    if (plb->cMac) {
        iTopNew = plb->iTop;
        switch (cmd) {
        case SB_LINEUP:
            dwTime = yAmt;
            iTopNew--;
            break;

        case SB_LINEDOWN:
            dwTime = yAmt;
            iTopNew++;
            break;

        case SB_PAGEUP:
            if (plb->OwnerDraw == OWNERDRAWVAR) {
                iTopNew = LBPage(plb, plb->iTop, FALSE);
            } else {
                iTopNew -= cItemPageScroll;
            }
            break;

        case SB_PAGEDOWN:
            if (plb->OwnerDraw == OWNERDRAWVAR) {
                iTopNew = LBPage(plb, plb->iTop, TRUE);
            } else {
                iTopNew += cItemPageScroll;
            }
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION: {

            /*
             * If the listbox contains more than 0xFFFF items
             * it means that the scrolbar can return a position
             * that cannot fit in a WORD (16 bits), so use
             * GetScrollInfo (which is slower) in this case.
             */
            if (plb->cMac < 0xFFFF) {
                iTopNew = yAmt;
            } else {
                SCROLLINFO si;

                si.cbSize   = sizeof(SCROLLINFO);
                si.fMask    = SIF_TRACKPOS;

                GetScrollInfo( HWq(plb->spwnd), SB_VERT, &si);

                iTopNew = si.nTrackPos;
            }
            break;
        }
        case SB_TOP:
            iTopNew = 0;
            break;

        case SB_BOTTOM:
            iTopNew = plb->cMac - 1;
            break;

        case SB_ENDSCROLL:
            plb->fSmoothScroll = TRUE;
            xxxLBSetCaret(plb, FALSE);
            xxxLBShowHideScrollBars(plb);
            xxxLBSetCaret(plb, TRUE);
            return;
        }

        xxxNewITopEx(plb, iTopNew, dwTime);
    }
}

/***************************************************************************\
* LBGetScrollFlags
*
\***************************************************************************/

DWORD LBGetScrollFlags(PLBIV plb, DWORD dwTime)
{
    DWORD dwFlags;

    if (GetAppCompatFlags(NULL) & GACF_NOSMOOTHSCROLLING)
        goto NoSmoothScrolling;

    if (dwTime != 0) {
        dwFlags = MAKELONG(SW_SCROLLWINDOW | SW_SMOOTHSCROLL | SW_SCROLLCHILDREN, dwTime);
    } else if (TEST_EffectPUSIF(PUSIF_LISTBOXSMOOTHSCROLLING) && plb->fSmoothScroll) {
        dwFlags = SW_SCROLLWINDOW | SW_SMOOTHSCROLL | SW_SCROLLCHILDREN;
        plb->fSmoothScroll = FALSE;
    } else {
NoSmoothScrolling:
        dwFlags = SW_SCROLLWINDOW | SW_INVALIDATE | SW_ERASE | SW_SCROLLCHILDREN;
    }

    return dwFlags;
}

/***************************************************************************\
* xxxLBoxCtlHScroll
*
* Supports horizontal scrolling of listboxes
*
* History:
\***************************************************************************/

void xxxLBoxCtlHScroll(
    PLBIV plb,
    INT cmd,
    int xAmt)
{
    int newOrigin = plb->xOrigin;
    int oldOrigin = plb->xOrigin;
    int windowWidth;
    RECT rc;
    DWORD dwTime = 0;

    CheckLock(plb->spwnd);

    /*
     * Update the window so that we don't run into problems with invalid
     * regions during the horizontal scroll.
     */
    if (plb->fMultiColumn) {

        /*
         * Handle multicolumn scrolling in a separate segment
         */
        xxxLBoxCtlHScrollMultiColumn(plb, cmd, xAmt);
        return;
    }

    _GetClientRect(plb->spwnd, &rc);
    windowWidth = rc.right;

    if (plb->cMac) {

        switch (cmd) {
        case SB_LINEUP:
            dwTime = xAmt;
            newOrigin -= plb->cxChar;
            break;

        case SB_LINEDOWN:
            dwTime = xAmt;
            newOrigin += plb->cxChar;
            break;

        case SB_PAGEUP:
            newOrigin -= (windowWidth / 3) * 2;
            break;

        case SB_PAGEDOWN:
            newOrigin += (windowWidth / 3) * 2;
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            newOrigin = xAmt;
            break;

        case SB_TOP:
            newOrigin = 0;
            break;

        case SB_BOTTOM:
            newOrigin = plb->maxWidth;
            break;

        case SB_ENDSCROLL:
            plb->fSmoothScroll = TRUE;
            xxxLBSetCaret(plb, FALSE);
            xxxLBShowHideScrollBars(plb);
            xxxLBSetCaret(plb, TRUE);
            return;
        }

        xxxLBSetCaret(plb, FALSE);
        plb->xOrigin = newOrigin;
        plb->xOrigin = xxxSetLBScrollParms(plb, SB_HORZ);

        if ((cmd == SB_BOTTOM) && plb->fRightAlign) {
            /*
             * so we know where to draw from.
             */
            plb->xRightOrigin = plb->xOrigin;
        }

        if(oldOrigin != plb->xOrigin)  {
            HWND hwnd = HWq(plb->spwnd);
            DWORD dwFlags;

            dwFlags = LBGetScrollFlags(plb, dwTime);
            ScrollWindowEx(hwnd, oldOrigin-plb->xOrigin,
                0, NULL, &rc, NULL, NULL, dwFlags);
            UpdateWindow(hwnd);
        }

        xxxLBSetCaret(plb, TRUE);
    } else {
        // this is a less-than-ideal fix for ImageMind ScreenSaver (Win95
        // B#8252) but it works and it doesn't hurt anybody -- JEFFBOG 10/28/94
        xxxSetLBScrollParms(plb, SB_HORZ);
    }
}


/***************************************************************************\
* xxxLBoxCtlPaint
*
* History:
\***************************************************************************/

void xxxLBPaint(
    PLBIV plb,
    HDC hdc,
    LPRECT lprcBounds)
{
    INT i;
    RECT rect;
    RECT    scratchRect;
    BOOL    fHilite;
    INT iLastItem;
    HBRUSH hbrSave = NULL;
    HBRUSH hbrControl;
    BOOL fCaretOn;
    RECT    rcBounds;
    HDC     hdcSave;

    CheckLock(plb->spwnd);

    if (lprcBounds == NULL) {
        lprcBounds = &rcBounds;
        _GetClientRect(plb->spwnd, lprcBounds);
    }

    hdcSave = plb->hdc;
    plb->hdc = hdc;

    // Initialize dc.
    LBInitDC(plb);

    // Turn caret off
    if (fCaretOn = plb->fCaretOn)
        xxxLBSetCaret(plb, FALSE);

    hbrSave = NULL;
    hbrControl = xxxLBGetBrush(plb, &hbrSave);

    // Get listbox's client
    _GetClientRect(plb->spwnd, &rect);

    // Adjust width of client rect for scrolled amount
    // fix for #140, t-arthb
    if (plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw) && plb->fHorzBar)
        rect.right += plb->xOrigin + (plb->xRightOrigin - plb->xOrigin);
    else
        rect.right += plb->xOrigin;

    // Get the index of the last item visible on the screen. This is also
    // valid for var height ownerdraw.
    iLastItem = plb->iTop + CItemInWindow(plb,TRUE);
    iLastItem = min(iLastItem, plb->cMac - 1);

    // Fill in the background of the listbox if it's an empty listbox
    // or if we're doing a control print
    if (iLastItem == -1)
        FillRect(plb->hdc, &rect, hbrControl);


    // Allow AnimateWindow() catch the apps that do not use our DC when
    // drawing the list box
    SetBoundsRect(plb->hdc, NULL, DCB_RESET | DCB_ENABLE);

    for (i = plb->iTop; i <= iLastItem; i++) {

        /*
         * Note that rect contains the clientrect from when we did the
         * _GetClientRect so the width is correct.  We just need to adjust
         * the top and bottom of the rectangle to the item of interest.
         */
        rect.bottom = rect.top + plb->cyChar;

        if ((UINT)i < (UINT)plb->cMac) {

            /*
             * If var height, get the rectangle for the item.
             */
            if (plb->OwnerDraw == OWNERDRAWVAR || plb->fMultiColumn) {
                LBGetItemRect(plb, i, &rect);
            }

            if (IntersectRect(&scratchRect, lprcBounds, &rect)) {
                fHilite = !plb->fNoSel && IsSelected(plb, i, HILITEONLY);

                if (plb->OwnerDraw) {

                    /*
                     * Fill in the drawitem struct
                     */
                    xxxLBoxDrawItem(plb, i, ODA_DRAWENTIRE,
                            (UINT)(fHilite ? ODS_SELECTED : 0), &rect);
                } else {
                    xxxLBDrawLBItem(plb, i, &rect, fHilite, hbrControl);
                }
            }
        }
        rect.top = rect.bottom;
    }

    if (hbrSave != NULL)
        SelectObject(hdc, hbrSave);

    if (fCaretOn)
        xxxLBSetCaret(plb, TRUE);

    LBTermDC(plb);

    plb->hdc = hdcSave;
}


/***************************************************************************\
* ISelFromPt
*
* In the loword, returns the closest item number the pt is on. The high
* word is 0 if the point is within bounds of the listbox client rect and is
* 1 if it is outside the bounds.  This will allow us to make the invertrect
* disappear if the mouse is outside the listbox yet we can still show the
* outline around the item that would be selected if the mouse is brought back
* in bounds...
*
* History:
\***************************************************************************/

BOOL ISelFromPt(
    PLBIV plb,
    POINT pt,
    LPDWORD piItem)
{
    RECT rect;
    int y;
    UINT mouseHighWord = 0;
    INT sItem;
    INT sTmp;

    _GetClientRect(plb->spwnd, &rect);

    if (pt.y < 0) {

        /*
         * Mouse is out of bounds above listbox
         */
        *piItem = plb->iTop;
        return TRUE;
    } else if ((y = pt.y) > rect.bottom) {
        y = rect.bottom;
        mouseHighWord = 1;
    }

    if (pt.x < 0 || pt.x > rect.right)
        mouseHighWord = 1;

    /*
     * Now just need to check if y mouse coordinate intersects item's rectangle
     */
    if (plb->OwnerDraw != OWNERDRAWVAR) {
        if (plb->fMultiColumn) {
            if (y < plb->itemsPerColumn * plb->cyChar) {
                if (plb->fRightAlign)
                    sItem = plb->iTop + (INT)((y / plb->cyChar) +
                            ((rect.right - pt.x) / plb->cxColumn) * plb->itemsPerColumn);
                else
                    sItem = plb->iTop + (INT)((y / plb->cyChar) +
                            (pt.x / plb->cxColumn) * plb->itemsPerColumn);

            } else {

                /*
                 * User clicked in blank space at the bottom of a column.
                 * Just select the last item in the column.
                 */
                mouseHighWord = 1;
                sItem = plb->iTop + (plb->itemsPerColumn - 1) +
                        (INT)((pt.x / plb->cxColumn) * plb->itemsPerColumn);
            }
        } else {
            sItem = plb->iTop + (INT)(y / plb->cyChar);
        }
    } else {

        /*
         * VarHeightOwnerdraw so we gotta do this the hardway...   Set the x
         * coordinate of the mouse down point to be inside the listbox client
         * rectangle since we no longer care about it.  This lets us use the
         * point in rect calls.
         */
        pt.x = 8;
        pt.y = y;
        for (sTmp = plb->iTop; sTmp < plb->cMac; sTmp++) {
            (void)LBGetItemRect(plb, sTmp, &rect);
            if (PtInRect(&rect, pt)) {
                *piItem = sTmp;
                return mouseHighWord;
            }
        }

        /*
         * Point was at the empty area at the bottom of a not full listbox
         */
        *piItem = plb->cMac - 1;
        return mouseHighWord;
    }

    /*
     * Check if user clicked on the blank area at the bottom of a not full list.
     * Assumes > 0 items in the listbox.
     */
    if (sItem > plb->cMac - 1) {
        mouseHighWord = 1;
        sItem = plb->cMac - 1;
    }

    *piItem = sItem;
    return mouseHighWord;
}


/***************************************************************************\
* SetSelected
*
* This is used for button initiated changes of selection state.
*
*  fSelected : TRUE  if the item is to be set as selected, FALSE otherwise
*
*  wOpFlags : HILITEONLY = Modify only the Display state (hi-nibble)
*             SELONLY    = Modify only the Selection state (lo-nibble)
*             HILITEANDSEL = Modify both of them;
*
* History:
* 16-Apr-1992 beng      The NODATA listbox case
\***************************************************************************/

void SetSelected(
    PLBIV plb,
    INT iSel,
    BOOL fSelected,
    UINT wOpFlags)
{
    LPSTR lp;
    BYTE cMask;
    BYTE cSelStatus;

    if (iSel < 0 || iSel >= plb->cMac)
        return;

    if (plb->wMultiple == SINGLESEL) {
        if (fSelected)
            plb->iSel = iSel;
    } else {
        cSelStatus = (BYTE)fSelected;
        switch (wOpFlags) {
        case HILITEONLY:

            /*
             * Mask out lo-nibble
             */
            cSelStatus = (BYTE)(cSelStatus << 4);
            cMask = 0x0F;
            break;
        case SELONLY:

            /*
             * Mask out hi-nibble
             */
            cMask = 0xF0;
            break;
        case HILITEANDSEL:

            /*
             * Mask the byte fully
             */
            cSelStatus |= (cSelStatus << 4);
            cMask = 0;
            break;
        }
        lp = (LPSTR)(plb->rgpch) + iSel +
                (plb->cMac * (plb->fHasStrings
                                ? sizeof(LBItem)
                                : (plb->fHasData ? sizeof(LBODItem) : 0)));

        *lp = (*lp & cMask) | cSelStatus;
    }
}


/***************************************************************************\
* LastFullVisible
*
* Returns the last fully visible item in the listbox. This is valid
* for ownerdraw var height and fixed height listboxes.
*
* History:
\***************************************************************************/

INT LastFullVisible(
    PLBIV plb)
{
    INT iLastItem;

    if (plb->OwnerDraw == OWNERDRAWVAR || plb->fMultiColumn) {
        iLastItem = plb->iTop + CItemInWindow(plb, FALSE) - 1;
        iLastItem = max(iLastItem, plb->iTop);
    } else {
        iLastItem = min(plb->iTop + plb->cItemFullMax - 1, plb->cMac - 1);
    }
    return iLastItem;
}


/***************************************************************************\
* xxxInvertLBItem
*
* History:
\***************************************************************************/

void xxxInvertLBItem(
    PLBIV plb,
    INT i,
    BOOL fHilite)  /* The new selection state of the item */
{
    RECT rect;
    BOOL fCaretOn;
    HBRUSH hbrControl;
    BOOL    fNewDC;

    CheckLock(plb->spwnd);

    // Skip if item isn't showing.
    if (plb->fNoSel || (i < plb->iTop) || (i >= (plb->iTop + CItemInWindow(plb, TRUE))))
        return;

    if (IsLBoxVisible(plb)) {
        LBGetItemRect(plb, i, &rect);

        /*
         * Only turn off the caret if it is on.  This avoids annoying caret
         * flicker when nesting xxxCaretOns and xxxCaretOffs.
         */
        if (fCaretOn = plb->fCaretOn) {
            xxxLBSetCaret(plb, FALSE);
        }

        fNewDC = LBGetDC(plb);

        hbrControl = xxxLBGetBrush(plb, NULL);

        if (!plb->OwnerDraw) {
            if (!fHilite) {
                FillRect(plb->hdc, &rect, hbrControl);
                hbrControl = NULL;
            }

            xxxLBDrawLBItem(plb, i, &rect, fHilite, hbrControl);
        } else {

            /*
             * We are ownerdraw so fill in the drawitem struct and send off
             * to the owner.
             */
            xxxLBoxDrawItem(plb, i, ODA_SELECT,
                    (UINT)(fHilite ? ODS_SELECTED : 0), &rect);
        }

        if (fNewDC)
            LBReleaseDC(plb);

        /*
         * Turn the caret back on only if it was originally on.
         */
        if (fCaretOn) {
            xxxLBSetCaret(plb, TRUE);
        }
    }
}


/***************************************************************************\
* xxxResetWorld
*
* Resets everyone's selection and hilite state except items in the
* range sStItem to sEndItem (Both inclusive).
*
* History:
\***************************************************************************/

void xxxResetWorld(
    PLBIV plb,
    INT iStart,
    INT iEnd,
    BOOL fSelect)
{
    INT i;
    INT iLastInWindow;
    BOOL fCaretOn;

    CheckLock(plb->spwnd);

    /*
     * If iStart and iEnd are not in correct order we swap them
     */

    if (iStart > iEnd) {
        i = iStart;
        iStart = iEnd;
        iEnd = i;
    }

    if (plb->wMultiple == SINGLESEL) {
        if (plb->iSel != -1 && ((plb->iSel < iStart) || (plb->iSel > iEnd))) {
            xxxInvertLBItem(plb, plb->iSel, fSelect);
            plb->iSel = -1;
        }
        return;
    }

    iLastInWindow = plb->iTop + CItemInWindow(plb, TRUE);

    if (fCaretOn = plb->fCaretOn)
        xxxLBSetCaret(plb, FALSE);

    for (i = 0; i < plb->cMac; i++) {
        if (i == iStart)
            // skip range to be preserved
            i = iEnd;
        else {
            if ((plb->iTop <= i) && (i <= iLastInWindow) &&
                (fSelect != IsSelected(plb, i, HILITEONLY)))
                // Only invert the item if it is visible and present Selection
                // state is different from what is required.
                xxxInvertLBItem(plb, i, fSelect);

            // Set all items outside of preserved range to unselected
            SetSelected(plb, i, fSelect, HILITEANDSEL);
        }
    }

    if (fCaretOn)
        xxxLBSetCaret(plb, TRUE);

}


/***************************************************************************\
* xxxNotifyOwner
*
* History:
\***************************************************************************/

void xxxNotifyOwner(
    PLBIV plb,
    INT sEvt)
{
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    ThreadLock(plb->spwndParent, &tlpwndParent);
    SendMessage(HW(plb->spwndParent), WM_COMMAND,
            MAKELONG(PTR_TO_ID(plb->spwnd->spmenu), sEvt), (LPARAM)HWq(plb->spwnd));
    ThreadUnlock(&tlpwndParent);
}


/***************************************************************************\
* xxxSetISelBase
*
* History:
\***************************************************************************/

void xxxSetISelBase(
    PLBIV plb,
    INT sItem)
{
    CheckLock(plb->spwnd);

    xxxLBSetCaret(plb, FALSE);
    plb->iSelBase = sItem;
    xxxLBSetCaret(plb, TRUE);

    xxxInsureVisible(plb, plb->iSelBase, FALSE);
    
    /*
     * We need to send this event even if the listbox isn't visible. See
     * bug #88548. Also see 355612.
     */
    if (_IsWindowVisible(plb->spwnd) || (GetFocus() == HWq(plb->spwnd))) {
        LBEvent(plb, EVENT_OBJECT_FOCUS, sItem);
    }
}


/***************************************************************************\
* xxxTrackMouse
*
* History:
\***************************************************************************/

void xxxTrackMouse(
    PLBIV plb,
    UINT wMsg,
    POINT pt)
{
    INT iSelFromPt;
    INT iSelTemp;
    BOOL mousetemp;
    BOOL fMouseInRect;
    RECT rcClient;
    UINT wModifiers = 0;
    BOOL fSelected;
    UINT uEvent = 0;
    INT trackPtRetn;
    HWND hwnd = HWq(plb->spwnd);
    TL tlpwndEdit;
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    /*
     * Optimization:  do nothing if mouse not captured
     */
    if ((wMsg != WM_LBUTTONDOWN) && (wMsg != WM_LBUTTONDBLCLK)) {
        if (!plb->fCaptured) {
            return;
        }
        /*
         * If we are processing a WM_MOUSEMOVE but the mouse has not moved
         * from the previous point, then we may be dealing with a mouse
         * "jiggle" sent from the kernel (see zzzInvalidateDCCache). If we
         * process this, we will snap the listbox selection back to where
         * the mouse cursor is pointing, even if the user has not touched
         * the mouse. Windows NT Bug #220722.
         *
         * Some apps (like MSMoney98) rely on this, so we need to check the
         * SRVIF_LASTRITWASKEYBOARD flag. Windows NT Bug #244450.
         */
        if (wMsg == WM_MOUSEMOVE && RtlEqualMemory(&pt, &(plb->ptPrev), sizeof(POINT))
            && TEST_SRVIF(SRVIF_LASTRITWASKEYBOARD)) {
                RIPMSG0(RIP_WARNING, "xxxTrackMouse ignoring WM_MOUSEMOVE with no mouse movement");
                return;
        }
    }

    mousetemp = ISelFromPt(plb, pt, &iSelFromPt);

    /*
     * If we allow the user to cancel his selection then fMouseInRect is true if
     * the mouse is in the listbox client area otherwise it is false.  If we
     * don't allow the user to cancel his selection, then fMouseInRect will
     * always be true.  This allows us to implement cancelable selection
     * listboxes ie.  The selection reverts to the origional one if the user
     * releases the mouse outside of the listbox.
     */
    fMouseInRect = !mousetemp || !plb->pcbox;

    _GetClientRect(plb->spwnd, &rcClient);

    switch (wMsg) {
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
        /*
         * We want to divert mouse clicks.  If the user clicks outside
         * of a dropped down listbox, we want to popup it up, using
         * the current selection.
         */
        if (plb->fCaptured) {
            /*
             * If plb->pcbox is NULL, this is a listbox that
             * received a WM_LBUTTONDOWN again w/o receiving
             * a WM_LBUTTONUP for the previous WM_LBUTTONDOWN
             * bug
             */
            if (plb->pcbox && mousetemp) {
                _ClientToScreen(plb->spwnd, &pt);

                if (!PtInRect(KPRECT_TO_PRECT(&plb->spwnd->rcWindow), pt)) {
                    /*
                     * Cancel selection if clicked outside of combo;
                     * Accept if clicked on combo button or item.
                     */
                    xxxCBHideListBoxWindow(plb->pcbox, TRUE, FALSE);
                } else if (!PtInRect(KPRECT_TO_PRECT(&plb->spwnd->rcClient), pt)) {
                    /*
                     * Let it pass through.  Save, restore capture in
                     * case user is clicking on scrollbar.
                     */
                    plb->fCaptured = FALSE;
                    NtUserReleaseCapture();

                    SendMessageWorker(plb->spwnd, WM_NCLBUTTONDOWN,
                        FindNCHit(plb->spwnd, POINTTOPOINTS(pt)),
                        MAKELONG(pt.x, pt.y), FALSE);

                    NtUserSetCapture(hwnd);
                    plb->fCaptured = TRUE;
                }

                break;
            }

            plb->fCaptured = FALSE;
            NtUserReleaseCapture();
        }

        if (plb->pcbox) {

            /*
             * If this listbox is in a combo box, set the focus to the combo
             * box window so that the edit control/static text is also
             * activated
             */
            ThreadLock(plb->pcbox->spwndEdit, &tlpwndEdit);
            NtUserSetFocus(HWq(plb->pcbox->spwndEdit));
            ThreadUnlock(&tlpwndEdit);
        } else {

            /*
             * Get the focus if the listbox is clicked in and we don't
             * already have the focus.  If we don't have the focus after
             * this, run away...
             */
            NtUserSetFocus(hwnd);
            if (!plb->fCaret)
                return;
        }

        if (plb->fAddSelMode) {

            /*
             * If it is in "Add" mode, quit it using shift f8 key...
             * However, since we can't send shift key state, we have to turn
             * this off directly...
             */

            /*
             *SendMessage(HW(plb->spwnd),WM_KEYDOWN, (UINT)VK_F8, 0L);
             */

            /*
             * Switch off the Caret blinking
             */
            NtUserKillTimer(hwnd, IDSYS_CARET);

            /*
             * Make sure the caret does not vanish
             */
            xxxLBSetCaret(plb, TRUE);
            plb->fAddSelMode = FALSE;
        }

        if (!plb->cMac) {

            /*
             * Don't even bother handling the mouse if no items in the
             * listbox since the code below assumes >0 items in the
             * listbox.  We will just get the focus (the statement above) if
             * we don't already have it.
             */
            break;
        }

        if (mousetemp) {

            /*
             * Mouse down occurred in a empty spot.  Just ignore it.
             */
            break;
        }

        plb->fDoubleClick = (wMsg == WM_LBUTTONDBLCLK);

        if (!plb->fDoubleClick) {

            /*
             * This hack put in for the shell.  Tell the shell where in the
             * listbox the user clicked and at what item number.  The shell
             * can return 0 to continue normal mouse tracking or TRUE to
             * abort mouse tracking.
             */
            ThreadLock(plb->spwndParent, &tlpwndParent);
            trackPtRetn = (INT)SendMessage(HW(plb->spwndParent), WM_LBTRACKPOINT,
                    (DWORD)iSelFromPt, MAKELONG(pt.x+plb->xOrigin, pt.y));
            ThreadUnlock(&tlpwndParent);
            if (trackPtRetn) {
                if (trackPtRetn == 2) {

                    /*
                     * Ignore double clicks
                     */
                    NtUserCallNoParam(SFI__RESETDBLCLK);
                }
                return;
            }
        }

        if (plb->pcbox) {

            /*
             * Save the last selection if this is a combo box.  So that it
             * can be restored if user decides to cancel the selection by up
             * clicking outside the listbox.
             */
            plb->iLastSelection = plb->iSel;
        }

        /*
         * Save for timer
         */
        plb->ptPrev = pt;

        plb->fMouseDown = TRUE;
        NtUserSetCapture(hwnd);
        plb->fCaptured = TRUE;

        if (plb->fDoubleClick) {

            /*
             * Double click.  Fake a button up and exit
             */
            xxxTrackMouse(plb, WM_LBUTTONUP, pt);
            return;
        }

        /*
         * Set the system timer so that we can autoscroll if the mouse is
         * outside the bounds of the listbox rectangle
         */
        NtUserSetTimer(hwnd, IDSYS_SCROLL, gpsi->dtScroll, NULL);



        /*
         * If extended multiselection listbox, are any modifier key pressed?
         */
        if (plb->wMultiple == EXTENDEDSEL) {
            if (GetKeyState(VK_SHIFT) < 0)
                wModifiers = SHIFTDOWN;
            if (GetKeyState(VK_CONTROL) < 0)
                wModifiers += CTLDOWN;

            /*
             * Please Note that (SHIFTDOWN + CTLDOWN) == (SHCTLDOWN)
             */
        }


        switch (wModifiers) {
        case NOMODIFIER:
MouseMoveHandler:
            if (plb->iSelBase != iSelFromPt) {
                xxxLBSetCaret(plb, FALSE);
            }

            /*
             * We only look at the mouse if the point it is pointing to is
             * not selected.  Since we are not in ExtendedSelMode, anywhere
             * the mouse points, we have to set the selection to that item.
             * Hence, if the item isn't selected, it means the mouse never
             * pointed to it before so we can select it.  We ignore already
             * selected items so that we avoid flashing the inverted
             * selection rectangle.  Also, we could get WM_SYSTIMER simulated
             * mouse moves which would cause flashing otherwise...
             */

            iSelTemp = (fMouseInRect ? iSelFromPt : -1);

            /*
             * If the LB is either SingleSel or Extended multisel, clear all
             * old selections except the new one being made.
             */
            if (plb->wMultiple != MULTIPLESEL) {
                xxxResetWorld(plb, iSelTemp, iSelTemp, FALSE);
                /*
                 * This will be TRUE if iSelTemp isn't -1 (like below)
                 * and also if it is but there is a current selection.
                 */
                if ((iSelTemp == -1) && (plb->iSel != -1)) {
                    uEvent = EVENT_OBJECT_SELECTIONREMOVE;
                }
            }

            fSelected = IsSelected(plb, iSelTemp, HILITEONLY);
            if (iSelTemp != -1) {

                /*
                 * If it is MULTIPLESEL, then toggle; For others, only if
                 * not selected already, select it.
                 */
                if (((plb->wMultiple == MULTIPLESEL) && (wMsg != WM_LBUTTONDBLCLK)) || !fSelected) {
                    SetSelected(plb, iSelTemp, !fSelected, HILITEANDSEL);

                    /*
                     * And invert it
                     */
                    xxxInvertLBItem(plb, iSelTemp, !fSelected);
                    fSelected = !fSelected;  /* Set the new state */
                    if (plb->wMultiple == MULTIPLESEL) {
                        uEvent = (fSelected ? EVENT_OBJECT_SELECTIONADD :
                                EVENT_OBJECT_SELECTIONREMOVE);
                    } else {
                        uEvent = EVENT_OBJECT_SELECTION;
                    }
                }
            }

            /*
             * We have to set iSel in case this is a multisel lb.
             */
            plb->iSel = iSelTemp;

            /*
             * Set the new anchor point
             */
            plb->iMouseDown = iSelFromPt;
            plb->iLastMouseMove = iSelFromPt;
            plb->fNewItemState = fSelected;

            break;
        case SHIFTDOWN:

            /*
             * This is so that we can handle click and drag for multisel
             * listboxes using Shift modifier key .
             */
            plb->iLastMouseMove = plb->iSel = iSelFromPt;



            /*
             * Check if an anchor point already exists
             */
            if (plb->iMouseDown == -1) {
                plb->iMouseDown = iSelFromPt;

                /*
                 * Reset all the previous selections
                 */
                xxxResetWorld(plb, plb->iMouseDown, plb->iMouseDown, FALSE);

                /*
                 * Select the current position
                 */
                SetSelected(plb, plb->iMouseDown, TRUE, HILITEANDSEL);
                xxxInvertLBItem(plb, plb->iMouseDown, TRUE);
                /*
                 * We are changing the selction to this item only
                 */
                uEvent = EVENT_OBJECT_SELECTION;
            } else {

                /*
                 * Reset all the previous selections
                 */
                xxxResetWorld(plb, plb->iMouseDown, plb->iMouseDown, FALSE);

                /*
                 * Select all items from anchor point upto current click pt
                 */
                xxxAlterHilite(plb, plb->iMouseDown, iSelFromPt, HILITE, HILITEONLY, FALSE);
                uEvent = EVENT_OBJECT_SELECTIONWITHIN;
            }
            plb->fNewItemState = (UINT)TRUE;
            break;

        case CTLDOWN:

            /*
             * This is so that we can handle click and drag for multisel
             * listboxes using Control modifier key.
             */

            /*
             * Reset the anchor point to the current point
             */
            plb->iMouseDown = plb->iLastMouseMove = plb->iSel = iSelFromPt;

            /*
             * The state we will be setting items to
             */
            plb->fNewItemState = (UINT)!IsSelected(plb, iSelFromPt, (UINT)HILITEONLY);

            /*
             * Toggle the current point
             */
            SetSelected(plb, iSelFromPt, plb->fNewItemState, HILITEANDSEL);
            xxxInvertLBItem(plb, iSelFromPt, plb->fNewItemState);
            uEvent = (plb->fNewItemState ? EVENT_OBJECT_SELECTIONADD :
                    EVENT_OBJECT_SELECTIONREMOVE);
            break;

        case SHCTLDOWN:

            /*
             * This is so that we can handle click and drag for multisel
             * listboxes using Shift and Control modifier keys.
             */

            /*
             * Preserve all the previous selections
             */

            /*
             * Deselect only the selection connected with the last
             * anchor point; If the last anchor point is associated with a
             * de-selection, then do not do it
             */
            if (plb->fNewItemState) {
                xxxAlterHilite(plb, plb->iMouseDown, plb->iLastMouseMove, FALSE, HILITEANDSEL, FALSE);
            }
            plb->iLastMouseMove = plb->iSel = iSelFromPt;

            /*
             * Check if an anchor point already exists
             */
            if (plb->iMouseDown == -1) {

                /*
                 * No existing anchor point; Make the current pt as anchor
                 */
                plb->iMouseDown = iSelFromPt;
            }

            /*
             * If one exists preserve the most recent anchor point
             */

            /*
             * The state we will be setting items to
             */
            plb->fNewItemState = (UINT)IsSelected(plb, plb->iMouseDown, HILITEONLY);

            /*
             * Select all items from anchor point upto current click pt
             */
            xxxAlterHilite(plb, plb->iMouseDown, iSelFromPt, plb->fNewItemState, HILITEONLY, FALSE);
            uEvent = EVENT_OBJECT_SELECTIONWITHIN;
            break;
        }

        /*
         * Set the new base point (the outline frame caret).  We do the check
         * first to avoid flashing the caret unnecessarly.
         */
        if (plb->iSelBase != iSelFromPt) {

            /*
             * Since xxxSetISelBase always turns on the caret, we don't need to
             * do it here...
             */
            xxxSetISelBase(plb, iSelFromPt);
        }

        /*
         * SetISelBase will change the focus and send a focus event.
         * Then we send the selection event.
         */
        if (uEvent) {
            LBEvent(plb, uEvent, iSelFromPt);
        }
        if (wMsg == WM_LBUTTONDOWN && TestWF(plb->spwnd, WEFDRAGOBJECT)) {
            if (NtUserDragDetect(hwnd, pt)) {

                /*
                 * User is trying to drag object...
                 */

                /*
                 *  Fake an up click so that the item is selected...
                 */
                xxxTrackMouse(plb, WM_LBUTTONUP, pt);

                /*
                 * Notify parent
                 * #ifndef WIN16 (32-bit Windows), plb->iSelBase gets
                 * zero-extended to LONG wParam automatically by the compiler.
                 */
                ThreadLock(plb->spwndParent, &tlpwndParent);
                SendMessage(HW(plb->spwndParent), WM_BEGINDRAG, plb->iSelBase,
                        (LPARAM)hwnd);
                ThreadUnlock(&tlpwndParent);
            } else {
                xxxTrackMouse(plb, WM_LBUTTONUP, pt);
            }
            return;
        }
        break;

    case WM_MOUSEMOVE: {
        int dist;
        int iTimer;

        /*
         * Save for timer.
         */
        plb->ptPrev = pt;
        /*
         * Autoscroll listbox if mouse button is held down and mouse is
         * moved outside of the listbox
         */
        if (plb->fMouseDown) {
            if (plb->fMultiColumn) {
                if ((pt.x < 0) || (pt.x >= rcClient.right - 1)) {
                    /*
                     * Reset timer interval based on distance from listbox.
                     * use a longer default interval because each multicolumn
                     * scrolling increment is larger
                     */
                    dist = pt.x < 0 ? -pt.x : (pt.x - rcClient.right + 1);
                    iTimer = ((gpsi->dtScroll * 3) / 2) - ((WORD) dist << 4);

                    if (plb->fRightAlign)
                        xxxLBoxCtlHScrollMultiColumn(plb, (pt.x < 0 ? SB_LINEDOWN : SB_LINEUP), 0);
                    else
                        xxxLBoxCtlHScrollMultiColumn(plb, (pt.x < 0 ? SB_LINEUP : SB_LINEDOWN), 0);

                    goto SetTimerAndSel;
                }
            } else if ((pt.y < 0) || (pt.y >= rcClient.bottom - 1)) {
                /*
                 * Reset timer interval based on distance from listbox.
                 */
                dist = pt.y < 0 ? -pt.y : (pt.y - rcClient.bottom + 1);
                iTimer = gpsi->dtScroll - ((WORD) dist << 4);

                xxxLBoxCtlScroll(plb, (pt.y < 0 ? SB_LINEUP : SB_LINEDOWN), 0);
SetTimerAndSel:
                NtUserSetTimer(hwnd, IDSYS_SCROLL, max(iTimer, 1), NULL);
                ISelFromPt(plb, pt, &iSelFromPt);
            }
        } else {
            /*
             * Ignore if not in client since we don't autoscroll
             */
            if (!PtInRect(&rcClient, pt))
                break;
        }

        switch (plb->wMultiple) {
        case SINGLESEL:

            /*
             * If it is a single selection or plain multisel list box
             */
            goto MouseMoveHandler;
            break;

        case MULTIPLESEL:
        case EXTENDEDSEL:

            /*
             * Handle mouse movement with extended selection of items
             */
            if (plb->iSelBase != iSelFromPt) {
                xxxSetISelBase(plb, iSelFromPt);

                /*
                 * If this is an extended Multi sel list box, then
                 * adjust the display of the range due to the mouse move
                 */
                if (plb->wMultiple == EXTENDEDSEL) {
                    xxxLBBlockHilite(plb, iSelFromPt, FALSE);
                    LBEvent(plb, EVENT_OBJECT_SELECTIONWITHIN, iSelFromPt);
                }
                plb->iLastMouseMove = iSelFromPt;
            }
            break;
        }
        break;
    }
    case WM_LBUTTONUP:
        if (plb->fMouseDown)
            xxxLBButtonUp(plb, LBUP_RELEASECAPTURE | LBUP_NOTIFY |
                (mousetemp ? LBUP_RESETSELECTION : 0) |
                (fMouseInRect ? LBUP_SUCCESS : 0));
    }
}

/***************************************************************************\
*
*  LBButtonUp()
*
*  Called in response to both WM_CAPTURECHANGED and WM_LBUTTONUP.
*
\***************************************************************************/
void xxxLBButtonUp(PLBIV plb, UINT uFlags)
{

    CheckLock(plb->spwnd);

    /*
     * If the list box is an Extended listbox, then change the select status
     * of all items between the anchor and the last mouse position to the
     * newItemState
     */
    if (plb->wMultiple == EXTENDEDSEL)
        xxxAlterHilite(plb, plb->iMouseDown, plb->iLastMouseMove,
            plb->fNewItemState, SELONLY, FALSE);

    /*
     * This is a combo box and user upclicked outside the listbox
     * so we want to restore the original selection.
     */
    if (plb->pcbox && (uFlags & LBUP_RESETSELECTION)) {
        int iSelOld;

        iSelOld = plb->iSel;

        if (iSelOld >= 0)
            xxxInvertLBItem(plb, plb->iSel, FALSE);

        plb->iSel = plb->iLastSelection;
        xxxInvertLBItem(plb, plb->iSel, TRUE);

        /*
         * Note that we always send selection events before we tell the
         * app.  This is on purpose--the app may turn around and select
         * something else when notified.  In which case our event would
         * be out of order.
         */
        LBEvent(plb, EVENT_OBJECT_SELECTION, plb->iSel);

        /*
         * On win-95 and NT4 the check used to be !(uFlags & LBUP_NOTIFY) which
         * is a bug because we would notify even when the lb is not LBUP_NOTIFY
         */
        if ((uFlags & LBUP_NOTIFY) && plb->fNotify && (iSelOld != plb->iSel))
            xxxNotifyOwner(plb, LBN_SELCHANGE);
    }

    NtUserKillTimer(HWq(plb->spwnd), IDSYS_SCROLL);
    plb->fMouseDown = FALSE;
    if (plb->fCaptured) {
        plb->fCaptured = FALSE;
        if (uFlags & LBUP_RELEASECAPTURE)
            NtUserReleaseCapture();
    }
    /*
     * Don't scroll item as long as any part of it is visible
     */
    if (plb->iSelBase < plb->iTop ||
        plb->iSelBase > plb->iTop + CItemInWindow(plb, TRUE))
        xxxInsureVisible(plb, plb->iSelBase, FALSE);

    if (plb->fNotify) {
        if (uFlags & LBUP_NOTIFY)  {
            if (uFlags & LBUP_SUCCESS) {
                /*
                 * ArtMaster needs this SELCHANGE notification now!
                 */
                if ((plb->fDoubleClick) && !TestWF(plb->spwnd, WFWIN31COMPAT))
                    xxxNotifyOwner(plb, LBN_SELCHANGE);

                /*
                 * Notify owner of click or double click on selection
                 */
                xxxNotifyOwner(plb, (plb->fDoubleClick) ? LBN_DBLCLK : LBN_SELCHANGE);
            } else {
                /*
                 * Notify owner that the attempted selection was cancelled.
                 */
                xxxNotifyOwner(plb, LBN_SELCANCEL);
            }
        } else if (uFlags & LBUP_SELCHANGE) {
            /*
             * Did we do some semi-selecting with mouse moves, then hit Enter?
             * If so, we need to make sure the app knows that something was
             * really truly selected.
             */
            UserAssert(TestWF(plb->spwnd, WFWIN40COMPAT));
            if (plb->iLastSelection != plb->iSel)
                xxxNotifyOwner(plb, LBN_SELCHANGE);

        }
    }

}


/***************************************************************************\
* IncrementISel
*
* History:
\***************************************************************************/

INT IncrementISel(
    PLBIV plb,
    INT iSel,
    INT sInc)
{

    /*
     * Assumes cMac > 0, return iSel+sInc in range [0..cmac).
     */
    iSel += sInc;
    if (iSel < 0) {
        return 0;
    } else if (iSel >= plb->cMac) {
        return plb->cMac - 1;
    }
    return iSel;
}


/***************************************************************************\
* NewITop
*
\***************************************************************************/

void xxxNewITop(PLBIV plb, INT iTopNew)
{
    xxxNewITopEx(plb, iTopNew, 0);
}


/***************************************************************************\
* xxxNewITopEx
*
* History:
\***************************************************************************/

void xxxNewITopEx(
    PLBIV plb,
    INT iTopNew,
    DWORD dwTime)
{
    int     iTopOld;
    BOOL fCaretOn;
    BOOL fMulti = plb->fMultiColumn;

    CheckLock(plb->spwnd);

    // Always try to turn off caret whether or not redraw is on
    if (fCaretOn = plb->fCaretOn)
        xxxLBSetCaret(plb, FALSE);

    iTopOld = (fMulti) ? (plb->iTop / plb->itemsPerColumn) : plb->iTop;
    plb->iTop = iTopNew;
    iTopNew = xxxSetLBScrollParms(plb, (fMulti) ? SB_HORZ : SB_VERT);
    plb->iTop = (fMulti) ? (iTopNew * plb->itemsPerColumn) : iTopNew;

    if (!IsLBoxVisible(plb)) {
        return;
    }

    if (iTopNew != iTopOld) {
        int     xAmt, yAmt;
        RECT    rc;
        DWORD   dwFlags;

        _GetClientRect(plb->spwnd, &rc);

        if (fMulti) {
            yAmt = 0;
            if (abs(iTopNew - iTopOld) > plb->numberOfColumns)
                // Handle scrolling a large number of columns properly so that
                // we don't overflow the size of a rect.
                xAmt = 32000;
            else {
                xAmt = (iTopOld - iTopNew) * plb->cxColumn;
                if (plb->fRightAlign)
                    xAmt = -xAmt;
            }
        } else {
            xAmt = 0;
            if (plb->OwnerDraw == OWNERDRAWVAR) {
                //
                // Have to fake iTopOld for OWNERDRAWVAR listboxes so that
                // the scrolling amount calculations work properly.
                //
                plb->iTop = iTopOld;
                yAmt = LBCalcVarITopScrollAmt(plb, iTopOld, iTopNew);
                plb->iTop = iTopNew;
            } else if (abs(iTopNew - iTopOld) > plb->cItemFullMax)
                yAmt = 32000;
            else
                yAmt = (iTopOld - iTopNew) * plb->cyChar;
        }

        dwFlags = LBGetScrollFlags(plb, dwTime);
        ScrollWindowEx(HWq(plb->spwnd), xAmt, yAmt, NULL, &rc, NULL,
                NULL, dwFlags);
        UpdateWindow(HWq(plb->spwnd));
    }

    // Note that although we turn off the caret regardless of redraw, we
    // only turn it on if redraw is true. Slimy thing to fixup many
    // caret related bugs...
    if (fCaretOn)
        // Turn the caret back on only if we turned it off. This avoids
        // annoying caret flicker.
        xxxLBSetCaret(plb, TRUE);
}


/***************************************************************************\
* xxxInsureVisible
*
* History:
\***************************************************************************/

void xxxInsureVisible(
    PLBIV plb,
    INT iSel,
    BOOL fPartial)  /* It is ok for the item to be partially visible */
{
    INT sLastVisibleItem;

    CheckLock(plb->spwnd);

    if (iSel < plb->iTop) {
        xxxNewITop(plb, iSel);
    } else {
        if (fPartial) {

            /*
             * 1 must be subtracted to get the last visible item
             * A part of the fix for Bug #3727 -- 01/14/91 -- SANKAR
             */
            sLastVisibleItem = plb->iTop + CItemInWindow(plb, TRUE) - (INT)1;
        } else {
            sLastVisibleItem = LastFullVisible(plb);
        }

        if (plb->OwnerDraw != OWNERDRAWVAR) {
            if (iSel > sLastVisibleItem) {
                if (plb->fMultiColumn) {
                    xxxNewITop(plb,
                        ((iSel / plb->itemsPerColumn) -
                        max(plb->numberOfColumns-1,0)) * plb->itemsPerColumn);
                } else {
                    xxxNewITop(plb, (INT)max(0, iSel - sLastVisibleItem + plb->iTop));
                }
            }
        } else if (iSel > sLastVisibleItem)
            xxxNewITop(plb, LBPage(plb, iSel, FALSE));
    }
}

/***************************************************************************\
* xxxLBoxCaretBlinker
*
* Timer callback function toggles Caret
* Since it is a callback, it is APIENTRY
*
* History:
\***************************************************************************/

VOID xxxLBoxCaretBlinker(
    HWND hwnd,
    UINT wMsg,
    UINT_PTR nIDEvent,
    DWORD dwTime)
{
    PWND pwnd;
    PLBIV plb;

    /*
     * Standard parameters for a timer callback function that aren't used.
     * Mentioned here to avoid compiler warnings
     */
    UNREFERENCED_PARAMETER(wMsg);
    UNREFERENCED_PARAMETER(nIDEvent);
    UNREFERENCED_PARAMETER(dwTime);

    pwnd = ValidateHwnd(hwnd);
    plb = ((PLBWND)pwnd)->pLBIV;

    /*
     * leave caret on, don't blink it off (prevents rapid blinks?)
     */
    if (ISREMOTESESSION() && plb->fCaretOn) {
        return;
    }

    /*
     * Check if the Caret is ON, if so, switch it OFF
     */
    xxxLBSetCaret(plb, !plb->fCaretOn);
    return;
}


/***************************************************************************\
* xxxLBoxCtlKeyInput
*
* If msg == LB_KEYDOWN, vKey is the number of the item to go to,
* otherwise it is the virtual key.
*
* History:
\***************************************************************************/

void xxxLBoxCtlKeyInput(
    PLBIV plb,
    UINT msg,
    UINT vKey)
{
    INT i;
    INT iNewISel;
    INT cItemPageScroll;
    PCBOX pcbox;
    BOOL fDropDownComboBox;
    BOOL fExtendedUIComboBoxClosed;
    BOOL hScrollBar = TestWF(plb->spwnd, WFHSCROLL);
    UINT wModifiers = 0;
    BOOL fSelectKey = FALSE;  /* assume it is a navigation key */
    UINT uEvent = 0;
    HWND hwnd = HWq(plb->spwnd);
    TL tlpwndParent;
    TL tlpwnd;

    CheckLock(plb->spwnd);

    pcbox = plb->pcbox;

    /*
     * Is this a dropdown style combo box/listbox ?
     */
    fDropDownComboBox = pcbox && (pcbox->CBoxStyle & SDROPPABLE);

    /*
     *Is this an extended ui combo box which is closed?
     */
    fExtendedUIComboBoxClosed = fDropDownComboBox && pcbox->fExtendedUI &&
                              !pcbox->fLBoxVisible;

    if (plb->fMouseDown || (!plb->cMac && vKey != VK_F4)) {

        /*
         * Ignore keyboard input if we are in the middle of a mouse down deal or
         * if there are no items in the listbox. Note that we let F4's go
         * through for combo boxes so that the use can pop up and down empty
         * combo boxes.
         */
        return;
    }

    /*
     * Modifiers are considered only in EXTENDED sel list boxes.
     */
    if (plb->wMultiple == EXTENDEDSEL) {

        /*
         * If multiselection listbox, are any modifiers used ?
         */
        if (GetKeyState(VK_SHIFT) < 0)
            wModifiers = SHIFTDOWN;
        if (GetKeyState(VK_CONTROL) < 0)
            wModifiers += CTLDOWN;

        /*
         * Please Note that (SHIFTDOWN + CTLDOWN) == (SHCTLDOWN)
         */
    }

    if (msg == LB_KEYDOWN) {

        /*
         * This is a listbox "go to specified item" message which means we want
         * to go to a particular item number (given by vKey) directly.  ie.  the
         * user has typed a character and we want to go to the item which
         * starts with that character.
         */
        iNewISel = (INT)vKey;
        goto TrackKeyDown;
    }

    cItemPageScroll = plb->cItemFullMax;

    if (cItemPageScroll > 1)
        cItemPageScroll--;

    if (plb->fWantKeyboardInput) {

        /*
         * Note: msg must not be LB_KEYDOWN here or we'll be in trouble...
         */
        ThreadLock(plb->spwndParent, &tlpwndParent);
        iNewISel = (INT)SendMessage(HW(plb->spwndParent), WM_VKEYTOITEM,
                MAKELONG(vKey, plb->iSelBase), (LPARAM)hwnd);
        ThreadUnlock(&tlpwndParent);

        if (iNewISel == -2) {

            /*
             * Don't move the selection...
             */
            return;
        }
        if (iNewISel != -1) {

            /*
             * Jump directly to the item provided by the app
             */
            goto TrackKeyDown;
        }

        /*
         * else do default processing of the character.
         */
    }

    switch (vKey) {
    // LATER IanJa: not language independent!!!
    // We could use VkKeyScan() to find out which is the '\' key
    // This is VK_OEM_5 '\|' for US English only.
    // Germans, Italians etc. have to type CTRL+^ (etc) for this.
    // This is documented as File Manager behaviour for 3.0, but apparently
    // not for 3.1., although functionality remains. We should still fix it,
    // although German (etc?) '\' is generated with AltGr (Ctrl-Alt) (???)
    case VERKEY_BACKSLASH:  /* '\' character for US English */

        /*
         * Check if this is CONTROL-\ ; If so Deselect all items
         */
        if ((wModifiers & CTLDOWN) && (plb->wMultiple != SINGLESEL)) {
            xxxLBSetCaret(plb, FALSE);
            xxxResetWorld(plb, plb->iSelBase, plb->iSelBase, FALSE);

            /*
             * And select the current item
             */
            SetSelected(plb, plb->iSelBase, TRUE, HILITEANDSEL);
            xxxInvertLBItem(plb, plb->iSelBase, TRUE);
            uEvent = EVENT_OBJECT_SELECTION;
            goto CaretOnAndNotify;
        }
        return;
        break;

    case VK_DIVIDE:     /* NumPad '/' character on enhanced keyboard */
    // LATER IanJa: not language independent!!!
    // We could use VkKeyScan() to find out which is the '/' key
    // This is VK_OEM_2 '/?' for US English only.
    // Germans, Italians etc. have to type CTRL+# (etc) for this.
    case VERKEY_SLASH:  /* '/' character */

        /*
         * Check if this is CONTROL-/ ; If so select all items
         */
        if ((wModifiers & CTLDOWN) && (plb->wMultiple != SINGLESEL)) {
            xxxLBSetCaret(plb, FALSE);
            xxxResetWorld(plb, -1, -1, TRUE);

            uEvent = EVENT_OBJECT_SELECTIONWITHIN;

CaretOnAndNotify:
            xxxLBSetCaret(plb, TRUE);
            LBEvent(plb, uEvent, plb->iSelBase);
            xxxNotifyOwner(plb, LBN_SELCHANGE);
        }
        return;
        break;

    case VK_F8:

        /*
         * The "Add" mode is possible only in Multiselection listboxes...  Get
         * into it via SHIFT-F8...  (Yes, sometimes these UI people are sillier
         * than your "typical dumb user"...)
         */
        if (plb->wMultiple != SINGLESEL && wModifiers == SHIFTDOWN) {

            /*
             * We have to make the caret blink! Do something...
             */
            if (plb->fAddSelMode) {

                /*
                 * Switch off the Caret blinking
                 */
                NtUserKillTimer(hwnd, IDSYS_CARET);

                /*
                 * Make sure the caret does not vanish
                 */
                xxxLBSetCaret(plb, TRUE);
            } else {

                /*
                 * Create a timer to make the caret blink
                 */
                NtUserSetTimer(hwnd, IDSYS_CARET, gpsi->dtCaretBlink,
                        xxxLBoxCaretBlinker);
            }

            /*
             * Toggle the Add mode flag
             */
            plb->fAddSelMode = (UINT)!plb->fAddSelMode;
        }
        return;
    case VK_SPACE:  /* Selection key is space */
        i = 0;
        fSelectKey = TRUE;
        break;

    case VK_PRIOR:
        if (fExtendedUIComboBoxClosed) {

            /*
             * Disable movement keys for TandyT.
             */
            return;
        }

        if (plb->OwnerDraw == OWNERDRAWVAR) {
            i = LBPage(plb, plb->iSelBase, FALSE) - plb->iSelBase;
        } else {
            i = -cItemPageScroll;
        }
        break;

    case VK_NEXT:
        if (fExtendedUIComboBoxClosed) {

            /*
             * Disable movement keys for TandyT.
             */
            return;
        }

        if (plb->OwnerDraw == OWNERDRAWVAR) {
            i = LBPage(plb, plb->iSelBase, TRUE) - plb->iSelBase;
        } else {
            i = cItemPageScroll;
        }
        break;

    case VK_HOME:
        if (fExtendedUIComboBoxClosed) {

            /*
             * Disable movement keys for TandyT.
             */
            return;
        }

        i = (INT_MIN/2)+1;  /* A very big negative number */
        break;

    case VK_END:
        if (fExtendedUIComboBoxClosed) {

            /*
             * Disable movement keys for TandyT.
             */
            return;
        }

        i = (INT_MAX/2)-1;  /* A very big positive number */
        break;

    case VK_LEFT:
        if (plb->fMultiColumn) {
            if (plb->fRightAlign ^ (!!TestWF(plb->spwnd, WEFLAYOUTRTL))) {
                goto ReallyRight;
            }
ReallyLeft:
            if (plb->iSelBase / plb->itemsPerColumn == 0) {
                i = 0;
            } else {
                i = -plb->itemsPerColumn;
            }
            break;
        }

        if (hScrollBar) {
            goto HandleHScrolling;
        } else {

            /*
             * Fall through and handle this as if the up arrow was pressed.
             */

            vKey = VK_UP;
        }

        /*
         * Fall through
         */

    case VK_UP:
        if (fExtendedUIComboBoxClosed)
            // Disable movement keys for TandyT.
            return;

        i = -1;
        break;

    case VK_RIGHT:
        if (plb->fMultiColumn) {
            if (plb->fRightAlign ^ (!!TestWF(plb->spwnd, WEFLAYOUTRTL))) {
                goto ReallyLeft;
            }
ReallyRight:
            if (plb->iSelBase / plb->itemsPerColumn == plb->cMac / plb->itemsPerColumn) {
                i = 0;
            } else {
                i = plb->itemsPerColumn;
            }
            break;
        }
        if (hScrollBar) {
HandleHScrolling:
            PostMessage(hwnd, WM_HSCROLL,
                    (vKey == VK_RIGHT ? SB_LINEDOWN : SB_LINEUP), 0L);
            return;
        } else {

            /*
             * Fall through and handle this as if the down arrow was
             * pressed.
             */
            vKey = VK_DOWN;
        }

        /*
         * Fall through
         */

    case VK_DOWN:
        if (fExtendedUIComboBoxClosed) {

            /*
             * If the combo box is closed, down arrow should open it.
             */
            if (!pcbox->fLBoxVisible) {

                /*
                 * If the listbox isn't visible, just show it
                 */
                ThreadLock(pcbox->spwnd, &tlpwnd);
                xxxCBShowListBoxWindow(pcbox, TRUE);
                ThreadUnlock(&tlpwnd);
            }
            return;
        }
        i = 1;
        break;

    case VK_ESCAPE:
    case VK_RETURN:
        if (!fDropDownComboBox || !pcbox->fLBoxVisible)
            return;

        // |  If this is a dropped listbox for a combobox and the ENTER  |
        // |  key is pressed, close up the listbox, so FALLTHRU          |
        // V                                                             V

    case VK_F4:
        if (fDropDownComboBox && !pcbox->fExtendedUI) {

            /*
             * If we are a dropdown combo box/listbox we want to process
             * this key.  BUT for TandtT, we don't do anything on VK_F4 if we
             * are in extended ui mode.
             */
            ThreadLock(pcbox->spwnd, &tlpwnd);
            if (!pcbox->fLBoxVisible) {

                /*
                 * If the listbox isn't visible, just show it
                 */
                xxxCBShowListBoxWindow(pcbox, (vKey != VK_ESCAPE));
            } else {

                /*
                 * Ok, the listbox is visible.  So hide the listbox window.
                 */
                xxxCBHideListBoxWindow(pcbox, TRUE, (vKey != VK_ESCAPE));
            }
            ThreadUnlock(&tlpwnd);
        }

        /*
         * Fall through to the return
         */

    default:
        return;
    }

    /*
     * Find out what the new selection should be
     */
    iNewISel = IncrementISel(plb, plb->iSelBase, i);


    if (plb->wMultiple == SINGLESEL) {
        if (plb->iSel == iNewISel) {

            /*
             * If we are single selection and the keystroke is moving us to an
             * item which is already selected, we don't have to do anything...
             */
            return;
        }

        uEvent = EVENT_OBJECT_SELECTION;

        plb->iTypeSearch = 0;
        if ((vKey == VK_UP || vKey == VK_DOWN) &&
                !IsSelected(plb, plb->iSelBase, HILITEONLY)) {

            /*
             * If the caret is on an unselected item and the user just hits the
             * up or down arrow key (ie. with no shift or ctrl modifications),
             * then we will just select the item the cursor is at. This is
             * needed for proper behavior in combo boxes but do we always want
             * to run this code??? Note that this is only used in single
             * selection list boxes since it doesn't make sense in the
             * multiselection case. Note that an LB_KEYDOWN message must not be
             * checked here because the vKey will be an item number not a
             * VK_and we will goof. Thus, trackkeydown label is below this to
             * fix a bug caused by it being above this...
             */
            iNewISel = (plb->iSelBase == -1) ? 0 : plb->iSelBase;
        }
    }

TrackKeyDown:

    xxxSetISelBase(plb, iNewISel);

    xxxLBSetCaret(plb, FALSE);

    if (wModifiers & SHIFTDOWN) {
        // Check if iMouseDown is un-initialised
        if (plb->iMouseDown == -1)
            plb->iMouseDown = iNewISel;
        if (plb->iLastMouseMove == -1)
            plb->iLastMouseMove = iNewISel;

        // Check if we are in ADD mode
        if (plb->fAddSelMode) {
            /* Preserve all the pre-existing selections except the
             * ones connected with the last anchor point; If the last
             * Preserve all the previous selections
            */
            /* Deselect only the selection connected with the last
             * anchor point; If the last anchor point is associated
             * with de-selection, then do not do it
            */

            if (!plb->fNewItemState)
                plb->iLastMouseMove = plb->iMouseDown;

            /* We haven't done anything here because, LBBlockHilite()
             * will take care of wiping out the selection between
             * Anchor point and iLastMouseMove and select the block
             * between anchor point and current cursor location
            */
        } else {
            /* We are not in ADD mode */
            /* Remove all selections except between the anchor point
             * and last mouse move because it will be taken care of in
             * LBBlockHilite
            */
            xxxResetWorld(plb, plb->iMouseDown, plb->iLastMouseMove, FALSE);
        }

        uEvent = EVENT_OBJECT_SELECTIONWITHIN;

        /* LBBlockHilite takes care to deselect the block between
         * the anchor point and iLastMouseMove and select the block
         * between the anchor point and the current cursor location
        */
        /* Toggle all items to the same selection state as the item
         * item at the anchor point) from the anchor point to the
         * current cursor location.
        */
        plb->fNewItemState = IsSelected(plb, plb->iMouseDown, SELONLY);
        xxxLBBlockHilite(plb, iNewISel, TRUE);

        plb->iLastMouseMove = iNewISel;
        /* Preserve the existing anchor point */
    } else {
        /* Check if this is in ADD mode */
        if ((plb->fAddSelMode) || (plb->wMultiple == MULTIPLESEL)) {
            /* Preserve all pre-exisiting selections */
            if (fSelectKey) {
                /* Toggle the selection state of the current item */
                plb->fNewItemState = !IsSelected(plb, iNewISel, SELONLY);
                SetSelected(plb, iNewISel, plb->fNewItemState, HILITEANDSEL);

                xxxInvertLBItem(plb, iNewISel, plb->fNewItemState);

                /* Set the anchor point at the current location */
                plb->iLastMouseMove = plb->iMouseDown = iNewISel;
                uEvent = (plb->fNewItemState ? EVENT_OBJECT_SELECTIONADD :
                        EVENT_OBJECT_SELECTIONREMOVE);
            }
        } else {
            /* We are NOT in ADD mode */
            /* Remove all existing selections except iNewISel, to
             * avoid flickering.
            */
            xxxResetWorld(plb, iNewISel, iNewISel, FALSE);

            /* Select the current item */
            SetSelected(plb, iNewISel, TRUE, HILITEANDSEL);
            xxxInvertLBItem(plb, iNewISel, TRUE);

            /* Set the anchor point at the current location */
            plb->iLastMouseMove = plb->iMouseDown = iNewISel;
            uEvent = EVENT_OBJECT_SELECTION;
        }
    }

    /*
     * Move the cursor to the new location
     */
    xxxInsureVisible(plb, iNewISel, FALSE);
    xxxLBShowHideScrollBars(plb);

    xxxLBSetCaret(plb, TRUE);

    if (uEvent) {
        LBEvent(plb, uEvent, iNewISel);
    }

    /*
     * Should we notify our parent?
     */
    if (plb->fNotify) {
        if (fDropDownComboBox && pcbox->fLBoxVisible) {

            /*
             * If we are in a drop down combo box/listbox and the listbox is
             * visible, we need to set the fKeyboardSelInListBox bit so that the
             * combo box code knows not to hide the listbox since the selchange
             * message is caused by the user keyboarding through...
             */
            pcbox->fKeyboardSelInListBox = TRUE;
            plb->iLastSelection = iNewISel;
        }
        xxxNotifyOwner(plb, LBN_SELCHANGE);
    }
}


/***************************************************************************\
* Compare
*
* Is lpstr1 equal/prefix/less-than/greater-than lsprst2 (case-insensitive) ?
*
* LATER IanJa: this assume a longer string is never a prefix of a longer one.
* Also assumes that removing 1 or more characters from the end of a string will
* give a string tahs sort before the original.  These assumptions are not valid
* for all languages.  We nedd better support from NLS. (Consider French
* accents, Spanish c/ch, ligatures, German sharp-s/SS, etc.)
*
* History:
\***************************************************************************/

INT Compare(
    LPCWSTR pwsz1,
    LPCWSTR pwsz2,
    DWORD dwLocaleId)
{
    UINT len1 = wcslen(pwsz1);
    UINT len2 = wcslen(pwsz2);
    INT result;

    /*
     * CompareStringW returns:
     *    1 = pwsz1  <  pwsz2
     *    2 = pwsz1  == pwsz2
     *    3 = pwsz1  >  pwsz2
     */
    result = CompareStringW((LCID)dwLocaleId, NORM_IGNORECASE,
            pwsz1, min(len1,len2), pwsz2, min(len1, len2));

    if (result == CSTR_LESS_THAN) {
       return LT;
    } else if (result == CSTR_EQUAL) {
        if (len1 == len2) {
            return EQ;
        } else if (len1 < len2) {
            /*
             * LATER IanJa: should not assume shorter string is a prefix
             * Spanish "c" and "ch", ligatures, German sharp-s/SS etc.
             */
            return PREFIX;
        }
    }
    return GT;
}

/***************************************************************************\
* xxxFindString
*
* Scans for a string in the listbox prefixed by or equal to lpstr.
* For OWNERDRAW listboxes without strings and without the sort style, we
* try to match the long app supplied values.
*
* History:
* 16-Apr-1992 beng      The NODATA case
\***************************************************************************/

INT xxxFindString(
    PLBIV plb,
    LPWSTR lpstr,
    INT sStart,
    INT code,
    BOOL fWrap)
{
    /*
     * Search for a prefix match (case-insensitive equal/prefix)
     * sStart == -1 means start from beginning, else start looking at sStart+1
     * assumes cMac > 0.
     */
    INT sInd;  /* index of string */
    INT sStop;          /* index to stop searching at */
    lpLBItem pRg;
    TL tlpwndParent;
    INT sortResult;

/*
 * Owner-Draw version of pRg
 */
#define pODRg ((lpLBODItem)pRg)
    COMPAREITEMSTRUCT cis;
    LPWSTR listboxString;

    CheckLock(plb->spwnd);

    if (plb->fHasStrings && (!lpstr || !*lpstr))
        return LB_ERR;

    if (!plb->fHasData) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "FindString called on NODATA lb");
        return LB_ERR;
    }

    if ((sInd = sStart + 1) >= plb->cMac)
        sInd = (fWrap ? 0 : plb->cMac - 1);

    sStop = (fWrap ? sInd : 0);

    /*
     * If at end and no wrap, stop right away
     */
    if (((sStart >= plb->cMac - 1) && !fWrap) || (plb->cMac < 1)) {
        return LB_ERR;
    }

    /*
     * Apps could pass in an invalid sStart like -2 and we would blow up.
     * Win 3.1 would not so we need to fixup sInd to be zero
     */
    if (sInd < 0)
        sInd = 0;

    pRg = (lpLBItem)(plb->rgpch);

    do {
        if (plb->fHasStrings) {

            /*
             * Searching for string matches.
             */
            listboxString = (LPWSTR)((LPBYTE)plb->hStrings + pRg[sInd].offsz);

            if (code == PREFIX &&
                listboxString &&
                *lpstr != TEXT('[') &&
                *listboxString == TEXT('[')) {

                /*
                 * If we are looking for a prefix string and the first items
                 * in this string are [- then we ignore them.  This is so
                 * that in a directory listbox, the user can goto drives
                 * by selecting the drive letter.
                 */
                listboxString++;
                if (*listboxString == TEXT('-'))
                    listboxString++;
            }

            if (Compare(lpstr, listboxString, plb->dwLocaleId) <= code) {
               goto FoundIt;
            }

        } else {
            if (plb->fSort) {

                /*
                 * Send compare item messages to the parent for sorting
                 */
                cis.CtlType = ODT_LISTBOX;
                cis.CtlID = PtrToUlong(plb->spwnd->spmenu);
                cis.hwndItem = HWq(plb->spwnd);
                cis.itemID1 = (UINT)-1;
                cis.itemData1 = (ULONG_PTR)lpstr;
                cis.itemID2 = (UINT)sInd;
                cis.itemData2 = pODRg[sInd].itemData;
                cis.dwLocaleId = plb->dwLocaleId;

                ThreadLock(plb->spwndParent, &tlpwndParent);
                sortResult = (INT)SendMessage(HW(plb->spwndParent), WM_COMPAREITEM,
                        cis.CtlID, (LPARAM)&cis);
                ThreadUnlock(&tlpwndParent);


                if (sortResult == -1) {
                   sortResult = LT;
                } else if (sortResult == 1) {
                   sortResult = GT;
                } else {
                   sortResult = EQ;
                }

                if (sortResult <= code) {
                    goto FoundIt;
                }
            } else {

                /*
                 * Searching for app supplied long data matches.
                 */
                if ((ULONG_PTR)lpstr == pODRg[sInd].itemData)
                    goto FoundIt;
            }
        }

        /*
         * Wrap round to beginning of list
         */
        if (++sInd == plb->cMac)
            sInd = 0;
    } while (sInd != sStop);

    sInd = -1;

FoundIt:
    return sInd;
}


/***************************************************************************\
* xxxLBoxCtlCharInput
*
* History:
\***************************************************************************/

void xxxLBoxCtlCharInput(
    PLBIV plb,
    UINT  inputChar,
    BOOL  fAnsi)
{
    INT iSel;
    BOOL fControl;
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    if (plb->cMac == 0 || plb->fMouseDown) {

        /*
         * Get out if we are in the middle of mouse routines or if we have no
         * items in the listbox, we just return without doing anything.
         */
        return;
    }

    fControl = (GetKeyState(VK_CONTROL) < 0);

    switch (inputChar) {
    case VK_ESCAPE:
        plb->iTypeSearch = 0;
        if (plb->pszTypeSearch)
            plb->pszTypeSearch[0] = 0;
        break;

    case VK_BACK:
        if (plb->iTypeSearch) {
            plb->pszTypeSearch[plb->iTypeSearch--] = 0;
            if (plb->fSort) {
                iSel = -1;
                goto TypeSearch;
            }
        }
        break;

    case VK_SPACE:
        if (plb->fAddSelMode || plb->wMultiple == MULTIPLESEL)
            break;
        /* Otherwise, for single/extended selection listboxes not in add
         * selection mode, let the  space go thru as a type search character
         * FALL THRU
         */

    default:

        /*
         * Move selection to first item beginning with the character the
         * user typed.  We don't want do this if we are using owner draw.
         */

        if (fAnsi && IS_DBCS_ENABLED() && IsDBCSLeadByteEx(THREAD_CODEPAGE(), (BYTE)inputChar)) {
            WCHAR wch;
            LPWSTR lpwstr = &wch;

            inputChar = DbcsCombine(HWq(plb->spwnd), (BYTE)inputChar);
            RIPMSG1(RIP_VERBOSE, "xxxLBoxCtlCharInput: combined DBCS. 0x%04x", inputChar);

            if (inputChar == 0) {
                RIPMSG1(RIP_WARNING, "xxxLBoxCtlCharInput: cannot combine two DBCS. LB=0x%02x",
                        inputChar);
                break;
            }
            // If it is DBCS, let's ignore the ctrl status.
            fControl = FALSE;

            // Convert DBCS to UNICODE.
            // Note: Leading byte is in the low byte, trailing byte is in high byte.
            // Let's assume Little Endian CPUs only, so inputChar can directly be
            // input for MBSToWCSEx as an ANSI string.
            if (MBToWCSEx(THREAD_CODEPAGE(), (LPCSTR)&inputChar, 2, &lpwstr, 1, FALSE) == 0) {
                RIPMSG1(RIP_WARNING, "xxxLBoxCtlCharInput: cannot convert 0x%04x to UNICODE.",
                        inputChar);
                break;
            }
            inputChar = wch;
        }

        if (plb->fHasStrings) {
            // Incremental Type Search processing
            //
            // update szTypeSearch string and then move to the first item from
            // the current selection whose prefix matches szTypeSearch
            //
            // the szTypeSearch will continue to grow until a "long enough"
            // gap between key entries is encountered -- at which point any
            // more searching will start over

            /*
             * Undo CONTROL-char to char
             */
            if (fControl && inputChar < 0x20)
                inputChar += 0x40;

            if (plb->iTypeSearch == MAX_TYPESEARCH) {
                NtUserMessageBeep(0);
                break;
            }
            iSel = -1;

            if (plb->pszTypeSearch == NULL)
                plb->pszTypeSearch = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(WCHAR) * (MAX_TYPESEARCH + 1));

            if (plb->pszTypeSearch == NULL) {
                NtUserMessageBeep(0);
                break;
            }

            plb->pszTypeSearch[plb->iTypeSearch++] = (WCHAR) inputChar;
            plb->pszTypeSearch[plb->iTypeSearch]   = 0;

TypeSearch:
            if (plb->fSort) {
                // Set timer to determine when to kill incremental searching
                NtUserSetTimer(HWq(plb->spwnd), IDSYS_LBSEARCH,
                               gpsi->dtLBSearch, NULL);
            } else {
                // If this is not a sorted listbox, no incremental search.
                plb->iTypeSearch = 0;
                iSel = plb->iSelBase;
            }


            /*
             * Search for the item beginning with the given character starting
             * at iSel+1.  We will wrap the search to the beginning of the
             * listbox if we don't find the item.   If SHIFT is down and we are
             * a multiselection lb, then the item's state will be set to
             * plb->fNewItemState according to the current mode.
             */
            iSel = xxxFindString(plb, plb->pszTypeSearch, iSel, PREFIX, TRUE);
            if (iSel == -1) {
                // no match found -- check for prefix match
                // (i.e. "p" find FIRST item that starts with 'p',
                //       "pp" find NEXT item that starts with 'p')
                if(plb->iTypeSearch)
                {
                    plb->iTypeSearch--;
                    if ((plb->iTypeSearch == 1) && (plb->pszTypeSearch[0] == plb->pszTypeSearch[1]))
                    {
                        plb->pszTypeSearch[1] = 0;
                        iSel = xxxFindString(plb, plb->pszTypeSearch, plb->iSelBase, PREFIX, TRUE);
                    }
                }
            }
            // if match is found -- select it
            if (iSel != -1)
            {
CtlKeyInput:
                xxxLBoxCtlKeyInput(plb, LB_KEYDOWN, iSel);

            }
        } else {
            if (plb->spwndParent != NULL) {
                ThreadLock(plb->spwndParent, &tlpwndParent);
                iSel = (INT)SendMessageWorker(plb->spwndParent, WM_CHARTOITEM,
                        MAKELONG(inputChar, plb->iSelBase), (LPARAM)HWq(plb->spwnd), fAnsi);
                ThreadUnlock(&tlpwndParent);
            } else
                iSel = -1;

            if (iSel != -1 && iSel != -2)
                goto CtlKeyInput;

        }
        break;
    }
}


/***************************************************************************\
* LBoxGetSelItems
*
* effects: For multiselection listboxes, this returns the total number of
* selection items in the listbox if fCountOnly is true.  or it fills an array
* (lParam) with the items numbers of the first wParam selected items.
*
* History:
\***************************************************************************/

int LBoxGetSelItems(
    PLBIV plb,
    BOOL fCountOnly,
    int wParam,
    LPINT lParam)
{
    int i;
    int itemsselected = 0;

    if (plb->wMultiple == SINGLESEL)
        return LB_ERR;

    for (i = 0; i < plb->cMac; i++) {
        if (IsSelected(plb, i, SELONLY)) {
            if (!fCountOnly) {
                if (itemsselected < wParam)
                    *lParam++ = i;
                else {

                    /*
                     * That's all the items we can fit in the array.
                     */
                    return itemsselected;
                }
            }
            itemsselected++;
        }
    }

    return itemsselected;
}


/***************************************************************************\
* xxxLBSetRedraw
*
* Handle WM_SETREDRAW message
*
* History:
\***************************************************************************/

void xxxLBSetRedraw(
    PLBIV plb,
    BOOL fRedraw)
{
    CheckLock(plb->spwnd);

    if (fRedraw)
        fRedraw = TRUE;

    if (plb->fRedraw != (UINT)fRedraw) {
        plb->fRedraw = !!fRedraw;

        if (fRedraw) {
            xxxLBSetCaret(plb, TRUE);
            xxxLBShowHideScrollBars(plb);

            if (plb->fDeferUpdate) {
                plb->fDeferUpdate = FALSE;
                RedrawWindow(HWq(plb->spwnd), NULL, NULL,
                        RDW_INVALIDATE | RDW_ERASE |
                        RDW_FRAME | RDW_ALLCHILDREN);
            }
        }
    }
}

/***************************************************************************\
* xxxLBSelRange
*
* Selects the range of items between i and j, inclusive.
*
* History:
\***************************************************************************/

void xxxLBSelRange(
    PLBIV plb,
    int iStart,
    int iEnd,
    BOOL fnewstate)
{
    DWORD temp;
    RECT rc;

    CheckLock(plb->spwnd);

    if (iStart > iEnd) {
        temp = iEnd;
        iEnd = iStart;
        iStart = temp;
    }

    /*
     * We don't want to loop through items that don't exist.
     */
    iEnd = min(plb->cMac, iEnd);
    iStart = max(iStart, 0);
    if (iStart > iEnd)
        return;


    /*
     * iEnd could be equal to MAXINT which is why we test temp and iEnd
     * as DWORDs.
     */
    for (temp = iStart; temp <= (DWORD)iEnd; temp++) {

        if (IsSelected(plb, temp, SELONLY) != fnewstate) {
            SetSelected(plb, temp, fnewstate, HILITEANDSEL);
            LBGetItemRect(plb, temp, &rc);

            xxxLBInvalidateRect(plb, (LPRECT)&rc, FALSE);
        }

    }
    UserAssert(plb->wMultiple);
    LBEvent(plb, EVENT_OBJECT_SELECTIONWITHIN, iStart);
}


/***************************************************************************\
* xxxLBSetCurSel
*
* History:
\***************************************************************************/

int xxxLBSetCurSel(
    PLBIV plb,
    int iSel)
{
    CheckLock(plb->spwnd);

    if (!(plb->wMultiple || iSel < -1 || iSel >= plb->cMac)) {
        xxxLBSetCaret(plb, FALSE);
        if (plb->iSel != -1) {

            /*
             * This prevents scrolling when iSel == -1
             */
            if (iSel != -1)
                xxxInsureVisible(plb, iSel, FALSE);

            /*
             * Turn off old selection
             */
            xxxInvertLBItem(plb, plb->iSel, FALSE);
        }

        if (iSel != -1) {
            xxxInsureVisible(plb, iSel, FALSE);
            plb->iSelBase = plb->iSel = iSel;

            /*
             * Highlight new selection
             */
            xxxInvertLBItem(plb, plb->iSel, TRUE);
        } else {
            plb->iSel = -1;
            if (plb->cMac)
                plb->iSelBase = min(plb->iSelBase, plb->cMac-1);
            else
                plb->iSelBase = 0;
        }

        /*
         * Send both focus and selection events
         *
         * We need to send this event even if the listbox isn't visible. See
         * bug #88548. Also see 355612.
         */
        if (_IsWindowVisible(plb->spwnd) || (GetFocus() == HWq(plb->spwnd))) {
            LBEvent(plb, EVENT_OBJECT_FOCUS, plb->iSelBase);
            LBEvent(plb, EVENT_OBJECT_SELECTION, plb->iSel);
        }

        xxxLBSetCaret(plb, TRUE);
        return plb->iSel;
    }

    return LB_ERR;
}


/***************************************************************************\
* LBSetItemData
*
* Makes the item at index contain the data given.
*
* History:
* 16-Apr-1992 beng      The NODATA listbox case
\***************************************************************************/

int LBSetItemData(
    PLBIV plb,
    int index,
    LONG_PTR data)
{
    LPSTR lpItemText;

    /*
     * v-ronaar: fix bug #25865, don't allow negative indices!
     */
    if ((index != -1) && ((UINT) index >= (UINT) plb->cMac)) {
        RIPERR1(ERROR_INVALID_INDEX, RIP_WARNING, "LBSetItemData with invalid index %x", index);
        return LB_ERR;
    }

    /*
     * No-data listboxes just ignore all LB_SETITEMDATA calls
     */
    if (!plb->fHasData) {
        return TRUE;
    }

    lpItemText = (LPSTR)plb->rgpch;

    if (index == -1) {

        /*
         * index == -1 means set the data to all the items
         */
        if (plb->fHasStrings) {
            for (index = 0; index < plb->cMac; index++) {

                ((lpLBItem)lpItemText)->itemData = data;
                lpItemText += sizeof(LBItem);
            }
        } else {
            for (index = 0; index < plb->cMac; index++) {

                ((lpLBODItem)lpItemText)->itemData = data;
                lpItemText += sizeof(LBODItem);
            }
        }
        return TRUE;
    }

    if (plb->fHasStrings) {

        lpItemText = (LPSTR)(lpItemText + (index * sizeof(LBItem)));
        ((lpLBItem)lpItemText)->itemData = data;
    } else {

        lpItemText = (LPSTR)(lpItemText + (index * sizeof(LBODItem)));
        ((lpLBODItem)lpItemText)->itemData = data;
    }
    return TRUE;
}

/***************************************************************************\
* xxxCheckRedraw
*
* History:
\***************************************************************************/

void xxxCheckRedraw(
    PLBIV plb,
    BOOL fConditional,
    INT sItem)
{
    CheckLock(plb->spwnd);

    if (fConditional && plb->cMac &&
            (sItem > (plb->iTop + CItemInWindow(plb, TRUE))))
        return;

    /*
     * Don't do anything if the parent is not visible.
     */
    xxxLBInvalidateRect(plb, (LPRECT)NULL, TRUE);
}


/***************************************************************************\
* xxxCaretDestroy
*
* History:
\***************************************************************************/

void xxxCaretDestroy(
    PLBIV plb)
{
    CheckLock(plb->spwnd);

    /*
     * We're losing the focus.  Act like up clicks are happening so we release
     * capture, set the current selection, notify the parent, etc.
     */
    if (plb->fCaptured)

        /*
         * If we have the capture and we lost the focus, that means we already
         * changed the selection and we have to notify also the parent about
         * this. So we need to add also the LBUP_SUCCESS flag in this case.
         */

        xxxLBButtonUp(plb, LBUP_RELEASECAPTURE | LBUP_NOTIFY |
            (plb->fMouseDown ? LBUP_SUCCESS : 0));

    if (plb->fAddSelMode) {

        /*
         * Switch off the Caret blinking
         */
        NtUserKillTimer(HWq(plb->spwnd), IDSYS_CARET);

        /*
         * Make sure the caret goes away
         */
        xxxLBSetCaret(plb, FALSE);
        plb->fAddSelMode = FALSE;
    }

    plb->fCaret = FALSE;
}


/***************************************************************************\
* xxxLbSetSel
*
* History:
\***************************************************************************/

LONG xxxLBSetSel(
    PLBIV plb,
    BOOL fSelect,  /* New state to set selection to */
    INT iSel)
{
    INT sItem;
    RECT rc;
    UINT uEvent = 0;

    CheckLock(plb->spwnd);

    /*
    * Bug 17656. WinZip's accelerator key for 'DeSelect All' sends a LB_SETSEL
    * message with lparam = 0x0000ffff instead of 0xffffffff(-1). If iSel
    * is equal to  0x0000ffff and there are less than 0xffff elements in the
    * list we set iSel equal to 0xffffffff.
    */
    if ((iSel == (UINT)0xffff) && (iSel >= plb->cMac)) {
        iSel = -1;
        RIPMSG0(RIP_WARNING, "Sign extending iSel=0xffff to 0xffffffff");
    }


    if ((plb->wMultiple == SINGLESEL) || (iSel != -1 && iSel >= plb->cMac)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING,
                "xxxLBSetSel:Invalid iSel or SINGLESEL listbox");
        return LB_ERR;
    }

    xxxLBSetCaret(plb, FALSE);

    if (iSel == -1/*(INT)0xffff*/) {

        /*
         * Set/clear selection from all items if -1
         */
        for (sItem = 0; sItem < plb->cMac; sItem++) {
            if (IsSelected(plb, sItem, SELONLY) != fSelect) {
                SetSelected(plb, sItem, fSelect, HILITEANDSEL);
                if (LBGetItemRect(plb, sItem, &rc)) {
                    xxxLBInvalidateRect(plb, &rc, FALSE);
                }
            }
        }
        xxxLBSetCaret(plb, TRUE);
        uEvent = EVENT_OBJECT_SELECTIONWITHIN;
    } else {
        if (fSelect) {

            /*
             * Check if the item if fully hidden and scroll it into view if it
             * is.  Note that we don't want to scroll partially visible items
             * into full view because this breaks the shell...
             */
            xxxInsureVisible(plb, iSel, TRUE);
            plb->iSelBase = plb->iSel = iSel;

            plb->iMouseDown = plb->iLastMouseMove = iSel;
            uEvent = EVENT_OBJECT_FOCUS;
        } else {
            uEvent = EVENT_OBJECT_SELECTIONREMOVE;
        }
        SetSelected(plb, iSel, fSelect, HILITEANDSEL);

        /*
         * Note that we set the caret on bit directly so that we avoid flicker
         * when drawing this item.  ie.  We turn on the caret, redraw the item and
         * turn it back on again.
         */
        if (!fSelect && plb->iSelBase != iSel) {
            xxxLBSetCaret(plb, TRUE);
        } else if (plb->fCaret) {
            plb->fCaretOn = TRUE;
        }

        if (LBGetItemRect(plb, iSel, &rc)) {
            xxxLBInvalidateRect(plb, &rc, FALSE);
        }
    }

    /*
     * We need to send this event even if the listbox isn't visible. See
     * bug #88548. Also see 355612.
     */
    if (_IsWindowVisible(plb->spwnd) || (GetFocus() == HWq(plb->spwnd))) {
        if (uEvent == EVENT_OBJECT_FOCUS) {
            LBEvent(plb, uEvent, plb->iSelBase);
            uEvent = EVENT_OBJECT_SELECTION;
        }
        LBEvent(plb, uEvent, iSel);
    }

    return 0;
}


/***************************************************************************\
* xxxLBoxDrawItem
*
* This fills the draw item struct with some constant data for the given
* item.  The caller will only have to modify a small part of this data
* for specific needs.
*
* History:
* 16-Apr-1992 beng      The NODATA case
\***************************************************************************/

void xxxLBoxDrawItem(
    PLBIV plb,
    INT item,
    UINT itemAction,
    UINT itemState,
    LPRECT lprect)
{
    DRAWITEMSTRUCT dis;
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    /*
     * Fill the DRAWITEMSTRUCT with the unchanging constants
     */

    dis.CtlType = ODT_LISTBOX;
    dis.CtlID = PtrToUlong(plb->spwnd->spmenu);

    /*
     * Use -1 if an invalid item number is being used.  This is so that the app
     * can detect if it should draw the caret (which indicates the lb has the
     * focus) in an empty listbox
     */
    dis.itemID = (UINT)(item < plb->cMac ? item : -1);
    dis.itemAction = itemAction;
    dis.hwndItem = HWq(plb->spwnd);
    dis.hDC = plb->hdc;
    dis.itemState = itemState |
            (UINT)(TestWF(plb->spwnd, WFDISABLED) ? ODS_DISABLED : 0);

    if (TestWF(plb->spwnd, WEFPUIFOCUSHIDDEN)) {
        dis.itemState |= ODS_NOFOCUSRECT;
    }
    if (TestWF(plb->spwnd, WEFPUIACCELHIDDEN)) {
        dis.itemState |= ODS_NOACCEL;
    }

    /*
     * Set the app supplied data
     */
    if (!plb->cMac || !plb->fHasData) {

        /*
         * If no strings or no items, just use 0 for data.  This is so that we
         * can display a caret when there are no items in the listbox.
         *
         * Lazy-eval listboxes of course have no data to pass - only itemID.
         */
        dis.itemData = 0L;
    } else {
        dis.itemData = LBGetItemData(plb, item);
    }

    CopyRect(&dis.rcItem, lprect);

    /*
     * Set the window origin to the horizontal scroll position.  This is so that
     * text can always be drawn at 0,0 and the view region will only start at
     * the horizontal scroll offset. We pass this as wParam
     */
    /*
     * Note:  Only pass the itemID in wParam for 3.1 or newer apps.  We break
     * ccMail otherwise.
     */

    ThreadLock(plb->spwndParent, &tlpwndParent);
    SendMessage(HW(plb->spwndParent), WM_DRAWITEM,
            TestWF(plb->spwndParent, WFWIN31COMPAT) ? dis.CtlID : 0,
            (LPARAM)&dis);
    ThreadUnlock(&tlpwndParent);
}


/***************************************************************************\
* xxxLBBlockHilite
*
*       In Extended selection mode for multiselection listboxes, when
*   mouse is draged to a new position, the range being marked should be
*   properly sized(parts of which will be highlighted/dehighlighted).
*   NOTE: This routine assumes that iSelFromPt and LasMouseMove are not
*          equal because only in that case this needs to be called;
*   NOTE: This routine calculates the region whose display attribute is to
*          be changed in an optimised way. Instead of de-highlighting the
*          the old range completely and highlight the new range, it omits
*          the regions that overlap and repaints only the non-pverlapping
*          area.
*   fKeyBoard = TRUE if this is called for Keyboard interface
*                FALSE if called from Mouse interface routines
*
* History:
\***************************************************************************/

void xxxLBBlockHilite(
    PLBIV plb,
    INT iSelFromPt,
    BOOL fKeyBoard)
{
    INT sCurPosOffset;
    INT sLastPosOffset;
    INT sHiliteOrSel;
    BOOL fUseSelStatus;
    BOOL DeHiliteStatus;

    CheckLock(plb->spwnd);

    if (fKeyBoard) {

        /*
         * Set both Hilite and Selection states
         */
        sHiliteOrSel = HILITEANDSEL;

        /*
         * Do not use the Selection state while de-hiliting
         */
        fUseSelStatus = FALSE;
        DeHiliteStatus = FALSE;
    } else {

        /*
         * Set/Reset only the Hilite state
         */
        sHiliteOrSel = HILITEONLY;

        /*
         * Use the selection state for de-hilighting
         */
        fUseSelStatus = TRUE;
        DeHiliteStatus = plb->fNewItemState;
    }



    /*
     * The idea of the routine is to :
     *          1.  De-hilite the old range (iMouseDown to iLastMouseDown)  and
     *          2.  Hilite the new range (iMouseDwon to iSelFromPt)
     */

    /*
     * Offset of current mouse position from the anchor point
     */
    sCurPosOffset = plb->iMouseDown - iSelFromPt;

    /*
     * Offset of last mouse position from the anchor point
     */
    sLastPosOffset = plb->iMouseDown - plb->iLastMouseMove;

    /*
     * Check if both current position and last position lie on the same
     * side of the anchor point.
     */
    if ((sCurPosOffset * sLastPosOffset) >= 0) {

        /*
         * Yes they are on the same side; So, highlight/dehighlight only
         * the difference.
         */
        if (abs(sCurPosOffset) > abs(sLastPosOffset)) {
            xxxAlterHilite(plb, plb->iLastMouseMove, iSelFromPt,
                    plb->fNewItemState, sHiliteOrSel, FALSE);
        } else {
            xxxAlterHilite(plb, iSelFromPt, plb->iLastMouseMove, DeHiliteStatus,
                    sHiliteOrSel, fUseSelStatus);
        }
    } else {
        xxxAlterHilite(plb, plb->iMouseDown, plb->iLastMouseMove,
                DeHiliteStatus, sHiliteOrSel, fUseSelStatus);
        xxxAlterHilite(plb, plb->iMouseDown, iSelFromPt,
                plb->fNewItemState, sHiliteOrSel, FALSE);
    }
}


/***************************************************************************\
* xxxAlterHilite
*
* Changes the hilite state of (i..j] (ie. excludes i, includes j in case
* you've forgotten this notation) to fHilite. It inverts this changes
* the hilite state.
*
*  OpFlags:  HILITEONLY      Only change the display state of the items
*            SELONLY         Only Change the selection state of the items
*            HILITEANDSELECT Do both.
*  fHilite:
*            HILITE/TRUE
*            DEHILITE/FALSE
*  fSelStatus:
*            if TRUE, use the selection state of the item to hilite/dehilite
*            if FALSE, use the fHilite parameter to hilite/dehilite
*
* History:
\***************************************************************************/

void xxxAlterHilite(
    PLBIV plb,
    INT i,
    INT j,
    BOOL fHilite,
    INT OpFlags,
    BOOL fSelStatus)
{
    INT low;
    INT high;
    INT sLastInWindow;
    BOOL fCaretOn;
    BOOL fSelected;

    CheckLock(plb->spwnd);

    sLastInWindow = plb->iTop + CItemInWindow(plb, TRUE);
    sLastInWindow = min(sLastInWindow, plb->cMac - 1);
    high = max(i, j) + 1;

    if (fCaretOn = plb->fCaretOn) {
        xxxLBSetCaret(plb, FALSE);
    }

    for (low = min(i, j); low < high; low++) {
        if (low != i) {
            if (OpFlags & HILITEONLY) {
                if (fSelStatus) {
                    fSelected = IsSelected(plb, low, SELONLY);
                } else {
                    fSelected = fHilite;
                }
                if (IsSelected(plb, low, HILITEONLY) != fSelected) {
                    if (plb->iTop <= low && low <= sLastInWindow) {

                        /*
                         * Invert the item only if it is visible
                         */
                        xxxInvertLBItem(plb, low, fSelected);
                    }
                    SetSelected(plb, low, fSelected, HILITEONLY);
                }
            }

            if (OpFlags & SELONLY) {
                SetSelected(plb, low, fHilite, SELONLY);
            }
        }
    }

    if (fCaretOn) {
        xxxLBSetCaret(plb, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\instance.c ===
/****************************** Module Header ******************************\
* Module Name: instance.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module handles conversion of instance handles (server side handles)
* to instance indecies used by the handle manager for associating a handle
* with a particular instance.
*
* History:
* 11-5-91 Sanfords Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define INST_GROW_COUNT 4

// globals

PHANDLE aInstance = NULL;
int cInstAllocated = 0;
int iFirstFreeInst = 0;


/***************************************************************************\
* AddInstance
*
* Description:
* Adds a server side instance handle to the instance handle array.
* The array index becomes the client-side unique instance index used for
* identifying other client side handles.
*
* Returns:
* client side instance handle or 0 on error.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/
HANDLE AddInstance(
HANDLE hInstServer)
{
    int i, iNextFree;
    PHANDLE ph, phTemp;

    if (iFirstFreeInst >= cInstAllocated) {
        if (cInstAllocated == 0) {
           aInstance = (PHANDLE)DDEMLAlloc(sizeof(HANDLE) * INST_GROW_COUNT);
        } else {
            /*
             * If the realloc failed, free the old ptr. We continue 
             * on in order to maintain compatibility with previous DDE code.
             */
            phTemp = (PHANDLE)DDEMLReAlloc((PVOID)aInstance,
                                          sizeof(HANDLE) * (cInstAllocated + INST_GROW_COUNT));

            if (phTemp == NULL) {
               DDEMLFree(aInstance);
            }
            aInstance = phTemp;
        }
        if (aInstance == 0) {
            return (0);
        }
        ph = &aInstance[cInstAllocated];
        i = cInstAllocated + 1;
        while (i <= cInstAllocated + INST_GROW_COUNT) {
           *ph++ = (HANDLE)(UINT_PTR)(UINT)i++;
        }
        cInstAllocated += INST_GROW_COUNT;
    }
    iNextFree = HandleToUlong(aInstance[iFirstFreeInst]);
    if (iNextFree > MAX_INST) {
        /*
         * Instance limit for this process exceeded!
         */
        return(0);
    }
    aInstance[iFirstFreeInst] = hInstServer;
    i = iFirstFreeInst;
    iFirstFreeInst = iNextFree;
    return (CreateHandle(0, HTYPE_INSTANCE, i));
}


/***************************************************************************\
* DestroyInstance
*
* Description:
* Removes an instance from the aInstance table. This does nothing for
* the server side instance info.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
HANDLE DestroyInstance(
HANDLE hInstClient)
{
    register HANDLE hInstServerRet = 0;

    DestroyHandle(hInstClient);
    hInstServerRet = aInstance[InstFromHandle(hInstClient)];
    aInstance[InstFromHandle(hInstClient)] = (HANDLE)UIntToPtr( iFirstFreeInst );
    iFirstFreeInst = InstFromHandle(hInstClient);

    return (hInstServerRet);
}


/***************************************************************************\
* ValidateInstance
*
* Description:
* Verifies the current validity of an instance handle - which is a server
* side handle that also references a client side data structure (pcii).
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
PCL_INSTANCE_INFO ValidateInstance(
HANDLE hInstClient)
{
    PCL_INSTANCE_INFO pcii;

    pcii = (PCL_INSTANCE_INFO)ValidateCHandle(hInstClient, HTYPE_INSTANCE, HINST_ANY);

    if (pcii != NULL) {
        if (pcii->tid != GetCurrentThreadId() ||
                pcii->hInstClient != hInstClient) {
            return (NULL);
        }
    }
    return (pcii);
}


/***************************************************************************\
* SetLastDDEMLError
*
* Description:
* Sets last error value and generates monitor events if monitoring.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
VOID SetLastDDEMLError(
PCL_INSTANCE_INFO pcii,
DWORD error)
{
    PEVENT_PACKET pep;

    if (pcii->MonitorFlags & MF_ERRORS && !(pcii->afCmd & APPCLASS_MONITOR)) {
        pep = (PEVENT_PACKET)DDEMLAlloc(sizeof(EVENT_PACKET) - sizeof(DWORD) +
                sizeof(MONERRSTRUCT));
        if (pep != NULL) {
            pep->EventType =    MF_ERRORS;
            pep->fSense =       TRUE;
            pep->cbEventData =  sizeof(MONERRSTRUCT);
#define perrs ((MONERRSTRUCT *)&pep->Data)
            perrs->cb =      sizeof(MONERRSTRUCT);
            perrs->wLastError = (WORD)error;
            perrs->dwTime =  NtGetTickCount();
            perrs->hTask =   (HANDLE)LongToHandle( pcii->tid );
#undef perrs
            LeaveDDECrit;
            Event(pep);
            EnterDDECrit;
        }
    }
#if DBG
    if (error != 0 && error != DMLERR_NO_CONV_ESTABLISHED) {
        RIPMSG3(RIP_WARNING,
                "DDEML Error set=%x, Client Instance=%p, Process=%x.",
                error, pcii, GetCurrentProcessId());
    }
#endif
    pcii->LastError = error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\immhotky.c ===
/**************************************************************************\
* Module Name: immhotky.c (user32 side IME hotkey handling)
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IME hot key management routines for imm32 dll
*
* History:
* 03-Jan-1996 hiroyama      Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


typedef struct tagFE_KEYBOARDS {
    BOOLEAN fJPN : 1;
    BOOLEAN fCHT : 1;
    BOOLEAN fCHS : 1;
    BOOLEAN fKOR : 1;
} FE_KEYBOARDS;

//
// internal functions
//
BOOL CliSaveImeHotKey(DWORD dwID, UINT uModifiers, UINT uVKey, HKL hkl, BOOL fDelete);
BOOL CliImmSetHotKeyWorker(DWORD dwID, UINT uModifiers, UINT uVKey, HKL hkl, DWORD dwAction);
VOID NumToHexAscii(DWORD, PTSTR);
BOOL CliGetImeHotKeysFromRegistry(void);
BOOL CliSetSingleHotKey(PKEY_BASIC_INFORMATION pKeyInfo, HANDLE hKey);
VOID CliSetDefaultImeHotKeys(PCIMEHOTKEY ph, INT num, BOOL fCheckExistingHotKey);
VOID CliGetPreloadKeyboardLayouts(FE_KEYBOARDS* pFeKbds);

//
// IMM hotkey related registry keys under HKEY_CURRENT_USER
//
CONST TCHAR *szaRegImmHotKeys[] = {
    TEXT("Control Panel"),
    TEXT("Input Method"),
    TEXT("Hot Keys"),
    NULL
};

CONST TCHAR szRegImeHotKey[] = TEXT("Control Panel\\Input Method\\Hot Keys");
CONST TCHAR szRegKeyboardPreload[] = TEXT("Keyboard Layout\\Preload");

CONST TCHAR szRegVK[] = TEXT("Virtual Key");
CONST TCHAR szRegMOD[] = TEXT("Key Modifiers");
CONST TCHAR szRegHKL[] = TEXT("Target IME");

//
// Default IME HotKey Tables
//
// CR:takaok - move this to the resource if you have time
//
CONST IMEHOTKEY DefaultHotKeyTableJ[]= {
    {IME_JHOTKEY_CLOSE_OPEN, VK_KANJI, MOD_IGNORE_ALL_MODIFIER, NULL}
};
CONST INT DefaultHotKeyNumJ = sizeof(DefaultHotKeyTableJ) / sizeof(IMEHOTKEY);

CONST IMEHOTKEY DefaultHotKeyTableT[] = {
    { IME_THOTKEY_IME_NONIME_TOGGLE, VK_SPACE, MOD_BOTH_SIDES|MOD_CONTROL, NULL },
    { IME_THOTKEY_SHAPE_TOGGLE, VK_SPACE, MOD_BOTH_SIDES|MOD_SHIFT,  NULL }
};
CONST INT DefaultHotKeyNumT = sizeof(DefaultHotKeyTableT) / sizeof(IMEHOTKEY);

CONST IMEHOTKEY DefaultHotKeyTableC[] = {
    { IME_CHOTKEY_IME_NONIME_TOGGLE, VK_SPACE, MOD_BOTH_SIDES|MOD_CONTROL, NULL },
    { IME_CHOTKEY_SHAPE_TOGGLE, VK_SPACE, MOD_BOTH_SIDES|MOD_SHIFT,  NULL }
};
CONST INT DefaultHotKeyNumC = sizeof(DefaultHotKeyTableC) / sizeof(IMEHOTKEY);

#if 0   // just FYI.
CONST IMEHOTKEY DefaultHotKeyTableK[] = {
    { IME_KHOTKEY_ENGLISH,  VK_HANGEUL, MOD_IGNORE_ALL_MODIFIER,  NULL },
    { IME_KHOTKEY_SHAPE_TOGGLE, VK_JUNJA, MOD_IGNORE_ALL_MODIFIER,  NULL },
    { IME_KHOTKEY_HANJACONVERT, VK_HANJA, MOD_IGNORE_ALL_MODIFIER, NULL }
};
CONST INT DefaultHotKeyNumK = sizeof(DefaultHotKeyTableK) / sizeof(IMEHOTKEY);
#endif

//
// Set language flags.
//
VOID SetFeKeyboardFlags(LANGID langid, FE_KEYBOARDS* pFeKbds)
{
    switch (langid) {
    case MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL):
    case MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_HONGKONG):
        pFeKbds->fCHT = TRUE;
        break;
    case MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED):
    case MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SINGAPORE):
        pFeKbds->fCHS = TRUE;
        break;
    case MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT):
        pFeKbds->fJPN = TRUE;
        break;
    case MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT):
        pFeKbds->fKOR = TRUE;
        break;
    }
}

/***************************************************************************\
* ImmInitializeHotkeys()
*
* Called from user\client\UpdatePerUserSystemParameters()
*
*  Read the User registry and set the IME hotkey.
*
* History:
* 25-Mar-1996 TakaoK       Created
\***************************************************************************/
VOID CliImmInitializeHotKeys(DWORD dwAction, HKL hkl)
{
    FE_KEYBOARDS feKbds = { 0, 0, 0, 0, };
    BOOL fFoundAny;

    UNREFERENCED_PARAMETER(hkl);

    // First, initialize the hotkey list
    CliImmSetHotKeyWorker(0, 0, 0, NULL, ISHK_INITIALIZE);

    // Check if the user has customized IME hotkeys
    // (they're stored in the registry)
    fFoundAny = CliGetImeHotKeysFromRegistry();

    if (dwAction == ISHK_INITIALIZE) {
        TAGMSG0(DBGTAG_IMM, "Setting IME HotKeys for Init.\n");

        // Get the user's default locale and set its flag
        SetFeKeyboardFlags(LANGIDFROMLCID(GetUserDefaultLCID()), &feKbds);

        // Get preloaded keyboards' locales and set their flags
        CliGetPreloadKeyboardLayouts(&feKbds);

    }
    else {
        UINT i;
        UINT nLayouts;
        LPHKL lphkl;

        TAGMSG0(DBGTAG_IMM, "Setting IME HotKeys for Add.\n");

        nLayouts = NtUserGetKeyboardLayoutList(0, NULL);
        if (nLayouts == 0) {
            return;
        }
        lphkl = UserLocalAlloc(0, nLayouts * sizeof(HKL));
        if (lphkl == NULL) {
            return;
        }
        NtUserGetKeyboardLayoutList(nLayouts, lphkl);
        for (i = 0; i < nLayouts; ++i) {
            //
            // Set language flags. By its definition, LOWORD(hkl) is LANGID
            //
            SetFeKeyboardFlags(LOWORD(HandleToUlong(lphkl[i])), &feKbds);
        }
        UserLocalFree(lphkl);
    }

    if (feKbds.fJPN) {
        TAGMSG0(DBGTAG_IMM, "JPN KL Preloaded.\n");
        CliSetDefaultImeHotKeys(DefaultHotKeyTableJ, DefaultHotKeyNumJ, fFoundAny);
    }

    if (feKbds.fKOR) {
        TAGMSG0(DBGTAG_IMM, "KOR KL Preloaded, but KOR hotkeys will not be registered.\n");
    }

    if (feKbds.fCHT) {
        TAGMSG0(DBGTAG_IMM, "CHT KL Preloaded.\n");
        CliSetDefaultImeHotKeys(DefaultHotKeyTableT, DefaultHotKeyNumT, fFoundAny);
    }
    if (feKbds.fCHS) {
        TAGMSG0(DBGTAG_IMM, "CHS KL Preloaded.\n");
        CliSetDefaultImeHotKeys(DefaultHotKeyTableC, DefaultHotKeyNumC, fFoundAny);
    }
}

VOID CliSetDefaultImeHotKeys(PCIMEHOTKEY ph, INT num, BOOL fNeedToCheckExistingHotKey)
{
    IMEHOTKEY hkt;

    while( num-- > 0 ) {
        //
        // Set IME hotkey only if there is no such
        // hotkey in the registry
        //
        if (!fNeedToCheckExistingHotKey ||
                !NtUserGetImeHotKey(ph->dwHotKeyID, &hkt.uModifiers, &hkt.uVKey, &hkt.hKL)) {

            CliImmSetHotKeyWorker(ph->dwHotKeyID,
                                    ph->uModifiers,
                                    ph->uVKey,
                                    ph->hKL,
                                    ISHK_ADD);
        }
        ph++;
    }
}

/***************************************************************************\
* CliGetPreloadKeyboardLayouts()
*
*  Read the User registry and enumerate values in Keyboard Layouts\Preload
* to see which FE languages are to be preloaded.
*
* History:
* 03-Dec-1997 Hiroyama     Created
\***************************************************************************/

VOID CliGetPreloadKeyboardLayouts(FE_KEYBOARDS* pFeKbds)
{
    UINT  i;
    WCHAR szPreLoadee[4];   // up to 999 preloads
    WCHAR lpszName[KL_NAMELENGTH];
    UNICODE_STRING UnicodeString;
    HKL hkl;

    for (i = 1; i < 1000; i++) {
        wsprintf(szPreLoadee, L"%d", i);
        if ((GetPrivateProfileStringW(
                 L"Preload",
                 szPreLoadee,
                 L"",                            // default = NULL
                 lpszName,                       // output buffer
                 KL_NAMELENGTH,
                 L"keyboardlayout.ini") == -1 ) || (*lpszName == L'\0')) {
            break;
        }
        RtlInitUnicodeString(&UnicodeString, lpszName);
        RtlUnicodeStringToInteger(&UnicodeString, 16L, (PULONG)&hkl);

        RIPMSG2(RIP_VERBOSE, "PreLoaded HKL(%d): %08X\n", i, hkl);

        //
        // Set language flags. By its definition, LOWORD(hkl) is LANGID
        //
        SetFeKeyboardFlags(LOWORD(HandleToUlong(hkl)), pFeKbds);
    }
}

BOOL CliGetImeHotKeysFromRegistry()
{
    BOOL    fFoundAny = FALSE;

    HANDLE hCurrentUserKey;
    HANDLE hKeyHotKeys;

    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      SubKeyName;

    NTSTATUS Status;
    ULONG uIndex;

    //
    // Open the current user registry key
    //
    Status = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &hCurrentUserKey);
    if (!NT_SUCCESS(Status)) {
        return fFoundAny;
    }

    RtlInitUnicodeString( &SubKeyName, szRegImeHotKey );
    InitializeObjectAttributes( &Obja,
                                &SubKeyName,
                                OBJ_CASE_INSENSITIVE,
                                hCurrentUserKey,
                                NULL);
    Status = NtOpenKey( &hKeyHotKeys, KEY_READ, &Obja );
    if (!NT_SUCCESS(Status)) {
        NtClose( hCurrentUserKey );
        return fFoundAny;
    }

    for (uIndex = 0; TRUE; uIndex++) {
        BYTE KeyBuffer[sizeof(KEY_BASIC_INFORMATION) + 16 * sizeof(WCHAR)];
        PKEY_BASIC_INFORMATION pKeyInfo;
        ULONG ResultLength;

        pKeyInfo = (PKEY_BASIC_INFORMATION)KeyBuffer;
        Status = NtEnumerateKey(hKeyHotKeys,
                                 uIndex,
                                 KeyBasicInformation,
                                 pKeyInfo,
                                 sizeof( KeyBuffer ),
                                 &ResultLength );

        if (NT_SUCCESS(Status)) {

            if (CliSetSingleHotKey(pKeyInfo, hKeyHotKeys)) {

                    fFoundAny = TRUE;
            }

        } else if (Status == STATUS_NO_MORE_ENTRIES) {
            break;
        }
    }

    NtClose(hKeyHotKeys);
    NtClose(hCurrentUserKey);

    return fFoundAny;
}

DWORD CliReadRegistryValue(HANDLE hKey, PCWSTR pName)
{
    BYTE ValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 16 * sizeof(UCHAR)];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValue;
    UNICODE_STRING      ValueName;
    ULONG ResultLength;
    NTSTATUS Status;

    pKeyValue = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;

    RtlInitUnicodeString(&ValueName, pName);
    Status = NtQueryValueKey(hKey,
                             &ValueName,
                             KeyValuePartialInformation,
                             pKeyValue,
                             sizeof(ValueBuffer),
                             &ResultLength );

    if (NT_SUCCESS(Status) && pKeyValue->DataLength > 3) {
        //
        // In Win95 registry, these items are written as BYTE data...
        //
        return (DWORD)(MAKEWORD( pKeyValue->Data[0], pKeyValue->Data[1])) |
                 (((DWORD)(MAKEWORD( pKeyValue->Data[2], pKeyValue->Data[3]))) << 16);
    }

    return 0;
}

BOOL CliSetSingleHotKey(PKEY_BASIC_INFORMATION pKeyInfo, HANDLE hKey)
{
    UNICODE_STRING      SubKeyName;
    HANDLE    hKeySingleHotKey;
    OBJECT_ATTRIBUTES   Obja;

    DWORD dwID = 0;
    UINT  uVKey = 0;
    UINT  uModifiers = 0;
    HKL   hKL = NULL;

    NTSTATUS Status;

    SubKeyName.Buffer = (PWSTR)&(pKeyInfo->Name[0]);
    SubKeyName.Length = (USHORT)pKeyInfo->NameLength;
    SubKeyName.MaximumLength = (USHORT)pKeyInfo->NameLength;
    InitializeObjectAttributes(&Obja,
                               &SubKeyName,
                               OBJ_CASE_INSENSITIVE,
                               hKey,
                               NULL);

    Status = NtOpenKey(&hKeySingleHotKey, KEY_READ, &Obja);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    RtlUnicodeStringToInteger(&SubKeyName, 16L, &dwID);
    uVKey = CliReadRegistryValue(hKeySingleHotKey, szRegVK);
    uModifiers = CliReadRegistryValue(hKeySingleHotKey, szRegMOD);
    hKL = (HKL)LongToHandle( CliReadRegistryValue(hKeySingleHotKey, szRegHKL) );

    NtClose(hKeySingleHotKey);

    return CliImmSetHotKeyWorker(dwID, uModifiers, uVKey, hKL, ISHK_ADD);
}

/***************************************************************************\
* ImmSetHotKey()
*
* Private API for IMEs and the control panel.
*
* History:
* 25-Mar-1996 TakaoK       Created
\***************************************************************************/

FUNCLOG4(LOG_GENERAL, BOOL, WINAPI, CliImmSetHotKey, DWORD, dwID, UINT, uModifiers, UINT, uVKey, HKL, hkl)
BOOL WINAPI CliImmSetHotKey(
    DWORD dwID,
    UINT uModifiers,
    UINT uVKey,
    HKL hkl)
{
    BOOL fResult;
    BOOL fTmp;
    BOOL fDelete = (uVKey == 0 );

    if (fDelete) {
        //
        // Removing an IME hotkey from the list in the kernel side
        // should not be failed, if we succeed to remove the IME
        // hotkey entry from the registry. Therefore CliSaveImeHotKey
        // is called first.
        //
        fResult = CliSaveImeHotKey( dwID, uModifiers, uVKey, hkl,  fDelete );
        if (fResult) {
            fTmp = CliImmSetHotKeyWorker( dwID, uModifiers, uVKey, hkl, ISHK_REMOVE );
            UserAssert(fTmp);
        }
    } else {
        //
        // CliImmSetHotKeyWorker should be called first since
        // adding an IME hotkey into the list in the kernel side
        // will be failed in various reasons.
        //
        fResult = CliImmSetHotKeyWorker(dwID, uModifiers, uVKey, hkl, ISHK_ADD);
        if (fResult) {
            fResult = CliSaveImeHotKey(dwID, uModifiers, uVKey, hkl, fDelete);
            if (!fResult) {
                //
                // We failed to save the hotkey to the registry.
                // We need to remove the entry from the IME hotkey
                // list in the kernel side.
                //
                fTmp = CliImmSetHotKeyWorker(dwID, uModifiers, uVKey, hkl, ISHK_REMOVE);
                UserAssert(fTmp);
            }
        }
    }
    return fResult;
}

/***************************************************************************\
* CliSaveImeHotKey()
*
*  Put/Remove the specified IME hotkey entry from the registry
*
* History:
* 25-Mar-1996 TakaoK       Created
\***************************************************************************/
BOOL CliSaveImeHotKey(DWORD id, UINT mod, UINT vk, HKL hkl, BOOL fDelete)
{
    HKEY hKey, hKeyParent;
    INT i;
    LONG lResult;
    TCHAR szHex[16];

    if (fDelete) {
        TCHAR szRegTmp[(sizeof(szRegImeHotKey) / sizeof(TCHAR) + 1 + 8 + 1)];

        lstrcpy(szRegTmp, szRegImeHotKey);
        lstrcat(szRegTmp, TEXT("\\"));
        NumToHexAscii(id, szHex);
        lstrcat(szRegTmp, szHex);

        lResult = RegDeleteKeyW(HKEY_CURRENT_USER, szRegTmp);
        if (lResult != ERROR_SUCCESS) {
            RIPERR1(lResult, RIP_WARNING,
                     "CliSaveImeHotKey: deleting %s failed", szRegTmp);
            return FALSE;
        }
        return TRUE;
    }

    hKeyParent = HKEY_CURRENT_USER;
    for (i = 0; szaRegImmHotKeys[i] != NULL; i++) {
        lResult = RegCreateKeyExW(hKeyParent,
                                  szaRegImmHotKeys[i],
                                  0,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_WRITE|KEY_READ,
                                  NULL,
                                  &hKey,
                                  NULL );
        RegCloseKey(hKeyParent);
        if (lResult == ERROR_SUCCESS) {
            hKeyParent = hKey;
        } else {
            RIPERR1(lResult, RIP_WARNING,
                    "CliSaveImeHotKey: creating %s failed", szaRegImmHotKeys[i]);

            return FALSE;
        }
    }

    NumToHexAscii(id, szHex);
    lResult = RegCreateKeyExW(hKeyParent,
                             szHex,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE|KEY_READ,
                             NULL,
                             &hKey,
                             NULL );
    RegCloseKey(hKeyParent);
    if (lResult != ERROR_SUCCESS) {
        RIPERR1(lResult, RIP_WARNING,
                "CliSaveImeHotKey: creating %s failed", szHex );
        return FALSE;
    }

    lResult = RegSetValueExW(hKey,
                             szRegVK,
                             0,
                             REG_BINARY,
                            (LPBYTE)&vk,
                            sizeof(DWORD));
    if (lResult != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        CliSaveImeHotKey(id, vk, mod, hkl, TRUE);
        RIPERR1( lResult, RIP_WARNING,
                 "SaveImeHotKey:setting value on %s failed", szRegVK );
        return ( FALSE );
    }
    lResult = RegSetValueExW(hKey,
                             szRegMOD,
                             0,
                             REG_BINARY,
                             (LPBYTE)&mod,
                             sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        CliSaveImeHotKey(id, vk, mod, hkl, TRUE);
        RIPERR1(lResult, RIP_WARNING,
                "CliSaveImeHotKey: setting value on %s failed", szRegMOD);
        return FALSE;
    }

    lResult = RegSetValueExW(hKey,
                             szRegHKL,
                             0,
                             REG_BINARY,
                             (LPBYTE)&hkl,
                             sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        CliSaveImeHotKey(id, vk, mod, hkl, TRUE);
        RIPERR1(lResult, RIP_WARNING,
                "CliSaveImeHotKey: setting value on %s failed", szRegHKL);
        return FALSE;
    }

    RegCloseKey(hKey);
    return TRUE;
}

BOOL CliImmSetHotKeyWorker(
    DWORD dwID,
    UINT uModifiers,
    UINT uVKey,
    HKL hkl,
    DWORD dwAction)
{
    //
    // if we're adding an IME hotkey entry, let's check
    // the parameters before calling the kernel side code
    //
    if (dwAction == ISHK_ADD) {

        if (dwID >= IME_HOTKEY_DSWITCH_FIRST &&
                dwID <= IME_HOTKEY_DSWITCH_LAST) {
            //
            // IME direct switching hot key - switch to
            // the keyboard layout specified.
            // We need to specify keyboard layout.
            //
            if (hkl == NULL) {
                RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "hkl should be specified");
                return FALSE;
            }

        } else {
            //
            // normal hot keys - change the mode of current iME
            //
            // Because it should be effective in all IME no matter
            // which IME is active we should not specify a target IME
            //
            if (hkl != NULL) {
                RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "hkl shouldn't be specified");
                return FALSE;
            }

            if (dwID >= IME_KHOTKEY_FIRST && dwID <= IME_KHOTKEY_LAST) {
                RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Hotkey for Korean IMEs are invalid.");
                return FALSE;
            }
        }

        if (uModifiers & MOD_MODIFY_KEYS) {
            //
            // Because normal keyboard has left and right key for
            // these keys, you should specify left or right ( or both )
            //
            if ((uModifiers & MOD_BOTH_SIDES) == 0) {
                RIPERR3(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid modifiers %x for id %x vKey %x", uModifiers, dwID, uVKey);
                return FALSE;
            }
        }

#if 0   // Skip this check for now
        //
        // It doesn't make sense if vkey is same as modifiers
        //
        if ( ((uModifiers & MOD_ALT) && (uVKey == VK_MENU))        ||
             ((uModifiers & MOD_CONTROL) && (uVKey == VK_CONTROL)) ||
             ((uModifiers & MOD_SHIFT) && (uVKey == VK_SHIFT))     ||
             ((uModifiers & MOD_WIN) && ((uVKey == VK_LWIN)||(uVKey == VK_RWIN)))
           ) {

            RIPERR0( ERROR_INVALID_PARAMETER, RIP_WARNING, "vkey and modifiers are same");
            return FALSE;
        }
#endif
    }
    return NtUserSetImeHotKey(dwID, uModifiers, uVKey, hkl, dwAction);
}

//
// NumToHexAscii
//
// convert a DWORD into the hex string
// (e.g. 0x31 -> "00000031")
//
// 29-Jan-1996 takaok   ported from Win95.
//
static CONST TCHAR szHexString[] = TEXT("0123456789ABCDEF");

VOID
NumToHexAscii(
    DWORD dwNum,
    PWSTR szAscii)
{
    int i;

    for (i = 7; i >= 0; i--) {
        szAscii[i] = szHexString[dwNum & 0x0000000f];
        dwNum >>= 4;
    }
    szAscii[8] = TEXT('\0');

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\lb1.c ===
/****************************** Module Header ********************************\
* Module Name: lb1.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* ListBox routines
*
* History:
* ??-???-???? ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code
\*****************************************************************************/

#include "precomp.h"
#pragma hdrstop

LOOKASIDE ListboxLookaside;


/***************************************************************************\
* xxxLBoxCtlWndProc
*
* Window Procedure for ListBox AND ComboLBox control.
* NOTE: All window procedures are APIENTRY
* WARNING: This listbox code contains some internal messages and styles which
* are defined in combcom.h and in combcom.inc.  They may be redefined
* (or renumbered) as needed to extend the windows API.
*
* History:
* 16-Apr-1992 beng      Added LB_SETCOUNT
\***************************************************************************/

LRESULT APIENTRY ListBoxWndProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    PAINTSTRUCT ps;
    HDC         hdc;
    LPRECT      lprc;
    PLBIV plb;    /* List Box Instance Variable */
    INT iSel;     /* Index of selected item */
    DWORD dw;
    TL tlpwndParent;
    UINT wFlags;
    LPWSTR lpwsz = NULL;
    LRESULT lReturn = 0;
    static BOOL fInit = TRUE;

    CheckLock(pwnd);

    VALIDATECLASSANDSIZE(pwnd, FNID_LISTBOX);
    INITCONTROLLOOKASIDE(&ListboxLookaside, LBIV, spwnd, 4);

    /*
     * Get the plb for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,0,plb)
     * when the listbox was first created (by INITCONTROLLOOKASIDE above)
     */
    plb = ((PLBWND)pwnd)->pLBIV;

    /*
     * Handle ANSI translations of input parameters
     */
    if (fAnsi) {
        switch (message) {
        case LB_ADDSTRING:
        case LB_ADDSTRINGUPPER:
        case LB_ADDSTRINGLOWER:
        case LB_FINDSTRING:
        case LB_FINDSTRINGEXACT:
        case LB_INSERTSTRING:
        case LB_INSERTSTRINGUPPER:
        case LB_INSERTSTRINGLOWER:
        case LB_SELECTSTRING:
            if (!plb->fHasStrings) {
                break;
            }
            // Fall through...
        case LB_ADDFILE:
        case LB_DIR:
            if (lParam) {
                if (!MBToWCS((LPSTR)lParam, -1, &lpwsz, -1, TRUE))
                    return LB_ERR;
            }
            break;
        default:
            break;
        }
        if (lpwsz) {
            lParam = (LPARAM)lpwsz;
        }
    }

    switch (message) {

    case LB_GETTOPINDEX:        // Return index of top item displayed.
        return plb->iTop;

    case LB_SETTOPINDEX:
        if (wParam && ((INT)wParam < 0 || (INT)wParam >= plb->cMac)) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return LB_ERR;
        }
        if (plb->cMac) {
            xxxNewITop(plb, (INT)wParam);
        }
        break;

    case WM_STYLECHANGED:
        plb->fRtoLReading = (TestWF(pwnd, WEFRTLREADING) != 0);
        plb->fRightAlign  = (TestWF(pwnd, WEFRIGHT) != 0);
        xxxCheckRedraw(plb, FALSE, 0);
        break;

    case WM_WINDOWPOSCHANGED:

        /*
         * If we are in the middle of creation, ignore this
         * message because it will generate a WM_SIZE message.
         * See xxxLBCreate().
         */
        if (!plb->fIgnoreSizeMsg)
            goto CallDWP;
        break;

    case WM_SIZE:

        /*
         * If we are in the middle of creation, ignore size
         * messages.  See xxxLBCreate().
         */
        if (!plb->fIgnoreSizeMsg)
            xxxLBSize(plb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        break;

    case WM_ERASEBKGND:
        ThreadLock(plb->spwndParent, &tlpwndParent);
        FillWindow(HW(plb->spwndParent), hwnd, (HDC)wParam,
                (HBRUSH)CTLCOLOR_LISTBOX);
        ThreadUnlock(&tlpwndParent);
        return TRUE;

    case LB_RESETCONTENT:
        xxxLBResetContent(plb);
        break;

    case WM_TIMER:
        if (wParam == IDSYS_LBSEARCH) {
            plb->iTypeSearch = 0;
            NtUserKillTimer(hwnd, IDSYS_LBSEARCH);
            xxxInvertLBItem(plb, plb->iSel, TRUE);
            break;
        }

        message = WM_MOUSEMOVE;
        xxxTrackMouse(plb, message, plb->ptPrev);
        break;

        /*
         * Fall through
         */
    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_LBUTTONDBLCLK:
        {
            POINT pt;

            POINTSTOPOINT(pt, lParam);
            xxxTrackMouse(plb, message, pt);
        }
        break;

    case WM_MBUTTONDOWN:
        EnterReaderModeHelper(hwnd);
        break;

    case WM_CAPTURECHANGED:
            //
            // Note that this message should be handled only on unexpected
            // capture changes currently.
            //
        UserAssert(TestWF(pwnd, WFWIN40COMPAT));
        if (plb->fCaptured)
            xxxLBButtonUp(plb, LBUP_NOTIFY);
        break;

    case LBCB_STARTTRACK:
        //
        // Start tracking mouse moves in the listbox, setting capture
        //
        if (!plb->pcbox)
            break;

        plb->fCaptured = FALSE;
        if (wParam) {
            POINT pt;

            POINTSTOPOINT(pt, lParam);

            _ScreenToClient(pwnd, &pt);
            xxxTrackMouse(plb, WM_LBUTTONDOWN, pt);
        } else {
            NtUserSetCapture(hwnd);
            plb->fCaptured = TRUE;
            plb->iLastSelection = plb->iSel;
        }
        break;

    case LBCB_ENDTRACK:
        // Kill capture, tracking, etc.
        if (plb->fCaptured)
            xxxLBButtonUp(plb, LBUP_RELEASECAPTURE | (wParam ? LBUP_SELCHANGE :
                LBUP_RESETSELECTION));
        break;

    case WM_PRINTCLIENT:
        xxxLBPaint(plb, (HDC) wParam, NULL);
        break;

    case WM_PAINT:
        if (wParam) {
            hdc = (HDC) wParam;
            lprc = NULL;
        } else {
            hdc = NtUserBeginPaint(hwnd, &ps);
            lprc = &(ps.rcPaint);
        }

        if (IsLBoxVisible(plb))
            xxxLBPaint(plb, hdc, lprc);

        if (!wParam)
            NtUserEndPaint(hwnd, &ps);
        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        xxxDestroyLBox(plb, pwnd);
        break;

    case WM_SETFOCUS:
// DISABLED in Win 3.1        xxxUpdateWindow(pwnd);
        CaretCreate(plb);
        xxxLBSetCaret(plb, TRUE);
        xxxNotifyOwner(plb, LBN_SETFOCUS);

        /*
         * We need to send this event even if the listbox isn't visible. See
         * bug #88548.
         */
         LBEvent(plb, EVENT_OBJECT_FOCUS, plb->iSelBase);
        break;

    case WM_KILLFOCUS:
        /*
         * Reset the wheel delta count.
         */
        gcWheelDelta = 0;

        xxxLBSetCaret(plb, FALSE);
        xxxCaretDestroy(plb);
        xxxNotifyOwner(plb, LBN_KILLFOCUS);
        if (plb->iTypeSearch) {
            plb->iTypeSearch = 0;
            NtUserKillTimer(hwnd, IDSYS_LBSEARCH);
        }
        if (plb->pszTypeSearch) {
            UserLocalFree(plb->pszTypeSearch);
            plb->pszTypeSearch = NULL;
        }
        break;

    case WM_MOUSEWHEEL:
        {
            int     cDetants;
            int     cPage;
            int     cLines;
            RECT    rc;
            int     windowWidth;
            int     cPos;

            /*
             * Don't handle zoom and datazoom.
             */
            if (wParam & (MK_SHIFT | MK_CONTROL)) {
                goto CallDWP;
            }

            lReturn = 1;
            gcWheelDelta -= (short) HIWORD(wParam);
            cDetants = gcWheelDelta / WHEEL_DELTA;
            if (    cDetants != 0 &&
                    gpsi->ucWheelScrollLines > 0 &&
                    (pwnd->style & (WS_VSCROLL | WS_HSCROLL))) {

                gcWheelDelta = gcWheelDelta % WHEEL_DELTA;

                if (pwnd->style & WS_VSCROLL) {
                    cPage = max(1, (plb->cItemFullMax - 1));
                    cLines = cDetants *
                            (int) min((UINT) cPage, gpsi->ucWheelScrollLines);

                    cPos = max(0, min(plb->iTop + cLines, plb->cMac - 1));
                    if (cPos != plb->iTop) {
                        xxxLBoxCtlScroll(plb, SB_THUMBPOSITION, cPos);
                        xxxLBoxCtlScroll(plb, SB_ENDSCROLL, 0);
                    }
                } else if (plb->fMultiColumn) {
                    cPage = max(1, plb->numberOfColumns);
                    cLines = cDetants * (int) min((UINT) cPage, gpsi->ucWheelScrollLines);
                    cPos = max(
                            0,
                            min((plb->iTop / plb->itemsPerColumn) + cLines,
                                plb->cMac - 1 - ((plb->cMac - 1) % plb->itemsPerColumn)));

                    if (cPos != plb->iTop) {
                        xxxLBoxCtlHScrollMultiColumn(plb, SB_THUMBPOSITION, cPos);
                        xxxLBoxCtlHScrollMultiColumn(plb, SB_ENDSCROLL, 0);
                    }
                } else {
                    _GetClientRect(plb->spwnd, &rc);
                    windowWidth = rc.right;
                    cPage = max(plb->cxChar, (windowWidth / 3) * 2) /
                            plb->cxChar;

                    cLines = cDetants *
                            (int) min((UINT) cPage, gpsi->ucWheelScrollLines);

                    cPos = max(
                            0,
                            min(plb->xOrigin + (cLines * plb->cxChar),
                                plb->maxWidth));

                    if (cPos != plb->xOrigin) {
                        xxxLBoxCtlHScroll(plb, SB_THUMBPOSITION, cPos);
                        xxxLBoxCtlHScroll(plb, SB_ENDSCROLL, 0);
                    }
                }
            }
        }
        break;

    case WM_VSCROLL:
        xxxLBoxCtlScroll(plb, LOWORD(wParam), HIWORD(wParam));
        break;

    case WM_HSCROLL:
        xxxLBoxCtlHScroll(plb, LOWORD(wParam), HIWORD(wParam));
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS | DLGC_WANTCHARS;

    case WM_CREATE:
        return xxxLBCreate(plb, pwnd, (LPCREATESTRUCT) lParam);

    case WM_SETREDRAW:

        /*
         * If wParam is nonzero, the redraw flag is set
         * If wParam is zero, the flag is cleared
         */
        xxxLBSetRedraw(plb, (wParam != 0));
        break;

    case WM_ENABLE:
        xxxLBInvalidateRect(plb, NULL, !plb->OwnerDraw);
        break;

    case WM_SETFONT:
        xxxLBSetFont(plb, (HANDLE)wParam, LOWORD(lParam));
        break;

    case WM_GETFONT:
        return (LRESULT)plb->hFont;

    case WM_DRAGSELECT:
    case WM_DRAGLOOP:
    case WM_DRAGMOVE:
    case WM_DROPFILES:
        ThreadLock(plb->spwndParent, &tlpwndParent);
        lReturn = SendMessage(HW(plb->spwndParent), message, wParam, lParam);
        ThreadUnlock(&tlpwndParent);
        return lReturn;


    case WM_QUERYDROPOBJECT:
    case WM_DROPOBJECT:

        /*
         * fix up control data, then pass message to parent
         */
        LBDropObjectHandler(plb, (PDROPSTRUCT)lParam);
        ThreadLock(plb->spwndParent, &tlpwndParent);
        lReturn = SendMessage(HW(plb->spwndParent), message, wParam, lParam);
        ThreadUnlock(&tlpwndParent);
        return lReturn;

    case LB_GETITEMRECT:
        return LBGetItemRect(plb, (INT)wParam, (LPRECT)lParam);

    case LB_GETITEMDATA:
        return LBGetItemData(plb, (INT)wParam);  // wParam = item index

    case LB_SETITEMDATA:

        /*
         * wParam is item index
         */
        return LBSetItemData(plb, (INT)wParam, lParam);

    case LB_ADDSTRINGUPPER:
        wFlags = UPPERCASE | LBI_ADD;
        goto CallInsertItem;

    case LB_ADDSTRINGLOWER:
        wFlags = LOWERCASE | LBI_ADD;
        goto CallInsertItem;

    case LB_ADDSTRING:
        wFlags = LBI_ADD;
        goto CallInsertItem;

    case LB_INSERTSTRINGUPPER:
        wFlags = UPPERCASE;
        goto CallInsertItem;

    case LB_INSERTSTRINGLOWER:
        wFlags = LOWERCASE;
        goto CallInsertItem;

    case LB_INSERTSTRING:
        wFlags = 0;
CallInsertItem:
        lReturn = ((LRESULT) xxxLBInsertItem(plb, (LPWSTR) lParam, (int) wParam, wFlags));
        break;

    case LB_INITSTORAGE:
        return xxxLBInitStorage(plb, fAnsi, (INT)wParam, (INT)lParam);

    case LB_DELETESTRING:
        return xxxLBoxCtlDelete(plb, (INT)wParam);

    case LB_DIR:
        /*
         * wParam - Dos attribute value.
         * lParam - Points to a file specification string
         */
        lReturn = xxxLbDir(plb, (INT)wParam, (LPWSTR)lParam);
        break;

    case LB_ADDFILE:
        lReturn = xxxLbInsertFile(plb, (LPWSTR)lParam);
        break;

    case LB_SETSEL:
        return xxxLBSetSel(plb, (wParam != 0), (INT)lParam);

    case LB_SETCURSEL:
        /*
         * If window obscured, update so invert will work correctly
         */
// DISABLED in Win 3.1        xxxUpdateWindow(pwnd);
        return xxxLBSetCurSel(plb, (INT)wParam);

    case LB_GETSEL:
        if (wParam >= (UINT) plb->cMac)
                return((LRESULT) LB_ERR);

        return IsSelected(plb, (INT)wParam, SELONLY);

    case LB_GETCURSEL:
        if (plb->wMultiple == SINGLESEL) {
            return plb->iSel;
        }
        return plb->iSelBase;

    case LB_SELITEMRANGE:
        if (plb->wMultiple == SINGLESEL) {
            /*
             * Can't select a range if only single selections are enabled
             */
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE,"Invalid index passed to LB_SELITEMRANGE");
            return LB_ERR;
        }

        xxxLBSelRange(plb, LOWORD(lParam), HIWORD(lParam), (wParam != 0));
        break;

    case LB_SELITEMRANGEEX:
        if (plb->wMultiple == SINGLESEL) {
            /*
             * Can't select a range if only single selections are enabled
             */
            RIPERR0(ERROR_INVALID_LB_MESSAGE, RIP_VERBOSE,"LB_SELITEMRANGEEX:Can't select a range if only single selections are enabled");
            return LB_ERR;
        } else {
            BOOL fHighlight = ((DWORD)lParam > (DWORD)wParam);
            if (fHighlight == FALSE) {
                ULONG_PTR temp = lParam;
                lParam = wParam;
                wParam = temp;
            }
            xxxLBSelRange(plb, (INT)wParam, (INT)lParam, fHighlight);
        }
        break;

    case LB_GETTEXTLEN:
        if (lParam != 0) {
            RIPMSG1(RIP_WARNING, "LB_GETTEXTLEN with lParam = %lx\n", lParam);
        }
        lReturn = LBGetText(plb, TRUE, fAnsi, (INT)wParam, NULL);
        break;

    case LB_GETTEXT:
        lReturn = LBGetText(plb, FALSE, fAnsi, (INT)wParam, (LPWSTR)lParam);
        break;

    case LB_GETCOUNT:
        // Lotus Approach calls CallWndProc(ListWndProc, LB_GETCOUNT,...)
        // on a window that doesn't have a plb yet. So, we need to make
        // this check. Bug #6675 - 11/7/94 --
        if(plb)
            return((LRESULT) plb->cMac);
        else
            return(0);

    case LB_SETCOUNT:
        return xxxLBSetCount(plb, (INT)wParam);

    case LB_SELECTSTRING:
    case LB_FINDSTRING:
        iSel = xxxFindString(plb, (LPWSTR)lParam, (INT)wParam, PREFIX, TRUE);
        if (message == LB_FINDSTRING || iSel == LB_ERR) {
            lReturn = iSel;
        } else {
            lReturn = xxxLBSetCurSel(plb, iSel);
        }
        break;

    case LB_GETLOCALE:
        return plb->dwLocaleId;

    case LB_SETLOCALE:

        /*
         * Validate locale
         */
        wParam = ConvertDefaultLocale((LCID)wParam);
        if (!IsValidLocale((LCID)wParam, LCID_INSTALLED))
            return LB_ERR;

        dw = plb->dwLocaleId;
        plb->dwLocaleId = (DWORD)wParam;
        return dw;

    case WM_KEYDOWN:

        /*
         * IanJa: Use LOWORD() to get low 16-bits of wParam - this should
         * work for Win16 & Win32.  The value obtained is the virtual key
         */
        xxxLBoxCtlKeyInput(plb, message, LOWORD(wParam));
        break;

    case WM_CHAR:
        xxxLBoxCtlCharInput(plb, LOWORD(wParam), fAnsi);
        break;

    case LB_GETSELITEMS:
    case LB_GETSELCOUNT:

        /*
         * IanJa/Win32 should this be LPWORD now?
         */
        return LBoxGetSelItems(plb, (message == LB_GETSELCOUNT), (INT)wParam,
                (LPINT)lParam);

    case LB_SETTABSTOPS:

        /*
         * IanJa/Win32: Tabs given by array of INT for backwards compatability
         */
        return LBSetTabStops(plb, (INT)wParam, (LPINT)lParam);

    case LB_GETHORIZONTALEXTENT:

        /*
         * Return the max width of the listbox used for horizontal scrolling
         */
        return plb->maxWidth;

    case LB_SETHORIZONTALEXTENT:

        /*
         * Set the max width of the listbox used for horizontal scrolling
         */
        if (plb->maxWidth != (INT)wParam) {
            plb->maxWidth = (INT)wParam;

            /*
             * When horizontal extent is set, Show/hide the scroll bars.
             * NOTE: LBShowHideScrollBars() takes care if Redraw is OFF.
             * Fix for Bug #2477 -- 01/14/91 -- SANKAR --
             */
            xxxLBShowHideScrollBars(plb); //Try to show or hide scroll bars
            if (plb->fHorzBar && plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw)) {
                /*
                 * origin to right
                 */
                xxxLBoxCtlHScroll(plb, SB_BOTTOM, 0);
            }
        }
        break;    /* originally returned register ax (message) ! */

    case LB_SETCOLUMNWIDTH:

        /*
         * Set the width of a column in a multicolumn listbox
         */
        plb->cxColumn = (INT)wParam;
        LBCalcItemRowsAndColumns(plb);
        if (IsLBoxVisible(plb))
            NtUserInvalidateRect(hwnd, NULL, TRUE);
        xxxLBShowHideScrollBars(plb);
        break;

    case LB_SETANCHORINDEX:
        if ((INT)wParam >= plb->cMac) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE,"Invalid index passed to LB_SETANCHORINDEX");
            return LB_ERR;
        }
        plb->iMouseDown = (INT)wParam;
        plb->iLastMouseMove = (INT)wParam;
        xxxInsureVisible(plb, (int) wParam, (BOOL)(lParam != 0));
        break;

    case LB_GETANCHORINDEX:
        return plb->iMouseDown;

    case LB_SETCARETINDEX:
        if ( (plb->iSel == -1) || ((plb->wMultiple != SINGLESEL) &&
                    (plb->cMac > (INT)wParam))) {

            /*
             * Set's the iSelBase to the wParam
             * if lParam, then don't scroll if partially visible
             * else scroll into view if not fully visible
             */
            xxxInsureVisible(plb, (INT)wParam, (BOOL)LOWORD(lParam));
            xxxSetISelBase(plb, (INT)wParam);
            break;
        } else {
            if ((INT)wParam >= plb->cMac) {
                RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE,"Invalid index passed to LB_SETCARETINDEX");
            }
            return LB_ERR;
        }
        break;

    case LB_GETCARETINDEX:
        return plb->iSelBase;

    case LB_SETITEMHEIGHT:
    case LB_GETITEMHEIGHT:
        return LBGetSetItemHeightHandler(plb, message, (INT)wParam, LOWORD(lParam));
        break;

    case LB_FINDSTRINGEXACT:
        lReturn = xxxFindString(plb, (LPWSTR)lParam, (INT)wParam, EQ, TRUE);
        break;

    case LB_ITEMFROMPOINT: {
        POINT pt;
        BOOL bOutside;
        DWORD dwItem;

        POINTSTOPOINT(pt, lParam);
        bOutside = ISelFromPt(plb, pt, &dwItem);
        UserAssert(bOutside == 1 || bOutside == 0);
        return (LRESULT)MAKELONG(dwItem, bOutside);
    }

    case LBCB_CARETON:

        /*
         * Internal message for combo box support
         */
        CaretCreate(plb);
        // Set up the caret in the proper location for drop downs.
        plb->iSelBase = plb->iSel;
        xxxLBSetCaret(plb, TRUE);
            
        /*
         * We need to send this event even if the listbox isn't visible. See
         * bug #88548.  Also see 355612.
         */
        if (_IsWindowVisible(pwnd) || (GetFocus() == hwnd)) {
            LBEvent(plb, EVENT_OBJECT_FOCUS, plb->iSelBase);
        }

        return(plb->iSel);

    case LBCB_CARETOFF:

        /*
         * Internal message for combo box support
         */
        xxxLBSetCaret(plb, FALSE);
        xxxCaretDestroy(plb);
        break;

    case LB_GETLISTBOXINFO:
       return NtUserGetListBoxInfo(hwnd);

    case WM_NCCREATE:
        if ((pwnd->style & LBS_MULTICOLUMN) && (pwnd->style & WS_VSCROLL))
        {
            DWORD mask = WS_VSCROLL;
            DWORD flags = 0;
            if (!TestWF(pwnd, WFWIN40COMPAT)) {
                mask |= WS_HSCROLL;
                flags = WS_HSCROLL;
            }
            NtUserAlterWindowStyle(hwnd, mask, flags);
        }
        goto CallDWP;

     default:
CallDWP:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }

    /*
     * Handle translation of ANSI output data and free buffer
     */
    if (lpwsz) {
        UserLocalFree(lpwsz);
    }

    return lReturn;
}


/***************************************************************************\
\***************************************************************************/

LRESULT WINAPI ListBoxWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_LISTBOX))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, TRUE);

    return ListBoxWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI ListBoxWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_LISTBOX))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, FALSE);

    return ListBoxWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}

LRESULT WINAPI ComboListBoxWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_LISTBOX))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, TRUE);

    return ListBoxWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI ComboListBoxWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_LISTBOX))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, FALSE);

    return ListBoxWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}


/***************************************************************************\
* GetLpszItem
*
* Returns a far pointer to the string belonging to item sItem
* ONLY for Listboxes maintaining their own strings (pLBIV->fHasStrings == TRUE)
*
* History:
\***************************************************************************/

LPWSTR GetLpszItem(
    PLBIV pLBIV,
    INT sItem)
{
    LONG offsz;
    lpLBItem plbi;

    if (sItem < 0 || sItem >= pLBIV->cMac) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"sItem\" (%ld) to GetLpszItem",
                sItem);

        return NULL;
    }

    /*
     * get pointer to item index array
     * NOTE: NOT OWNERDRAW
     */
    plbi = (lpLBItem)(pLBIV->rgpch);
    offsz = plbi[sItem].offsz;
    return (LPWSTR)((PBYTE)(pLBIV->hStrings) + offsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\lboxctl1.c ===
/**************************** Module Header ********************************\
* Module Name: lboxctl1.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* List Box Handling Routines
*
* History:
* ??-???-???? ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

INT xxxLBBinarySearchString(PLBIV plb,LPWSTR lpstr);

/***************************************************************************\
*
*  SetLBScrollParms()
*
*  Sets the scroll range, page, and position
*
\***************************************************************************/

int xxxSetLBScrollParms(PLBIV plb, int nCtl)
{
    int         iPos;
    int         cItems;
    UINT        iPage;
    SCROLLINFO  si;
    BOOL        fNoScroll = FALSE;
    PSCROLLPOS  psp;
    BOOL        fCacheInitialized;
    int         iReturn;

    if (nCtl == SB_VERT) {
        iPos = plb->iTop;
        cItems = plb->cMac;
        iPage = plb->cItemFullMax;
        if (!plb->fVertBar)
            fNoScroll = TRUE;
        psp = &plb->VPos;
        fCacheInitialized = plb->fVertInitialized;
    } else {
        if (plb->fMultiColumn) {
            iPos   = plb->iTop / plb->itemsPerColumn;
            cItems = plb->cMac ? ((plb->cMac - 1) / plb->itemsPerColumn) + 1 : 0;
            iPage = plb->numberOfColumns;
            if (plb->fRightAlign && cItems)
                iPos = cItems - iPos - 1;
        } else {
            iPos = plb->xOrigin;
            cItems = plb->maxWidth;
            iPage = plb->spwnd->rcClient.right - plb->spwnd->rcClient.left;
        }

        if (!plb->fHorzBar)
            fNoScroll = TRUE;
        psp = &plb->HPos;
        fCacheInitialized = plb->fHorzInitialized;
    }

    if (cItems)
        cItems--;

    if (fNoScroll) {
        // Limit page to 0, posMax + 1
        iPage = max(min((int)iPage, cItems + 1), 0);

        // Limit pos to 0, posMax - (page - 1).
        return(max(min(iPos, cItems - ((iPage) ? (int)(iPage - 1) : 0)), 0));
    } else {
        si.fMask    = SIF_ALL;
        if (plb->fDisableNoScroll)
            si.fMask |= SIF_DISABLENOSCROLL;

        /*
         * If the scrollbar is already where we want it, do nothing.
         */
        if (fCacheInitialized) {
            if (psp->fMask == si.fMask &&
                    psp->cItems == cItems && psp->iPage == iPage &&
                    psp->iPos == iPos)
                return psp->iReturn;
        } else if (nCtl == SB_VERT) {
            plb->fVertInitialized = TRUE;
        } else {
            plb->fHorzInitialized = TRUE;
        }

        si.cbSize   = sizeof(SCROLLINFO);
        si.nMin     = 0;
        si.nMax     = cItems;
        si.nPage    = iPage;

        if (plb->fMultiColumn && plb->fRightAlign)
            si.nPos =  (iPos+1) > (int)iPage ? iPos - iPage + 1 : 0;
        else
            si.nPos = iPos;

        iReturn = SetScrollInfo(HWq(plb->spwnd), nCtl, &si, plb->fRedraw);
        if (plb->fMultiColumn && plb->fRightAlign)
            iReturn = cItems - (iReturn + iPage - 1);

        /*
         * Update the position cache
         */
        psp->fMask = si.fMask;
        psp->cItems = cItems;
        psp->iPage = iPage;
        psp->iPos = iPos;
        psp->iReturn = iReturn;

        return iReturn;
    }
}

/***************************************************************************\
* xxxLBShowHideScrollBars
*
* History:
\***************************************************************************/

void xxxLBShowHideScrollBars(
    PLBIV plb)
{
    BOOL fVertDone = FALSE;
    BOOL fHorzDone = FALSE;

    // Don't do anything if there are no scrollbars or if parents
    // are invisible.
    if ((!plb->fHorzBar && !plb->fVertBar) || !plb->fRedraw)
        return;

    //
    // Adjust iTop if necessary but DO NOT REDRAW PERIOD.  We never did
    // in 3.1.  There's a potential bug:
    //      If someone doesn't have redraw off and inserts an item in the
    // same position as the caret, we'll tell them to draw before they may
    // have called LB_SETITEMDATA for their item.  This is because we turn
    // the caret off & on inside of NewITop(), even if the item isn't
    // changing.
    //      So we just want to reflect the position/scroll changes.
    // CheckRedraw() will _really_ redraw the visual changes later if
    // redraw isn't off.
    //

    if (!plb->fFromInsert) {
        xxxNewITop(plb, plb->iTop);
        fVertDone = TRUE;
    }

    if (!plb->fMultiColumn) {
        if (!plb->fFromInsert) {
            fHorzDone = TRUE;
            xxxLBoxCtlHScroll(plb, SB_THUMBPOSITION, plb->xOrigin);
        }

        if (!fVertDone)
            xxxSetLBScrollParms(plb, SB_VERT);
    }
    if (!fHorzDone)
        xxxSetLBScrollParms(plb, SB_HORZ);
}

/***************************************************************************\
* LBGetItemData
*
* returns the long value associated with listbox items. -1 if error
*
* History:
* 16-Apr-1992 beng      The NODATA listbox case
\***************************************************************************/

LONG_PTR LBGetItemData(
    PLBIV plb,
    INT sItem)
{
    LONG_PTR buffer;
    LPBYTE lpItem;

    if (sItem < 0 || sItem >= plb->cMac) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return LB_ERR;
    }

    // No-data listboxes always return 0L
    //
    if (!plb->fHasData) {
        return 0L;
    }

    lpItem = (plb->rgpch +
            (sItem * (plb->fHasStrings ? sizeof(LBItem) : sizeof(LBODItem))));
    buffer = (plb->fHasStrings ? ((lpLBItem)lpItem)->itemData : ((lpLBODItem)lpItem)->itemData);
    return buffer;
}


/***************************************************************************\
* LBGetText
*
* Copies the text associated with index to lpbuffer and returns its length.
* If fLengthOnly, just return the length of the text without doing a copy.
*
* Waring: for size only querries lpbuffer is the count of ANSI characters
*
* Returns count of chars
*
* History:
\***************************************************************************/

INT LBGetText(
    PLBIV plb,
    BOOL fLengthOnly,
    BOOL fAnsi,
    INT index,
    LPWSTR lpbuffer)
{
    LPWSTR lpItemText;
    INT cchText;

    if (index < 0 || index >= plb->cMac) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return LB_ERR;
    }

    if (!plb->fHasStrings && plb->OwnerDraw) {

        /*
         * Owner draw without strings so we must copy the app supplied DWORD
         * value.
         */
        cchText = sizeof(ULONG_PTR);

        if (!fLengthOnly) {
            LONG_PTR UNALIGNED *p = (LONG_PTR UNALIGNED *)lpbuffer;
            *p = LBGetItemData(plb, index);
        }
    } else {
        lpItemText = GetLpszItem(plb, index);
        if (!lpItemText)
            return LB_ERR;

        /*
         * These are strings so we are copying the text and we must include
         * the terminating 0 when doing the RtlMoveMemory.
         */
        cchText = wcslen(lpItemText);

        if (fLengthOnly) {
            if (fAnsi)
                RtlUnicodeToMultiByteSize(&cchText, lpItemText, cchText*sizeof(WCHAR));
        } else {
            if (fAnsi) {
#ifdef FE_SB // LBGetText()
                cchText = WCSToMB(lpItemText, cchText+1, &((LPSTR)lpbuffer), (cchText+1)*sizeof(WORD), FALSE);
                /*
                 * Here.. cchText contains null-terminate char, subtract it... Because, we pass cchText+1 to
                 * above Unicode->Ansi convertsion to make sure the string is terminated with null.
                 */
                cchText--;
#else
                WCSToMB(lpItemText, cchText+1, &((LPSTR)lpbuffer), cchText+1, FALSE);
#endif // FE_SB
            } else {
                RtlCopyMemory(lpbuffer, lpItemText, (cchText+1)*sizeof(WCHAR));
            }
        }

    }

    return cchText;
}

/***************************************************************************\
* GrowMem
*
* History:
* 16-Apr-1992 beng      NODATA listboxes
* 23-Jul-1996 jparsons  Added numItems parameter for LB_INITSTORAGE support
\***************************************************************************/

BOOL GrowMem(
    PLBIV plb,
    INT   numItems)

{
    LONG cb;
    HANDLE hMem;

    /*
     * Allocate memory for pointers to the strings.
     */
    cb = (plb->cMax + numItems) *
            (plb->fHasStrings ? sizeof(LBItem)
                              : (plb->fHasData ? sizeof(LBODItem)
                                              : 0));

    /*
     * If multiple selection list box (MULTIPLESEL or EXTENDEDSEL), then
     * allocate an extra byte per item to keep track of it's selection state.
     */
    if (plb->wMultiple != SINGLESEL) {
        cb += (plb->cMax + numItems);
    }

    /*
     * Extra bytes for each item so that we can store its height.
     */
    if (plb->OwnerDraw == OWNERDRAWVAR) {
        cb += (plb->cMax + numItems);
    }

    /*
     * Don't allocate more than 2G of memory
     */
    if (cb > MAXLONG)
        return FALSE;

    if (plb->rgpch == NULL) {
        if ((plb->rgpch = UserLocalAlloc(HEAP_ZERO_MEMORY, (LONG)cb)) == NULL)
            return FALSE;
    } else {
        if ((hMem = UserLocalReAlloc(plb->rgpch, (LONG)cb, HEAP_ZERO_MEMORY)) == NULL)
            return FALSE;
        plb->rgpch = hMem;
    }

    plb->cMax += numItems;

    return TRUE;
}

/***************************************************************************\
* xxxLBInitStorage
*
* History:
* 23-Jul-1996 jparsons  Added support for pre-allocation
\***************************************************************************/
LONG xxxLBInitStorage(PLBIV plb, BOOL fAnsi, INT cItems, INT cb)
{
    HANDLE hMem;
    INT    cbChunk;

    /*
     * if the app is talking ANSI, then adjust for the worst case in unicode
     * where each single ansi byte translates to one 16 bit unicode value
     */
    if (fAnsi) {
        cb *= sizeof(WCHAR) ;
    } /* if */

    /*
     * Fail if either of the parameters look bad.
     */
    if ((cItems < 0) || (cb < 0)) {
        xxxNotifyOwner(plb, LBN_ERRSPACE);
        return LB_ERRSPACE;
    } /* if */

    /*
     * try to grow the pointer array (if necessary) accounting for the free space
     * already available.
     */
    cItems -= plb->cMax - plb->cMac ;
    if ((cItems > 0) && !GrowMem(plb, cItems)) {
        xxxNotifyOwner(plb, LBN_ERRSPACE);
        return LB_ERRSPACE;
    } /* if */

    /*
     * now grow the string space if necessary
     */
    if (plb->fHasStrings) {
        if ((cbChunk = (plb->ichAlloc + cb)) > plb->cchStrings) {

            /*
             * Round up to the nearest 256 byte chunk.
             */
            cbChunk = (cbChunk & ~0xff) + 0x100;
            if (!(hMem = UserLocalReAlloc(plb->hStrings, (LONG)cbChunk, 0))) {
                xxxNotifyOwner(plb, LBN_ERRSPACE);
                return LB_ERRSPACE;
            }
            plb->hStrings = hMem;
            plb->cchStrings = cbChunk;
        } /* if */
    } /* if */

    /*
     * return the number of items that can be stored
     */
    return plb->cMax ;
}

/***************************************************************************\
* xxxInsertString
*
* Insert an item at a specified position.
*
* History:
* 16-Apr-1992 beng      NODATA listboxes
\***************************************************************************/

INT xxxLBInsertItem(
    PLBIV plb,

    /*
     * For owner draw listboxes without LBS_HASSTRINGS style, this is not a
     * string but rather a 4 byte value we will store for the app.
     */
    LPWSTR lpsz,
    INT index,
    UINT wFlags)
{
    MEASUREITEMSTRUCT measureItemStruct;
    INT cbString = 0;
    INT cbChunk;
    PBYTE lp;
    PBYTE lpT;
    PBYTE lpHeightStart;
    LONG cbItem;     /* sizeof the Item in rgpch */
    HANDLE hMem;
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    if (wFlags & LBI_ADD)
        index = (plb->fSort) ? xxxLBBinarySearchString(plb, lpsz) : -1;

    if (!plb->rgpch) {
        if (index != 0 && index != -1) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return LB_ERR;
        }

        plb->iSel = -1;
        plb->iSelBase = 0;
        plb->cMax = 0;
        plb->cMac = 0;
        plb->iTop = 0;
        plb->rgpch = UserLocalAlloc(HEAP_ZERO_MEMORY, 0L);
        if (!plb->rgpch)
            return LB_ERR;
    }

    if (index == -1) {
        index = plb->cMac;
    }

    if (index > plb->cMac || plb->cMac >= MAXLONG) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return LB_ERR;
    }

    if (plb->fHasStrings) {

        /*
         * we must store the string in the hStrings memory block.
         */
        cbString = (wcslen(lpsz) + 1)*sizeof(WCHAR);  /* include 0 terminator */

        if ((cbChunk = (plb->ichAlloc + cbString)) > plb->cchStrings) {

            /*
             * Round up to the nearest 256 byte chunk.
             */
            cbChunk = (cbChunk & ~0xff) + 0x100;
            if (!(hMem = UserLocalReAlloc(plb->hStrings, (LONG)cbChunk,
                    0))) {
                xxxNotifyOwner(plb, LBN_ERRSPACE);
                return LB_ERRSPACE;
            }
            plb->hStrings = hMem;

            plb->cchStrings = cbChunk;
        }

        /*
         * Note difference between Win 95 code with placement of new string
         */
        if (wFlags & UPPERCASE)
            CharUpperBuffW((LPWSTR)lpsz, cbString / sizeof(WCHAR));
        else if (wFlags & LOWERCASE)
            CharLowerBuffW((LPWSTR)lpsz, cbString / sizeof(WCHAR));

        lp = (PBYTE)(plb->hStrings);
        RtlMoveMemory(lp + plb->ichAlloc, lpsz, cbString);
    }

    /*
     * Now expand the pointer array.
     */
    if (plb->cMac >= plb->cMax) {
        if (!GrowMem(plb, CITEMSALLOC)) {
            xxxNotifyOwner(plb, LBN_ERRSPACE);
            return LB_ERRSPACE;
        }
    }

    lpHeightStart = lpT = lp = plb->rgpch;

    /*
     * Now calculate how much room we must make for the string pointer (lpsz).
     * If we are ownerdraw without LBS_HASSTRINGS, then a single DWORD
     * (LBODItem.itemData) stored for each item, but if we have strings with
     * each item then a LONG string offset (LBItem.offsz) is also stored.
     */
    cbItem = (plb->fHasStrings ? sizeof(LBItem)
                               : (plb->fHasData ? sizeof(LBODItem):0));
    cbChunk = (plb->cMac - index) * cbItem;

    if (plb->wMultiple != SINGLESEL) {

        /*
         * Extra bytes were allocated for selection flag for each item
         */
        cbChunk += plb->cMac;
    }

    if (plb->OwnerDraw == OWNERDRAWVAR) {

        /*
         * Extra bytes were allocated for each item's height
         */
        cbChunk += plb->cMac;
    }

    /*
     * First, make room for the 2 byte pointer to the string or the 4 byte app
     * supplied value.
     */
    lpT += (index * cbItem);
    RtlMoveMemory(lpT + cbItem, lpT, cbChunk);
    if (!plb->fHasStrings && plb->OwnerDraw) {
        if (plb->fHasData) {
            /*
             * Ownerdraw so just save the DWORD value
             */
            lpLBODItem p = (lpLBODItem)lpT;
            p->itemData = (ULONG_PTR)lpsz;
        }
    } else {
        lpLBItem p = ((lpLBItem)lpT);

        /*
         * Save the start of the string.  Let the item data field be 0
         */
        p->offsz = (LONG)(plb->ichAlloc);
        p->itemData = 0;
        plb->ichAlloc += cbString;
    }

    /*
     * Now if Multiple Selection lbox, we have to insert a selection status
     * byte.  If var height ownerdraw, then we also have to move up the height
     * bytes.
     */
    if (plb->wMultiple != SINGLESEL) {
        lpT = lp + ((plb->cMac + 1) * cbItem) + index;
        RtlMoveMemory(lpT + 1, lpT, plb->cMac - index +
                (plb->OwnerDraw == OWNERDRAWVAR ? plb->cMac : 0));
        *lpT = 0;  /* fSelected = FALSE */
    }

    /*
     * Increment count of items in the listbox now before we send a message to
     * the app.
     */
    plb->cMac++;

    /*
     * If varheight ownerdraw, we much insert an extra byte for the item's
     * height.
     */
    if (plb->OwnerDraw == OWNERDRAWVAR) {

        /*
         * Variable height owner draw so we need to get the height of each item.
         */
        lpHeightStart += (plb->cMac * cbItem) + index +
                (plb->wMultiple ? plb->cMac : 0);

        RtlMoveMemory(lpHeightStart + 1, lpHeightStart, plb->cMac - 1 - index);

        /*
         * Query for item height only if we are var height owner draw.
         */
        measureItemStruct.CtlType = ODT_LISTBOX;
        measureItemStruct.CtlID = PtrToUlong(plb->spwnd->spmenu);
        measureItemStruct.itemID = index;

        /*
         * System font height is default height
         */
        measureItemStruct.itemHeight = (UINT)gpsi->cySysFontChar;
        measureItemStruct.itemData = (ULONG_PTR)lpsz;

        /*
         * If "has strings" then add the special thunk bit so the client data
         * will be thunked to a client side address.  LB_DIR sends a string
         * even if the listbox is not HASSTRINGS so we need to special
         * thunk this case.  HP Dashboard for windows send LB_DIR to a non
         * HASSTRINGS listbox needs the server string converted to client.
         * WOW needs to know about this situation as well so we mark the
         * previously uninitialized itemWidth as FLAT.
         */
        if (plb->fHasStrings || (wFlags & MSGFLAG_SPECIAL_THUNK)) {
            measureItemStruct.itemWidth = MIFLAG_FLAT;
        }

        ThreadLock(plb->spwndParent, &tlpwndParent);
        SendMessage(HW(plb->spwndParent),
                WM_MEASUREITEM,
                measureItemStruct.CtlID,
                (LPARAM)&measureItemStruct);
        ThreadUnlock(&tlpwndParent);
        *lpHeightStart = (BYTE)measureItemStruct.itemHeight;
    }


    /*
     * If the item was inserted above the current selection then move
     * the selection down one as well.
     */
    if ((plb->wMultiple == SINGLESEL) && (plb->iSel >= index))
        plb->iSel++;

    if (plb->OwnerDraw == OWNERDRAWVAR)
        LBSetCItemFullMax(plb);

    /*
     * Check if scroll bars need to be shown/hidden
     */
    plb->fFromInsert = TRUE;
    xxxLBShowHideScrollBars(plb);
    if (plb->fHorzBar && plb->fRightAlign && !(plb->fMultiColumn || plb->OwnerDraw)) {
        /*
         * origin to right
         */
        xxxLBoxCtlHScroll(plb, SB_BOTTOM, 0);
    }
    plb->fFromInsert = FALSE;

    xxxCheckRedraw(plb, TRUE, index);

    LBEvent(plb, EVENT_OBJECT_CREATE, index);

    return index;
}


/***************************************************************************\
* LBlstrcmpi
*
* This is a version of lstrcmpi() specifically used for listboxes
* This gives more weight to '[' characters than alpha-numerics;
* The US version of lstrcmpi() and lstrcmp() are similar as far as
* non-alphanumerals are concerned; All non-alphanumerals get sorted
* before alphanumerals; This means that subdirectory strings that start
* with '[' will get sorted before; But we don't want that; So, this
* function takes care of it;
*
* History:
\***************************************************************************/

INT LBlstrcmpi(
    LPWSTR lpStr1,
    LPWSTR lpStr2,
    DWORD dwLocaleId)
{

    /*
     * NOTE: This function is written so as to reduce the number of calls
     * made to the costly IsCharAlphaNumeric() function because that might
     * load a language module; It 'traps' the most frequently occurring cases
     * like both strings starting with '[' or both strings NOT starting with '['
     * first and only in abosolutely necessary cases calls IsCharAlphaNumeric();
     */
    if (*lpStr1 == TEXT('[')) {
        if (*lpStr2 == TEXT('[')) {
            goto LBL_End;
        }
        if (IsCharAlphaNumeric(*lpStr2)) {
            return 1;
        }
    }

    if ((*lpStr2 == TEXT('[')) && IsCharAlphaNumeric(*lpStr1)) {
        return -1;
    }

LBL_End:
    if ((GetClientInfo()->dwTIFlags & TIF_16BIT) &&
        dwLocaleId == MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)) {
        /*
         * This is how Windows95 does, bug #4199
         */
        return (*pfnWowIlstrcmp)(lpStr1, lpStr2);
    }
    return (INT)CompareStringW((LCID)dwLocaleId, NORM_IGNORECASE,
            lpStr1, -1, lpStr2, -1 ) - 2;
}


/***************************************************************************\
* xxxLBBinarySearchString
*
* Does a binary search of the items in the SORTED listbox to find
* out where this item should be inserted.  Handles both HasStrings and item
* long WM_COMPAREITEM cases.
*
* History:
*    27 April 1992  GregoryW
*          Modified to support sorting based on current list box locale.
\***************************************************************************/

INT xxxLBBinarySearchString(
    PLBIV plb,
    LPWSTR lpstr)
{
    BYTE *FAR *lprgpch;
    INT sortResult;
    COMPAREITEMSTRUCT cis;
    LPWSTR pszLBBase;
    LPWSTR pszLB;
    INT itemhigh;
    INT itemnew = 0;
    INT itemlow = 0;
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    if (!plb->cMac)
        return 0;

    lprgpch = (BYTE *FAR *)(plb->rgpch);
    if (plb->fHasStrings) {
        pszLBBase = plb->hStrings;
    }

    itemhigh = plb->cMac - 1;
    while (itemlow <= itemhigh) {
        itemnew = (itemhigh + itemlow) / 2;

        if (plb->fHasStrings) {

            /*
             * Searching for string matches.
             */
            pszLB = (LPWSTR)((LPSTR)pszLBBase + ((lpLBItem)lprgpch)[itemnew].offsz);
            sortResult = LBlstrcmpi(pszLB, lpstr, plb->dwLocaleId);
        } else {

            /*
             * Send compare item messages to the parent for sorting
             */
            cis.CtlType = ODT_LISTBOX;
            cis.CtlID = PtrToUlong(plb->spwnd->spmenu);
            cis.hwndItem = HWq(plb->spwnd);
            cis.itemID1 = itemnew;
            cis.itemData1 = ((lpLBODItem)lprgpch)[itemnew].itemData;
            cis.itemID2 = (UINT)-1;
            cis.itemData2 = (ULONG_PTR)lpstr;
            cis.dwLocaleId = plb->dwLocaleId;
            ThreadLock(plb->spwndParent, &tlpwndParent);
            sortResult = (INT)SendMessage(HW(plb->spwndParent), WM_COMPAREITEM,
                    cis.CtlID, (LPARAM)&cis);
            ThreadUnlock(&tlpwndParent);
        }

        if (sortResult < 0) {
            itemlow = itemnew + 1;
        } else if (sortResult > 0) {
            itemhigh = itemnew - 1;
        } else {
            itemlow = itemnew;
            goto FoundIt;
        }
    }

FoundIt:

    return max(0, itemlow);
}

/***************************************************************************\
* xxxLBResetContent
*
* History:
\***************************************************************************/

BOOL xxxLBResetContent(
    PLBIV plb)
{
    if (!plb->cMac)
        return TRUE;

    xxxLBoxDoDeleteItems(plb);

    if (plb->rgpch != NULL) {
        UserLocalFree(plb->rgpch);
        plb->rgpch = NULL;
    }

    if (plb->hStrings != NULL) {
        UserLocalFree(plb->hStrings);
        plb->hStrings = NULL;
    }

    InitHStrings(plb);

    if (TestWF(plb->spwnd, WFWIN31COMPAT))
        xxxCheckRedraw(plb, FALSE, 0);
    else if (IsVisible(plb->spwnd))
        NtUserInvalidateRect(HWq(plb->spwnd), NULL, TRUE);

    plb->iSelBase =  0;
    plb->iTop =  0;
    plb->cMac =  0;
    plb->cMax =  0;
    plb->xOrigin =  0;
    plb->iLastSelection =  0;
    plb->iSel = -1;

    xxxLBShowHideScrollBars(plb);
    return TRUE;
}


/***************************************************************************\
* xxxLBoxCtlDelete
*
* History:
* 16-Apr-1992 beng      NODATA listboxes
\***************************************************************************/

INT xxxLBoxCtlDelete(
    PLBIV plb,
    INT sItem)  /* Item number to delete */
{
    LONG cb;
    LPBYTE lp;
    LPBYTE lpT;
    RECT rc;
    int cbItem;    /* size of Item in rgpch */
    LPWSTR lpString;
    PBYTE pbStrings;
    INT cbStringLen;
    LPBYTE itemNumbers;
    INT sTmp;
    TL tlpwnd;

    CheckLock(plb->spwnd);

    if (sItem < 0 || sItem >= plb->cMac) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return LB_ERR;
    }

    LBEvent(plb, EVENT_OBJECT_DESTROY, sItem);

    if (plb->cMac == 1) {

        /*
         * When the item count is 0, we send a resetcontent message so that we
         * can reclaim our string space this way.
         */
        SendMessageWorker(plb->spwnd, LB_RESETCONTENT, 0, 0, FALSE);
        goto FinishUpDelete;
    }

    /*
     * Get the rectangle associated with the last item in the listbox.  If it is
     * visible, we need to invalidate it.  When we delete an item, everything
     * scrolls up to replace the item deleted so we must make sure we erase the
     * old image of the last item in the listbox.
     */
    if (LBGetItemRect(plb, (INT)(plb->cMac - 1), &rc)) {
        xxxLBInvalidateRect(plb, &rc, TRUE);
    }

    // 3.1 and earlier used to only send WM_DELETEITEMs if it was an ownerdraw
    // listbox.  4.0 and above will send WM_DELETEITEMs for every item that has
    // nonzero item data.
    if (TestWF(plb->spwnd, WFWIN40COMPAT) || (plb->OwnerDraw && plb->fHasData)) {
        xxxLBoxDeleteItem(plb, sItem);
    }

    plb->cMac--;

    cbItem = (plb->fHasStrings ? sizeof(LBItem)
                               : (plb->fHasData ? sizeof(LBODItem): 0));
    cb = ((plb->cMac - sItem) * cbItem);

    /*
     * Byte for the selection status of the item.
     */
    if (plb->wMultiple != SINGLESEL) {
        cb += (plb->cMac + 1);
    }

    if (plb->OwnerDraw == OWNERDRAWVAR) {

        /*
         * One byte for the height of the item.
         */
        cb += (plb->cMac + 1);
    }

    /*
     * Might be nodata and singlesel, for instance.
     * but what out for the case where cItem == cMac (and cb == 0).
     */
    if ((cb != 0) || plb->fHasStrings) {
        lp = plb->rgpch;

        lpT = (lp + (sItem * cbItem));

        if (plb->fHasStrings) {
            /*
             * If we has strings with each item, then we want to compact the string
             * heap so that we can recover the space occupied by the string of the
             * deleted item.
             */
            /*
             * Get the string which we will be deleting
             */
            pbStrings = (PBYTE)(plb->hStrings);
            lpString = (LPTSTR)(pbStrings + ((lpLBItem)lpT)->offsz);
            cbStringLen = (wcslen(lpString) + 1) * sizeof(WCHAR);  /* include null terminator */

            /*
             * Now compact the string array
             */
            plb->ichAlloc = plb->ichAlloc - cbStringLen;

            RtlMoveMemory(lpString, (PBYTE)lpString + cbStringLen,
                    plb->ichAlloc + (pbStrings - (LPBYTE)lpString));

            /*
             * We have to update the string pointers in plb->rgpch since all the
             * string after the deleted string have been moved down stringLength
             * bytes.  Note that we have to explicitly check all items in the list
             * box if the string was allocated after the deleted item since the
             * LB_SORT style allows a lower item number to have a string allocated
             * at the end of the string heap for example.
             */
            itemNumbers = lp;
            for (sTmp = 0; sTmp <= plb->cMac; sTmp++) {
                lpLBItem p =(lpLBItem)itemNumbers;
                if ( (LPTSTR)(p->offsz + pbStrings) > lpString ) {
                    p->offsz -= cbStringLen;
                }
                p++;
                itemNumbers=(LPBYTE)p;
            }
        }

        /*
         * Now compact the pointers to the strings (or the long app supplied values
         * if ownerdraw without strings).
         */
        RtlMoveMemory(lpT, lpT + cbItem, cb);

        /*
         * Compress the multiselection bytes
         */
        if (plb->wMultiple != SINGLESEL) {
            lpT = (lp + (plb->cMac * cbItem) + sItem);
            RtlMoveMemory(lpT, lpT + 1, plb->cMac - sItem +
                    (plb->OwnerDraw == OWNERDRAWVAR ? plb->cMac + 1 : 0));
        }

        if (plb->OwnerDraw == OWNERDRAWVAR) {
            /*
             * Compress the height bytes
             */
            lpT = (lp + (plb->cMac * cbItem) + (plb->wMultiple ? plb->cMac : 0)
                    + sItem);
            RtlMoveMemory(lpT, lpT + 1, plb->cMac - sItem);
        }

    }

    if (plb->wMultiple == SINGLESEL) {
        if (plb->iSel == sItem) {
            plb->iSel = -1;

            if (plb->pcbox != NULL) {
                ThreadLock(plb->pcbox->spwnd, &tlpwnd);
                xxxCBInternalUpdateEditWindow(plb->pcbox, NULL);
                ThreadUnlock(&tlpwnd);
            }
        } else if (plb->iSel > sItem)
            plb->iSel--;
    }

    if ((plb->iMouseDown != -1) && (sItem <= plb->iMouseDown))
        plb->iMouseDown = -1;

    if (plb->iSelBase && sItem == plb->iSelBase)
        plb->iSelBase--;

    if (plb->cMac) {
        plb->iSelBase = min(plb->iSelBase, plb->cMac - 1);
    } else {
        plb->iSelBase = 0;
    }

    if ((plb->wMultiple == EXTENDEDSEL) && (plb->iSel == -1))
        plb->iSel = plb->iSelBase;

    if (plb->OwnerDraw == OWNERDRAWVAR)
        LBSetCItemFullMax(plb);

    /*
     * We always set a new iTop.  The iTop won't change if it doesn't need to
     * but it will change if:  1.  The iTop was deleted or 2.  We need to change
     * the iTop so that we fill the listbox.
     */
    xxxInsureVisible(plb, plb->iTop, FALSE);

FinishUpDelete:

    /*
     * Check if scroll bars need to be shown/hidden
     */
    plb->fFromInsert = TRUE;
    xxxLBShowHideScrollBars(plb);
    plb->fFromInsert = FALSE;

    xxxCheckRedraw(plb, TRUE, sItem);
    xxxInsureVisible(plb, plb->iSelBase, FALSE);

    return plb->cMac;
}

/***************************************************************************\
* xxxLBoxDeleteItem
*
* Sends a WM_DELETEITEM message to the owner of an ownerdraw listbox
*
* History:
\***************************************************************************/

void xxxLBoxDeleteItem(
    PLBIV plb,
    INT sItem)
{
    DELETEITEMSTRUCT dis;
    TL tlpwndParent;

    CheckLock(plb->spwnd);
    if (plb->spwnd == NULL)
        return;

    /*
     * Bug 262122 - joejo
     * No need to send message if no data!
     */
    if (!plb->fHasData) {
        return;
    }

    /*
     * Fill the DELETEITEMSTRUCT
     */
    dis.CtlType = ODT_LISTBOX;
    dis.CtlID = PtrToUlong(plb->spwnd->spmenu);
    dis.itemID = sItem;
    dis.hwndItem = HWq(plb->spwnd);

    /*
     * Bug 262122 - joejo
     * Fixed in 93 so that ItemData was passed. For some reason, not
     * merged in.
     */
    dis.itemData = LBGetItemData(plb, sItem);

    if (plb->spwndParent != NULL) {
        ThreadLock(plb->spwndParent, &tlpwndParent);
        SendMessage(HWq(plb->spwndParent), WM_DELETEITEM, dis.CtlID,
                (LPARAM)&dis);
        ThreadUnlock(&tlpwndParent);
    }
}

/**************************************************************************\
* xxxLBSetCount
*
* Sets the number of items in a lazy-eval (fNoData) listbox.
*
* Calling SetCount scorches any existing selection state.  To preserve
* selection state, call Insert/DeleteItem instead.
*
* History
* 16-Apr-1992 beng      Created
\**************************************************************************/

INT xxxLBSetCount(
    PLBIV plb,
    INT cItems)
{
    UINT  cbRequired;
    BOOL    fRedraw;

    CheckLock(plb->spwnd);

    /*
     * SetCount is only valid on lazy-eval ("nodata") listboxes.
     * All other lboxen must add their items one at a time, although
     * they may SetCount(0) via RESETCONTENT.
     */
    if (plb->fHasStrings || plb->fHasData) {
        RIPERR0(ERROR_SETCOUNT_ON_BAD_LB, RIP_VERBOSE, "");
        return LB_ERR;
    }

    if (cItems == 0) {
        SendMessageWorker(plb->spwnd, LB_RESETCONTENT, 0, 0, FALSE);
        return 0;
    }

    // If redraw isn't turned off, turn it off now
    if (fRedraw = plb->fRedraw)
        xxxLBSetRedraw(plb, FALSE);

    cbRequired = LBCalcAllocNeeded(plb, cItems);

    /*
     * Reset selection and position
     */
    plb->iSelBase = 0;
    plb->iTop = 0;
    plb->cMax = 0;
    plb->xOrigin = 0;
    plb->iLastSelection = 0;
    plb->iSel = -1;

    if (cbRequired != 0) { // Only if record instance data required

        /*
         * If listbox was previously empty, prepare for the
         * realloc-based alloc strategy ahead.
         */
        if (plb->rgpch == NULL) {
            plb->rgpch = UserLocalAlloc(HEAP_ZERO_MEMORY, 0L);
            plb->cMax = 0;

            if (plb->rgpch == NULL) {
                xxxNotifyOwner(plb, LBN_ERRSPACE);
                return LB_ERRSPACE;
            }
        }

        /*
         * rgpch might not have enough room for the new record instance
         * data, so check and realloc as necessary.
         */
        if (cItems >= plb->cMax) {
            INT    cMaxNew;
            UINT   cbNew;
            HANDLE hmemNew;

            /*
             * Since GrowMem presumes a one-item-at-a-time add schema,
             * SetCount can't use it.  Too bad.
             */
            cMaxNew = cItems+CITEMSALLOC;
            cbNew = LBCalcAllocNeeded(plb, cMaxNew);
            hmemNew = UserLocalReAlloc(plb->rgpch, cbNew, HEAP_ZERO_MEMORY);

            if (hmemNew == NULL) {
                xxxNotifyOwner(plb, LBN_ERRSPACE);
                return LB_ERRSPACE;
            }

            plb->rgpch = hmemNew;
            plb->cMax = cMaxNew;
        }

        /*
         * Reset the item instance data (multisel annotations)
         */
        RtlZeroMemory(plb->rgpch, cbRequired);
    }

    plb->cMac = cItems;

    // Turn redraw back on
    if (fRedraw)
        xxxLBSetRedraw(plb, TRUE);

    xxxLBInvalidateRect(plb, NULL, TRUE);
// Not In Chicago -- FritzS
//    NtUserSetScrollPos(plb->spwnd, SB_HORZ, 0, plb->fRedraw);
//    NtUserSetScrollPos(plb->spwnd, SB_VERT, 0, plb->fRedraw);
    xxxLBShowHideScrollBars(plb); // takes care of fRedraw

    return 0;
}

/**************************************************************************\
* LBCalcAllocNeeded
*
* Calculate the number of bytes needed in rgpch to accommodate a given
* number of items.
*
* History
* 16-Apr-1992 beng      Created
\**************************************************************************/

UINT LBCalcAllocNeeded(
    PLBIV plb,
    INT cItems)
{
    UINT cb;

    /*
     * Allocate memory for pointers to the strings.
     */
    cb = cItems * (plb->fHasStrings ? sizeof(LBItem)
                                    : (plb->fHasData ? sizeof(LBODItem)
                                                    : 0));

    /*
     * If multiple selection list box (MULTIPLESEL or EXTENDEDSEL), then
     * allocate an extra byte per item to keep track of it's selection state.
     */
    if (plb->wMultiple != SINGLESEL) {
        cb += cItems;
    }

    /*
     * Extra bytes for each item so that we can store its height.
     */
    if (plb->OwnerDraw == OWNERDRAWVAR) {
        cb += cItems;
    }

    return cb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\lboxmult.c ===
/**************************** Module Header ********************************\
* Module Name: lboxmult.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Multi column list box routines
*
* History:
* ??-???-???? ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* LBCalcItemRowsAndColumns
*
* Calculates the number of columns (including partially visible)
* in the listbox and calculates the number of items per column
*
* History:
\***************************************************************************/

void LBCalcItemRowsAndColumns(
    PLBIV plb)
{
    RECT rc;

    _GetClientRect(plb->spwnd, &rc);

    //
    // B#4155
    // We need to check if plb->cyChar has been initialized.  This is because
    // we remove WS_BORDER from old listboxes and add on WS_EX_CLIENTEDGE.
    // Since listboxes are always inflated by CXBORDER and CYBORDER, a
    // listbox that was created empty always ends up 2 x 2.  Since this isn't
    // big enough to fit the entire client border, we don't mark it as
    // present.  Thus the client isn't empty in VER40, although it was in
    // VER31 and before.  It is possible to get to this spot without
    // plb->cyChar having been initialized yet if the listbox  is
    // multicolumn && ownerdraw variable.
    //

    if (rc.bottom && rc.right && plb->cyChar) {

        /*
         * Only make these calculations if the width & height are positive
         */
        plb->itemsPerColumn = (INT)max(rc.bottom / plb->cyChar, 1);
        plb->numberOfColumns = (INT)max(rc.right / plb->cxColumn, 1);

        plb->cItemFullMax = plb->itemsPerColumn * plb->numberOfColumns;

        /*
         * Adjust iTop so it's at the top of a column
         */
        xxxNewITop(plb, plb->iTop);
    }
}


/***************************************************************************\
* xxxLBoxCtlHScrollMultiColumn
*
* Supports horizontal scrolling of multicolumn listboxes
*
* History:
\***************************************************************************/

void xxxLBoxCtlHScrollMultiColumn(
    PLBIV plb,
    INT cmd,
    INT xAmt)
{
    INT iTop = plb->iTop;

    CheckLock(plb->spwnd);

    if (!plb->cMac)  return;

    switch (cmd) {
    case SB_LINEUP:
        if (plb->fRightAlign)
            goto ReallyLineDown;
ReallyLineUp:
        iTop -= plb->itemsPerColumn;
        break;
    case SB_LINEDOWN:
        if (plb->fRightAlign)
            goto ReallyLineUp;
ReallyLineDown:
        iTop += plb->itemsPerColumn;
        break;
    case SB_PAGEUP:
        if (plb->fRightAlign)
            goto ReallyPageDown;
ReallyPageUp:
        iTop -= plb->itemsPerColumn * plb->numberOfColumns;
        break;
    case SB_PAGEDOWN:
        if (plb->fRightAlign)
            goto ReallyPageUp;
ReallyPageDown:
        iTop += plb->itemsPerColumn * plb->numberOfColumns;
        break;
    case SB_THUMBTRACK:
    case SB_THUMBPOSITION:
        if (plb->fRightAlign) {
            int  iCols = plb->cMac ? ((plb->cMac-1) / plb->itemsPerColumn) + 1 : 0;

            xAmt = iCols - (xAmt + plb->numberOfColumns);
            if (xAmt<0)
                xAmt=0;
        }
        iTop = xAmt * plb->itemsPerColumn;
        break;
    case SB_TOP:
        if (plb->fRightAlign)
            goto ReallyBottom;
ReallyTop:
        iTop = 0;
        break;
    case SB_BOTTOM:
        if (plb->fRightAlign)
            goto ReallyTop;
ReallyBottom:
        iTop = plb->cMac - 1 - ((plb->cMac - 1) % plb->itemsPerColumn);
        break;
    case SB_ENDSCROLL:
        plb->fSmoothScroll = TRUE;
        xxxLBShowHideScrollBars(plb);
        break;
    }

    xxxNewITop(plb, iTop);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\lboxctl3.c ===
/****************************************************************************\
*
*  LBOXCTL3.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      Directory List Box Routines
*
* ??-???-???? ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code
\****************************************************************************/

#define CTLMGR
#define LSTRING

#include "precomp.h"
#pragma hdrstop

#define DATESEPARATOR TEXT('-')
#define TIMESEPARATOR  TEXT(':')
#define TABCHAR        TEXT('\t')

#define MAXDIGITSINSIZE 9

void LB_CreateLBLine(LPWIN32_FIND_DATA, LPWSTR);

#define DDL_PRIVILEGES  (DDL_READONLY | DDL_HIDDEN | DDL_SYSTEM | DDL_ARCHIVE)
#define DDL_TYPE        (DDL_DRIVES | DDL_DIRECTORY | DDL_POSTMSGS)

/***************************************************************************\
* ChopText
*
* Chops the given path at 'lpchBuffer' + CCH_CHOPTEXT_EXTRA to fit in the
* field of the static control with id 'idStatic' in the dialog box 'hwndDlg'.
* If the path is too long, an ellipsis prefix is added to the beginning of the
* chopped text ("x:\...\")
*
* If the supplied path does not fit and the last directory appended to
* ellipsis (i.e. "c:\...\eee" in the case of "c:\aaa\bbb\ccc\ddd\eee")
* does not fit, then "x:\..." is returned.
*
* Pathological case:
* "c:\SW\MW\R2\LIB\SERVICES\NT" almost fits into static control, while
* "c:\...\MW\R2\LIB\SERVICES\NT" does fit - although it is more characters.
* In this case, ChopText substitutes the first 'n' characters of the path with
* a prefix containing MORE than 'n' characters!  The extra characters will
* be put in front of lpch, so there must be space reserved for them or they
* will trash the stack.  lpch contains CCH_CHOPTEXT_EXTRA chars followed by
* the path.
*
* History:
\***************************************************************************/

/*
 * In practice CCH_CHOPTEXT_EXTRA probably never has to be more than 1 or 2,
 * but in case the font is weird, set it to the number of chars in the prefix.
 * This guarantees enough space to prepend the prefix.
 */
#define CCH_CHOPTEXT_EXTRA 7

LPWSTR ChopText(
    PWND pwndDlg,
    int idStatic,
    LPWSTR lpchBuffer)
{
#define AWCHLEN(a) ((sizeof(a)/sizeof(a[0])) - 1)

    /*
     * Declaring szPrefix this way ensures CCH_CHOPTEXT_EXTRA is big enough
     */
    WCHAR szPrefix[CCH_CHOPTEXT_EXTRA + 1] = L"x:\\...\\";
    int cxField;
    RECT rc;
    SIZE size;
    PWND pwndStatic;
    PSTAT pstat;
    HDC hdc;
    HFONT hOldFont;
    int cchPath;
    PWCHAR lpch;
    PWCHAR lpchPath;

    /*
     * Get length of static field.
     */
    pwndStatic = _GetDlgItem(pwndDlg, idStatic);
    if (pwndStatic == NULL)
        return NULL;

    _GetClientRect(pwndStatic, &rc);
    cxField = rc.right - rc.left;

    /*
     * Set up DC appropriately for the static control.
     */
    hdc = NtUserGetDC(HWq(pwndStatic));

    /*
     * Only assume this is a static window if this window uses the static
     * window wndproc.
     */
    hOldFont = NULL;
    if (GETFNID(pwndStatic) == FNID_STATIC) {
        pstat = ((PSTATWND)pwndStatic)->pstat;
        if (pstat != NULL && pstat != (PSTAT)-1 && pstat->hFont)
            hOldFont = SelectObject(hdc, pstat->hFont);
    }

    /*
     * Check horizontal extent of string.
     */
    lpch = lpchPath = lpchBuffer + CCH_CHOPTEXT_EXTRA;
    cchPath = wcslen(lpchPath);
    GetTextExtentPoint(hdc, lpchPath, cchPath, &size);
    if (size.cx > cxField) {

        /*
         * String is too long to fit in the static control; chop it.
         * Set up new prefix and determine remaining space in control.
         */
        szPrefix[0] = *lpchPath;
        GetTextExtentPoint(hdc, szPrefix, AWCHLEN(szPrefix), &size);

        /*
         * If the field is too small to display all of the prefix,
         * copy only the prefix.
         */
        if (cxField < size.cx) {
            RtlCopyMemory(lpch, szPrefix, sizeof(szPrefix));
            goto DoneChop;
        } else
            cxField -= size.cx;

        /*
         * Advance a directory at a time until the remainder of the
         * string fits into the static control after the "x:\...\" prefix.
         */
        while (TRUE) {
            int cchT;
            while (*lpch && (*lpch++ != L'\\')) {
                ;
            }
            cchT = cchPath - (int)(lpch - lpchPath);
            GetTextExtentPoint(hdc, lpch, cchT, &size);
            if (*lpch == 0 || size.cx <= cxField) {

                if (*lpch == 0) {

                    /*
                     * Nothing could fit after the prefix; remove the
                     * final "\" from the prefix
                     */
                    szPrefix[AWCHLEN(szPrefix) - 1] = 0;
                }

                /*
                 * rest of string fits -- back up and stick prefix on front
                 * We are guaranteed to have at least CCH_CHOPTEXT_EXTRA chars
                 * backing up space, so we won't trash any stack. #26453
                 */
                lpch -= AWCHLEN(szPrefix);

                UserAssert(lpch >= lpchBuffer);

                RtlCopyMemory(lpch, szPrefix, sizeof(szPrefix) - sizeof(WCHAR));
                goto DoneChop;
            }
        }
    }

DoneChop:
    if (hOldFont)
        SelectObject(hdc, hOldFont);

    ReleaseDC(HWq(pwndStatic), hdc);

    return lpch;
}


/***************************************************************************\
* xxxDlgDirListHelper
*
*  NOTE:  If idStaticPath is < 0, then that parameter contains the details
*         about what should be in each line of the list box
*
* History:
\***************************************************************************/

BOOL xxxDlgDirListHelper(
    PWND pwndDlg,
    LPWSTR lpszPathSpec,
    LPBYTE lpszPathSpecClient,
    int idListBox,
    int idStaticPath,
    UINT attrib,
    BOOL fListBox)  /* Listbox or ComboBox? */
{
    PWND pwndLB;
    TL tlpwndLB;
    BOOL fDir = TRUE;
    BOOL fRoot, bRet;
    BOOL fPostIt;
    INT   cch;
    WCHAR ch;
    WCHAR szStaticPath[CCH_CHOPTEXT_EXTRA + MAX_PATH];
    PWCHAR pszCurrentDir;
    UINT wDirMsg;
    LPWSTR lpchFile;
    LPWSTR lpchDirectory;
    PLBIV plb;
    BOOL fWasVisible = FALSE;
    BOOL        fWin40Compat;
    PCBOX pcbox;

    CheckLock(pwndDlg);

    /*
     * Strip the private bit DDL_NOFILES out - KidPix passes it in my mistake!
     */
    if (attrib & ~DDL_VALID) {
        RIPERR2(ERROR_INVALID_FLAGS, RIP_WARNING, "Invalid flags, %x & ~%x != 0",
              attrib, DDL_VALID);
        return FALSE;
    }

    if (attrib & DDL_NOFILES) {
        RIPMSG0(RIP_WARNING, "DlgDirListHelper: stripping DDL_NOFILES");
        attrib &= ~DDL_NOFILES;
    }

    /*
     * Case:Works is an app that calls DlgDirList with a NULL has hwndDlg;
     * This is allowed because he uses NULL for idStaticPath and idListBox.
     * So, the validation layer has been modified to allow a NULL for hwndDlg.
     * But, we catch the bad apps with the following check.
     * Fix for Bug #11864 --SANKAR-- 08/22/91 --
     */
    if (!pwndDlg && (idStaticPath || idListBox)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        return FALSE;
    }

    plb = NULL;

    /*
     * Do we need to add date, time, size or attribute info?
     * Windows checks the Atom but misses if the class has been sub-classed
     * as in VB.
     */
    if (pwndLB = (PWND)_GetDlgItem(pwndDlg, idListBox)) {
        WORD fnid = GETFNID(pwndLB);

        if ((fnid == FNID_LISTBOX && fListBox) ||
                (fnid == FNID_COMBOBOX && !fListBox) ||
                (fnid == FNID_COMBOLISTBOX && fListBox)) {
            if (fListBox) {
                plb = ((PLBWND)pwndLB)->pLBIV;
            } else {

                pcbox = ((PCOMBOWND)pwndLB)->pcbox;
                plb = ((PLBWND)(pcbox->spwndList))->pLBIV;
            }
        } else {
            RIPERR0(ERROR_LISTBOX_ID_NOT_FOUND, RIP_VERBOSE, "");
        }
    } else if (idListBox != 0) {

        /*
         * Yell if the app passed an invalid list box id and keep from using a
         * bogus plb.  PLB is NULLed above.
         */
        RIPERR0(ERROR_LISTBOX_ID_NOT_FOUND, RIP_VERBOSE, "");
    }

    if (idStaticPath < 0 && plb != NULL) {

        /*
         * Clear idStaticPath because its purpose is over.
         */
        idStaticPath = 0;

    }

    fPostIt = (attrib & DDL_POSTMSGS);

    if (lpszPathSpec) {
        cch = lstrlenW(lpszPathSpec);
        if (!cch) {
            if (lpszPathSpecClient != (LPBYTE)lpszPathSpec) {
                lpszPathSpecClient = achSlashStar;
            }
            lpszPathSpec = awchSlashStar;
        } else {
            /*
             * Make sure we won't overflow our buffers...
             */
            if (cch > CCHFILEMAX)
                return FALSE;

            /*
             * Convert lpszPathSpec into an upper case, OEM string.
             */
            CharUpper(lpszPathSpec);
            lpchDirectory = lpszPathSpec;

            lpchFile = szSLASHSTARDOTSTAR + 1;

            if (*lpchDirectory) {

                cch = wcslen(lpchDirectory);

                /*
                 * If the directory name has a * or ? in it, don't bother trying
                 * the (slow) SetCurrentDirectory.
                 */
                if (((INT)FindCharPosition(lpchDirectory, TEXT('*')) != cch) ||
                    ((INT)FindCharPosition(lpchDirectory, TEXT('?')) != cch) ||
                    !SetCurrentDirectory(lpchDirectory)) {

                    /*
                     * Set 'fDir' and 'fRoot' accordingly.
                     */
                    lpchFile = lpchDirectory + cch;
                    fDir = *(lpchFile - 1) == TEXT('\\');
                    fRoot = 0;
                    while (cch--) {
                        ch = *(lpchFile - 1);
                        if (ch == TEXT('*') || ch == TEXT('?'))
                            fDir = TRUE;

                        if (ch == TEXT('\\') || ch == TEXT('/') || ch == TEXT(':')) {
                            fRoot = (cch == 0 || *(lpchFile - 2) == TEXT(':') ||
                                    (ch == TEXT(':')));
                            break;
                        }
                        lpchFile--;
                    }

                    /*
                     * To remove Bug #16, the following error return is to be removed.
                     * In order to prevent the existing apps from breaking up, it is
                     * decided that the bug will not be fixed and will be mentioned
                     * in the documentation.
                     * --SANKAR-- Sep 21
                     */

                    /*
                     * If no wildcard characters, return error.
                     */
                    if (!fDir) {
                        RIPERR0(ERROR_NO_WILDCARD_CHARACTERS, RIP_VERBOSE, "");
                        return FALSE;
                    }

                    /*
                     * Special case for lpchDirectory == "\"
                     */
                    if (fRoot)
                        lpchFile++;

                    /*
                     * Do we need to change directories?
                     */
                    if (fRoot || cch >= 0) {

                        /*
                         * Replace the Filename's first char with a nul.
                         */
                        ch = *--lpchFile;
                        *lpchFile = TEXT('\0');

                        /*
                         * Change the current directory.
                         */
                        if (*lpchDirectory) {
                            bRet = SetCurrentDirectory(lpchDirectory);
                            if (!bRet) {

                                /*
                                 * Restore the filename before we return...
                                 */
                                *((LPWSTR)lpchFile)++ = ch;
                                return FALSE;
                            }
                        }

                        /*
                         * Restore the filename's first character.
                         */
                        *lpchFile++ = ch;
                    }

                    /*
                     * Undo damage caused by special case above.
                     */
                    if (fRoot) {
                        lpchFile--;
                    }
                }
            }

            /*
             * This is copying on top of the data the client passed us! Since
             * the LB_DIR or CB_DIR could be posted, and since we need to
             * pass a client side string pointer when we do that, we need
             * to copy this new data back to the client!
             */
            if (fPostIt && lpszPathSpecClient != (LPBYTE)lpszPathSpec) {
                WCSToMB(lpchFile, -1, &lpszPathSpecClient, MAXLONG, FALSE);
            }
            wcscpy(lpszPathSpec, lpchFile);
        }
    }
    /*
     * In some cases, the ChopText requires extra space ahead of the path:
     * Give it CCH_CHOPTEXT_EXTRA extra spaces. (See ChopText() above).
     */
    pszCurrentDir = szStaticPath + CCH_CHOPTEXT_EXTRA;
    GetCurrentDirectory(
            sizeof(szStaticPath)/sizeof(WCHAR) - CCH_CHOPTEXT_EXTRA,
            pszCurrentDir);

    /*
     * If we have a listbox, lock it down
     */
    if (pwndLB != NULL) {
        ThreadLockAlways(pwndLB, &tlpwndLB);
    }

    /*
     * Fill in the static path item.
     */
    if (idStaticPath) {

        /*
         * To fix a bug OemToAnsi() call is inserted; SANKAR--Sep 16th
         */
// OemToChar(szCurrentDir, szCurrentDir);
        CharLower(pszCurrentDir);
        SetDlgItemText(HWq(pwndDlg), idStaticPath, ChopText(pwndDlg, idStaticPath, szStaticPath));
    }

    /*
     * Fill in the directory List/ComboBox if it exists.
     */
    if (idListBox && pwndLB != NULL) {

        HWND hwndLB = HWq(pwndLB);

        wDirMsg = (UINT)(fListBox ? LB_RESETCONTENT : CB_RESETCONTENT);

        if (fPostIt) {
            PostMessage(hwndLB, wDirMsg, 0, 0L);
        } else {
            if (plb != NULL && (fWasVisible = IsLBoxVisible(plb))) {
                SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
            }
            SendMessage(hwndLB, wDirMsg, 0, 0L);
        }

        wDirMsg = (UINT)(fListBox ? LB_DIR : CB_DIR);

        if (attrib == DDL_DRIVES)
            attrib |= DDL_EXCLUSIVE;

        //
        // Hack for DDL_EXCLUSIVE to REALLY work.
        //
        fWin40Compat = TestWF(pwndLB, WFWIN40COMPAT);

        //
        // BACKWARDS COMPATIBILITY HACK
        //
        // We want DDL_EXCLUSIVE to _really_ work for new apps.  I.E., we
        // want apps to be able to specify DDL_DRIVES/DDL_VOLUMES with
        // DDL_EXCLUSIVE and privilege bits -- and have only those items
        // matching show up, w/out files.
        //
        if (attrib & DDL_EXCLUSIVE)
        {
            if (fWin40Compat)
            {
                if (attrib & (DDL_DRIVES | DDL_DIRECTORY))
                    attrib |= DDL_NOFILES;
            }
            else
            {
                if (attrib == (DDL_DRIVES | DDL_EXCLUSIVE))
                    attrib |= DDL_NOFILES;
            }
        }

        if (!(attrib & DDL_NOFILES)) {

            /*
             * Add everything except the subdirectories and disk drives.
             */
            if (fPostIt) {
                /*
                 * Post lpszPathSpecClient, the client side pointer.
                 */
#ifdef WASWIN31
                PostMessage(hwndLB, wDirMsg, attrib &
                        ~(DDL_DIRECTORY | DDL_DRIVES | DDL_POSTMSGS),
                        (LPARAM)lpszPathSpecClient);
#else
                /*
                 * On NT, keep DDL_POSTMSGS in wParam because we need to know
                 * in the wndproc whether the pointer is clientside or server
                 * side.
                 */
                PostMessage(hwndLB, wDirMsg,
                        attrib & ~(DDL_DIRECTORY | DDL_DRIVES),
                        (LPARAM)lpszPathSpecClient);
#endif

            } else {

                /*
                 * IanJa: #ifndef WIN16 (32-bit Windows), attrib gets extended
                 * to LONG wParam automatically by the compiler
                 */
                SendMessage(hwndLB, wDirMsg,
                        attrib & ~(DDL_DIRECTORY | DDL_DRIVES),
                        (LPARAM)lpszPathSpec);
            }

#ifdef WASWIN31
            /*
             * Strip out just the subdirectory and drive bits.
             */
            attrib &= (DDL_DIRECTORY | DDL_DRIVES);
#else
            //
            // B#1433
            // The old code stripped out read-only, hidden, system, and archive
            // information for subdirectories, making it impossible to have
            // a listbox w/ hidden directories!
            //

            /*
             * Strip out just the subdirectory and drive bits. ON NT, keep
             * the DDL_POSTMSG bit so we know how to thunk this message.
             */
            if (!fWin40Compat)
                attrib &= DDL_TYPE;
            else
            {
                attrib &= (DDL_TYPE | (attrib & DDL_PRIVILEGES));
                attrib |= DDL_NOFILES;
            }
//            attrib &= (DDL_DIRECTORY | DDL_DRIVES | DDL_POSTMSGS);
#endif
        }

        //
        // Add directories and volumes to the listbox.
        //
        if (attrib & DDL_TYPE) {

            /*
             * Add the subdirectories and disk drives.
             */
            lpszPathSpec = szSLASHSTARDOTSTAR + 1;

            attrib |= DDL_EXCLUSIVE;

            if (fPostIt) {
                /*
                 * Post lpszPathSpecClient, the client side pointer (see text
                 * above).
                 */
                PostMessage(hwndLB, wDirMsg, attrib, (LPARAM)lpszPathSpecClient);
            } else {
                SendMessage(hwndLB, wDirMsg, attrib, (LPARAM)lpszPathSpec);
            }
        }

        if (!fPostIt && fWasVisible) {
            SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
            NtUserInvalidateRect(hwndLB, NULL, TRUE);
        }
    }

    if (pwndLB != NULL) {
        ThreadUnlock(&tlpwndLB);
    }

    return TRUE;
}


/***************************************************************************\
* xxxDlgDirList
*
* History:
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DlgDirListA, HWND, hwndDlg, LPSTR, lpszPathSpecClient, int, idListBox, int, idStaticPath, UINT, attrib)
BOOL DlgDirListA(
    HWND hwndDlg,
    LPSTR lpszPathSpecClient,
    int idListBox,
    int idStaticPath,
    UINT attrib)
{
    LPWSTR lpszPathSpec;
    PWND pwndDlg;
    TL tlpwndDlg;
    BOOL fRet;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return FALSE;

    lpszPathSpec = NULL;
    if (lpszPathSpecClient) {
        if (!MBToWCS(lpszPathSpecClient, -1, &lpszPathSpec, -1, TRUE))
            return FALSE;
    }

    /*
     * The last parameter is TRUE to indicate ListBox (not ComboBox)
     */
    ThreadLock(pwndDlg, &tlpwndDlg);
    fRet = xxxDlgDirListHelper(pwndDlg, lpszPathSpec, lpszPathSpecClient,
            idListBox, idStaticPath, attrib, TRUE);
    ThreadUnlock(&tlpwndDlg);

    if (lpszPathSpec) {
        if (fRet) {
            /*
             * Non-zero retval means some text to copy out.  Copy out up to
             * the nul terminator (buffer will be big enough).
             */
            WCSToMB(lpszPathSpec, -1, &lpszPathSpecClient, MAXLONG, FALSE);
        }
        UserLocalFree(lpszPathSpec);
    }

    return fRet;
}


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DlgDirListW, HWND, hwndDlg, LPWSTR, lpszPathSpecClient, int, idListBox, int, idStaticPath, UINT, attrib)
BOOL DlgDirListW(
    HWND hwndDlg,
    LPWSTR lpszPathSpecClient,
    int idListBox,
    int idStaticPath,
    UINT attrib)
{
    LPWSTR lpszPathSpec;
    PWND pwndDlg;
    TL tlpwndDlg;
    BOOL fRet;

    pwndDlg = ValidateHwnd(hwndDlg);

    if (pwndDlg == NULL)
        return FALSE;

    lpszPathSpec = lpszPathSpecClient;

    /*
     * The last parameter is TRUE to indicate ListBox (not ComboBox)
     */
    ThreadLock(pwndDlg, &tlpwndDlg);
    fRet = xxxDlgDirListHelper(pwndDlg, lpszPathSpec, (LPBYTE)lpszPathSpecClient,
            idListBox, idStaticPath, attrib, TRUE);
    ThreadUnlock(&tlpwndDlg);

    return fRet;
}


/***************************************************************************\
* DlgDirSelectHelper
*
* History:
\***************************************************************************/

BOOL DlgDirSelectHelper(
    LPWSTR lpszPathSpec,
    int chCount,
    HWND hwndListBox)
{
    INT   cch;
    LPWSTR lpchFile;
    BOOL fDir;
    INT sItem;
    LPWSTR lpchT;
    WCHAR rgch[CCHFILEMAX + 2];
    int cchT;
    LARGE_UNICODE_STRING str;

    /*
     * Callers such as DlgDirSelectEx do not validate the existance
     * of hwndListBox
     */
    if (hwndListBox == NULL) {
        RIPERR0(ERROR_CONTROL_ID_NOT_FOUND, RIP_VERBOSE, "");
        return 0;
    }

    sItem = (INT)SendMessage(hwndListBox, LB_GETCURSEL, 0, 0L);
    if (sItem < 0)
        return FALSE;

    cchT = (INT)SendMessage(hwndListBox, LB_GETTEXT, sItem, (LPARAM)rgch);
    UserAssert(cchT < (sizeof(rgch)/sizeof(rgch[0])));

    lpchFile = rgch;
    fDir = (*rgch == TEXT('['));

    /*
     * Check if all details along with file name are to be returned.  Make sure
     * we can find the listbox because with drop down combo boxes, the
     * GetDlgItem will fail.
     *
     * Make sure this window has been using the listbox window proc because
     * we store some data as a window long.
     */

    /*
     * Only the file name is to be returned.  Find the end of the filename.
     */
    lpchT = lpchFile;
    while ((*lpchT) && (*lpchT != TABCHAR))
        lpchT++;
    *lpchT = TEXT('\0');

    cch = wcslen(lpchFile);

    /*
     * Selection is drive or directory.
     */
    if (fDir) {
        lpchFile++;
        cch--;
        *(lpchFile + cch - 1) = TEXT('\\');

        /*
         * Selection is drive
         */
        if (rgch[1] == TEXT('-')) {
            lpchFile++;
            cch--;
            *(lpchFile + 1) = TEXT(':');
            *(lpchFile + 2) = 0;
        }
    } else {

        /*
         * Selection is file.  If filename has no extension, append '.'
         */
        lpchT = lpchFile;
        for (; (cch > 0) && (*lpchT != TABCHAR);
                cch--, lpchT++) {
            if (*lpchT == TEXT('.'))
                goto Exit;
        }
        if (*lpchT == TABCHAR) {
            memmove(lpchT + 1, lpchT, CHARSTOBYTES(cch + 1));
            *lpchT = TEXT('.');
        } else {
            *lpchT++ = TEXT('.');
            *lpchT = 0;
        }
    }

Exit:
    RtlInitLargeUnicodeString(&str, lpchFile, (UINT)-1);
    TextCopy(&str, lpszPathSpec, (UINT)chCount);
    return fDir;
}


/***************************************************************************\
* DlgDirSelectEx
*
* History:
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DlgDirSelectExA, HWND, hwndDlg, LPSTR, lpszPathSpec, int, chCount, int, idListBox)
BOOL DlgDirSelectExA(
    HWND hwndDlg,
    LPSTR lpszPathSpec,
    int chCount,
    int idListBox)
{
    LPWSTR lpwsz;
    BOOL fRet;

    lpwsz = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, chCount * sizeof(WCHAR));
    if (!lpwsz) {
        return FALSE;
    }

    fRet = DlgDirSelectHelper(lpwsz, chCount, GetDlgItem(hwndDlg, idListBox));

    WCSToMB(lpwsz, -1, &lpszPathSpec, chCount, FALSE);

    UserLocalFree(lpwsz);

    return fRet;
}


FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DlgDirSelectExW, HWND, hwndDlg, LPWSTR, lpszPathSpec, int, chCount, int, idListBox)
BOOL DlgDirSelectExW(
    HWND hwndDlg,
    LPWSTR lpszPathSpec,
    int chCount,
    int idListBox)
{
    return DlgDirSelectHelper(lpszPathSpec, chCount, GetDlgItem(hwndDlg, idListBox));
}


/***************************************************************************\
* xxxLbDir
*
* History:
\***************************************************************************/

/*
 * Note that these FILE_ATTRIBUTE_* values map directly with
 * their DDL_* counterparts, with the exception of FILE_ATTRIBUTE_NORMAL.
 */
#define FIND_ATTR ( \
        FILE_ATTRIBUTE_NORMAL | \
        FILE_ATTRIBUTE_DIRECTORY | \
        FILE_ATTRIBUTE_HIDDEN | \
        FILE_ATTRIBUTE_SYSTEM | \
        FILE_ATTRIBUTE_ARCHIVE | \
        FILE_ATTRIBUTE_READONLY )
#define EXCLUDE_ATTR ( \
        FILE_ATTRIBUTE_DIRECTORY | \
        FILE_ATTRIBUTE_HIDDEN | \
        FILE_ATTRIBUTE_SYSTEM )

INT xxxLbDir(
    PLBIV plb,
    UINT attrib,
    LPWSTR lhszFileSpec)
{
    INT result;
    BOOL fWasVisible, bRet;
    WCHAR Buffer[CCHFILEMAX + 1];
    WCHAR Buffer2[CCHFILEMAX + 1];
    HANDLE hFind;
    WIN32_FIND_DATA ffd;
    UINT attribFile;
    DWORD mDrives;
    INT cDrive;
    UINT attribInclMask, attribExclMask;

    CheckLock(plb->spwnd);

    /*
     * Make sure the buffer is valid and copy it onto the stack. Why? Because
     * there is a chance that lhszFileSpec is pointing to an invalid string
     * because some app posted a CB_DIR or LB_DIR without the DDL_POSTMSGS
     * bit set.
     */
    try {
        wcscpy(Buffer2, lhszFileSpec);
        lhszFileSpec = Buffer2;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return -1;
    }

    result = -1;

#ifndef UNICODE
    CharToOem(lhszFileSpec, lhszFileSpec);
#endif

    if (fWasVisible = IsLBoxVisible(plb)) {
        SendMessage(HWq(plb->spwnd), WM_SETREDRAW, FALSE, 0);
    }

    /*
     * First we add the files then the directories and drives.
     * If they only wanted drives then skip the file query
     * Also under Windows specifing only 0x8000 (DDL_EXCLUSIVE) adds no files).
     */


//    if ((attrib != (DDL_EXCLUSIVE | DDL_DRIVES)) && (attrib != DDL_EXCLUSIVE) &&
    if (attrib != (DDL_EXCLUSIVE | DDL_DRIVES | DDL_NOFILES)) {
        hFind = FindFirstFile(lhszFileSpec, &ffd);

        if (hFind != INVALID_HANDLE_VALUE) {

            /*
             * If this is not an exclusive search, include normal files.
             */
            attribInclMask = attrib & FIND_ATTR;
            if (!(attrib & DDL_EXCLUSIVE))
                attribInclMask |= FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_READONLY |
                        FILE_ATTRIBUTE_ARCHIVE;

            /*
             * Make a mask of the attributes to be excluded from
             * the search.
             */
            attribExclMask = ~attrib & EXCLUDE_ATTR;

// LATER BUG - scottlu
// Win3 assumes doing a LoadCursor here will return the same wait cursor that
// has already been created, whereas calling ServerLoadCursor creates a new
// one every time!
// hCursorT = NtUserSetCursor(ServerLoadCursor(NULL, IDC_WAIT));


// FindFirst/Next works different in NT then DOS.  Under DOS you passed in
// a set of attributes under NT you get back a set of attributes and have
// to test for those attributes (Dos input attributes were Hidden, System
// and Directoy) the dos find first always returned ReadOnly and archive files

// we are going to select a file in one of two cases.
// 1) if any of the attrib bits are set on the file.
// 2) if we want normal files and the file is a notmal file (the file attrib
//    bits don't contain any NOEXCLBITS

            do {
                attribFile = (UINT)ffd.dwFileAttributes;
                if (attribFile == FILE_ATTRIBUTE_COMPRESSED) {
                    attribFile = FILE_ATTRIBUTE_NORMAL;
                }
                attribFile &= ~FILE_ATTRIBUTE_COMPRESSED;

                /*
                 * Accept those files that have only the
                 * attributes that we are looking for.
                 */
                if ((attribFile & attribInclMask) != 0 &&
                        (attribFile & attribExclMask) == 0) {
                    if (attribFile & DDL_DIRECTORY) {

                        /*
                         * Don't include '.' (current directory) in list.
                         */
                        if (*((LPDWORD)&ffd.cFileName[0]) == 0x0000002E)
                            goto cfnf;

                        /*
                         * If we're not looking for dirs, ignore it
                         */
                        if (!(attrib & DDL_DIRECTORY))
                            goto cfnf;

                    } else if (attrib & DDL_NOFILES) {
                        /*
                         * Don't include files if DDL_NOFILES is set.
                         */
                        goto cfnf;
                    }

                    LB_CreateLBLine(&ffd,
                            Buffer);
                    result = xxxLBInsertItem(plb, Buffer, 0, MSGFLAG_SPECIAL_THUNK | LBI_ADD);
                }
cfnf:
                bRet = FindNextFile(hFind, &ffd);

            } while (result >= -1 && bRet);
            FindClose(hFind);

// LATER see above comment
// NtUserSetCursor(hCursorT);
        }
    }

    /*
     * If drive bit set, include drives in the list.
     */
    if (result != LB_ERRSPACE && (attrib & DDL_DRIVES)) {
        ffd.cFileName[0] = TEXT('[');
        ffd.cFileName[1] = ffd.cFileName[3] = TEXT('-');
        ffd.cFileName[4] = TEXT(']');
        ffd.cFileName[5] = 0;
        mDrives = GetLogicalDrives();
        for (cDrive = 0; mDrives; mDrives >>= 1, cDrive++) {
            if (mDrives & 1) {
                ffd.cFileName[2] = (WCHAR)(TEXT('A') + cDrive);

                /*
                 * We have to set the SPECIAL_THUNK bit because we are
                 * adding a server side string to a list box that may not
                 * be HASSTRINGS so we have to force the server-client
                 * string thunk.
                 */
                if ((result = xxxLBInsertItem(plb, CharLower(ffd.cFileName), -1,
                        MSGFLAG_SPECIAL_THUNK)) < 0) {
                    break;
                }
            }
        }
    }

    if (result == LB_ERRSPACE) {
        xxxNotifyOwner(plb, LB_ERRSPACE);
    }

    if (fWasVisible) {
        SendMessage(HWq(plb->spwnd), WM_SETREDRAW, TRUE, 0);
    }

    xxxLBShowHideScrollBars(plb);

    xxxCheckRedraw(plb, FALSE, 0);

    if (result != LB_ERRSPACE) {

        /*
         * Return index of last item in the listbox.  We can't just return
         * result because that is the index of the last item added which may
         * be in the middle somewhere if the LBS_SORT style is on.
         */
        return plb->cMac - 1;
    } else {
        return result;
    }
}

/***************************************************************************\
* xxxLbInsertFile
*
* Yet another CraigC shell hack... This responds to LB_ADDFILE messages
* sent to directory windows in the file system as a response to the
* WM_FILESYSCHANGE message.  That way, we don't reread the whole
* directory when we copy files.
*
* History:
\***************************************************************************/

INT xxxLbInsertFile(
    PLBIV plb,
    LPWSTR lpFile)
{
    WCHAR chBuffer[CCHFILEMAX + 1];
    INT result = -1;
    HANDLE hFind;
    WIN32_FIND_DATA ffd;

    CheckLock(plb->spwnd);

    hFind = FindFirstFile(lpFile, &ffd);
    if (hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
        LB_CreateLBLine(&ffd, chBuffer);
        result = xxxLBInsertItem(plb, chBuffer, 0, MSGFLAG_SPECIAL_THUNK | LBI_ADD);
    }

    if (result == LB_ERRSPACE) {
        xxxNotifyOwner(plb, result);
    }

    xxxCheckRedraw(plb, FALSE, 0);
    return result;
}

/***************************************************************************\
* LB_CreateLBLine
*
* This creates a character string that contains all the required
* details of a file;( Name)
*
* History:
\***************************************************************************/

void LB_CreateLBLine(
    PWIN32_FIND_DATA pffd,
    LPWSTR lpBuffer)
{
    BYTE bAttribute;
    LPWSTR lpch;

    lpch = lpBuffer;

    bAttribute = (BYTE)pffd->dwFileAttributes;
    if (bAttribute & DDL_DIRECTORY)  /* Is it a directory */
        *lpch++ = TEXT('[');

    /*
     * Copy the file name
     *
     * If we are running from wow, check if the shortname exists
     */
    if (GetClientInfo()->dwTIFlags & TIF_16BIT) {
        UNICODE_STRING Name;
        BOOLEAN fSpace = FALSE;

        RtlInitUnicodeString(&Name, pffd->cFileName);
        if (RtlIsNameLegalDOS8Dot3(&Name, NULL, &fSpace) && !fSpace) {
            /*
             * Legal 8.3 name and no spaces, so use the principal
             * file name.
             */
            wcscpy(lpch, pffd->cFileName);
        } else {
            if (pffd->cAlternateFileName[0] == 0)
                wcscpy(lpch, pffd->cFileName);
            else
                /*
                 * Use the alternate file name.
                 */
                wcscpy(lpch, pffd->cAlternateFileName);
        }
        /*
         * Make filename lower-case for 16-bit apps.  Some Corel apps
         * require this.
         */
        CharLower(lpch);

    }
    else
       wcscpy(lpch, pffd->cFileName);

    lpch = (LPWSTR)(lpch + wcslen(lpch));

    if (bAttribute & DDL_DIRECTORY)  /* Is it a directory */
        *lpch++ = TEXT(']');

    *lpch = TEXT('\0');

#ifndef UNICODE
    OemToChar(lpBuffer, lpBuffer);
#endif

    *lpch = TEXT('\0');  /* Null terminate */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\lboxrare.c ===
/**************************** Module Header ********************************\
* Module Name: lboxrare.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Infrequently Used List Box Routines
*
* History:
* ??-???-???? ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern LOOKASIDE ListboxLookaside;

/***************************************************************************\
* LBSetCItemFullMax
*
* History:
* 03-04-92 JimA             Ported from Win 3.1 sources.
\***************************************************************************/

void LBSetCItemFullMax(
    PLBIV plb)
{
    if (plb->OwnerDraw != OWNERDRAWVAR) {
        plb->cItemFullMax = CItemInWindow(plb, FALSE);
    } else if (plb->cMac < 2) {
        plb->cItemFullMax = 1;
    } else {
        int     height;
        RECT    rect;
        int     i;
        int     j = 0;

        _GetClientRect(plb->spwnd, &rect);
        height = rect.bottom;

        plb->cItemFullMax = 0;
        for (i = plb->cMac - 1; i >= 0; i--, j++) {
            height -= LBGetVariableHeightItemHeight(plb, i);

            if (height < 0) {
                plb->cItemFullMax = j;
                break;
            }
        }
        if (!plb->cItemFullMax)
            plb->cItemFullMax = j;
    }
}

/***************************************************************************\
* xxxCreateLBox
*
* History:
* 16-Apr-1992 beng      Added LBS_NODATA
\***************************************************************************/

LONG xxxLBCreate(
    PLBIV plb, PWND pwnd, LPCREATESTRUCT lpcs)
{
    UINT style;
    MEASUREITEMSTRUCT measureItemStruct;
    TL tlpwndParent;
    HDC hdc;

    /*
     * Once we make it here, nobody can change the ownerdraw style bits
     * by calling SetWindowLong. The window style must match the flags in plb
     *
     */
    plb->fInitialized = TRUE;

    style = pwnd->style;

    /*
     * Compatibility hack.
     */
    if (pwnd->spwndParent == NULL)
        Lock(&(plb->spwndParent), _GetDesktopWindow());
    else
        Lock(&(plb->spwndParent), REBASEPWND(pwnd, spwndParent));

    /*
     * Break out the style bits
     */
    plb->fRedraw = ((style & LBS_NOREDRAW) == 0);
    plb->fDeferUpdate = FALSE;
    plb->fNotify = (UINT)((style & LBS_NOTIFY) != 0);
    plb->fVertBar = ((style & WS_VSCROLL) != 0);
    plb->fHorzBar = ((style & WS_HSCROLL) != 0);

    if (!TestWF(pwnd, WFWIN40COMPAT)) {
        // for 3.x apps, if either scroll bar was specified, the app got BOTH
        if (plb->fVertBar || plb->fHorzBar)
            plb->fVertBar = plb->fHorzBar = TRUE;
    }

    plb->fRtoLReading = (TestWF(pwnd, WEFRTLREADING) != 0);
    plb->fRightAlign  = (TestWF(pwnd, WEFRIGHT) != 0);
    plb->fDisableNoScroll = ((style & LBS_DISABLENOSCROLL) != 0);

    plb->fSmoothScroll = TRUE;

    /*
     * LBS_NOSEL gets priority over any other selection style.  Next highest
     * priority goes to LBS_EXTENDEDSEL. Then LBS_MULTIPLESEL.
     */
    if (TestWF(pwnd, WFWIN40COMPAT) && (style & LBS_NOSEL)) {
        plb->wMultiple = SINGLESEL;
        plb->fNoSel = TRUE;
    } else if (style & LBS_EXTENDEDSEL) {
        plb->wMultiple = EXTENDEDSEL;
    } else {
        plb->wMultiple = (UINT)((style & LBS_MULTIPLESEL) ? MULTIPLESEL : SINGLESEL);
    }

    plb->fNoIntegralHeight = ((style & LBS_NOINTEGRALHEIGHT) != 0);
    plb->fWantKeyboardInput = ((style & LBS_WANTKEYBOARDINPUT) != 0);
    plb->fUseTabStops = ((style & LBS_USETABSTOPS) != 0);
    if (plb->fUseTabStops) {

        /*
         * Set tab stops every <default> dialog units.
         */
        LBSetTabStops(plb, 0, NULL);
    }
    plb->fMultiColumn = ((style & LBS_MULTICOLUMN) != 0);
    plb->fHasStrings = TRUE;
    plb->iLastSelection = -1;
    plb->iMouseDown = -1;  /* Anchor point for multi selection */
    plb->iLastMouseMove = -1;

    /*
     * Get ownerdraw style bits
     */
    if ((style & LBS_OWNERDRAWFIXED)) {
        plb->OwnerDraw = OWNERDRAWFIXED;
    } else if ((style & LBS_OWNERDRAWVARIABLE) && !plb->fMultiColumn) {
        plb->OwnerDraw = OWNERDRAWVAR;

        /*
         * Integral height makes no sense with var height owner draw
         */
        plb->fNoIntegralHeight = TRUE;
    }

    if (plb->OwnerDraw && !(style & LBS_HASSTRINGS)) {

        /*
         * If owner draw, do they want the listbox to maintain strings?
         */
        plb->fHasStrings = FALSE;
    }

    /*
     * If user specifies sort and not hasstrings, then we will send
     * WM_COMPAREITEM messages to the parent.
     */
    plb->fSort = ((style & LBS_SORT) != 0);

    /*
     * "No data" lazy-eval listbox mandates certain other style settings
     */
    plb->fHasData = TRUE;

    if (style & LBS_NODATA) {
        if (plb->OwnerDraw != OWNERDRAWFIXED || plb->fSort || plb->fHasStrings) {
            RIPERR0(ERROR_INVALID_FLAGS, RIP_WARNING,
                 "NODATA listbox must be OWNERDRAWFIXED, w/o SORT or HASSTRINGS");
        } else {
            plb->fHasData = FALSE;
        }
    }

    plb->dwLocaleId = GetThreadLocale();

    /*
     * Check if this is part of a combo box
     */
    if ((style & LBS_COMBOBOX) != 0) {

        /*
         * Get the pcbox structure contained in the parent window's extra data
         * pointer.  Check cbwndExtra to ensure compatibility with SQL windows.
         */
        if (plb->spwndParent->cbwndExtra != 0)
            plb->pcbox = ((PCOMBOWND)(plb->spwndParent))->pcbox;
    }

    /*
     * No need to set these to 0 since that was done for us when we Alloced
     * the PLBIV.
     */

    /*
     * plb->rgpch       = (PBYTE)0;
     */

    /*
     * plb->iSelBase    = plb->iTop = 0;
     */

    /*
     * plb->fMouseDown  = FALSE;
     */

    /*
     * plb->fCaret      = FALSE;
     */

    /*
     * plb->fCaretOn    = FALSE;
     */

    /*
     * plb->maxWidth    = 0;
     */

    plb->iSel = -1;

    plb->hdc        = NULL;

    /*
     * Set the keyboard state so that when the user keyboard clicks he selects
     * an item.
     */
    plb->fNewItemState = TRUE;

    InitHStrings(plb);

    if (plb->fHasStrings && plb->hStrings == NULL) {
        return -1L;
    }

    hdc = NtUserGetDC(HWq(pwnd));
    plb->cxChar = GdiGetCharDimensions(hdc, NULL, &plb->cyChar);
    NtUserReleaseDC(HWq(pwnd), hdc);

    if (plb->cxChar == 0) {
        RIPMSG0(RIP_WARNING, "xxxLBCreate: GdiGetCharDimensions failed");
        plb->cxChar = gpsi->cxSysFontChar;
        plb->cyChar = gpsi->cySysFontChar;
    }

    if (plb->OwnerDraw == OWNERDRAWFIXED) {

        /*
         * Query for item height only if we are fixed height owner draw.  Note
         * that we don't care about an item's width for listboxes.
         */
        measureItemStruct.CtlType = ODT_LISTBOX;
        measureItemStruct.CtlID = PtrToUlong(pwnd->spmenu);

        /*
         * System font height is default height
         */
        measureItemStruct.itemHeight = plb->cyChar;
        measureItemStruct.itemWidth = 0;
        measureItemStruct.itemData = 0;

        /*
         * IanJa: #ifndef WIN16 (32-bit Windows), plb->id gets extended
         * to LONG wParam automatically by the compiler
         */
        ThreadLock(plb->spwndParent, &tlpwndParent);
        SendMessage(HW(plb->spwndParent), WM_MEASUREITEM,
                measureItemStruct.CtlID,
                (LPARAM)&measureItemStruct);
        ThreadUnlock(&tlpwndParent);

        /*
         * Use default height if given 0.  This prevents any possible future
         * div-by-zero errors.
         */
        if (measureItemStruct.itemHeight)
            plb->cyChar = measureItemStruct.itemHeight;


        if (plb->fMultiColumn) {

            /*
             * Get default column width from measure items struct if we are a
             * multicolumn listbox.
             */
            plb->cxColumn = measureItemStruct.itemWidth;
        }
    } else if (plb->OwnerDraw == OWNERDRAWVAR)
        plb->cyChar = 0;


    if (plb->fMultiColumn) {

        /*
         * Set these default values till we get the WM_SIZE message and we
         * calculate them properly.  This is because some people create a
         * 0 width/height listbox and size it later.  We don't want to have
         * problems with invalid values in these fields
         */
        if (plb->cxColumn <= 0)
            plb->cxColumn = 15 * plb->cxChar;
        plb->numberOfColumns = plb->itemsPerColumn = 1;
    }

    LBSetCItemFullMax(plb);

    // Don't do this for 4.0 apps.  It'll make everyone's lives easier and
    // fix the anomaly that a combo & list created the same width end up
    // different when all is done.
    // B#1520

    if (!TestWF(pwnd, WFWIN40COMPAT)) {
        plb->fIgnoreSizeMsg = TRUE;
        NtUserMoveWindow(HWq(pwnd),
             lpcs->x - SYSMET(CXBORDER),
             lpcs->y - SYSMET(CYBORDER),
             lpcs->cx + SYSMET(CXEDGE),
             lpcs->cy + SYSMET(CYEDGE),
             FALSE);
        plb->fIgnoreSizeMsg = FALSE;
    }

    if (!plb->fNoIntegralHeight) {

        /*
         * Send a message to ourselves to resize the listbox to an integral
         * height.  We need to do it this way because at create time we are all
         * mucked up with window rects etc...
         * IanJa: #ifndef WIN16 (32-bit Windows), wParam 0 gets extended
         * to wParam 0L automatically by the compiler.
         */
        PostMessage(HWq(pwnd), WM_SIZE, 0, 0L);
    }

    return 1L;
}

/***************************************************************************\
* xxxLBoxDoDeleteItems
*
* Send DELETEITEM message for all the items in the ownerdraw listbox.
*
* History:
* 16-Apr-1992 beng          Nodata case
\***************************************************************************/

void xxxLBoxDoDeleteItems(
    PLBIV plb)
{
    INT sItem;

    CheckLock(plb->spwnd);

    /*
     * Send WM_DELETEITEM message for ownerdraw listboxes which are
     * being deleted.  (NODATA listboxes don't send such, though.)
     */
    if (plb->OwnerDraw && plb->cMac && plb->fHasData) {
        for (sItem = plb->cMac - 1; sItem >= 0; sItem--) {
            xxxLBoxDeleteItem(plb, sItem);
        }
    }
}


/***************************************************************************\
* xxxDestroyLBox
*
* History:
\***************************************************************************/

void xxxDestroyLBox(
    PLBIV pLBIV,
    PWND pwnd)
{
    PWND pwndParent;

    CheckLock(pwnd);

    if (pLBIV != NULL) {
        CheckLock(pLBIV->spwnd);

        /*
         * If ownerdraw, send deleteitem messages to parent
         */
        xxxLBoxDoDeleteItems(pLBIV);

        if (pLBIV->rgpch != NULL) {
            UserLocalFree(pLBIV->rgpch);
            pLBIV->rgpch = NULL;
        }

        if (pLBIV->hStrings != NULL) {
            UserLocalFree(pLBIV->hStrings);
            pLBIV->hStrings = NULL;
        }

        if (pLBIV->iTabPixelPositions != NULL) {
            UserLocalFree((HANDLE)pLBIV->iTabPixelPositions);
            pLBIV->iTabPixelPositions = NULL;
        }

        Unlock(&pLBIV->spwnd);
        Unlock(&pLBIV->spwndParent);

        if (pLBIV->pszTypeSearch) {
            UserLocalFree(pLBIV->pszTypeSearch);
        }

        FreeLookasideEntry(&ListboxLookaside, pLBIV);
    }

    /*
     * Set the window's fnid status so that we can ignore rogue messages
     */
    NtUserSetWindowFNID(HWq(pwnd), FNID_CLEANEDUP_BIT);

    /*
     * If we're part of a combo box, let it know we're gone
     */
    pwndParent = REBASEPWND(pwnd, spwndParent);
    if (pwndParent && GETFNID(pwndParent) == FNID_COMBOBOX) {
        ComboBoxWndProcWorker(pwndParent, WM_PARENTNOTIFY,
                MAKELONG(WM_DESTROY, PTR_TO_ID(pwnd->spmenu)), (LPARAM)HWq(pwnd), FALSE);
    }
}


/***************************************************************************\
* xxxLBSetFont
*
* History:
\***************************************************************************/

void xxxLBSetFont(
    PLBIV plb,
    HANDLE hFont,
    BOOL fRedraw)
{
    HDC     hdc;
    HANDLE  hOldFont = NULL;
    int     iHeight;

    CheckLock(plb->spwnd);

    plb->hFont = hFont;

    hdc = NtUserGetDC(HWq(plb->spwnd));

    if (hFont) {
        hOldFont = SelectObject(hdc, hFont);
        if (!hOldFont) {
            plb->hFont = NULL;
        }
    }

    plb->cxChar = GdiGetCharDimensions(hdc, NULL, &iHeight);
    if (plb->cxChar == 0) {
        RIPMSG0(RIP_WARNING, "xxxLBSetFont: GdiGetCharDimensions failed");
        plb->cxChar = gpsi->cxSysFontChar;
        iHeight = gpsi->cySysFontChar;
    }


    if (!plb->OwnerDraw && (plb->cyChar != iHeight)) {

        /*
         * We don't want to mess up the cyChar height for owner draw listboxes
         * so don't do this.
         */
        plb->cyChar = iHeight;

        /*
         * Only resize the listbox for 4.0 dudes, or combo dropdowns.
         * Macromedia Director 4.0 GP-faults otherwise.
         */
        if (!plb->fNoIntegralHeight &&
                (plb->pcbox || TestWF(plb->spwnd, WFWIN40COMPAT))) {
            xxxLBSize(plb,
                plb->spwnd->rcClient.right  - plb->spwnd->rcClient.left,
                plb->spwnd->rcClient.bottom - plb->spwnd->rcClient.top);
        }
    }

    if (hOldFont) {
        SelectObject(hdc, hOldFont);
    }

    /*
     * IanJa: was ReleaseDC(hwnd, hdc);
     */
    NtUserReleaseDC(HWq(plb->spwnd), hdc);

    if (plb->fMultiColumn) {
        LBCalcItemRowsAndColumns(plb);
    }

    LBSetCItemFullMax(plb);

    if (fRedraw)
        xxxCheckRedraw(plb, FALSE, 0);
}


/***************************************************************************\
* xxxLBSize
*
* History:
\***************************************************************************/

void xxxLBSize(
    PLBIV plb,
    INT cx,
    INT cy)
{
    RECT rc;
    int iTopOld;
    BOOL fSizedSave;

    CheckLock(plb->spwnd);

    if (!plb->fNoIntegralHeight) {
        int cBdrs = GetWindowBorders(plb->spwnd->style, plb->spwnd->ExStyle, TRUE, TRUE);

        CopyInflateRect(&rc, KPRECT_TO_PRECT(&plb->spwnd->rcWindow), 0, -cBdrs * SYSMET(CYBORDER));

        // Size the listbox to fit an integral # of items in its client
        if ((rc.bottom - rc.top) % plb->cyChar) {
            int iItems = (rc.bottom - rc.top);

            // B#2285 - If its a 3.1 app its SetWindowPos needs
            // to be window based dimensions not Client !
            // this crunches Money into using a scroll bar

            if ( ! TestWF( plb->spwnd, WFWIN40COMPAT ) )
                iItems += (cBdrs * SYSMET(CYEDGE)); // so add it back in

            iItems /= plb->cyChar;

            NtUserSetWindowPos(HWq(plb->spwnd), HWND_TOP, 0, 0, rc.right - rc.left,
                    iItems * plb->cyChar + (SYSMET(CYEDGE) * cBdrs),
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);

            /*
             * Changing the size causes us to recurse.  Upon return
             * the state is where it should be and nothing further
             * needs to be done.
             */
            return;
        }
    }

    if (plb->fMultiColumn) {

        /*
         * Compute the number of DISPLAYABLE rows and columns in the listbox
         */
        LBCalcItemRowsAndColumns(plb);
    } else {

        /*
         * Adjust the current horizontal position to eliminate as much
         * empty space as possible from the right side of the items.
         */
        _GetClientRect(plb->spwnd, &rc);
        if ((plb->maxWidth - plb->xOrigin) < (rc.right - rc.left))
            plb->xOrigin = max(0, plb->maxWidth - (rc.right - rc.left));
    }

    LBSetCItemFullMax(plb);

    /*
     * Adjust the top item in the listbox to eliminate as much empty space
     * after the last item as possible
     * (fix for bugs #8490 & #3836)
     */
    iTopOld = plb->iTop;
    fSizedSave = plb->fSized;
    plb->fSized = FALSE;
    xxxNewITop(plb, plb->iTop);

    /*
     * If changing the top item index caused a resize, there is no
     * more work to be done here.
     */
    if (plb->fSized)
        return;
    plb->fSized = fSizedSave;

    if (IsLBoxVisible(plb)) {
        /*
         * This code no longer blows because it's fixed right!!!  We could
         * optimize the fMultiColumn case with some more code to figure out
         * if we really need to invalidate the whole thing but note that some
         * 3.0 apps depend on this extra invalidation (AMIPRO 2.0, bug 14620)
         *
         * For 3.1 apps, we blow off the invalidaterect in the case where
         * cx and cy are 0 because this happens during the processing of
         * the posted WM_SIZE message when we are created which would otherwise
         * cause us to flash.
         */
        if ((plb->fMultiColumn && !(cx == 0 && cy == 0)) ||
                plb->iTop != iTopOld)
            NtUserInvalidateRect(HWq(plb->spwnd), NULL, TRUE);
        else if (plb->iSelBase >= 0) {

            /*
             * Invalidate the item with the caret so that if the listbox
             * grows horizontally, we redraw it properly.
             */
            LBGetItemRect(plb, plb->iSelBase, &rc);
            NtUserInvalidateRect(HWq(plb->spwnd), &rc, FALSE);
        }
    } else if (!plb->fRedraw)
        plb->fDeferUpdate = TRUE;

    /*
     * Send "fake" scroll bar messages to update the scroll positions since we
     * changed size.
     */
    if (TestWF(plb->spwnd, WFVSCROLL)) {
        xxxLBoxCtlScroll(plb, SB_ENDSCROLL, 0);
    }

    /*
     * We count on this to call LBShowHideScrollBars except when plb->cMac == 0!
     */
    xxxLBoxCtlHScroll(plb, SB_ENDSCROLL, 0);

    /*
     * Show/hide scroll bars depending on how much stuff is visible...
     *
     * Note:  Now we only call this guy when cMac == 0, because it is
     * called inside the LBoxCtlHScroll with SB_ENDSCROLL otherwise.
     */
    if (plb->cMac == 0)
        xxxLBShowHideScrollBars(plb);
}


/***************************************************************************\
* LBSetTabStops
*
* Sets the tab stops for this listbox. Returns TRUE if successful else FALSE.
*
* History:
\***************************************************************************/

BOOL LBSetTabStops(
    PLBIV plb,
    INT count,
    LPINT lptabstops)
{
    PINT ptabs;

    if (!plb->fUseTabStops) {
        RIPERR0(ERROR_LB_WITHOUT_TABSTOPS, RIP_VERBOSE, "");
        return FALSE;
    }

    if (count) {
        /*
         * Allocate memory for the tab stops.  The first byte in the
         * plb->iTabPixelPositions array will contain a count of the number
         * of tab stop positions we have.
         */
        ptabs = (LPINT)UserLocalAlloc(HEAP_ZERO_MEMORY, (count + 1) * sizeof(int));
        if (ptabs == NULL)
            return FALSE;

        if (plb->iTabPixelPositions != NULL)
            UserLocalFree(plb->iTabPixelPositions);
        plb->iTabPixelPositions = ptabs;

        /*
         * Set the count of tab stops
         */
        *ptabs++ = count;

        for (; count > 0; count--) {

            /*
             * Convert the dialog unit tabstops into pixel position tab stops.
             */
            *ptabs++ = MultDiv(*lptabstops, plb->cxChar, 4);
            lptabstops++;
        }
    } else {

        /*
         * Set default 8 system font ave char width tabs.  So free the memory
         * associated with the tab stop list.
         */
        if (plb->iTabPixelPositions != NULL) {
            UserLocalFree((HANDLE)plb->iTabPixelPositions);
            plb->iTabPixelPositions = NULL;
        }
    }

    return TRUE;
}


/***************************************************************************\
* InitHStrings
*
* History:
\***************************************************************************/

void InitHStrings(
    PLBIV plb)
{
    if (plb->fHasStrings) {
        plb->ichAlloc = 0;
        plb->cchStrings = 0;
        plb->hStrings = UserLocalAlloc(0, 0L);
    }
}


/***************************************************************************\
* LBDropObjectHandler
*
* Handles a WM_DROPITEM message on this listbox
*
* History:
\***************************************************************************/

void LBDropObjectHandler(
    PLBIV plb,
    PDROPSTRUCT pds)
{
    LONG mouseSel;

    if (ISelFromPt(plb, pds->ptDrop, &mouseSel)) {

        /*
         * User dropped in empty space at bottom of listbox
         */
        pds->dwControlData = (DWORD)-1L;
    } else {
        pds->dwControlData = mouseSel;
    }
}


/***************************************************************************\
* LBGetSetItemHeightHandler()
*
* Sets/Gets the height associated with each item.  For non ownerdraw
* and fixed height ownerdraw, the item number is ignored.
*
* History:
\***************************************************************************/

int LBGetSetItemHeightHandler(
    PLBIV plb,
    UINT message,
    int item,
    UINT height)
{
    if (message == LB_GETITEMHEIGHT) {
        /*
         * All items are same height for non ownerdraw and for fixed height
         * ownerdraw.
         */
        if (plb->OwnerDraw != OWNERDRAWVAR)
            return plb->cyChar;

        if (plb->cMac && item >= plb->cMac) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return LB_ERR;
        }

        return (int)LBGetVariableHeightItemHeight(plb, (INT)item);
    }

    if (!height || height > 255) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"height\" (%ld) to LBGetSetItemHeightHandler",
                height);

        return LB_ERR;
    }

    if (plb->OwnerDraw != OWNERDRAWVAR)
        plb->cyChar = height;
    else {
        if (item < 0 || item >= plb->cMac) {
            RIPERR1(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "Invalid parameter \"item\" (%ld) to LBGetSetItemHeightHandler",
                    item);

            return LB_ERR;
        }

        LBSetVariableHeightItemHeight(plb, (INT)item, (INT)height);
    }

    if (plb->fMultiColumn)
        LBCalcItemRowsAndColumns(plb);

    LBSetCItemFullMax(plb);

    return(0);
}

/*****************************************************************************\
*
* LBEvent()
*
* This is for item focus & selection events in listboxes.
*
\*****************************************************************************/
void LBEvent(PLBIV plb, UINT uEvent, int iItem)
{
    switch (uEvent) {
        case EVENT_OBJECT_SELECTIONREMOVE:
            if (plb->wMultiple != SINGLESEL) {
                break;
            }
            iItem = -1;
            //
            // FALL THRU
            //

        case EVENT_OBJECT_SELECTIONADD:
            if (plb->wMultiple == MULTIPLESEL) {
                uEvent = EVENT_OBJECT_SELECTION;
            }
            break;

        case EVENT_OBJECT_SELECTIONWITHIN:
            iItem = -1;
            break;
    }

    NotifyWinEvent(uEvent, HW(plb->spwnd), OBJID_CLIENT, iItem+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\lboxvar.c ===
/**************************** Module Header ********************************\
* Module Name: lboxvar.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* List Box variable height owner draw routines
*
* History:
* ??-???-???? ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code (None)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* LBGetVariableHeightItemHeight
*
* Returns the height of the given item number. Assumes variable
* height owner draw.
*
* History:
\***************************************************************************/

INT LBGetVariableHeightItemHeight(
    PLBIV plb,
    INT itemNumber)
{
    BYTE itemHeight;
    int offsetHeight;

    if (plb->cMac) {
        if (plb->fHasStrings)
            offsetHeight = plb->cMac * sizeof(LBItem);
        else
            offsetHeight = plb->cMac * sizeof(LBODItem);

        if (plb->wMultiple)
            offsetHeight += plb->cMac;

        offsetHeight += itemNumber;

        itemHeight = *(plb->rgpch+(UINT)offsetHeight);

        return (INT)itemHeight;

    }

    /*
     *Default, we return the height of the system font.  This is so we can draw
     * the focus rect even though there are no items in the listbox.
     */
    return gpsi->cySysFontChar;
}


/***************************************************************************\
* LBSetVariableHeightItemHeight
*
* Sets the height of the given item number. Assumes variable height
* owner draw, a valid item number and valid height.
*
*
* History:
\***************************************************************************/

void LBSetVariableHeightItemHeight(
    PLBIV plb,
    INT itemNumber,
    INT itemHeight)
{
    int offsetHeight;

    if (plb->fHasStrings)
        offsetHeight = plb->cMac * sizeof(LBItem);
    else
        offsetHeight = plb->cMac * sizeof(LBODItem);

    if (plb->wMultiple)
        offsetHeight += plb->cMac;

    offsetHeight += itemNumber;

    *(plb->rgpch + (UINT)offsetHeight) = (BYTE)itemHeight;

}


/***************************************************************************\
* CItemInWindowVarOwnerDraw
*
* Returns the number of items which can fit in a variable height OWNERDRAW
* list box. If fDirection, then we return the number of items which
* fit starting at sTop and going forward (for page down), otherwise, we are
* going backwards (for page up). (Assumes var height ownerdraw) If fPartial,
* then include the partially visible item at the bottom of the listbox.
*
* History:
\***************************************************************************/

INT CItemInWindowVarOwnerDraw(
    PLBIV plb,
    BOOL fPartial)
{
    RECT rect;
    INT sItem;
    INT clientbottom;

    _GetClientRect(plb->spwnd, (LPRECT)&rect);
    clientbottom = rect.bottom;

    /*
     * Find the number of var height ownerdraw items which are visible starting
     * from plb->iTop.
     */
    for (sItem = plb->iTop; sItem < plb->cMac; sItem++) {

        /*
         * Find out if the item is visible or not
         */
        if (!LBGetItemRect(plb, sItem, (LPRECT)&rect)) {

            /*
             * This is the first item which is completely invisible, so return
             * how many items are visible.
             */
            return (sItem - plb->iTop);
        }

        if (!fPartial && rect.bottom > clientbottom) {

            /*
             * If we only want fully visible items, then if this item is
             * visible, we check if the bottom of the item is below the client
             * rect, so we return how many are fully visible.
             */
            return (sItem - plb->iTop - 1);
        }
    }

    /*
     * All the items are visible
     */
    return (plb->cMac - plb->iTop);
}


/***************************************************************************\
* LBPage
*
* For variable height ownerdraw listboxes, calaculates the new iTop we must
* move to when paging (page up/down) through variable height listboxes.
*
* History:
\***************************************************************************/

INT LBPage(
    PLBIV plb,
    INT startItem,
    BOOL fPageForwardDirection)
{
    INT     i;
    INT height;
    RECT    rc;

    if (plb->cMac == 1)
        return(0);

    _GetClientRect(plb->spwnd, &rc);
    height = rc.bottom;
    i = startItem;

    if (fPageForwardDirection) {
        while ((height >= 0) && (i < plb->cMac))
            height -= LBGetVariableHeightItemHeight(plb, i++);

        return((height >= 0) ? plb->cMac - 1 : max(i - 2, startItem + 1));
    } else {
        while ((height >= 0) && (i >= 0))
            height -= LBGetVariableHeightItemHeight(plb, i--);

        return((height >= 0) ? 0 : min(i + 2, startItem - 1));
    }

}


/***************************************************************************\
* LBCalcVarITopScrollAmt
*
* Changing the top most item in the listbox from iTopOld to iTopNew we
* want to calculate the number of pixels to scroll so that we minimize the
* number of items we will redraw.
*
* History:
\***************************************************************************/

INT LBCalcVarITopScrollAmt(
    PLBIV plb,
    INT iTopOld,
    INT iTopNew)
{
    RECT rc;
    RECT rcClient;

    _GetClientRect(plb->spwnd, (LPRECT)&rcClient);

    /*
     * Just optimize redrawing when move +/- 1 item.  We will redraw all items
     * if moving more than 1 item ahead or back.  This is good enough for now.
     */
    if (iTopOld + 1 == iTopNew) {

        /*
         * We are scrolling the current iTop up off the top off the listbox so
         * return a negative number.
         */
        LBGetItemRect(plb, iTopOld, (LPRECT)&rc);
        return (rcClient.top - rc.bottom);
    }

    if (iTopOld - 1 == iTopNew) {

        /*
         * We are scrolling the current iTop down and the previous item is
         * becoming the new iTop so return a positive number.
         */
        LBGetItemRect(plb, iTopNew, (LPRECT)&rc);
        return -rc.top;
    }

    return rcClient.bottom - rcClient.top;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\makefile.inc ===
$(DYNLINK_LIB) : $(DYNLINK_LIBP)

$(O)\$(TARGETNAME).def: ..\$(TARGETNAME).def
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\dispcb.c: ..\dispcb.tpl ..\..\inc\$(ALT_PROJECT)\$(O)\cb.lst
    listmung ..\..\inc\$(ALT_PROJECT)\$(O)\cb.lst ..\dispcb.tpl >$@

$(O)\strid.rc $(O)\strid.h $(O)\msg00001.bin: ..\strid.mc
    mc -v -U -r $(O) -h $(O) ..\strid.mc

..\csenda.c: ..\ntcftxt.h
..\csendw.c: ..\ntcftxt.h
..\crecv.c:  ..\..\inc\ntcb.h ..\..\inc\$(ALT_PROJECT)\$(O)\cb.lst ..\..\inc\messages.h
..\clmsg.c: ..\..\inc\messages.h
..\clienta.c: ..\cltxt.h
..\clientw.c: ..\cltxt.h
..\csrstubs.c: ..\..\inc\csrmsg.h
..\ntstubs.c: ..\..\inc\messages.h
..\precomp.h: ..\usercli.h ..\..\inc\user.h ..\..\inc\ntuser.h $(WINDOWS_INC_PATH)\winuserp.h \
              ..\..\inc\$(ALT_PROJECT)\$(O)\cscall.h $(WINCORE_PATH)\w32inc\winuserk.h
..\res.rc: ..\rcscale\truetype.bmp  \
           ..\rc96dpi\truetype.bmp  \
           ..\rc120dpi\truetype.bmp  \
           ..\cursicon\windows.ico  \
           ..\cursicon\warning.ico  \
           ..\cursicon\question.ico  \
           ..\cursicon\error.ico  \
           ..\cursicon\info.ico  \
           ..\cursicon\app.ico  \
           ..\cursicon\help.bmp  \
           ..\cursicon\arrow.cur  \
           ..\cursicon\ibeam.cur  \
           ..\cursicon\wait.cur  \
           ..\cursicon\cross.cur \
           ..\cursicon\uparrow.cur  \
           ..\cursicon\sizenwse.cur  \
           ..\cursicon\sizenesw.cur  \
           ..\cursicon\sizewe.cur  \
           ..\cursicon\sizens.cur  \
           ..\cursicon\sizeall.cur  \
           ..\cursicon\nodrop.cur  \
           ..\cursicon\appstart.cur  \
           ..\cursicon\help.cur  \
           ..\cursicon\nwpen.cur  \
           $(O)\strid.rc  \
           ..\cursicon\autorun.cur \
           ..\cursicon\icon.cur



$(DYNLINK_LIBP) $(DYNLINK_LIBP:.lib=.exp): $(O)\$(TARGETNAMEP).def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(DYNLINK_LIBP) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\$(TARGETNAMEP).def
$(LIBRARY_OBJS)
<<NOKEEP

!IF "$(PRECOMPILED_INCLUDE)" != ""
$(O)\clienta.obj $(O)\csenda.obj :
    nmake PRECOMPILED_INCLUDE= $(O)\$(@F)
!ENDIF

C_DEFINES=$(C_DEFINES) -DPRIVATE=
$(O)\$(TARGETNAMEP).def: $(O)\$(TARGETNAME).def
    $(C_PREPROCESSOR) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\mmcl.c ===
/****************************** Module Header ******************************\
* Module Name: mmcl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
* 
* Multimonitor APIs in the client.
* 
* History:
* 29-Mar-1997 adams     Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

HMONITOR
MonitorFromPoint(
    IN POINT pt,
    IN DWORD dwFlags)
{
    PMONITOR    pMonitor;

    if (dwFlags > MONITOR_DEFAULTTONEAREST) {
        RIPERR1(ERROR_INVALID_FLAGS,
                RIP_WARNING,
                "Invalid flags to MonitorFromPoint, %x", dwFlags);

        return NULL;
    }

    pMonitor = _MonitorFromPoint(pt, dwFlags);

    try {
        return PtoH(pMonitor);
    } except(W32ExceptionHandler(TRUE, RIP_WARNING)) {
        return NULL;
    }
}



HMONITOR
MonitorFromRect(
    IN LPCRECT lprc,
    IN DWORD dwFlags)
{
    PMONITOR    pMonitor;

    if (dwFlags > MONITOR_DEFAULTTONEAREST) {
        RIPERR1(ERROR_INVALID_FLAGS,
                RIP_WARNING,
                "Invalid flags to MonitorFromRect, %x", dwFlags);

        return NULL;
    }

    pMonitor = _MonitorFromRect(lprc, dwFlags);

    try {
        return PtoH(pMonitor);
    } except(W32ExceptionHandler(TRUE, RIP_WARNING)) {
        return NULL;
    }
}



HMONITOR
MonitorFromWindow(
    IN HWND hwnd,
    IN DWORD dwFlags)
{
    PMONITOR    pMonitor;
    PWND        pwnd;

    if (dwFlags > MONITOR_DEFAULTTONEAREST) {
        RIPERR1(ERROR_INVALID_FLAGS,
                RIP_WARNING,
                "Invalid flags to MonitorFromWindow, %x", dwFlags);

        return NULL;
    }

    if (hwnd) {
        pwnd = ValidateHwnd(hwnd);
        if (!pwnd) {
            return NULL;
        }
    } else {
        pwnd = NULL;
    }

    pMonitor = _MonitorFromWindow(pwnd, dwFlags);

    try {
        return PtoH(pMonitor);
    } except(W32ExceptionHandler(TRUE, RIP_WARNING)) {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\menuc.c ===
/****************************** Module Header ******************************\
* Module Name: menuc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains
*
* History:
* 01-11-93  DavidPe     Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


FUNCLOG3(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, CheckMenuItem, HMENU, hMenu, UINT, uIDCheckItem, UINT, uCheck)
DWORD CheckMenuItem(
    HMENU hMenu,
    UINT uIDCheckItem,
    UINT uCheck)
{
    PMENU pMenu;
    PITEM pItem;

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return (DWORD)-1;
    }

    /*
     * Get a pointer the the menu item
     */
    if ((pItem = MNLookUpItem(pMenu, uIDCheckItem, (BOOL) (uCheck & MF_BYPOSITION), NULL)) == NULL)
        return (DWORD)-1;

    /*
     * If the item is already in the state we're
     * trying to set, just return.
     */
    if ((pItem->fState & MFS_CHECKED) == (uCheck & MFS_CHECKED)) {
        return pItem->fState & MF_CHECKED;
    }

    return NtUserCheckMenuItem(hMenu, uIDCheckItem, uCheck);
}


FUNCLOG3(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, GetMenuDefaultItem, HMENU, hMenu, UINT, fByPosition, UINT, uFlags)
UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPosition, UINT uFlags)
{
    PMENU pMenu;

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return (DWORD)-1;
    }

    return _GetMenuDefaultItem(pMenu, (BOOL)fByPosition, uFlags);
}

/***************************************************************************\
* SetMenuItemInfoStruct
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
void SetMenuItemInfoStruct(HMENU hMenu, UINT wFlags, UINT_PTR wIDNew, LPWSTR pwszNew, LPMENUITEMINFO pmii)
{
    PMENU pMenu;
    PITEM pItem;

    UserAssert(sizeof(MENUITEMINFOW) == sizeof(MENUITEMINFOA));

    RtlZeroMemory(pmii, sizeof(*pmii));

    pmii->fMask = MIIM_STATE | MIIM_ID | MIIM_FTYPE;

    /*
     * For compatibility, setting the bitmap drops the string and
     *  viceversa; new apps that want to have sting and bitmaps
     *  must use the MENUITEMINFO APIs
     */
    if (wFlags & MFT_BITMAP) {
        pmii->fMask |= MIIM_BITMAP | MIIM_STRING;
        pmii->hbmpItem = (HBITMAP)pwszNew;
        pmii->dwTypeData  = 0;
    } else if (!(wFlags & MFT_NONSTRING)) {
        pmii->fMask |= MIIM_BITMAP | MIIM_STRING;
        pmii->dwTypeData  = pwszNew;
        pmii->hbmpItem = NULL;
    }

    if (wFlags & MF_POPUP) {
        pmii->fMask |= MIIM_SUBMENU;
        pmii->hSubMenu = (HMENU)wIDNew;
    }

    if (wFlags & MF_OWNERDRAW) {
        pmii->fMask |= MIIM_DATA;
        pmii->dwItemData = (ULONG_PTR) pwszNew;
    }

    pmii->fState = wFlags & MFS_OLDAPI_MASK;
    pmii->fType  = wFlags & MFT_OLDAPI_MASK;
    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu && pMenu->cItems) {
        pItem = &((PITEM)REBASEALWAYS(pMenu, rgItems))[0];
        if (pItem && TestMFT(pItem, MFT_RIGHTORDER)) {
            pmii->fType |= MFT_RIGHTORDER;
        }
    }
    pmii->wID    = (UINT)wIDNew;
}
/***************************************************************************\
* SetMenuItemInfo
*
* History:
*  07-22-96 GerardoB - Added header
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetMenuInfo, HMENU, hMenu, LPCMENUINFO, lpmi)
BOOL SetMenuInfo(HMENU hMenu, LPCMENUINFO lpmi)
{
    if (!ValidateMENUINFO(lpmi, MENUAPI_SET)) {
        return FALSE;
    }

    return NtUserThunkedMenuInfo(hMenu, (LPCMENUINFO)lpmi);
}
/***************************************************************************\
* ChangeMenu
*
* Stub routine for compatibility with version < 3.0
*
* History:
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ChangeMenuW, HMENU, hMenu, UINT, cmd, LPCWSTR, lpNewItem, UINT, IdItem, UINT, flags)
BOOL ChangeMenuW(
    HMENU hMenu,
    UINT cmd,
    LPCWSTR lpNewItem,
    UINT IdItem,
    UINT flags)
{
    /*
     * These next two statements take care of sleazyness needed for
     * compatability with old changemenu.
     */
    if ((flags & MF_SEPARATOR) && cmd == MFMWFP_OFFMENU && !(flags & MF_CHANGE))
        flags |= MF_APPEND;

    if (lpNewItem == NULL)
        flags |= MF_SEPARATOR;



    /*
     * MUST be MF_BYPOSITION for Win2.x compatability.
     */
    if (flags & MF_REMOVE)
        return(NtUserRemoveMenu(hMenu, cmd,
                (DWORD)((flags & ~MF_REMOVE) | MF_BYPOSITION)));

    if (flags & MF_DELETE)
        return(NtUserDeleteMenu(hMenu, cmd, (DWORD)(flags & ~MF_DELETE)));

    if (flags & MF_CHANGE)
        return(ModifyMenuW(hMenu, cmd, (DWORD)((flags & ~MF_CHANGE) &
                (0x07F | MF_HELP | MF_BYPOSITION | MF_BYCOMMAND |
                MF_SEPARATOR)), IdItem, lpNewItem));

    if (flags & MF_APPEND)
        return(AppendMenuW(hMenu, (UINT)(flags & ~MF_APPEND),
            IdItem, lpNewItem));

    /*
     * Default is insert
     */
    return(InsertMenuW(hMenu, cmd, (DWORD)(flags & ~MF_INSERT),
            IdItem, lpNewItem));
}


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ChangeMenuA, HMENU, hMenu, UINT, cmd, LPCSTR, lpNewItem, UINT, IdItem, UINT, flags)
BOOL ChangeMenuA(
    HMENU hMenu,
    UINT cmd,
    LPCSTR lpNewItem,
    UINT IdItem,
    UINT flags)
{
    /*
     * These next two statements take care of sleazyness needed for
     * compatability with old changemenu.
     */
    if ((flags & MF_SEPARATOR) && cmd == MFMWFP_OFFMENU && !(flags & MF_CHANGE))
        flags |= MF_APPEND;

    if (lpNewItem == NULL)
        flags |= MF_SEPARATOR;



    /*
     * MUST be MF_BYPOSITION for Win2.x compatability.
     */
    if (flags & MF_REMOVE)
        return(NtUserRemoveMenu(hMenu, cmd,
                (DWORD)((flags & ~MF_REMOVE) | MF_BYPOSITION)));

    if (flags & MF_DELETE)
        return(NtUserDeleteMenu(hMenu, cmd, (DWORD)(flags & ~MF_DELETE)));

    if (flags & MF_CHANGE)
        return(ModifyMenuA(hMenu, cmd, (DWORD)((flags & ~MF_CHANGE) &
                (0x07F | MF_HELP | MF_BYPOSITION | MF_BYCOMMAND |
                MF_SEPARATOR)), IdItem, lpNewItem));

    if (flags & MF_APPEND)
        return(AppendMenuA(hMenu, (UINT)(flags & ~MF_APPEND),
            IdItem, lpNewItem));

    /*
     * Default is insert
     */
    return(InsertMenuA(hMenu, cmd, (DWORD)(flags & ~MF_INSERT),
            IdItem, lpNewItem));
}

LONG GetMenuCheckMarkDimensions()
{
    return((DWORD)MAKELONG(SYSMET(CXMENUCHECK), SYSMET(CYMENUCHECK)));
}

/***************************************************************************\
* GetMenuContextHelpId
*
* Return the help id of a menu.
*
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, WINUSERAPI DWORD, WINAPI, GetMenuContextHelpId, HMENU, hMenu)
WINUSERAPI DWORD WINAPI GetMenuContextHelpId(
    HMENU hMenu)
{
    PMENU pMenu;

    pMenu = VALIDATEHMENU(hMenu);

    if (pMenu == NULL)
        return 0;

    return pMenu->dwContextHelpId;
}

BOOL TrackPopupMenu(
    HMENU hMenu,
    UINT fuFlags,
    int x,
    int y,
    int nReserved,
    HWND hwnd,
    CONST RECT *prcRect)
{
    UNREFERENCED_PARAMETER(nReserved);
    UNREFERENCED_PARAMETER(prcRect);

    return NtUserTrackPopupMenuEx(hMenu, fuFlags, x, y, hwnd, NULL);
}

/***************************************************************************\
* GetSysMenuHandle
*
* Returns a handle to the system menu of the given window. NULL if
* the window doesn't have a system menu.
*
* History:
\***************************************************************************/

PMENU xxxGetSysMenuHandle(
    PWND pwnd)
{
    PMENU pMenu;

    if (TestWF(pwnd, WFSYSMENU)) {
        pMenu = pwnd->spmenuSys;

        /*
         * If the window doesn't have a System Menu, use the default one.
         */
        if (pMenu == NULL) {

            /*
             * Change owner so this app can access this menu.
             */
            pMenu = (PMENU)NtUserCallHwndLock(HWq(pwnd), SFI_XXXGETSYSMENUHANDLE);
        }
    } else {
        pMenu = NULL;
    }

    return pMenu;
}

BOOL WINAPI SetMenuItemBitmaps
(
    HMENU hMenu,
    UINT nPosition,
    UINT uFlags,
    HBITMAP hbmpUnchecked,
    HBITMAP hbmpChecked
)
{
    MENUITEMINFO    mii;
    mii.cbSize          = sizeof(MENUITEMINFO);
    mii.fMask           = MIIM_CHECKMARKS;
    mii.hbmpChecked     = hbmpChecked;
    mii.hbmpUnchecked   = hbmpUnchecked;

    return(SetMenuItemInfo(hMenu, nPosition, (BOOL) (uFlags & MF_BYPOSITION), &mii));
}


FUNCLOG5(LOG_GENERAL, int, WINAPI, DrawMenuBarTemp, HWND, hwnd, HDC, hdc, LPCRECT, lprc, HMENU, hMenu, HFONT, hFont)
int WINAPI DrawMenuBarTemp(
    HWND hwnd,
    HDC hdc,
    LPCRECT lprc,
    HMENU hMenu,
    HFONT hFont)
{
    HDC hdcr;

    if (IsMetaFile(hdc))
        return -1;

    hdcr = GdiConvertAndCheckDC(hdc);
    if (hdcr == (HDC)0)
        return -1;

    if (!hMenu)
        return -1;

    return NtUserDrawMenuBarTemp(
            hwnd,
            hdc,
            lprc,
            hMenu,
            hFont);
}

/***************************************************************************\
*
*  CheckMenuRadioItem() -
*
*  Checks one menu item in a range, unchecking the others.  This can be
*  done either MF_BYCOMMAND or MF_BYPOSITION.  It works similarly to
*  CheckRadioButton().
*
*  The return value is TRUE if the given item was checked, FALSE if not.
*
* History
* 04/04/97 GerardoB     Moved to the client side
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CheckMenuRadioItem, HMENU, hMenu, UINT, wIDFirst, UINT, wIDLast, UINT, wIDCheck, UINT, flags)
BOOL CheckMenuRadioItem(HMENU hMenu, UINT wIDFirst, UINT wIDLast,
        UINT wIDCheck, UINT flags)
{
    BOOL    fByPosition = (BOOL) (flags & MF_BYPOSITION);
    PMENU   pMenu, pMenuItemIsOn;
    PITEM   pItem;
    UINT    wIDCur;
    BOOL    fChecked = FALSE;
    BOOL    fFirst  = TRUE;
    MENUITEMINFO mii;

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return FALSE;
    }

    mii.cbSize = sizeof(mii);
    /*
     * Make sure we won't loop for ever
     */
    wIDLast = min(wIDLast, (UINT)0xFFFFFFFE);

    for (wIDCur = wIDFirst; wIDCur <= wIDLast; wIDCur++) {
        pItem = MNLookUpItem(pMenu, wIDCur, fByPosition, &pMenuItemIsOn);
        /*
         * Continue searching if it didn't find the item or it's a separator
         */
        if ((pItem == NULL) || TestMFT(pItem, MFT_SEPARATOR)) {
            continue;
        }
        /*
         * If this is the first one, rememeber what menu it's on because
         *  all items are supposed to be in the same menu.
         */
        if (fFirst) {
            pMenu = pMenuItemIsOn;
            hMenu = PtoHq(pMenu);
            fFirst = FALSE;
        }
        /*
         * If this item is on a different menu, don't touch it
         */
        if (pMenu != pMenuItemIsOn) {
            continue;
        }
        /*
         * Set the new check state. Avoid the trip to the kernel if possible
         */
        if (wIDCur == wIDCheck) {
            /*
             * Check it.
             */
            if (!TestMFT(pItem, MFT_RADIOCHECK) || !TestMFS(pItem, MFS_CHECKED)) {
                mii.fMask = MIIM_FTYPE | MIIM_STATE;
                mii.fType = (pItem->fType & MFT_MASK) | MFT_RADIOCHECK;
                mii.fState = (pItem->fState & MFS_MASK) | MFS_CHECKED;
                NtUserThunkedMenuItemInfo(hMenu, wIDCheck, fByPosition, FALSE, &mii, NULL);
            }
            fChecked = TRUE;
        } else {
            /*
             * Uncheck it
             * NOTE:  don't remove MFT_RADIOCHECK type
             */
            if (TestMFS(pItem, MFS_CHECKED)) {
                mii.fMask = MIIM_STATE;
                mii.fState = (pItem->fState & MFS_MASK) & ~MFS_CHECKED;
                NtUserThunkedMenuItemInfo(hMenu, wIDCur, fByPosition, FALSE, &mii, NULL);
            }
        }
    } /* for */

    if (fFirst) {
        /*
         * No item was ever found.
         */
        RIPERR0(ERROR_MENU_ITEM_NOT_FOUND, RIP_VERBOSE, "CheckMenuRadioItem, no items found\n");

    }
    return(fChecked);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\mdimenu.c ===
//depot/Lab06_N/Windows/Core/ntuser/client/mdimenu.c#1 - branch change 13 (text)
/***************************************************************************\
*
*  MDIMENU.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      MDI "Window" Menu Support
*
* History
* 11-14-90 MikeHar     Ported from windows
* 14-Feb-1991 mikeke   Added Revalidation code
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* FindPwndChild
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

PWND FindPwndChild(
    PWND pwndMDI,
    UINT wChildID)
{
    PWND pwndT;

    for (pwndT = REBASEPWND(pwndMDI, spwndChild);
            pwndT && (pwndT->spwndOwner || PtrToUlong(pwndT->spmenu) != wChildID);
            pwndT = REBASEPWND(pwndT, spwndNext))
        ;

    return pwndT;
}


/***************************************************************************\
* MakeMenuItem
*
* History:
* 11-14-90 MikeHar Ported from windows
*  4-16-91 Win31 Merge
\***************************************************************************/

int MakeMenuItem(
    LPWSTR lpOut,
    PWND pwnd)
{
    PMDI pmdi;
    DWORD rgParm;
    int cch = 0;
    WCHAR string[160];
    LPWSTR lpstr;
    int i = 0;
    int max = sizeof(string) / sizeof(WCHAR) - 1;

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)(REBASEPWND(pwnd, spwndParent)))->pmdi;

    *lpOut = 0;

    rgParm = PtrToUlong(pwnd->spmenu) - (DWORD)FIRST(pmdi) + 1;

    if (pwnd->strName.Length) {
        lpstr = REBASEALWAYS(pwnd, strName.Buffer);

        /*
         * Search for an & in the title string and duplicate it so that we don't
         * get bogus accelerators.
         */
        while (*lpstr && i < max) {
            string[i] = *lpstr;
            i++;
            if (*lpstr == TEXT('&')) {
                if (i == max) {
                    /*
                     * We're at the end of the string and we need to double this
                     * ampersand. If we do that, we're going to overflow the
                     * buffer below when we NULL-terminate it. We also don't
                     * want to leave a single ampersand - as it'll be mistakenl
                     * used as an accelerator - so move back one character so
                     * that when we NULL-terminate we'll be wiping out the
                     * original ampersand. Bug #35673.
                     */
                    --i;
                    break;
                }
                string[i++] = TEXT('&');
            }

            lpstr++;
        }

        string[i] = 0;
        cch = wsprintfW(lpOut, L"&%d %ws", rgParm, string);

    } else {

        /*
         * Handle the case of MDI children without any window title text.
         */
        cch = wsprintfW(lpOut, L"&%d ", rgParm);
    }

    return cch;
}

/***************************************************************************\
* ModifyMenuItem
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

void ModifyMenuItem(
    PWND pwnd)
{
    PMDI pmdi;
    WCHAR sz[200];
    MENUITEMINFO    mii;
    PWND pwndParent;
    PMENU pmenu;

    /*
     * Get a pointer to the MDI structure
     */
    pwndParent = REBASEPWND(pwnd, spwndParent);
    pmdi = ((PMDIWND)pwndParent)->pmdi;

    if (PtrToUlong(pwnd->spmenu) > FIRST(pmdi) + (UINT)8)
        return;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_STRING;
    mii.dwTypeData = sz;

    /*
     * Parent is MDI Client.
     */
    MakeMenuItem(sz, pwnd);

    /*
     * Changing the active child?  Check it.
     */
    if (HWq(pwnd) == ACTIVE(pmdi)) {
        mii.fMask |= MIIM_STATE;
        mii.fState = MFS_CHECKED;
    }

    pwndParent = REBASEPWND(pwndParent, spwndParent);

    if (pwndParent->spmenu) {

        /*
         * Bug# 21566. If spmenu is NULL we used to fail
         * because REBASEALWAYS is trying to get the kernel
         * address of NULL based on pwndParent
         */
        pmenu = REBASEALWAYS(pwndParent, spmenu);
        /*
         * Internal call to SetMenuItemInfo
         */
        ThunkedMenuItemInfo(PtoH(pmenu), PtrToUlong(pwnd->spmenu), FALSE, FALSE, &mii, FALSE);
    }
}

/***************************************************************************\
* MDIAddSysMenu
*
* Insert the MDI child's system menu onto the existing Menu.
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

BOOL MDIAddSysMenu(
    HMENU hMenuFrame,
    HWND hwndChild)
{
    PWND pwndChild;
    MENUITEMINFO    mii;
    PMENU pMenuChild;


// LATER -- look at passing pwndChild in -- FritzS

    UserAssert(IsWindow(hwndChild));
    pwndChild = ValidateHwnd(hwndChild);
    if (!hMenuFrame || !pwndChild || !pwndChild->spmenuSys) {
        return FALSE;
    }

    /*
     * We don't need the pMenuChild pointer but the handle. However, if you
     * do PtoH(_GetSubMenu()), you end up calling the function twice
     */
    pMenuChild = _GetSubMenu (REBASEALWAYS(pwndChild, spmenuSys), 0);
    if (!pMenuChild) {
        return FALSE;
    }

// Add MDI system button as first menu item
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_SUBMENU | MIIM_DATA | MIIM_BITMAP;  // Add MIIM_DATA because of hack described below
    mii.hSubMenu = PtoH(pMenuChild);
// Fritzs -- this won't work.
//    mii.dwTypeData = (LPSTR) MAKELONG(MENUHBM_SYSTEM, GetWindowSmIcon(hwndChild));
    mii.hbmpItem = HBMMENU_SYSTEM;
// FritzS -- so, we sneak the icon into ItemData
    mii.dwItemData = (ULONG_PTR)hwndChild;

    if (!InternalInsertMenuItem(hMenuFrame, 0, TRUE, &mii))
        return FALSE;

    // TimeLine 6.1 gets confused by the extra Min/Close buttons,
    // don't add them if WFOLDUI

    mii.fMask = MIIM_ID | MIIM_FTYPE | MIIM_BITMAP;
    mii.fType = MFT_RIGHTJUSTIFY;

    pwndChild = ValidateHwnd(hwndChild);
    if (!pwndChild) {
        NtUserRemoveMenu(hMenuFrame, 0, MF_BYPOSITION);
        return FALSE;
    }


    if (!TestWF(pwndChild, WFOLDUI))
    {
        // Add Minimize button as last menu item
        mii.hbmpItem = (TestWF(pwndChild, WFMINBOX) ? HBMMENU_MBAR_MINIMIZE : HBMMENU_MBAR_MINIMIZE_D);
        mii.wID = SC_MINIMIZE;

        if (!InternalInsertMenuItem(hMenuFrame, MFMWFP_NOITEM, TRUE, &mii))
        {
            NtUserRemoveMenu(hMenuFrame, 0, MF_BYPOSITION);
            return FALSE;
        }
        mii.fType &= ~MFT_RIGHTJUSTIFY;
    }

    // Add Restore button as last menu item
    mii.hbmpItem = HBMMENU_MBAR_RESTORE;
    mii.wID = SC_RESTORE;

    if (!InternalInsertMenuItem(hMenuFrame, MFMWFP_NOITEM, TRUE, &mii)) {
        // BOGUS -- we gotta remove the MINIMIZE button too
        NtUserRemoveMenu(hMenuFrame, 0, MF_BYPOSITION);
        return FALSE;
    }

    pwndChild = ValidateHwnd(hwndChild);
    if (!pwndChild) {
        NtUserRemoveMenu(hMenuFrame, 0, MF_BYPOSITION);
        return FALSE;
    }

    if (!TestWF(pwndChild, WFOLDUI))
    {
        // Add Close button as last menu item
        mii.hbmpItem = (xxxMNCanClose(pwndChild) ? HBMMENU_MBAR_CLOSE : HBMMENU_MBAR_CLOSE_D);
        mii.wID = SC_CLOSE;

        if (!InternalInsertMenuItem(hMenuFrame, MFMWFP_NOITEM, TRUE, &mii))
        {
            // BOGUS -- we gotta remove the MINIMIZE and RESTORE buttons too
            NtUserRemoveMenu(hMenuFrame, 0, MF_BYPOSITION);
            return FALSE;
        }
    }

    /*
     * Set the menu items to proper state since we just maximized it.  Note
     * setsysmenu doesn't work if we've cleared the sysmenu bit so do it now...
     */
    NtUserSetSysMenu(hwndChild);

    /*
     * This is so that if the user brings up the child sysmenu, it's sure
     * to be that in the frame menu bar...
     */
    ClearWindowState(pwndChild, WFSYSMENU);

    /*
     * Make sure that the child's frame is redrawn to reflect the removed
     * system menu.
     */
    MDIRedrawFrame(hwndChild, TRUE);

    return TRUE;
}

/***************************************************************************\
* MDIRemoveSysMenu
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

BOOL MDIRemoveSysMenu(
    HMENU hMenuFrame,
    HWND hwndChild)
{
    int iLastItem;
    UINT    iLastCmd;
    PWND pwndChild;

// LATER -- look at passing pwndChild in -- FritzS

    if (hMenuFrame == NULL)
        return FALSE;

    pwndChild = ValidateHwnd(hwndChild);

    if (pwndChild == NULL)
        return FALSE;

    iLastItem = GetMenuItemCount(hMenuFrame) - 1;
    iLastCmd = TestWF(pwndChild, WFOLDUI) ? SC_RESTORE : SC_CLOSE;

    if ((UINT) GetMenuItemID(hMenuFrame, iLastItem) != iLastCmd)
        return FALSE;

    /*
     * Enable the sysmenu in the child window.
     */
    SetWindowState(pwndChild, WFSYSMENU);

    /*
     * Take the child sysmenu popup out of the frame menu.
     */
    NtUserRemoveMenu(hMenuFrame, 0, MF_BYPOSITION);

    /*
     * Delete the restore button from the menu bar.
     */
    NtUserDeleteMenu(hMenuFrame, iLastItem - 1, MF_BYPOSITION);

    pwndChild = ValidateHwnd(hwndChild);
    if (pwndChild == NULL)
        return FALSE;

    if (!TestWF(pwndChild, WFOLDUI)) {
        NtUserDeleteMenu(hMenuFrame, iLastItem - 2, MF_BYPOSITION);
        NtUserDeleteMenu(hMenuFrame, iLastItem - 3, MF_BYPOSITION);
    }

    /*
     * Make sure that the child's frame is redrawn to reflect the added
     * system menu.
     */
    MDIRedrawFrame(hwndChild, FALSE);

    return TRUE;
}

/***************************************************************************\
* AppendToWindowsMenu
*
* Add the title of the MDI child window 'hwndChild' to the bottom of the
* "Window" menu (or add the "More Windows ..." item) if there's room.
*
*   MDI Child #                    Add
*  -------------          --------------------
*   < MAXITEMS             Child # and Title
*   = MAXITEMS             "More Windows ..."
*   > MAXITEMS             nothing
*
* History:
* 17-Mar-1992 mikeke   from win31
\***************************************************************************/

BOOL FAR PASCAL AppendToWindowsMenu(
    PWND pwndMDI,
    PWND pwndChild)
{
    PMDI pmdi;
    WCHAR szMenuItem[165];
    int item;
    MENUITEMINFO    mii;

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;

    item = PtrToUlong(pwndChild->spmenu) - FIRST(pmdi);

    if (WINDOW(pmdi) && (item < MAXITEMS)) {
        mii.cbSize = sizeof(MENUITEMINFO);
        if (!item) {

            /*
             * Add separator before first item
             */
            mii.fMask = MIIM_FTYPE;
            mii.fType = MFT_SEPARATOR;
            if (!InternalInsertMenuItem(WINDOW(pmdi), MFMWFP_NOITEM, TRUE, &mii))
                return FALSE;
        }

        if (item == (MAXITEMS - 1))
            LoadString(hmodUser, STR_MOREWINDOWS, szMenuItem,
                       sizeof(szMenuItem) / sizeof(WCHAR));
        else
            MakeMenuItem(szMenuItem, pwndChild);

        mii.fMask = MIIM_ID | MIIM_STRING;
        mii.wID = PtrToUlong(pwndChild->spmenu);
        mii.dwTypeData = szMenuItem;
        mii.cch = (UINT)-1;
        if (!InternalInsertMenuItem(WINDOW(pmdi), MFMWFP_NOITEM, TRUE, &mii))
            return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* SwitchWindowsMenus
*
* Switch the "Window" menu in the frame menu bar 'hMenu' from
* 'hOldWindow' to 'hNewWindow'
*
* History:
* 17-Mar-1992 mikeke    from win31
\***************************************************************************/

BOOL SwitchWindowsMenus(
    HMENU hmenu,
    HMENU hOldWindow,
    HMENU hNewWindow)
{
    int i;
    HMENU hsubMenu;
    WCHAR szMenuName[128];
    MENUITEMINFO    mii;

    if (hOldWindow == hNewWindow)
        return TRUE;

    mii.cbSize = sizeof(MENUITEMINFO);

    /*
     * Determine position of old "Window" menu
     */
    for (i = 0; hsubMenu = GetSubMenu(hmenu, i); i++) {
        if (hsubMenu == hOldWindow)
        {
            // Extract the name of the old menu to use it for the new menu
            mii.fMask = MIIM_STRING;
            mii.dwTypeData = szMenuName;
            mii.cch = sizeof(szMenuName)/sizeof(WCHAR);
            GetMenuItemInfoInternalW(hmenu, i, TRUE, &mii);
            // Out with the old, in with the new
            if (!NtUserRemoveMenu(hmenu, i, MF_BYPOSITION))
                return(FALSE);

            mii.fMask |= MIIM_SUBMENU;
            mii.hSubMenu = hNewWindow;
            return(InternalInsertMenuItem(hmenu, i, TRUE, &mii));
        }
    }

    return(FALSE);
}

/***************************************************************************\
* ShiftMenuIDs
*
* Shift the id's of the MDI child windows of the MDI client window 'hWnd'
* down by 1 (id--) starting with the child window 'hwndVictim' -- moving
* 'hwndVictim' to the end of the list
*
* History:
* 17-Mar-1992 mikeke   from win31
\***************************************************************************/

void ShiftMenuIDs(
    PWND pwnd,
    PWND pwndVictim)
{
    PMDI pmdi;
    PWND pwndChild;
    PWND pwndParent;
    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwnd)->pmdi;

    pwndParent = REBASEPWND(pwndVictim, spwndParent);
    pwndChild = REBASEPWND(pwndParent, spwndChild);

    while (pwndChild) {
        if (!pwndChild->spwndOwner && (pwndChild->spmenu > pwndVictim->spmenu)) {
            SetWindowLongPtr(HWq(pwndChild), GWLP_ID, PtrToUlong(pwndChild->spmenu) - 1);
        }
        pwndChild = REBASEPWND(pwndChild, spwndNext);
    }

    SetWindowLongPtr(HWq(pwndVictim), GWLP_ID, FIRST(pmdi) + CKIDS(pmdi) - 1);
}

/***************************************************************************\
* MDISetMenu
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

HMENU MDISetMenu(
    PWND pwndMDI,
    BOOL fRefresh,
    HMENU hNewSys,
    HMENU hNewWindow)
{
    int i;
    int iFirst;
    int item;
    PMDI pmdi;
    PWND pwndParent;
    HMENU hOldSys;
    HMENU hOldWindow;
    PWND pwndChild;

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;

    /*
     * Save the old values
     */
    pwndParent = REBASEPWND(pwndMDI, spwndParent);
    hOldSys = GetMenu(HW(pwndParent));
    hOldWindow = WINDOW(pmdi);

    if (fRefresh) {
        hNewSys = hOldSys;
        hNewWindow = hOldWindow;
    }

    /*
     * Change the Frame Menu.
     */
    if (hNewSys && (hNewSys != hOldSys)) {
        if (MAXED(pmdi))
            MDIRemoveSysMenu(hOldSys, MAXED(pmdi));

        NtUserSetMenu(HW(pwndParent), hNewSys, FALSE);

        if (MAXED(pmdi))
            MDIAddSysMenu(hNewSys, MAXED(pmdi));
    } else
        hNewSys = hOldSys;

    /*
     * Now update the Window menu.
     */
    if (fRefresh || (hOldWindow != hNewWindow)) {
        iFirst = FIRST(pmdi);

        if (hOldWindow) {
            int cItems = GetMenuItemCount(hOldWindow);

            for (i = cItems - 1; i >= 0; i--) {
                if (GetMenuState(hOldWindow, i, MF_BYPOSITION) & MF_SEPARATOR)
                   break;
            }
            if ((i >= 0) && (GetMenuItemID(hOldWindow, i + 1) == (UINT)iFirst)) {
                int idTrim = i;

                for (i = idTrim; i < cItems; i++)
                    NtUserDeleteMenu(hOldWindow, idTrim, MF_BYPOSITION);
            }
        }

        Lock(&WINDOW(pmdi), hNewWindow);

        if (hNewWindow != NULL) {

           /*
            * Add the list of child windows to the new window
            */
           for (i = 0, item = 0; ((UINT)i < CKIDS(pmdi)) && (item < MAXITEMS);
                    i++) {
               pwndChild = FindPwndChild(pwndMDI, iFirst + item);
               if (pwndChild != NULL) {
                   if ((!TestWF(pwndChild, WFVISIBLE) &&
                          (LOWORD(pwndMDI->style) & 0x0001)) ||
                          TestWF(pwndChild, WFDISABLED)) {
                       ShiftMenuIDs(pwndMDI, pwndChild);
                   } else {
                       AppendToWindowsMenu(pwndMDI, pwndChild);
                       item++;
                   }
               }
           }

           /*
            * Add checkmark by the active child's menu item
            */
           if (ACTIVE(pmdi))
               CheckMenuItem(hNewWindow, (WORD)GetWindowID(ACTIVE(pmdi)),
                       MF_BYCOMMAND | MF_CHECKED);
        }

        /*
         * Out with the old, in with the new
         */
        SwitchWindowsMenus(hNewSys, hOldWindow, hNewWindow);
    }
    return hOldSys;
}

/***************************************************************************\
* xxxInitActivateDlg
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

void xxxInitActivateDlg(
    HWND hwnd,
    PWND pwndMDI)
{
    PMDI pmdi;
    UINT wKid;
    HWND hwndT;
    PWND pwndT;
    WCHAR szTitle[CCHTITLEMAX];
    TL tlpwndT;
    SIZE Size;
    HDC hDC;
    DWORD width = 0;

    CheckLock(pwndMDI);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;

    hDC = NtUserGetDC(hwnd);

    /*
     * Insert the list of titles.
     * Note the wKid-th item in the listbox has ID wKid+FIRST(pwnd), so that
     * the listbox is in creation order (like the menu).  This is also
     * helpful when we go to select one...
     */

    for (wKid = 0; wKid < CKIDS(pmdi); wKid++) {
        pwndT = FindPwndChild(pwndMDI, (UINT)(wKid + FIRST(pmdi)));

        if (pwndT && TestWF(pwndT, WFVISIBLE) && !TestWF(pwndT, WFDISABLED)) {
            ThreadLockAlways(pwndT, &tlpwndT);
            GetWindowText(HWq(pwndT), szTitle, CCHTITLEMAX);
            SendDlgItemMessage(hwnd, 100, LB_ADDSTRING, 0, (LPARAM)szTitle);
            GetTextExtentPoint(hDC, szTitle, lstrlen(szTitle), &Size);
            if (Size.cx > (LONG)width) {
                width = Size.cx;
            }
            ThreadUnlock(&tlpwndT);
        }
    }

    /*
     * Select the currently active window.
     */
    SendDlgItemMessage(hwnd, 100, LB_SETTOPINDEX, MAXITEMS - 1, 0L);
    SendDlgItemMessage(hwnd, 100, LB_SETCURSEL, MAXITEMS - 1, 0L);

    /*
     * Set the horizontal extent of the list box to the longest window title.
     */
    SendDlgItemMessage(hwnd, 100, LB_SETHORIZONTALEXTENT, width, 0L);
    NtUserReleaseDC(hwnd, hDC);

    /*
     * Set the focus to the listbox.
     */
    hwndT = GetDlgItem(hwnd, 100);
    NtUserSetFocus(hwndT);
}

/***************************************************************************\
* MDIActivateDlgSize
*
* The minimum allowed size and the previous one are saved as properties
* of the parent window.
*
* History:
* Oct 97 MCostea Created
\***************************************************************************/

VOID MDIActivateDlgSize(HWND hwnd, int width, int height)
{
    PMDIACTIVATEPOS pPos;
    PWND pwnd, pwndList, pwndButtonLeft, pwndButtonRight;
    HDWP hdwp;
    int  deltaX, deltaY;

    pPos = (PMDIACTIVATEPOS)GetProp(GetParent(hwnd), MAKEINTATOM(atomMDIActivateProp));
    if (pPos == NULL) {
        return;
    }

    /*
     * Retrieve the children
     */
    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return;
    }
    pwndList = REBASEPWND(pwnd, spwndChild);
    pwndButtonLeft  = REBASEPWND(pwndList, spwndNext);
    pwndButtonRight = REBASEPWND(pwndButtonLeft, spwndNext);

    UserAssert(GETFNID(pwndList) == FNID_LISTBOX);
    UserAssert(GETFNID(pwndButtonLeft) == FNID_BUTTON);
    UserAssert(GETFNID(pwndButtonRight) == FNID_BUTTON);
    UserAssert(pwndButtonRight->rcWindow.left > pwndButtonLeft->rcWindow.left);

    deltaX = width - pPos->cx;
    deltaY = height - pPos->cy;

    pPos->cx = width;
    pPos->cy = height;

    /*
     * Move/resize the child windows accordingly
     */
    hdwp = NtUserBeginDeferWindowPos(3);

    if (hdwp)
    {
        hdwp = NtUserDeferWindowPos( hdwp,
                               PtoH(pwndList),
                               NULL,
                               0,
                               0,
                               deltaX + pwndList->rcWindow.right - pwndList->rcWindow.left,
                               deltaY + pwndList->rcWindow.bottom - pwndList->rcWindow.top,
                               SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE );

        if (hdwp)
        {
            hdwp = NtUserDeferWindowPos(hdwp,
                               PtoH(pwndButtonLeft),
                               NULL,
                               pwndButtonLeft->rcWindow.left - pwnd->rcClient.left,
                               deltaY + pwndButtonLeft->rcWindow.top - pwnd->rcClient.top,
                               0,
                               0,
                               SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );


            if (hdwp)
            {
                hdwp = NtUserDeferWindowPos( hdwp,
                               PtoH(pwndButtonRight),
                               NULL,
                               pwndButtonRight->rcWindow.left - pwnd->rcClient.left,
                               deltaY + pwndButtonRight->rcWindow.top - pwnd->rcClient.top,
                               0,
                               0,
                               SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
            }

        }
        if (hdwp) {
            NtUserEndDeferWindowPosEx(hdwp, FALSE);
        }
    }
}

/***************************************************************************\
* MDIActivateDlgInit
*
* The minimum allowed size and the previous one are saved as properties
* of the parent window.
*
* History:
* Oct 97 MCostea Created
\***************************************************************************/

VOID MDIActivateDlgInit(HWND hwnd, LPARAM lParam)
{
    PMDIACTIVATEPOS pPos;
    HWND  hwndParent;
    RECT  rc;

    xxxInitActivateDlg(hwnd, (PWND)lParam);

    hwndParent = GetParent(hwnd);
    /*
     * Preserve the previous size of the dialog, if any
     */
    if (atomMDIActivateProp == 0) {

        atomMDIActivateProp = AddAtomW(MDIACTIVATE_PROP_NAME);
        UserAssert(atomMDIActivateProp);
    }

    GetWindowRect(hwnd, &rc);

    pPos = (PMDIACTIVATEPOS)GetProp(hwndParent, MAKEINTATOM(atomMDIActivateProp));
    /*
     * If the dialog was used before, retrieve it's size
     */
    if (pPos != NULL) {

        int cxBorder, cyBorder, cx, cy;

        /*
         * The stored size and the ones in WM_SIZE are client window coordinates
         * Need to adjust them for NtUserSetWindowPos and WM_INITDIALOG
         */
        cxBorder = rc.right - rc.left;
        cyBorder = rc.bottom - rc.top;
        GetClientRect(hwnd, &rc);
        cxBorder -= rc.right - rc.left;
        cyBorder -= rc.bottom - rc.top;

        NtUserSetWindowPos(hwnd, NULL, 0, 0,
                           pPos->cx + cxBorder,
                           pPos->cy + cyBorder,
                           SWP_NOMOVE | SWP_NOZORDER | SWP_NOOWNERZORDER
                           | SWP_NOSENDCHANGING | SWP_NOREDRAW);
        cx = pPos->cx;
        cy = pPos->cy;
        pPos->cx = pPos->cxMin - cxBorder;
        pPos->cy = pPos->cyMin - cyBorder;
        MDIActivateDlgSize(hwnd, cx, cy);

    } else {
        /*
         *
         */
        pPos = UserLocalAlloc(0, sizeof(MDIACTIVATEPOS));
        if (pPos == NULL) {
            return;
        }
        pPos->cxMin = rc.right - rc.left;
        pPos->cyMin = rc.bottom - rc.top;

        GetClientRect(hwnd, &rc);
        pPos->cx = rc.right - rc.left;
        pPos->cy = rc.bottom - rc.top;
        SetProp(hwndParent, MAKEINTATOM(atomMDIActivateProp), (HANDLE)pPos);
    }
}

/***************************************************************************\
* MDIActivateDlgProc
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

INT_PTR MDIActivateDlgProcWorker(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int i;

    switch (wMsg) {

    case WM_INITDIALOG:
        /*
         * NOTE: Code above uses DialogBoxParam, passing pwndMDI in the low
         * word of the parameter...
         */
        MDIActivateDlgInit(hwnd, lParam);
        return FALSE;

    case WM_COMMAND:
        i = -2;

        switch (LOWORD(wParam)) {

        /*
         * Listbox doubleclicks act like OK...
         */
        case 100:
            if (HIWORD(wParam) != LBN_DBLCLK)
                break;

        /*
         ** FALL THRU **
         */
        case IDOK:
            i = (UINT)SendDlgItemMessage(hwnd, 100, LB_GETCURSEL, 0, 0L);

        /*
         ** FALL THRU **
         */
        case IDCANCEL:
            EndDialog(hwnd, i);
            break;
        default:
            return FALSE;
        }
        break;

    case WM_SIZE:
        MDIActivateDlgSize(hwnd, LOWORD(lParam), HIWORD(lParam));
        return FALSE;

    case WM_GETMINMAXINFO:
        {
            PMDIACTIVATEPOS pPos;

            if (pPos = (PMDIACTIVATEPOS)GetProp(GetParent(hwnd), MAKEINTATOM(atomMDIActivateProp))) {
                 ((LPMINMAXINFO)lParam)->ptMinTrackSize.x = pPos->cxMin;
                 ((LPMINMAXINFO)lParam)->ptMinTrackSize.y = pPos->cyMin;
            }
            return FALSE;
        }

    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR WINAPI MDIActivateDlgProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return MDIActivateDlgProcWorker(hwnd, message, wParam, lParam);
}

INT_PTR WINAPI MDIActivateDlgProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return MDIActivateDlgProcWorker(hwnd, message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\mdiwin.c ===
/****************************************************************************\
*
*  MDIWIN.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      MDI Child Windows Support
*
* History
* 11-14-90 MikeHar     Ported from windows
* 14-Feb-1991 mikeke   Added Revalidation code
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define TITLE_EXTRA 5
#define MAX_TITLE_LEN 160


/***************************************************************************\
* xxxSetFrameTitle
*
* if lpch == 1, we redraw the whole frame. If 2, we don't do any redraw. Any
* other value, and we redraw just the caption of the frame.
*
* History:
* 11-14-90 MikeHar Ported from windows
* 04-16-91 MikeHar Win31 Merge
\***************************************************************************/
VOID xxxSetFrameTitle(
    PWND pwndFrame,
    PWND pwndMDI,
    LPWSTR lpch)
{
    PWND pwnd;
    PMDI pmdi;
    WCHAR sz[MAX_TITLE_LEN];
    HWND hwndFrame = HW(pwndFrame);

    CheckLock(pwndFrame);
    CheckLock(pwndMDI);

    /*
     * Get a pointer to the MDI structure.
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;

    if (IS_PTR(lpch) || lpch == NULL) {
        if (HTITLE(pmdi)) {
            UserLocalFree(HTITLE(pmdi));
        }
        HTITLE(pmdi) = TextAlloc(lpch);
    }

    if (HTITLE(pmdi)) {
        LARGE_UNICODE_STRING str;
        int cch;

        RtlInitLargeUnicodeString(&str, HTITLE(pmdi), (UINT)-1);
        TextCopy(&str, sz, sizeof(sz)/sizeof(WCHAR));

        if (MAXED(pmdi) && (pwnd = ValidateHwnd(MAXED(pmdi))) && pwnd->strName.Length) {

            cch = MAX_TITLE_LEN - ((str.Length / sizeof(WCHAR)) + TITLE_EXTRA);
            if (cch > 0) {
                wcscat(sz, TEXT(" - ["));
                wcsncat(sz, REBASE(pwnd, strName.Buffer), cch - 1);
                wcscat(sz, TEXT("]"));
            }
        }
    } else {
        sz[0] = 0;
    }

    _DefSetText(hwndFrame, sz, FALSE);

    if (lpch == (LPWSTR)1L)
        NtUserRedrawFrameAndHook(hwndFrame);

    else if (lpch != (LPWSTR)2L) {
        if (!NtUserRedrawTitle(hwndFrame, DC_TEXT))
            NtUserRedrawFrame(hwndFrame);
    }
}


/***************************************************************************\
* TranslateMDISysAccel
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, TranslateMDISysAccel, HWND, hwnd, LPMSG, lpMsg)
BOOL TranslateMDISysAccel(
    HWND hwnd,
    LPMSG lpMsg)
{
    PWND pwnd;
    PMDI pmdi;
    int event;

    /*
     * Is this a message we care about?
     */
    if (lpMsg->message != WM_KEYDOWN && lpMsg->message != WM_SYSKEYDOWN) {
        return FALSE;
    }

    /*
     * This is called within a message loop. If the window gets destroyed,
     * there still may be other messages in the queue that get returned
     * after the window is destroyed. The app will call TranslateAccelerator()
     * on every one of these, causing RIPs.... Make it nice so it just
     * returns FALSE.
     */
    if ((pwnd = ValidateHwndNoRip(hwnd)) == NULL) {
        RIPERR0(ERROR_INVALID_WINDOW_HANDLE, RIP_VERBOSE, "");
        return FALSE;
    }

    CheckLock(pwnd);

    /*
     * Make sure this is really an MDIClient window. Harvard Graphics 2.0
     * calls this function with a different window class and caused us
     * to get an access violation.
     */
    if (GETFNID(pwnd) != FNID_MDICLIENT) {
        RIPMSG0(RIP_WARNING, "Window not of MDIClient class");
        return FALSE;
    }

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwnd)->pmdi;

    if (!ACTIVE(pmdi))
        return FALSE;

    if (!IsWindowEnabled(ACTIVE(pmdi)))
        return FALSE;

    switch (lpMsg->wParam) {
    case VK_F4:
        event = SC_CLOSE;
        break;
    case VK_F6:
    case VK_TAB:
        if (GetKeyState(VK_SHIFT) < 0)
            event = SC_PREVWINDOW;
        else
            event = SC_NEXTWINDOW;
        break;
    default:
        return FALSE;
    }

    /*
     * All of these have the control key down
     */
    if (GetKeyState(VK_CONTROL) >= 0)
        return FALSE;

    if (GetKeyState(VK_MENU) < 0)
        return FALSE;

    SendMessage(ACTIVE(pmdi), WM_SYSCOMMAND, event, MAKELONG(lpMsg->wParam, 0));

    return TRUE;
}

/***************************************************************************\
*
*  CalcClientScrolling()
*
\***************************************************************************/

#define SBJ_HORZ  HAS_SBHORZ
#define SBJ_VERT  HAS_SBVERT
#define SBJ_BOTH  (SBJ_HORZ | SBJ_VERT)

VOID ByteOutsetRect(
    LPRECT lprc)
{
    int *pi;
    int i;

    for (i = 0, pi = (int*)lprc; i < 4; i++, pi++) {
        if (*pi > 0) {
            *pi += 7;
        } else if (*pi < 0) {
            *pi -= 7;
        }

        *pi /= 8;
    }
}

VOID CalcClientScrolling(
    HWND hwnd,
    UINT sbj,
    BOOL fIgnoreMin)
{
    PWND pwnd;
    RECT rcScroll;
    RECT rcClient;
    RECT rcRange;
    RECT rcT;
    PWND pwndT;
    BOOL fVert;
    BOOL fHorz;
    BYTE fHadVert, fHadHorz;
    BOOL fCheckVert;
    BOOL fCheckHorz;
    BOOL fNeedScrolls;
    SCROLLINFO si;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return;
    }
    CheckLock(pwnd);

    UserAssert(GETFNID(pwnd) != FNID_DESKTOP);

    // do nothing if the parent is iconic.  This way, we don't add invisible
    // scrollbars which will paint and unpaint when restoring...
    if (TestWF(pwnd, WFMINIMIZED))
        return;

    fVert = FALSE;
    fHorz = FALSE;
    fNeedScrolls=FALSE;

    fCheckHorz = (sbj & SBJ_HORZ);
    fCheckVert = (sbj & SBJ_VERT);

    // find client area without scroll bars
    CopyRect(&rcClient, KPRECT_TO_PRECT(&pwnd->rcClient));

    fHadVert = TestWF(pwnd, WFVSCROLL);
    if (fCheckVert && fHadVert)
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            rcClient.left -= SYSMET(CXVSCROLL);
        } else {
            rcClient.right += SYSMET(CXVSCROLL);
        }

    fHadHorz = TestWF(pwnd, WFHSCROLL);
    if (fCheckHorz && fHadHorz)
        rcClient.bottom += SYSMET(CYHSCROLL);

    // find the rectangle that bounds all visible child windows
    SetRectEmpty(&rcScroll);

    for (pwndT = REBASEPWND(pwnd, spwndChild); pwndT;
            pwndT = REBASEPWND(pwndT, spwndNext)) {
        if (fIgnoreMin && TestWF(pwndT, WFMINIMIZED))
            continue;

        if (TestWF(pwndT,WFVISIBLE)) {
            if (TestWF(pwndT, WFMAXIMIZED)) {
                fNeedScrolls = FALSE;
                break;
            }

            /*
             * add this window to the area that has to be visible
             */
            UnionRect(&rcScroll, &rcScroll, KPRECT_TO_PRECT(&pwndT->rcWindow));

            /*
             * add scroll bars if its not contained in the
             * client area
             */
            UnionRect(&rcT, &rcClient, KPRECT_TO_PRECT(&pwndT->rcWindow));
            if (!EqualRect(&rcClient, &rcT)) {
                fNeedScrolls = TRUE;
            }
        }
    }

    SetRectEmpty(&rcRange);

    // offset rectangles such that rcClient's top & left are both 0
    // making rcClient's right & bottom be the page size
    _ScreenToClient(pwnd, (LPPOINT)&rcScroll.left);
    _ScreenToClient(pwnd, (LPPOINT)&rcScroll.right);

    /*
     * Swap the left and right if pwnd is a mirrored window.
     */
    if (TestWF(pwnd, WEFLAYOUTRTL)) {
       int  nSaveLeft;

       nSaveLeft = rcScroll.left;
       rcScroll.left  = rcScroll.right;
       rcScroll.right = nSaveLeft;
    }

    OffsetRect(&rcClient, -rcClient.left, -rcClient.top);

    if (!fNeedScrolls)
        rcClient.bottom = rcClient.right = 0;
    else do
    {
            /*
             * the range is the union of the parent client with all of its
             * children
             */
        CopyRect(&rcT, &rcRange);
        UnionRect(&rcRange, &rcScroll, &rcClient);

        if (fCheckVert) {
            // subtract off space for the vertical scroll if we need it
            if (((rcRange.bottom - rcRange.top) > rcClient.bottom) && !fVert) {
                fVert = TRUE;
                rcClient.right -= SYSMET(CXVSCROLL);
            }
        }

        if (fCheckHorz) {
            // subtract off space for the horizontal scroll if we need it
            if (((rcRange.right - rcRange.left) > rcClient.right) && !fHorz) {
                fHorz = TRUE;
                rcClient.bottom -= SYSMET(CYHSCROLL);
            }
        }
    }
    while (!EqualRect(&rcRange, &rcT));

    if (fNeedScrolls) {
        // HACK of death beginning
        if (rcRange.right == rcClient.right)
            rcRange.right -= 8;

        if (rcRange.bottom == rcClient.bottom)
            rcRange.bottom -= 8;
        // HACK of death ending
    }

    if (fCheckVert) {

        /*
         * check to see if we are changing the presence of the vertical
         * scrollbar
         */
        if ((rcRange.bottom - rcRange.top) <= rcClient.bottom) {
            ClearWindowState(pwnd, WFVSCROLL);
        } else {
            SetWindowState(pwnd, WFVSCROLL);
       }
    }

    if (fCheckHorz) {

        /*
         * same for horizontal scroll
         */
        if ((rcRange.right - rcRange.left) <= rcClient.right) {
            ClearWindowState(pwnd, WFHSCROLL);
        } else {
            SetWindowState(pwnd, WFHSCROLL);
        }
    }

    if (fNeedScrolls) {
        ByteOutsetRect(&rcClient);
        ByteOutsetRect(&rcRange);
    }

    si.cbSize   = sizeof(SCROLLINFO);
    si.fMask    = SIF_ALL;
    si.nPos     = 0;

    si.nMin     = rcRange.left;
    si.nMax     = rcRange.right;
    si.nPage    = rcClient.right;

    SetScrollInfo(hwnd, SB_HORZ, &si, FALSE);

    si.nMin     = rcRange.top;
    si.nMax     = rcRange.bottom;
    si.nPage    = rcClient.bottom;

    SetScrollInfo(hwnd, SB_VERT, &si, FALSE);

    if ((fHadVert != TestWF(pwnd, WFVSCROLL)) ||
        (fHadHorz != TestWF(pwnd, WFHSCROLL)))
    NtUserRedrawFrame(hwnd);
}


/***************************************************************************\
* ScrollChildren
*
*  Handles WM_VSCROLL and WM_HSCROLL messages
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

void ScrollMDIChildren(
    HWND hwnd,
    int nCtl,
    UINT wCmd,
    int iThumbPos)
{
    SCROLLINFO  si;
    int wInc;
    int wNewPos;
    //SHORT sPos;
    int          x, y;

    wInc = (((nCtl == SB_VERT) ? SYSMET(CYSIZE) : SYSMET(CXSIZE)) + 7) / 8;

    si.cbSize   = sizeof(SCROLLINFO);
    si.fMask    = SIF_ALL;
    GetScrollInfo(hwnd, nCtl, &si);

    si.nPage--;
    si.nMax -= si.nPage;

    switch (wCmd) {
    case SB_BOTTOM:
        wNewPos = si.nMax;
        break;
    case SB_TOP:
        wNewPos = si.nMin;
        break;
    case SB_LINEDOWN:
        wNewPos = si.nPos + wInc;
        break;
    case SB_LINEUP:
        wNewPos = si.nPos - wInc;
        break;
    case SB_PAGEDOWN:
        wNewPos = si.nPos + si.nPage;
        break;
    case SB_PAGEUP:
        wNewPos = si.nPos - si.nPage;
        break;
    case SB_THUMBPOSITION:

        wNewPos = iThumbPos;
        break;
    case SB_ENDSCROLL:
        CalcClientScrolling(hwnd, (nCtl == SB_VERT) ? SBJ_VERT : SBJ_HORZ, FALSE);

    /*
     ** FALL THRU **
     */
    default:
        return;
    }

    if (wNewPos < si.nMin)
        wNewPos = si.nMin;
    else if (wNewPos > si.nMax)
        wNewPos = si.nMax;

    SetScrollPos(hwnd, nCtl, wNewPos, TRUE);

    // the "* 8" is because we need to scroll in bytes.  The scrollbar
    // increments for MDI are bytes (this is due to the fact that we need to
    // not upset the brush origin of the app workspace brush that is used to
    // fill the MDI background)

    x = (si.nPos - wNewPos) * 8;

    if (nCtl == SB_VERT) {
        y = x;
        x = 0;
    } else
        // x is already set properly for this case
        y = 0;

    NtUserScrollWindowEx(hwnd, x, y, NULL, NULL, NULL, NULL,
           SW_SCROLLWINDOW | SW_INVALIDATE | SW_ERASE | SW_SCROLLCHILDREN);
}



FUNCLOGVOID3(LOG_GENERAL, DUMMYCALLINGTYPE, ScrollChildren, HWND, hwnd, UINT, wMsg, DWORD, wParam)
VOID ScrollChildren(
    HWND hwnd,
    UINT wMsg,
    DWORD wParam)
{
    ScrollMDIChildren(hwnd,
                      wMsg == WM_VSCROLL ? SB_VERT : SB_HORZ,
                      LOWORD(wParam),
                      (short)(HIWORD(wParam)));
}


/***************************************************************************\
* RecalculateScrollRanges
*
* History:
* 11-14-90 MikeHar Ported from windows
* 04-16-91 MikeHar Win31 Merge
\***************************************************************************/

VOID RecalculateScrollRanges(
    PWND pwndParent,
    BOOL fIgnoreMin)
{
    PMDI pmdi = ((PMDIWND)pwndParent)->pmdi;

    if (!(SCROLL(pmdi) & (CALCSCROLL | SCROLLCOUNT))) {
        if (PostMessage(HWq(pwndParent), MM_CALCSCROLL, fIgnoreMin, 0L)) {
            SCROLL(pmdi) |= CALCSCROLL;
        }
    }
}


/***************************************************************************\
* GetCascadeWindowPos
*
* History:
* 11-14-90 MikeHar Ported from windows
* 01-12-94 FritzS  Ported from Chicago
\***************************************************************************/
VOID GetCascadeWindowPos(
    LPCRECT prcClient,  /* area to arrange to */
    int     iWindow,    /* index of this window */
    LPRECT  lprc)       /* resulting rectangle */
{
    int cStack;
    int xStep, yStep;
    int dxClient, dyClient;

    /*
     * Compute the width and breadth of the situation.
     */
    dxClient = prcClient->right - prcClient->left;
    UserAssert(dxClient >= 0);
    dyClient = prcClient->bottom - prcClient->top;
    UserAssert(dyClient >= 0);

    /*
     * Compute the width and breadth of the window steps.
     */
    xStep = SYSMET(CXSIZEFRAME) + SYSMET(CXSIZE);
    yStep = SYSMET(CYSIZEFRAME) + SYSMET(CYSIZE);

    /*
     * How many windows per stack?
     */
    cStack = dyClient / (3 * yStep);

    lprc->right = dxClient - (cStack * xStep);
    lprc->bottom = dyClient - (cStack * yStep);

    /*
     * HACK!: Mod by cStack+1 and make sure no div-by-zero
     * exception happens.
     */
    if (++cStack <= 0) {
        cStack = 1;
    }

    lprc->left = prcClient->left + (iWindow % cStack) * xStep;
    lprc->top = prcClient->top + (iWindow % cStack) * yStep;
}


/***************************************************************************\
* MDICheckCascadeRect
*
* History:
* 11-14-90 MikeHar Ported from windows
* 04-16-91 MikeHar Win31 Merge
\***************************************************************************/
VOID MDICheckCascadeRect(
    PWND pwndClient,
    LPRECT lprc)
{
    PMDI pmdi;
    RECT rc, rcClient;
    int         iWindow;

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndClient)->pmdi;

    iWindow = ITILELEVEL(pmdi);

    GetRect(pwndClient, &rcClient, GRECT_CLIENT | GRECT_CLIENTCOORDS);
    GetCascadeWindowPos(&rcClient, iWindow, &rc);

    if ((lprc->right == CW_USEDEFAULT || lprc->right == CW2_USEDEFAULT) ||
            !(lprc->right)) {
        lprc->right = rc.right;
    }

    if ((lprc->bottom == CW_USEDEFAULT || lprc->bottom == CW2_USEDEFAULT) ||
            !(lprc->bottom)) {
        lprc->bottom = rc.bottom;
    }

    if (lprc->left == CW_USEDEFAULT || lprc->left == CW2_USEDEFAULT) {
        lprc->left = rc.left;
        lprc->top = rc.top;
    }
}


/***************************************************************************\
* UnMaximizeChildWindows
*
* effects: Helper routine used by TileChildWindows and CascadeChildWindows to
* restore any maximized windows of the given parent. Returns TRUE if a
* maximized window was restored.
*
* History:
* 4-16-91 MikeHar       Win31 Merge
\***************************************************************************/

BOOL UnmaximizeChildWindows(
    HWND hwndParent)
{
    HWND hwndMove;
    PWND pwndMove;
    BOOL fFoundOne = FALSE;
    BOOL fAsync;
    UINT chwnd;
    HWND *phwndList;
    HWND *phwnd;
    HWND hwndChild = GetWindow(hwndParent, GW_CHILD);

    /*
     * Get the hwnd list. It is returned in a block of memory allocated with
     * UserLocalAlloc.
     */
    if (hwndChild == NULL ||
            (chwnd = BuildHwndList(NULL, GetWindow(hwndParent, GW_CHILD),
                                   FALSE, 0, &phwndList)) == 0) {
        return FALSE;
    }

    fAsync = (hwndParent == GetDesktopWindow());

    for (phwnd = phwndList; chwnd > 0; chwnd--, phwnd++) {
        if ((hwndMove = *phwnd) == NULL) {
            continue;
        }

        if ((pwndMove = ValidateHwnd(hwndMove)) == NULL) {
            continue;
        }

        if (TestWF(pwndMove, WFMAXIMIZED) && TestWF(pwndMove, WFVISIBLE)) {
            //
            // If we haven't done it yet, lock the screen to prevent sending
            // paints for a cleaner update.
            //
            if (!fFoundOne && fAsync) {
                NtUserLockWindowUpdate(hwndParent);
            }

            fFoundOne = TRUE;

            if (fAsync) {
                NtUserShowWindowAsync(hwndMove, SW_SHOWNOACTIVATE);
            } else {
                NtUserShowWindow(hwndMove, SW_SHOWNORMAL);
            }
        }
    }

    UserLocalFree(phwndList);

    if (fFoundOne && fAsync) {

        HWND hwndActive = NtUserGetForegroundWindow();
        if (hwndActive != NULL) {

            /*
             * Hack! Since the above showwindows cause zorder changes, we want
             * the active window to be in front.  This makes sure...
             */
            NtUserSetWindowPos(hwndActive, HWND_TOP, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_ASYNCWINDOWPOS);

        }
        NtUserLockWindowUpdate(NULL);
        RedrawWindow(hwndParent, NULL, NULL,
                RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE | RDW_FRAME);
    }

    return fFoundOne;
}


/***************************************************************************\
*
* ARRANGEWINDOWSDATA: passed to EnumDisplayMonitors enumeration functions.
*
\***************************************************************************/

typedef struct tagARRANGEWINDOWSDATA {
    PWND    pwndParent;
    UINT    flags;
    LPRECT  lprcParent;
    int     chwnd;
    int     chwndReal;
    HWND *  phwnd;
    PWND    pwndDesktop;
    HDWP    hdwp;
    UINT    uGRCFlags;
    int     fVerifyParent;
} ARRANGEWINDOWSDATA, *PARRANGEWINDOWSDATA;



/***************************************************************************\
* ArrangeWindows
*
* Called from CascadeWindows and TileWindows, it performs what
* is common to both functions, and calls out to the enumeration
* function to do the work of window arrangement.
*
* History:
* 10-Jul-1997 adams     Created.
\***************************************************************************/

WORD ArrangeWindows(
    HWND            hwndParent,
    UINT            flags,
    CONST RECT *    lpRect,
    UINT            chwnd,
    CONST HWND *    ahwnd,
    MONITORENUMPROC lpfnEnum)
{
    ARRANGEWINDOWSDATA  awd;
    HWND *              phwnd = NULL;

    /*
     * Get parent window
     */
    awd.pwndDesktop = _GetDesktopWindow();
    if (!hwndParent) {
        hwndParent = HW(awd.pwndDesktop);
        awd.pwndParent = awd.pwndDesktop;
    } else {
        awd.pwndParent = ValidateHwnd(hwndParent);
        if (awd.pwndParent == NULL) {
            return 0;
        }
    }

    UnmaximizeChildWindows(hwndParent);

    /*
     * If the rect passed in contains the desktop window,
     * arrange the windows on the desktop
     */
    if ( lpRect &&
         awd.pwndParent == awd.pwndDesktop   &&
         lpRect->left   <= awd.pwndDesktop->rcClient.left   &&
         lpRect->top    <= awd.pwndDesktop->rcClient.top    &&
         lpRect->right  >= awd.pwndDesktop->rcClient.right  &&
         lpRect->bottom >= awd.pwndDesktop->rcClient.bottom ) {

        lpRect = NULL;
    }

    /*
     * Arrange iconic windows if appropriate, and determine flags
     * for getting the client rectangle if no rect is given.
     */
    if (lpRect == NULL) {
        if (    (   awd.pwndParent != awd.pwndDesktop ||
                    !(SYSMET(ARRANGE) & ARW_HIDE)) &&
                NtUserArrangeIconicWindows(hwndParent) != 0) {

            awd.uGRCFlags = GRC_SCROLLS | GRC_MINWNDS;
        } else {
            awd.uGRCFlags = GRC_SCROLLS;
        }
    }

    /*
     * Get window list
     */
    if (ahwnd == NULL) {
        HWND hwndChild;
        PWND pwndChild;

        pwndChild = REBASEPWND(awd.pwndParent, spwndChild);
        hwndChild = HW(pwndChild);
        if (    hwndChild == NULL ||
                (chwnd = BuildHwndList(NULL, hwndChild, FALSE, 0, &phwnd)) == 0) {
            return 0;
        }
    }

    /*
     * Arrange windows
     */
    awd.hdwp = NtUserBeginDeferWindowPos(chwnd);
    if (awd.hdwp == NULL)
        goto Done;

    awd.flags = flags;
    awd.lprcParent = (LPRECT) lpRect;
    awd.chwnd = chwnd;
    awd.chwndReal = 0;
    awd.phwnd = ahwnd ? (HWND *) ahwnd : phwnd;
    awd.fVerifyParent = (ahwnd != NULL);

    /*
     * If the parent is the desktop and a rectangle is not provided,
     * arrange the windows on each monitor. Otherwise, arrange the
     * windows once by calling the enumeration function directly.
     */
    if (awd.pwndParent == awd.pwndDesktop && lpRect == NULL) {
            NtUserEnumDisplayMonitors(NULL, NULL, lpfnEnum, (LPARAM) &awd);
    } else {
        (*lpfnEnum)(NULL, NULL, NULL, (LPARAM) &awd);
    }

    /* Make this arrangement asynchronous so we don't hang */
    if (awd.hdwp != NULL) {
        NtUserEndDeferWindowPosEx(awd.hdwp, TRUE);
    }

Done:
    if (phwnd) {
        UserLocalFree(phwnd);
    }

    return (awd.hdwp != NULL) ? awd.chwndReal : 0;
}



/***************************************************************************\
* GetParentArrangeRect
*
* Returns the rect passed in pawd if provided, otherwise gets the client
* rect of the parent window.
*
* History:
* 10-Jul-1997 adams     Created.
\***************************************************************************/
VOID GetParentArrangeRect(
    PARRANGEWINDOWSDATA pawd,
    PMONITOR pMonitor,
    LPRECT lprc)
{
    UINT uGRCFlags;

    if (pawd->lprcParent) {
        *lprc = *pawd->lprcParent;
    } else {
        uGRCFlags = pawd->uGRCFlags;

        /*
         * If icons are shown on the desktop, then they are always
         * shown on the primary monitor. So remove the GRC_MINWNDS
         * flag for monitors other than the primary.
         */
        if (pMonitor && pMonitor != GetPrimaryMonitor()) {
            uGRCFlags &= ~GRC_MINWNDS;
        }

        GetRealClientRect(
                pawd->pwndParent, lprc, uGRCFlags, pMonitor);
    }
}



/***************************************************************************\
* ValidatePositionableWindow
*
* Validates and returns a window if it is positionable, and sets
* the appropriate sizing flags.
*
* History:
* 10-Jul-1997 adams     Created.
\***************************************************************************/

PWND
ValidatePositionableWindow(
        HWND        hwndChild,
        PWND        pwndParent,
        PWND        pwndDesktop,
        DWORD       dwMDIFlags,
        PMONITOR    pMonitor,
        DWORD *     pdwSWPFlags)
{
    PWND    pwndChild;

    pwndChild = ValidateHwnd(hwndChild);
    if (pwndChild) {
        if (pwndParent && REBASEPWND(pwndChild, spwndParent) != pwndParent) {
            RIPMSG0(RIP_WARNING, "Cascade/Tile Windows: Windows in list must have same parent");
        } else if (
                /*
                 * mikesch - removed the maximized check since the call
                 * to restore maximized windows in unmaximizechildwindows occurs
                 * asynchronously now.
                 */
                TestWF(pwndChild, WFVISIBLE) &&
                TestWF(pwndChild, WFCPRESENT) &&
                !TestWF(pwndChild, WFMINIMIZED) &&
                !TestWF(pwndChild, WEFTOPMOST) &&
                (!(dwMDIFlags & MDITILE_SKIPDISABLED) || !TestWF(pwndChild, WFDISABLED)) &&
                !TestWF(pwndChild, WEFTOOLWINDOW) &&
                ((pMonitor) ?
                    (pMonitor == _MonitorFromWindow(pwndChild, MONITOR_DEFAULTTONULL)) :
                    (pwndParent != pwndDesktop || _MonitorFromWindow(pwndChild, MONITOR_DEFAULTTONULL)))) {

                    if (pdwSWPFlags) {
                        *pdwSWPFlags = SWP_NOACTIVATE | SWP_NOCOPYBITS;
                        if (!TestWF(pwndChild, WFSIZEBOX)) {
                            *pdwSWPFlags |= SWP_NOSIZE;
                        }
                        if (!(dwMDIFlags & MDITILE_ZORDER)) {
                            *pdwSWPFlags |= SWP_NOZORDER;
                        }
                    }
            return pwndChild;
        }
    }

    return NULL;
}



/***************************************************************************\
* CascadeWindowsEnum
*
* Cascades windows on the monitor.
*
* History:
* 10-Jul-1997 adams     Created.
\***************************************************************************/

BOOL CALLBACK
CascadeWindowsEnum(
        HMONITOR    hmonitor,
        HDC         hdc,
        LPRECT      lprc,
        LPARAM      lparam)
{
    PARRANGEWINDOWSDATA pawd = (PARRANGEWINDOWSDATA)lparam;
    PMONITOR    pMonitor = hmonitor ? VALIDATEHMONITOR(hmonitor) : NULL;
    RECT        rcParent;
    int         i;
    int         chwndReal = 0;
    RECT        rc;
    HWND        * phwnd, * phwndCopy;
    BOOL        fRet = TRUE;

    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(lprc);

    /*
     * Get the parent rectangle if none is given.
     */
    GetParentArrangeRect(pawd, pMonitor, &rcParent);

    /*
     * New for NT5: MDITILE_ZORDER (for the SHELL guys)
     * Sort pawd->phwnd by z-order
     */
    if (pawd->flags & MDITILE_ZORDER) {
        PWND pwndChild;
        HWND * phwndFullList, * phwndNext, * phwndSort, * phwndSearch;
        int chwndFullList, chwndSort, chwndSearch;
        /*
         * Make a copy to leave their array alone (it's supposed to be const)
         */
        phwndCopy = UserLocalAlloc(0, pawd->chwnd * sizeof(HWND));
        if (phwndCopy == NULL) {
            return FALSE;
        }
        RtlCopyMemory(phwndCopy, pawd->phwnd, pawd->chwnd * sizeof(HWND));
        /*
         * Get the sibblings Z-Ordered list.
         */
        pwndChild = REBASEPWND(pawd->pwndParent, spwndChild);
        if (pwndChild == NULL) {
            fRet = FALSE;
            goto CleanUp;
        }
        chwndFullList = BuildHwndList(NULL, HWq(pwndChild), FALSE, 0, &phwndFullList);
        if (chwndFullList == 0) {
            fRet = FALSE;
            goto CleanUp;
        }
        /*
         * Loop through the Z-Ordered list looking for the windows in the array
         */
        for (phwndNext = phwndFullList, chwndSort = pawd->chwnd, phwndSort = phwndCopy;
                (chwndFullList > 0) && (chwndSort > 1);
                chwndFullList--, phwndNext++) {

            for (chwndSearch = chwndSort, phwndSearch = phwndSort;
                    chwndSearch > 0;
                    chwndSearch--, phwndSearch++) {
                /*
                 * If it found a window, move it after the last sorted window.
                 */
                if (*phwndNext == *phwndSearch) {
                    HWND hwndFirst = *phwndSort;
                    *phwndSort = *phwndSearch;
                    *phwndSearch = hwndFirst;
                    phwndSort++;
                    chwndSort--;
                    break;
                }
            }
        }
        UserLocalFree(phwndFullList);
    } else { /* if (pawd->flags & MDITILE_ZORDER) */
        phwndCopy = pawd->phwnd;
    }

    /*
     * Arrange the windows in the list, preserving z-order.
     */
    for (i = pawd->chwnd, phwnd = phwndCopy + i - 1; --i >= 0; phwnd--) {
        HWND    hwndChild;
        PWND    pwndChild = NULL;
        DWORD   dwSWPFlags;

        hwndChild = *phwnd;
        pwndChild = ValidatePositionableWindow(
                hwndChild,
                pawd->fVerifyParent ? pawd->pwndParent : NULL,
                pawd->pwndDesktop,
                pawd->flags,
                pMonitor,
                &dwSWPFlags);

        if (!pwndChild)
            continue;

        GetCascadeWindowPos(&rcParent, chwndReal, &rc);

        pawd->hdwp = NtUserDeferWindowPos(
                pawd->hdwp,
                hwndChild,
                HWND_TOP,
                rc.left,
                rc.top,
                rc.right,
                rc.bottom,
                dwSWPFlags);

        chwndReal++;
        pawd->chwndReal++;
    }

CleanUp:
    if (pawd->flags & MDITILE_ZORDER) {
        UserLocalFree(phwndCopy);
    }

    return fRet && (pawd->hdwp != NULL);
}



/***************************************************************************\
*
*  CascadeWindows()
*
*  Cascades a list of children within a parent, according to the flags and
*  the rectangle passed in.
*
\***************************************************************************/
WORD CascadeWindows(
    HWND hwndParent,
    UINT flags,
    CONST RECT *lpRect,
    UINT chwnd,
    CONST HWND *ahwnd)
{
    return ArrangeWindows(hwndParent, flags, lpRect, chwnd, ahwnd, CascadeWindowsEnum);
}

BOOL CALLBACK
TileWindowsEnum(
        HMONITOR    hmonitor,
        HDC         hdc,
        LPRECT      lprc,
        LPARAM      lparam)
{
    PARRANGEWINDOWSDATA pawd = (PARRANGEWINDOWSDATA)lparam;
    PMONITOR    pMonitor = hmonitor ? VALIDATEHMONITOR(hmonitor) : NULL;
    RECT        rcParent;
    int         ihwnd;
    int         chwndReal;
    int         square;
    int         iCol, iRow;
    int         cCol, cRow;
    int         cRem;
    int         dx, dy;
    int         xRes, yRes;

    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(lprc);

    /*
     * Get the parent rectangle if none is given.
     */
    GetParentArrangeRect(pawd, pMonitor, &rcParent);

    /*
     * Now, figure out how many REAL windows we have.
     */
    chwndReal = 0;
    for (ihwnd = pawd->chwnd; --ihwnd >= 0;) {
        if (ValidatePositionableWindow(
                pawd->phwnd[ihwnd],
                pawd->fVerifyParent ? pawd->pwndParent : NULL,
                pawd->pwndDesktop,
                pawd->flags,
                pMonitor,
                NULL)) {

            chwndReal++;
        }
    }

    if (chwndReal == 0)
        return TRUE;

    xRes = rcParent.right - rcParent.left;
    yRes = rcParent.bottom - rcParent.top;
    if (xRes <= 0 || yRes <= 0)
        return TRUE;

    /*
     * Compute nearest least square
     */
    for (square = 2; square * square <= chwndReal; square++) {
        /* do nothing */;
    }

    if (pawd->flags & MDITILE_HORIZONTAL) {
        cCol = square - 1;
        cRow = chwndReal / cCol;
        cRem = chwndReal % cCol;
    } else {
        cRow = square - 1;
        cCol = chwndReal / cRow;
        cRem = chwndReal % cRow;
    }

    chwndReal = 0;
    ihwnd = -1;
    for (iCol = 0; iCol < cCol; iCol++) {
        /*
         * Add one extra row to handle the remainders.
         */
        if (cCol - iCol <= cRem) {
            cRow++;
        }

        for (iRow = 0; iRow < cRow; iRow++) {
            HWND    hwndChild;
            PWND    pwndChild;
            DWORD   dwSWPFlags;

            dx = xRes / cCol;
            dy = yRes / cRow;

NextWindow:
            /*
             * Skip bogus and nonpositionable windows.
             */
            ihwnd++;
            if (ihwnd >= pawd->chwnd) {
                return TRUE;
            }

            hwndChild = pawd->phwnd[ihwnd];
            pwndChild = ValidatePositionableWindow(
                    hwndChild,
                    pawd->fVerifyParent ? pawd->pwndParent : NULL,
                    pawd->pwndDesktop,
                    pawd->flags,
                    pMonitor,
                    &dwSWPFlags);

            if (!pwndChild) {
                goto NextWindow;
            }

            /*
             * Move, size the window.
             */
            pawd->hdwp = NtUserDeferWindowPos(pawd->hdwp,
                                              hwndChild,
                                              HWND_TOP,
                                              rcParent.left + iCol*dx,
                                              rcParent.top + iRow*dy,
                                              dx,
                                              dy,
                                              dwSWPFlags);
            if (pawd->hdwp == NULL) {
                return FALSE;
            }

            chwndReal++;
            pawd->chwndReal++;
        }

        if (cCol - iCol <= cRem) {
            cRow--;
            cRem--;
        }
    }

    return TRUE;
}



/***************************************************************************\
*
*  TileWindows()
*
*  Tiles a list of children within a parent, according to the flags and
*  the rectangle passed in.
*
\***************************************************************************/
WORD TileWindows(
    HWND        hwndParent,
    UINT        flags,
    CONST RECT *lpRect,
    UINT        chwnd,
    CONST HWND *ahwnd)
{
    return ArrangeWindows(hwndParent, flags, lpRect, chwnd, ahwnd, TileWindowsEnum);
}



/***************************************************************************\
* xxxMDIActivate
*
* History:
* 11-14-90 MikeHar Ported from windows
*  4-16-91 MikeHar Win31 Merge
\***************************************************************************/
VOID xxxMDIActivate(
    PWND pwnd,
    PWND pwndActivate)
{
    HWND hwndOld;
    PWND pwndOld;

    PMDI pmdi;
    BOOL fShowActivate;
    UINT nID;
    TL tlpwnd;
    TL tlpwndOld;
    PWND pwndT;
    HWND hwnd = HWq(pwnd);
    HWND hwndActivate = HW(pwndActivate);

    CheckLock(pwnd);
    CheckLock(pwndActivate);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwnd)->pmdi;

    if (ACTIVE(pmdi) == hwndActivate)
        return;

    if ((pwndActivate != NULL) && (TestWF(pwndActivate, WFDISABLED))) {
        /*
         * Don't even try activating disabled or invisible windows.
         */
        return;
    }

    pwndT = REBASEPWND(pwnd, spwndParent);
    fShowActivate = (HW(pwndT) ==
            NtUserQueryWindow(hwnd, WindowActiveWindow));

    hwndOld = ACTIVE(pmdi);
    if (hwndOld && (pwndOld = ValidateHwnd(hwndOld)) == NULL) {
        hwndOld = NULL;
    }
    ThreadLock(pwndOld, &tlpwndOld);

    if (hwndOld) {

        /*
         * Attempt to deactivate the MDI child window.
         * The MDI child window can fail deactivation by returning FALSE.
         * But this only applies if the MDI frame is the active window
         * and the app is a 3.1 app or later
         */
        if (!SendMessage(hwndOld, WM_NCACTIVATE, FALSE, 0L) && fShowActivate) {
            if (TestWF(pwndOld, WFWIN31COMPAT))
                goto UnlockOld;
        }

        if (!TestWF(pwndOld, WFWIN31COMPAT) && TestWF(pwndOld, WFFRAMEON)) {

            /*
             * Error: Quicken for Windows is sort of bogus.  They try to fail
             * the WM_NCACTIVATE of their newly created window by not passing
             * it to DefWindowProc.  Bug 6412.  WM_NCACTIVATE sets/unsets the
             * WFFRAMEON bit if passed to DWP so we can double check things
             * here.
             */
            goto UnlockOld;
        }

        SendMessage(hwndOld, WM_MDIACTIVATE, (WPARAM)hwndOld, (LPARAM)hwndActivate);

        /*
         * Uncheck the old window menu entry.
         */
        if (WINDOW(pmdi))
            CheckMenuItem(WINDOW(pmdi), PtrToUlong(pwndOld->spmenu),
                MF_BYCOMMAND | MF_UNCHECKED);
    }

    //
    // Handle switching to a new (or NO) maximized window.  If NO window is
    // to become maximized, because we're activating NULL or the window to
    // become active doesn't have a WS_MAXIMIZEBOX, restore the old one to
    // it's normal size to clean up the MDI maximized menubar mess
    //
    if (MAXED(pmdi) && MAXED(pmdi) != hwndActivate) {
        HWND hwndMax;
        int  iShowCode;

        // The MAXBOX check is a new thing for 4.0 dudes; it breaks 3.x apps.
        // See comment in the WM_MDIMAXIMIZE handling.

        if (pwndActivate && (TestWF(pwndActivate, WFMAXBOX) || !TestWF(pwndActivate, WFWIN40COMPAT))) {
            hwndMax = hwndActivate;
            iShowCode = SW_SHOWMAXIMIZED;
            Lock(&ACTIVE(pmdi), hwndMax);
        } else {
            hwndMax = MAXED(pmdi);
            iShowCode = SW_SHOWNORMAL;
        }

        // overload WFFULLSCREEN bit -- useless for child windows anyways
        // use it to indicate to min/max code to not animate size change.

        // NO -- no bit overloading.  FritzS
        NtUserCallHwndParam(hwndMax, WFNOANIMATE, SFI_SETWINDOWSTATE);
        NtUserShowWindow(hwndMax, iShowCode);
        NtUserCallHwndParam(hwndMax, WFNOANIMATE, SFI_CLEARWINDOWSTATE);
    }

    Lock(&ACTIVE(pmdi), hwndActivate);

    /*
     * We may be removing the activation entirely...
     */
    if (!pwndActivate) {
        if (fShowActivate)
            NtUserSetFocus(hwnd);
        goto UnlockOld;
    }

    if (WINDOW(pmdi)) {

        /*
         * Check the new window menu entry.
         */
        nID = GetWindowID(ACTIVE(pmdi));
        if (nID - FIRST(pmdi) < (MAXITEMS - 1)) {
            CheckMenuItem(WINDOW(pmdi), nID, MF_BYCOMMAND | MFS_CHECKED);
        } else {
            /*
             * the item is not in the menu at all!  Swap it with number 9.
             */
            PWND pwndOther = FindPwndChild(pwnd, (UINT)(FIRST(pmdi) + MAXITEMS - 2));

            SetWindowLongPtr(HW(pwndOther), GWLP_ID, PtrToLong(pwndActivate->spmenu));
            SetWindowLongPtr(hwndActivate, GWLP_ID, FIRST(pmdi) + MAXITEMS - 2);

            ModifyMenuItem(pwndActivate);
        }
    }

    /*
     * Bring the window to the top.
     */
    NtUserSetWindowPos(ACTIVE(pmdi), NULL, 0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    /*
     * Update the Caption bar.  Don't muck with styles for 3.1.
     */
    if (fShowActivate) {
        SendMessage(ACTIVE(pmdi), WM_NCACTIVATE, TRUE, 0L);

        ThreadLock(pwnd, &tlpwnd);

        if (hwnd == NtUserQueryWindow(hwnd, WindowFocusWindow))
            SendMessage(hwnd, WM_SETFOCUS, (WPARAM)hwnd, 0);
        else
            NtUserSetFocus(hwnd);

        ThreadUnlock(&tlpwnd);
    }

    /*
     * Notify the new active window of his activation.
     */
    SendMessage(ACTIVE(pmdi), WM_MDIACTIVATE, (WPARAM)hwndOld,
                (LPARAM)hwndActivate);

UnlockOld:
    ThreadUnlock(&tlpwndOld);
}


/***************************************************************************\
* xxxMDINext
*
* History:
* 11-14-90 MikeHar Ported from windows
*  4-16-91 MikeHar Win31 Merge
\***************************************************************************/
VOID xxxMDINext(
    PWND pwndMDI,
    PWND pwnd,
    BOOL fPrevWindow)
{
    PMDI pmdi;
    PWND pwndNextGuy;
    HDWP hdwp;
    BOOL fHack = FALSE;

    CheckLock(pwndMDI);
    CheckLock(pwnd);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;

    pwndNextGuy = pwnd;

    while (TRUE) {
        if (fPrevWindow)
            pwndNextGuy = _GetWindow(pwndNextGuy, GW_HWNDPREV);
        else
            pwndNextGuy = REBASEPWND(pwndNextGuy, spwndNext);

        if (!pwndNextGuy) {
            if (fPrevWindow) {
                pwndNextGuy = _GetWindow(pwnd, GW_HWNDLAST);
            } else {
                pwndNextGuy =  REBASEPWND(pwndMDI, spwndChild);
            }
        }

        if (pwndNextGuy == pwnd)
            return;


        //
        // Ignore hidden and disabled windows.
        //
        if (TestWF(pwndNextGuy, WFVISIBLE) && !TestWF(pwndNextGuy, WFDISABLED))
            break;
    }

    if (MAXED(pmdi)) {
        NtUserSetVisible(HWq(pwndMDI), SV_UNSET | SV_CLRFTRUEVIS);
        fHack = TRUE;
    }

    hdwp = NtUserBeginDeferWindowPos(2);

    /*
     * activate the new window (first, in case of maximized windows)
     */
    hdwp = NtUserDeferWindowPos(hdwp, HW(pwndNextGuy), HWND_TOP, 0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE);

// LATER 30-Mar-1992 mikeke
// this used to be _GetWindow(pwndMDI->spwndChild, GW_HWNDLAST)
// instead of HWND_BOTTOM
   if (hdwp && !fPrevWindow && (pwnd != pwndNextGuy))
       hdwp = NtUserDeferWindowPos(hdwp, HW(pwnd),
            HWND_BOTTOM, 0, 0, 0, 0,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    NtUserEndDeferWindowPosEx(hdwp, FALSE);

    if (fHack) {
        NtUserShowWindow(HWq(pwndMDI), SW_SHOW);
    }
}



FUNCLOG10(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, CreateMDIWindowA, LPCSTR, pClassName, LPCSTR, pWindowName, DWORD, dwStyle, int, x, int, y, int, nWidth, int, nHeight, HWND, hwndParent, HINSTANCE, hModule, LPARAM, lParam)
HWND
CreateMDIWindowA(
    LPCSTR pClassName,
    LPCSTR pWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hwndParent,
    HINSTANCE hModule,
    LPARAM lParam)
{
    return CreateWindowExA(WS_EX_MDICHILD, pClassName, pWindowName,
                                 dwStyle, x, y, nWidth, nHeight,
                                 hwndParent, NULL, hModule, (LPVOID)lParam);
}



FUNCLOG10(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, CreateMDIWindowW, LPCWSTR, pClassName, LPCWSTR, pWindowName, DWORD, dwStyle, int, x, int, y, int, nWidth, int, nHeight, HWND, hwndParent, HINSTANCE, hModule, LPARAM, lParam)
HWND
CreateMDIWindowW(
    LPCWSTR pClassName,
    LPCWSTR pWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hwndParent,
    HINSTANCE hModule,
    LPARAM lParam)
{
    return CreateWindowExW(WS_EX_MDICHILD, pClassName, pWindowName,
                                 dwStyle, x, y, nWidth, nHeight,
                                 hwndParent, NULL, hModule, (LPVOID)lParam);
}


/***************************************************************************\
* xxxMDIDestroy
*
* History:
* 11-14-90 MikeHar Ported from windows
*  4-16-91 MikeHar Win31 Merge
\***************************************************************************/
VOID xxxMDIDestroy(
    PWND pwnd,
    HWND hwndVictim)
{
    PWND pwndVictim;
    TL tlpwndParent;
    PMDI pmdi;
    PWND pwndParent;
    HWND hwnd;

    CheckLock(pwnd);

    if ((pwndVictim = ValidateHwnd(hwndVictim)) == NULL) {
        return;
    }
    CheckLock(pwndVictim);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwnd)->pmdi;

#ifdef NEVER
// don't do this validation - because it sometimes doesn't work! If an
// app passed in idFirstChild (through CLIENTCREATESTRUCT) as -1, this
// code fails because it treats the id comparisons as unsigned compares.
// Change them to signed compares and it still doesn't work. That is because
// when ShiftMenuIDs() is called, you'll shift mdi windows out of the signed
// comparison range and this check won't allow them to be destroyed. This
// is straight win3.1 code.
//
    /*
     * Validate that this is one of the mdi children we are keeping track
     * of. If it isn't don't destroy it because it'll get mdi id tracking
     * code all messed up.
     */
    if (((UINT)pwndVictim->spmenu) < FIRST(pmdi) ||
            ((UINT)pwndVictim->spmenu) >= (UINT)(FIRST(pmdi) + CKIDS(pmdi)) ||
            pwndVictim->spwndOwner != NULL) {
        RIPERR0(ERROR_NON_MDICHILD_WINDOW, RIP_VERBOSE, "");
        return;
    }
#endif

    ShiftMenuIDs(pwnd, pwndVictim);

    /*
     * First Activate another window.
     */
    if (SAMEWOWHANDLE(hwndVictim, ACTIVE(pmdi))) {
        xxxMDINext(pwnd, pwndVictim, FALSE);

        /*
         * Destroying only child?
         */
        if (SAMEWOWHANDLE(hwndVictim, ACTIVE(pmdi))) {
            NtUserShowWindow(hwndVictim, SW_HIDE);

            /*
             * If the window is maximized, we need to remove his sys menu
             * now otherwise it may get deleted twice.  Once when the child
             * is destroyed and once when the frame is destroyed.
             */
            if (MAXED(pmdi)) {
                pwndParent = REBASEPWND(pwnd, spwndParent);
                MDIRemoveSysMenu(PtoH(REBASE(pwndParent,spmenu)), MAXED(pmdi));
                Unlock(&MAXED(pmdi));
                ThreadLock(pwndParent, &tlpwndParent);
                xxxSetFrameTitle(pwndParent, pwnd, (LPWSTR)1L);

                /*
                 * Redraw frame so menu bar shows the removed sys menu stuff
                 */
                if (TestWF(pwndParent, WFVISIBLE))
                    NtUserRedrawFrame(HWq(pwndParent));
                ThreadUnlock(&tlpwndParent);
            }
            xxxMDIActivate(pwnd, NULL);
        }
    }

    /*
     * Don't ever let this go negative or we'll get caught in long loops.
     */
    CKIDS(pmdi)--;
    if ((int)CKIDS(pmdi) < 0)
        CKIDS(pmdi) = 0;

    hwnd = HWq(pwnd);
    SendMessage(hwnd, WM_MDIREFRESHMENU, 0L, 0L);

    /*
     * Destroy the window.
     */
    NtUserDestroyWindow(hwndVictim);


    /*
     * During the DestroyWindow the parent may also have been deleted
     * Remove revalidate if we get client side locking
     */
    if (ValidateHwnd(hwnd) == NULL)
       return;

    /*
     * Deleting a window can change the scroll ranges.
     */
    RecalculateScrollRanges(pwnd, FALSE);
}

/***************************************************************************\
* MDIClientWndProc
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

LRESULT MDIClientWndProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    HWND hwndT;
    PWND pwndT;
    TL tlpwndT;
    PMDI pmdi;
    PWND pwndParent;

    CheckLock(pwnd);

    VALIDATECLASSANDSIZE(pwnd, FNID_MDICLIENT);

    /*
     * Get the pmdi for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,4,pmdi) when
     * we initially created the MDI client window.
     */
    pmdi = ((PMDIWND)pwnd)->pmdi;

    if (pmdi == NULL) {
        switch (message) {
        case WM_MDICREATE:
        case WM_MDIMAXIMIZE:
        case WM_PARENTNOTIFY:
        case WM_CREATE:
            /*
             * These messages are safe to call, even when pmdi has not already
             * been initialized.
             */
            break;

        default:
            /*
             * Any message that is not listed above is not safe to call when
             * pmdi has not been initialized.  Instead, just directly call DWP.
             */
            goto CallDWP;
        }
    }

    switch (message) {
    case WM_NCACTIVATE:

        /*
         * We are changing app activation.  Fix the active child's caption.
         */
        if (ACTIVE(pmdi) != NULL) {
            SendMessage(ACTIVE(pmdi), WM_NCACTIVATE, wParam, lParam);
        }
        goto CallDWP;

    case WM_MDIGETACTIVE:
        if (lParam != 0) {
            *((LPBOOL)lParam) = (MAXED(pmdi) != NULL);
        }

        return (LRESULT)ACTIVE(pmdi);

    case WM_MDIACTIVATE:
        hwndT = (HWND)wParam;
        if ((pwndT = ValidateHwnd(hwndT)) == NULL)
            return 0;

        if (SAMEWOWHANDLE(hwndT, ACTIVE(pmdi)))
              break;

        NtUserSetWindowPos(hwndT, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
        break;

    case WM_MDICASCADE:
        pmdi->wScroll |= SCROLLSUPPRESS;
        NtUserShowScrollBar(hwnd, SB_BOTH, FALSE);

        /*
         * Unmaximize any maximized window.
         */
#ifdef NEVER  // Not in Chicago -- FritzS
        if (MAXED(pmdi) != NULL) {
            NtUserShowWindow(MAXED(pmdi), SW_SHOWNORMAL);
        }
#endif
        /*
         * Save success/failure code to return to app
         */
        message = (UINT)CascadeWindows(hwnd, (UINT)wParam, NULL, 0, NULL);
        pmdi->wScroll &= ~SCROLLCOUNT;
        return (LONG)message;
        break;

    case WM_VSCROLL:
    case WM_HSCROLL:
        pmdi->wScroll |= SCROLLSUPPRESS;
        ScrollMDIChildren(hwnd, (message == WM_VSCROLL) ? SB_VERT : SB_HORZ,
              LOWORD(wParam), (short)(HIWORD(wParam)));
        pmdi->wScroll &= ~SCROLLCOUNT;
        break;

    case WM_MDICREATE:
        {
        LPMDICREATESTRUCTA lpMCSA = (LPMDICREATESTRUCTA)lParam;
        LPMDICREATESTRUCTW lpMCSW = (LPMDICREATESTRUCTW)lParam;
        DWORD exStyle = WS_EX_MDICHILD;

        /*
         * inherit the right.to.leftness of the parent.
         */
        exStyle |= (pwnd->ExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR));

        if (fAnsi) {
            hwndT = CreateWindowExA(exStyle, lpMCSA->szClass, lpMCSA->szTitle,
                lpMCSA->style, lpMCSA->x, lpMCSA->y, lpMCSA->cx, lpMCSA->cy,
                hwnd, NULL, lpMCSA->hOwner, (LPSTR)lpMCSA->lParam);
        } else {
            hwndT = CreateWindowExW(exStyle, lpMCSW->szClass, lpMCSW->szTitle,
                lpMCSW->style, lpMCSW->x, lpMCSW->y, lpMCSW->cx, lpMCSW->cy,
                hwnd, NULL, lpMCSW->hOwner, (LPWSTR)lpMCSW->lParam);
        }

        return((LRESULT)hwndT);

        }

    case WM_MDIDESTROY:
        xxxMDIDestroy(pwnd, (HWND)wParam);
        break;

    case WM_MDIMAXIMIZE:
        hwndT = (HWND)wParam;
        if ((pwndT = ValidateHwnd(hwndT)) == NULL)
            return 0;

        // Only maximize children with a MAXBOX.  However, this introduces
        // backwards-compatibility issues with VB apps (see#12211)
        // So, we do this only for WIN40COMPAT apps and beyond.
        //
        if ((TestWF(pwndT, WFMAXBOX)) || !(TestWF(pwndT, WFWIN40COMPAT))) {
            NtUserShowWindow(hwndT, SW_SHOWMAXIMIZED);
        }
        break;

    case WM_MDIRESTORE:
        hwndT = (HWND)wParam;
        if ((pwndT = ValidateHwnd(hwndT)) == NULL)
            return 0;

        NtUserShowWindow(hwndT, SW_SHOWNORMAL);
        break;

    case WM_MDITILE:
        pmdi->wScroll |= SCROLLSUPPRESS;
        NtUserShowScrollBar(hwnd, SB_BOTH, FALSE);

        /*
         * Unmaximize any maximized window.
         */
#ifdef NEVER  //Not in Chicago
        if (MAXED(pmdi) != NULL) {
            NtUserShowWindow(MAXED(pmdi), SW_SHOWNORMAL);
        }
#endif
        /*
         * Save success/failure code to return to app
         */
        message = (UINT)TileWindows(hwnd, (UINT)wParam, NULL, 0, NULL);
        pmdi->wScroll &= ~SCROLLCOUNT;
        return (LONG)message;
        break;

    case WM_MDIICONARRANGE:
        pmdi->wScroll |= SCROLLSUPPRESS;
        NtUserArrangeIconicWindows(hwnd);
        pmdi->wScroll &= ~SCROLLCOUNT;
        RecalculateScrollRanges(pwnd, TRUE);
        break;

    case WM_MDINEXT:
        if (wParam) {
            hwndT = (HWND)wParam;
        } else {
            hwndT = ACTIVE(pmdi);
        }

        if ((pwndT = ValidateHwnd(hwndT)) == NULL) {
            return 0;
        }

        /*
         * If lParam is 1, do a prev window instead of a next window
         */
        ThreadLockAlways(pwndT, &tlpwndT);
        xxxMDINext(pwnd, pwndT, (lParam == 0 ? 0 : 1));
        ThreadUnlock(&tlpwndT);
        break;

    case WM_MDIREFRESHMENU:
            return (LRESULT)MDISetMenu(pwnd, TRUE, NULL, NULL);

    case WM_MDISETMENU:
            return (LRESULT)MDISetMenu(pwnd, FALSE, (HMENU)wParam, (HMENU)lParam);

    case WM_PARENTNOTIFY:
        if (wParam == WM_LBUTTONDOWN) {
            HWND hwndChild;
            POINT pt;

            if ((pwndT = ValidateHwnd(hwnd)) == NULL) {
                return 0;
            }

            /*
             * Activate this child and bring it to the top.
             */
            pt.x = (int)MAKEPOINTS(lParam).x;
            pt.y = (int)MAKEPOINTS(lParam).y;

            /*
             * Since pt is relative to the client MDI window,
             * then the points should be mirrored if the MDI
             * client window is mirrored so that Scrren Coord
             * calculations are done properly in NtUserChildWindowFromPointEx.
             * [samera]
             */
            if (TestWF(pwndT, WEFLAYOUTRTL)) {
                pt.x = (pwndT->rcClient.right-pwndT->rcClient.left)-pt.x;
            }

            hwndChild = NtUserChildWindowFromPointEx(hwnd, pt,
                CWP_SKIPDISABLED | CWP_SKIPINVISIBLE);

            if ((hwndChild) && (hwndChild != hwnd)) {

                if (hwndChild != ACTIVE(pmdi)) {
                    NtUserSetWindowPos(hwndChild, HWND_TOP, 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE);
                }
            }
        }
        break;

    case WM_SETFOCUS:
        if (ACTIVE(pmdi) != NULL && !IsIconic(ACTIVE(pmdi))) {
            NtUserSetFocus(ACTIVE(pmdi));
        }
        break;

    case WM_SIZE:
        if (ACTIVE(pmdi) && (pwndT = ValidateHwnd(ACTIVE(pmdi))) &&
            TestWF(pwndT, WFMAXIMIZED)) {

            RECT rc;

            rc.top = rc.left = 0;
            rc.right = (int)MAKEPOINTS(lParam).x;
            rc.bottom = (int)MAKEPOINTS(lParam).y;
            RealAdjustWindowRectEx(&rc, pwndT->style, FALSE,
                    pwndT->ExStyle);
            NtUserMoveWindow(ACTIVE(pmdi), rc.left, rc.top,
                    rc.right - rc.left, rc.bottom - rc.top, TRUE);
        } else {
            RecalculateScrollRanges(pwnd, FALSE);
        }
        goto CallDWP;

    case MM_CALCSCROLL: {

        if (SCROLL(pmdi) & SCROLLCOUNT)
            break;

        {
            WORD sbj = pmdi->wScroll & (HAS_SBVERT | HAS_SBHORZ);

            if (sbj)
            {
                CalcClientScrolling(hwnd, sbj, (BOOL) wParam);

                SCROLL(pmdi) &= ~CALCSCROLL;
            }
        }
        break;
    }

    case WM_CREATE: {
        LPCLIENTCREATESTRUCT pccs = ((LPCREATESTRUCT)lParam)->lpCreateParams;

        /*
         * Try to allocate space for the pmdi
         */
        if ((pmdi = (PMDI)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(MDI)))) {
            NtUserSetWindowLongPtr(hwnd, GWLP_MDIDATA, (LONG_PTR)pmdi, FALSE);
        } else {
            NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);
            break;
        }

        pwndParent = REBASEPWND(pwnd, spwndParent);
        ACTIVE(pmdi) = NULL;
        MAXED(pmdi)  = NULL;
        CKIDS(pmdi)  = 0;
        WINDOW(pmdi) = pccs->hWindowMenu;

        FIRST(pmdi)  = pccs->idFirstChild;
        SCROLL(pmdi) = 0;
        HTITLE(pmdi) = TextAlloc(REBASE(pwndParent, strName.Buffer));

        _DefSetText(HW(pwndParent), NULL, FALSE);

        ThreadLock(pwndParent, &tlpwndT);
        xxxSetFrameTitle(pwndParent, pwnd, (LPWSTR)2L);
        ThreadUnlock(&tlpwndT);

        if (TestWF(pwnd, WFVSCROLL))
            SCROLL(pmdi) |= HAS_SBVERT;
        if (TestWF(pwnd, WFHSCROLL))
            SCROLL(pmdi) |= HAS_SBHORZ;
        if (SCROLL(pmdi)) {
            ClearWindowState(pwnd, WFVSCROLL | WFHSCROLL);
        }

        /*
         * Set this dude's system menu.
         */
        NtUserGetSystemMenu(HW(pwndParent), FALSE);

        /*
         * make sure we have the correct window client area if scrolls are
         * removed...  hack to take care of small progman bug
         */
        if (SCROLL(pmdi)) {
            NtUserUpdateClientRect(hwnd);
        }
        break;
    }

    case WM_DESTROY:
    case WM_FINALDESTROY:
        if (MAXED(pmdi)) {
            PWND pwndParent;
            PMENU pmenu;

            pwndParent = REBASEPWND(pwnd, spwndParent);
            pmenu = REBASE(pwndParent, spmenu);
            MDIRemoveSysMenu(PtoH(pmenu), MAXED(pmdi));
        }

        /*
         * delete the title
         */
        if (HTITLE(pmdi)) {
            UserLocalFree(HTITLE(pmdi));
            HTITLE(pmdi) = NULL;
        }

        /*
         * Delete the menu items of the child windows in the frame.
         * Chances are, this is called by destroying the frame, but
         * one never knows, does one?
         *
         * Increase CKIDS by 1 after checking to delete the separator
         */
        if (IsMenu(WINDOW(pmdi)) && CKIDS(pmdi)++) {
            UINT iPosition;

            if (CKIDS(pmdi) > MAXITEMS + 1)
                CKIDS(pmdi) = MAXITEMS + 1;

            iPosition = GetMenuItemCount(WINDOW(pmdi));
            while (CKIDS(pmdi)--) {
                NtUserDeleteMenu(WINDOW(pmdi), --iPosition, MF_BYPOSITION);
            }
        }

        /*
         * Unlock those objects that are used by the MDI structure.
         */
        Unlock(&MAXED(pmdi));
        Unlock(&ACTIVE(pmdi));
        Unlock(&WINDOW(pmdi));

        /*
         * Free the MDI structure
         */
        UserLocalFree(pmdi);
        NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);

        break;

    default:
CallDWP:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }
    return 0L;
}

/***************************************************************************\
*
\***************************************************************************/

LRESULT WINAPI MDIClientWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return 0;
    }

    return MDIClientWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI MDIClientWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return 0;
    }

    return MDIClientWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}


/***************************************************************************\
* DefFrameProc
*
* History:
* 11-14-90 MikeHar      Ported from windows
\***************************************************************************/

LRESULT DefFrameProcWorker(
    HWND hwnd,
    HWND hwndMDI,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fAnsi)
{
    PWND pwnd;
    PWND pwndMDI;
    PMDI pmdi;
    TL tlpwndT;
    HWND hwndT;
    PWND pwndT;
    PMDINEXTMENU pmnm;
    WINDOWPLACEMENT wp;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }
    CheckLock(pwnd);

    if (hwndMDI == NULL) {
        goto CallDWP;
    }

    if ((pwndMDI = ValidateHwnd(hwndMDI)) == NULL) {
        return (0L);
    }
    CheckLock(pwndMDI);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;

    switch (wMsg) {

    /*
     * If there is a maximized child window, add it's window text...
     */
    case WM_SETTEXT: {
        LPWSTR lpwsz = NULL;

        if (fAnsi && lParam) {
            if (!MBToWCS((LPSTR)lParam, -1, &lpwsz, -1, TRUE))
                return 0;
            lParam = (LPARAM)lpwsz;
        }
        xxxSetFrameTitle(pwnd, pwndMDI, (LPWSTR)lParam);

        if (lpwsz) {
            UserLocalFree(lpwsz);
        }
        break;
    }
    case WM_NCACTIVATE:
        SendMessage(hwndMDI, WM_NCACTIVATE, wParam, lParam);
        goto CallDWP;

    case WM_COMMAND:
        if ((UINT)LOWORD(wParam) == (FIRST(pmdi) + MAXITEMS -1)) {

            /*
             * selected the More...  item
             */
            if (fAnsi) {
                wParam = DialogBoxParamA(hmodUser,
                                         MAKEINTRESOURCEA(IDD_MDI_ACTIVATE),
                                         hwnd,
                                         MDIActivateDlgProcA,
                                         (LPARAM)pwndMDI);
            } else {
                wParam = DialogBoxParamW(hmodUser,
                                         MAKEINTRESOURCEW(IDD_MDI_ACTIVATE),
                                         hwnd,
                                         MDIActivateDlgProcW,
                                         (LPARAM)pwndMDI);
            }
            if ((int)wParam >= 0) {
                wParam += FIRST(pmdi);
                goto ActivateTheChild;
            }
        } else if (((UINT)LOWORD(wParam) >= FIRST(pmdi)) &&
                ((UINT)LOWORD(wParam) < FIRST(pmdi) + CKIDS(pmdi))) {
ActivateTheChild:
            pwndT = FindPwndChild(pwndMDI, (UINT)LOWORD(wParam));
            ThreadLock(pwndT, &tlpwndT);

            SendMessage(hwndMDI, WM_MDIACTIVATE, (WPARAM)HW(pwndT), 0L);

            /*
             * if minimized, restore it.
             */
            if (pwndT != NULL && TestWF(pwndT, WFMINIMIZED))
                    //
                    // Fix for B#1510.  Don't restore directly.  Send child
                    // a restore message.
                    //
                SendMessage(HWq(pwndT), WM_SYSCOMMAND, (WPARAM)SC_RESTORE, 0L);
            ThreadUnlock(&tlpwndT);
            break;
        }

        switch (wParam & 0xFFF0) {

        /*
         * System menu commands on a maxed mdi child
         */
        case SC_SIZE:
        case SC_MOVE:
        case SC_RESTORE:
        case SC_CLOSE:
        case SC_NEXTWINDOW:
        case SC_PREVWINDOW:
        case SC_MINIMIZE:
        case SC_MAXIMIZE:
            hwndT = MAXED(pmdi);
            if (hwndT != NULL) {
                PWND pwndT = ValidateHwnd(hwndT);
                if (pwndT == NULL)
                    break;
                if ((wParam & 0xFFF0) == SC_CLOSE) {
                    /*
                     * Since the window is maxed, we've cleared WFSYSMENU (see
                     *  MDIAddSysMenu). We need to set it back here so GetSysMenuHandle
                     *  will do the right thing for _MNCanClose.
                     */
                    BOOL fCanClose;
                    UserAssert(!TestWF(pwndT, WFSYSMENU) && (pwndT->spmenuSys != NULL));
                    SetWindowState(pwndT, WFSYSMENU);
                    fCanClose = xxxMNCanClose(pwndT);
                    ClearWindowState(pwndT, WFSYSMENU);
                    if (!fCanClose) {
                        break;
                    }
                } else if (((wParam & 0xFFF0) == SC_MINIMIZE) && !TestWF(pwndT, WFMINBOX)) {
                    break;
                }

                return SendMessage(hwndT, WM_SYSCOMMAND, wParam, lParam);
            }
        }
        goto CallDWP;

    case WM_SIZE:
        if (wParam != SIZEICONIC) {
            NtUserMoveWindow(hwndMDI, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
        } else {
            wp.length = sizeof(WINDOWPLACEMENT);
            if (GetWindowPlacement(hwnd, &wp)) {
                RECT rcT;
                int  clB;

               /*
                * If frame is iconic, size mdi win to be size of restored
                * frame's client area.  Thus mdi children etc created in here
                * use the proper mdiclient size.
                */
               clB = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, TRUE);

               CopyInflateRect(&rcT, &wp.rcNormalPosition,
                        -clB*SYSMET(CXBORDER), -clB*SYSMET(CYBORDER));

               if (TestWF(pwnd, WFBORDERMASK) == LOBYTE(WFCAPTION))
                       rcT.top += SYSMET(CYCAPTION);
               rcT.top += SYSMET(CYMENU);

               NtUserMoveWindow(hwndMDI, 0, 0, rcT.right-rcT.left,
                       rcT.bottom-rcT.top, TRUE);
            }
        }
        goto CallDWP;

    case WM_SETFOCUS:
        NtUserSetFocus(hwndMDI);
        break;

    case WM_NEXTMENU:
        if (TestWF(pwnd, WFSYSMENU) && !TestWF(pwnd, WFMINIMIZED) &&
            ACTIVE(pmdi) && !MAXED(pmdi))
        {
            PMENU pmenuIn;
            /*
             * Go to child system menu by wrapping to the left from
             * the first popup in the menu bar or to the right from
             * the frame sysmenu.
             */
            pmnm = (PMDINEXTMENU)lParam;
            pmenuIn = RevalidateHmenu(pmnm->hmenuIn);

            if (pmenuIn && ((wParam == VK_LEFT && pmenuIn == REBASE(pwnd, spmenu)) ||
                    (wParam == VK_RIGHT && pmnm->hmenuIn ==
                    NtUserGetSystemMenu(hwnd, FALSE)))) {

                HMENU hmenu;
                PWND pwndActive;

                //
                // Make sure the window is still valid
                //
                if ((pwndActive = ValidateHwnd(ACTIVE(pmdi))) == NULL) {
                    return 0;
                }

                //
                // Make sure the child's system menu items are updated
                // (i.e. the ones are enabled/disabled)
                //
                if (!TestWF(pwndActive,WFMAXIMIZED)) {
                    NtUserSetSysMenu(ACTIVE(pmdi));
                }

                hmenu = NtUserGetSystemMenu(ACTIVE(pmdi), FALSE);
                pmnm->hmenuNext = hmenu;
                pmnm->hwndNext = ACTIVE(pmdi);

                return TRUE;
            }
        }

        /*
         * default behaviour
         */
        return 0L;

    case WM_MENUCHAR:
        if (!TestWF(pwnd, WFMINIMIZED) && LOWORD(wParam) == TEXT('-')) {
            if (MAXED(pmdi))
                return MAKELONG(0, 2);
            else if (ACTIVE(pmdi)) {
              PostMessage(ACTIVE(pmdi), WM_SYSCOMMAND,
                    SC_KEYMENU, MAKELONG(TEXT('-'), 0));
              return MAKELONG(0, 1);
          }
        }

        /*
         ** FALL THRU **
         */

    default:
CallDWP:
        return DefWindowProcWorker(pwnd, wMsg, wParam, lParam, fAnsi);
    }

    return 0L;
}



FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, DefFrameProcW, HWND, hwnd, HWND, hwndMDIClient, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI DefFrameProcW(
    HWND hwnd,
    HWND hwndMDIClient,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return DefFrameProcWorker(hwnd, hwndMDIClient, message, wParam, lParam,
                              FALSE);
}


FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, DefFrameProcA, HWND, hwnd, HWND, hwndMDIClient, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI DefFrameProcA(
    HWND hwnd,
    HWND hwndMDIClient,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return DefFrameProcWorker(hwnd, hwndMDIClient, message, wParam,
                              lParam, TRUE);
}


/***************************************************************************\
* ChildMinMaxInfo
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/
VOID ChildMinMaxInfo(
    PWND pwnd,
    PMINMAXINFO pmmi)
{
    PWND pwndParent = REBASEPWND(pwnd, spwndParent);
    RECT rc;

    UserAssert(GETFNID(pwnd) != FNID_DESKTOP);

    CopyRect(&rc, KPRECT_TO_PRECT(&pwndParent->rcClient));
    _ScreenToClient(pwndParent, (LPPOINT)&rc.left);
    _ScreenToClient(pwndParent, (LPPOINT)&rc.right);

    /*
     * Swap the left and right if pwnd is a mirrored window.
     */
    if (TestWF(pwnd, WEFLAYOUTRTL)) {
       int nSaveLeft;

       nSaveLeft = rc.left;
       rc.left   = rc.right;
       rc.right  = nSaveLeft;
    }

    RealAdjustWindowRectEx(&rc, pwnd->style, FALSE, pwnd->ExStyle);

    /*
     * Position...
     */
    pmmi->ptMaxPosition.x = rc.left;
    pmmi->ptMaxPosition.y = rc.top;
    pmmi->ptMaxSize.x = rc.right - rc.left;
    pmmi->ptMaxSize.y = rc.bottom - rc.top;
}


/***************************************************************************\
* xxxChildResize
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/
VOID xxxChildResize(
    PWND pwnd,
    UINT wMode)
{
    PWND pwndT;
    PWND pwndMDI = REBASEPWND(pwnd, spwndParent);
    PWND pwndFrame = REBASEPWND(pwndMDI, spwndParent);
    HWND hwndOldActive;
    PMDI pmdi;
    HWND hwndActive;
    TL tlpwndMDI;
    TL tlpwndFrame;
    TL tlpwndT;
    PMENU pmenu;
    HWND hwnd = HWq(pwnd);

    CheckLock(pwnd);

    NtUserSetSysMenu(hwnd);

    ThreadLock(pwndMDI, &tlpwndMDI);
    ThreadLock(pwndFrame, &tlpwndFrame);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;
    pmenu = REBASE(pwndFrame, spmenu);

    if (MAXED(pmdi) == hwnd && wMode != SIZEFULLSCREEN) {
        /*
         * Restoring the current maximized window...
         * Remove the system menu from the Frame window.
         */
        if (!(SCROLL(pmdi) & OTHERMAXING)) {
            Unlock(&MAXED(pmdi));
            MDIRemoveSysMenu(PtoH(pmenu), hwnd);
            Unlock(&MAXED(pmdi));
            xxxSetFrameTitle(pwndFrame, pwndMDI, (LPWSTR)1L);
        }
    }

    if (wMode == SIZEFULLSCREEN) {

        /*
         * Already maximized?
         */
        if (hwnd == MAXED(pmdi))
            goto Exit;

        /*
         * Maximizing this window...
         */

        pmdi->wScroll |= OTHERMAXING | SCROLLCOUNT;

        if (hwndOldActive = MAXED(pmdi)) {
            SendMessage(hwndOldActive, WM_SETREDRAW, FALSE, 0L);
            MDIRemoveSysMenu(PtoH(pmenu), hwndOldActive);
            NtUserMinMaximize(hwndOldActive, SW_MDIRESTORE, FALSE);
            SendMessage(hwndOldActive, WM_SETREDRAW, TRUE, 0L);
        }

        Lock(&MAXED(pmdi), hwnd);

        /*
         * Add the system menu to the Frame window.
         */
        MDIAddSysMenu(PtoH(pmenu), hwnd);
        xxxSetFrameTitle(pwndFrame, pwndMDI, (LPWSTR)1L);

        pmdi->wScroll &= ~(OTHERMAXING | SCROLLCOUNT);
    }

    if (wMode == SIZEICONIC) {
        for (pwndT = REBASEPWND(pwndMDI, spwndChild); pwndT;
                pwndT = REBASEPWND(pwndT, spwndNext)) {
            if (!pwndT->spwndOwner && TestWF(pwndT, WFVISIBLE))
                break;
        }

        hwndActive = NtUserQueryWindow(hwnd, WindowActiveWindow);
        if ((pwndT != NULL) && (hwndActive != NULL) &&
                IsChild(hwndActive, HWq(pwndMDI))) {
            ThreadLockAlways(pwndT, &tlpwndT);
            SendMessage(HWq(pwndT), WM_CHILDACTIVATE, 0, 0L);
            ThreadUnlock(&tlpwndT);
        }
    }

    if (!(SCROLL(pmdi) & SCROLLCOUNT))
        RecalculateScrollRanges(pwndMDI, FALSE);

Exit:
    ThreadUnlock(&tlpwndFrame);
    ThreadUnlock(&tlpwndMDI);
}


/***************************************************************************\
* DefMDIChildProc
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

LRESULT DefMDIChildProcWorker(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fAnsi)
{
    PWND pwnd;
    PWND pwndParent;
    PMDI pmdi;
    PMDINEXTMENU pmnm;
    HWND hwndT;
    PWND pwndT;
    TL tlpwndT;
    TL tlpwndParent;
    LRESULT lRet;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    CheckLock(pwnd);

    /*
     * Check to see if this is a real mdi child window
     */
    pwndParent = REBASEPWND(pwnd, spwndParent);
    if (!pwndParent || GETFNID(pwndParent) != FNID_MDICLIENT) {
        RIPERR0(ERROR_NON_MDICHILD_WINDOW, RIP_VERBOSE, "");
        return DefWindowProcWorker(pwnd, wMsg, wParam, lParam, fAnsi);
    }

    /*
     * Get a pointer to the MDI structure, if it still exists
     */
    pmdi = ((PMDIWND)pwndParent)->pmdi;
    if ((ULONG_PTR)pmdi == (ULONG_PTR)-1) {
        goto CallDWP;
    }

    switch (wMsg) {
    case WM_SETFOCUS:
        if (DIFFWOWHANDLE(hwnd, ACTIVE(pmdi))) {
            ThreadLockAlways(pwndParent, &tlpwndParent);
            xxxMDIActivate(pwndParent, pwnd);
            ThreadUnlock(&tlpwndParent);
        }
        goto CallDWP;

    case WM_NEXTMENU:

        /*
         * wrap to the frame menu bar, either left to the system menu,
         * or right to the frame menu bar.
         */
        pmnm = (PMDINEXTMENU)lParam;
        pwndT = REBASEPWND(pwndParent, spwndParent);
        pmnm->hwndNext = HW(pwndT);
        pmnm->hmenuNext = (wParam == VK_LEFT) ?
                NtUserGetSystemMenu(pmnm->hwndNext, FALSE) :
                GetMenu(pmnm->hwndNext);
        return TRUE;
#if 0
             hWnd->hwndParent->hwndParent
        return (LONG)(((wParam == VK_LEFT) ?
                NtUserGetSystemMenu(HW(pwndT), FALSE):
                pwndT->spmenu)
          );
// return MAKELONG(NtUserGetSystemMenu(ACTIVE(pwndMDI), FALSE),
// ACTIVE(pwndMDI));
#endif
    case WM_CLOSE:
        hwndT = GetParent(hwnd);
        if (hwndT != NULL) {
            SendMessage(hwndT, WM_MDIDESTROY, (WPARAM)hwnd, 0L);
        }
        break;

    case WM_MENUCHAR:
        PostMessage(GetParent(GetParent(hwnd)), WM_SYSCOMMAND,
                (DWORD)SC_KEYMENU, (LONG)LOWORD(wParam));
        return 0x10000;

    case WM_SETTEXT:
        DefWindowProcWorker(pwnd, wMsg, wParam, lParam, fAnsi);
        if (WINDOW(pmdi))
            ModifyMenuItem(pwnd);

        if (TestWF(pwnd, WFMAXIMIZED)) {

            /*
             * Add the child's window text to the frame since it is
             * maximized.  But just redraw the caption so pass a 3L.
             */
            pwndT = REBASEPWND(pwndParent, spwndParent);
            ThreadLock(pwndT, &tlpwndT);
            ThreadLock(pwndParent, &tlpwndParent);
            xxxSetFrameTitle(pwndT, pwndParent, (LPWSTR)3L);
            ThreadUnlock(&tlpwndParent);
            ThreadUnlock(&tlpwndT);
        }
        break;

    case WM_GETMINMAXINFO:
        ChildMinMaxInfo(pwnd, (PMINMAXINFO)lParam);
        break;

    case WM_SIZE:
        xxxChildResize(pwnd, (UINT)wParam);
        goto CallDWP;

    case WM_MOVE:
        if (!TestWF(pwnd, WFMAXIMIZED))
            RecalculateScrollRanges(pwndParent, FALSE);
        goto CallDWP;

    case WM_CHILDACTIVATE:
        ThreadLock(pwndParent, &tlpwndParent);
        xxxMDIActivate(pwndParent, pwnd);
        ThreadUnlock(&tlpwndParent);
        break;

    case WM_SYSCOMMAND:
        switch (wParam & 0xFFF0) {
        case SC_NEXTWINDOW:
        case SC_PREVWINDOW:
            hwndT = GetParent(hwnd);
            SendMessage(hwndT, WM_MDINEXT, (WPARAM)hwnd,
                    (DWORD)((wParam & 0xFFF0) == SC_PREVWINDOW));
            break;

        case SC_SIZE:
        case SC_MOVE:
            if (SAMEWOWHANDLE(hwnd, MAXED(pmdi))) {

                /*
                 * If a maxed child gets a size or move message, blow it
                 * off.
                 */
                break;
            } else
                goto CallDWP;

        case SC_MAXIMIZE:
            if (SAMEWOWHANDLE(hwnd, MAXED(pmdi))) {

                /*
                 * If a maxed child gets a maximize message, forward it
                 * to the frame.  Useful if the maximized child has a
                 * size box so that clicking on it then maximizes the
                 * parent.
                 */
                pwndT = REBASEPWND(pwndParent, spwndParent);
                ThreadLock(pwndT, &tlpwndT);
                lRet = SendMessage(HW(pwndT),
                        WM_SYSCOMMAND, SC_MAXIMIZE, lParam);
                ThreadUnlock(&tlpwndT);
                return lRet;
            }

            /*
             * else fall through
             */

        default:
            goto CallDWP;
        }
        break;

    default:
CallDWP:
        return DefWindowProcWorker(pwnd, wMsg, wParam, lParam, fAnsi);
    }

    return 0L;
}


/***************************************************************************\
* DefMDIChildProc
*
* Translates the message, calls DefMDIChildProc on server side.
*
* 04-11-91 ScottLu Created.
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, LRESULT, WINAPI, DefMDIChildProcW, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI DefMDIChildProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return DefMDIChildProcWorker(hwnd, message, wParam, lParam, FALSE);
}


FUNCLOG4(LOG_GENERAL, LRESULT, WINAPI, DefMDIChildProcA, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI DefMDIChildProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return DefMDIChildProcWorker(hwnd, message, wParam, lParam, TRUE);
}

BOOL MDICompleteChildCreation(HWND hwndChild, HMENU hSysMenu, BOOL fVisible, BOOL fDisabled) {
    PWND pwndChild;
    PWND  pwndClient;
    HWND  hwndClient;
    BOOL  fHasOwnSysMenu;
    PMDI pmdi;

    pwndChild = ValidateHwnd(hwndChild);
    pwndClient = REBASEPWND(pwndChild,spwndParent);
    hwndClient = HWq(pwndClient);

    fHasOwnSysMenu = (pwndChild->spmenuSys) ? TRUE : FALSE;

    pmdi = ((PMDIWND)(pwndClient))->pmdi;

    CKIDS(pmdi)++;
    ITILELEVEL(pmdi)++;
    if (ITILELEVEL(pmdi) > 0x7ffe)
        ITILELEVEL(pmdi) = 0;

    // Update "Window" menu if this new window should be on it
    if (fVisible && !fDisabled && (CKIDS(pmdi) <= MAXITEMS))
        SendMessage(hwndClient, WM_MDIREFRESHMENU, 0, 0L);

    //
    // Add the MDI System Menu.  Catch the case of not being able to add a
    // system menu (EG, guy doesn't have WS_SYSMENU style), and delete the
    // menu to avoid buildup in USER's heap.
    //
    if (hSysMenu && (fHasOwnSysMenu || !NtUserSetSystemMenu(hwndChild, hSysMenu)))
        NtUserDestroyMenu(hSysMenu);

    if (fVisible)
    {
        if (!TestWF(pwndChild, WFMINIMIZED) || !ACTIVE(pmdi))
        {
            NtUserSetWindowPos(hwndChild, HWND_TOP, 0, 0, 0, 0,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

            if (TestWF(pwndChild, WFMAXIMIZED) && !fHasOwnSysMenu)
            {
                PWND pwndParent = REBASEPWND(pwndClient, spwndParent);
                PMENU pmenu = REBASE(pwndParent, spmenu);
                MDIAddSysMenu(PtoH(pmenu), hwndChild);
                NtUserRedrawFrame(HW(pwndParent));
            }
        }
        else
        {
            NtUserShowWindow(hwndChild, SW_SHOWMINNOACTIVE);
        }
    }


    return TRUE;
}


BOOL
CreateMDIChild(
        PSHORTCREATE        psc,
        LPMDICREATESTRUCT   pmcs,
        DWORD               dwExpWinVerAndFlags,
        HMENU *             phSysMenu,
        PWND                pwndParent)
{
    BOOL fVisible;
    RECT rcT;
    HMENU hSysMenu = NULL;
    HWND hwndPrevMaxed;
    PMDI pmdi;

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)(pwndParent))->pmdi;

    pmcs->style = psc->style;

    // Mask off ignored style bits and add required ones.
    psc->style |= (WS_CHILD | WS_CLIPSIBLINGS);
    if (!(pwndParent->style & MDIS_ALLCHILDSTYLES))
    {
        psc->style &= WS_MDIALLOWED;
        psc->style |= (WS_MDISTYLE | WS_VISIBLE);
    }
    else if (psc->style & WS_POPUP)
    {
        RIPMSG0(RIP_ERROR, "CreateWindowEx: WS_POPUP not allowed on MDI children");
        if (LOWORD(dwExpWinVerAndFlags) >= VER40)
            return FALSE;
    }

    fVisible = ((psc->style & WS_VISIBLE) != 0L);

    //
    // Save ORIGINAL parameters in MDICREATESTRUCT.  This is for
    // compatibility with old WM_MDICREATE.
    //
    pmcs->x   = rcT.left   = psc->x;
    pmcs->y   = rcT.top    = psc->y;
    pmcs->cx  = rcT.right  = psc->cx;
    pmcs->cy  = rcT.bottom = psc->cy;

    MDICheckCascadeRect(pwndParent, &rcT);

    //
    // Setup creation coords
    //
    psc->x       = rcT.left;
    psc->y       = rcT.top;
    psc->cx      = rcT.right;
    psc->cy      = rcT.bottom;

    // Load the system menu
    if (psc->style & WS_SYSMENU) {
#ifdef LAME_BUTTON
        hSysMenu = xxxLoadSysMenu(CHILDSYSMENU, NULL);
#else
        hSysMenu = xxxLoadSysMenu(CHILDSYSMENU);
#endif // LAME_BUTTON

        if (hSysMenu == NULL) {
            return FALSE;
        }
    }


    // The window got created ok: now restore the current maximized window
    // so we can maximize ourself in its place.
    hwndPrevMaxed = MAXED(pmdi);
    if (fVisible && IsWindow(hwndPrevMaxed))
    {
        if (psc->style & WS_MAXIMIZE)
            SendMessage(hwndPrevMaxed, WM_SETREDRAW, (WPARAM)FALSE, 0L);

        // we could nuke the hwndPrevMaxed during the SendMessage32
        // so recheck just in case, B#11122, [t-arthb]

        if ( IsWindow(hwndPrevMaxed) )
        {
            NtUserMinMaximize(hwndPrevMaxed, SW_SHOWNORMAL, TRUE);

            if ( psc->style & WS_MAXIMIZE )
               SendMessage(hwndPrevMaxed, WM_SETREDRAW, (WPARAM)TRUE, 0L);
        }

    }

    // Set the proper Child Window ID for this MDI child.
    psc->hMenu = (HMENU)UIntToPtr( (FIRST(pmdi) + CKIDS(pmdi)) );

    *phSysMenu = hSysMenu;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\menuddc.c ===
/****************************** Module Header ******************************\
* Module Name: menudd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu drag and drop - client
*
* History:
* 10/29/96  GerardoB    Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop

/*
 * OLE's GUID initialization.
 */
#include "initguid.h"

/*
 * Macro to cast OLE's IDropTarget pointer to internal pointer.
 */
#define PMNIDT(pdt) ((PMNIDROPTARGET)pdt)

/*
 * The mndt* functions implement the IDropTarget interface.
 */
/**************************************************************************\
* mndtAddRef
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
ULONG mndtAddRef(
    LPDROPTARGET pdt)
{
    return ++(PMNIDT(pdt)->dwRefCount);
}

/**************************************************************************\
* mndtQueryInterface
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
HRESULT mndtQueryInterface(
    LPDROPTARGET pdt,
    REFIID riid,
    PVOID * ppvObj)
{
    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IDropTarget)) {
        mndtAddRef(pdt);
        *ppvObj = pdt;
        return NOERROR;
    } else {
        return E_NOINTERFACE;
    }
}


/**************************************************************************\
* mndtRelease
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
ULONG mndtRelease(
    LPDROPTARGET pdt)
{
    if (--(PMNIDT(pdt)->dwRefCount) != 0) {
        return PMNIDT(pdt)->dwRefCount;
    }

    UserLocalFree(pdt);

    return NOERROR;
}

/**************************************************************************\
* mndtDragOver
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
HRESULT mndtDragOver(
    LPDROPTARGET pdt,
    DWORD grfKeyState,
    POINTL ptl,
    LPDWORD pdwEffect)
{
    MNDRAGOVERINFO mndoi;
    MENUGETOBJECTINFO mngoi;

    /*
     * Get the dragover info for the selection corresponding to this point
     */
    if (!NtUserMNDragOver((POINT *)&ptl, &mndoi)) {
        RIPMSG0(RIP_WARNING, "mndtDragOver: NtUserDragOver failed");
        *pdwEffect = DROPEFFECT_NONE;
        return NOERROR;
    }

    /*
     * If not switching items or crossing gap boundaries, pass the
     *  the drag over.
     */
    if (!(mndoi.dwFlags & MNGOF_CROSSBOUNDARY)) {
        if (PMNIDT(pdt)->pidt != NULL) {
            return PMNIDT(pdt)->pidt->lpVtbl->DragOver(PMNIDT(pdt)->pidt, grfKeyState, ptl, pdwEffect);
        }
    } else {
        /*
         *  DragLeave and Release the current item, if any
         */
        if (PMNIDT(pdt)->pidt != NULL) {
            PMNIDT(pdt)->pidt->lpVtbl->DragLeave(PMNIDT(pdt)->pidt);
            PMNIDT(pdt)->pidt->lpVtbl->Release(PMNIDT(pdt)->pidt);
            PMNIDT(pdt)->pidt = NULL;
        }

        /*
         * If an item is selected, Get the interface for it
         */
        if (mndoi.uItemIndex != MFMWFP_NOITEM) {
            mngoi.hmenu = mndoi.hmenu;
            mngoi.dwFlags = mndoi.dwFlags & MNGOF_GAP;
            mngoi.uPos = mndoi.uItemIndex;
            mngoi.riid = (PVOID)&IID_IDropTarget;
            mngoi.pvObj = NULL;

            if (MNGO_NOERROR == SendMessage(mndoi.hwndNotify, WM_MENUGETOBJECT, 0, (LPARAM)&mngoi)) {
                PMNIDT(pdt)->pidt = mngoi.pvObj;
            }
        }

        /*
         * If we got a new interface, AddRef and DragEnter it.
         */
        if (PMNIDT(pdt)->pidt != NULL) {
            PMNIDT(pdt)->pidt->lpVtbl->AddRef(PMNIDT(pdt)->pidt);
            return PMNIDT(pdt)->pidt->lpVtbl->DragEnter(PMNIDT(pdt)->pidt, PMNIDT(pdt)->pido, grfKeyState, ptl, pdwEffect);
        }
    }

    *pdwEffect = DROPEFFECT_NONE;
    return NOERROR;
}

/**************************************************************************\
* mndtDragEnter
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
HRESULT mndtDragEnter(
    LPDROPTARGET pdt,
    LPDATAOBJECT pdo,
    DWORD grfKeyState,
    POINTL ptl,
    LPDWORD pdwEffect)
{
    /*
     * Save the IDataObject.
     */
    PMNIDT(pdt)->pido = pdo;

    /*
     * DragEnter is the same as a DragOver; only that we will never fail it.
     */
    mndtDragOver(pdt, grfKeyState, ptl, pdwEffect);

    return NOERROR;
}

/**************************************************************************\
* mndtDragLeave
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
HRESULT mndtDragLeave(
    LPDROPTARGET pdt)
{
    /*
     * Let the kernel mode clean up.
     */
    NtUserMNDragLeave();

    /*
     * DragLeave and Release the current item, if any.
     */
    if (PMNIDT(pdt)->pidt != NULL) {
        PMNIDT(pdt)->pidt->lpVtbl->DragLeave(PMNIDT(pdt)->pidt);
        PMNIDT(pdt)->pidt->lpVtbl->Release(PMNIDT(pdt)->pidt);
        PMNIDT(pdt)->pidt = NULL;
    }

    return NOERROR;
}

/**************************************************************************\
* mndtDrop
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
HRESULT mndtDrop(
    LPDROPTARGET pdt,
    LPDATAOBJECT pdo,
    DWORD grfKeyState,
    POINTL ptl,
    LPDWORD pdwEffect)
{
    HRESULT hres;

    /*
     * If we got a target, pass the drop and release it.
     */
    if (PMNIDT(pdt)->pidt != NULL) {
        hres = PMNIDT(pdt)->pidt->lpVtbl->Drop(PMNIDT(pdt)->pidt, pdo, grfKeyState, ptl, pdwEffect);
        PMNIDT(pdt)->pidt->lpVtbl->Release(PMNIDT(pdt)->pidt);
        PMNIDT(pdt)->pidt = NULL;
    } else {
        *pdwEffect = DROPEFFECT_NONE;
        hres = NOERROR;
    }

    /*
     * Clean up.
     */
    mndtDragLeave(pdt);

    return hres;
}

/**************************************************************************\
* Drop target VTable
*
\**************************************************************************/
IDropTargetVtbl idtVtbl = {
    mndtQueryInterface,
    mndtAddRef,
    mndtRelease,
    mndtDragEnter,
    mndtDragOver,
    mndtDragLeave,
    mndtDrop
};

/**************************************************************************\
* __ClientRegisterDragDrop
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
DWORD __ClientRegisterDragDrop(
    HWND * phwnd)
{
    HRESULT hres = STATUS_UNSUCCESSFUL;
    PMNIDROPTARGET pmnidt;

    /*
     * Allocate the IDropTarget interface struct & additional data.
     */
    pmnidt = (PMNIDROPTARGET)UserLocalAlloc(HEAP_ZERO_MEMORY,
                                            sizeof(MNIDROPTARGET));
    if (pmnidt == NULL) {
        RIPMSG0(RIP_WARNING, "__ClientRegisterDragDrop allocation Failed");
        hres = STATUS_UNSUCCESSFUL;
        goto BackToKernel;
    }

    /*
     * Initialize it
     */
    pmnidt->idt.lpVtbl = &idtVtbl;

    /*
     * Call RegisterDragDrop
     */
    hres = (*(REGISTERDDPROC)gpfnOLERegisterDD)(*phwnd, (LPDROPTARGET)pmnidt);
    if (!SUCCEEDED(hres)) {
        RIPMSG1(RIP_WARNING, "__ClientRegisterDragDrop Failed:%#lx", hres);
    }

BackToKernel:
    return UserCallbackReturn(NULL, 0, hres);
}

/**************************************************************************\
* __ClientRevokeDragDrop
*
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
DWORD __ClientRevokeDragDrop(
    HWND * phwnd)
{
    HRESULT hres;

    /*
     * Call RevokeDragDrop.
     */
    hres = (*(REVOKEDDPROC)gpfnOLERevokeDD)(*phwnd);
    if (!SUCCEEDED(hres)) {
        RIPMSG1(RIP_WARNING, "__ClientRevokeDragDrop Failed: 0x%x", hres);
    }

    return UserCallbackReturn(NULL, 0, hres);
}

/**************************************************************************\
* LoadOLEOnce
*
*
* 10/31/96 GerardoB     Created
\**************************************************************************/
NTSTATUS LoadOLEOnce(
    VOID)
{
    NTSTATUS Status;
    OLEINITIALIZEPROC pfnOLEOleInitialize;

    /*
     * These are the functions that we'll call.
     */
    GETPROCINFO gpi [] = {
        {&((FARPROC)pfnOLEOleInitialize), (LPCSTR)"OleInitialize"},
        {&gpfnOLEOleUninitialize, (LPCSTR)"OleUninitialize"},
        {&gpfnOLERegisterDD, (LPCSTR)"RegisterDragDrop"},
        {&gpfnOLERevokeDD, (LPCSTR)"RevokeDragDrop"},
        {NULL, NULL}
    };

    GETPROCINFO * pgpi = gpi;

    /*
     * We should come here only once
     */
    UserAssert(ghinstOLE == NULL);

    /*
     * Load it
     */
    ghinstOLE = LoadLibrary(L"OLE32.DLL");
    if (ghinstOLE == NULL) {
        RIPMSG1(RIP_WARNING, "LoadOLEOnce: Failed to load OLE32.DLL: %#lx", GetLastError());
        goto OLEWontLoad;
    }

    /*
     * Get the address of all procs
     */
    while (pgpi->ppfn != NULL) {
        *(pgpi->ppfn) = GetProcAddress(ghinstOLE, pgpi->lpsz);
        if (*(pgpi->ppfn) == NULL) {
            RIPMSG2(RIP_WARNING, "LoadOLEOnce: GetProcAddress failed: '%s': %#lx",
                    pgpi->lpsz, GetLastError());
            break;
        }
        pgpi++;
    }

    /*
     * If it got all procs, call OleInitialize.
     */
    if (pgpi->ppfn == NULL) {
        Status = (*pfnOLEOleInitialize)(NULL);
        if (SUCCEEDED(Status)) {
            goto BackToKernel;
        } else {
            RIPMSG1(RIP_WARNING, "LoadOLEOnce: OleInitialize failed:%#lx", Status);
        }
    }

    /*
     * Something failed; NULL out all function pointers, free the library,
     * and mark ghinstOLE so we won't come back here.
     */
    pgpi = gpi;
    while (pgpi->ppfn != NULL) {
        *(pgpi->ppfn) = NULL;
        pgpi++;
    }
    FreeLibrary(ghinstOLE);

OLEWontLoad:
    ghinstOLE = OLEWONTLOAD;
    Status = STATUS_UNSUCCESSFUL;

BackToKernel:
    return Status;
}

/**************************************************************************\
* __ClientLoadOLE
*
*
* 10/31/96 GerardoB     Created
\**************************************************************************/
DWORD __ClientLoadOLE(
    PVOID p)
{

    NTSTATUS Status;

    UNREFERENCED_PARAMETER(p);

    if (ghinstOLE == NULL) {
        Status = LoadOLEOnce();
    } else if (ghinstOLE == OLEWONTLOAD) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        UserAssert(gpfnOLERegisterDD != NULL);
        UserAssert(gpfnOLERevokeDD != NULL);
        Status = STATUS_SUCCESS;
    }

    return UserCallbackReturn(NULL, 0, Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\mngrayc.c ===
/****************************** Module Header ******************************\
* Module Name: mngray.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the DrawState API
*
* History:
* 01-05-94  FritzS  Ported from Chicago
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define PATOR               0x00FA0089L
#define SRCSTENCIL          0x00B8074AL
#define SRCINVSTENCIL       0x00E20746L

#define BC_INVERT             0x00000001

void BltColor(HDC hdc, HBRUSH hbr, HDC hdcSrce,int xO, int yO,
       int cx, int cy, int xO1, int yO1, UINT uBltFlags);
/***************************************************************************\
*
*  BitBltSysBmp()
*
*  From Chicago -- client *only* for now.
\***************************************************************************/
BOOL FAR BitBltSysBmp(HDC hdc, int x, int y, UINT i)
{
    POEMBITMAPINFO pOem = gpsi->oembmi + i;

    return(NtUserBitBltSysBmp(hdc, x, y, pOem->cx, pOem->cy, pOem->x, pOem->y, SRCCOPY));
}


/***************************************************************************\
*
*  DrawState()
*
*  Generic state drawing routine.  Does simple drawing into same DC if
*  normal state;  uses offscreen bitmap otherwise.
*
*  We do drawing for these simple types ourselves:
*      (1) Text
*          lData is string pointer.
*          wData is string length
*      (2) Icon
*          LOWORD(lData) is hIcon
*      (3) Bitmap
*          LOWORD(lData) is hBitmap
*      (4) Glyph (internal)
*          LOWORD(lData) is OBI_ value, one of
*              OBI_CHECKMARK
*              OBI_BULLET
*              OBI_MENUARROW
*          right now
*
*  Other types are required to draw via the callback function, and are
*  allowed to stick whatever they want in lData and wData.
*
*  We apply the following effects onto the image:
*      (1) Normal      (nothing)
*      (2) Default     (drop shadow)
*      (3) Union       (gray string dither)
*      (4) Disabled    (embossed)
*
*  Note that we do NOT stretch anything.  We just clip.
*
*
*   FritzS note -- this is client-side *only*.  Similar code is in server\mngray.c
*
*
\***************************************************************************/

FUNCLOG10(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DrawStateW, HDC, hdcDraw, HBRUSH, hbrFore, DRAWSTATEPROC, qfnCallBack, LPARAM, lData, WPARAM, wData, int, x, int, y, int, cx, int, cy, UINT, uFlags)
BOOL DrawStateW(
    HDC             hdcDraw,
    HBRUSH          hbrFore,
    DRAWSTATEPROC   qfnCallBack,
    LPARAM          lData,
    WPARAM          wData,
    int             x,
    int             y,
    int             cx,
    int             cy,
    UINT            uFlags)
{
    HFONT   hFont;
    HFONT   hFontSave = NULL;
    HDC     hdcT;
    HBITMAP hbmpT;
    BOOL    fResult = FALSE;
    DWORD   dwPSMFlags;
    POINT   ptOrg;
    int     oldAlign;
    DWORD   dwLayout = GDI_ERROR;

    if (ghdcGray == NULL)
        return FALSE;

    RtlEnterCriticalSection(&gcsHdc);

    /*
     * These require monochrome conversion
     *
     * Enforce monochrome: embossed doesn't look great with 2 color displays
     */
    if ((uFlags & DSS_DISABLED) &&
        (gpsi->BitCount == 1 || SYSMET(SLOWMACHINE))) {

        uFlags &= ~DSS_DISABLED;
        uFlags |= DSS_UNION;
    }

    if (uFlags & (DSS_DISABLED | DSS_DEFAULT | DSS_UNION))
        uFlags |= DSS_MONO;

    /*
     * Get drawing sizes etc. AND VALIDATE.
     */
    switch (uFlags & DST_TYPEMASK) {

        case DST_GLYPH:

            /*
             * LOWORD(lData) is OBI_ value.
             */
            if (LOWORD(lData) >= (WORD)OBI_COUNT) {
                goto CDS_Leave;
            }

            if (!cx) {
                cx = gpsi->oembmi[LOWORD(lData)].cx;
            }

            if (!cy) {
                cy = gpsi->oembmi[LOWORD(lData)].cy;
            }

            break;

        case DST_BITMAP:

            /*
             * LOWORD(lData) is hbmp.
             */
            if (GetObjectType((HGDIOBJ)lData) != OBJ_BITMAP) {
                goto CDS_Leave;
            }

            if (!cx || !cy) {

                BITMAP bmp;

                GetObjectW((HGDIOBJ)lData, sizeof(BITMAP), &bmp);

                if (!cx)
                    cx = bmp.bmWidth;

                if (!cy)
                    cy = bmp.bmHeight;
            }
            break;

        case DST_ICON:

            /*
             * lData is hicon.
             */
            if (!cx || !cy) {

                int cx1 = 0;
                int cy1 = 0;

                NtUserGetIconSize((HICON)lData, 0, &cx1, &cy1);

                if (!cx)
                    cx = cx1;

                if (!cy)
                    cy = cy1 / 2; // icons are double height in NT
            }
            break;

        case DST_TEXT:

            /*
             * lData is LPSTR
             * NOTE THAT WE DO NOT VALIDATE lData, DUE TO COMPATIBILITY
             * WITH GRAYSTRING().  THIS _SHOULD_ FAULT IF YOU PASS IN NULL.
             *
             * wData is cch.
             */
            if (!wData)
                wData = wcslen((LPWSTR)lData);

            if (!cx || !cy) {

                SIZE size;

                /*
                 * Make sure we use right dc w/ right font.
                 */
                GetTextExtentPointW(hdcDraw, (LPWSTR)lData, (INT)wData, &size);

                if (!cx)
                    cx = size.cx;

                if (!cy)
                    cy = size.cy;

            }

            /*
             * Now, pretend we're complex if qfnCallBack is supplied AND
             * we're supporting GrayString().
             */
#if 0 // This will get turned on if/when we change GrayString to tie
      // into DrawState.
      //
      // FritzS
            if ((uFlags & DST_GRAYSTRING) && SELECTOROF(qfnCallBack)) {
                uFlags &= ~DST_TYPEMASK;
                uFlags |= DST_COMPLEX;
            }
#endif
            break;

        case DST_PREFIXTEXT:

            if (lData == 0) {
                RIPMSG0(RIP_ERROR, "DrawState: NULL DST_PREFIXTEXT string");
                goto CDS_Leave;
            }

            if (!wData)
                wData = wcslen((LPWSTR)lData);

            if (!cx || !cy) {

                SIZE size;

                PSMGetTextExtent(hdcDraw, (LPWSTR)lData, (int)wData, &size);

                if (!cx)
                    cx = size.cx;

                if (!cy)
                    cy = size.cy;
            }

            /*
             * Add on height for prefix
             */
            cy += (2 * SYSMET(CYBORDER));
            break;

        case DST_COMPLEX:
#if 0
            if (!SELECTOROF(qfnCallBack)) {
                DebugErr(DBF_ERROR, "DrawState: invalid callback for DST_COMPLEX");
                goto CDS_Leave;
            }
#endif
            break;

        default:
            RIPMSG0(RIP_ERROR, "DrawState: invalid DST_ type");
            goto CDS_Leave;
    }

    /*
     * Optimize:  nothing to draw
     * Have to call callback if GRAYSTRING for compatibility.
     */
    if ((!cx || !cy)
//        && !(uFlags & DST_GRAYSTRING)
    ) {
        fResult = TRUE;
        goto CDS_Leave;
    }

    /*
     * Setup drawing dc
     */
    if (uFlags & DSS_MONO) {

        hdcT = ghdcGray;
        /*
         * First turn off mirroring on hdcGray if any.
         */
        SetLayoutWidth(hdcT, -1, 0);
        /*
         * Set the ghdcGray layout to be equal to the screen hdcDraw layout.
         */
        dwLayout = GetLayout(hdcDraw);
        if (dwLayout != GDI_ERROR) {
            SetLayoutWidth(hdcT, cx, dwLayout);
        }

        /*
         * Is our scratch bitmap big enough?  We need potentially
         * cx+1 by cy pixels for default etc.
         */
        if ((gcxGray < cx + 1) || (gcyGray < cy)) {

            if (hbmpT = CreateBitmap(max(gcxGray, cx + 1), max(gcyGray, cy), 1, 1, 0L)) {

                HBITMAP hbmGray;

                hbmGray = SelectObject(ghdcGray, hbmpT);
                DeleteObject(hbmGray);

                gcxGray = max(gcxGray, cx + 1);
                gcyGray = max(gcyGray, cy);

            } else {
                cx = gcxGray - 1;
                cy = gcyGray;
            }
        }

        PatBlt(ghdcGray, 0, 0, gcxGray, gcyGray, WHITENESS);
        SetTextCharacterExtra(ghdcGray, GetTextCharacterExtra(hdcDraw));

        oldAlign = GetTextAlign(hdcT);
        SetTextAlign(hdcT, (oldAlign & ~(TA_RTLREADING |TA_CENTER |TA_RIGHT))
                     | (GetTextAlign(hdcDraw) & (TA_RTLREADING |TA_CENTER |TA_RIGHT)));

        /*
         * Setup font
         */
        if ((uFlags & DST_TYPEMASK) <= DST_TEXTMAX) {

            if (GetCurrentObject(hdcDraw, OBJ_FONT) != ghFontSys) {
                hFont = SelectObject(hdcDraw, ghFontSys);
                SelectObject(hdcDraw, hFont);
                hFontSave = SelectObject(ghdcGray, hFont);
            }
        }

    } else {

        hdcT = hdcDraw;

        /*
         * Adjust viewport
         */
        GetViewportOrgEx(hdcT, &ptOrg);
        SetViewportOrgEx(hdcT, ptOrg.x + x, ptOrg.y + y, NULL);
    }

    /*
     * Now, draw original image
     */
    fResult = TRUE;

    switch (uFlags & DST_TYPEMASK) {

        case DST_GLYPH:
            /*
             * Blt w/ current brush in hdcT
             */
            BitBltSysBmp(hdcT, 0, 0, LOWORD(lData));
            break;

        case DST_BITMAP:
            /*
             * Draw the bitmap.  If mono, it'll use the colors set up
             * in the dc.
             */
//            RtlEnterCriticalSection(&gcsHdcBits2);
            UserAssert(GetBkColor(ghdcBits2) == RGB(255, 255, 255));
            UserAssert(GetTextColor(ghdcBits2) == RGB(0, 0, 0));

            hbmpT = SelectObject(ghdcBits2, (HBITMAP)lData);
            BitBlt(hdcT, 0, 0, cx, cy, ghdcBits2, 0, 0, SRCCOPY);
            SelectObject(ghdcBits2, hbmpT);
//            RtlLeaveCriticalSection(&gcsHdcBits2);
            break;

        case DST_ICON:
            /*
             * Draw the icon.
             */
            DrawIconEx(hdcT, 0, 0, (HICON)lData, 0, 0, 0, NULL, DI_NORMAL);
            break;

        case DST_PREFIXTEXT:
            if (uFlags & DSS_HIDEPREFIX) {
                dwPSMFlags = DT_HIDEPREFIX;
            } else if (uFlags & DSS_PREFIXONLY) {
                dwPSMFlags = DT_PREFIXONLY;
            } else {
                dwPSMFlags = 0;
            }
            PSMTextOut(hdcT, 0, 0, (LPWSTR)lData, (int)wData, dwPSMFlags);
            break;

        case DST_TEXT:
            fResult = TextOutW(hdcT, 0, 0, (LPWSTR)lData, (int)wData);
            break;

        default:

            fResult = (qfnCallBack)(hdcT, lData, wData, cx, cy);

            /*
             * The callbacks could have altered the attributes of ghdcGray
             */
            if (hdcT == ghdcGray) {
                SetBkColor(ghdcGray, RGB(255, 255, 255));
                SetTextColor(ghdcGray, RGB(0, 0, 0));
                SelectObject(ghdcGray, GetStockObject(BLACK_BRUSH));
                SetBkMode(ghdcGray, OPAQUE);
            }
            break;
    }

    /*
     * Clean up
     */
    if (uFlags & DSS_MONO) {
        /*
         * Reset font
         */
        if (hFontSave)
            SelectObject(hdcT, hFontSave);
        SetTextAlign(hdcT, oldAlign);
    } else {
        /*
         * Reset DC.
         */
        SetViewportOrgEx(hdcT, ptOrg.x, ptOrg.y, NULL);
        goto CDS_Leave;
    }

    /*
     * UNION state
     * Dither over image
     * We want white pixels to stay white, in either dest or pattern.
     */
    if (uFlags & DSS_UNION) {

        POLYPATBLT PolyData;

        PolyData.x         = 0;
        PolyData.y         = 0;
        PolyData.cx        = cx;
        PolyData.cy        = cy;
        PolyData.BrClr.hbr = gpsi->hbrGray;

        PolyPatBlt(ghdcGray, PATOR, &PolyData, 1, PPB_BRUSH);
    }

    /*
     * DISABLED state
     * Emboss
     * Draw over-1/down-1 in hilight color, and in same position in shadow.
     *
     * DEFAULT state
     * Drop shadow
     * Draw over-1/down-1 in shadow color, and in same position in foreground
     * Draw offset down in shadow color,
     */
    if (uFlags & DSS_DISABLED) {

        BltColor(hdcDraw,
                 SYSHBR(3DHILIGHT),
                 ghdcGray,
                 x + 1,
                 y + 1,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

        BltColor(hdcDraw,
                 SYSHBR(3DSHADOW),
                 ghdcGray,
                 x,
                 y,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

    } else if (uFlags & DSS_DEFAULT) {

        BltColor(hdcDraw,
                 SYSHBR(3DSHADOW),
                 ghdcGray,
                 x+1,
                 y+1,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

        goto DrawNormal;

    } else {

DrawNormal:

        BltColor(hdcDraw, hbrFore, ghdcGray, x, y, cx, cy, 0, 0, BC_INVERT);
    }

CDS_Leave:

    if (uFlags & DSS_MONO) {
        /*
         * Set the ghdcGray layout to 0, it is a public DC.
         */
        if (dwLayout != GDI_ERROR) {
            SetLayoutWidth(hdcT, -1, 0);
        }
    }
    RtlLeaveCriticalSection(&gcsHdc);

    return fResult;
}


FUNCLOG10(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DrawStateA, HDC, hDC, HBRUSH, hBrush, DRAWSTATEPROC, func, LPARAM, lParam, WPARAM, wParam, int, x, int, y, int, cx, int, cy, UINT, wFlags)
BOOL DrawStateA(HDC hDC, HBRUSH hBrush, DRAWSTATEPROC func,
    LPARAM lParam, WPARAM wParam, int x, int y, int cx, int cy, UINT wFlags)
{

    LPARAM lpwstr = lParam;
    BOOL bRet;
    BOOL bFree;

    if (((wFlags & DST_TYPEMASK) == DST_TEXT) ||
        ((wFlags & DST_TYPEMASK) == DST_PREFIXTEXT)) {

        bFree = TRUE;

        if ((wParam = MBToWCS((LPSTR)lParam, wParam ? (int)wParam : USER_AWCONV_COUNTSTRINGSZ, &(LPWSTR)lpwstr, -1, TRUE)) == 0)
            return FALSE;
    } else {
        bFree = FALSE;
    }

    bRet = DrawStateW(hDC, hBrush, func, lpwstr, wParam, x, y, cx, cy, wFlags);

    if (bFree) {
        UserLocalFree((HANDLE)lpwstr);
    }
    return bRet;
}

/***************************************************************************\
* BltColor
*
* History:
\***************************************************************************/

void BltColor(
    HDC hdc,
    HBRUSH hbr,
    HDC hdcSrce,
    int xO,
    int yO,
    int cx,
    int cy,
    int xO1,
    int yO1,
    UINT uBltFlags
)
{
    HBRUSH hbrSave;
    HBRUSH hbrNew = NULL;
    DWORD  textColorSave;
    DWORD  bkColorSave;

    if (hbr == (HBRUSH)NULL) {
        LOGBRUSH lb;

        lb.lbStyle = BS_SOLID;
        lb.lbColor = GetSysColor(COLOR_WINDOWTEXT);
        hbrNew = hbr = CreateBrushIndirect(&lb);
    }

    /*
     * Set the Text and Background colors so that bltColor handles the
     * background of buttons (and other bitmaps) properly.
     * Save the HDC's old Text and Background colors.  This causes problems with
     * Omega (and probably other apps) when calling GrayString which uses this
     * routine...
     */
    textColorSave = SetTextColor(hdc, 0x00000000L);
    bkColorSave = SetBkColor(hdc, 0x00FFFFFFL);

    hbrSave = SelectObject(hdc, hbr);

    BitBlt(hdc, xO, yO, cx, cy, hdcSrce,
        xO1, yO1, ((uBltFlags & BC_INVERT) ? 0xB8074AL : 0xE20746L));
        //xO1, yO1, (fInvert ? 0xB80000 : 0xE20000));

    SelectObject(hdc, hbrSave);

    /*
     * Restore saved colors
     */
    SetTextColor(hdc, textColorSave);
    SetBkColor(hdc, bkColorSave);

    if (hbrNew) {
        DeleteObject(hbrNew);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\monitor.c ===
/****************************** Module Header ******************************\
* Module Name: monitor.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager client side DDESPY monitoring functions.
*
* Created: 11/20/91 Sanford Staab
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


//
// Other monitor events are initiated directly from SetLastDDEMLError()
// and DoCallback().
//

/***************************************************************************\
* MonitorStringHandle
*
* Description:
* Launches a string handle monitor event. This function should be
* invoked via the MONHSZ() macro so as not to slow down things much
* when no DDESpy is running.
*
* History:
* 11-26-91 sanfords Created.
\***************************************************************************/
VOID MonitorStringHandle(
PCL_INSTANCE_INFO pcii,
HSZ hsz, // local atom
DWORD fsAction)
{
    WCHAR szT[256];
    PEVENT_PACKET pep;
    DWORD cchString;

    CheckDDECritIn;

    UserAssert(pcii->MonitorFlags & MF_HSZ_INFO);

    if (!(cchString = GetAtomName(LATOM_FROM_HSZ(hsz), szT,
            sizeof(szT) / sizeof(WCHAR)))) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        return ;
    }
    cchString++;
    pep = (PEVENT_PACKET)DDEMLAlloc(sizeof(EVENT_PACKET) - sizeof(DWORD) +
            sizeof(MONHSZSTRUCT) + cchString * sizeof(WCHAR));
    if (pep == NULL) {
        SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
        return ;
    }

    pep->EventType =    MF_HSZ_INFO;
    pep->fSense =       TRUE;
    pep->cbEventData =  (WORD)(sizeof(MONHSZSTRUCT) + cchString * sizeof(WCHAR));

#define phszs ((MONHSZSTRUCT *)&pep->Data)
    phszs->cb =      sizeof(MONHSZSTRUCT);
    phszs->fsAction = fsAction;
    phszs->dwTime =  NtGetTickCount();
    phszs->hsz = hsz;
    phszs->hTask = (HANDLE)LongToHandle( pcii->tid );
    // phszs->wReserved = 0; // zero init.
    wcscpy(phszs->str, szT);

    LeaveDDECrit;
    Event(pep);
    EnterDDECrit;
#undef phszs
}




/***************************************************************************\
* MonitorLink
*
* Description:
* Launches a link monitor event. This function should be
* invoked via the MONLINK() macro so as not to slow down things much
* when no DDESpy is running.
*
* History:
* 11-26-91 sanfords Created.
\***************************************************************************/
VOID MonitorLink(
PCL_INSTANCE_INFO pcii,
BOOL fEstablished,
BOOL fNoData,
LATOM aService,
LATOM aTopic,
GATOM aItem,
WORD wFmt,
BOOL fServer,
HCONV hConvServer,
HCONV hConvClient)
{
    PEVENT_PACKET pep;

    CheckDDECritIn;

    UserAssert(pcii->MonitorFlags & MF_LINKS);

    pep = (PEVENT_PACKET)DDEMLAlloc(sizeof(EVENT_PACKET) - sizeof(DWORD) +
            sizeof(MONLINKSTRUCT));
    if (pep == NULL) {
        SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
        return ;
    }

    pep->EventType =    MF_LINKS;
    pep->fSense =       TRUE;
    pep->cbEventData =  sizeof(MONLINKSTRUCT);

#define pls ((MONLINKSTRUCT *)&pep->Data)
    pls->cb =           sizeof(MONLINKSTRUCT);
    pls->dwTime =       NtGetTickCount();
    pls->hTask =        (HANDLE)LongToHandle( pcii->tid );
    pls->fEstablished = fEstablished;
    pls->fNoData =      fNoData;

    // use global atoms here - these need to be changed to local atoms before
    // the callbacks to the ddespy apps.

    pls->hszSvc =       (HSZ)LocalToGlobalAtom(aService);
    pls->hszTopic =     (HSZ)LocalToGlobalAtom(aTopic);
    IncGlobalAtomCount(aItem);
    pls->hszItem =      (HSZ)aItem;

    pls->wFmt =         wFmt;
    pls->fServer =      fServer;
    pls->hConvServer =  hConvServer;
    pls->hConvClient =  hConvClient;

    LeaveDDECrit;
    Event(pep);
    EnterDDECrit;

    GlobalDeleteAtom((ATOM)(ULONG_PTR)pls->hszSvc);
    GlobalDeleteAtom((ATOM)(ULONG_PTR)pls->hszTopic);
    GlobalDeleteAtom(aItem);
#undef pls
}




/***************************************************************************\
* MonitorConv
*
* Description:
* Launches a conversation monitor event. This function should be
* invoked via the MONCONV() macro so as not to slow down things much
* when no DDESpy is running.
*
* History:
* 11-26-91 sanfords Created.
* 5-8-92   sanfords Since the hConv's mean nothing outside this process,
*                   the hConv fields now hold hwnds.  This lets DDESPY
*                   tie together connect and disconnect events from each
*                   side.
\***************************************************************************/
VOID MonitorConv(
PCONV_INFO pcoi,
BOOL fConnect)
{
    PEVENT_PACKET pep;

    CheckDDECritIn;

    UserAssert(pcoi->pcii->MonitorFlags & MF_CONV);

    pep = (PEVENT_PACKET)DDEMLAlloc(sizeof(EVENT_PACKET) - sizeof(DWORD) +
            sizeof(MONCONVSTRUCT));
    if (pep == NULL) {
        SetLastDDEMLError(pcoi->pcii, DMLERR_MEMORY_ERROR);
        return ;
    }

    pep->EventType =    MF_CONV;
    pep->fSense =       TRUE;
    pep->cbEventData =  sizeof(MONCONVSTRUCT);

#define pcs ((MONCONVSTRUCT *)&pep->Data)
    pcs->cb =           sizeof(MONCONVSTRUCT);
    pcs->fConnect =     fConnect;
    pcs->dwTime =       NtGetTickCount();
    pcs->hTask =        (HANDLE)LongToHandle( pcoi->pcii->tid );
    pcs->hszSvc =       (HSZ)LocalToGlobalAtom(pcoi->laService);
    pcs->hszTopic =     (HSZ)LocalToGlobalAtom(pcoi->laTopic);
    if (pcoi->state & ST_CLIENT) {
        pcs->hConvClient =  (HCONV)pcoi->hwndConv;
        pcs->hConvServer =  (HCONV)pcoi->hwndPartner;
    } else {
        pcs->hConvClient =  (HCONV)pcoi->hwndPartner;
        pcs->hConvServer =  (HCONV)pcoi->hwndConv;
    }

    LeaveDDECrit;
    Event(pep);
    EnterDDECrit;

    GlobalDeleteAtom((ATOM)(ULONG_PTR)pcs->hszSvc);
    GlobalDeleteAtom((ATOM)(ULONG_PTR)pcs->hszTopic);
#undef pcs
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\msgbox.c ===
/****************************** Module Header ******************************\
* Module Name: msgbox.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the MessageBox API and related functions.
*
* History:
* 10-23-90 DarrinM     Created.
* 02-08-91 IanJa       HWND revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

//
// Dimension constants  --  D.U. == dialog units
//
#define DU_OUTERMARGIN    7
#define DU_INNERMARGIN    10

#define DU_BTNGAP         4   // D.U. of space between buttons
#define DU_BTNHEIGHT      14  // D.U. of button height
// This is used only in kernel\inctlpan.c, so move it there
//
// #define DU_BTNWIDTH       50  // D.U. of button width, minimum
//

LPBYTE MB_UpdateDlgHdr(LPDLGTEMPLATE lpDlgTmp, long lStyle, long lExtendedStyle, BYTE bItemCount,
           int iX, int iY, int iCX, int iCY, LPWSTR lpszCaption, int iCaptionLen);
LPBYTE MB_UpdateDlgItem(LPDLGITEMTEMPLATE lpDlgItem, int iCtrlId, long lStyle, long lExtendedStyle,
           int iX, int iY, int iCX, int iCY, LPWSTR lpszText, UINT wTextLen,
           int iControlClass);
UINT   MB_GetIconOrdNum(UINT rgBits);
LPBYTE MB_AddPushButtons(
    LPDLGITEMTEMPLATE lpDlgTmp,
    LPMSGBOXDATA      lpmb,
    UINT wLEdge,
    UINT wBEdge);
UINT MB_FindDlgTemplateSize( LPMSGBOXDATA lpmb );
int MessageBoxWorker(LPMSGBOXDATA pMsgBoxParams);
VOID EndTaskModalDialog(HWND hwndDlg);
VOID StartTaskModalDialog(HWND hwndDlg);

#ifdef _JANUS_

#include "strid.h"
#include <imagehlp.h>

// constant strings
CONST WCHAR szEMIKey[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Error Message Instrument\\";
CONST WCHAR szEMIEnable[] = L"EnableLogging";
CONST WCHAR szEMISeverity[] = L"LogSeverity";
CONST WCHAR szDMREnable[] = L"EnableDefaultReply";
CONST WCHAR szEventKey[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\EventLog\\Application\\Error Instrument\\";
CONST WCHAR szEventMsgFile[] = L"EventMessageFile";
CONST WCHAR szEventType[] = L"TypesSupported";

#define TITLE_SIZE          64
#define DATETIME_SIZE       32

#define EMI_SEVERITY_ALL          0
#define EMI_SEVERITY_USER         1
#define EMI_SEVERITY_INFORMATION  2
#define EMI_SEVERITY_QUESTION     3
#define EMI_SEVERITY_WARNING      4
#define EMI_SEVERITY_ERROR        5
#define EMI_SEVERITY_MAX_VALUE    5

// element of error message
PVOID gpReturnAddr = 0;
HANDLE gdwEMIThreadID = 0;
typedef struct _ERROR_ELEMENT {
    WCHAR       ProcessName[MAX_PATH];
    WCHAR       WindowTitle[TITLE_SIZE];
    DWORD       dwStyle;
    DWORD       dwErrorCode;
    WCHAR       CallerModuleName[MAX_PATH];
    PVOID       BaseAddr;
    DWORD       dwImageSize;
    PVOID       ReturnAddr;
    LPWSTR      lpszCaption;
    LPWSTR      lpszText;
} ERROR_ELEMENT, *LPERROR_ELEMENT;

BOOL ErrorMessageInst(LPMSGBOXDATA pMsgBoxParams);
BOOL InitInstrument(LPDWORD lpEMIControl);

// eventlog stuff
HANDLE gEventSource;
NTSTATUS CreateLogSource();
BOOL LogMessageBox(LPERROR_ELEMENT lpErrEle);

#define EMIGETRETURNADDRESS()                                    \
{                                                                \
    if (gfEMIEnable) {                                           \
        if (InterlockedCompareExchangePointer(&gdwEMIThreadID,   \
                                              GETTHREADID(),     \
                                              0)                 \
             == 0) {                                             \
            gpReturnAddr = (PVOID) 1; \
        }                                                        \
    }                                                            \
}

// _ReturnAddress();
#else
#define EMIGETRETURNADDRESS()
#endif //_JANUS_



#define MB_MASKSHIFT    4

static CONST WCHAR szEmpty[] = L"";
WCHAR szERROR[10];

/***************************************************************************\
* SendHelpMessage
*
*
\***************************************************************************/
VOID
SendHelpMessage(
    HWND   hwnd,
    int    iType,
    int    iCtrlId,
    HANDLE hItemHandle,
    DWORD  dwContextId,
    MSGBOXCALLBACK lpfnCallback)
{
    HELPINFO    HelpInfo;
    long        lValue;

    HelpInfo.cbSize = sizeof(HELPINFO);
    HelpInfo.iContextType = iType;
    HelpInfo.iCtrlId = iCtrlId;
    HelpInfo.hItemHandle = hItemHandle;
    HelpInfo.dwContextId = dwContextId;

    lValue = NtUserGetMessagePos();
    HelpInfo.MousePos.x = GET_X_LPARAM(lValue);
    HelpInfo.MousePos.y = GET_Y_LPARAM(lValue);

    // Check if there is an app supplied callback.
    if (lpfnCallback != NULL) {
        if (IsWOWProc(lpfnCallback)) {
            (*pfnWowMsgBoxIndirectCallback)(PtrToUlong(lpfnCallback), &HelpInfo);
        } else {
            (*lpfnCallback)(&HelpInfo);
        }
    } else {
        SendMessage(hwnd, WM_HELP, 0, (LPARAM)&HelpInfo);
    }
}


/***************************************************************************\
* ServiceMessageBox
*
*
\***************************************************************************/

CONST int aidReturn[] = { 0, 0, IDABORT, IDCANCEL, IDIGNORE, IDNO, IDOK, IDRETRY, IDYES };

int ServiceMessageBox(
    LPCWSTR pText,
    LPCWSTR pCaption,
    UINT wType,
    DWORD dwTimeout)
{
    NTSTATUS Status;
    ULONG_PTR Parameters[4];
    ULONG Response = ResponseNotHandled;
    UNICODE_STRING Text, Caption;

    /*
     * For Terminal Services we must decided the session in which this message
     * box should be displayed.  We do this by looking at the impersonation token
     * and use the session on which the client is running.
     */
    if (ISTS()) {
        HANDLE      TokenHandle;
        ULONG       ClientSessionId;
        ULONG       ProcessSessionId;
        ULONG       ReturnLength;
        BOOLEAN     bResult;

        /*
         * Obtain access to the impersonation token if it's present.
         */
        Status = NtOpenThreadToken (
            GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            TRUE,
            &TokenHandle
            );
        if (NT_SUCCESS(Status)) {
            /*
             * Query the Session ID out of the Token
             */
            Status = NtQueryInformationToken (
                TokenHandle,
                TokenSessionId,
                (PVOID)&ClientSessionId,
                sizeof(ClientSessionId),
                &ReturnLength
                );
            CloseHandle(TokenHandle);
            if (NT_SUCCESS(Status)) {
                /*
                 * Get the process session Id.  Use the Kernel32 API first because
                 * the PEB is writable in case someone is hacking it.
                 */
                if (!ProcessIdToSessionId(GetCurrentProcessId(), &ProcessSessionId)) {
                    ProcessSessionId = NtCurrentPeb()->SessionId;
                }

                if (ClientSessionId != ProcessSessionId) {
                    /*
                     * This message box was intended for session other than the
                     * one on which this process is running.  Forward it to the
                     * right session with WinStationSendMessage().
                     */
                    /*
                     * Handle case where Caption or Title is NULL
                     */
                    if (pCaption == NULL) {
                        pCaption = szEmpty;
                    }
                    if (pText == NULL) {
                        pText = szEmpty;
                    }

                    /*
                     * MessageBoxTimeout assumes the timeout value is in milliseconds,
                     * but WinStationSendMessageW uses seconds.
                     */
                    if (dwTimeout != INFINITE) {
                        dwTimeout /= 1000;
                    }
                    bResult = WinStationSendMessageW(SERVERNAME_CURRENT,
                                                     ClientSessionId,
                                                     (LPWSTR)pCaption,
                                                     wcslen(pCaption) * sizeof(WCHAR),
                                                     (LPWSTR)pText,
                                                     wcslen(pText) * sizeof(WCHAR),
                                                     wType,
                                                     dwTimeout,
                                                     &Response,
                                                     FALSE         // always wait
                                                    );
                    if (bResult != TRUE) {
                        Response = aidReturn[ResponseNotHandled];
                    } else {
                        if (Response == IDTIMEOUT || Response == IDERROR) {
                            Response = aidReturn[ResponseNotHandled];
                        }
                    }

                    return (int)Response;
                }
            }
        }
    }

    /*
     * MessageBox is for this session, go call CSR.
     */
    RtlInitUnicodeString(&Text, pText);
    RtlInitUnicodeString(&Caption, pCaption);
    Parameters[0] = (ULONG_PTR)&Text;
    Parameters[1] = (ULONG_PTR)&Caption;
    Parameters[2] = wType;
    Parameters[3] = dwTimeout;

    /*
     * Compatibility: Pass the override bit to make sure this box always shows
     */
    Status = NtRaiseHardError(STATUS_SERVICE_NOTIFICATION | HARDERROR_OVERRIDE_ERRORMODE,
                              ARRAY_SIZE(Parameters),
                              3,
                              Parameters,
                              OptionOk,
                              &Response);

    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
    }

    return aidReturn[Response];
}


/***************************************************************************\
* MessageBox (API)
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
int MessageBoxA(
    HWND hwndOwner,
    LPCSTR lpszText,
    LPCSTR lpszCaption,
    UINT wStyle)
{
    EMIGETRETURNADDRESS();
    return MessageBoxExA(hwndOwner, lpszText, lpszCaption, wStyle, 0);
}


int MessageBoxW(
    HWND hwndOwner,
    LPCWSTR lpszText,
    LPCWSTR lpszCaption,
    UINT wStyle)
{
    EMIGETRETURNADDRESS();
    return MessageBoxExW(hwndOwner, lpszText, lpszCaption, wStyle, 0);
}


/***************************************************************************\
* MessageBoxEx (API)
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
int MessageBoxExA(
    HWND hwndOwner,
    LPCSTR lpszText,
    LPCSTR lpszCaption,
    UINT wStyle,
    WORD wLanguageId)
{
    return MessageBoxTimeoutA(hwndOwner,
                              lpszText,
                              lpszCaption,
                              wStyle,
                              wLanguageId,
                              INFINITE);
}


int MessageBoxExW(
    HWND hwndOwner,
    LPCWSTR lpszText,
    LPCWSTR lpszCaption,
    UINT wStyle,
    WORD wLanguageId)
{
    return MessageBoxTimeoutW(hwndOwner,
                              lpszText,
                              lpszCaption,
                              wStyle,
                              wLanguageId,
                              INFINITE);
}

/***************************************************************************\
* MessageBoxTimeout (API)
*
* History:
* 04-28-2001 JasonSch   Wrote it.
\***************************************************************************/
int MessageBoxTimeoutW(
    HWND hwndOwner,
    LPCWSTR lpszText,
    LPCWSTR lpszCaption,
    UINT wStyle,
    WORD wLanguageId,
    DWORD dwTimeout)
{
    MSGBOXDATA  MsgBoxParams;

#if DBG
    /*
     * MB_USERICON is valid for MessageBoxIndirect only.
     * MessageBoxWorker validates the other style bits
     */
    if (wStyle & MB_USERICON) {
        RIPMSG0(RIP_WARNING, "MessageBoxExW: Invalid flag: MB_USERICON");
    }
#endif

    RtlZeroMemory(&MsgBoxParams, sizeof(MsgBoxParams));
    MsgBoxParams.cbSize           = sizeof(MSGBOXPARAMS);
    MsgBoxParams.hwndOwner        = hwndOwner;
    MsgBoxParams.hInstance        = NULL;
    MsgBoxParams.lpszText         = lpszText;
    MsgBoxParams.lpszCaption      = lpszCaption;
    MsgBoxParams.dwStyle          = wStyle;
    MsgBoxParams.wLanguageId      = wLanguageId;
    MsgBoxParams.dwTimeout        = dwTimeout;

    EMIGETRETURNADDRESS();
    return MessageBoxWorker(&MsgBoxParams);
}

int MessageBoxTimeoutA(
    HWND hwndOwner,
    LPCSTR lpszText,
    LPCSTR lpszCaption,
    UINT wStyle,
    WORD wLanguageId,
    DWORD dwTimeout)
{
    int retval;
    LPWSTR lpwszText = NULL;
    LPWSTR lpwszCaption = NULL;

    if (lpszText) {
        if (!MBToWCS(lpszText, -1, &lpwszText, -1, TRUE))
            return 0;
    }

    if (lpszCaption) {
        if (!MBToWCS(lpszCaption, -1, &lpwszCaption, -1, TRUE)) {
            UserLocalFree(lpwszText);
            return 0;
        }
    }

    EMIGETRETURNADDRESS();
    retval = MessageBoxTimeoutW(hwndOwner,
                                lpwszText,
                                lpwszCaption,
                                wStyle,
                                wLanguageId,
                                dwTimeout);

    UserLocalFree(lpwszText);
    if (lpwszCaption) {
        UserLocalFree(lpwszCaption);
    }

    return retval;
}

#define MessageBoxIndirectInit(MsgBoxParams, lpmbp)                             \
    do {                                                                        \
        if (lpmbp->cbSize != sizeof(MSGBOXPARAMS)) {                            \
            RIPMSG1(RIP_WARNING,                                                \
                    "MessageBoxIndirect: Invalid cbSize 0x%x",                  \
                    lpmbp->cbSize);                                             \
        }                                                                       \
                                                                                \
        RtlZeroMemory(&MsgBoxParams, sizeof(MSGBOXDATA));                       \
        RtlCopyMemory(&MsgBoxParams, lpmbp, sizeof(MSGBOXPARAMS));              \
    } while (FALSE);

/**************************************************************************\
* MessageBoxIndirect (API)
*
* 09-30-1994 FritzS      Created.
\**************************************************************************/
int MessageBoxIndirectA(
    CONST MSGBOXPARAMSA *lpmbp)
{
    int retval;
    MSGBOXDATA  MsgBoxParams;
    LPWSTR lpwszText = NULL;
    LPWSTR lpwszCaption = NULL;

    MessageBoxIndirectInit(MsgBoxParams, lpmbp);

    if (IS_PTR(MsgBoxParams.lpszText)) {
        if (!MBToWCS((LPSTR)MsgBoxParams.lpszText, -1, &lpwszText, -1, TRUE)) {
            return 0;
        }
        MsgBoxParams.lpszText = lpwszText;
    }
    if (IS_PTR(MsgBoxParams.lpszCaption)) {
        if (!MBToWCS((LPSTR)MsgBoxParams.lpszCaption, -1, &lpwszCaption, -1, TRUE)) {
            UserLocalFree(lpwszText);
            return 0;
        }
        MsgBoxParams.lpszCaption = lpwszCaption;
    }

    EMIGETRETURNADDRESS();
    retval = MessageBoxWorker(&MsgBoxParams);

    if (lpwszText) {
        UserLocalFree(lpwszText);
    }
    if (lpwszCaption) {
        UserLocalFree(lpwszCaption);
    }

    return retval;
}

int MessageBoxIndirectW(
    CONST MSGBOXPARAMSW *lpmbp)
{
    MSGBOXDATA  MsgBoxParams;

    MessageBoxIndirectInit(MsgBoxParams, lpmbp);

    EMIGETRETURNADDRESS();
    return MessageBoxWorker(&MsgBoxParams);
}

/***************************************************************************\
* MessageBoxWorker (API)
*
* History:
* 03-10-93 JohnL      Created
\***************************************************************************/

int MessageBoxWorker(
    LPMSGBOXDATA pMsgBoxParams)
{
    DWORD  dwStyle = pMsgBoxParams->dwStyle;
    UINT   wBtnCnt;
    UINT   wDefButton;
    UINT   i;
    UINT   wBtnBeg;
    WCHAR  szErrorBuf[64];
    LPWSTR apstrButton[4];
    int    aidButton[4];
    BOOL   fCancel = FALSE;
    int    retValue;
    PMBSTRING pMBString;

#if DBG
    if (dwStyle & ~MB_VALID) {
        RIPMSG2(RIP_WARNING, "MessageBoxWorker: Invalid flags, %#lx & ~%#lx != 0",
              dwStyle, MB_VALID);
    }
#endif

    /*
     * dwTimeout == 0 means wait forever. This is mostly for compat reasons.
     */
    if (pMsgBoxParams->dwTimeout == 0) {
        pMsgBoxParams->dwTimeout = INFINITE;
    }

    /*
     * Be sure that MBStrings are already loaded.
     */
    UserAssert(gpsi->MBStrings[0].szName[0] != TEXT('\0'));

#ifdef _JANUS_
    /*
     * Error message instrument start here
     * Check EMI enable
     */

    if (gfEMIEnable) {
        if (!ErrorMessageInst(pMsgBoxParams))
            RIPMSG0(RIP_WARNING, "MessageBoxWorker: Fail to instrument error msg");
    };

    /*
     * Default Message Return: on unattended systems the default button
     * can be returned automatically without putting up the message box
     */

    if (gfDMREnable) {
        /*
         * validate the style and default button as in the main code path
         */

        /*
         * Validate the "type" of message box requested.
         */
        if ((dwStyle & MB_TYPEMASK) > MB_LASTVALIDTYPE) {
            RIPERR0(ERROR_INVALID_MSGBOX_STYLE, RIP_VERBOSE, "");
            return 0;
        }

        wBtnCnt = mpTypeCcmd[dwStyle & MB_TYPEMASK] +
                                ((dwStyle & MB_HELP) ? 1 : 0);

        /*
         * Set the default button value
         */
        wDefButton = (dwStyle & (UINT)MB_DEFMASK) / (UINT)(MB_DEFMASK & (MB_DEFMASK >> 3));

        if (wDefButton >= wBtnCnt)   /* Check if valid */
            wDefButton = 0;          /* Set the first button if error */

        /*
         * return the default button
         */

        wBtnBeg = mpTypeIich[dwStyle & (UINT)MB_TYPEMASK];
        pMBString = &gpsi->MBStrings[ SEBbuttons[wBtnBeg + wDefButton] ];
        return pMBString->uID;
    }
#endif // _JANUS_

    /*
     * If lpszCaption is NULL, then use "Error!" string as the caption
     * string.
     * LATER: IanJa localize according to wLanguageId
     */
    if (pMsgBoxParams->lpszCaption == NULL) {
        /*
         * Load the default error string if we haven't done it yet
         */
        if (*szERROR == 0) {
            LoadStringW(hmodUser, STR_ERROR, szERROR, ARRAY_SIZE(szERROR));
        }
        if (pMsgBoxParams->wLanguageId == 0) {
            pMsgBoxParams->lpszCaption = szERROR;
        } else {
            LoadStringOrError(hmodUser,
                                 STR_ERROR,
                                 szErrorBuf,
                                 sizeof(szErrorBuf)/sizeof(WCHAR),
                                 pMsgBoxParams->wLanguageId);

            /*
             *  If it didn't find the string, use the default language
             */
            if (*szErrorBuf) {
               pMsgBoxParams->lpszCaption = szErrorBuf;
            } else {
               pMsgBoxParams->lpszCaption = szERROR;

               RIPMSG1(RIP_WARNING, "MessageBoxWorker: STR_ERROR string resource for language %#lx not found",
                      pMsgBoxParams->wLanguageId);
            }
        }
    }

    /*
     * MB_SERVICE_NOTIFICATION had to be redefined because
     * Win95 defined MB_TOPMOST using the same value.
     * So for old apps, we map it to the new value
     */

    if ((dwStyle & MB_TOPMOST) && !Is400Compat(GetClientInfo()->dwExpWinVer)) {
        dwStyle &= ~MB_TOPMOST;
        dwStyle |= MB_SERVICE_NOTIFICATION;
        pMsgBoxParams->dwStyle = dwStyle;

        RIPMSG1(RIP_WARNING, "MessageBoxWorker: MB_SERVICE_NOTIFICATION flag mapped. New dwStyle:%#lx", dwStyle);
    }

    /*
     * For backward compatiblity, use MB_SERVICE_NOTIFICATION if
     * it's going to the default desktop.
     */
    if (dwStyle & (MB_DEFAULT_DESKTOP_ONLY | MB_SERVICE_NOTIFICATION)) {

        /*
         * Allow services to put up popups without getting
         * access to the current desktop.
         */
        if (pMsgBoxParams->hwndOwner != NULL) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
            return 0;
        }

        return ServiceMessageBox(pMsgBoxParams->lpszText,
                                 pMsgBoxParams->lpszCaption,
                                 dwStyle & ~MB_SERVICE_NOTIFICATION,
                                 pMsgBoxParams->dwTimeout);
    }

    /*
     * Make sure we have a valid window handle.
     */
    if (pMsgBoxParams->hwndOwner && !IsWindow(pMsgBoxParams->hwndOwner)) {
        RIPERR0(ERROR_INVALID_WINDOW_HANDLE, RIP_VERBOSE, "");
        return 0;
    }

    /*
     * Validate the "type" of message box requested.
     */
    if ((dwStyle & MB_TYPEMASK) > MB_LASTVALIDTYPE) {
        RIPERR0(ERROR_INVALID_MSGBOX_STYLE, RIP_VERBOSE, "");
        return 0;
    }

    wBtnCnt = mpTypeCcmd[dwStyle & MB_TYPEMASK] +
                            ((dwStyle & MB_HELP) ? 1 : 0);

    /*
     * Set the default button value
     */
    wDefButton = (dwStyle & (UINT)MB_DEFMASK) / (UINT)(MB_DEFMASK & (MB_DEFMASK >> 3));

    if (wDefButton >= wBtnCnt)   /* Check if valid */
        wDefButton = 0;          /* Set the first button if error */

    /*
     * Calculate the strings to use in the message box
     */
    wBtnBeg = mpTypeIich[dwStyle & (UINT)MB_TYPEMASK];
    for (i=0; i<wBtnCnt; i++) {

        pMBString = &gpsi->MBStrings[SEBbuttons[wBtnBeg + i]];
        /*
         * Pick up the string for the button.
         */
        if (pMsgBoxParams->wLanguageId == 0) {
            apstrButton[i] = KPWSTR_TO_PWSTR(pMBString->szName);
        } else {
            WCHAR szButtonBuf[64];
            // LATER is it possible to have button text greater than 64 chars

           /*
            *  BUG: gpsi->wMaxBtnSize might be too short for the length of this string...
            */
            LoadStringOrError(hmodUser,
                    pMBString->uStr,
                    szButtonBuf,
                    ARRAY_SIZE(szButtonBuf),
                    pMsgBoxParams->wLanguageId);

            /*
             *  If it didn't find the string, use the default language.
             */
            if (*szButtonBuf) {
               apstrButton[i] = TextAlloc(szButtonBuf);
            } else {
               apstrButton[i] = TextAlloc(KPWSTR_TO_PWSTR(pMBString->szName));

               RIPMSG2(RIP_WARNING, "MessageBoxWorker: string resource %#lx for language %#lx not found",
                      pMBString->uStr,
                      pMsgBoxParams->wLanguageId);
            }
        }
        aidButton[i] = pMBString->uID;
        if (aidButton[i] == IDCANCEL) {
            fCancel = TRUE;
        }
    }

    /*
     * Hackery: There are some apps that use MessageBox as initial error
     * indicators, such as mplay32, and we want this messagebox to be
     * visible regardless of waht was specified in the StartupInfo->wShowWindow
     * field.  ccMail for instance starts all of its embedded objects hidden
     * but on win 3.1 the error message would show because they don't have
     * the startup info.
     */
    NtUserModifyUserStartupInfoFlags(STARTF_USESHOWWINDOW, 0);

    pMsgBoxParams->pidButton      = aidButton;
    pMsgBoxParams->ppszButtonText = apstrButton;
    pMsgBoxParams->DefButton      = wDefButton;
    pMsgBoxParams->cButtons       = wBtnCnt;
    pMsgBoxParams->CancelId      = ((dwStyle & MB_TYPEMASK) == 0) ? IDOK : (fCancel ? IDCANCEL : 0);
    retValue = SoftModalMessageBox(pMsgBoxParams);

    if (pMsgBoxParams->wLanguageId != 0) {
        for (i = 0; i < wBtnCnt; i++) {
           UserLocalFree(apstrButton[i]);
        }
    }

    return retValue;
}

#define MAX_RES_STRING  256

/***************************************************************************\
* SoftModalMessageBox
\***************************************************************************/
int SoftModalMessageBox(
    LPMSGBOXDATA lpmb)
{
    LPBYTE              lpDlgTmp;
    int                 cyIcon, cxIcon;
    int                 cxButtons;
    int                 cxMBMax;
    int                 cxText, cyText, xText;
    int                 cxBox, cyBox;
    int                 cxFoo, cxCaption;
    int                 xMB, yMB;
    HDC                 hdc;
    DWORD               wIconOrdNum;
    DWORD               wCaptionLen;
    DWORD               wTextLen;
    WORD                OrdNum[2];  // Must be an array or WORDs
    RECT                rc;
    RECT                rcWork;
    HCURSOR             hcurOld;
    DWORD               dwStyleMsg, dwStyleText;
    DWORD               dwExStyleMsg = 0;
    DWORD               dwStyleDlg;
    HWND                hwndOwner;
    LPWSTR              lpsz;
    int                 iRetVal     = 0;
    HICON               hIcon;
    HGLOBAL             hTemplate   = NULL;
    HGLOBAL             hCaption    = NULL;
    HGLOBAL             hText       = NULL;
    HINSTANCE           hInstMsg    = lpmb->hInstance;
    SIZE                size;
    HFONT               hFontOld    = NULL;
    int                 cntMBox;
    PMONITOR            pMonitor;

    ConnectIfNecessary(0);

    dwStyleMsg = lpmb->dwStyle;

    if (dwStyleMsg & MB_RIGHT) {
        dwExStyleMsg |= WS_EX_RIGHT;
    }

    if (!IS_PTR(lpmb->lpszCaption)) {
        /*
         * Won't ever be NULL because MessageBox sticks "Error!" on error.
         */
        if (hInstMsg && (hCaption = UserLocalAlloc(HEAP_ZERO_MEMORY, MAX_RES_STRING * sizeof(WCHAR)))) {
            lpsz = (LPWSTR)hCaption;
            LoadString(hInstMsg, PTR_TO_ID(lpmb->lpszCaption), lpsz, MAX_RES_STRING);
        } else {
            lpsz = NULL;
        }

        lpmb->lpszCaption = lpsz ? lpsz : szEmpty;
    }

    if (!IS_PTR(lpmb->lpszText)) {
        // NULL not allowed
        if (hInstMsg && (hText = UserLocalAlloc(HEAP_ZERO_MEMORY, MAX_RES_STRING * sizeof(WCHAR)))) {
            lpsz = (LPWSTR)hText;
            LoadString(hInstMsg, PTR_TO_ID(lpmb->lpszText), lpsz, MAX_RES_STRING);
        } else {
            lpsz = NULL;
        }

        lpmb->lpszText = lpsz ? lpsz : szEmpty;
    }

    //
    // Mirroring of MessageBox'es is only enabled if :-
    //
    // * MB_RTLREADING style has been specified in the MessageBox styles OR
    // * The first two code points of the MessageBox text are Right-To-Left
    //   marks (RLMs = U+200f).
    // The feature of enable RTL mirroring if two consecutive RLMs are found
    // in the MB text is to acheive a no-code-change for localization of
    // of MessageBoxes for BiDi Apps.  [samera]
    //
    if ((dwStyleMsg & MB_RTLREADING) ||
            (lpmb->lpszText != NULL && (lpmb->lpszText[0] == UNICODE_RLM) &&
            (lpmb->lpszText[1] == UNICODE_RLM))) {
        //
        // Set Mirroring so that MessageBox and its child controls
        // get mirrored. Otherwise, the message box and its child controls
        // are Left-To-Right.
        //
        dwExStyleMsg |= WS_EX_LAYOUTRTL;

        //
        // And turn off any conflicting flags.
        //
        dwExStyleMsg &= ~WS_EX_RIGHT;
        if (dwStyleMsg & MB_RTLREADING) {
            dwStyleMsg &= ~MB_RTLREADING;
            dwStyleMsg ^= MB_RIGHT;
        }
    }

    if ((dwStyleMsg & MB_ICONMASK) == MB_USERICON)
        hIcon = LoadIcon(hInstMsg, lpmb->lpszIcon);
    else
        hIcon = NULL;

    // For compatibility reasons, we still allow the message box to come up.
    hwndOwner = lpmb->hwndOwner;

    // For PowerBuilder4.0, we must make their messageboxes owned popups. Or, else
    // they get WM_ACTIVATEAPP and they install multiple keyboard hooks and get into
    // infinite loop later.
    // Bug #15896 -- WIN95B -- 2/17/95 -- SANKAR --
    if (!hwndOwner)
      {
        WCHAR pwszLibFileName[MAX_PATH];
        static WCHAR szPB040[] = L"PB040";  // Module name of PowerBuilder4.0
        WCHAR *pw1;

        //Is this a win3.1 or older app?
        if (!Is400Compat(GETAPPVER())) {
            if (GetModuleFileName(NULL, pwszLibFileName, sizeof(pwszLibFileName)/sizeof(WCHAR)) == 0) goto getthedc;
            pw1 = pwszLibFileName + wcslen(pwszLibFileName) - 1;
            while (pw1 > pwszLibFileName) {
                if (*pw1 == TEXT('.')) *pw1-- = 0;
                else if (*pw1 == TEXT(':')) {pw1++; break;}
                else if (*pw1 == TEXT('\\')) {pw1++; break;}
                else pw1--;
            }
            // Is this the PowerBuilder 4.0 module?
            if (!_wcsicmp(pw1, szPB040))
                hwndOwner = NtUserGetForegroundWindow(); // Make the MsgBox owned.
          }
      }
getthedc:
    // Check if we're out of cache DCs until robustness...
    if (!(hdc = NtUserGetDCEx(NULL, NULL, DCX_WINDOW | DCX_CACHE))) {

        /*
         * The above call might fail for TIF_RESTRICTED processes
         * so check for the DC from the owner window
         */
        if (!(hdc = NtUserGetDCEx(hwndOwner, NULL, DCX_WINDOW | DCX_CACHE)))
            goto SMB_Exit;
    }

    // Figure out the types and dimensions of buttons

    cxButtons = (lpmb->cButtons * gpsi->wMaxBtnSize) + ((lpmb->cButtons - 1) * XPixFromXDU(DU_BTNGAP, gpsi->cxMsgFontChar));

    // Ditto for the icon, if there is one.  If not, cxIcon & cyIcon are 0.

    if (wIconOrdNum = MB_GetIconOrdNum(dwStyleMsg)) {
        cxIcon = SYSMET(CXICON) + XPixFromXDU(DU_INNERMARGIN, gpsi->cxMsgFontChar);
        cyIcon = SYSMET(CYICON);
    } else
        cxIcon = cyIcon = 0;

    hFontOld = SelectObject(hdc, KHFONT_TO_HFONT(gpsi->hCaptionFont));

    // Find the max between the caption text and the buttons
    wCaptionLen = wcslen(lpmb->lpszCaption);
    GetTextExtentPoint(hdc, lpmb->lpszCaption, wCaptionLen, &size);
    cxCaption = size.cx + 2*SYSMET(CXSIZE);

    //
    // The max width of the message box is 5/8 of the work area for most
    // countries.  We will then try 6/8 and 7/8 if it won't fit.  Then
    // we will use whole screen.
    //
    pMonitor = GetDialogMonitor(hwndOwner, MONITOR_DEFAULTTOPRIMARY);
    CopyRect(&rcWork, KPRECT_TO_PRECT(&pMonitor->rcWork));
    cxMBMax = MultDiv(rcWork.right - rcWork.left, 5, 8);

    cxFoo = 2*XPixFromXDU(DU_OUTERMARGIN, gpsi->cxMsgFontChar);

    SelectObject(hdc, KHFONT_TO_HFONT(gpsi->hMsgFont));

    //
    // If the text doesn't fit in 5/8, try 7/8 of the screen
    //
ReSize:
    //
    // The message box is as big as needed to hold the caption/text/buttons,
    // but not bigger than the maximum width.
    //

    cxBox = cxMBMax - 2*SYSMET(CXFIXEDFRAME);

    // Ask DrawText for the right cx and cy
    rc.left     = 0;
    rc.top      = 0;
    rc.right    = cxBox - cxFoo - cxIcon;
    rc.bottom   = rcWork.bottom - rcWork.top;
    cyText = DrawTextExW(hdc, (LPWSTR)lpmb->lpszText, -1, &rc,
                DT_CALCRECT | DT_WORDBREAK | DT_EXPANDTABS |
                DT_NOPREFIX | DT_EXTERNALLEADING | DT_EDITCONTROL, NULL);
    //
    // Make sure we have enough width to hold the buttons, in addition to
    // the icon+text.  Always force the buttons.  If they don't fit, it's
    // because the working area is small.
    //
    //
    // The buttons are centered underneath the icon/text.
    //
    cxText = rc.right - rc.left + cxIcon + cxFoo;
    cxBox = min(cxBox, max(cxText, cxCaption));
    cxBox = max(cxBox, cxButtons + cxFoo);
    cxText = cxBox - cxFoo - cxIcon;

    //
    // Now we know the text width for sure.  Really calculate how high the
    // text will be.
    //
    rc.left     = 0;
    rc.top      = 0;
    rc.right    = cxText;
    rc.bottom   = rcWork.bottom - rcWork.top;
    cyText      = DrawTextExW(hdc, (LPWSTR)lpmb->lpszText, -1, &rc, DT_CALCRECT | DT_WORDBREAK
        | DT_EXPANDTABS | DT_NOPREFIX | DT_EXTERNALLEADING | DT_EDITCONTROL, NULL);

    // Find the window size.
    cxBox += 2*SYSMET(CXFIXEDFRAME);
    cyBox = 2*SYSMET(CYFIXEDFRAME) + SYSMET(CYCAPTION) + YPixFromYDU(2*DU_OUTERMARGIN +
        DU_INNERMARGIN + DU_BTNHEIGHT, gpsi->cyMsgFontChar);

    cyBox += max(cyIcon, cyText);

    //
    // If the message box doesn't fit on the working area, we'll try wider
    // sizes successively:  6/8 of work then 7/8 of screen.
    //
    if (cyBox > rcWork.bottom - rcWork.top) {
        int cxTemp;

        cxTemp = MultDiv(rcWork.right - rcWork.left, 6, 8);

        if (cxMBMax == MultDiv(rcWork.right - rcWork.left, 5, 8)) {
            cxMBMax = cxTemp;
            goto ReSize;
        } else if (cxMBMax == cxTemp) {
            // then let's try with rcMonitor
            CopyRect(&rcWork, KPRECT_TO_PRECT(&pMonitor->rcMonitor));
            cxMBMax = MultDiv(rcWork.right - rcWork.left, 7, 8);
            goto ReSize;
        }
    }

    if (hFontOld) {
        SelectFont(hdc, hFontOld);
    }
    NtUserReleaseDC(NULL, hdc);

    // Find the window position
    cntMBox = GetClientInfo()->pDeskInfo->cntMBox;

    xMB = (rcWork.left + rcWork.right - cxBox) / 2 + (cntMBox * SYSMET(CXSIZE));
    xMB = max(xMB, rcWork.left);
    yMB = (rcWork.top + rcWork.bottom - cyBox) / 2 + (cntMBox * SYSMET(CYSIZE));
    yMB = max(yMB, rcWork.top);

    //
    // Bottom, right justify if we're going off the screen--but leave a
    // little gap.
    //
    if (xMB + cxBox > rcWork.right) {
        xMB = rcWork.right - SYSMET(CXEDGE) - cxBox;
    }

    //
    // Pin to the working area.  If it won't fit, then pin to the screen
    // height.  Bottom justify it at least if too big even for that, so
    // that the buttons are visible.
    //
    if (yMB + cyBox > rcWork.bottom) {
        yMB = rcWork.bottom - SYSMET(CYEDGE) - cyBox;
        if (yMB < rcWork.top) {
            yMB = pMonitor->rcMonitor.bottom - SYSMET(CYEDGE) - cyBox;
        }
    }

    wTextLen = wcslen(lpmb->lpszText);

    // Find out the memory required for the Dlg template and try to alloc it
    hTemplate = UserLocalAlloc(HEAP_ZERO_MEMORY, MB_FindDlgTemplateSize(lpmb));
    if (!hTemplate) {
        goto SMB_Exit;
    }

    lpDlgTmp = (LPBYTE)hTemplate;

    //
    // Setup the dialog style for the message box
    //
    dwStyleDlg = WS_POPUPWINDOW | WS_CAPTION | DS_ABSALIGN | DS_NOIDLEMSG |
                 DS_SETFONT | DS_3DLOOK;

    if ((dwStyleMsg & MB_MODEMASK) == MB_SYSTEMMODAL) {
        dwStyleDlg |= DS_SYSMODAL | DS_SETFOREGROUND;
    } else {
        dwStyleDlg |= DS_MODALFRAME | WS_SYSMENU;
    }

    if (dwStyleMsg & MB_SETFOREGROUND) {
        dwStyleDlg |= DS_SETFOREGROUND;
    }

    // Add the Header of the Dlg Template
    // BOGUS !!!  don't ADD bools
    lpDlgTmp = MB_UpdateDlgHdr((LPDLGTEMPLATE) lpDlgTmp, dwStyleDlg, dwExStyleMsg,
        (BYTE) (lpmb->cButtons + (wIconOrdNum != 0) + (lpmb->lpszText != NULL)),
        xMB, yMB, cxBox, cyBox, (LPWSTR)lpmb->lpszCaption, wCaptionLen);

    //
    // Center the buttons
    //

    cxFoo = (cxBox - 2*SYSMET(CXFIXEDFRAME) - cxButtons) / 2;

    lpDlgTmp = MB_AddPushButtons((LPDLGITEMTEMPLATE)lpDlgTmp, lpmb, cxFoo,
        cyBox - SYSMET(CYCAPTION) - (2 * SYSMET(CYFIXEDFRAME)) -
        YPixFromYDU(DU_OUTERMARGIN, gpsi->cyMsgFontChar));

    // Add Icon, if any, to the Dlg template
    //
    // The icon is always top justified.  If the text is shorter than the
    // height of the icon, we center it.  Otherwise the text will start at
    // the top.
    //
    if (wIconOrdNum) {
        OrdNum[0] = 0xFFFF;  // To indicate that an Ordinal number follows
        OrdNum[1] = (WORD) wIconOrdNum;

        lpDlgTmp = MB_UpdateDlgItem((LPDLGITEMTEMPLATE)lpDlgTmp, IDUSERICON,        // Control Id
            SS_ICON | WS_GROUP | WS_CHILD | WS_VISIBLE, 0,
            XPixFromXDU(DU_OUTERMARGIN, gpsi->cxMsgFontChar),   // X co-ordinate
            YPixFromYDU(DU_OUTERMARGIN, gpsi->cyMsgFontChar),   // Y co-ordinate
            0,  0,          // For Icons, CX and CY are ignored, can be zero
            OrdNum,         // Ordinal number of Icon
            ARRAY_SIZE(OrdNum), // Length of OrdNum
            STATICCODE);
    }

    // Add the Text of the Message to the Dlg Template
    if (lpmb->lpszText) {
        //
        // Center the text if shorter than the icon.
        //
        if (cyText >= cyIcon)
            cxFoo = 0;
        else
            cxFoo = (cyIcon - cyText) / 2;

        dwStyleText = SS_NOPREFIX | WS_GROUP | WS_CHILD | WS_VISIBLE | SS_EDITCONTROL;
        if (dwStyleMsg & MB_RIGHT) {
            dwStyleText |= SS_RIGHT;
            xText = cxBox - (SYSMET(CXSIZE) + cxText);
        } else {
            dwStyleText |= SS_LEFT;
            xText = cxIcon + XPixFromXDU(DU_INNERMARGIN, gpsi->cxMsgFontChar);
        }

        MB_UpdateDlgItem((LPDLGITEMTEMPLATE)lpDlgTmp, -1, dwStyleText, dwExStyleMsg, xText,
            YPixFromYDU(DU_OUTERMARGIN, gpsi->cyMsgFontChar) + cxFoo,
            cxText, cyText,
            (LPWSTR)lpmb->lpszText, wTextLen, STATICCODE);
    }

    // The dialog template is ready

    //
    // Set the normal cursor
    //
    hcurOld = NtUserSetCursor(LoadCursor(NULL, IDC_ARROW));

    lpmb->lpszIcon = (LPWSTR) hIcon;

    if (!(lpmb->dwStyle & MB_USERICON))
    {
        int wBeep = (LOWORD(lpmb->dwStyle & MB_ICONMASK)) >> MB_MASKSHIFT;
        if (wBeep < USER_SOUND_MAX) {
            NtUserCallOneParam(wBeep, SFI_PLAYEVENTSOUND);
        }
    }

    iRetVal = (int)InternalDialogBox(hmodUser, hTemplate, hwndOwner,
        MB_DlgProc, (LPARAM) lpmb, FALSE);

    //
    // Fix up return value
    if (iRetVal == -1)
        iRetVal = 0;                /* Messagebox should also return error */

     //
     // If the messagebox contains only OK button, then its ID is changed as
     // IDCANCEL in MB_DlgProc; So, we must change it back to IDOK irrespective
     // of whether ESC is pressed or Carriage return is pressed;
     //
    if (((dwStyleMsg & MB_TYPEMASK) == MB_OK) && iRetVal)
        iRetVal = IDOK;


    //
    // Restore the previous cursor
    //
    if (hcurOld)
        NtUserSetCursor(hcurOld);

SMB_Exit:
    if (hTemplate) {
        UserLocalFree(hTemplate);
    }

    if (hCaption) {
        UserLocalFree(hCaption);
    }

    if (hText) {
        UserLocalFree(hText);
    }

    return iRetVal;
}

/***************************************************************************\
* MB_CopyToClipboard
*
* Called in response to WM_COPY, it will save the title, message and button's
* texts to the clipboard in CF_UNICODETEXT format.
*
*   ---------------------------
*   Caption
*   ---------------------------
*   Text
*   ---------------------------
*   Button1   ...   ButtonN
*   ---------------------------
*
*
* History:
* 08-03-97 MCostea      Created
\***************************************************************************/
VOID
MB_CopyToClipboard(
    HWND hwndDlg)
{
    LPCWSTR lpszRead;
    LPWSTR lpszAll, lpszWrite;
    HANDLE hData;
    static  CONST WCHAR   szLine[] = L"---------------------------\r\n";
    UINT cBufSize, i, cWrote;
    LPMSGBOXDATA lpmb;

    if (!(lpmb = (LPMSGBOXDATA)GetWindowLongPtr(hwndDlg, GWLP_USERDATA))) {
        return;
    }

    if (!OpenClipboard(hwndDlg)) {
        return;
    }

    /*
     * Calculate the buffer size:
     *      - the message text can be all \n, that will become \r\n
     *      - there are a few extra \r\n (that's why 8)
     */
    cBufSize =  (lpmb->lpszCaption ? wcslen(lpmb->lpszCaption) : 0) +
                (lpmb->lpszText ? 2*wcslen(lpmb->lpszText) : 0) +
                4*sizeof(szLine) +
                lpmb->cButtons * gpsi->wMaxBtnSize +
                8;

    cBufSize *= sizeof(WCHAR);

    if (!(hData = UserGlobalAlloc(LHND, (LONG)(cBufSize))) ) {
        goto CloseClip;
    }

    USERGLOBALLOCK(hData, lpszAll);
    UserAssert(lpszAll);

    cWrote = wsprintf(lpszAll, L"%s%s\r\n%s",
                                szLine,
                                lpmb->lpszCaption ? lpmb->lpszCaption : L"",
                                szLine);

    lpszWrite = lpszAll + cWrote;
    lpszRead = lpmb->lpszText;
    /*
     * Change \n to \r\n in the text
     */
    for (i = 0; *lpszRead; i++) {

        if (*lpszRead == L'\n')
            *lpszWrite++ = L'\r';

        *lpszWrite++ = *lpszRead++;
    }

    cWrote = wsprintf(lpszWrite, L"\r\n%s", szLine);
    lpszWrite += cWrote;

    /*
     * Remove & from the button texts
     */
    for (i = 0; i<lpmb->cButtons; i++) {

        lpszRead = lpmb->ppszButtonText[i];
        while (*lpszRead) {
            if (*lpszRead != L'&') {
                *lpszWrite++ = *lpszRead;
            }
            lpszRead++;
        }
        *lpszWrite++ = L' ';
        *lpszWrite++ = L' ';
        *lpszWrite++ = L' ';
    }
    wsprintf(lpszWrite, L"\r\n%s\0", szLine);

    USERGLOBALUNLOCK(hData);

    NtUserEmptyClipboard();
    /*
     * If we just called EmptyClipboard in the context of a 16 bit
     * app then we also have to tell WOW to nix its 16 handle copy of
     * clipboard data.  WOW does its own clipboard caching because
     * some 16 bit apps use clipboard data even after the clipboard
     * has been emptied.  See the note in the server code.
     *
     * Note: this is another place (besides client\editec.c) where
     * EmptyClipboard is called* for a 16 bit app not going through WOW.
     * If we added others we might want to move this into EmptyClipboard
     * and have two versions.
     */
    if (GetClientInfo()->CI_flags & CI_16BIT) {
        pfnWowEmptyClipBoard();
    }

    SetClipboardData(CF_UNICODETEXT, hData);

CloseClip:
    NtUserCloseClipboard();

}

/***************************************************************************\
* MB_UpdateDlgHdr
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/

LPBYTE MB_UpdateDlgHdr(
    LPDLGTEMPLATE lpDlgTmp,
    long lStyle,
    long lExtendedStyle,
    BYTE bItemCount,
    int iX,
    int iY,
    int iCX,
    int iCY,
    LPWSTR lpszCaption,
    int cchCaptionLen)
{
    LPTSTR lpStr;
    RECT rc;

    /*
     * Adjust the rectangle dimensions.
     */
    rc.left     = iX + SYSMET(CXFIXEDFRAME);
    rc.top      = iY + SYSMET(CYFIXEDFRAME);
    rc.right    = iX + iCX - SYSMET(CXFIXEDFRAME);
    rc.bottom   = iY + iCY - SYSMET(CYFIXEDFRAME);


    /*
     * Adjust for the caption.
     */
    rc.top += SYSMET(CYCAPTION);

    lpDlgTmp->style = lStyle;
    lpDlgTmp->dwExtendedStyle = lExtendedStyle;
    lpDlgTmp->cdit = bItemCount;
    lpDlgTmp->x  = XDUFromXPix(rc.left, gpsi->cxMsgFontChar);
    lpDlgTmp->y  = YDUFromYPix(rc.top, gpsi->cyMsgFontChar);
    lpDlgTmp->cx = XDUFromXPix(rc.right - rc.left, gpsi->cxMsgFontChar);
    lpDlgTmp->cy = YDUFromYPix(rc.bottom - rc.top, gpsi->cyMsgFontChar);

    /*
     * Move pointer to variable length fields.  No menu resource for
     * message box, a zero window class (means dialog box class).
     */
    lpStr = (LPWSTR)(lpDlgTmp + 1);
    *lpStr++ = 0;                           // Menu
    lpStr = (LPWSTR)NextWordBoundary(lpStr);
    *lpStr++ = 0;                           // Class
    lpStr = (LPWSTR)NextWordBoundary(lpStr);

    /*
     * NOTE: iCaptionLen may be less than the length of the Caption string;
     * So, DO NOT USE lstrcpy();
     */
    RtlCopyMemory(lpStr, lpszCaption, cchCaptionLen*sizeof(WCHAR));
    lpStr += cchCaptionLen;
    *lpStr++ = TEXT('\0');                // Null terminate the caption str

    /*
     * Font height of 0x7FFF means use the message box font
     */
    *lpStr++ = 0x7FFF;

    return NextDWordBoundary(lpStr);
}

/***************************************************************************\
* MB_AddPushButtons
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/

LPBYTE MB_AddPushButtons(
    LPDLGITEMTEMPLATE  lpDlgTmp,
    LPMSGBOXDATA       lpmb,
    UINT               wLEdge,
    UINT               wBEdge)
{
    UINT   wYValue;
    UINT   i;
    UINT   wHeight;
    UINT   wCount = lpmb->cButtons;

    wHeight = YPixFromYDU(DU_BTNHEIGHT, gpsi->cyMsgFontChar);

    wYValue = wBEdge - wHeight;         // Y co-ordinate for push buttons

    for (i = 0; i < wCount; i++) {

        lpDlgTmp = (LPDLGITEMTEMPLATE)MB_UpdateDlgItem(
                lpDlgTmp,                       /* Ptr to template */
                lpmb->pidButton[i],             /* Control Id */
                WS_TABSTOP | WS_CHILD | WS_VISIBLE | (i == 0 ? WS_GROUP : 0) |
                ((UINT)i == lpmb->DefButton ? BS_DEFPUSHBUTTON : BS_PUSHBUTTON),
                0,
                wLEdge,                         /* X co-ordinate */
                wYValue,                        /* Y co-ordinate */
                gpsi->wMaxBtnSize,              /* CX */
                wHeight,                        /* CY */
                lpmb->ppszButtonText[i],        /* String for button */
                (UINT)wcslen(lpmb->ppszButtonText[i]),/* Length */
                BUTTONCODE);

        /*
         * Get the X co-ordinate for the next Push button
         */
        wLEdge += gpsi->wMaxBtnSize + XPixFromXDU(DU_BTNGAP, gpsi->cxMsgFontChar);
    }

    return (LPBYTE)lpDlgTmp;
}

/***************************************************************************\
* MB_UpdateDlgItem
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/

LPBYTE MB_UpdateDlgItem(
    LPDLGITEMTEMPLATE lpDlgItem,
    int iCtrlId,
    long lStyle,
    long lExtendedStyle,
    int iX,
    int iY,
    int iCX,
    int iCY,
    LPWSTR lpszText,
    UINT cchTextLen,
    int iControlClass)
{
    LPWSTR lpStr;
    BOOL fIsOrdNum;


    lpDlgItem->x        = XDUFromXPix(iX, gpsi->cxMsgFontChar);
    lpDlgItem->y        = YDUFromYPix(iY, gpsi->cyMsgFontChar);
    lpDlgItem->cx       = XDUFromXPix(iCX,gpsi->cxMsgFontChar);
    lpDlgItem->cy       = YDUFromYPix(iCY,gpsi->cyMsgFontChar);
    lpDlgItem->id       = (WORD)iCtrlId;
    lpDlgItem->style    = lStyle;
    lpDlgItem->dwExtendedStyle = lExtendedStyle;

    /*
     * We have to avoid the following nasty rounding off problem:
     * (e.g) If iCX=192 and cxSysFontChar=9, then cx becomes 85; When the
     * static text is drawn, from 85 dlg units we get 191 pixels; So, the text
     * is truncated;
     * So, to avoid this, check if this is a static text and if so,
     * add one more dialog unit to cx and cy;
     * --Fix for Bug #4481 --SANKAR-- 09-29-89--
     */

    /*
     * Also, make sure we only do this to static text items.  davidds
     */

    /*
     * Now static text uses SS_NOPREFIX = 0x80;
     * So, test the lStyle field only with 0x0F instead of 0xFF;
     * Fix for Bugs #5933 and 5935 --SANKAR-- 11-28-89
     */
    if (iControlClass == STATICCODE &&
         (((lStyle & 0x0F) == SS_LEFT) || ((lStyle & 0x0F) == SS_RIGHT))) {

        /*
         * This is static text
         */
        lpDlgItem->cx++;
        lpDlgItem->cy++;
    }

    /*
     * Move ptr to the variable fields
     */
    lpStr = (LPWSTR)(lpDlgItem + 1);

    /*
     * Store the Control Class value
     */
    *lpStr++ = 0xFFFF;
    *lpStr++ = (BYTE)iControlClass;
    lpStr = (LPWSTR)NextWordBoundary(lpStr);        // WORD-align lpszText

    /*
     * Check if the String contains Ordinal number or not
     */
    fIsOrdNum = ((*lpszText == 0xFFFF) && (cchTextLen == sizeof(DWORD)/sizeof(WCHAR)));

    /*
     * NOTE: cchTextLen may be less than the length of lpszText.  So,
     * DO NOT USE lstrcpy() for the copy.
     */
    RtlCopyMemory(lpStr, lpszText, cchTextLen*sizeof(WCHAR));
    lpStr = lpStr + cchTextLen;
    if (!fIsOrdNum) {
        *lpStr = TEXT('\0');    // NULL terminate the string
        lpStr = (LPWSTR)NextWordBoundary(lpStr + 1);
    }

    *lpStr++ = 0;           // sizeof control data (there is none)

    return NextDWordBoundary(lpStr);
}


/***************************************************************************\
* MB_FindDlgTemplateSize
*
* This routine computes the amount of memory that will be needed for the
* messagebox's dialog template structure.  The dialog template has several
* required and optional records.  The dialog manager expects each record to
* be DWORD aligned so any necessary padding is also accounted for.
*
* (header - required)
* DLGTEMPLATE (header) + 1 menu byte + 1 pad + 1 class byte + 1 pad
* szCaption + 0 term + DWORD alignment
*
* (static icon control - optional)
* DLGITEMTEMPLATE + 1 class byte + 1 pad + (0xFF00 + icon ordinal # [szText]) +
* UINT alignment + 1 control data length byte (0) + DWORD alignment
*
* (pushbutton controls - variable, but at least one required)
* DLGITEMTEMPLATE + 1 class byte + 1 pad + length of button text +
* UINT alignment + 1 control data length byte (0) + DWORD alignment
*
* (static text control - optional)
* DLGITEMTEMPLATE + 1 class byte + 1 pad + length of text +
* UINT alignment + 1 control data length byte (0) + DWORD alignment
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
UINT
MB_FindDlgTemplateSize(
    LPMSGBOXDATA lpmb)
{
    ULONG_PTR cbLen;
    UINT cbT;
    UINT i;
    UINT wCount;

    wCount = lpmb->cButtons;

    /*
     * Start with dialog header's size.
     */
    cbLen = (ULONG_PTR)NextWordBoundary(sizeof(DLGTEMPLATE) + sizeof(WCHAR));
    cbLen = (ULONG_PTR)NextWordBoundary(cbLen + sizeof(WCHAR));
    cbLen += wcslen(lpmb->lpszCaption) * sizeof(WCHAR) + sizeof(WCHAR);
    cbLen += sizeof(WORD);                   // Font height
    cbLen = (ULONG_PTR)NextDWordBoundary(cbLen);

    /*
     * Check if an Icon is present.
     */
    if (lpmb->dwStyle & MB_ICONMASK)
        cbLen += (ULONG_PTR)NextDWordBoundary(sizeof(DLGITEMTEMPLATE) + 7 * sizeof(WCHAR));

    /*
     * Find the number of buttons in the msg box.
     */
    for (i = 0; i < wCount; i++) {
        cbLen = (ULONG_PTR)NextWordBoundary(cbLen + sizeof(DLGITEMTEMPLATE) +
                (2 * sizeof(WCHAR)));
        cbT = (wcslen(lpmb->ppszButtonText[i]) + 1) * sizeof(WCHAR);
        cbLen = (ULONG_PTR)NextWordBoundary(cbLen + cbT);
        cbLen += sizeof(WCHAR);
        cbLen = (ULONG_PTR)NextDWordBoundary(cbLen);
    }

    /*
     * Add in the space required for the text message (if there is one).
     */
    if (lpmb->lpszText != NULL) {
        cbLen = (ULONG_PTR)NextWordBoundary(cbLen + sizeof(DLGITEMTEMPLATE) +
                (2 * sizeof(WCHAR)));
        cbT = (wcslen(lpmb->lpszText) + 1) * sizeof(WCHAR);
        cbLen = (ULONG_PTR)NextWordBoundary(cbLen + cbT);
        cbLen += sizeof(WCHAR);
        cbLen = (ULONG_PTR)NextDWordBoundary(cbLen);
    }

    return (UINT)cbLen;
}

/***************************************************************************\
* MB_GetIconOrdNum
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/

UINT MB_GetIconOrdNum(
    UINT rgBits)
{
    switch (rgBits & MB_ICONMASK) {
    case MB_USERICON:
    case MB_ICONHAND:
        return PtrToUlong(IDI_HAND);

    case MB_ICONQUESTION:
        return PtrToUlong(IDI_QUESTION);

    case MB_ICONEXCLAMATION:
        return PtrToUlong(IDI_EXCLAMATION);

    case MB_ICONASTERISK:
        return PtrToUlong(IDI_ASTERISK);
    }

    return 0;
}

/***************************************************************************\
* MB_GetString
*
* History:
*  1-24-95 JerrySh      Created.
\***************************************************************************/
LPWSTR MB_GetString(
    UINT wBtn)
{
    if (wBtn < MAX_SEB_STYLES)
        return GETGPSIMBPSTR(wBtn);

    RIPMSG1(RIP_ERROR, "Invalid wBtn: %d", wBtn);

    return NULL;
}

/***************************************************************************\
* MB_DlgProc
*
* Returns: TRUE  - message processed
*          FALSE - message not processed
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
INT_PTR MB_DlgProc(
    HWND hwndDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndT;
    int iCount;
    LPMSGBOXDATA lpmb;
    HWND hwndOwner;
    PVOID lpfnCallback;
    PWND pwnd;
    BOOL bTimedOut = FALSE;

    switch (wMsg) {
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORSTATIC:
        if ((pwnd = ValidateHwnd(hwndDlg)) == NULL)
            return 0L;
        return DefWindowProcWorker(pwnd, WM_CTLCOLORMSGBOX,
                                   wParam, lParam, FALSE);

    case WM_TIMER:
        if (!bTimedOut) {
            bTimedOut = TRUE;
            EndTaskModalDialog(hwndDlg);
            EndDialog(hwndDlg, IDTIMEOUT);
        }
        break;

    case WM_NCDESTROY:
        if ((lpmb = (LPMSGBOXDATA)GetWindowLongPtr(hwndDlg, GWLP_USERDATA))) {
            if (lpmb->dwTimeout != INFINITE) {
                NtUserKillTimer(hwndDlg, 0);
                lpmb->dwTimeout = INFINITE;
            }
        }
        if ((pwnd = ValidateHwnd(hwndDlg)) == NULL) {
            return 0L;
        }
        return DefWindowProcWorker(pwnd, wMsg,
                                   wParam, lParam, FALSE);


    case WM_INITDIALOG:

        lpmb = (LPMSGBOXDATA)lParam;
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (ULONG_PTR)lParam);

        NtUserCallHwnd(hwndDlg, SFI_SETMSGBOX);

        if (lpmb->dwStyle & MB_HELP) {
            NtUserSetWindowContextHelpId(hwndDlg, lpmb->dwContextHelpId);
        }

        if (lpmb->dwStyle & MB_TOPMOST) {
            NtUserSetWindowPos(hwndDlg,
                               HWND_TOPMOST,
                               0, 0, 0, 0,
                               SWP_NOMOVE | SWP_NOSIZE);
        }

        if (lpmb->dwStyle & MB_USERICON) {
            SendDlgItemMessage(hwndDlg, IDUSERICON, STM_SETICON, (WPARAM)(lpmb->lpszIcon), 0);
            iCount = ALERT_SYSTEM_WARNING;
        } else {
            /*
             * Generate an alert notification
             */
            switch (lpmb->dwStyle & MB_ICONMASK) {
            case MB_ICONWARNING:
                iCount = ALERT_SYSTEM_WARNING;
                break;

            case MB_ICONQUESTION:
                iCount = ALERT_SYSTEM_QUERY;
                break;

            case MB_ICONERROR:
                iCount = ALERT_SYSTEM_ERROR;
                break;

            case MB_ICONINFORMATION:
            default:
                iCount = ALERT_SYSTEM_INFORMATIONAL;
                break;
            }
        }

        NotifyWinEvent(EVENT_SYSTEM_ALERT, hwndDlg, OBJID_ALERT, iCount);

        if (lpmb->hwndOwner == NULL &&
            (lpmb->dwStyle & MB_MODEMASK) == MB_TASKMODAL) {
            StartTaskModalDialog(hwndDlg);
        }

        /*
         * Set focus on the default button
         */
        hwndT = GetWindow(hwndDlg, GW_CHILD);
        iCount = lpmb->DefButton;
        while (iCount--)
            hwndT = GetWindow(hwndT, GW_HWNDNEXT);

        NtUserSetFocus(hwndT);

        //
        // Need the dialog's HWND later, but we reuse hwndDlg.
        //
        hwndT = hwndDlg;

        //
        // If this dialogbox does not contain a IDCANCEL button, then
        // remove the CLOSE command from the system menu.
        // Bug #4445, --SANKAR-- 09-13-89 --
        //
        if (lpmb->CancelId == 0) {
            HMENU hMenu;

            if (hMenu = NtUserGetSystemMenu(hwndDlg, FALSE)) {
                NtUserDeleteMenu(hMenu, SC_CLOSE, (UINT)MF_BYCOMMAND);
            }
        }

        if ((lpmb->dwStyle & MB_TYPEMASK) == MB_OK) {
            //
            // Make the ID of OK button to be CANCEL, because we want
            // the ESC to terminate the dialogbox; GetDlgItem32() will
            // not fail, because this is MB_OK messagebox!
            //

            hwndDlg = GetDlgItem(hwndDlg, IDOK);

            if (hwndDlg != NULL) {
            //    hwndDlg->hMenu = (HMENU)IDCANCEL;
                SetWindowLongPtr(hwndDlg, GWLP_ID, IDCANCEL);
            } else {
                RIPMSG0(RIP_WARNING, "MB_DlgProc- IDOK control not found");
            }
        }

        if (lpmb->dwTimeout != INFINITE) {
            if (NtUserSetTimer(hwndT, 0, lpmb->dwTimeout, NULL) == 0) {
                /*
                 * Couldn't create the timer, so "clear" out the timeout value
                 * for future reference.
                 */
                lpmb->dwTimeout = INFINITE;
            }
        }

        /*
         * We have changed the input focus
         */
        return FALSE;

    case WM_HELP:
        // When user hits an F1 key, it results in this message.
        // It is possible that this MsgBox has a callback instead of a
        // parent. So, we must behave as if the user hit the HELP button.

        goto  MB_GenerateHelp;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        case IDCANCEL:
           //
           // Check if a control exists with the given ID; This
           // check is needed because DlgManager returns IDCANCEL
           // blindly when ESC is pressed even if a button with
           // IDCANCEL is not present.
           // Bug #4445 --SANKAR--09-13-1989--
           //
           if (!GetDlgItem(hwndDlg, LOWORD(wParam)))
              return FALSE;


           // else FALL THRO....This is intentional.
        case IDABORT:
        case IDIGNORE:
        case IDNO:
        case IDRETRY:
        case IDYES:
        case IDTRYAGAIN:
        case IDCONTINUE:
           EndTaskModalDialog(hwndDlg);
           EndDialog(hwndDlg, LOWORD(wParam));
             break;
        case IDHELP:
MB_GenerateHelp:
                // Generate the WM_HELP message and send it to owner or callback
           hwndOwner = NULL;

           // Check if there is an app supplied callback for this MsgBox
           lpmb = (LPMSGBOXDATA)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
           if ((lpfnCallback = lpmb->lpfnMsgBoxCallback) == NULL) {
               // If not, see if we need to inform the parent.
               hwndOwner = GetWindow(hwndDlg, GW_OWNER);
           }

           /*
            * See if we need to generate the Help message or call back.
            */
           if (hwndOwner || lpfnCallback) {
               SendHelpMessage(hwndOwner,
                               HELPINFO_WINDOW,
                               IDHELP,
                               hwndDlg,
                               NtUserGetWindowContextHelpId(hwndDlg),
                               lpfnCallback);
           }
           break;

        default:
            return FALSE;
            break;
        }
        break;

    case WM_COPY:
        MB_CopyToClipboard(hwndDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
* StartTaskModalDialog
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
VOID
StartTaskModalDialog(
    HWND hwndDlg)
{
    int cHwnd;
    HWND *phwnd;
    HWND *phwndList, *phwndEnd;
    HWND hwnd;
    PWND pwnd;
    LPMSGBOXDATA lpmb;

    /*
     * Get the hwnd list. It is returned in a block of memory allocated with
     * UserLocalAlloc.
     */
    if ((cHwnd = BuildHwndList(NULL, NULL, FALSE, GetCurrentThreadId(), &phwndList)) == 0) {
        return;
    }

    lpmb = (LPMSGBOXDATA)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    lpmb->phwndList = phwndList;

    phwndEnd = phwndList + cHwnd;
    for (phwnd = phwndList; phwnd < phwndEnd; phwnd++) {
        if ((hwnd = *phwnd) == NULL || (pwnd = RevalidateHwnd(hwnd)) == NULL)
            continue;

        /*
         * if the window belongs to the current task and is enabled, disable
         * it.  All other windows are NULL'd out, to prevent their being
         * enabled later
         */
        if (!TestWF(pwnd, WFDISABLED) && DIFFWOWHANDLE(hwnd, hwndDlg)) {
            NtUserEnableWindow(hwnd, FALSE);
        } else {
            *phwnd = NULL;
        }
    }
}


/***************************************************************************\
* EndTaskModalDialog
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
VOID
EndTaskModalDialog(
    HWND hwndDlg)
{
    HWND *phwnd;
    HWND *phwndList;
    HWND hwnd;
    LPMSGBOXDATA lpmb;

    lpmb = (LPMSGBOXDATA)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    phwndList = lpmb->phwndList;
    if (phwndList == NULL) {
        return;
    }

    lpmb->phwndList = NULL;

    for (phwnd = phwndList; *phwnd != (HWND)1; phwnd++) {
        if ((hwnd = *phwnd) != NULL) {
            NtUserEnableWindow(hwnd, TRUE);
        }
    }

    UserLocalFree(phwndList);
}

#ifdef _JANUS_
/***************************************************************************\
* ErrorMessageInst
*
* Instrument routine for recording error msg
*
* Returns: TRUE  - Instrument error msg Success
*          FALSE - Fail
*
* History:
*   8-5-98 Chienho      Created
\***************************************************************************/

BOOL ErrorMessageInst(
     LPMSGBOXDATA pMsgBoxParams)
{
    ERROR_ELEMENT ErrEle;
    WCHAR *pwcs;
    PVOID ImageBase;
    PIMAGE_NT_HEADERS NtHeaders;
    BOOL rc;
    WCHAR szUnknown[32];

    /*
     * Check if the MessageBox style is within the logged severity level
     */
    switch (pMsgBoxParams->dwStyle & MB_ICONMASK) {
    case MB_ICONHAND:
        /*
         * when EMI is enabled, we at least log error messages
         */
        break;
    case MB_ICONEXCLAMATION:
        if (gdwEMIControl > EMI_SEVERITY_WARNING) {
            rc = TRUE;
            goto End;
        }
        break;
    case MB_ICONQUESTION:
        if (gdwEMIControl > EMI_SEVERITY_QUESTION) {
            rc = TRUE;
            goto End;
        }
        break;
    case MB_ICONASTERISK:
        if (gdwEMIControl > EMI_SEVERITY_INFORMATION) {
            rc = TRUE;
            goto End;
        }
        break;
    case MB_USERICON:
        if (gdwEMIControl > EMI_SEVERITY_USER) {
            rc = TRUE;
            goto End;
        }
        break;
    default:
        if (gdwEMIControl > EMI_SEVERITY_ALL) {
            rc = TRUE;
            goto End;
        }
        break;
    }

    if (gdwEMIThreadID != GETTHREADID()) {
        rc = FALSE;
        goto End;
    }
    RtlZeroMemory(&ErrEle, sizeof(ErrEle));

    /*
     * get last error first, check with FormatMessage???
     */
    ErrEle.dwErrorCode = GetLastError();

    /*
     * get return address
     */

    ErrEle.ReturnAddr = gpReturnAddr;

    /*
     * get the process image name
     */
    GetCurrentProcessName(ErrEle.ProcessName, ARRAY_SIZE(ErrEle.ProcessName));

    /*
     * Load the "unknown" string
     */
    LoadString(hmodUser, STR_UNKNOWN, szUnknown, ARRAYSIZE(szUnknown));

    /*
     * get the window title
     */
    GetWindowTextW(pMsgBoxParams->hwndOwner, ErrEle.WindowTitle, TITLE_SIZE);
    if (!(*(ErrEle.WindowTitle))) {
        lstrcpy(ErrEle.WindowTitle, szUnknown);
    }

    /*
     * get messagebox data
     */
    ErrEle.lpszText = (LPWSTR)pMsgBoxParams->lpszText;
    ErrEle.lpszCaption = (LPWSTR)pMsgBoxParams->lpszCaption;
    ErrEle.dwStyle = pMsgBoxParams->dwStyle;

    /*
     * resolve the module name of caller
     */
    if (!RtlPcToFileHeader((PVOID)ErrEle.ReturnAddr, &ImageBase)) {
        RIPMSG0(RIP_WARNING, "ErrorMessageInst: Can't find Caller");
        ErrEle.BaseAddr = (PVOID)-1;
        ErrEle.dwImageSize = -1;
        lstrcpy(ErrEle.CallerModuleName, szUnknown);
    } else {
        ErrEle.BaseAddr = ImageBase;
        if (GetModuleFileName((HMODULE)ImageBase, ErrEle.CallerModuleName, MAX_PATH)) {
            pwcs = wcsrchr(ErrEle.CallerModuleName, TEXT('\\'));
            if (pwcs) {
                pwcs++;
                lstrcpy(ErrEle.CallerModuleName, pwcs);
            }
        } else {
            lstrcpy(ErrEle.CallerModuleName, szUnknown);
        }
        NtHeaders = RtlImageNtHeader(ImageBase);
        if (NtHeaders == NULL) {
            ErrEle.dwImageSize = -1;
        } else {
            ErrEle.dwImageSize = NtHeaders->OptionalHeader.SizeOfImage;
        }
    }
    /*
     * Register the event if we haven't done so already.
     * Since RegisterEventSource is supported by a service, we must not hold
     * any locks while making this call. Hence we might have several threads
     * registering the event simultaneously.
     */

    if (!gEventSource) {
        gEventSource = RegisterEventSourceW(NULL, L"Error Instrument");
        if (!gEventSource) {
            ErrEle.dwErrorCode = GetLastError();
            rc = FALSE;
        }
    }

    /*
     * report event
     */
    if (gEventSource) {
       rc = LogMessageBox(&ErrEle);
    }

    /*
     * allow to process another event log again
     */

    InterlockedExchangePointer(&gdwEMIThreadID, 0);

End:
    return rc;
}

/***************************************************************************\
* InitInstrument
*
* Returns: TRUE  - Initialization Success
*          FALSE - Initialization Fail
*
\***************************************************************************/
BOOL InitInstrument(
    LPDWORD lpEMIControl)
{
    NTSTATUS Status;
    HKEY hKeyEMI = NULL;
    UNICODE_STRING UnicodeStringEMIKey;
    UNICODE_STRING UnicodeStringEnable;
    UNICODE_STRING UnicodeStringStyle;
    OBJECT_ATTRIBUTES ObjA;
    DWORD EMIEnable = 0; //means disable
    DWORD EMISeverity;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION;
        LARGE_INTEGER;
    } EMIValueInfo;
    DWORD dwDisposition;

    RtlInitUnicodeString(&UnicodeStringEMIKey, szEMIKey);
    InitializeObjectAttributes(&ObjA, &UnicodeStringEMIKey, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtOpenKey(&hKeyEMI, KEY_READ, &ObjA);
    if (!NT_SUCCESS(Status)) {
        /*
         * Key doesn't exist, assume disable
         */
        return FALSE;
    }

    /*
     * read the logging enable and setting
     */
    RtlInitUnicodeString(&UnicodeStringEnable, szEMIEnable);
    Status = NtQueryValueKey(hKeyEMI,
                     &UnicodeStringEnable,
                     KeyValuePartialInformation,
                     &EMIValueInfo,
                     sizeof(EMIValueInfo),
                     &dwDisposition);

    if (NT_SUCCESS(Status)) {

        RtlCopyMemory(&EMIEnable, &EMIValueInfo.Data, sizeof(EMIEnable));

        RtlInitUnicodeString(&UnicodeStringStyle, szEMISeverity);
        Status = NtQueryValueKey(hKeyEMI,
                         &UnicodeStringStyle,
                         KeyValuePartialInformation,
                         &EMIValueInfo,
                         sizeof(EMIValueInfo),
                         &dwDisposition);

        if (NT_SUCCESS(Status)) {
            RtlCopyMemory(&EMISeverity, &EMIValueInfo.Data, sizeof(EMISeverity));
            /*
             * Validate data
             */
            if (EMISeverity > EMI_SEVERITY_MAX_VALUE) {
                EMISeverity = EMI_SEVERITY_MAX_VALUE;
            }
        } else {
            /*
             * default severity for instrument
             */
            EMISeverity = EMI_SEVERITY_WARNING;
        }
        *lpEMIControl = EMISeverity;
    }

    /*
     * read default message reply enable
     */
    RtlInitUnicodeString(&UnicodeStringEnable, szDMREnable);
    Status = NtQueryValueKey(hKeyEMI,
                     &UnicodeStringEnable,
                     KeyValuePartialInformation,
                     &EMIValueInfo,
                     sizeof(EMIValueInfo),
                     &dwDisposition);

    if (NT_SUCCESS(Status)) {
        RtlCopyMemory(&gfDMREnable, &EMIValueInfo.Data, sizeof(gfDMREnable));
    }

    NtClose(hKeyEMI);

    if (EMIEnable) {

          /*
           * add eventlog file
           */
          if (NT_SUCCESS(CreateLogSource())) {
              return TRUE;
          }
    }
    return FALSE;
}

/***************************************************************************\
* CreateLogSource
*
* Create the event source for eventlog
* Return : NTSTATUS
*
\***************************************************************************/
NTSTATUS CreateLogSource()
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeStringEventKey;
    OBJECT_ATTRIBUTES ObjA;
    HKEY hKeyEvent = NULL;
    UNICODE_STRING UnicodeString;
    DWORD dwDisposition;


    RtlInitUnicodeString(&UnicodeStringEventKey, szEventKey);
    InitializeObjectAttributes(&ObjA, &UnicodeStringEventKey, OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (NT_SUCCESS(Status = NtOpenKey(&hKeyEvent, KEY_READ, &ObjA))) {

        struct {
            KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
            WCHAR awchMsgFileName[256];
        } MsgFile;

        RtlInitUnicodeString(&UnicodeString, szEventMsgFile);

        Status = NtQueryValueKey(hKeyEvent,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 &MsgFile,
                                 sizeof MsgFile,
                                 &dwDisposition);
        if (NT_SUCCESS(Status)) {
            Status = lstrcmpi((LPWSTR)MsgFile.KeyInfo.Data, L"%SystemRoot%\\System32\\user32.dll");
        }
        NtClose(hKeyEvent);
    }

    return Status;
}

/***************************************************************************\
* LogMessageBox
*
* Output error message record into eventlog
*
\***************************************************************************/
BOOL LogMessageBox(
    LPERROR_ELEMENT lpErrEle)
{
    LPWSTR lps[8];
    DWORD dwData[2];
    WCHAR BaseAddress[19];
    WCHAR ImageSize[19];
    WCHAR ReturnAddress[19];
    PTOKEN_USER pTokenUser = NULL;
    PSID pSid = NULL;
    BOOL rc;

    lps[0] = lpErrEle->ProcessName;
    lps[1] = lpErrEle->WindowTitle;
    lps[2] = lpErrEle->lpszCaption;
    lps[3] = lpErrEle->lpszText;
    lps[4] = lpErrEle->CallerModuleName;
    wsprintf(BaseAddress, L"%-#16p", lpErrEle->BaseAddr);
    lps[5] = BaseAddress;
    wsprintf(ImageSize, L"%-#16lX", lpErrEle->dwImageSize);
    lps[6] = ImageSize;
    wsprintf(ReturnAddress, L"%-#16p", lpErrEle->ReturnAddr);
    lps[7] = ReturnAddress;

    dwData[0] = lpErrEle->dwStyle;
    dwData[1] = lpErrEle->dwErrorCode;

    if (GetUserSid(&pTokenUser)) {
        pSid = pTokenUser->User.Sid;
    }

    UserAssert(gEventSource != NULL);
    rc = ReportEventW(gEventSource,
                      EVENTLOG_INFORMATION_TYPE,
                      0,
                      STATUS_LOG_ERROR_MSG,
                      pSid,
                      ARRAY_SIZE(lps),
                      sizeof(dwData),
                      lps,
                      dwData);

    if (pTokenUser) {
        VirtualFree(pTokenUser, 0, MEM_RELEASE);
    }

    return rc;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\ntcftxt.h ===
/***************************** Module Header ******************************\
* Module Name: ntcftxt.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Kernel call forward stubs with text arguments
*
* Each function will be created with two flavors Ansi and Unicode
*
* 06-Jan-1992 IanJa      Moved from cf.h
* 18-Mar-1995 JimA       Ported from cftxt.h
\**************************************************************************/

#ifdef UNICODE
#define IS_ANSI FALSE
#ifndef _UNICODE
#define _UNICODE
#endif
#else
#define IS_ANSI TRUE
#undef _UNICODE
#endif
#include <tchar.h>
#include "ntsend.h"

HWND TEXT_FN(InternalFindWindowEx)(
    HWND    hwndParent,
    HWND    hwndChild,
    LPCTSTR pClassName,
    LPCTSTR pWindowName,
    DWORD   dwFlag)
{
    IN_STRING strClass;
    IN_STRING strWindow;

    /*
     * Make sure cleanup will work successfully
     */
    strClass.fAllocated = FALSE;
    strWindow.fAllocated = FALSE;

    BEGINCALL()

        FIRSTCOPYLPTSTRIDOPT(&strClass, pClassName);
        COPYLPTSTROPT(&strWindow, pWindowName);

        retval = (ULONG_PTR)NtUserFindWindowEx(
                hwndParent,
                hwndChild,
                strClass.pstr,
                strWindow.pstr,
                dwFlag);

    ERRORTRAP(0);
    CLEANUPLPTSTR(strClass);
    CLEANUPLPTSTR(strWindow);
    ENDCALL(HWND);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, HWND, WINUSERAPI, FindWindowExW, HWND, hwndParent, HWND, hwndChild, LPCTSTR, pClassName, LPCTSTR, pWindowName)
#else
FUNCLOG4(LOG_GENERAL, HWND, WINUSERAPI, FindWindowExA, HWND, hwndParent, HWND, hwndChild, LPCTSTR, pClassName, LPCTSTR, pWindowName)
#endif // UNICODE
HWND FindWindowEx(
    HWND    hwndParent,
    HWND    hwndChild,
    LPCTSTR pClassName,
    LPCTSTR pWindowName)
{
    return TEXT_FN(InternalFindWindowEx)(hwndParent, hwndChild, pClassName, pWindowName, FW_BOTH);
}

#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, FindWindowW, LPCTSTR, pClassName, LPCTSTR, pWindowName)
#else
FUNCLOG2(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, FindWindowA, LPCTSTR, pClassName, LPCTSTR, pWindowName)
#endif // UNICODE

HWND FindWindow(
    LPCTSTR pClassName,
    LPCTSTR pWindowName)
{
    return TEXT_FN(InternalFindWindowEx)(NULL, NULL, pClassName, pWindowName, FW_BOTH);
}

BOOL GetClassInfoEx(
    HINSTANCE hmod,
    LPCTSTR pszClassName,
    LPWNDCLASSEX pwc)
{
    IN_STRING strClassName;
    LPWSTR pszMenuName;
    DWORD Error;
    HMODULE hDllMod = NULL;

#ifdef LAZY_CLASS_INIT
    LazyInitClasses();
#endif

    /*
     * Make sure cleanup will work successfully.
     */
    strClassName.fAllocated = FALSE;

    BEGINCALL_CLASSV()

        FIRSTCOPYLPTSTRID(&strClassName, lpClassNameVer);

TryAgain:
        retval = (DWORD)NtUserGetClassInfoEx(hmod,
                                             strClassName.pstr,
                                             (LPWNDCLASSEXW)pwc,
                                             &pszMenuName,
                                             IS_ANSI);

        /*
         * If we failed to find the class specified, let's register it and
         * try again.
         */
        if (!retval &&
            !bRegistered &&
            lpDllName != NULL &&
            ((Error = NtCurrentTeb()->LastErrorValue) == ERROR_CANNOT_FIND_WND_CLASS
                || Error == ERROR_CLASS_DOES_NOT_EXIST)) {

                IN_STRING strClassNameNoVer;
                FIRSTCOPYLPTSTRID(&strClassNameNoVer, pszClassName);
                bRegistered = VersionRegisterClass(strClassNameNoVer.pstr->Buffer, lpDllName, lpActivationContext, &hDllMod);
                CLEANUPLPTSTR(strClassNameNoVer);
            if (bRegistered) {
                goto TryAgain;
            }
        }

        if (!retval && hDllMod != NULL) {
            FREE_LIBRARY_SAVE_ERROR(hDllMod);
            hDllMod = NULL;
        }

        if (lpActivationContext != NULL) {
            RtlReleaseActivationContext(lpActivationContext);
            lpActivationContext = NULL;
        }

        if (retval) {
            /*
             * Update these pointers so they point to something real.
             * pszMenuName is actually just the pointer the app originally
             * passed to us.
             */
            pwc->lpszMenuName = (LPTSTR)pszMenuName;
            pwc->lpszClassName = pszClassName;
        }

    ERRORTRAP(0);
    CLEANUPLPTSTR(strClassName);
    ENDCALL(BOOL);
}

BOOL GetClassInfo(
    HINSTANCE hmod,
    LPCTSTR pszClassName,
    LPWNDCLASS pwc)
{
    WNDCLASSEX WndClass;
    BOOL retval;

    retval = GetClassInfoEx(hmod, pszClassName, &WndClass);
    if (retval) {
        /*
         * Move the info from the WNDCLASSEX to the WNDCLASS structure. On
         * 64-bit plaforms we'll have 32 bits of padding between style and
         * lpfnWndProc in WNDCLASS, so start the copy from the first 64-bit
         * aligned field and hand copy the rest.
         */
        RtlCopyMemory(&(pwc->lpfnWndProc),
                      &(WndClass.lpfnWndProc),
                      sizeof(WNDCLASS) - FIELD_OFFSET(WNDCLASS, lpfnWndProc));
        pwc->style = WndClass.style;
    }

    return retval;
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetClipboardFormatNameW, UINT, wFormat, LPTSTR, pFormatName, int, chMaxCount)
#else
FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetClipboardFormatNameA, UINT, wFormat, LPTSTR, pFormatName, int, chMaxCount)
#endif // UNICODE
int GetClipboardFormatName(
    UINT wFormat,
    LPTSTR pFormatName,
    int chMaxCount)
{
    LPWSTR lpszReserve;

    BEGINCALL()

#ifdef UNICODE
        lpszReserve = pFormatName;
#else
        lpszReserve = UserLocalAlloc(0, chMaxCount * sizeof(WCHAR));
        if (!lpszReserve) {
            return 0;
        }
#endif

        retval = (DWORD)NtUserGetClipboardFormatName(wFormat,
                                                     lpszReserve,
                                                     chMaxCount);

#ifndef UNICODE
        if (retval) {
            /*
             * Do not copy out more than the requested byte count 'chMaxCount'.
             * Set retval to reflect the number of ANSI bytes.
             */
            retval = WCSToMB(lpszReserve,
                             (UINT)retval,
                             &pFormatName,
                             chMaxCount - 1,
                             FALSE);
            pFormatName[retval] = '\0';
        }
        UserLocalFree(lpszReserve);
#endif

    ERRORTRAP(0);
    ENDCALL(int);
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetKeyNameTextW, LONG, lParam, LPTSTR, pString, int, cchSize)
#else
FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetKeyNameTextA, LONG, lParam, LPTSTR, pString, int, cchSize)
#endif // UNICODE
int GetKeyNameText(
    LONG lParam,
    LPTSTR pString,
    int cchSize)
{
    LPWSTR lpszReserve;

    BEGINCALL()

#ifdef UNICODE
        lpszReserve = pString;
#else
        lpszReserve = UserLocalAlloc(0, cchSize * sizeof(WCHAR));
        if (!lpszReserve) {
            return 0;
        }
#endif

        retval = (DWORD)NtUserGetKeyNameText(
                lParam,
                lpszReserve,
                cchSize);

#ifndef UNICODE
        if (retval) {
            /*
             * Do not copy out more than the requested byte count 'nSize'.
             * Set retval to reflect the number of ANSI bytes.
             */
            retval = WCSToMB(lpszReserve,
                             (UINT)retval,
                             &pString,
                             cchSize - 1,
                             FALSE);
        }
        UserLocalFree(lpszReserve);
        ((LPSTR)pString)[retval] = '\0';
#endif

    ERRORTRAP(0);
    ENDCALL(int);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, GetMessageW, LPMSG, pmsg, HWND, hwnd, UINT, wMsgFilterMin, UINT, wMsgFilterMax)
#else
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, GetMessageA, LPMSG, pmsg, HWND, hwnd, UINT, wMsgFilterMin, UINT, wMsgFilterMax)
#endif // UNICODE
BOOL APIENTRY GetMessage(
    LPMSG pmsg,
    HWND hwnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax)
{
    BEGINCALL()

        /*
         * Prevent apps from setting hi 16 bits so we can use them internally.
         */
        if ((wMsgFilterMin | wMsgFilterMax) & RESERVED_MSG_BITS) {
            /*
             * Backward compatability with Win9x where someone is setting
             * wMsgFilterMax to -1 to get all the messages.
             */
            if (wMsgFilterMax == (UINT)-1 && !(wMsgFilterMin & RESERVED_MSG_BITS)) {
                wMsgFilterMax = 0;
            } else {
                MSGERRORCODE(ERROR_INVALID_PARAMETER);
            }
        }

#ifndef UNICODE
        /*
         * If we have pushed message for DBCS messaging, we should pass this one
         * to Apps at first...
         */
        GET_DBCS_MESSAGE_IF_EXIST(GetMessage, pmsg, wMsgFilterMin, wMsgFilterMax, TRUE);
#endif

        retval = (DWORD)NtUserGetMessage(
                pmsg,
                hwnd,
                wMsgFilterMin,
                wMsgFilterMax);

#ifndef UNICODE
        // May have a bit more work to do if this MSG is for an ANSI app

        // !!! LATER if the unichar translates into multiple ANSI chars
        // !!! then what??? Divide into two messages??  WM_SYSDEADCHAR??

        if (RtlWCSMessageWParamCharToMB(pmsg->message, &(pmsg->wParam))) {
            WPARAM dwAnsi = pmsg->wParam;
            /*
             * Build DBCS-ware wParam. (for EM_SETPASSWORDCHAR...)
             */
            BUILD_DBCS_MESSAGE_TO_CLIENTA_FROM_SERVER(pmsg, dwAnsi, TRUE, TRUE);
        } else {
            retval = 0;
        }
ExitGetMessage:
#else
        /*
         * Only LOWORD of WPARAM is valid for WM_CHAR (Unicode)....
         * (Mask off DBCS messaging information.)
         */
        BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_SERVER(pmsg->message,pmsg->wParam);
#endif // UNICODE

#if DBG && defined(GENERIC_INPUT)
    // TEST PURPOSE ONLY
    if (pmsg->message == WM_INPUT) {
        TAGMSG3(DBGTAG_PNP, "GetMessage: WM_INPUT, hwnd=%p, wp=%04x, lp=%08x", pmsg->hwnd, pmsg->wParam, pmsg->lParam);
    }
#endif // GENERIC_INPUT

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetKeyboardLayoutNameW, LPTSTR, pwszKL)
#else
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetKeyboardLayoutNameA, LPTSTR, pwszKL)
#endif // UNICODE
BOOL GetKeyboardLayoutName(
    LPTSTR pwszKL)
{
#ifdef UNICODE
    UNICODE_STRING str;
    PUNICODE_STRING pstr = &str;
#else
    PUNICODE_STRING pstr = &NtCurrentTeb()->StaticUnicodeString;
#endif

    BEGINCALL()

#ifdef UNICODE
        str.MaximumLength = KL_NAMELENGTH * sizeof(WCHAR);
        str.Buffer = pwszKL;
#endif

        retval = (DWORD)NtUserGetKeyboardLayoutName(pstr);

#ifndef UNICODE
        if (retval) {
            /*
             * Non-zero retval means some text to copy out.  Do not copy out
             * more than the requested byte count 'chMaxCount'.
             */
            WCSToMB(pstr->Buffer, -1, &pwszKL, KL_NAMELENGTH, FALSE);
        }
#endif

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, MapVirtualKeyW, UINT, wCode, UINT, wMapType)
#else
FUNCLOG2(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, MapVirtualKeyA, UINT, wCode, UINT, wMapType)
#endif // UNICODE

UINT MapVirtualKey(
    UINT wCode,
    UINT wMapType)
{
    BEGINCALL()

        retval = (DWORD)NtUserMapVirtualKeyEx(
                wCode,
                wMapType,
                0,
                FALSE);

#ifndef UNICODE
        if ((wMapType == 2) && (retval != 0)) {
            WCHAR wch = LOWORD(retval);
            retval &= ~0xFFFF;
            RtlUnicodeToMultiByteN((LPSTR)&(retval), sizeof(CHAR),
                    NULL, &wch, sizeof(WCHAR));
        }
#endif

    ERRORTRAP(0);
    ENDCALL(UINT);
}

/**************************************************************************\
* MapVirtualKeyEx
*
* 21-Feb-1995 GregoryW    Created
\**************************************************************************/

#ifndef UNICODE
static HKL  hMVKCachedHKL = 0;
static UINT uMVKCachedCP  = 0;
#endif

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, MapVirtualKeyExW, UINT, wCode, UINT, wMapType, HKL, hkl)
#else
FUNCLOG3(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, MapVirtualKeyExA, UINT, wCode, UINT, wMapType, HKL, hkl)
#endif // UNICODE

UINT MapVirtualKeyEx(
    UINT wCode,
    UINT wMapType,
    HKL hkl)
{
    BEGINCALL()

        retval = (DWORD)NtUserMapVirtualKeyEx(
                wCode,
                wMapType,
                (ULONG_PTR)hkl,
                TRUE);

#ifndef UNICODE
        if ((wMapType == 2) && (retval != 0)) {
            WCHAR wch = LOWORD(retval);

            if (hkl != hMVKCachedHKL) {
                DWORD dwCodePage;
                if (!GetLocaleInfoW(
                         HandleToUlong(hkl) & 0xffff,
                         LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                         (LPWSTR)&dwCodePage,
                         sizeof(dwCodePage) / sizeof(WCHAR)
                         )) {
                    MSGERROR();
                }
                uMVKCachedCP = dwCodePage;
                hMVKCachedHKL = hkl;
            }
            /*
             * Clear low word which contains Unicode character returned from server.
             * This preserves the high word which is used to indicate dead key status.
             */
            retval = retval & 0xffff0000;
            if (!WideCharToMultiByte(
                     uMVKCachedCP,
                     0,
                     &wch,
                     1,
                     (LPSTR)&(retval),
                     1,
                     NULL,
                     NULL)) {
                MSGERROR();
            }
        }
#endif

    ERRORTRAP(0);
    ENDCALL(UINT);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, PostMessageW , HWND, hwnd, UINT, wMsg, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, PostMessageA , HWND, hwnd, UINT, wMsg, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE
BOOL APIENTRY PostMessage(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    BEGINCALL()

        switch (wMsg) {
        case WM_DROPFILES:
            if (GetWindowProcess(hwnd) != GETPROCESSID()) {
                /*
                 * We first send a WM_COPYGLOBALDATA message to get the data into the proper
                 * context.
                 */
                HGLOBAL hg;

                hg = (HGLOBAL)SendMessage(hwnd, WM_COPYGLOBALDATA,
                        GlobalSize((HGLOBAL)wParam), wParam);
                if (!hg) {
                    MSGERROR();
                }
                wParam = (WPARAM)hg;
            }
            break;

        case LB_DIR:
        case CB_DIR:
            /*
             * Make sure this bit is set so the client side string gets
             * successfully copied over.
             */
            wParam |= DDL_POSTMSGS;
            break;
        }

#ifndef UNICODE
        /*
         * Setup DBCS Messaging for WM_CHAR...
         */
        BUILD_DBCS_MESSAGE_TO_SERVER_FROM_CLIENTA(wMsg,wParam,TRUE);

        RtlMBMessageWParamCharToWCS(wMsg, &wParam);
#endif
        retval = (DWORD)NtUserPostMessage(
                hwnd,
                wMsg,
                wParam,
                lParam);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, PostThreadMessageW, DWORD, idThread, UINT, msg, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, PostThreadMessageA, DWORD, idThread, UINT, msg, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE
BOOL APIENTRY PostThreadMessage(
    DWORD idThread,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    BEGINCALL()

#ifndef UNICODE
#ifdef FE_SB // PostThreadMessage()
        /*
         * The server always expects the characters to be unicode so
         * if this was generated from an ANSI routine convert it to Unicode
         */
        BUILD_DBCS_MESSAGE_TO_SERVER_FROM_CLIENTA(msg,wParam,TRUE);
#endif // FE_SB

        RtlMBMessageWParamCharToWCS(msg, &wParam);
#endif

        retval = (DWORD)NtUserPostThreadMessage(
                idThread,
                msg,
                wParam,
                lParam);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}


/**************************************************************************\
* StringDuplicate
*
* 03-25-96 GerardoB         Added Header.
\**************************************************************************/
#define StringDuplicate TEXT_FN(StringDuplicate)
LPTSTR StringDuplicate(LPCTSTR ptszDup) {
    LPTSTR ptsz;
    ULONG cb;

    cb = (_tcslen(ptszDup) + 1) * sizeof(TCHAR);
    ptsz = UserLocalAlloc(0, cb);
    if (ptsz != NULL) {
        RtlCopyMemory(ptsz, ptszDup, cb);
    }
    return ptsz;
}
/**************************************************************************\
* InitClsMenuName
*
* 03-22-96 GerardoB         Created.
\**************************************************************************/
#define InitClsMenuName TEXT_FN(InitClsMenuName)
BOOL InitClsMenuName (PCLSMENUNAME pcmn, LPCTSTR lpszMenuName, PIN_STRING pstrMenuName)
{
    /*
     * We check the high-word because this may be a resource-ID.
     */
    if (IS_PTR(lpszMenuName)) {
#ifdef UNICODE
        if ((pcmn->pwszClientUnicodeMenuName = StringDuplicate(lpszMenuName)) == NULL) {
            return FALSE;
        }

        if (!WCSToMB(lpszMenuName, -1, &(pcmn->pszClientAnsiMenuName), -1, TRUE)) {
            pcmn->pszClientAnsiMenuName = NULL;
        }
#else
        if ((pcmn->pszClientAnsiMenuName = StringDuplicate(lpszMenuName)) == NULL) {
            return FALSE;
        }

        if (!MBToWCS(lpszMenuName, -1, &(pcmn->pwszClientUnicodeMenuName), -1, TRUE)) {
            pcmn->pwszClientUnicodeMenuName = NULL;
        }
#endif // UNICODE
    } else {
        /* Copy the ID */
        pcmn->pszClientAnsiMenuName = (LPSTR)lpszMenuName;
        pcmn->pwszClientUnicodeMenuName = (LPWSTR)lpszMenuName;
    }

    COPYLPTSTRID(pstrMenuName, lpszMenuName);
    pcmn->pusMenuName = pstrMenuName->pstr;

    return TRUE;

    goto errorexit; /* Keep the compiler happy */

errorexit: /* Used by COPYLPTSTRID */
#ifdef UNICODE
    UserLocalFree(pcmn->pwszClientUnicodeMenuName);
    pcmn->pwszClientUnicodeMenuName = NULL;
#else
    UserLocalFree(pcmn->pszClientAnsiMenuName);
    pcmn->pszClientAnsiMenuName = NULL;
#endif
    return FALSE;
}

/**************************************************************************\
* SetClassLong
*
* 03-22-96 GerardoB      Moved from client\cltxt.h & client\ntstubs.c
\**************************************************************************/
#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, ULONG_PTR, APIENTRY, SetClassLongPtrW, HWND, hwnd, int, nIndex, LONG_PTR, dwNewLong)
#else
FUNCLOG3(LOG_GENERAL, ULONG_PTR, APIENTRY, SetClassLongPtrA, HWND, hwnd, int, nIndex, LONG_PTR, dwNewLong)
#endif // UNICODE
ULONG_PTR APIENTRY SetClassLongPtr(HWND hwnd, int nIndex, LONG_PTR dwNewLong)
{
    CLSMENUNAME cmn;
    IN_STRING strMenuName;

    switch (nIndex) {
        case GCLP_MENUNAME:
            if (!InitClsMenuName(&cmn, (LPCTSTR) dwNewLong, &strMenuName)) {
                RIPERR0(ERROR_INVALID_HANDLE, RIP_WARNING, "SetClassLong: InitClsMenuName failed");
                return 0;
            }
            dwNewLong = (ULONG_PTR) &cmn;
            break;

        case GCLP_HBRBACKGROUND:
            if ((DWORD)dwNewLong > COLOR_ENDCOLORS) {
                /*
                 * Let gdi validate the brush. If it's invalid, then gdi
                 * will log a warning. No need to rip twice so we'll just
                 * set the last error.
                 */
                if (GdiValidateHandle((HBRUSH)dwNewLong) == FALSE) {
                    RIPERR0(ERROR_INVALID_HANDLE, RIP_VERBOSE, "");
                    return 0;
                }
            }
            break;
    }

    BEGINCALL()

    retval = (ULONG_PTR)NtUserSetClassLongPtr(hwnd, nIndex, dwNewLong, IS_ANSI);

    ERRORTRAP(0);

    /* Clean up */
    switch (nIndex) {
        case GCLP_MENUNAME:
            CLEANUPLPTSTR(strMenuName); /* Initialized by InitClsMenuName */
            /*
             * We free either the old strings (returned by the kernel),
             *  or the new ones if the kernel call failed
             */
            if (IS_PTR(cmn.pszClientAnsiMenuName)) {
                UserLocalFree(KPVOID_TO_PVOID(cmn.pszClientAnsiMenuName));
            }
            if (IS_PTR(cmn.pwszClientUnicodeMenuName)) {
                UserLocalFree(KPVOID_TO_PVOID(cmn.pwszClientUnicodeMenuName));
            }

            break;
    }

    ENDCALL(ULONG_PTR);
}

#ifdef _WIN64
DWORD  APIENTRY SetClassLong(HWND hwnd, int nIndex, LONG dwNewLong)
{
    BEGINCALL()

    retval = (DWORD)NtUserSetClassLong(hwnd, nIndex, dwNewLong, IS_ANSI);

    ERRORTRAP(0);
    ENDCALL(DWORD);
}
#endif

/**************************************************************************\
* RegisterClassExWOW
*
* 03-22-96 GerardoB      Added Header
\**************************************************************************/
ATOM TEXT_FN(RegisterClassExWOW)(
    WNDCLASSEX *lpWndClass,
    LPDWORD pdwWOWstuff,
    WORD fnid,
    DWORD dwFlags)
{
    WNDCLASSEX WndClass;
    IN_STRING strClassName;
    IN_STRING strClassNameVer;
    IN_STRING strMenuName;
    DWORD dwExpWinVer;
    CLSMENUNAME cmn;
    TCHAR ClassNameVer[MAX_ATOM_LEN];
    LPTSTR lpClassNameVer;
    PACTIVATION_CONTEXT lpActivationContext = NULL;

#ifdef LAZY_CLASS_INIT
    LazyInitClasses();
#endif

    strClassName.fAllocated = 0;
    strClassNameVer.fAllocated = 0;
    strMenuName.fAllocated  = 0;

    /*
     * Skip validation for our classes
     */
    if (fnid != 0) {
        /*
         * This is a hack to bypass validation for DDE classes
         * specifically, allow them to use hmodUser.
         */
         if (fnid == FNID_DDE_BIT) {
             fnid = 0;
         }
         dwExpWinVer = VER40;
    } else {
        if (lpWndClass->cbSize != sizeof(WNDCLASSEX)) {
            RIPMSG0(RIP_WARNING, "RegisterClass: Invalid cbSize");
        }

        if (lpWndClass->cbClsExtra < 0 || lpWndClass->cbWndExtra < 0) {
            RIPMSG0(RIP_WARNING, "RegisterClass: invalid cb*Extra");
            goto BadParameter;
        }

        /*
         * Validate hInstance
         * Don't allow 4.0 apps to use hmodUser
         */
         if ((lpWndClass->hInstance == hmodUser)
                && (GetClientInfo()->dwExpWinVer >= VER40)) {
             RIPMSG0(RIP_WARNING, "RegisterClass: Cannot use USER's hInstance");
             goto BadParameter;
         } else if (lpWndClass->hInstance == NULL) {
            /*
             * For 32 bit apps we need to fix up the hInstance because Win 95 does
             * this in their thunk MapHInstLS
             */

            lpWndClass->hInstance = GetModuleHandle(NULL);
            RIPMSG1(RIP_VERBOSE, "RegisterClass: fixing up NULL hmodule to %#p",
                    lpWndClass->hInstance);
        }

        dwExpWinVer = GETEXPWINVER(lpWndClass->hInstance);


        /*
         * Check for valid style bits and strip if appropriate
         */
        if (lpWndClass->style & ~CS_VALID40) {

            if (dwExpWinVer > VER31) {
                RIPMSG0(RIP_WARNING, "RegisterClass: Invalid class style");
                goto BadParameter;
            }

            /*
             * Old application - strip bogus bits and pass through
             */
            RIPMSG0(RIP_WARNING, "RegisterClass: Invalid class style, stripping bad styles");
            lpWndClass->style &= CS_VALID40;
        }

        /*
         * Validate hbrBackground
         */
        if (lpWndClass->hbrBackground > (HBRUSH)COLOR_MAX
                && !GdiValidateHandle(lpWndClass->hbrBackground)) {

            RIPMSG1(RIP_WARNING, "RegisterClass: Invalid class brush:%#p", lpWndClass->hbrBackground);
            if (dwExpWinVer > VER30) {
                goto BadParameter;
            }

            lpWndClass->hbrBackground = NULL;
        }

    }

    if (!InitClsMenuName(&cmn, lpWndClass->lpszMenuName, &strMenuName)) {
        return FALSE;
    }

    BEGINCALL()
        WndClass = *lpWndClass;

#ifndef UNICODE
        dwFlags |= CSF_ANSIPROC;
#endif // UNICODE

        if (dwExpWinVer > VER31) {
            dwFlags |= CSF_WIN40COMPAT;
        }

        if (GetClientInfo()->dwTIFlags & TIF_16BIT) {
            /*
             * No Fusion redirection for 16BIT apps.
             */
            if (!(GetAppCompatFlags2(VERMAX) & GACF2_FORCEFUSION)) {
                dwFlags &= ~CW_FLAGS_VERSIONCLASS;
            }
        }

        if (dwFlags & CSF_VERSIONCLASS) {
            lpClassNameVer = (LPTSTR)ClassNameToVersion((LPCWSTR)lpWndClass->lpszClassName, (LPWSTR)ClassNameVer, NULL, NULL, IS_ANSI);

            if (lpClassNameVer == NULL) {
                RIPMSG0(RIP_WARNING, "RegisterClass: Couldn't resolve class name");
                MSGERROR();
            }
        } else {
            lpClassNameVer = (LPTSTR)lpWndClass->lpszClassName;
        }

        COPYLPTSTRID(&strClassName, (LPTSTR)lpWndClass->lpszClassName);
        COPYLPTSTRID(&strClassNameVer, (LPTSTR)lpClassNameVer);

        retval = NtUserRegisterClassExWOW(
                &WndClass,
                strClassName.pstr,
                strClassNameVer.pstr,
                &cmn,
                fnid,
                dwFlags,
                pdwWOWstuff);

        /*
         * Return the atom associated with this class or if earlier
         * than Win 3.1 convert it to a strict BOOL (some apps check)
         */
        if (GETEXPWINVER(lpWndClass->hInstance) < VER31)
            retval = !!retval;

    ERRORTRAP(0);
    CLEANUPLPTSTR(strMenuName);     /* Initialized by InitClsMenuName */
    CLEANUPLPTSTR(strClassName);
    CLEANUPLPTSTR(strClassNameVer);

    if (lpActivationContext != NULL) {
        RtlReleaseActivationContext(lpActivationContext);
        lpActivationContext = NULL;
    }

    if (!retval) {
        if (IS_PTR(cmn.pszClientAnsiMenuName)) {
            UserLocalFree(KPVOID_TO_PVOID(cmn.pszClientAnsiMenuName));
        }
        if (IS_PTR(cmn.pwszClientUnicodeMenuName)) {
            UserLocalFree(KPVOID_TO_PVOID(cmn.pwszClientUnicodeMenuName));
        }
    }
    ENDCALL(BOOL);

BadParameter:
    RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "RegisterClass: Invalid Parameter");
    return FALSE;
}

#ifdef UNICODE
FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, RegisterWindowMessageW , LPCTSTR, pString)
#else
FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, RegisterWindowMessageA , LPCTSTR, pString)
#endif // UNICODE
UINT RegisterWindowMessage(
    LPCTSTR pString)
{
    IN_STRING str;

    /*
     * Make sure cleanup will work successfully
     */
    str.fAllocated = FALSE;

    BEGINCALL()

        FIRSTCOPYLPTSTR(&str, (LPTSTR)pString);

        retval = (DWORD)NtUserRegisterWindowMessage(
                str.pstr);

    ERRORTRAP(0);
    CLEANUPLPTSTR(str);
    ENDCALL(UINT);
}

#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, HANDLE, DUMMYCALLINGTYPE, RemovePropW , HWND, hwnd, LPCTSTR, pString)
#else
FUNCLOG2(LOG_GENERAL, HANDLE, DUMMYCALLINGTYPE, RemovePropA , HWND, hwnd, LPCTSTR, pString)
#endif // UNICODE

HANDLE RemoveProp(
    HWND hwnd,
    LPCTSTR pString)
{
    ATOM atomProp;
    DWORD dwProp;

    BEGINCALL()

        if (IS_PTR(pString)) {
            atomProp = GlobalFindAtom(pString);
            if (atomProp == 0)
                MSGERROR();
            dwProp = MAKELONG(atomProp, TRUE);
        } else
            dwProp = MAKELONG(PTR_TO_ID(pString), FALSE);

        retval = (ULONG_PTR)NtUserRemoveProp(
                hwnd,
                dwProp);

        if (retval != 0 && IS_PTR(pString))
            GlobalDeleteAtom(atomProp);

    ERRORTRAP(0);
    ENDCALL(HANDLE);
}

#ifdef UNICODE
FUNCLOG6(LOG_GENERAL, BOOL, APIENTRY, SendMessageCallbackW, HWND, hwnd, UINT, wMsg, WPARAM, wParam, LPARAM, lParam, SENDASYNCPROC, lpResultCallBack, ULONG_PTR, dwData)
#else
FUNCLOG6(LOG_GENERAL, BOOL, APIENTRY, SendMessageCallbackA, HWND, hwnd, UINT, wMsg, WPARAM, wParam, LPARAM, lParam, SENDASYNCPROC, lpResultCallBack, ULONG_PTR, dwData)
#endif // UNICODE
BOOL APIENTRY SendMessageCallback(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam,
    SENDASYNCPROC lpResultCallBack,
    ULONG_PTR dwData)
{
    SNDMSGCALLBACK smcb;

    BEGINCALL()

        smcb.dwData = dwData;
        smcb.lpResultCallBack = lpResultCallBack;

        retval = (DWORD)CsSendMessage(hwnd, wMsg, wParam, lParam,
            (ULONG_PTR)&smcb, FNID_SENDMESSAGECALLBACK, IS_ANSI);
    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, SendNotifyMessageW , HWND, hwnd, UINT, wMsg, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, SendNotifyMessageA , HWND, hwnd, UINT, wMsg, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE

BOOL APIENTRY SendNotifyMessage(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    BEGINCALL()

        retval = (DWORD)CsSendMessage(hwnd, wMsg, wParam, lParam,
                0L, FNID_SENDNOTIFYMESSAGE, IS_ANSI);
    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetPropW , HWND, hwnd, LPCTSTR, pString, HANDLE, hData)
#else
FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetPropA , HWND, hwnd, LPCTSTR, pString, HANDLE, hData)
#endif // UNICODE

BOOL SetProp(
    HWND hwnd,
    LPCTSTR pString,
    HANDLE hData)
{
    ATOM atomProp;
    DWORD dwProp;

    BEGINCALL()

        if (IS_PTR(pString)) {
            atomProp = GlobalAddAtom(pString);
            if (atomProp == 0)
                MSGERROR();
            dwProp = MAKELONG(atomProp, TRUE);
        } else
            dwProp = MAKELONG(PTR_TO_ID(pString), FALSE);

        retval = (DWORD)NtUserSetProp(
                hwnd,
                dwProp,
                hData);

        /*
         * If it failed, get rid of the atom
         */
        if (retval == FALSE && IS_PTR(pString))
            GlobalDeleteAtom(atomProp);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, UnregisterClassW, LPCTSTR, pszClassName, HINSTANCE, hModule)
#else
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, UnregisterClassA, LPCTSTR, pszClassName, HINSTANCE, hModule)
#endif // UNICODE
BOOL UnregisterClass(
    LPCTSTR pszClassName,
    HINSTANCE hModule)
{
    IN_STRING strClassName;
    CLSMENUNAME cmn;

    /*
     * Make sure cleanup will work successfully
     */
    strClassName.fAllocated = FALSE;

    BEGINCALL_CLASSV()

        FIRSTCOPYLPTSTRID(&strClassName, lpClassNameVer);

        retval = (DWORD)NtUserUnregisterClass(
                strClassName.pstr,
                hModule,
                &cmn);


        /*
         * Check explicity for TRUE so we don't get a !FALSE when
         * converttogui fails and the NtUser returns a status code intead of bool.
         */
        if (retval == TRUE) {
            /*
             * Free the menu strings if they are not resource IDs
             */
            if (IS_PTR(cmn.pszClientAnsiMenuName)) {
                UserLocalFree(KPVOID_TO_PVOID(cmn.pszClientAnsiMenuName));
            }
            if (IS_PTR(cmn.pwszClientUnicodeMenuName)) {
                UserLocalFree(KPVOID_TO_PVOID(cmn.pwszClientUnicodeMenuName));
            }
        }

    ERRORTRAP(0);
    CLEANUPLPTSTR(strClassName);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG1(LOG_GENERAL, SHORT, DUMMYCALLINGTYPE, VkKeyScanW , TCHAR, cChar)
#else
FUNCLOG1(LOG_GENERAL, SHORT, DUMMYCALLINGTYPE, VkKeyScanA , TCHAR, cChar)
#endif // UNICODE

SHORT VkKeyScan(
    TCHAR cChar)
{
    WCHAR wChar;

    BEGINCALL()

#ifdef UNICODE
        wChar = cChar;
#else
#ifdef FE_SB // VkKeyScan()
        /*
         * Return 0xFFFFFFFF for DBCS LeadByte character.
         */
        if (IsDBCSLeadByte(cChar)) {
            MSGERROR();
        }
#endif // FE_SB

        RtlMultiByteToUnicodeN((LPWSTR)&(wChar), sizeof(WCHAR), NULL, &cChar, sizeof(CHAR));
#endif // UNICODE

        retval = (DWORD)NtUserVkKeyScanEx(
                wChar,
                0,
                FALSE);

    ERRORTRAP(-1);
    ENDCALL(SHORT);
}

#ifndef UNICODE
static HKL  hVKSCachedHKL = 0;
static UINT uVKSCachedCP  = 0;
#endif
#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, SHORT, DUMMYCALLINGTYPE, VkKeyScanExW, TCHAR, cChar, HKL, hkl)
#else
FUNCLOG2(LOG_GENERAL, SHORT, DUMMYCALLINGTYPE, VkKeyScanExA, TCHAR, cChar, HKL, hkl)
#endif // UNICODE
SHORT VkKeyScanEx(
    TCHAR cChar,
    HKL hkl)
{
    WCHAR wChar;
    BEGINCALL()

#ifdef UNICODE
        wChar = cChar;
#else
        if (hkl != hVKSCachedHKL) {
            DWORD dwCodePage;
            if (!GetLocaleInfoW(
                     HandleToUlong(hkl) & 0xffff,
                     LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                     (LPWSTR)&dwCodePage,
                     sizeof(dwCodePage) / sizeof(WCHAR)
                     )) {
                MSGERROR();
            }
            uVKSCachedCP = dwCodePage;
            hVKSCachedHKL = hkl;
        }

#ifdef FE_SB // VkKeyScanEx()
        /*
         * Return 0xFFFFFFFF for DBCS LeadByte character.
         */
        if (IsDBCSLeadByteEx(uVKSCachedCP,cChar)) {
            MSGERROR();
        }
#endif // FE_SB

        if (!MultiByteToWideChar(
                 uVKSCachedCP,
                 0,
                 &cChar,
                 1,
                 &wChar,
                 1)) {
            MSGERROR();
        }
#endif // UNICODE

        retval = (DWORD)NtUserVkKeyScanEx(
                wChar,
                (ULONG_PTR)hkl,
                TRUE);

    ERRORTRAP(-1);
    ENDCALL(SHORT);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDisplayDevicesW, LPCTSTR, lpszDevice, DWORD, iDevNum, PDISPLAY_DEVICE, lpDisplayDevice, DWORD, dwFlags)
#else
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDisplayDevicesA, LPCTSTR, lpszDevice, DWORD, iDevNum, PDISPLAY_DEVICE, lpDisplayDevice, DWORD, dwFlags)
#endif // UNICODE
BOOL
EnumDisplayDevices(
    LPCTSTR lpszDevice,
    DWORD iDevNum,
    PDISPLAY_DEVICE lpDisplayDevice,
    DWORD dwFlags)
{
    UNICODE_STRING  UnicodeString;
    PUNICODE_STRING pUnicodeString = NULL;
    NTSTATUS Status;
    DISPLAY_DEVICEW tmpDisplayDevice;

    //
    // Clear out things to make sure the caller passes in appropriate
    // parameters
    //

    ZeroMemory(((PUCHAR)lpDisplayDevice) + sizeof(DWORD),
               lpDisplayDevice->cb - sizeof(DWORD));

    tmpDisplayDevice.cb = sizeof(DISPLAY_DEVICEW);

    if (lpszDevice) {

#ifdef UNICODE

        RtlInitUnicodeString(&UnicodeString, lpszDevice);

#else

        ANSI_STRING     AnsiString;

        UnicodeString = NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString, (LPSTR)lpszDevice);

        if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeString,
                                                     &AnsiString,
                                                     FALSE))) {
            return FALSE;
        }

#endif

        pUnicodeString = &UnicodeString;
    }

    Status = NtUserEnumDisplayDevices(
                pUnicodeString,
                iDevNum,
                &tmpDisplayDevice,
                dwFlags);

    if (NT_SUCCESS(Status))
    {
#ifndef UNICODE
        LPSTR psz;

        if (lpDisplayDevice->cb >= FIELD_OFFSET(DISPLAY_DEVICE, DeviceString)) {
            psz = (LPSTR)&(lpDisplayDevice->DeviceName[0]);
            WCSToMB(&(tmpDisplayDevice.DeviceName[0]), -1, &psz, 32, FALSE);
        }

        if (lpDisplayDevice->cb >= FIELD_OFFSET(DISPLAY_DEVICE, StateFlags)) {
            psz = (LPSTR)&(lpDisplayDevice->DeviceString[0]);
            WCSToMB(&(tmpDisplayDevice.DeviceString[0]), -1, &psz, 128, FALSE);
        }

        if (lpDisplayDevice->cb >= FIELD_OFFSET(DISPLAY_DEVICE, DeviceID)) {
            lpDisplayDevice->StateFlags = tmpDisplayDevice.StateFlags;
        }

        if (lpDisplayDevice->cb >= FIELD_OFFSET(DISPLAY_DEVICE, DeviceKey)) {
            psz = (LPSTR)&(lpDisplayDevice->DeviceID[0]);
            WCSToMB(&(tmpDisplayDevice.DeviceID[0]), -1, &psz, 128, FALSE);
        }
        if (lpDisplayDevice->cb >= sizeof(DISPLAY_DEVICE)) {
            psz = (LPSTR)&(lpDisplayDevice->DeviceKey[0]);
            WCSToMB(&(tmpDisplayDevice.DeviceKey[0]), -1, &psz, 128, FALSE);
        }
#else

        //
        // Copy the contents of the tmpDisplayDevice back to the
        // user supplied buffer.  Make sure not to overwrite the original
        // size field.
        //

        RtlMoveMemory((PUCHAR)lpDisplayDevice + sizeof(DWORD),
                      ((PUCHAR)&tmpDisplayDevice + sizeof(DWORD)),
                      lpDisplayDevice->cb - sizeof(DWORD));

#endif

        return TRUE;
    }

    return FALSE;
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDisplaySettingsW , LPCTSTR, lpszDeviceName, DWORD, iModeNum, LPDEVMODE, lpDevMode)
#else
FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDisplaySettingsA, LPCTSTR, lpszDeviceName, DWORD, iModeNum, LPDEVMODE, lpDevMode)
#endif // UNICODE
BOOL EnumDisplaySettings(
    LPCTSTR   lpszDeviceName,
    DWORD     iModeNum,
    LPDEVMODE lpDevMode)
{

    //
    // Work-around Win95 problem which does not require the caller
    // to initialize these two fields.
    //

    lpDevMode->dmDriverExtra = 0;
    lpDevMode->dmSize = FIELD_OFFSET(DEVMODE, dmICMMethod);

    return EnumDisplaySettingsEx(lpszDeviceName, iModeNum, lpDevMode, 0);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDisplaySettingsExW, LPCTSTR, lpszDeviceName, DWORD, iModeNum, LPDEVMODE, lpDevMode, DWORD, dwFlags)
#else
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDisplaySettingsExA, LPCTSTR, lpszDeviceName, DWORD, iModeNum, LPDEVMODE, lpDevMode, DWORD, dwFlags)
#endif // UNICODE
BOOL EnumDisplaySettingsEx(
    LPCTSTR   lpszDeviceName,
    DWORD     iModeNum,
    LPDEVMODE lpDevMode,
    DWORD     dwFlags)
{
    UNICODE_STRING  UnicodeString;
    PUNICODE_STRING pUnicodeString = NULL;
    LPDEVMODEW      lpDevModeReserve;
    BOOL            retval = FALSE;
    WORD            size = lpDevMode->dmSize;

    if (lpszDeviceName) {

#ifdef UNICODE

        RtlInitUnicodeString(&UnicodeString, lpszDeviceName);

#else

        ANSI_STRING     AnsiString;

        UnicodeString = NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString, (LPSTR)lpszDeviceName);

        if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeString,
                                                     &AnsiString,
                                                     FALSE))) {
            return FALSE;
        }

#endif

        pUnicodeString = &UnicodeString;
    }

    /*
     * Currently -2 is reserved (undocumented function of the NT api.
     * remove the check is win95 implements this.
     * -> -1 returns the content of the registry at the time of the call
     *
     *
     * if (iModeNum == (DWORD) -2)
     * {
     *     return FALSE;
     * }
     *
     *
     * -1 should return the current DEVMODE for the device.
     * This is handled in the kernel part of the function, so we pass it on.
     *
     *
     *
     * We will always request a full DEVMODE from the kernel.
     * So allocate the space needed
     *
     */
    lpDevModeReserve = UserLocalAlloc(HEAP_ZERO_MEMORY,
                                      sizeof(DEVMODEW) + lpDevMode->dmDriverExtra);
    if (lpDevModeReserve) {

        lpDevModeReserve->dmSize = sizeof(DEVMODEW);
        lpDevModeReserve->dmDriverExtra = lpDevMode->dmDriverExtra;

        /*
         * Get the information
         */
        retval = (NT_SUCCESS(NtUserEnumDisplaySettings(pUnicodeString,
                                                       iModeNum,
                                                       lpDevModeReserve,
                                                       dwFlags)));
        if (retval) {

#ifndef UNICODE
            LPSTR psz;
#endif

            /*
             * return only the amount of information requested.
             * For ANSI, this requires a conversion.
             */

            /*
             * First, copy the driver extra information
             */

            if (lpDevMode->dmDriverExtra && lpDevModeReserve->dmDriverExtra) {
                RtlMoveMemory(((PUCHAR)lpDevMode) + size,
                              lpDevModeReserve + 1,
                              min(lpDevMode->dmDriverExtra,
                                  lpDevModeReserve->dmDriverExtra));
            }

#ifndef UNICODE
            psz = (LPSTR)&(lpDevMode->dmDeviceName[0]);

            retval = WCSToMB(lpDevModeReserve->dmDeviceName,
                             -1,
                             &psz,
                             32,
                             FALSE);

            RtlMoveMemory(&lpDevMode->dmSpecVersion,
                          &lpDevModeReserve->dmSpecVersion,
                          min(size, FIELD_OFFSET(DEVMODE,dmFormName)) -
                              FIELD_OFFSET(DEVMODE,dmSpecVersion));

            lpDevMode->dmSize = size;

            if (size >= FIELD_OFFSET(DEVMODE,dmFormName)) {
                psz = (LPSTR)&(lpDevMode->dmFormName[0]);

                retval = WCSToMB(lpDevModeReserve->dmFormName, -1, &psz, 32, FALSE);
            }

            if (size > FIELD_OFFSET(DEVMODE,dmBitsPerPel)) {
                RtlMoveMemory(&lpDevMode->dmBitsPerPel,
                              &lpDevModeReserve->dmBitsPerPel,
                              lpDevMode->dmSize +
                                  lpDevMode->dmDriverExtra -
                                  FIELD_OFFSET(DEVMODE,dmBitsPerPel));
            }

#else
            RtlMoveMemory(lpDevMode, lpDevModeReserve, size);

            lpDevMode->dmSize = size;

#endif

            if (size != lpDevMode->dmSize) {
                RIPMSG0(RIP_WARNING, "EnumDisplaySettings : Error in dmSize");
            }

            /*
             * Don't return invalid field flags to the application
             * Add any other new ones here.
             *
             * We assume apps at least have up to dmDisplayFrenquency for
             * now ...
             */

            if (size < FIELD_OFFSET(DEVMODE,dmPanningWidth))
                lpDevMode->dmFields &= ~DM_PANNINGWIDTH;

            if (size < FIELD_OFFSET(DEVMODE,dmPanningHeight))
                lpDevMode->dmFields &= ~DM_PANNINGHEIGHT;
        }

        UserLocalFree(lpDevModeReserve);
    }

    return retval;
}


#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, LONG, DUMMYCALLINGTYPE, ChangeDisplaySettingsW, LPDEVMODE, lpDevMode, DWORD, dwFlags)
#else
FUNCLOG2(LOG_GENERAL, LONG, DUMMYCALLINGTYPE, ChangeDisplaySettingsA, LPDEVMODE, lpDevMode, DWORD, dwFlags)
#endif // UNICODE
LONG ChangeDisplaySettings(
    LPDEVMODE lpDevMode,
    DWORD     dwFlags)
{
    /*
     * Compatibility.
     */
    if (lpDevMode) {
        lpDevMode->dmDriverExtra = 0;
    }

    return ChangeDisplaySettingsEx(NULL, lpDevMode, NULL, dwFlags, NULL);
}

#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, LONG, DUMMYCALLINGTYPE, ChangeDisplaySettingsExW, LPCTSTR, lpszDeviceName, LPDEVMODE, lpDevMode, HWND, hwnd, DWORD, dwFlags, LPVOID, lParam)
#else
FUNCLOG5(LOG_GENERAL, LONG, DUMMYCALLINGTYPE, ChangeDisplaySettingsExA, LPCTSTR, lpszDeviceName, LPDEVMODE, lpDevMode, HWND, hwnd, DWORD, dwFlags, LPVOID, lParam)
#endif // UNICODE
LONG ChangeDisplaySettingsEx(
    LPCTSTR   lpszDeviceName,
    LPDEVMODE lpDevMode,
    HWND      hwnd,
    DWORD     dwFlags,
    LPVOID    lParam)
{
#ifndef UNICODE
    ANSI_STRING     AnsiString;
#endif

    UNICODE_STRING  UnicodeString;
    PUNICODE_STRING pUnicodeString = NULL;
    LONG            status = DISP_CHANGE_FAILED;
    LPDEVMODEW      lpDevModeW;

    if (hwnd != NULL) {
        return DISP_CHANGE_BADPARAM;
    }

    if (lpszDeviceName) {
#ifdef UNICODE
        RtlInitUnicodeString(&UnicodeString, lpszDeviceName);
#else
        UnicodeString = NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString, (LPSTR)lpszDeviceName);

        if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeString,
                                                     &AnsiString,
                                                     FALSE))) {
            return FALSE;
        }
#endif

        pUnicodeString = &UnicodeString;
    }

#ifdef UNICODE
    lpDevModeW = lpDevMode;
#else
    lpDevModeW = NULL;

    if (lpDevMode) {
        lpDevModeW = GdiConvertToDevmodeW(lpDevMode);
        if (lpDevModeW == NULL) {
            return FALSE;
        }
    }
#endif

    status = NtUserChangeDisplaySettings(pUnicodeString,
                                         lpDevModeW,
                                         dwFlags,
                                         lParam);

#ifndef UNICODE
    if (lpDevMode) {
        UserLocalFree(lpDevModeW);
    }
#endif

    return status;
}


#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CallMsgFilterW , LPMSG, pmsg, int, nCode)
#else
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CallMsgFilterA , LPMSG, pmsg, int, nCode)
#endif // UNICODE
BOOL CallMsgFilter(
    LPMSG pmsg,
    int   nCode)
{
    PCLIENTINFO pci;
    MSG         msg;

    BEGINCALLCONNECT()

        /*
         * If we're not hooked, don't bother going to the server
         */
        pci = GetClientInfo();
        if (!IsHooked(pci, (WH_MSGFILTER | WH_SYSMSGFILTER))) {
            return FALSE;
        }

        /*
         * Don't allow apps to use the hiword of the message parameter.
         */
        if (pmsg->message & RESERVED_MSG_BITS) {
            MSGERRORCODE(ERROR_INVALID_PARAMETER);
        }
        msg = *pmsg;

#ifndef UNICODE
        switch (pmsg->message) {
#ifdef FE_SB // CallMsgFilter()
        case WM_CHAR:
        case EM_SETPASSWORDCHAR:
#ifndef LATER
             /*
              * we should not return "TRUE" everytime for DBCS leadbyte character...
              * but should convert DBCS character to Unicode correctly.. How I can do ??
              * then ,finally, we just take what we did in NT 3.51, it means do nothing..
              */
#else
             /*
              * Build DBCS-aware message.
              */
             BUILD_DBCS_MESSAGE_TO_SERVER_FROM_CLIENTA(pmsg->message,pmsg->wParam,TRUE);
             /*
              * Fall through.....
              */
#endif // LATER
#else
        case WM_CHAR:
        case EM_SETPASSWORDCHAR:
#endif // FE_SB
        case WM_CHARTOITEM:
        case WM_DEADCHAR:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
        case WM_MENUCHAR:
#ifdef FE_IME // CallMsgFilter()
        case WM_IME_CHAR:
        case WM_IME_COMPOSITION:
#endif // FE_IME

            RtlMBMessageWParamCharToWCS( msg.message, &(msg.wParam));
            break;
        }
#endif //!UNICODE

        retval = (DWORD)NtUserCallMsgFilter(
                &msg,
                nCode);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG7(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DrawCaptionTempW, HWND, hwnd, HDC, hdc, LPCRECT, lprc, HFONT, hFont, HICON, hicon, LPCTSTR, lpText, UINT, flags)
#else
FUNCLOG7(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DrawCaptionTempA, HWND, hwnd, HDC, hdc, LPCRECT, lprc, HFONT, hFont, HICON, hicon, LPCTSTR, lpText, UINT, flags)
#endif // UNICODE
BOOL DrawCaptionTemp(
    HWND hwnd,
    HDC hdc,
    LPCRECT lprc,
    HFONT hFont,
    HICON hicon,
    LPCTSTR lpText,
    UINT flags)
{
    HDC hdcr;
    IN_STRING strText;

    /*
     * Make sure cleanup will work successfully
     */
    strText.fAllocated = FALSE;

    BEGINCALL()

        if (IsMetaFile(hdc)) return FALSE;

        hdcr = GdiConvertAndCheckDC(hdc);
        if (hdcr == (HDC)0)
            return FALSE;

        FIRSTCOPYLPTSTRIDOPT(&strText, lpText);

        retval = (DWORD)NtUserDrawCaptionTemp(
                hwnd,
                hdc,
                lprc,
                hFont,
                hicon,
                strText.pstr,
                flags);

    ERRORTRAP(0);
    CLEANUPLPTSTR(strText);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, UINT, WINUSERAPI, RealGetWindowClassW, HWND, hwnd, LPTSTR, ptszClassName, UINT, cchClassNameMax)
#else
FUNCLOG3(LOG_GENERAL, UINT, WINUSERAPI, RealGetWindowClassA, HWND, hwnd, LPTSTR, ptszClassName, UINT, cchClassNameMax)
#endif // UNICODE

WINUSERAPI UINT WINAPI
RealGetWindowClass(
    HWND hwnd,
    LPTSTR ptszClassName,
    UINT cchClassNameMax)
{
    UNICODE_STRING strClassName;
    int retval;

    strClassName.MaximumLength = (USHORT)(cchClassNameMax * sizeof(WCHAR));

#ifndef UNICODE
    strClassName.Buffer = UserLocalAlloc(0, strClassName.MaximumLength);
    if (!strClassName.Buffer) {
        return 0;
    }
#else
    strClassName.Buffer = ptszClassName;
#endif

    retval = NtUserGetClassName(hwnd, TRUE, &strClassName);

#ifndef UNICODE
    if (retval || (cchClassNameMax == 1)) {
        /*
         * Copy the result
         */
        retval = WCSToMB(strClassName.Buffer,
                         retval,
                         &ptszClassName,
                         cchClassNameMax - 1,
                         FALSE);
        ptszClassName[retval] = '\0';
    }
    UserLocalFree(strClassName.Buffer);
#endif

  return retval;
}

WINUSERAPI BOOL WINAPI GetAltTabInfo(
    HWND hwnd,
    int iItem,
    PALTTABINFO pati,
    LPTSTR pszItemText,
    UINT cchItemText OPTIONAL)
{
    BEGINCALL()

    retval = (DWORD)NtUserGetAltTabInfo(hwnd,
                                        iItem,
                                        pati,
                                        (LPWSTR)pszItemText,
                                        cchItemText,
                                        IS_ANSI);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\precomp.h ===
/*
 * Core NT headers
 */
#define NONTOSPINTERLOCK
#include <ntosp.h>

#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrdll.h>

/*
 * CRT headers.
 */
#include <limits.h>
#include <stdio.h>

/*
 * USER client specific headers.
 */
#include "usercli.h"

#include <windowsx.h>
#include <newres.h>
#include <asdf.h>

#include <winsta.h>
#include <sxstypes.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\queuec.c ===
/****************************** Module Header ******************************\
* Module Name: queuec.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the low-level code for working with the Q structure.
*
* History:
* 11-Mar-1993 JerrySh   Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* SetMessageQueue
*
* Dummy API for binary win32s compatibility.
*
* 12-1-92 sanfords created
\***************************************************************************/

FUNCLOG1(LOG_GENERAL,BOOL , WINAPI, SetMessageQueue, int, cMessagesMax)
BOOL
WINAPI
SetMessageQueue(
    int cMessagesMax)
{
    UNREFERENCED_PARAMETER(cMessagesMax);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\ntstubs.c ===
/**************************************************************************\
* Module Name: ntstubs.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* client side API stubs
*
* History:
* 03-19-95 JimA             Created.
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define CLIENTSIDE 1

#include <dbt.h>

#include "ntsend.h"
#include "cfgmgr32.h"
#include "csrhlpr.h"

WINUSERAPI
BOOL
WINAPI
SetSysColors(
    int cElements,
    CONST INT * lpaElements,
    CONST COLORREF * lpaRgbValues)
{

    return NtUserSetSysColors(cElements,
                              lpaElements,
                              lpaRgbValues,
                              SSCF_NOTIFY | SSCF_FORCESOLIDCOLOR | SSCF_SETMAGICCOLORS);
}


HWND WOWFindWindow(
    LPCSTR pClassName,
    LPCSTR pWindowName)
{
    return InternalFindWindowExA(NULL, NULL, pClassName, pWindowName, FW_16BIT);
}

#ifdef IMM_PER_LOGON
VOID UpdatePerUserImmEnabling(
    VOID)
{
    BOOL fRet = (BOOL)NtUserCallNoParam(SFI_UPDATEPERUSERIMMENABLING);

    if (fRet) {
        if (IS_IME_ENABLED()) {
            /*
             * hen ImmEnable flag is update and it gets enabled during
             * the last logon, we need to load Imm32.dll.
             */
            HMODULE hModule = GetModuleHandleW(L"imm32.dll");
            if (hModule == NULL) {
                LoadLibraryW(L"imm32.dll");
            }
        }
    }
}
#endif


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, UpdatePerUserSystemParameters, HANDLE, hToken, DWORD, dwFlags)
BOOL UpdatePerUserSystemParameters(
    HANDLE  hToken,
    DWORD    dwFlags)
{
    TAGMSGF0(DBGTAG_KBD, "entering");
    BEGINCALL()
        if ((dwFlags & UPUSP_USERLOGGEDON) || (dwFlags & (UPUSP_POLICYCHANGE | UPUSP_REMOTESETTINGS)) == 0) {
            /*
             * This is the first logon, need to initialize
             * the input locale.
             */
            LANGID langidKbd;
            WCHAR wszKLName[KL_NAMELENGTH];
            UINT uKlFlags = KLF_ACTIVATE | KLF_RESET;

#ifdef IMM_PER_LOGON
            /*
             * Update the per user portion of the system metrics.
             * Continues even if this update fails.
             */
            UpdatePerUserImmEnabling();
#endif

            /*
             * Initialize IME hotkeys before loading keyboard
             * layouts.
             */
            CliImmInitializeHotKeys(ISHK_INITIALIZE, NULL);

            /*
             * Try to get the remote input locale first.
             */
            if (!GetRemoteKeyboardLayout(wszKLName, &langidKbd)) {
                /*
                 * If this is not a remote connection,
                 * let's handle the input locale substition.
                 */
                uKlFlags |= KLF_SUBSTITUTE_OK;
                langidKbd = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
                /*
                 * Get the active keyboard layout from the registry.
                 */
                GetActiveKeyboardName(wszKLName);
            }

            LoadKeyboardLayoutWorker(NULL, wszKLName, langidKbd, uKlFlags, TRUE);

            /*
             * Now load the remaining preload keyboard layouts.
             */
            LoadPreloadKeyboardLayouts();
        }

        /*
         * Only if not just a policy change.
         */
        if (dwFlags != UPUSP_POLICYCHANGE) {
            /*
             * FLush any MUI cach to be able to load strings latter for the new UIlangID.
             */
            LdrFlushAlternateResourceModules();
        }

        retval = (DWORD)NtUserUpdatePerUserSystemParameters(hToken, dwFlags);

        /*
         * Cause the wallpaper to be changed.
         */
        SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, 0, 0);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

DWORD Event(
    PEVENT_PACKET pep)
{
    BEGINCALL()

        CheckDDECritOut;

        retval = (DWORD)NtUserEvent(
                pep);

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

LONG GetClassWOWWords(
    HINSTANCE hInstance,
    LPCTSTR pString)
{
    IN_STRING strClassName;
    PCLS pcls;

    /*
     * Make sure cleanup will work successfully
     */
    strClassName.fAllocated = FALSE;

    BEGINCALL()

        FIRSTCOPYLPSTRW(&strClassName, pString);

        pcls = NtUserGetWOWClass(hInstance, strClassName.pstr);

        if (pcls == NULL) {
            MSGERRORCODE(ERROR_CLASS_DOES_NOT_EXIST);
        }

        pcls = (PCLS)((KPBYTE)pcls - GetClientInfo()->ulClientDelta);
        retval = _GetClassData(pcls, NULL, GCLP_WOWWORDS, TRUE);

    ERRORTRAP(0);
    CLEANUPLPSTRW(strClassName);
    ENDCALL(LONG);
}

/***************************************************************************\
* InitTask
*
* Initialize a WOW task.  This is the first call a WOW thread makes to user.
* NtUserInitTask returns NTSTATUS because if the thread fails to convert
* to a GUI thread, STATUS_INVALID_SYSTEM_SERVICE is returned.
*
* 11-03-95 JimA         Modified to use NTSTATUS.
\***************************************************************************/

BOOL InitTask(
    UINT wVersion,
    DWORD dwAppCompatFlags,
    DWORD dwUserWOWCompatFlags,
    LPCSTR pszModName,
    LPCSTR pszBaseFileName,
    DWORD hTaskWow,
    DWORD dwHotkey,
    DWORD idTask,
    DWORD dwX,
    DWORD dwY,
    DWORD dwXSize,
    DWORD dwYSize)
{
    IN_STRING strModName;
    IN_STRING strBaseFileName;
    NTSTATUS Status;

    /*
     * Make sure cleanup will work successfully
     */
    strModName.fAllocated = FALSE;
    strBaseFileName.fAllocated = FALSE;

    BEGINCALL()

        FIRSTCOPYLPSTRW(&strModName, pszModName);
        COPYLPSTRW(&strBaseFileName, pszBaseFileName);

        Status = NtUserInitTask(
                wVersion,
                dwAppCompatFlags,
                dwUserWOWCompatFlags,
                strModName.pstr,
                strBaseFileName.pstr,
                hTaskWow,
                dwHotkey,
                idTask,
                dwX,
                dwY,
                dwXSize,
                dwYSize);
        retval = (Status == STATUS_SUCCESS);

        CLEANUPLPSTRW(strModName);
        CLEANUPLPSTRW(strBaseFileName);

    ERRORTRAP(FALSE);
    ENDCALL(BOOL);
}

HANDLE ConvertMemHandle(
    HANDLE hData,
    UINT cbNULL)
{
    UINT cbData;
    LPBYTE lpData;

    BEGINCALL()

        if (GlobalFlags(hData) == GMEM_INVALID_HANDLE) {
            RIPMSG0(RIP_WARNING, "ConvertMemHandle hMem is not valid");
            MSGERROR();
        }

        if (!(cbData = (UINT)GlobalSize(hData))) {
            MSGERROR();
        }

        USERGLOBALLOCK(hData, lpData);
        if (lpData == NULL) {
            MSGERROR();
        }

        /*
         * Make sure text formats are NULL terminated.
         */
        switch (cbNULL) {
        case 2:
            lpData[cbData - 2] = 0;
            // FALL THROUGH
        case 1:
            lpData[cbData - 1] = 0;
        }

        retval = (ULONG_PTR)NtUserConvertMemHandle(lpData, cbData);

        USERGLOBALUNLOCK(hData);

    ERRORTRAP(NULL);
    ENDCALL(HANDLE);
}

HANDLE CreateLocalMemHandle(
    HANDLE hMem)
{
    UINT cbData;
    NTSTATUS Status;

    BEGINCALL()

        Status = NtUserCreateLocalMemHandle(hMem, NULL, 0, &cbData);
        if (Status != STATUS_BUFFER_TOO_SMALL) {
            RIPMSG0(RIP_WARNING, "__CreateLocalMemHandle server returned failure");
            MSGERROR();
        }

        if (!(retval = (ULONG_PTR)GlobalAlloc(GMEM_FIXED, cbData))) {
            MSGERROR();
        }

        Status = NtUserCreateLocalMemHandle(hMem, (LPBYTE)retval, cbData, NULL);
        if (!NT_SUCCESS(Status)) {
            RIPMSG0(RIP_WARNING, "__CreateLocalMemHandle server returned failure");
            UserGlobalFree((HANDLE)retval);
            MSGERROR();
        }

    ERRORTRAP(0);
    ENDCALL(HANDLE);
}

HHOOK _SetWindowsHookEx(
    HANDLE hmod,
    LPTSTR pszLib,
    DWORD idThread,
    int nFilterType,
    PROC pfnFilterProc,
    DWORD dwFlags)
{
    IN_STRING strLib;

    /*
     * Make sure cleanup will work successfully
     */
    strLib.fAllocated = FALSE;

    BEGINCALL()

        FIRSTCOPYLPWSTROPT(&strLib, pszLib);

        retval = (ULONG_PTR)NtUserSetWindowsHookEx(
                hmod,
                strLib.pstr,
                idThread,
                nFilterType,
                pfnFilterProc,
                dwFlags);

    ERRORTRAP(0);
    CLEANUPLPWSTR(strLib);
    ENDCALL(HHOOK);
}

/***************************************************************************\
* SetWinEventHook
*
* History:
* 1996-09-23 IanJa Created
\***************************************************************************/
WINUSERAPI
HWINEVENTHOOK
WINAPI
SetWinEventHook(
    DWORD        eventMin,
    DWORD        eventMax,
    HMODULE      hmodWinEventProc,   // Must pass this if global!
    WINEVENTPROC lpfnWinEventProc,
    DWORD        idProcess,          // Can be zero; all processes
    DWORD        idThread,           // Can be zero; all threads
    DWORD        dwFlags)
{
    UNICODE_STRING str;
    PUNICODE_STRING pstr;
    WCHAR awchLib[MAX_PATH];

    BEGINCALL()

        if ((dwFlags & WINEVENT_INCONTEXT) && (hmodWinEventProc != NULL)) {
            /*
             * If we're passing an hmod, we need to grab the file name of the
             * module while we're still on the client since module handles
             * are NOT global.
             */
            USHORT cb;
            cb = (USHORT)(sizeof(WCHAR) * GetModuleFileNameW(hmodWinEventProc, awchLib, sizeof(awchLib)/sizeof(WCHAR)));
            if (cb == 0) {
                /*
                 * hmod is bogus - return NULL.
                 */
                return NULL;
            }
            str.Buffer = awchLib;
            str.Length = cb - sizeof(UNICODE_NULL);
            str.MaximumLength = cb;
            pstr = &str;
        } else {
            pstr = NULL;
        }

        retval = (ULONG_PTR)NtUserSetWinEventHook(
                eventMin,
                eventMax,
                hmodWinEventProc,
                pstr,
                lpfnWinEventProc,
                idProcess,
                idThread,
                dwFlags);

    ERRORTRAP(0);
    ENDCALL(HWINEVENTHOOK);
};


FUNCLOGVOID4(LOG_GENERAL, WINAPI, NotifyWinEvent, DWORD, dwEvent, HWND, hwnd, LONG, idObject, LONG, idChild)
WINUSERAPI
VOID
WINAPI
NotifyWinEvent(
    DWORD dwEvent,
    HWND  hwnd,
    LONG  idObject,
    LONG  idChild)
{
    BEGINCALLVOID()

    if (FEVENTHOOKED(dwEvent)) {
        NtUserNotifyWinEvent(dwEvent, hwnd, idObject, idChild);
    }

    ERRORTRAPVOID();
    ENDCALLVOID();
}

/***************************************************************************\
* RegisterUserApiHook
*
* History:
* 03-Mar-2000 JerrySh   Created.
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, RegisterUserApiHook, HINSTANCE, hmod, INITUSERAPIHOOK, pfnUserApiHook)
BOOL RegisterUserApiHook(
    HINSTANCE hmod,
    INITUSERAPIHOOK pfnUserApiHook)
{
    WCHAR pwszLibFileName[MAX_PATH];
    ULONG_PTR offPfnProc;
    IN_STRING strLib;

    /*
     * If we're passing an hmod, we need to grab the file name of the
     * module while we're still on the client since module handles
     * are NOT global.
     */
    if (!GetModuleFileNameW(hmod, pwszLibFileName, ARRAY_SIZE(pwszLibFileName))) {
        return FALSE;
    }

    /*
     * Libraries are loaded at different linear addresses in different
     * process contexts.  For this reason, we need to convert the window
     * proc address into an offset while setting the hook, and then convert
     * it back to a real per-process function pointer when calling a
     * hook.  Do this by subtracting the 'hmod' (which is a pointer to the
     * linear and contiguous .exe header) from the function index.
     */
    offPfnProc = (ULONG_PTR)pfnUserApiHook - (ULONG_PTR)hmod;

    /*
     * Make sure cleanup will work successfully
     */
    strLib.fAllocated = FALSE;

    BEGINCALL()

        COPYLPWSTR(&strLib, pwszLibFileName);

        retval = (ULONG_PTR)NtUserRegisterUserApiHook(
                strLib.pstr,
                offPfnProc);

    ERRORTRAP(0);
    CLEANUPLPWSTR(strLib);
    ENDCALL(BOOL);
}


#ifdef MESSAGE_PUMP_HOOK

/***************************************************************************\
* ResetMessagePumpHook
*
* ResetMessagePumpHook() resets the MessagePumpHook function pointers
* to the internal "real" implementations.
*
* History:
* 12-13-2000    JStall      Created
\***************************************************************************/

void ResetMessagePumpHook(MESSAGEPUMPHOOK * pwmh)
{
    pwmh->cbSize                = sizeof(MESSAGEPUMPHOOK);
    pwmh->pfnInternalGetMessage = NtUserRealInternalGetMessage;
    pwmh->pfnWaitMessageEx      = NtUserRealWaitMessageEx;
    pwmh->pfnGetQueueStatus     = RealGetQueueStatus;
    pwmh->pfnMsgWaitForMultipleObjectsEx
                                = RealMsgWaitForMultipleObjectsEx;
}


/***************************************************************************\
* RegisterMessagePumpHook
*
* RegisterMessagePumpHook() sets up MPH's on the current thread.  If this is
* the first thread to be initialized in the process, the process-wide
* initialization is also performed.  If a thread has already been
* initialized with MPH's, its "ref-count" is incremented on the existing
* MPH's.
*
* NOTE: Unlike UserApiHook's, we make a callback while holding a critical
* section.  This is because it is infinitely easier to synchronize this
* inside USER32.DLL rather than allowing re-entrancy in the DLL.  It is
* designed after DllMain(), where the loader also has a lock that is
* sychronized.
*
* NOTE: Under the current implementation of MPH's, only one set of MPH's
* per process can be installed.  Each process may have a different set of
* WMH's.
*
* History:
* 12-13-2000    JStall      Created
\***************************************************************************/

BOOL RegisterMessagePumpHook(
    INITMESSAGEPUMPHOOK pfnInitMPH)
{
    BOOL fInit = FALSE;

    BEGINCALL()
    retval = FALSE;

    RtlEnterCriticalSection(&gcsMPH);

    if (pfnInitMPH == NULL) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "Need valid pfnInitMPH");
        goto errorexit;
    }

    if (gcLoadMPH == 0) {
        MESSAGEPUMPHOOK mphTemp;

        /*
         * First time we are initializing.
         */
        UserAssertMsg0(gpfnInitMPH == NULL, "MPH callback should not already be initialized");
        gpfnInitMPH = pfnInitMPH;

        ResetMessagePumpHook(&mphTemp);
        if (!(gpfnInitMPH)(UIAH_INITIALIZE, &mphTemp) || (mphTemp.cbSize == 0)) {
            goto errorexit;
        }

        CopyMemory(&gmph, &mphTemp, mphTemp.cbSize);
        fInit = TRUE;
    } else {
        if (gpfnInitMPH == pfnInitMPH) {
            /*
             * Initializing a second time with the same callback.
             */
            fInit = TRUE;
        }
    }

    if (fInit) {
        /*
         * Initialize MPH's on this thread.
         */
        if (NtUserCallNoParam(SFI__DOINITMESSAGEPUMPHOOK)) {
            if (gcLoadMPH++ == 0) {
                InterlockedExchange(&gfMessagePumpHook, TRUE);
            }
            retval = TRUE;
        }
    }

    ERRORTRAP(0);
    RtlLeaveCriticalSection(&gcsMPH);
    ENDCALL(BOOL);
}


/***************************************************************************\
* UnregisterMessagePumpHook
*
* UnregisterMessagePumpHook() decrements the count of WMH's on the current
* thread.  When this count reaches 0, WMH's are uninstalled from the
* current thread.  When the global WMH count reaches 0, WMH's are uninstalled
* from the entire process.
*
* NOTE: See RegisterMessagePumpHook() about use of the critical section.
*
* History:
* 12-13-2000    JStall      Created
\***************************************************************************/
BOOL UnregisterMessagePumpHook(
    VOID)
{
    BEGINCALL()
    RtlEnterCriticalSection(&gcsMPH);

    if (gcLoadMPH <= 0) {
        RIPMSG0(RIP_ERROR, "UninitMessagePumpHook: Called without matching Init()");
        goto errorexit;
    }

    /*
     * Uninitialize this thread's WMH.  When the reference count reaches 0, the
     * thread will no longer be hooked.
     */
    if (!NtUserCallNoParam(SFI__DOUNINITMESSAGEPUMPHOOK)) {
        goto errorexit;
    }

    if (--gcLoadMPH == 0) {
        /*
         * Final unload: make callback and reset
         */

        InterlockedExchange(&gfMessagePumpHook, FALSE);

        (gpfnInitMPH)(UIAH_UNINITIALIZE, NULL);

        ResetMessagePumpHook(&gmph);
        gpfnInitMPH = NULL;
    }
    retval = TRUE;

    ERRORTRAP(0);
    RtlLeaveCriticalSection(&gcsMPH);
    ENDCALL(BOOL);
}

#endif // MESSAGE_PUMP_HOOK



/***************************************************************************\
* ThunkedMenuItemInfo
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
BOOL ThunkedMenuItemInfo(
    HMENU hMenu,
    UINT nPosition,
    BOOL fByPosition,
    BOOL fInsert,
    LPMENUITEMINFOW lpmii,
    BOOL fAnsi)
{
    MENUITEMINFOW mii;
    IN_STRING strItem;

    /*
     * Make sure cleanup will work successfully
     */
    strItem.fAllocated = FALSE;

    BEGINCALL()

        /*
         *  Make a local copy so we can make changes
         */
        mii = *(LPMENUITEMINFO)(lpmii);

        strItem.pstr = NULL;
        if (mii.fMask & MIIM_BITMAP) {
            if (((HBITMAP)LOWORD(HandleToUlong(mii.hbmpItem)) < HBMMENU_MAX) && IS_PTR(mii.hbmpItem)) {
                /*
                 *  Looks like the user was trying to insert one of the
                 *  HBMMENU_* bitmaps, but stuffed some data in the HIWORD.
                 *  We know the HIWORD data is invalid because the LOWORD
                  *  handle is below the GDI minimum.
                 */
                RIPMSG1(RIP_WARNING, "Invalid HIWORD data (0x%04X) for HBMMENU_* bitmap.", HIWORD(HandleToUlong(mii.hbmpItem)));
                mii.hbmpItem = (HBITMAP)LOWORD(HandleToUlong(mii.hbmpItem));
            } else if (!IS_PTR(mii.hbmpItem) && mii.hbmpItem >= HBMMENU_MAX) {
                /*
                 * The app is passing a 16-bit GDI handle. GDI handles this
                 * on the client-side, but not on the kernel side. So
                 * convert it to 32-bits. This fixes bug 201493 in
                 * Macromedia Director.
                 */
                HBITMAP hbmNew = GdiFixUpHandle(mii.hbmpItem);
                if (hbmNew) {
                    RIPMSGF2(RIP_WARNING,
                             "Fix 16-bit bitmap handle 0x%x to 0x%x",
                             mii.hbmpItem,
                             hbmNew);
                    mii.hbmpItem = hbmNew;
                }
            }
        }

        if (mii.fMask & MIIM_STRING) {
            if (fAnsi) {
                FIRSTCOPYLPSTROPTW(&strItem, mii.dwTypeData);
            } else {
                FIRSTCOPYLPWSTROPT(&strItem, mii.dwTypeData);
            }
        }

        retval = (DWORD)NtUserThunkedMenuItemInfo(hMenu,
                                                  nPosition,
                                                  fByPosition,
                                                  fInsert,
                                                  &mii,
                                                  strItem.pstr);

    ERRORTRAP(FALSE);
    CLEANUPLPSTRW(strItem);
    ENDCALL(BOOL);
}

/***************************************************************************\
* DrawCaption
*
* History:
*   16-April-2001  Mohamed  Hooked API and created this wrapper.
\***************************************************************************/
FUNCLOG4(
    LOG_GENERAL,
    BOOL,
    DUMMYCALLINGTYPE,
    DrawCaption,
    HWND,
    hwnd,
    HDC,
    hdc,
    CONST RECT*,
    lprc,
    UINT,
    flags)
BOOL DrawCaption(
    HWND        hwnd,
    HDC         hdc,
    CONST RECT *lprc,
    UINT        flags)
{
    BOOL bRet;

    BEGIN_USERAPIHOOK()
        bRet = guah.pfnDrawCaption(hwnd, hdc, lprc, flags);
    END_USERAPIHOOK()

    return bRet;
}

BOOL RealDrawCaption(
    HWND        hwnd,
    HDC         hdc,
    CONST RECT *lprc,
    UINT        flags)
{
    HDC hdcr;
    BEGINCALL()

        if (IsMetaFile(hdc)) {
            return FALSE;
        }

        hdcr = GdiConvertAndCheckDC(hdc);
        if (hdcr == (HDC)0) {
            return FALSE;
        }

        retval = (DWORD)NtUserDrawCaption(hwnd, hdcr, lprc, flags);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}


FUNCLOG1(LOG_GENERAL, SHORT, DUMMYCALLINGTYPE, GetAsyncKeyState, int, vKey)
SHORT GetAsyncKeyState(
    int vKey)
{
    BEGINCALLCONNECT()

        /*
         * Asynchronous key state reports the PHYSICAL mouse button,
         * regardless of whether the buttons have been swapped or not.
         */
        if ((vKey == VK_RBUTTON || vKey == VK_LBUTTON) && SYSMET(SWAPBUTTON)) {
            vKey ^= (VK_RBUTTON ^ VK_LBUTTON);
        }

        /*
         * If this is one of the common keys, see if we can pull it out
         * of the cache.
         */
        if ((UINT)vKey < CVKASYNCKEYCACHE) {
            PCLIENTINFO pci = GetClientInfo();
            if ((pci->dwAsyncKeyCache == gpsi->dwAsyncKeyCache) &&
                !TestKeyRecentDownBit(pci->afAsyncKeyStateRecentDown, vKey)) {

                if (TestKeyDownBit(pci->afAsyncKeyState, vKey)) {
                    retval = 0x8000;
                } else {
                    retval = 0;
                }

                return (SHORT)retval;
            }
        }

        retval = (DWORD)NtUserGetAsyncKeyState(vKey);

    ERRORTRAP(0);
    ENDCALL(SHORT);
}


FUNCLOG1(LOG_GENERAL, SHORT, DUMMYCALLINGTYPE, GetKeyState, int, vKey)
SHORT GetKeyState(
    int vKey)
{
    BEGINCALLCONNECT()

        /*
         * If this is one of the common keys, see if we can pull it out
         * of the cache.
         */
        if ((UINT)vKey < CVKKEYCACHE) {
            PCLIENTINFO pci = GetClientInfo();
            if (pci->dwKeyCache == gpsi->dwKeyCache) {
                retval = 0;
                if (TestKeyToggleBit(pci->afKeyState, vKey))
                    retval |= 0x0001;
                if (TestKeyDownBit(pci->afKeyState, vKey)) {
                  /*
                   * Used to be retval |= 0x8000.Fix for bug 28820; Ctrl-Enter
                   * accelerator doesn't work on Nestscape Navigator Mail 2.0
                   */
                    retval |= 0xff80;  // This is what 3.1 returned!!!!
                }

                return (SHORT)retval;
            }
        }

        retval = (DWORD)NtUserGetKeyState(
                vKey);

    ERRORTRAP(0);
    ENDCALL(SHORT);
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, OpenClipboard, HWND, hwnd)
BOOL OpenClipboard(
    HWND hwnd)
{
    BOOL fEmptyClient;

    BEGINCALL()

        retval = (DWORD)NtUserOpenClipboard(hwnd, &fEmptyClient);

        if (fEmptyClient)
            ClientEmptyClipboard();

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

BOOL _PeekMessage(
    LPMSG pmsg,
    HWND hwnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg,
    BOOL bAnsi)
{
    BEGINCALL()

        if (bAnsi) {
            //
            // If we have pushed message for DBCS messaging, we should pass this one
            // to Apps at first...
            //
            GET_DBCS_MESSAGE_IF_EXIST(
                PeekMessage,pmsg,wMsgFilterMin,wMsgFilterMax,((wRemoveMsg & PM_REMOVE) ? TRUE:FALSE));
        }

        retval = (DWORD)NtUserPeekMessage(
                pmsg,
                hwnd,
                wMsgFilterMin,
                wMsgFilterMax,
                wRemoveMsg);

        if (retval) {
            // May have a bit more work to do if this MSG is for an ANSI app

            if (bAnsi) {
                if (RtlWCSMessageWParamCharToMB(pmsg->message, &(pmsg->wParam))) {
                    WPARAM dwAnsi = pmsg->wParam;
                    //
                    // Build DBCS-ware wParam. (for EM_SETPASSWORDCHAR...)
                    //
                    BUILD_DBCS_MESSAGE_TO_CLIENTA_FROM_SERVER(
                        pmsg,dwAnsi,TRUE,((wRemoveMsg & PM_REMOVE) ? TRUE:FALSE));
                } else {
                    retval = 0;
                }
            } else {
               //
               // Only LOWORD of WPARAM is valid for WM_CHAR....
               // (Mask off DBCS messaging information.)
               //
               BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_SERVER(pmsg->message,pmsg->wParam);
            }
        }

ExitPeekMessage:

    ERRORTRAP(0);
    ENDCALL(BOOL);
}


LONG_PTR _SetWindowLongPtr(
    HWND hwnd,
    int nIndex,
    LONG_PTR dwNewLong,
    BOOL bAnsi)
{
    PWND pwnd;
    LONG_PTR dwOldLong;
    DWORD dwCPDType = 0;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    if (TestWF(pwnd, WFDIALOGWINDOW)) {
        switch (nIndex) {
        case DWLP_DLGPROC:    // See similar case GWL_WNDPROC

            /*
             * Hide the window proc from other processes
             */
            if (!TestWindowProcess(pwnd)) {
                RIPERR1(ERROR_ACCESS_DENIED,
                        RIP_WARNING,
                        "Access denied to hwnd (%#lx) in _SetWindowLong",
                        hwnd);

                return 0;
            }

            /*
             * Get the old window proc address
             */
            dwOldLong = (LONG_PTR)PDLG(pwnd)->lpfnDlg;

            /*
             * We always store the actual address in the wndproc; We only
             * give the CallProc handles to the application
             */
            UserAssert(!ISCPDTAG(dwOldLong));

            /*
             * May need to return a CallProc handle if there is an
             * Ansi/Unicode tranistion
             */

            if (bAnsi != ((PDLG(pwnd)->flags & DLGF_ANSI) ? TRUE : FALSE)) {
                dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
            }

            /*
             * If we detected a transition create a CallProc handle for
             * this type of transition and this wndproc (dwOldLong)
             */
            if (dwCPDType) {
                ULONG_PTR cpd;

                cpd = GetCPD(pwnd, dwCPDType | CPD_DIALOG, dwOldLong);

                if (cpd) {
                    dwOldLong = cpd;
                } else {
                    RIPMSGF0(RIP_WARNING,
                             "[DWL_DLGPROC]: Unable to alloc CPD handle");
                }
            }

            /*
             * Convert a possible CallProc Handle into a real address.
             * The app may have kept the CallProc Handle from some
             * previous mixed GetClassinfo or SetWindowLong.
             *
             * WARNING bAnsi is modified here to represent real type of
             * proc rather than if SetWindowLongA or W was called
             */
            if (ISCPDTAG(dwNewLong)) {
                PCALLPROCDATA pCPD;
                if (pCPD = HMValidateHandleNoRip((HANDLE)dwNewLong, TYPE_CALLPROC)) {
                    dwNewLong = KERNEL_ULONG_PTR_TO_ULONG_PTR(pCPD->pfnClientPrevious);
                    bAnsi = pCPD->wType & CPD_UNICODE_TO_ANSI;
                }
            }

            /*
             * If an app 'unsubclasses' a server-side window proc we need to
             * restore everything so SendMessage and friends know that it's
             * a server-side proc again.  Need to check against client side
             * stub addresses.
             */
            PDLG(pwnd)->lpfnDlg = (DLGPROC)dwNewLong;
            if (bAnsi) {
                PDLG(pwnd)->flags |= DLGF_ANSI;
            } else {
                PDLG(pwnd)->flags &= ~DLGF_ANSI;
            }

            return dwOldLong;

        case DWLP_USER:
#ifdef BUILD_WOW6432
            // kernel has special handling of DWLP_USER
            nIndex = sizeof(KERNEL_LRESULT) + sizeof(KERNEL_PVOID);
#endif
        case DWLP_MSGRESULT:
            break;

        default:
            if (nIndex >= 0 && nIndex < DLGWINDOWEXTRA) {
                RIPERR0(ERROR_PRIVATE_DIALOG_INDEX, RIP_VERBOSE, "");
                return 0;
            }
        }
    }

    BEGINCALL()

    /*
     * If this is a listbox window and the listbox structure has
     * already been initialized, don't allow the app to override the
     * owner draw styles. We need to do this since Windows only
     * used the styles in creating the structure, but we also use
     * them to determine if strings need to be thunked.
     *
     */

    if (nIndex == GWL_STYLE &&
        GETFNID(pwnd) == FNID_LISTBOX &&
        ((PLBWND)pwnd)->pLBIV != NULL &&
        (!TestWindowProcess(pwnd) || ((PLBWND)pwnd)->pLBIV->fInitialized)) {

#if DBG
        LONG_PTR dwDebugLong = dwNewLong;
#endif

        dwNewLong &= ~(LBS_OWNERDRAWFIXED |
                       LBS_OWNERDRAWVARIABLE |
                       LBS_HASSTRINGS);

        dwNewLong |= pwnd->style & (LBS_OWNERDRAWFIXED |
                                    LBS_OWNERDRAWVARIABLE |
                                    LBS_HASSTRINGS);

#if DBG
        if (dwDebugLong != dwNewLong) {
           RIPMSG0(RIP_WARNING, "SetWindowLong can't change LBS_OWNERDRAW* or LBS_HASSTRINGS.");
        }
#endif
    }


        retval = (ULONG_PTR)NtUserSetWindowLongPtr(
                hwnd,
                nIndex,
                dwNewLong,
                bAnsi);

    ERRORTRAP(0);
    ENDCALL(LONG_PTR);
}

#ifdef _WIN64
LONG _SetWindowLong(
    HWND hwnd,
    int nIndex,
    LONG dwNewLong,
    BOOL bAnsi)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    if (TestWF(pwnd, WFDIALOGWINDOW)) {
        switch (nIndex) {
        case DWLP_DLGPROC:    // See similar case GWLP_WNDPROC
            RIPERR1(ERROR_INVALID_INDEX, RIP_WARNING, "SetWindowLong: invalid index %d", nIndex);
            return 0;

        case DWLP_MSGRESULT:
        case DWLP_USER:
            break;

        default:
            if (nIndex >= 0 && nIndex < DLGWINDOWEXTRA) {
                RIPERR0(ERROR_PRIVATE_DIALOG_INDEX, RIP_VERBOSE, "");
                return 0;
            }
        }
    }

    BEGINCALL()

    /*
     * If this is a listbox window and the listbox structure has
     * already been initialized, don't allow the app to override the
     * owner draw styles. We need to do this since Windows only
     * used the styles in creating the structure, but we also use
     * them to determine if strings need to be thunked.
     *
     */

    if (nIndex == GWL_STYLE &&
        GETFNID(pwnd) == FNID_LISTBOX &&
        ((PLBWND)pwnd)->pLBIV != NULL &&
        (!TestWindowProcess(pwnd) || ((PLBWND)pwnd)->pLBIV->fInitialized)) {

#if DBG
        LONG dwDebugLong = dwNewLong;
#endif

        dwNewLong &= ~(LBS_OWNERDRAWFIXED |
                       LBS_OWNERDRAWVARIABLE |
                       LBS_HASSTRINGS);

        dwNewLong |= pwnd->style & (LBS_OWNERDRAWFIXED |
                                    LBS_OWNERDRAWVARIABLE |
                                    LBS_HASSTRINGS);

#if DBG
        if (dwDebugLong != dwNewLong) {
           RIPMSG0(RIP_WARNING, "SetWindowLong can't change LBS_OWNERDRAW* or LBS_HASSTRINGS.");
        }
#endif
    }


        retval = (DWORD)NtUserSetWindowLong(
                hwnd,
                nIndex,
                dwNewLong,
                bAnsi);

    ERRORTRAP(0);
    ENDCALL(LONG);
}
#endif

BOOL TranslateMessageEx(
    CONST MSG *pmsg,
    UINT flags)
{
    BEGINCALL()

        /*
         * Don't bother going over to the kernel if this isn't
         * key message.
         */
        switch (pmsg->message) {
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_SYSKEYDOWN:
        case WM_SYSKEYUP:
            break;
        default:
            if (pmsg->message & RESERVED_MSG_BITS) {
                RIPERR1(ERROR_INVALID_PARAMETER,
                        RIP_WARNING,
                        "Invalid parameter \"pmsg->message\" (%ld) to TranslateMessageEx",
                        pmsg->message);
            }
            MSGERROR();
        }

        retval = (DWORD)NtUserTranslateMessage(
                pmsg,
                flags);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

BOOL TranslateMessage(
    CONST MSG *pmsg)
{
    //
    // IME special key handling
    //
    if (LOWORD(pmsg->wParam) == VK_PROCESSKEY) {
        BOOL fResult;

        //
        // This vkey should be processed by IME.
        //
        fResult = fpImmTranslateMessage(pmsg->hwnd,
                                        pmsg->message,
                                        pmsg->wParam,
                                        pmsg->lParam);
        if (fResult) {
            return fResult;
        }
    }

    return TranslateMessageEx(pmsg, 0);
}


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetWindowRgn, HWND, hwnd, HRGN, hrgn, BOOL, bRedraw)
BOOL SetWindowRgn(
    HWND hwnd,
    HRGN hrgn,
    BOOL bRedraw)
{
    BOOL ret;

    BEGIN_USERAPIHOOK()
        ret = guah.pfnSetWindowRgn(hwnd, hrgn, bRedraw);
    END_USERAPIHOOK()

    return ret;
}


BOOL RealSetWindowRgn(
    HWND hwnd,
    HRGN hrgn,
    BOOL bRedraw)
{
    BEGINCALL()

        retval = (DWORD)NtUserSetWindowRgn(
                hwnd,
                hrgn,
                bRedraw);

        if (retval) {
            DeleteObject(hrgn);
        }

    ERRORTRAP(0);
    ENDCALL(BOOL);
}


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, InternalGetWindowText, HWND, hwnd, LPWSTR, pString, int, cchMaxCount)
BOOL InternalGetWindowText(
    HWND hwnd,
    LPWSTR pString,
    int cchMaxCount)
{
    BEGINCALL()

        retval = (DWORD)NtUserInternalGetWindowText(
                hwnd,
                pString,
                cchMaxCount);

        if (!retval) {
            *pString = (WCHAR)0;
        }

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

int ToUnicode(
    UINT wVirtKey,
    UINT wScanCode,
    CONST BYTE *pKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags)
{
    BEGINCALL()

        retval = (DWORD)NtUserToUnicodeEx(
                wVirtKey,
                wScanCode,
                pKeyState,
                pwszBuff,
                cchBuff,
                wFlags,
                (HKL)NULL);

        if (!retval) {
            *pwszBuff = L'\0';
        }

    ERRORTRAP(0);
    ENDCALL(int);
}

int ToUnicodeEx(
    UINT wVirtKey,
    UINT wScanCode,
    CONST BYTE *pKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags,
    HKL hkl)
{
    BEGINCALL()

    retval = (DWORD)NtUserToUnicodeEx(
            wVirtKey,
            wScanCode,
            pKeyState,
            pwszBuff,
            cchBuff,
            wFlags,
            hkl);

    if (!retval) {
        *pwszBuff = L'\0';
    }

    ERRORTRAP(0);
    ENDCALL(int);
}

#if DBG

FUNCLOGVOID2(LOG_GENERAL, DUMMYCALLINGTYPE, DbgWin32HeapFail, DWORD, dwFlags, BOOL, bFail)
VOID DbgWin32HeapFail(
    DWORD dwFlags,
    BOOL  bFail)
{
    if ((dwFlags | WHF_VALID) != WHF_VALID) {
        RIPMSG1(RIP_WARNING, "Invalid flags for DbgWin32HeapFail %x", dwFlags);
        return;
    }

    if (dwFlags & WHF_CSRSS) {
        // Tell csr about it
        CsrWin32HeapFail(dwFlags, bFail);
    }

    NtUserDbgWin32HeapFail(dwFlags, bFail);
}


FUNCLOG3(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, DbgWin32HeapStat, PDBGHEAPSTAT, phs, DWORD, dwLen, DWORD, dwFlags)
DWORD DbgWin32HeapStat(
    PDBGHEAPSTAT    phs,
    DWORD   dwLen,
    DWORD   dwFlags)
{
    if ((dwFlags | WHF_VALID) != WHF_VALID) {
        RIPMSG1(RIP_WARNING, "Invalid flags for DbgWin32HeapFail %x", dwFlags);
        return 0;
    }

    if (dwFlags & WHF_CSRSS) {
        return CsrWin32HeapStat(phs, dwLen);
    } else if (dwFlags & WHF_DESKTOP) {
        return NtUserDbgWin32HeapStat(phs, dwLen);
    }
    return 0;
}

#endif // DBG


FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetWindowStationUser, HWINSTA, hwinsta, PLUID, pluidUser, PSID, psidUser, DWORD, cbsidUser)
BOOL SetWindowStationUser(
    HWINSTA hwinsta,
    PLUID   pluidUser,
    PSID    psidUser,
    DWORD   cbsidUser)
{
    LUID luidNone = { 0, 0 };


    BEGINCALL()

        retval = (DWORD)NtUserSetWindowStationUser(hwinsta,
                                                   pluidUser,
                                                   psidUser,
                                                   cbsidUser);

        /*
         * Load global atoms if the logon succeeded
         */
        if (retval) {

            if (!RtlEqualLuid(pluidUser,&luidNone)) {
                /*
                 * Reset console and load Nls data.
                 */
                Logon(TRUE);
            } else {
                /*
                 * Flush NLS cache.
                 */
                Logon(FALSE);
            }

            retval = TRUE;
        }
    ERRORTRAP(0);
    ENDCALL(BOOL);
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetSystemCursor, HCURSOR, hcur, DWORD, id)
BOOL SetSystemCursor(
    HCURSOR hcur,
    DWORD   id)
{
    BEGINCALL()

        if (hcur == NULL) {
            hcur = (HANDLE)LoadIcoCur(NULL,
                                      MAKEINTRESOURCE(id),
                                      RT_CURSOR,
                                      0,
                                      0,
                                      LR_DEFAULTSIZE);

            if (hcur == NULL)
                MSGERROR();
        }

        retval = (DWORD)NtUserSetSystemCursor(hcur, id);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

HCURSOR FindExistingCursorIcon(
    LPWSTR      pszModName,
    LPCWSTR     pszResName,
    PCURSORFIND pcfSearch)
{
    IN_STRING strModName;
    IN_STRING strResName;

    /*
     * Make sure cleanup will work successfully
     */
    strModName.fAllocated = FALSE;
    strResName.fAllocated = FALSE;

    BEGINCALL()

        if (pszModName == NULL)
            pszModName = szUSER32;

        COPYLPWSTR(&strModName, pszModName);
        COPYLPWSTRID(&strResName, pszResName);

        retval = (ULONG_PTR)NtUserFindExistingCursorIcon(strModName.pstr,
                                                     strResName.pstr,
                                                     pcfSearch);

    ERRORTRAP(0);

    CLEANUPLPWSTR(strModName);
    CLEANUPLPWSTR(strResName);

    ENDCALL(HCURSOR);
}



BOOL _SetCursorIconData(
    HCURSOR     hCursor,
    PCURSORDATA pcur)
{
    IN_STRING  strModName;
    IN_STRING  strResName;

    /*
     * Make sure cleanup will work successfully
     */
    strModName.fAllocated = FALSE;
    strResName.fAllocated = FALSE;

    BEGINCALL()

        COPYLPWSTROPT(&strModName, KPWSTR_TO_PWSTR(pcur->lpModName));
        COPYLPWSTRIDOPT(&strResName, KPWSTR_TO_PWSTR(pcur->lpName));

        retval = (DWORD)NtUserSetCursorIconData(hCursor,
                                                strModName.pstr,
                                                strResName.pstr,
                                                pcur);

    ERRORTRAP(0);

    CLEANUPLPWSTR(strModName);
    CLEANUPLPWSTR(strResName);

    ENDCALL(BOOL);
}



BOOL _DefSetText(
    HWND hwnd,
    LPCWSTR lpszText,
    BOOL bAnsi)
{
    LARGE_STRING str;

    BEGINCALL()

        if (lpszText) {
            if (bAnsi) {
                RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&str,
                        (LPSTR)lpszText, (UINT)-1);
            } else {
                RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&str,
                        lpszText, (UINT)-1);
            }
        }

        retval = (DWORD)NtUserDefSetText(hwnd, lpszText ? &str : NULL);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

HWND _CreateWindowEx(
    DWORD dwExStyle,
    LPCTSTR pClassName,
    LPCTSTR pWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hwndParent,
    HMENU hmenu,
    HANDLE hModule,
    LPVOID pParam,
    DWORD dwFlags)
{
    LARGE_IN_STRING strClassName;
    LARGE_STRING strWindowName;
    PLARGE_STRING pstrClassName;
    PLARGE_STRING pstrWindowName;
    DWORD dwExpWinVerAndFlags;

    /*
     * Make sure cleanup will work successfully
     */
    strClassName.fAllocated = FALSE;

    /*
     * To be compatible with Chicago, we test the validity of
     * the ExStyle bits and fail if any invalid bits are found.
     * And for backward compatibilty with NT apps, we only fail for
     * new apps (post NT 3.1).
     */

// BOGUS

    if (dwExStyle & 0x00000800L) {
        dwExStyle |= WS_EX_TOOLWINDOW;
        dwExStyle &= 0xfffff7ffL;
    }

    dwExpWinVerAndFlags = (DWORD)(WORD)GETEXPWINVER(hModule);
    if ((dwExStyle & ~WS_EX_ALLVALID) && Is400Compat(dwExpWinVerAndFlags)) {
        RIPMSG1(RIP_WARNING, "Invalid 5.1 ExStyle 0x%x", dwExStyle);
        return NULL;
    }

    {

    BOOL fMDIchild = FALSE;
    MDICREATESTRUCT mdics;
    HMENU hSysMenu;

    BEGINCALL()

        if ((fMDIchild = (BOOL)(dwExStyle & WS_EX_MDICHILD))) {
            SHORTCREATE sc;
            PWND pwndParent;

            pwndParent = ValidateHwnd(hwndParent);
            if (pwndParent == NULL || GETFNID(pwndParent) != FNID_MDICLIENT) {
                RIPMSG0(RIP_WARNING, "Invalid parent for MDI child window");
                MSGERROR();
            }

            mdics.lParam  = (LPARAM)pParam;
            pParam = &mdics;
            mdics.x = sc.x = x;
            mdics.y = sc.y = y;
            mdics.cx = sc.cx = nWidth;
            mdics.cy = sc.cy = nHeight;
            mdics.style = sc.style = dwStyle;
            mdics.hOwner = hModule;
            mdics.szClass = pClassName;
            mdics.szTitle = pWindowName;

            if (!CreateMDIChild(&sc, &mdics, dwExpWinVerAndFlags, &hSysMenu, pwndParent))
                MSGERROR();

            x = sc.x;
            y = sc.y;
            nWidth = sc.cx;
            nHeight = sc.cy;
            dwStyle = sc.style;
            hmenu = sc.hMenu;
        }

        /*
         * Set up class and window name.  If the window name is an
         * ordinal, make it look like a string so the callback thunk
         * will be able to ensure it is in the correct format.
         */
        pstrWindowName = NULL;
        if (dwFlags & CW_FLAGS_ANSI) {
            dwExStyle = dwExStyle | WS_EX_ANSICREATOR;

            if (IS_PTR(pClassName)) {
                RtlCaptureLargeAnsiString(&strClassName,
                        (PCHAR)pClassName, TRUE);
                pstrClassName = (PLARGE_STRING)strClassName.pstr;
            } else {
                pstrClassName = (PLARGE_STRING)pClassName;
            }

            if (pWindowName != NULL) {
                if (*(PBYTE)pWindowName == 0xff) {
                    strWindowName.bAnsi = TRUE;
                    strWindowName.Buffer = (PVOID)pWindowName;
                    strWindowName.Length = 3;
                    strWindowName.MaximumLength = 3;
                } else {
                    RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&strWindowName,
                                           (LPSTR)pWindowName,
                                           (UINT)-1);
                }

                pstrWindowName = &strWindowName;
            }
        } else {
            if (IS_PTR(pClassName)) {
                RtlInitLargeUnicodeString(
                        (PLARGE_UNICODE_STRING)&strClassName.strCapture,
                        pClassName, (UINT)-1);
                pstrClassName = (PLARGE_STRING)&strClassName.strCapture;
            } else {
                pstrClassName = (PLARGE_STRING)pClassName;
            }

            if (pWindowName != NULL) {
                if (pWindowName != NULL &&
                     *(PWORD)pWindowName == 0xffff) {
                    strWindowName.bAnsi = FALSE;
                    strWindowName.Buffer = (PVOID)pWindowName;
                    strWindowName.Length = 4;
                    strWindowName.MaximumLength = 4;
                } else {
                    RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&strWindowName,
                            pWindowName, (UINT)-1);
                }

                pstrWindowName = &strWindowName;
            }
        }

        dwExpWinVerAndFlags |= (dwFlags & (CW_FLAGS_DIFFHMOD | CW_FLAGS_VERSIONCLASS));

        retval = (ULONG_PTR)VerNtUserCreateWindowEx(
                dwExStyle,
                pstrClassName,
                pstrWindowName,
                dwStyle,
                x,
                y,
                nWidth,
                nHeight,
                hwndParent,
                hmenu,
                hModule,
                pParam,
                dwExpWinVerAndFlags);

    // If this is an MDI child, we need to do some more to complete the
    // process of creating an MDI child.
    if (retval && fMDIchild) {
        MDICompleteChildCreation((HWND)retval, hSysMenu, ((dwStyle & WS_VISIBLE) != 0L), (BOOL)((dwStyle & WS_DISABLED)!= 0L));
    }


    ERRORTRAP(0);
    CLEANUPLPSTRW(strClassName);
    ENDCALL(HWND);
    }

}

HKL _LoadKeyboardLayoutEx(
    HANDLE hFile,
    UINT offTable,
    PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    HKL hkl,
    LPCTSTR pwszKL,
    UINT KbdInputLocale,
    UINT Flags)
{
    IN_STRING strKL;

    /*
     * Make sure cleanup will work successfully
     */
    strKL.fAllocated = FALSE;

    BEGINCALL()

        FIRSTCOPYLPWSTR(&strKL, pwszKL);

        retval = (ULONG_PTR)NtUserLoadKeyboardLayoutEx(
                hFile,
                offTable,
                pKbdTableMulti,
                hkl,
                strKL.pstr,
                KbdInputLocale,
                Flags);

    ERRORTRAP(0);
    CLEANUPLPWSTR(strKL);
    ENDCALL(HKL);
}


FUNCLOGVOID5(LOG_GENERAL, DUMMYCALLINGTYPE, mouse_event, DWORD, dwFlags, DWORD, dx, DWORD, dy, DWORD, dwData, ULONG_PTR, dwExtraInfo)
VOID mouse_event(
    DWORD dwFlags,
    DWORD dx,
    DWORD dy,
    DWORD dwData,
    ULONG_PTR dwExtraInfo)
{
    INPUT ms;

    BEGINCALLVOID()

        ms.type           = INPUT_MOUSE;
        ms.mi.dwFlags     = dwFlags;
        ms.mi.dx          = dx;
        ms.mi.dy          = dy;
        ms.mi.mouseData   = dwData;
        ms.mi.time        = 0;
        ms.mi.dwExtraInfo = dwExtraInfo;

        NtUserSendInput(1, &ms, sizeof(INPUT));

    ENDCALLVOID()
}


FUNCLOGVOID4(LOG_GENERAL, DUMMYCALLINGTYPE, keybd_event, BYTE, bVk, BYTE, bScan, DWORD, dwFlags, ULONG_PTR, dwExtraInfo)
VOID keybd_event(
    BYTE  bVk,
    BYTE  bScan,
    DWORD dwFlags,
    ULONG_PTR dwExtraInfo)
{
    INPUT kbd;

    BEGINCALLVOID()

        kbd.type           = INPUT_KEYBOARD;
        kbd.ki.dwFlags     = dwFlags;
        kbd.ki.wVk         = bVk;
        kbd.ki.wScan       = bScan;
        kbd.ki.time        = 0;
        kbd.ki.dwExtraInfo = dwExtraInfo;

        NtUserSendInput(1, &kbd, sizeof(INPUT));

    ENDCALLVOID()
}

/*
 * Message thunks
 */
MESSAGECALL(fnINWPARAMDBCSCHAR)
{
    BEGINCALL()

        /*
         * The server always expects the characters to be unicode so
         * if this was generated from an ANSI routine convert it to Unicode
         */
        if (bAnsi) {

            /*
             * Setup for DBCS Messaging..
             */
            BUILD_DBCS_MESSAGE_TO_SERVER_FROM_CLIENTA(msg,wParam,TRUE);

            /*
             * Convert DBCS/SBCS to Unicode...
             */
            RtlMBMessageWParamCharToWCS(msg, &wParam);
        }

        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

MESSAGECALL(fnCOPYGLOBALDATA)
{
    PBYTE pData;
    BEGINCALL()

        if (wParam == 0) {
            MSGERROR();
        }

        USERGLOBALLOCK((HGLOBAL)lParam, pData);
        if (pData == NULL) {
            MSGERROR();
        }
        retval = NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                (LPARAM)pData,
                xParam,
                xpfnProc,
                bAnsi);
        USERGLOBALUNLOCK((HGLOBAL)lParam);
        UserGlobalFree((HGLOBAL)lParam);
    ERRORTRAP(0);
    ENDCALL(ULONG_PTR);
}

MESSAGECALL(fnINPAINTCLIPBRD)
{
    LPPAINTSTRUCT lpps;

    BEGINCALL()

        USERGLOBALLOCK((HGLOBAL)lParam, lpps);
        if (lpps) {
            retval = (DWORD)NtUserMessageCall(
                    hwnd,
                    msg,
                    wParam,
                    (LPARAM)lpps,
                    xParam,
                    xpfnProc,
                    bAnsi);
            USERGLOBALUNLOCK((HGLOBAL)lParam);
        } else {
            RIPMSG1(RIP_WARNING, "MESSAGECALL(fnINPAINTCLIPBRD): USERGLOBALLOCK failed on %p!", lParam);
            MSGERROR();
        }

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

MESSAGECALL(fnINSIZECLIPBRD)
{
    LPRECT lprc;
    BEGINCALL()

        USERGLOBALLOCK((HGLOBAL)lParam, lprc);
        if (lprc) {
            retval = (DWORD)NtUserMessageCall(
                    hwnd,
                    msg,
                    wParam,
                    (LPARAM)lprc,
                    xParam,
                    xpfnProc,
                bAnsi);
            USERGLOBALUNLOCK((HGLOBAL)lParam);
        } else {
            RIPMSG1(RIP_WARNING, "MESSAGECALL(fnINSIZECLIPBRD): USERGLOBALLOCK failed on %p!", lParam);
            MSGERROR();
        }

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

MESSAGECALL(fnINDEVICECHANGE)
{
    struct _DEV_BROADCAST_HEADER *pHdr;
    PDEV_BROADCAST_PORT_W pPortW = NULL;
    PDEV_BROADCAST_PORT_A pPortA;
    PDEV_BROADCAST_DEVICEINTERFACE_W pInterfaceW = NULL;
    PDEV_BROADCAST_DEVICEINTERFACE_A pInterfaceA;
    PDEV_BROADCAST_HANDLE pHandleW = NULL;
    PDEV_BROADCAST_HANDLE pHandleA;

    LPWSTR lpStr;
    int iStr, iSize;

    BEGINCALL()

        if (!(wParam &0x8000) || !lParam || !bAnsi)
            goto shipit;

        pHdr = (struct _DEV_BROADCAST_HEADER *)lParam;
        switch (pHdr->dbcd_devicetype) {
        case DBT_DEVTYP_PORT:
            pPortA = (PDEV_BROADCAST_PORT_A)lParam;
            iStr = strlen(pPortA->dbcp_name);
            iSize = FIELD_OFFSET(DEV_BROADCAST_PORT_W, dbcp_name) + sizeof(WCHAR)*(iStr+1);
            pPortW = UserLocalAlloc(0, iSize);
            if (pPortW == NULL)
                return 0;
            RtlCopyMemory(pPortW, pPortA, sizeof(DEV_BROADCAST_PORT_A));
            lpStr = pPortW->dbcp_name;
            if (iStr) {
                MBToWCS(pPortA->dbcp_name, -1, &lpStr, iStr, FALSE);
                lpStr[iStr] = 0;
            } else {
                lpStr[0] = 0;
            }
            pPortW->dbcp_size = iSize;
            lParam = (LPARAM)pPortW;
            bAnsi = FALSE;
            break;

        case DBT_DEVTYP_DEVICEINTERFACE:
            pInterfaceA = (PDEV_BROADCAST_DEVICEINTERFACE_A)lParam;
            iStr = strlen(pInterfaceA->dbcc_name);
            iSize = FIELD_OFFSET(DEV_BROADCAST_DEVICEINTERFACE_W, dbcc_name) + sizeof(WCHAR)*(iStr+1);
            pInterfaceW = UserLocalAlloc(0, iSize);
            if (pInterfaceW == NULL)
                return 0;
            RtlCopyMemory(pInterfaceW, pInterfaceA, sizeof(DEV_BROADCAST_DEVICEINTERFACE_A));
            lpStr = pInterfaceW->dbcc_name;
            if (iStr) {
                MBToWCS(pInterfaceA->dbcc_name, -1, &lpStr, iStr, FALSE);
                lpStr[iStr] = 0;
            } else {
                lpStr[0] = 0;
            }
            pInterfaceW->dbcc_size = iSize;
            lParam = (LPARAM)pInterfaceW;
            bAnsi = FALSE;
            break;

        case DBT_DEVTYP_HANDLE:
            pHandleA = (PDEV_BROADCAST_HANDLE)lParam;
            bAnsi = FALSE;
            if ((wParam != DBT_CUSTOMEVENT) || (pHandleA->dbch_nameoffset < 0)) break;
            iStr = strlen(pHandleA->dbch_data+pHandleA->dbch_nameoffset);
        /*
         * Calculate size of new structure with UNICODE string instead of Ansi string
         */

            iSize = FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data)+ pHandleA->dbch_nameoffset + sizeof(WCHAR)*(iStr+1);
            /*
             * Just in case there were an odd number of bytes in the non-text data
             */
            if (iSize & 1) iSize++;
            pHandleW = UserLocalAlloc(0, iSize);
            if (pHandleW == NULL)
                return 0;
            RtlCopyMemory(pHandleW, pHandleA, FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data)+ pHandleA->dbch_nameoffset);

            /*
             * Make sure this is even for the UNICODE string.
             */

            if (pHandleW->dbch_nameoffset & 1) pHandleW->dbch_nameoffset++;

            lpStr = (LPWSTR)(pHandleW->dbch_data+pHandleW->dbch_nameoffset);
            if (iStr) {
                MBToWCS(pHandleA->dbch_data+pHandleA->dbch_nameoffset, -1,
                        &lpStr, iStr, FALSE);
            }
                lpStr[iStr] = 0;
            pHandleW->dbch_size = iSize;
            lParam = (LPARAM)pHandleW;

            break;
        }

shipit:
        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);

    if (pPortW) UserLocalFree(pPortW);
    if (pInterfaceW) UserLocalFree(pInterfaceW);
    if (pHandleW) UserLocalFree(pHandleW);

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

MESSAGECALL(fnIMECONTROL)
{
    PVOID pvData = NULL;
    LPARAM lData = lParam;

    BEGINCALL()

        /*
         * The server always expects the characters to be unicode so
         * if this was generated from an ANSI routine convert it to Unicode
         */
        if (bAnsi) {
            switch (wParam) {
                case IMC_GETCOMPOSITIONFONT:
                case IMC_GETSOFTKBDFONT:
                case IMC_SETCOMPOSITIONFONT:
                    pvData = UserLocalAlloc(0, sizeof(LOGFONTW));
                    if (pvData == NULL)
                        MSGERROR();

                    if (wParam == IMC_SETCOMPOSITIONFONT) {
                        // Later, we do A/W conversion based on thread hkl/CP.
                        CopyLogFontAtoW((PLOGFONTW)pvData, (PLOGFONTA)lParam);
                    }

                    lData = (LPARAM)pvData;
                    break;

                case IMC_SETSOFTKBDDATA:
                    {
                        PSOFTKBDDATA pSoftKbdData;
                        PWORD pCodeA;
                        PWSTR pCodeW;
                        CHAR  ch[3];
                        DWORD cbSize;
                        UINT  uCount, i;

                        uCount = ((PSOFTKBDDATA)lParam)->uCount;

                        cbSize = FIELD_OFFSET(SOFTKBDDATA, wCode[0])
                               + uCount * sizeof(WORD) * 256;

                        pvData = UserLocalAlloc(0, cbSize);
                        if (pvData == NULL)
                            MSGERROR();

                        pSoftKbdData = (PSOFTKBDDATA)pvData;

                        pSoftKbdData->uCount = uCount;

                        ch[2] = (CHAR)'\0';

                        pCodeA = &((PSOFTKBDDATA)lParam)->wCode[0][0];
                        pCodeW = &pSoftKbdData->wCode[0][0];

                        i = uCount * 256;

                        while (i--) {
                            if (HIBYTE(*pCodeA)) {
                                ch[0] = (CHAR)HIBYTE(*pCodeA);
                                ch[1] = (CHAR)LOBYTE(*pCodeA);
                            } else {
                                ch[0] = (CHAR)LOBYTE(*pCodeA);
                                ch[1] = (CHAR)'\0';
                            }
                            MBToWCSEx(THREAD_CODEPAGE(), (LPSTR)&ch, -1, &pCodeW, 1, FALSE);
                            pCodeA++; pCodeW++;
                        }

                        lData = (LPARAM)pvData;
                    }
                    break;

                default:
                    break;
            }
        }

        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lData,
                xParam,
                xpfnProc,
                bAnsi);

        if (bAnsi) {
            switch (wParam) {
                case IMC_GETCOMPOSITIONFONT:
                case IMC_GETSOFTKBDFONT:
                    CopyLogFontWtoA((PLOGFONTA)lParam, (PLOGFONTW)pvData);
                    break;

                default:
                    break;
            }
        }

        if (pvData != NULL)
            UserLocalFree(pvData);

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

DWORD CalcCharacterPositionAtoW(
    DWORD dwCharPosA,
    LPSTR lpszCharStr,
    DWORD dwCodePage)
{
    DWORD dwCharPosW = 0;

    while (dwCharPosA != 0) {
        if (IsDBCSLeadByteEx(dwCodePage, *lpszCharStr)) {
            if (dwCharPosA >= 2) {
                dwCharPosA -= 2;
            }
            else {
                dwCharPosA--;
            }
            lpszCharStr += 2;
        }
        else {
            dwCharPosA--;
            lpszCharStr++;
        }
        dwCharPosW++;
    }

    return dwCharPosW;
}

int UnicodeToMultiByteSize(DWORD dwCodePage, LPCWSTR pwstr)
{
    char dummy[2], *lpszDummy = dummy;
    return WCSToMBEx((WORD)dwCodePage, pwstr, 1, &lpszDummy, sizeof(WCHAR), FALSE);
}

DWORD CalcCharacterPositionWtoA(
    DWORD dwCharPosW,
    LPWSTR lpwszCharStr,
    DWORD  dwCodePage)
{
    DWORD dwCharPosA = 0;
    ULONG MultiByteSize;

    while (dwCharPosW != 0) {
        MultiByteSize = UnicodeToMultiByteSize(dwCodePage, lpwszCharStr);
        if (MultiByteSize == 2) {
            dwCharPosA += 2;
        }
        else {
            dwCharPosA++;
        }
        dwCharPosW--;
        lpwszCharStr++;
    }

    return dwCharPosA;
}

#ifdef LATER
DWORD WINAPI ImmGetReconvertTotalSize(DWORD dwSize, REQ_CALLER eCaller, BOOL bAnsiTarget)
{
    if (dwSize < sizeof(RECONVERTSTRING)) {
        return 0;
    }
    if (bAnsiTarget) {
        dwSize -= sizeof(RECONVERTSTRING);
        if (eCaller == FROM_IME) {
            dwSize /= 2;
        } else {
            dwSize *= 2;
        }
        dwSize += sizeof(RECONVERTSTRING);
    }
    return dwSize;
}


FUNCLOG4(LOG_GENERAL, DWORD, WINAPI, ImmReconversionWorker, LPRECONVERTSTRING, lpRecTo, LPRECONVERTSTRING, lpRecFrom, BOOL, bToAnsi, DWORD, dwCodePage)
DWORD WINAPI ImmReconversionWorker(
        LPRECONVERTSTRING lpRecTo,
        LPRECONVERTSTRING lpRecFrom,
        BOOL bToAnsi,
        DWORD dwCodePage)
{
    INT i;
    DWORD dwSize = 0;

    UserAssert(lpRecTo);
    UserAssert(lpRecFrom);

    if (lpRecFrom->dwVersion != 0 || lpRecTo->dwVersion != 0) {
        RIPMSG0(RIP_WARNING, "ImmReconversionWorker: dwVersion in lpRecTo or lpRecFrom is incorrect.");
        return 0;
    }
    // Note:
    // In any IME related structures, use the following principal.
    // 1) xxxStrOffset is an actual offset, i.e. byte count.
    // 2) xxxStrLen is a number of characters, i.e. TCHAR count.
    //
    // CalcCharacterPositionXtoY() takes TCHAR count so that we
    // need to adjust xxxStrOffset if it's being converted. But you
    // should be careful, because the actual position of the string
    // is always at something like (LPBYTE)lpStruc + lpStruc->dwStrOffset.
    //
    if (bToAnsi) {
        // Convert W to A
        lpRecTo->dwStrOffset = sizeof *lpRecTo;
        i = WideCharToMultiByte(dwCodePage,
                                (DWORD)0,
                                (LPWSTR)((LPSTR)lpRecFrom + lpRecFrom->dwStrOffset), // src
                                (INT)lpRecFrom->dwStrLen,
                                (LPSTR)lpRecTo + lpRecTo->dwStrOffset,  // dest
                                (INT)lpRecFrom->dwStrLen * DBCS_CHARSIZE,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpRecTo->dwCompStrOffset =
            CalcCharacterPositionWtoA(lpRecFrom->dwCompStrOffset / sizeof(WCHAR),
                                      (LPWSTR)((LPBYTE)lpRecFrom + lpRecFrom->dwStrOffset),
                                      dwCodePage)
                            * sizeof(CHAR);

        lpRecTo->dwCompStrLen =
            (CalcCharacterPositionWtoA(lpRecFrom->dwCompStrOffset / sizeof(WCHAR) +
                                      lpRecFrom->dwCompStrLen,
                                      (LPWSTR)((LPBYTE)lpRecFrom + lpRecFrom->dwStrOffset),
                                      dwCodePage)
                            * sizeof(CHAR))
            - lpRecTo->dwCompStrOffset;

        lpRecTo->dwTargetStrOffset =
            CalcCharacterPositionWtoA(lpRecFrom->dwTargetStrOffset / sizeof(WCHAR),
                                      (LPWSTR)((LPBYTE)lpRecFrom +
                                                lpRecFrom->dwStrOffset),
                                      dwCodePage)
                            * sizeof(CHAR);

        lpRecTo->dwTargetStrLen =
            (CalcCharacterPositionWtoA(lpRecFrom->dwTargetStrOffset / sizeof(WCHAR) +
                                      lpRecFrom->dwTargetStrLen,
                                      (LPWSTR)((LPBYTE)lpRecFrom + lpRecFrom->dwStrOffset),
                                       dwCodePage)
                            * sizeof(CHAR))
            - lpRecTo->dwTargetStrOffset;

        ((LPSTR)lpRecTo)[lpRecTo->dwStrOffset + i] = '\0';
        lpRecTo->dwStrLen = i * sizeof(CHAR);

        dwSize = sizeof(RECONVERTSTRING) + ((i + 1) * sizeof(CHAR));

    } else {

        // AtoW
        lpRecTo->dwStrOffset = sizeof *lpRecTo;
        i = MultiByteToWideChar(dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,  // src
                                (INT)lpRecFrom->dwStrLen,
                                (LPWSTR)((LPSTR)lpRecTo + lpRecTo->dwStrOffset), // dest
                                (INT)lpRecFrom->dwStrLen);

        lpRecTo->dwCompStrOffset =
            CalcCharacterPositionAtoW(lpRecFrom->dwCompStrOffset,
                                      (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                      dwCodePage) * sizeof(WCHAR);

        lpRecTo->dwCompStrLen =
            ((CalcCharacterPositionAtoW(lpRecFrom->dwCompStrOffset +
                                       lpRecFrom->dwCompStrLen,
                                       (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                        dwCodePage)  * sizeof(WCHAR))
            - lpRecTo->dwCompStrOffset) / sizeof(WCHAR);

        lpRecTo->dwTargetStrOffset =
            CalcCharacterPositionAtoW(lpRecFrom->dwTargetStrOffset,
                                      (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                      dwCodePage) * sizeof(WCHAR);

        lpRecTo->dwTargetStrLen =
            ((CalcCharacterPositionAtoW(lpRecFrom->dwTargetStrOffset +
                                       lpRecFrom->dwTargetStrLen,
                                       (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                       dwCodePage)  * sizeof(WCHAR))
            - lpRecTo->dwTargetStrOffset) / sizeof(WCHAR);

        lpRecTo->dwStrLen = i;  // Length is TCHAR count.
        if (lpRecTo->dwSize >= (DWORD)(lpRecTo->dwStrOffset + (i + 1)* sizeof(WCHAR))) {
            LPWSTR lpW = (LPWSTR)((LPSTR)lpRecTo + lpRecTo->dwStrOffset);
            lpW[i] = L'\0';
        }
        dwSize = sizeof(RECONVERTSTRING) + ((i + 1) * sizeof(WCHAR));
    }
    return dwSize;
}

#define GETCOMPOSITIONSTRING(hImc, index, buf, buflen) \
            (bAnsi ? fpImmGetCompositionStringA : fpImmGetCompositionStringW)((hImc), (index), (buf), (buflen))

MESSAGECALL(fnIMEREQUEST)
{
    PVOID pvData = NULL;
    LPARAM lData = lParam;

    BEGINCALL()

        if (!IS_IME_ENABLED()) {
            // If IME is not enabled, save time.
            MSGERROR();
        }

        /*
         * The server always expects the characters to be unicode so
         * if this was generated from an ANSI routine convert it to Unicode
         */
        if (wParam == IMR_QUERYCHARPOSITION) {
            //
            // Store the UNICODE character count in PrivateIMECHARPOSITION.
            //
            // No need to save the original dwCharPos, since dwCharPositionA/W are not
            // overwritten in the kernel.
            //
            if (bAnsi) {
                ((LPIMECHARPOSITION)lParam)->dwCharPos = ((LPPrivateIMECHARPOSITION)lParam)->dwCharPositionW;
            }
        }
        else if (bAnsi) {
            switch (wParam) {
            case IMR_COMPOSITIONFONT:
                pvData = UserLocalAlloc(0, sizeof(LOGFONTW));
                if (pvData == NULL)
                    MSGERROR();
                lData = (LPARAM)pvData;
                break;

            case IMR_CONFIRMRECONVERTSTRING:
            case IMR_RECONVERTSTRING:
            case IMR_DOCUMENTFEED:
                if ((LPVOID)lParam != NULL) {
                    // IME wants not only the buffer size but the real reconversion information
                    DWORD dwSize = ImmGetReconvertTotalSize(((LPRECONVERTSTRING)lParam)->dwSize, FROM_IME, FALSE);
                    LPRECONVERTSTRING lpReconv;

                    pvData = UserLocalAlloc(0, dwSize + sizeof(WCHAR));
                    if (pvData == NULL) {
                        RIPMSG0(RIP_WARNING, "fnIMEREQUEST: failed to allocate a buffer for reconversion.");
                        MSGERROR();
                    }
                    lpReconv = (LPRECONVERTSTRING)pvData;
                    // setup the information in the allocated structure
                    lpReconv->dwVersion = 0;
                    lpReconv->dwSize = dwSize;

                    //
                    // if it's confirmation message, we need to translate the contents
                    //
                    if (wParam == IMR_CONFIRMRECONVERTSTRING) {
                        ImmReconversionWorker(lpReconv, (LPRECONVERTSTRING)lParam, FALSE, CP_ACP);
                    }
                }
                break;

            default:
                break;
            }
        }

        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lData,
                xParam,
                xpfnProc,
                bAnsi);

        if (bAnsi) {
            switch (wParam) {
            case IMR_COMPOSITIONFONT:
                if (retval) {
                    CopyLogFontWtoA((PLOGFONTA)lParam, (PLOGFONTW)pvData);
                }
                break;

            case IMR_QUERYCHARPOSITION:
                ((LPIMECHARPOSITION)lParam)->dwCharPos = ((LPPrivateIMECHARPOSITION)lParam)->dwCharPositionA;
                break;

            case IMR_RECONVERTSTRING:
            case IMR_DOCUMENTFEED:
                //
                // Note: by definition, we don't need back-conversion for IMR_CONFIRMRECONVERTSTRING
                //
                if (retval) {
                    // IME wants the buffer size
                    retval = ImmGetReconvertTotalSize((DWORD)retval, FROM_APP, FALSE);
                    if (retval < sizeof(RECONVERTSTRING)) {
                        RIPMSG2(RIP_WARNING, "WM_IME_REQUEST(%x): return value from application %d is invalid.", wParam, retval);
                        retval = 0;
                    } else if (lParam) {
                        // We need to perform the A/W conversion of the contents
                        if (!ImmReconversionWorker((LPRECONVERTSTRING)lParam, (LPRECONVERTSTRING)pvData, TRUE, CP_ACP)) {
                            MSGERROR();
                        }
                    }
                }
                break;
            }
        }


    ERRORTRAP(0);

    if (pvData != NULL)
        UserLocalFree(pvData);

    ENDCALL(DWORD);
}
#endif

MESSAGECALL(fnEMGETSEL)
{
    PWND pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    BEGINCALL()

        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);

        //
        // temp for our beta...
        //
        // !!! THIS CODE SHOULD BE IN KERNEL MODE !!!
        //
        // to reduce user <-> kernel mode transition...
        //
        if (bAnsi != ((TestWF(pwnd, WFANSIPROC)) ? TRUE : FALSE)) {
            ULONG  cchTextLength;
            LONG   lOriginalLengthW;
            LONG   lOriginalLengthL;
            LONG   wParamLocal;
            LONG   lParamLocal;

            if (wParam) {
                lOriginalLengthW = *(LONG *)wParam;
            } else {
                lOriginalLengthW = (LONG)(LOWORD(retval));
            }

            if (lParam) {
                lOriginalLengthL = *(LONG *)lParam;
            } else {
                lOriginalLengthL = (LONG)(HIWORD(retval));
            }

            cchTextLength = (DWORD)NtUserMessageCall(
                           hwnd,
                           WM_GETTEXTLENGTH,
                           (WPARAM)0,
                           (LPARAM)0,
                           xParam,
                           xpfnProc,
                           bAnsi);

            if (cchTextLength) {
                PVOID pvString;
                ULONG cbTextLength;

                cchTextLength++;
                if (!bAnsi) {
                    cbTextLength = cchTextLength * sizeof(WCHAR);
                } else {
                    cbTextLength = cchTextLength;
                }

                pvString = UserLocalAlloc(0,cbTextLength);

                if (pvString) {

                    retval = (DWORD)NtUserMessageCall(
                            hwnd,
                            WM_GETTEXT,
                            cchTextLength,
                            (LPARAM)pvString,
                            xParam,
                            xpfnProc,
                            bAnsi);

                    if (retval) {
                        if (bAnsi) {
                            /*
                             * ansiString/unicodeLenght -> ansiLength
                             */
                            CalcAnsiStringLengthA(pvString, lOriginalLengthW, &wParamLocal)
                            CalcAnsiStringLengthA(pvString, lOriginalLengthL, &lParamLocal);
                        } else {
                            /*
                             * unicodeString/ansiLenght -> unicodeLength
                             */
                            CalcUnicodeStringLengthW(pvString, lOriginalLengthW, &wParamLocal);
                            CalcUnicodeStringLengthW(pvString, lOriginalLengthL, &lParamLocal);
                        }

                        retval = (DWORD)(((lParamLocal) << 16) | ((wParamLocal) & 0x0000FFFF));

                        if (wParam) {
                            *(LONG *)wParam = wParamLocal;
                        }

                        if (lParam) {
                            *(LONG *)lParam = lParamLocal;
                        }

                    } else {
                        UserLocalFree(pvString);
                        MSGERROR();
                    }

                    UserLocalFree(pvString);

                } else {
                    MSGERROR();
                }
            } else {
                MSGERROR();
            }
        }

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

MESSAGECALL(fnEMSETSEL)
{
    PWND pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL) {
        return 0;
    }

    BEGINCALL()

        //
        // temp for our beta...
        //
        // !!! THIS CODE SHOULD BE IN KERNEL MODE !!!
        //
        // to reduce user <-> kernel mode transition...
        //
        if (bAnsi != ((TestWF(pwnd, WFANSIPROC)) ? TRUE : FALSE)) {
            if (((LONG)wParam <= 0) && ((LONG)lParam <=0)) {
                //
                // if (wParam == 0 or wParam == -1)
                //               and
                //    (lParam == 0 or lParam == -1)
                //
                // In this case, we don't need to convert the value...
                //
            } else {
                ULONG  cchTextLength;
                LONG   lOriginalLengthW = (LONG)wParam;
                LONG   lOriginalLengthL = (LONG)lParam;

                cchTextLength = (DWORD)NtUserMessageCall(
                               hwnd,
                               WM_GETTEXTLENGTH,
                               (WPARAM)0,
                               (LPARAM)0,
                               xParam,
                               xpfnProc,
                               bAnsi);

                if (cchTextLength) {
                    PVOID pvString;
                    ULONG cbTextLength;

                    cchTextLength++;
                    if (!bAnsi) {
                        cbTextLength = cchTextLength * sizeof(WCHAR);
                    } else {
                        cbTextLength = cchTextLength;
                    }

                    pvString = UserLocalAlloc(0,cbTextLength);

                    if (pvString) {

                        retval = (DWORD)NtUserMessageCall(
                                hwnd,
                                WM_GETTEXT,
                                cchTextLength,
                                (LPARAM)pvString,
                                xParam,
                                xpfnProc,
                                bAnsi);

                        if (retval) {
                            if ((LONG)retval < lOriginalLengthW) {
                                lOriginalLengthW = (LONG)retval;
                            }
                            if ((LONG)retval < lOriginalLengthL) {
                                lOriginalLengthL = (LONG)retval;
                            }
                            if (bAnsi) {
                                if (lOriginalLengthW > 0) {
                                    CalcUnicodeStringLengthA(pvString, lOriginalLengthW, &wParam);
                                }
                                if (lOriginalLengthL > 0) {
                                    CalcUnicodeStringLengthA(pvString, lOriginalLengthL, &lParam);
                                }
                            } else {
                                if (lOriginalLengthW > 0) {
                                    CalcAnsiStringLengthW(pvString, lOriginalLengthW, &wParam);
                                }
                                if (lOriginalLengthL > 0) {
                                    CalcAnsiStringLengthW(pvString, lOriginalLengthL, &lParam);
                                }
                            }
                        } else {
                            UserLocalFree(pvString);
                            MSGERROR();
                        }

                        UserLocalFree(pvString);

                    } else {
                        MSGERROR();
                    }
                } else {
                    MSGERROR();
                }
            }
        }

        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

MESSAGECALL(fnCBGETEDITSEL)
{
    PWND pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    BEGINCALL()

        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);

        //
        // temp for our beta...
        //
        // !!! THIS CODE SHOULD BE IN KERNEL MODE !!!
        //
        // to reduce user <-> kernel mode transition...
        //
        if (bAnsi != ((TestWF(pwnd, WFANSIPROC)) ? TRUE : FALSE)) {
            ULONG  cchTextLength;
            LONG   lOriginalLengthW = *(LONG *)wParam;
            LONG   lOriginalLengthL = *(LONG *)lParam;
            LONG   wParamLocal;
            LONG   lParamLocal;

            if (wParam) {
                lOriginalLengthW = *(LONG *)wParam;
            } else {
                lOriginalLengthW = (LONG)(LOWORD(retval));
            }

            if (lParam) {
                lOriginalLengthL = *(LONG *)lParam;
            } else {
                lOriginalLengthL = (LONG)(HIWORD(retval));
            }

            cchTextLength = (DWORD)NtUserMessageCall(
                           hwnd,
                           WM_GETTEXTLENGTH,
                           (WPARAM)0,
                           (LPARAM)0,
                           xParam,
                           xpfnProc,
                           bAnsi);

            if (cchTextLength) {
                PVOID pvString;
                ULONG cbTextLength;

                cchTextLength++;
                if (!bAnsi) {
                    cbTextLength = cchTextLength * sizeof(WCHAR);
                } else {
                    cbTextLength = cchTextLength;
                }

                pvString = UserLocalAlloc(0,cbTextLength);

                if (pvString) {

                    retval = (DWORD)NtUserMessageCall(
                            hwnd,
                            WM_GETTEXT,
                            cchTextLength,
                            (LPARAM)pvString,
                            xParam,
                            xpfnProc,
                            bAnsi);

                    if (retval) {
                        if (bAnsi) {
                            /*
                             * ansiString/unicodeLenght -> ansiLength
                             */
                            CalcAnsiStringLengthA(pvString, lOriginalLengthW, &wParamLocal);
                            CalcAnsiStringLengthA(pvString, lOriginalLengthL, &lParamLocal);
                        } else {
                            /*
                             * unicodeString/ansiLenght -> unicodeLength
                             */
                            CalcUnicodeStringLengthW(pvString, lOriginalLengthW, &wParamLocal);
                            CalcUnicodeStringLengthW(pvString, lOriginalLengthL, &lParamLocal);
                        }

                        retval = (DWORD)(((lParamLocal) << 16) | ((wParamLocal) & 0x0000FFFF));

                        if (wParam) {
                            *(LONG *)wParam = wParamLocal;
                        }

                        if (lParam) {
                            *(LONG *)lParam = lParamLocal;
                        }

                    } else {
                        UserLocalFree(pvString);
                        MSGERROR();
                    }

                    UserLocalFree(pvString);

                } else {
                    MSGERROR();
                }
            } else {
                MSGERROR();
            }
        }

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

LONG BroadcastSystemMessageWorker(
    DWORD dwFlags,
    LPDWORD lpdwRecipients,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PBSMINFO pBSMInfo,
    BOOL fAnsi)
{
    DWORD  dwRecipients;

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (message & RESERVED_MSG_BITS) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid message 0x%x for BroadcastSystemMessage",
                message);
        return 0;
    }

    if (dwFlags & ~BSF_VALID) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid dwFlags 0x%x for BroadcastSystemMessage",
                dwFlags);
        return 0;
    }

    if ((dwFlags & (BSF_RETURNHDESK | BSF_LUID)) && pBSMInfo == NULL) {
        RIPERR0(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid BSF_RETURNHDESK or BSF_LUID is set and pBSMInfo is NULL for BroadcastSystemMessageEx");
        return 0;
    }

    if (pBSMInfo != NULL && pBSMInfo->cbSize != sizeof(BSMINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid pBSMInfo->cbSize (%x) for BroadcastSystemMessageEx",
                pBSMInfo->cbSize);
        return 0;
    }

    //
    // Check if the message number is in the private message range.
    // If so, do not send it to Win4.0 windows.
    // (This is required because apps like SimCity broadcast a message
    // that has the value 0x500 and that confuses MsgSrvr's
    // MSGSRVR_NOTIFY handler.
    //
    if (message >= WM_USER && message < 0xC000) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid message (%x) for BroadcastSystemMessage", message);
        return 0;
    }

    if (dwFlags & BSF_FORCEIFHUNG) {
        dwFlags |= BSF_NOHANG;
    }

    //
    // If BSF_QUERY or message has a pointer, it can not be posted.
    //
    if (dwFlags & BSF_QUERY) {
        if (dwFlags & BSF_ASYNC) {
            RIPMSGF0(RIP_WARNING, "BSF_QUERY can't be BSF_ASYNC");
        }

        dwFlags &= ~BSF_ASYNC;          // Strip the BSF_ASYNC flags.
    }

    if (dwFlags & BSF_ASYNC) {
        if (TESTSYNCONLYMESSAGE(message, wParam)) {
            RIPERR0(ERROR_MESSAGE_SYNC_ONLY,
                    RIP_WARNING,
                    "BSM: Can't post messages with pointers");
            dwFlags &= ~BSF_ASYNC;          // Strip the BSF_ASYNC flags.
        }
    }


    /*
     * Let us find out who the intended recipients are.
     */
    if (lpdwRecipients != NULL) {
        dwRecipients = *lpdwRecipients;
    } else {
        dwRecipients = BSM_ALLCOMPONENTS;
    }

    /*
     * If they want all components, add the corresponding bits.
     */
    if ((dwRecipients & BSM_COMPONENTS) == BSM_ALLCOMPONENTS) {
        dwRecipients |= (BSM_VXDS | BSM_NETDRIVER | BSM_INSTALLABLEDRIVERS |
                             BSM_APPLICATIONS);
    }


    if (dwRecipients & ~BSM_VALID) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "BSM: Invalid dwRecipients 0x%x",
                dwRecipients);
        return 0;
    }

    /*
     * Does this need to be sent to all apps?
     */
    if (dwRecipients & BSM_APPLICATIONS) {
        BROADCASTSYSTEMMSGPARAMS bsmParams;
        LONG lret;

        bsmParams.dwFlags = dwFlags;
        bsmParams.dwRecipients = dwRecipients;
        bsmParams.hwnd  = NULL;
        bsmParams.hdesk = NULL;
        if (dwFlags & BSF_LUID) {
            bsmParams.luid = pBSMInfo->luid;
        }

        lret = (LONG)CsSendMessage(GetDesktopWindow(), message, wParam, lParam,
            (ULONG_PTR)&bsmParams, FNID_SENDMESSAGEBSM, fAnsi);

        /*
         * Give the caller back the recipients that actually receive the message.
         */
        if (lpdwRecipients != NULL) {
            *lpdwRecipients = bsmParams.dwRecipients;
        }

        //
        // If the query was denied, then return who denied it.
        //
        if (lret == 0 && (dwFlags & BSF_QUERY) && pBSMInfo != NULL) {
            pBSMInfo->hwnd = bsmParams.hwnd;
            pBSMInfo->hdesk = bsmParams.hdesk;
        }

        return lret;
    }

    return -1;
}

HDEVNOTIFY
RegisterDeviceNotificationWorker(
    IN HANDLE hRecipient,
    IN LPVOID NotificationFilter,
    IN DWORD Flags)
{
    HINSTANCE hLib;
    FARPROC fpRegisterNotification;
    PVOID Context = NULL;
    HDEVNOTIFY notifyHandle = NULL;
    CONFIGRET Status = CR_SUCCESS;

    extern
    CONFIGRET
    CMP_RegisterNotification(IN  HANDLE   hRecipient,
                             IN  LPBYTE   NotificationFilter,
                             IN  DWORD    Flags,
                             OUT PVOID   *Context);

    //
    // Load the config manager client dll and retrieve entry pts.
    //
    hLib = LoadLibrary(TEXT("SETUPAPI.DLL"));
    if (hLib != NULL) {
        fpRegisterNotification = GetProcAddress(hLib,
                                                "CMP_RegisterNotification");
        if (fpRegisterNotification != NULL) {
            Status = (CONFIGRET)(*fpRegisterNotification)(hRecipient,
                                                          NotificationFilter,
                                                          Flags,
                                                          &Context);
        }

        FreeLibrary(hLib);
    }

    if (Status != CR_SUCCESS) {
        /*
         * Something went wrong, map the CR errors to a Win32 style error
         * code.
         */
        switch (Status) {
            case CR_INVALID_POINTER:
                SetLastError(ERROR_INVALID_PARAMETER);
                break;
            case CR_INVALID_DATA:
                SetLastError(ERROR_INVALID_DATA);
                break;
            case CR_OUT_OF_MEMORY:
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                break;
            case CR_FAILURE:
            default:
                SetLastError(ERROR_SERVICE_SPECIFIC_ERROR);
                break;

        }
    }

    if (Context != NULL && (ULONG_PTR)Context != -1) {
        notifyHandle = (HDEVNOTIFY)Context;
    }

    return notifyHandle;
}


BOOL
UnregisterDeviceNotification(
    IN HDEVNOTIFY Handle)
{
    HINSTANCE hLib;
    FARPROC fpUnregisterNotification;
    CONFIGRET crStatus = CR_SUCCESS;

    extern
    CONFIGRET
    CMP_UnregisterNotification(IN ULONG Context);

    /*
     * Load the config manager client dll and retrieve entry pts.
     */
    hLib = LoadLibrary(TEXT("SETUPAPI.DLL"));
    if (hLib != NULL) {
        fpUnregisterNotification = GetProcAddress(hLib,
                                                  "CMP_UnregisterNotification");
        if (fpUnregisterNotification != NULL) {
            crStatus = (CONFIGRET)(*fpUnregisterNotification)((ULONG_PTR)Handle);
        }

        FreeLibrary(hLib);
    }

    if (crStatus != CR_SUCCESS) {
        /*
         * Something went wrong, map the CR errors to a Win32 style error
         * code.
         */
        switch (crStatus) {
            case CR_INVALID_POINTER:
                SetLastError(ERROR_INVALID_PARAMETER);
                break;
            case CR_INVALID_DATA:
                SetLastError(ERROR_INVALID_DATA);
                break;
            case CR_FAILURE:
            default:
                SetLastError(ERROR_SERVICE_SPECIFIC_ERROR);
                break;
        }
    }

    return (BOOL)(crStatus == CR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\oemxlate.c ===
/**************************** Module Header ********************************\
* Module Name: oemxlate.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* ANSI/UNICODE(U+00--) to/from OEM translation routines for CP 437
*
* The goal of this module is to translate strings from ANSI/U+00-- to Oem
* character set or the opposite. If there is no equivalent character
* we use the followings rules:
*
*  1) we put a similar character (e.g. character without accent)
*  2) In OemToChar, graphics vertical, horizontal, and junction characters
*     are usually translated to '|', '-', and '+' characters, as appropriate,
*     unless the ANSI set is expanded to include such graphics.
*  3) Otherwise we put underscore "_".
*
* History:
* IanJa 4/10/91  from Win3.1 \\pucus\win31ro!drivers\keyboard\xlat*.*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* CharToOemA
*
* CharToOemA(pSrc, pDst) - Translates the ANSI string at pSrc into
* the OEM string at pDst.  pSrc == pDst is legal.
* Always returns TRUE
*
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, CharToOemA, LPCSTR, pSrc, LPSTR, pDst)
BOOL WINAPI CharToOemA(
    LPCSTR pSrc,
    LPSTR pDst)
{
    UserAssert(gpsi);

    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    }

    do {
        *pDst++ = gpsi->acAnsiToOem[(UCHAR)*pSrc];
    } while (*pSrc++);

    return TRUE;
}

/***************************************************************************\
* CharToOemBuffA
*
* CharToOemBuffA(pSrc, pDst, nLength) - Translates nLength characters from
* the ANSI string at pSrc into OEM characters in the buffer at pDst.
* pSrc == pDst is legal.
*
* History:
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, CharToOemBuffA, LPCSTR, pSrc, LPSTR, pDst, DWORD, nLength)
BOOL WINAPI CharToOemBuffA(
    LPCSTR pSrc,
    LPSTR pDst,
    DWORD nLength)
{
    UserAssert(gpsi);

    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    }

    while (nLength--) {
        *pDst++ = gpsi->acAnsiToOem[(UCHAR)*pSrc++];
    }

    return TRUE;
}


/***************************************************************************\
* OemToCharA
*
* OemToCharA(pSrc, pDst) - Translates the OEM string at pSrc into
* the ANSI string at pDst.  pSrc == pDst is legal.
*
* Always returns TRUE
*
* History:
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, OemToCharA, LPCSTR, pSrc, LPSTR, pDst)
BOOL WINAPI OemToCharA(
    LPCSTR pSrc,
    LPSTR pDst)
{
    UserAssert(gpsi);

    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    }

    do {
        *pDst++ = gpsi->acOemToAnsi[(UCHAR)*pSrc];
    } while (*pSrc++);

    return TRUE;
}


/***************************************************************************\
* OemToCharBuffA
*
* OemToCharBuffA(pSrc, pDst, nLength) - Translates nLength OEM characters from
* the buffer at pSrc into ANSI characters in the buffer at pDst.
* pSrc == pDst is legal.
*
* Always returns TRUE
*
* History:
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, OemToCharBuffA, LPCSTR, pSrc, LPSTR, pDst, DWORD, nLength)
BOOL WINAPI OemToCharBuffA(
    LPCSTR pSrc,
    LPSTR pDst,
    DWORD nLength)
{
    UserAssert(gpsi);

    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    }

    while (nLength--) {
        *pDst++ = gpsi->acOemToAnsi[(UCHAR)*pSrc++];
    }

    return TRUE;
}


/***************************************************************************\
* CharToOemW
*
* CharToOemW(pSrc, pDst) - Translates the Unicode string at pSrc into
* the OEM string at pDst.  pSrc == pDst is legal.
*
* History:
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, CharToOemW, LPCWSTR, pSrc, LPSTR, pDst)
BOOL WINAPI CharToOemW(
    LPCWSTR pSrc,
    LPSTR pDst)
{
    int cch;
    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    } else if (pSrc == (LPCWSTR)pDst) {
        /*
         * WideCharToMultiByte() requires pSrc != pDst: fail this call.
         * LATER: Is this really true?
         */
        return FALSE;
    }

    cch = wcslen(pSrc) + 1;

    WideCharToMultiByte(
            CP_OEMCP,           // Unicode -> OEM
            0,                  // gives best visual match
            (LPWSTR)pSrc, cch,  // source & length
            pDst,               // dest
            cch * 2,            // max poss.length (DBCS may * 2)
            "_",                // default char
            NULL);              // (don't care whether defaulted)

    return TRUE;
}

/***************************************************************************\
* CharToOemBuffW
*
* CharToOemBuffW(pSrc, pDst, nLength) - Translates nLength characters from
* the Unicode string at pSrc into OEM characters in the buffer at pDst.
* pSrc == pDst is legal.
*
* History:
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, CharToOemBuffW, LPCWSTR, pSrc, LPSTR, pDst, DWORD, nLength)
BOOL WINAPI CharToOemBuffW(
    LPCWSTR pSrc,
    LPSTR pDst,
    DWORD nLength)
{
    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    } else if (pSrc == (LPCWSTR)pDst) {
        /*
         * WideCharToMultiByte() requires pSrc != pDst: fail this call.
         * LATER: Is this really true?
         */
        return FALSE;
    }

    WideCharToMultiByte(
            CP_OEMCP,                   // Unicode -> OEM
            0,                          // gives best visual match
            (LPWSTR)pSrc, (int)nLength, // source & length
            pDst,                       // dest
            (int)nLength * 2,           // max poss. length (DBCS may * 2)
            "_",                        // default char
            NULL);                      // (don't care whether defaulted)

    return TRUE;
}

/***************************************************************************\
* OemToCharW
*
* OemToCharW(pSrc, pDst) - Translates the OEM string at pSrc into
* the Unicode string at pDst.  pSrc == pDst is not legal.
*
* History:
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, OemToCharW, LPCSTR, pSrc, LPWSTR, pDst)
BOOL WINAPI OemToCharW(
    LPCSTR pSrc,
    LPWSTR pDst)
{
    int cch;
    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    } else if (pSrc == (LPCSTR)pDst) {
        /*
         * MultiByteToWideChar() requires pSrc != pDst: fail this call.
         * LATER: Is this really true?
         */
        return FALSE;
    }

    cch = strlen(pSrc) + 1;

    MultiByteToWideChar(
            CP_OEMCP,                          // Unicode -> OEM
            MB_PRECOMPOSED | MB_USEGLYPHCHARS, // visual map to precomposed
            (LPSTR)pSrc, cch,                  // source & length
            pDst,                              // destination
            cch);                              // max poss. precomposed length

    return TRUE;
}

/***************************************************************************\
* OemToCharBuffW
*
* OemToCharBuffW(pSrc, pDst, nLength) - Translates nLength OEM characters from
* the buffer at pSrc into Unicode characters in the buffer at pDst.
* pSrc == pDst is not legal.
*
* History:
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, OemToCharBuffW, LPCSTR, pSrc, LPWSTR, pDst, DWORD, nLength)
BOOL WINAPI OemToCharBuffW(
    LPCSTR pSrc,
    LPWSTR pDst,
    DWORD nLength)
{
    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    } else if (pSrc == (LPCSTR)pDst) {
        /*
         * MultiByteToWideChar() requires pSrc != pDst: fail this call.
         * LATER: Is this really true?
         */
        return FALSE;
    }

    if (MultiByteToWideChar(
            CP_OEMCP,                          // Unicode -> OEM
            MB_PRECOMPOSED | MB_USEGLYPHCHARS, // visual map to precomposed
            (LPSTR)pSrc, nLength,              // source & length
            pDst,                              // destination
            nLength)) {                          // max poss. precomposed length
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* OemKeyScan (API)
*
* Converts an OEM character into a scancode plus shift state, returning
* scancode in low byte, shift state in high byte.
*
* Returns -1 on error.
*
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, DWORD, WINAPI, OemKeyScan, WORD, wOemChar)
DWORD WINAPI OemKeyScan(
    WORD wOemChar)
{
    WCHAR wchOem;
    SHORT sVk;
    UINT dwRet;

#ifdef FE_SB // OemKeyScan()
    /*
     * Return 0xFFFFFFFF for DBCS LeadByte character.
     */
    if (IsDBCSLeadByte(LOBYTE(wOemChar))) {
        return 0xFFFFFFFF;
    }
#endif // FE_SB

    if (!OemToCharBuffW((LPCSTR)&wOemChar, &wchOem, 1)) {
        return 0xFFFFFFFF;
    }

    sVk = VkKeyScanW(wchOem);
    if ((dwRet = MapVirtualKeyW(LOBYTE(sVk), 0)) == 0) {
        return 0xFFFFFFFF;
    }
    return dwRet | ((sVk & 0xFF00) << 8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\random.c ===
/****************************** Module Header ******************************\
* Module Name: random.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This file contains global function pointers that are called trough to get
* to either a client or a server function depending on which side we are on
*
* History:
* 10-Nov-1993 MikeKe    Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
*
*
* History:
* 10-Nov-1993 MikeKe    Created
\***************************************************************************/

HBRUSH                      ghbrWhite = NULL;
HBRUSH                      ghbrBlack = NULL;

/***************************************************************************\
* GetSysColorBrush
*
* Retrieves the system-color-brush.
*
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, HBRUSH, WINAPI, GetSysColorBrush, int, nIndex)
HBRUSH WINAPI GetSysColorBrush(
    int nIndex)
{
    if ((nIndex < 0) || (nIndex >= COLOR_MAX))
        return NULL;

    return SYSHBRUSH(nIndex);
}

/***************************************************************************\
* SetSysColorTemp
*
* Sets the global system colors all at once.  Also remembers the old colors
* so they can be reset.
*
* Sets/Resets the color and brush arrays for user USER drawing.
* lpRGBs and lpBrushes are pointers to arrays paralleling the argbSystem and
* gpsi->hbrSystem arrays.  wCnt is a sanity check so that this does the "right"
* thing in a future windows version.  The current argbSystem and hbrSystem
* arrays are saved off, and a handle to those saved arrays is returned.
*
* To reset the arrays, pass in NULL for lpRGBs, NULL for lpBrushes, and the
* handle (from the first set) for wCnt.
*
* History:
* 18-Sep-1995   JohnC   Gave this miserable function a life
\***************************************************************************/

LPCOLORREF gpOriginalRGBs = NULL;
UINT       gcOriginalRGBs = 0;

WINUSERAPI HANDLE WINAPI SetSysColorsTemp(
    CONST COLORREF *lpRGBs,
    CONST HBRUSH   *lpBrushes,
    UINT_PTR       cBrushes)      // Count of brushes or handle
{
    UINT cbRGBSize;
    UINT i;
    UINT abElements[COLOR_MAX];

    /*
     * See if we are resetting the colors back to a saved state
     */
    if (lpRGBs == NULL) {

        /*
         * When restoring cBrushes is really a handle to the old global
         * handle.  Make sure that is true.  Also lpBrushes is unused
         */
        UNREFERENCED_PARAMETER(lpBrushes);
        UserAssert(lpBrushes == NULL);
        UserAssert(cBrushes == (ULONG_PTR)gpOriginalRGBs);

        if (gpOriginalRGBs == NULL) {
            RIPMSG0(RIP_ERROR, "SetSysColorsTemp: Can not restore if not saved");
            return NULL;
        }

        /*
         * reset the global Colors
         */
        UserAssert((sizeof(abElements)/sizeof(abElements[0])) >= gcOriginalRGBs);
        for (i = 0; i < gcOriginalRGBs; i++)
            abElements[i] = i;

        NtUserSetSysColors(gcOriginalRGBs, abElements, gpOriginalRGBs, 0);

        UserLocalFree(gpOriginalRGBs);

        gpOriginalRGBs = NULL;
        gcOriginalRGBs = 0;

        return (HANDLE)TRUE;
    }

    /*
     * Make sure we aren't trying to set too many colors
     * If we allow more then COLOR_MAX change the abElements array
     */
    if (cBrushes > COLOR_MAX) {
        RIPMSG1(RIP_ERROR, "SetSysColorsTemp: trying to set too many colors %lX", cBrushes);
        return NULL;
    }

    /*
     * If we have already a saved state then don't let them save it again
     */
    if (gpOriginalRGBs != NULL) {
        RIPMSG0(RIP_ERROR, "SetSysColorsTemp: temp colors already set");
        return NULL;
    }

    /*
     * If we are here then we must be setting the new temp colors
     *
     * First save the old colors
     */
    cbRGBSize = sizeof(COLORREF) * (UINT)cBrushes;

    UserAssert(sizeof(COLORREF) == sizeof(int));
    gpOriginalRGBs = UserLocalAlloc(HEAP_ZERO_MEMORY, cbRGBSize);

    if (gpOriginalRGBs == NULL) {
        RIPMSG0(RIP_WARNING, "SetSysColorsTemp: unable to alloc temp colors buffer");
        return NULL;
    }

    RtlCopyMemory(gpOriginalRGBs, gpsi->argbSystem, cbRGBSize);

    /*
     * Now set the new colors.
     */
    UserAssert( (sizeof(abElements)/sizeof(abElements[0])) >= cBrushes);

    for (i = 0; i < cBrushes; i++)
        abElements[i] = i;

    NtUserSetSysColors((UINT)cBrushes, abElements, lpRGBs, 0);

    gcOriginalRGBs = (UINT)cBrushes;

    return gpOriginalRGBs;
}

/***************************************************************************\
* TextAlloc
*
* History:
* 25-Oct-1990   MikeHar     Wrote.
* 09-Nov-1990   DarrinM     Fixed.
* 13-Jan-1992   GregoryW    Neutralized.
\***************************************************************************/

LPWSTR TextAlloc(
    LPCWSTR lpszSrc)
{
    LPWSTR pszT;
    DWORD  cbString;

    if (lpszSrc == NULL)
        return NULL;

    cbString = (wcslen(lpszSrc) + 1) * sizeof(WCHAR);

    if (pszT = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cbString)) {

        RtlCopyMemory(pszT, lpszSrc, cbString);
    }

    return pszT;
}

#if DBG
/***************************************************************************\
* CheckCurrentDesktop
*
* Ensure that the pointer is valid for the current desktop.
*
* History:
* 10-Apr-1995   JimA    Created.
\***************************************************************************/

VOID CheckCurrentDesktop(
    PVOID p)
{
    UserAssert(p >= GetClientInfo()->pDeskInfo->pvDesktopBase &&
               p < GetClientInfo()->pDeskInfo->pvDesktopLimit);
}
#endif


/***************************************************************************\
* SetLastErrorEx
*
* Sets the last error, ignoring dwtype.
\***************************************************************************/

FUNCLOGVOID2(LOG_GENERAL, WINAPI, SetLastErrorEx, DWORD, dwErrCode, DWORD, dwType)
VOID WINAPI SetLastErrorEx(
    DWORD dwErrCode,
    DWORD dwType
    )
{
    UNREFERENCED_PARAMETER(dwType);

    SetLastError(dwErrCode);
}

#if defined(_X86_)
/***************************************************************************\
* InitializeWin32EntryTable
*
* Initializes a Win32 entry table so our test apps will know which entry
* points to avoid. This should be removed before we ship.
\***************************************************************************/

static CONST PROC FunctionsToSkip[] = {
    NtUserWaitMessage,
    NtUserLockWorkStation,
};


FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, InitializeWin32EntryTable, PBOOLEAN, pbEntryTable)
UINT InitializeWin32EntryTable(
    PBOOLEAN pbEntryTable)
{
#if DBG
    // We'll only define this on free systems for now. Checked systems
    // will hit too many asserts.
    UNREFERENCED_PARAMETER(pbEntryTable);
    return 0;
#else
    UINT i;
    PBYTE pb;

    if (pbEntryTable) {
        for (i = 0; i < ARRAY_SIZE(FunctionsToSkip); i++) {
            pb = (PBYTE)FunctionsToSkip[i];
            pbEntryTable[*((WORD *)(pb+1)) - 0x1000] = TRUE;
        }

    }

    return gDispatchTableValues;
#endif
}
#endif
/***************************************************************************\
* GetLastInputInfo
*
* Retrieves information about the last input event
*
* 05/30/07  GerardoB    Created
\***************************************************************************/
BOOL GetLastInputInfo (PLASTINPUTINFO plii)
{
    if (plii->cbSize != sizeof(LASTINPUTINFO)) {
        VALIDATIONFAIL(plii->cbSize);
    }

    plii->dwTime = gpsi->dwLastRITEventTickCount;

    return TRUE;
    VALIDATIONERROR(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\register.c ===
/****************************** Module Header ******************************\
* Module Name: register.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager - server registration module
*
* Created: 4/15/94 sanfords
*       to allow interoperability between DDEML16 and DDEML32
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * interoperable DDEML service registration is accomplished via the
 * two messages UM_REGISTER and UM_UNREGISTER. (WM_USER range)
 * wParam=gaApp,
 * lParam=src hwndListen, (for instance specific HSZ generation.)
 * These messages are sent and the sender is responsible for freeing
 * the gaApp.
 */


/*
 * Broadcast-sends the given message to all top-level windows of szClass
 * except to hwndSkip.
 */
VOID SendRegisterMessageToClass(
ATOM atomClass,
UINT msg,
GATOM ga,
HWND hwndFrom,
BOOL fPost)
{
    HWND hwnd;
    PWND pwnd;
    PCLS pcls;

    hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
    while (hwnd != NULL) {
        pwnd=ValidateHwndNoRip(hwnd);
        if (pwnd) {
            pcls = (PCLS)REBASEALWAYS(pwnd, pcls);
            if (pcls->atomClassName == atomClass) {
                IncGlobalAtomCount(ga); // receiver frees
                if (fPost) {
                    PostMessage(hwnd, msg, (WPARAM)ga, (LPARAM)hwndFrom);
                } else {
                    SendMessage(hwnd, msg, (WPARAM)ga, (LPARAM)hwndFrom);
                }
            }
        }
        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }
}


/*
 * Broadcast-sends a UM_REGISTER or UM_UNREGISTER message to all DDEML16
 * and DDEML32 listening windows in the system except hwndListen.
 *
 * We post Registration messages to prevent DdeConnectList recursion
 * and send Unregistration messages to avoid invalid source window
 * errors.
 */
VOID RegisterService(
BOOL fRegister,
GATOM gaApp,
HWND hwndListen)
{
    CheckDDECritOut;

    /*
     * Send notification to each DDEML32 listening window.
     */
    SendRegisterMessageToClass(gpsi->atomSysClass[ICLS_DDEMLMOTHER], fRegister ? UM_REGISTER : UM_UNREGISTER,
            gaApp, hwndListen, (GetAppCompatFlags2(VERMAX) & GACF2_DDENOASYNCREG) ? FALSE: fRegister);
    /*
     * Send notification to each DDEML16 listening window.
     */
    SendRegisterMessageToClass(gpsi->atomSysClass[ICLS_DDEML16BIT], fRegister ? UM_REGISTER : UM_UNREGISTER,
            gaApp, hwndListen, (GetAppCompatFlags2(VERMAX) & GACF2_DDENOASYNCREG) ? FALSE : fRegister);
}




LRESULT ProcessRegistrationMessage(
HWND hwnd,
UINT msg,
WPARAM wParam,
LPARAM lParam)
{
    PCL_INSTANCE_INFO pcii;
    LRESULT lRet = 0;

    CheckDDECritOut;

    /*
     * wParam = GATOM of app
     * lParam = hwndListen of source - may be a WOW DDEML source unthunked.
     */
    lParam = (LPARAM)HMValidateHandleNoRip((HWND)lParam, TYPE_WINDOW);
    lParam = (LPARAM)PtoH((PVOID)lParam);

    if (lParam == 0) {
        return(0);
    }

    EnterDDECrit;

    pcii = (PCL_INSTANCE_INFO)GetWindowLongPtr(hwnd, GWLP_INSTANCE_INFO);
    if (pcii != NULL &&
            !((msg == UM_REGISTER) && (pcii->afCmd & CBF_SKIP_REGISTRATIONS)) &&
            !((msg == UM_UNREGISTER) && (pcii->afCmd & CBF_SKIP_UNREGISTRATIONS))) {

        LATOM la, lais;

        la = GlobalToLocalAtom((GATOM)wParam);
        lais = MakeInstSpecificAtom(la, (HWND)lParam);

        DoCallback(pcii,
                (WORD)((msg == UM_REGISTER) ? XTYP_REGISTER : XTYP_UNREGISTER),
                0,
                (HCONV)0L,
                (HSZ)NORMAL_HSZ_FROM_LATOM(la),
                INST_SPECIFIC_HSZ_FROM_LATOM(lais),
                (HDDEDATA)0L,
                0L,
                0L);

        DeleteAtom(la);
        DeleteAtom(lais);
        lRet = 1;
    }

    GlobalDeleteAtom((ATOM)wParam);  // receiver frees
    LeaveDDECrit;
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\reason.c ===
/****************************** Module Header ******************************\
* Module Name: reason.c
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* This module contains the (private) APIs for the shutdown reason stuff.
*
* History:
* ??-??-???? HughLeat     Wrote it as part of msgina.dll
* 11-15-2000 JasonSch     Moved from msgina.dll to its new, temporary home in
*                         user32.dll. Ultimately this code should live in
*                         advapi32.dll, but that's contingent upon LoadString
*                         being moved to ntdll.dll.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <regstr.h>

REASON_INITIALISER g_rgReasonInits[] = {
    { UCLEANUI | SHTDN_REASON_MAJOR_HARDWARE | SHTDN_REASON_MINOR_MAINTENANCE,          IDS_REASON_UNPLANNED_HARDWARE_MAINTENANCE_TITLE,        IDS_REASON_HARDWARE_MAINTENANCE_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_MAJOR_HARDWARE | SHTDN_REASON_MINOR_MAINTENANCE,          IDS_REASON_PLANNED_HARDWARE_MAINTENANCE_TITLE,          IDS_REASON_HARDWARE_MAINTENANCE_DESCRIPTION },
    { UCLEANUI | SHTDN_REASON_MAJOR_HARDWARE | SHTDN_REASON_MINOR_INSTALLATION,         IDS_REASON_UNPLANNED_HARDWARE_INSTALLATION_TITLE,       IDS_REASON_HARDWARE_INSTALLATION_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_MAJOR_HARDWARE | SHTDN_REASON_MINOR_INSTALLATION,         IDS_REASON_PLANNED_HARDWARE_INSTALLATION_TITLE,         IDS_REASON_HARDWARE_INSTALLATION_DESCRIPTION },

    // { UCLEANUI | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_UPGRADE,       IDS_REASON_UNPLANNED_OPERATINGSYSTEM_UPGRADE_TITLE,     IDS_REASON_OPERATINGSYSTEM_UPGRADE_DESCRIPTION },
    // { PCLEANUI | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_UPGRADE,       IDS_REASON_PLANNED_OPERATINGSYSTEM_UPGRADE_TITLE,       IDS_REASON_OPERATINGSYSTEM_UPGRADE_DESCRIPTION },
    { UCLEANUI | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG,      IDS_REASON_UNPLANNED_OPERATINGSYSTEM_RECONFIG_TITLE,    IDS_REASON_OPERATINGSYSTEM_RECONFIG_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG,      IDS_REASON_PLANNED_OPERATINGSYSTEM_RECONFIG_TITLE,      IDS_REASON_OPERATINGSYSTEM_RECONFIG_DESCRIPTION },

    { UCLEANUI | SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_HUNG,              IDS_REASON_APPLICATION_HUNG_TITLE,                      IDS_REASON_APPLICATION_HUNG_DESCRIPTION },
    { UCLEANUI | SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_UNSTABLE,          IDS_REASON_APPLICATION_UNSTABLE_TITLE,                  IDS_REASON_APPLICATION_UNSTABLE_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_INSTALLATION,      IDS_REASON_PLANNED_APPLICATION_INSTALLATION_TITLE,      IDS_REASON_APPLICATION_INSTALLATION_DESCRIPTION },
    { UCLEANUI | SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_MAINTENANCE,       IDS_REASON_APPLICATION_MAINTENANCE_TITLE,               IDS_REASON_APPLICATION_MAINTENANCE_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_MAINTENANCE,       IDS_REASON_APPLICATION_PM_TITLE,                        IDS_REASON_APPLICATION_PM_DESCRIPTION },

    { UCLEANUI | SHTDN_REASON_FLAG_COMMENT_REQUIRED | SHTDN_REASON_MAJOR_OTHER | SHTDN_REASON_MINOR_OTHER,          IDS_REASON_UNPLANNED_OTHER_TITLE,                       IDS_REASON_OTHER_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_FLAG_COMMENT_REQUIRED | SHTDN_REASON_MAJOR_OTHER | SHTDN_REASON_MINOR_OTHER,          IDS_REASON_PLANNED_OTHER_TITLE,                         IDS_REASON_OTHER_DESCRIPTION },

    { UDIRTYUI | SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_BLUESCREEN,             IDS_REASON_SYSTEMFAILURE_BLUESCREEN_TITLE,              IDS_REASON_SYSTEMFAILURE_BLUESCREEN_DESCRIPTION },
    { UDIRTYUI | SHTDN_REASON_MAJOR_POWER | SHTDN_REASON_MINOR_CORDUNPLUGGED,           IDS_REASON_POWERFAILURE_CORDUNPLUGGED_TITLE,            IDS_REASON_POWERFAILURE_CORDUNPLUGGED_DESCRIPTION },
    { UDIRTYUI | SHTDN_REASON_MAJOR_POWER | SHTDN_REASON_MINOR_ENVIRONMENT,             IDS_REASON_POWERFAILURE_ENVIRONMENT_TITLE,              IDS_REASON_POWERFAILURE_ENVIRONMENT_DESCRIPTION },
    { UDIRTYUI | SHTDN_REASON_MAJOR_OTHER | SHTDN_REASON_MINOR_HUNG,                    IDS_REASON_OTHERFAILURE_HUNG_TITLE,                     IDS_REASON_OTHERFAILURE_HUNG_DESCRIPTION },
    { UDIRTYUI | SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED | SHTDN_REASON_MAJOR_OTHER | SHTDN_REASON_MINOR_OTHER,          IDS_REASON_UNPLANNED_OTHER_TITLE,            IDS_REASON_OTHER_DESCRIPTION },
    { SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_UPGRADE,     IDS_REASON_PLANNED_OPERATINGSYSTEM_UPGRADE_TITLE,      IDS_REASON_OPERATINGSYSTEM_UPGRADE_DESCRIPTION },
    { SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_SERVICEPACK, IDS_REASON_PLANNED_OPERATINGSYSTEM_SERVICEPACK_TITLE,  IDS_REASON_OPERATINGSYSTEM_SERVICEPACK_DESCRIPTION },
    { SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_HOTFIX,      IDS_REASON_PLANNED_OPERATINGSYSTEM_HOTFIX_TITLE,       IDS_REASON_OPERATINGSYSTEM_HOTFIX_DESCRIPTION },
    { SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_SECURITYFIX, IDS_REASON_PLANNED_OPERATINGSYSTEM_SECURITYFIX_TITLE,  IDS_REASON_OPERATINGSYSTEM_SECURITYFIX_DESCRIPTION },
    { SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_HOTFIX,                                  IDS_REASON_UNPLANNED_OPERATINGSYSTEM_HOTFIX_TITLE,     IDS_REASON_OPERATINGSYSTEM_HOTFIX_DESCRIPTION },
    { SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_SECURITYFIX,                             IDS_REASON_UNPLANNED_OPERATINGSYSTEM_SECURITYFIX_TITLE,IDS_REASON_OPERATINGSYSTEM_SECURITYFIX_DESCRIPTION },
    { SHTDN_REASON_LEGACY_API,                                                                         IDS_REASON_LEGACY_API_TITLE, IDS_REASON_LEGACY_API_DESCRIPTION },
    { UCLEANUI | SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_SECURITY,              IDS_REASON_SECURITY_ISSUE_TITLE,                      IDS_REASON_SECURITY_ISSUE_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_SECURITY,              IDS_REASON_SECURITY_ISSUE_TITLE,                      IDS_REASON_SECURITY_ISSUE_DESCRIPTION },
    { UDIRTYUI | SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_SECURITY,              IDS_REASON_SECURITY_ISSUE_TITLE,                      IDS_REASON_SECURITY_ISSUE_DESCRIPTION },
    // { PDIRTYUI | SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_SECURITY,              IDS_REASON_SECURITY_ISSUE_TITLE,                      IDS_REASON_SECURITY_ISSUE_DESCRIPTION },
    { UCLEANUI | SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_NETWORK_CONNECTIVITY,  IDS_REASON_LOSS_OF_NETWORK_TITLE,                     IDS_REASON_LOSS_OF_NETWORK_DESCRIPTION }
};

BOOL ReasonCodeNeedsComment(DWORD dwCode)
{
    return (dwCode & SHTDN_REASON_FLAG_COMMENT_REQUIRED) != 0;
}

BOOL ReasonCodeNeedsBugID(DWORD dwCode)
{
    return (dwCode & SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED) != 0;
}

/*
 * Here is the regular expression used to parse the user defined reason codes
 * in the registry:
 *
 * S -> 's' | 'S'          { Set For Clean  UI }
 * D -> 'd' | 'D'          { Set For  Dirty UI }
 * P -> 'p' | 'P'          { Set Planned  }
 * C -> 'c' | 'C'          { Set Comment Required }
 * B -> 'b' | 'B'          { Set Problem Id Required in Dirty Mode }
 *
 *
 * Delim -> ';'
 * Flag -> S | D | P | C | B
 * Flags -> ( Flag )*
 *
 * Digit -> '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | ''8' | '9'
 * Num -> Digit*
 * Maj -> Num          { Set Major Code }
 * Min -> Num          { Set Minor Code }
 *
 * ValidSentence -> Flags . Delim . Maj . Delim . Min
 *
 * All initial states are false for each flag and 0 for minor and major reason
 * codes.
 * If neither S nor D are specified it is invaliad.
 */

BOOL
ParseReasonCode(
    PWCHAR lpString,
    LPDWORD lpdwCode)
{
    WCHAR c;
    UINT major = 0, minor = 0;
    UINT cnt = 0;

    if (!lpString || !lpdwCode)
        return FALSE;

    *lpdwCode = SHTDN_REASON_FLAG_USER_DEFINED;

    /*
     * Read the flags part.
     */

    c = *lpString;
    while ( c != 0 && c != L';') {
        switch( c ) {
        case L'P' :
        case L'p' :
            if (*lpdwCode & SHTDN_REASON_FLAG_PLANNED)
                return FALSE;
            *lpdwCode |= SHTDN_REASON_FLAG_PLANNED;
            break;
        case L'C' :
        case L'c' :
            if (*lpdwCode & SHTDN_REASON_FLAG_COMMENT_REQUIRED)
                return FALSE;
            *lpdwCode |= SHTDN_REASON_FLAG_COMMENT_REQUIRED;
            break;
        case L'S' :
        case L's' :
            if (*lpdwCode & SHTDN_REASON_FLAG_CLEAN_UI)
                return FALSE;
            *lpdwCode |= SHTDN_REASON_FLAG_CLEAN_UI;
            break;
        case L'D' :
        case L'd' :
            if (*lpdwCode & SHTDN_REASON_FLAG_DIRTY_UI)
                return FALSE;
            *lpdwCode |= SHTDN_REASON_FLAG_DIRTY_UI;
            break;
        case L'B' :
        case L'b' :
            if (*lpdwCode & SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED)
                return FALSE;
            *lpdwCode |= SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED;
            break;
        default :
            return FALSE;
        }
        c = *++lpString;
    }

    if (!(*lpdwCode & SHTDN_REASON_FLAG_DIRTY_UI)
        && (*lpdwCode & SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED)) {
        return FALSE;
    }

    if (!(*lpdwCode & SHTDN_REASON_FLAG_CLEAN_UI)
        && (*lpdwCode & SHTDN_REASON_FLAG_COMMENT_REQUIRED)) {
        return FALSE;
    }

    /*
     * You must have clean, or dirty or both flags set.
     */

    if (!(*lpdwCode & ( SHTDN_REASON_FLAG_CLEAN_UI | SHTDN_REASON_FLAG_DIRTY_UI))) {
        return FALSE;
    }

    /*
     * You must have reason code.
     */

    if (c == 0) {
        return FALSE;
    }

    if (c != L';') {
        return FALSE;
    }

    c = *++lpString; /* Skip delimiter.*/

    /*
     * Parse major reason
     */

    while (c != 0 && c != L';') {
        if (c < L'0' || c > L'9') {
            return FALSE;
        }
        cnt++;
        if (cnt > 3) {
            return FALSE;
        }
        major = major * 10 + c - L'0';
        c = *++lpString;
    }

    /*
     * major reason < 0x40 (64) is reserved for Microsoft.
     */

    if (major > 0xff || major < 0x40) {
        return FALSE;
    }
    *lpdwCode |= major << 16;

    /*
     * requires minor code.
     */

    if (c == 0) {
        return FALSE;
    }

    /*
     * Should have a delimiter
     */

    if (c != L';') {
        return FALSE;
    }

    c = *++lpString; /* Skip delimiter. */

    /*
     * Parse minor reason
     */

    cnt = 0;
    while (c != 0) {
        if (c < L'0' || c > L'9') {
            return FALSE;
        }
        cnt++;
        if (cnt > 5) {
            return FALSE;
        }
        minor = minor * 10 + c - L'0';
        c = *++lpString;
    }

    if (minor > 0xffff) {
        return FALSE;
    }
    *lpdwCode |= minor;

    return TRUE;
}

int
__cdecl
CompareReasons(
    CONST VOID *A,
    CONST VOID *B)
{
    REASON *a = *(REASON **)A;
    REASON *b = *(REASON **)B;

    /*
     * Shift the planned bit out and put it back in the bottom.
     * Ignore all ui bits.
     */

    DWORD dwA = ((a->dwCode & SHTDN_REASON_VALID_BIT_MASK ) << 1) + !!(a->dwCode & SHTDN_REASON_FLAG_PLANNED);
    DWORD dwB = ((b->dwCode & SHTDN_REASON_VALID_BIT_MASK ) << 1) + !!(b->dwCode & SHTDN_REASON_FLAG_PLANNED);

    if (dwA < dwB) {
        return -1;
    } else if (dwA == dwB) {
        return 0;
    } else {
        return 1;
    }
}

BOOL
SortReasonArray(
    REASONDATA *pdata)
{
    qsort(pdata->rgReasons, pdata->cReasons, sizeof(REASON *), CompareReasons);
    return TRUE;
}

/*
 * Append a reason to the reason array.
 *
 * Return -1 on error, 1 on success, 0 if dup.
 */
INT
AppendReason(
    REASONDATA *pdata,
    REASON *reason)
{
    int i;

    if (!pdata || !reason) {
        return -1;
    }

    /*
     * Remove dup here.
     */

    if ( reason->dwCode & SHTDN_REASON_FLAG_USER_DEFINED) {
        for (i = 0; i < pdata->cReasons; ++i) {
            if ( (pdata->rgReasons[i]->dwCode & SHTDN_REASON_FLAG_PLANNED) == (reason->dwCode & SHTDN_REASON_FLAG_PLANNED)) {
                if (((pdata->rgReasons[i]->dwCode & SHTDN_REASON_FLAG_CLEAN_UI) && (reason->dwCode & SHTDN_REASON_FLAG_CLEAN_UI))
                    || ((pdata->rgReasons[i]->dwCode & SHTDN_REASON_FLAG_DIRTY_UI) && (reason->dwCode & SHTDN_REASON_FLAG_DIRTY_UI))) {
                    if (((pdata->rgReasons[i]->dwCode & 0x00ffffff) == (reason->dwCode & 0x00ffffff))
                        || (_wcsicmp(pdata->rgReasons[i]->szName, reason->szName) == 0)) {
                        UserLocalFree(reason);
                        return 0;
                    }
                }
            }
        }
    }

    /*
     * Insert the new reason into the list.
     */

    if (pdata->cReasons < pdata->cReasonCapacity) {
        pdata->rgReasons[pdata->cReasons++] = reason;
    } else {

        /*
         * Need to expand the list.
         */

        REASON **temp_list = (REASON **)UserLocalAlloc(0, sizeof(REASON*)*(pdata->cReasonCapacity*2+1));
        if (temp_list == NULL) {
            return -1;
        }

        for (i = 0; i < pdata->cReasons; ++i) {
            temp_list[i] = pdata->rgReasons[i];
        }
        temp_list[pdata->cReasons++] = reason;

        if (pdata->rgReasons ) {
            UserLocalFree(pdata->rgReasons);
        }
        pdata->rgReasons = temp_list;
        pdata->cReasonCapacity = pdata->cReasonCapacity*2+1;
    }

    return 1;
}

BOOL
LoadReasonStrings(
    int idStringName,
    int idStringDesc,
    REASON *reason)
{
    return (LoadStringW(hmodUser, idStringName, reason->szName, ARRAYSIZE(reason->szName)) != 0)
        && (LoadStringW(hmodUser, idStringDesc, reason->szDesc, ARRAYSIZE(reason->szDesc)) != 0);
}

BOOL
BuildPredefinedReasonArray(
    REASONDATA *pdata,
    BOOL forCleanUI,
    BOOL forDirtyUI)
{
    int i;
    DWORD code;

    /*
     * If forCleanUI and forDirtyUI are both false, we
     * actually will load all reasons (UI or non UI).
     */

    for (i = 0; i < ARRAYSIZE(g_rgReasonInits); ++i) {
        REASON *temp_reason = NULL;

        code = g_rgReasonInits[ i ].dwCode;
        if ((!forCleanUI && !forDirtyUI) ||
            (forCleanUI && (code & SHTDN_REASON_FLAG_CLEAN_UI)) ||
            (forDirtyUI && (code & SHTDN_REASON_FLAG_DIRTY_UI))) {

            temp_reason = (REASON *)UserLocalAlloc(0, sizeof(REASON));
            if (temp_reason == NULL) {
                return FALSE;
            }

            temp_reason->dwCode = g_rgReasonInits[i].dwCode;
            if (!LoadReasonStrings(g_rgReasonInits[i].dwNameId, g_rgReasonInits[i].dwDescId, temp_reason)) {
                UserLocalFree(temp_reason);
                return FALSE;
            }

            if (AppendReason(pdata, temp_reason) == -1) {
                UserLocalFree(temp_reason);
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL
BuildUserDefinedReasonArray(
    REASONDATA *pdata,
    HKEY hReliabilityKey,
    BOOL forCleanUI,
    BOOL forDirtyUI
    )
{
    UINT    i;
    HKEY    hKey = NULL;
    DWORD   num_values;
    DWORD   max_value_len;
    DWORD   rc;
    WCHAR   szUserDefined[] = L"UserDefined";
    UINT    uiReasons = 0;

    //
    //  sizeof L"UserDefined" + sizeof(LangID)(Max Chars of ULONG)(11) + 1 ('\')
    //
#define MAX_USER_LOCALE_KEY_SIZE (ARRAY_SIZE(szUserDefined) + 12)
    WCHAR   szUserLocale[MAX_USER_LOCALE_KEY_SIZE + 1];

    _snwprintf (szUserLocale, MAX_USER_LOCALE_KEY_SIZE, L"%s\\%d", szUserDefined, GetSystemDefaultLangID());
    szUserLocale[ MAX_USER_LOCALE_KEY_SIZE ] = 0;

#undef MAX_USER_LOCALE_KEY_SIZE

    if (!pdata || !hReliabilityKey) {
        return FALSE;
    }

    /*
     * First try to open the system locale key.
     */

    rc = RegOpenKeyExW(hReliabilityKey,
                               szUserLocale,
                               0, KEY_READ, &hKey);


    /*
     * Fall back on userdefined key.
     */

    if (rc != ERROR_SUCCESS){
        rc = RegCreateKeyExW(hReliabilityKey,
                                szUserDefined,
                                0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ,
                                NULL, &hKey, NULL);
    }

    if (rc != ERROR_SUCCESS) {
        goto fail;
    }

    rc = RegQueryInfoKeyW(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &num_values, NULL, &max_value_len, NULL, NULL);
    if (rc != ERROR_SUCCESS) {
        goto fail;
    }

    /*
     * Read the user defined reasons.
     */

    for (i = 0; i < num_values && uiReasons < MAX_NUM_REASONS; ++i) {
        WCHAR name_buffer[ 16 ]; /* the value name for reason should be something like "ccccc;ddd;ddddd". */
        DWORD name_buffer_len = ARRAY_SIZE(name_buffer); /* name buffer len is in WCHAR */
        DWORD type;
        WCHAR data[MAX_REASON_NAME_LEN + MAX_REASON_DESC_LEN + 1]; /* Space for name, desc and a null char.*/
        DWORD data_len = (MAX_REASON_NAME_LEN + MAX_REASON_DESC_LEN + 1) * sizeof(WCHAR); /* Data len is in bytes */
        DWORD code;
        REASON *temp_reason = NULL;
        LPWSTR szTemp = NULL;

        rc = RegEnumValueW(hKey, i, name_buffer, &name_buffer_len, NULL, &type, (LPBYTE)data, &data_len);
        if (rc != ERROR_SUCCESS) {
            continue;
        }

        if (type != REG_MULTI_SZ) { /* Not a multi_string - ignore it.*/
            continue;
        }

        // Tidy up the output from RegEnuValueW.
        name_buffer[ARRAY_SIZE(name_buffer) - 1] = 0;
        if (data_len/sizeof(WCHAR) + 2 <= ARRAY_SIZE(data)) {
            // A reason might not have any description, an extra
            // NULL is necessary under some sitations.
            data[data_len/sizeof(WCHAR)] = 0;
            data[data_len/sizeof(WCHAR) + 1] = 0;
        }

        if (!ParseReasonCode(name_buffer, &code)) { /* malformed reason code */
            continue;
        }

        /*
         * Neither title nor desc can be longer than specified.
         */

        if (lstrlenW (data) > MAX_REASON_NAME_LEN - 1
            || lstrlenW (data + lstrlenW(data) + 1) > MAX_REASON_DESC_LEN - 1) {
            continue;
        }

        if ( (!forCleanUI && !forDirtyUI)
            || (forCleanUI && (code & SHTDN_REASON_FLAG_CLEAN_UI) != 0)
            || (forDirtyUI && (code & SHTDN_REASON_FLAG_DIRTY_UI) != 0)) {

            temp_reason = (REASON *)UserLocalAlloc(0, sizeof(REASON));
            if (temp_reason == NULL) {
                goto fail;
            }

            temp_reason->dwCode = code;
            // name and desc lenghts are checked already, should be ok here.
            lstrcpyW(temp_reason->szName, data);
            lstrcpyW(temp_reason->szDesc, data + lstrlenW(data) + 1);

            /*
             * Don't allow reasons without a title.
             */

            if (lstrlenW(temp_reason->szName) == 0) {
                UserLocalFree(temp_reason);
            } else {

                /*
                 * Dont allow reason title with only spaces.
                 */

                szTemp = temp_reason->szName;
                while (*szTemp && iswspace (*szTemp)) {
                    szTemp++;
                }
                if (! *szTemp) {
                    UserLocalFree(temp_reason);
                } else {
                    INT ret = AppendReason(pdata, temp_reason);
                    if (ret == -1) {
                        UserLocalFree(temp_reason);
                        goto fail;
                    } else if (ret == 1) {
                        uiReasons++;
                    } // else do nothing when dup.
                }
            }
        }
    }

    RegCloseKey(hKey);
    return TRUE;

fail :
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    return FALSE;
}

BOOL
BuildReasonArray(
    REASONDATA *pdata,
    BOOL forCleanUI,
    BOOL forDirtyUI)
{
    HKEY hReliabilityKey;
    DWORD ignore_predefined_reasons = FALSE;
    DWORD value_size = sizeof(DWORD);
    DWORD rc;
    DWORD dwPredefinedReasons;

    if (!pdata) {
        return FALSE;
    }

    pdata->rgReasons = (REASON **)UserLocalAlloc(0, sizeof(REASON *) * ARRAYSIZE(g_rgReasonInits));
    if (pdata->rgReasons == NULL) {
        return FALSE;
    }
    pdata->cReasonCapacity = ARRAYSIZE(g_rgReasonInits);
    pdata->cReasons = 0;

    if (!BuildPredefinedReasonArray(pdata, forCleanUI, forDirtyUI)) {
        DestroyReasons(pdata);
        return FALSE;
    }

    dwPredefinedReasons = pdata->cReasons;

    /*
     * Open the reliability key.
     */

    rc = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                        REGSTR_PATH_RELIABILITY,
                        0, NULL, REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE, NULL,
                        &hReliabilityKey, NULL);

    if (rc == ERROR_SUCCESS) {
        rc = RegQueryValueEx(hReliabilityKey, REGSTR_VAL_SHUTDOWN_IGNORE_PREDEFINED, NULL, NULL, (UCHAR *)&ignore_predefined_reasons, &value_size);
        if (rc != ERROR_SUCCESS) {
            ignore_predefined_reasons = FALSE;
        }

        if (!BuildUserDefinedReasonArray(pdata, hReliabilityKey, forCleanUI, forDirtyUI) || pdata->cReasons == 0) {
            ignore_predefined_reasons = FALSE;
        }

        RegCloseKey(hReliabilityKey);
    }

    // if ignore predefined reasons, we need to remove them from the list.
    // But we do this only if there is some custom reasons.
    if (ignore_predefined_reasons && pdata->cReasons > (int)dwPredefinedReasons) {
        DWORD i;
        for (i = 0; i < dwPredefinedReasons; i++) {
            UserLocalFree(pdata->rgReasons[i]);
        }
        memmove(pdata->rgReasons, &pdata->rgReasons[dwPredefinedReasons], sizeof(REASON*)*(pdata->cReasons-dwPredefinedReasons));
        pdata->cReasons -= dwPredefinedReasons;
    }

    return SortReasonArray(pdata);
}

VOID
DestroyReasons(
    REASONDATA *pdata)
{
    int i;

    if (pdata->rgReasons != 0) {
        for (i = 0; i < pdata->cReasons; ++i) {
            UserLocalFree( pdata->rgReasons[i]);
        }
        UserLocalFree(pdata->rgReasons);
        pdata->rgReasons = 0;
    }
    pdata->cReasons = 0;
}

/*
 * Get the title from the reason code.
 * Returns FALSE on error, TRUE otherwise.
 *
 * If the reason code cannot be found, then it fills the title with a default
 * string.
 */
BOOL
GetReasonTitleFromReasonCode(
    DWORD code,
    WCHAR *lpTitle,
    DWORD dwTitleLen)
{
    REASONDATA  data;
    DWORD       dwFlagBits = SHTDN_REASON_FLAG_CLEAN_UI | SHTDN_REASON_FLAG_DIRTY_UI;
    int         i;

    if (lpTitle == NULL || dwTitleLen == 0) {
        return FALSE;
    }

    /*
     * Load all of the reasons (UI or non UI).
     */

    if (BuildReasonArray(&data, FALSE, FALSE) == FALSE) {
        return FALSE;
    }

    /*
     * Try to find the reason.
     */

    for (i = 0; i < data.cReasons; ++i) {
        if ((code & SHTDN_REASON_VALID_BIT_MASK) == (data.rgReasons[i]->dwCode & SHTDN_REASON_VALID_BIT_MASK)) { // Check valid bits.
            if ((!(code & dwFlagBits) && !(data.rgReasons[i]->dwCode & dwFlagBits))
                || (code & SHTDN_REASON_FLAG_CLEAN_UI && data.rgReasons[i]->dwCode & SHTDN_REASON_FLAG_CLEAN_UI)
                || (code & SHTDN_REASON_FLAG_DIRTY_UI && data.rgReasons[i]->dwCode & SHTDN_REASON_FLAG_DIRTY_UI) ) { // check flag bits.
                lstrcpynW(lpTitle, data.rgReasons[i]->szName, dwTitleLen);
                lpTitle[dwTitleLen - 1] = '\0';
                DestroyReasons(&data);
                return TRUE;
            }
        }
    }

    /*
     * Reason not found.  Load the default string and return that.
     */

    DestroyReasons(&data);
    return (LoadStringW(hmodUser, IDS_REASON_DEFAULT_TITLE, lpTitle, dwTitleLen) != 0);
}

/*
 * Check to see if SET is enabled.
 * return TRUE if yes, FALSE if no.
 * Currently SET is controled by policy, but we need to handle the case where
 * the policy is not configured as in a clean setup case.
 */
BOOL
IsSETEnabled(
    VOID)
{
    HKEY hKey;
    DWORD rc;
    DWORD ShowReasonUI = 0;
    OSVERSIONINFOEX osVersionInfoEx;

    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RELIABILITY_POLICY, 0, KEY_QUERY_VALUE, &hKey);

    if (rc == ERROR_SUCCESS) {
        DWORD ValueSize = sizeof (DWORD);
        rc = RegQueryValueEx(hKey, REGSTR_PATH_RELIABILITY_POLICY_SHUTDOWNREASONUI, NULL, NULL, (UCHAR*)&ShowReasonUI, &ValueSize);

        /*
         * Now check the sku to decide whether we should show the dialog
         */
        if (rc == ERROR_SUCCESS) {
            if (ShowReasonUI != POLICY_SHOWREASONUI_NEVER && ShowReasonUI != POLICY_SHOWREASONUI_ALWAYS) {
                osVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
                if (GetVersionEx((LPOSVERSIONINFOW)&osVersionInfoEx)) {
                    /*
                     * if ShowReasonUI is anything other than 2 or 3, we think it is 0.
                     */
                    switch (osVersionInfoEx.wProductType) {
                    case VER_NT_WORKSTATION:
                        if (ShowReasonUI == POLICY_SHOWREASONUI_WORKSTATIONONLY) {
                            ShowReasonUI = 1;
                        } else {
                            ShowReasonUI = 0;
                        }
                        break;
                    default:
                        if (ShowReasonUI == POLICY_SHOWREASONUI_SERVERONLY) {
                            ShowReasonUI = 1;
                        } else {
                            ShowReasonUI = 0;
                        }
                        break;
                    }
                }
            } else {
                ShowReasonUI = ShowReasonUI == POLICY_SHOWREASONUI_ALWAYS ? 1 : 0;
            }
        } else if (rc == ERROR_FILE_NOT_FOUND) {
            /*
             * Try to check the ShutdownReasonOn. if absent, it is not configured.
             * if it is there, the value must be 0.
             */
            DWORD dwSROn;
            rc = RegQueryValueEx(hKey, L"ShutdownReasonOn", NULL, NULL, (UCHAR*)&dwSROn, &ValueSize);
            if (rc == ERROR_FILE_NOT_FOUND) {
                osVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
                if (GetVersionEx((LPOSVERSIONINFOW)&osVersionInfoEx)) {
                    switch (osVersionInfoEx.wProductType) {
                    case VER_NT_WORKSTATION:
                        ShowReasonUI = 0;
                        break;
                    default:
                        ShowReasonUI = 1;
                        break;
                    }
                } 
            } 
        } 
        RegCloseKey (hKey);
    } else if (rc == ERROR_FILE_NOT_FOUND) { // Policy not configured.
        osVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        if (GetVersionEx((LPOSVERSIONINFOW)&osVersionInfoEx)) {
            switch (osVersionInfoEx.wProductType) {
            case VER_NT_WORKSTATION:
                ShowReasonUI = 0;
                break;
            default:
                ShowReasonUI = 1;
                break;
            }
        } 
    }

    return (ShowReasonUI != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\rtlinit.c ===
/****************************** Module Header ******************************\
* Module Name: rtlinit.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 14-Jan-1991 mikeke
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/**************************************************************************\
* RtlCaptureAnsiString
*
* Converts a NULL-terminated ANSI string into a counted unicode string.
*
* 03-22-95 JimA         Created.
\**************************************************************************/
BOOL RtlCaptureAnsiString(
    PIN_STRING pstr,
    LPCSTR psz,
    BOOL fForceAlloc)
{
    int cbSrc, cbDst;
    NTSTATUS Status;

    pstr->fAllocated = FALSE;
    if (psz) {
        cbSrc = strlen(psz) + 1;
        if (cbSrc > MAXUSHORT) {
            RIPMSG0(RIP_WARNING, "String too long for standard string");
            return FALSE;
        }

        /*
         * If the allocation is forced or if the string is too long to fit
         * in the TEB, allocate a buffer. Otherwise, store the result in the
         * TEB.
         */
        if (fForceAlloc || cbSrc > (STATIC_UNICODE_BUFFER_LENGTH / sizeof(WCHAR))) {
            pstr->strCapture.Buffer = UserLocalAlloc(0, cbSrc * sizeof(WCHAR));
            if (pstr->strCapture.Buffer == NULL) {
                return FALSE;
            }
            pstr->fAllocated = TRUE;
            pstr->pstr = &pstr->strCapture;
            pstr->strCapture.MaximumLength = (USHORT)(cbSrc * sizeof(WCHAR));
        } else {
            pstr->pstr = &NtCurrentTeb()->StaticUnicodeString;
        }

        /*
         * Convert the string to Unicode.
         */
        Status = RtlMultiByteToUnicodeN(pstr->pstr->Buffer,
                                        (ULONG)pstr->pstr->MaximumLength,
                                        &cbDst,
                                        (LPSTR)psz,
                                        cbSrc);
        if (!NT_SUCCESS(Status)) {
            RIPMSG0(RIP_WARNING, "Unicode conversion failed");
            if (pstr->fAllocated) {
                UserLocalFree(pstr->strCapture.Buffer);
                pstr->fAllocated = FALSE;
            }

            return FALSE;
        }
        pstr->pstr->Length = (USHORT)cbDst - sizeof(WCHAR);
    } else {
        pstr->pstr = &pstr->strCapture;
        pstr->strCapture.Length = pstr->strCapture.MaximumLength = 0;
        pstr->strCapture.Buffer = NULL;
    }

    return TRUE;
}

/**************************************************************************\
* RtlCaptureLargeAnsiString
*
* Captures a large ANSI string in the same manner as RtlCaptureAnsiString.
*
* 03-22-95 JimA         Created.
\**************************************************************************/
BOOL RtlCaptureLargeAnsiString(
    PLARGE_IN_STRING plstr,
    LPCSTR psz,
    BOOL fForceAlloc)
{
    int cchSrc;
    UINT uLength;
    NTSTATUS Status;

    plstr->fAllocated = FALSE;
    plstr->strCapture.bAnsi = FALSE;
    plstr->pstr = &plstr->strCapture;

    if (psz) {
        cchSrc = strlen(psz) + 1;

        /*
         * If the allocation is forced or if the string is too long to fit
         * in the TEB, allocate a buffer. Otherwise, store the result in the
         * TEB.
         */
        if (fForceAlloc || cchSrc > STATIC_UNICODE_BUFFER_LENGTH) {
            plstr->strCapture.Buffer = UserLocalAlloc(0, cchSrc * sizeof(WCHAR));
            if (plstr->strCapture.Buffer == NULL) {
                return FALSE;
            }
            plstr->fAllocated = TRUE;
            plstr->strCapture.MaximumLength = cchSrc * sizeof(WCHAR);
        } else {
            plstr->strCapture.Buffer = NtCurrentTeb()->StaticUnicodeBuffer;
            plstr->strCapture.MaximumLength =
                    (UINT)(STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR));
        }

        /*
         * Convert the string to Unicode.
         */
        Status = RtlMultiByteToUnicodeN(KPWSTR_TO_PWSTR(plstr->pstr->Buffer),
                                        plstr->pstr->MaximumLength,
                                        &uLength,
                                        (LPSTR)psz,
                                        cchSrc);
        if (!NT_SUCCESS(Status)) {
            RIPMSG0(RIP_WARNING, "Unicode conversion failed");
            if (plstr->fAllocated) {
                UserLocalFree(KPWSTR_TO_PWSTR(plstr->strCapture.Buffer));
                plstr->fAllocated = FALSE;
            }
            return FALSE;
        }
        plstr->pstr->Length = uLength - sizeof(WCHAR);
    } else {
        plstr->strCapture.Length = plstr->strCapture.MaximumLength = 0;
        plstr->strCapture.Buffer = NULL;
    }

    return TRUE;
}

/**************************************************************************\
* AllocateFromZone
*
* This routine removes an entry from the zone and returns a pointer to it.
*
* Arguments:
*
*   Zone - Pointer to the zone header controlling the storage from which the
*          entry is to be allocated.
*
* Return Value:
*
*   The function value is a pointer to the storage allocated from the zone.
\**************************************************************************/
__inline PVOID AllocateFromZone(
    PZONE_HEADER Zone)
{
    PVOID ptr = (PVOID)(Zone->FreeList.Next);

    if (Zone->FreeList.Next) {
        Zone->FreeList.Next = Zone->FreeList.Next->Next;
    }

    return ptr;
}


/**************************************************************************\
* FreeToZone
*
* This routine places the specified block of storage back onto the free
* list in the specified zone.
*
* Arguments:
*
*   Zone - Pointer to the zone header controlling the storage to which the
*          entry is to be inserted.
*
*   Block - Pointer to the block of storage to be freed back to the zone.
*
* Return Value:
*
*   Pointer to previous block of storage that was at the head of the free
*   list. NULL implies the zone went from no available free blocks to at
*   least one free block.
\**************************************************************************/
__inline VOID FreeToZone(
    PZONE_HEADER Zone,
    PVOID Block)
{
    ((PSINGLE_LIST_ENTRY)Block)->Next = Zone->FreeList.Next;
    Zone->FreeList.Next = (PSINGLE_LIST_ENTRY)Block;
}

/***************************************************************************\
* InitLookaside
*
* Initializes the lookaside list. This improves control locality by keeping
* control entries in a single page
*
* 05-04-95 JimA         Created.
\***************************************************************************/
NTSTATUS
InitLookaside(
    PLOOKASIDE pla,
    DWORD cbEntry,
    DWORD cEntries)
{
    ULONG i;
    PCH p;
    ULONG BlockSize;
    PZONE_HEADER Zone;
    PVOID InitialSegment;
    ULONG InitialSegmentSize;


    InitialSegmentSize = (cEntries * cbEntry) + sizeof(ZONE_SEGMENT_HEADER);

    p = (PCH)UserLocalAlloc(0, InitialSegmentSize);
    if (!p) {
        return STATUS_NO_MEMORY;
    }

    RtlEnterCriticalSection(&gcsLookaside);

    //
    // If the lookaside list has already been initialized, we're done.
    //

    if (pla->LookasideBase != NULL && pla->EntrySize == cbEntry) {
        RtlLeaveCriticalSection(&gcsLookaside);
        UserLocalFree(p);
        return STATUS_SUCCESS;
    }

    pla->LookasideBase = (PVOID)p;
    pla->LookasideBounds = (PVOID)(p + InitialSegmentSize);
    pla->EntrySize = cbEntry;

    //
    // Using the ExZone-like code, slice up the page into QMSG's
    //

    Zone = &pla->LookasideZone;
    BlockSize = cbEntry;
    InitialSegment = pla->LookasideBase;

    Zone->BlockSize = BlockSize;

    Zone->SegmentList.Next = &((PZONE_SEGMENT_HEADER) InitialSegment)->SegmentList;
    ((PZONE_SEGMENT_HEADER) InitialSegment)->SegmentList.Next = NULL;
    ((PZONE_SEGMENT_HEADER) InitialSegment)->Reserved = NULL;

    Zone->FreeList.Next = NULL;

    p = (PCH)InitialSegment + sizeof(ZONE_SEGMENT_HEADER);

    for (i = sizeof(ZONE_SEGMENT_HEADER);
         i <= InitialSegmentSize - BlockSize;
         i += BlockSize) {
        ((PSINGLE_LIST_ENTRY)p)->Next = Zone->FreeList.Next;
        Zone->FreeList.Next = (PSINGLE_LIST_ENTRY)p;
        p += BlockSize;
    }
    Zone->TotalSegmentSize = i;

    RtlLeaveCriticalSection(&gcsLookaside);

    return STATUS_SUCCESS;

}

/***************************************************************************\
* AllocLookasideEntry
*
* Allocates an entry from the lookaside list.
*
* 05-04-95 JimA         Created.
\***************************************************************************/
PVOID AllocLookasideEntry(
    PLOOKASIDE pla)
{
    PVOID pEntry;

    //
    // Attempt to get an entry from the zone. If this fails, then
    // UserLocalAlloc the entry.
    //

    RtlEnterCriticalSection(&gcsLookaside);
    pEntry = AllocateFromZone(&pla->LookasideZone);
    RtlLeaveCriticalSection(&gcsLookaside);

    if (!pEntry) {
        /*
         * Allocate a local structure.
         */
#if DBG
        pla->AllocSlowCalls++;
#endif

        if ((pEntry = UserLocalAlloc(0, pla->EntrySize)) == NULL) {
            return NULL;
        }
    }
    RtlZeroMemory(pEntry, pla->EntrySize);

#if DBG
    pla->AllocCalls++;

    if (pla->AllocCalls - pla->DelCalls > pla->AllocHiWater) {
        pla->AllocHiWater = pla->AllocCalls - pla->DelCalls;
    }
#endif

    return pEntry;
}

/***************************************************************************\
* FreeLookasideEntry
*
* Returns a qmsg to the lookaside buffer or free the memory.
*
* 05-04-95 JimA         Created.
\***************************************************************************/
VOID FreeLookasideEntry(
    PLOOKASIDE pla,
    PVOID pEntry)
{
#if DBG
    pla->DelCalls++;
#endif

    //
    // If the pEntry was from zone, then free to zone.
    //
    if ((PVOID)pEntry >= pla->LookasideBase && (PVOID)pEntry < pla->LookasideBounds) {
        RtlEnterCriticalSection(&gcsLookaside);
        FreeToZone(&pla->LookasideZone, pEntry);
        RtlLeaveCriticalSection(&gcsLookaside);
    } else {
#if DBG
        pla->DelSlowCalls++;
#endif
        UserLocalFree(pEntry);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\sbapi.c ===
/**************************** Module Header ********************************\
* Module Name:
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Scroll bar public APIs
*
* History:
*   08-16-95 FritzS
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


WINUSERAPI
BOOL
WINAPI
EnableScrollBar(
    IN HWND hWnd,
    IN UINT wSBflags,
    IN UINT wArrows)
{
    BOOL ret;

    BEGIN_USERAPIHOOK()
        ret = guah.pfnEnableScrollBar(hWnd, wSBflags, wArrows);
    END_USERAPIHOOK()

    return ret;
}


BOOL RealEnableScrollBar(
    IN HWND hWnd,
    IN UINT wSBflags,
    IN UINT wArrows)
{
    return NtUserEnableScrollBar(hWnd, wSBflags, wArrows);
}



/***************************************************************************\
* SetScrollPos
*
* History:
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, int, DUMMYCALLINGTYPE, SetScrollPos, HWND, hwnd, int, code, int, pos, BOOL, fRedraw)
int SetScrollPos(
    HWND hwnd,
    int code,
    int pos,
    BOOL fRedraw)
{
    SCROLLINFO si;

    si.fMask = SIF_POS | SIF_RETURNOLDPOS;
    si.nPos = pos;
    si.cbSize = sizeof(SCROLLINFO);

    return((int) SetScrollInfo(hwnd, code, &si, fRedraw));
}


/***************************************************************************\
* SetScrollRange
*
* History:
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetScrollRange, HWND, hwnd, int, code, int, posMin, int, posMax, BOOL, fRedraw)
BOOL SetScrollRange(
    HWND hwnd,
    int code,
    int posMin,
    int posMax,
    BOOL fRedraw)
{
    SCROLLINFO si;

    /*
     * Validate the window handle first, because the further call
     * to NtUserSetScrollInfo will return the position of the scrollbar
     * and not FALSE if the hwnd is invalid
     */
    if ( ValidateHwnd((hwnd)) == NULL)
        return FALSE;

    /*
     * Check if the 'Range'(Max - Min) can be represented by an integer;
     * If not, it is an error;
     * Fix for Bug #1089 -- SANKAR -- 20th Sep, 1989 --.
     */
    if ((unsigned int)(posMax - posMin) > MAXLONG) {
        RIPERR0(ERROR_INVALID_SCROLLBAR_RANGE, RIP_VERBOSE, "");
        return FALSE;
    }

    si.fMask  = SIF_RANGE;
    si.nMin   = posMin;
    si.nMax   = posMax;
    si.cbSize = sizeof(SCROLLINFO);

    SetScrollInfo(hwnd, code, &si, fRedraw);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\rtlres.c ===
/****************************** Module Header ******************************\
*
* Module Name: rtlres.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Resource Loading Routines
*
* History:
* 05-Apr-1991 ScottLu   Fixed up, resource code is now shared between client
*                       and server, added a few new resource loading routines.
* 24-Sep-1990 MikeKe    From win30
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

HICON IconFromBestImage(
    ICONFILEHEADER *pifh,
    LPNEWHEADER     lpnhSrc,
    int             cxDesired,
    int             cyDesired,
    UINT            LR_flags);

/***************************************************************************\
* LoadStringOrError
*
* NOTE: Passing a NULL value for lpch returns the string length. (WRONG!)
*
* Warning: The return count does not include the terminating NULL WCHAR;
*
* History:
* 05-Apr-1991 ScottLu   Fixed - code is now shared between client and server
* 24-Sep-1990 MikeKe    From Win30
\***************************************************************************/

int LoadStringOrError(
    HANDLE    hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax,        // cch in Unicode buffer
    WORD      wLangId)
{
    HANDLE hResInfo;
    HANDLE hStringSeg;
    LPTSTR lpsz;
    int    cch;

    /*
     * Make sure the parms are valid.
     */
    if (lpBuffer == NULL) {
        RIPMSG0(RIP_WARNING, "LoadStringOrError: lpBuffer == NULL");
        return 0;
    }


    cch = 0;

    /*
     * String Tables are broken up into 16 string segments.  Find the segment
     * containing the string we are interested in.
     */
    if (hResInfo = FINDRESOURCEEXW(hModule, (LPTSTR)ULongToPtr( ((LONG)(((USHORT)wID >> 4) + 1)) ), RT_STRING, wLangId)) {

        /*
         * Load that segment.
         */
        hStringSeg = LOADRESOURCE(hModule, hResInfo);

        /*
         * Lock the resource.
         */
        if (lpsz = (LPTSTR)LOCKRESOURCE(hStringSeg, hModule)) {

            /*
             * Move past the other strings in this segment.
             * (16 strings in a segment -> & 0x0F)
             */
            wID &= 0x0F;
            while (TRUE) {
                cch = *((UTCHAR *)lpsz++);      // PASCAL like string count
                                                // first UTCHAR is count if TCHARs
                if (wID-- == 0) break;
                lpsz += cch;                    // Step to start if next string
            }

            /*
             * chhBufferMax == 0 means return a pointer to the read-only resource buffer.
             */
            if (cchBufferMax == 0) {
                *(LPTSTR *)lpBuffer = lpsz;
            } else {

                /*
                 * Account for the NULL
                 */
                cchBufferMax--;

                /*
                 * Don't copy more than the max allowed.
                 */
                if (cch > cchBufferMax)
                    cch = cchBufferMax;

                /*
                 * Copy the string into the buffer.
                 */
                RtlCopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));
            }

            /*
             * Unlock resource, but don't free it - better performance this
             * way.
             */
            UNLOCKRESOURCE(hStringSeg, hModule);
        }
    }

    /*
     * Append a NULL.
     */
    if (cchBufferMax != 0) {
        lpBuffer[cch] = 0;
    }

    return cch;
}


/***************************************************************************\
* RtlLoadObjectFromDIBFile
*
* Loads a resource object from file.
*
* 05-Sep-1995 ChrisWil      Created.
\***************************************************************************/

#define BITMAPFILEHEADER_SIZE 14
#define MINHEADERS_SIZE       (BITMAPFILEHEADER_SIZE + sizeof(BITMAPCOREHEADER))

HANDLE RtlLoadObjectFromDIBFile(
    LPCWSTR lpszName,
    LPWSTR  type,
    DWORD   cxDesired,
    DWORD   cyDesired,
    UINT    LR_flags)
{
    FILEINFO fi = { NULL, NULL, NULL };
    HANDLE   hFile;
    HANDLE   hFileMap = NULL;
    HANDLE   hObj     = NULL;
    TCHAR    szFile[MAX_PATH];
    TCHAR    szFile2[MAX_PATH];
    LPWSTR   pszFileDummy;

    if (LR_flags & LR_ENVSUBST) {

        /*
         * Do any %% string substitutions.  We need this feature to handle
         * loading custom cursors and icons from the registry which uses
         * %SystemRoot% in the paths.  It also makes the shell's job
         * easier.
         */
        ExpandEnvironmentStrings(lpszName, szFile2, MAX_PATH);

    } else {

        lstrcpyn(szFile2, lpszName, MAX_PATH);
    }

    if (SearchPath(NULL,         // use default search locations
                   szFile2,      // file name to search for
                   NULL,         // already have file name extension
                   MAX_PATH,     // how big is that buffer, anyway?
                   szFile,       // stick fully qualified path name here
                   &pszFileDummy) == 0) {
        RIPERR0(ERROR_FILE_NOT_FOUND, RIP_VERBOSE, "");
        return NULL;
    }

    /*
     * Open File for reading.
     */
    hFile = CreateFileW(szFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        goto Done;

    /*
     * Create file-mapping for the file in question.
     */
    hFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (hFileMap == NULL)
        goto CloseDone;

    /*
     * Map the file into view.
     */
    fi.pFileMap = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);

    if (fi.pFileMap == NULL)
        goto CloseDone;

    fi.pFileEnd = fi.pFileMap + GetFileSize(hFile, NULL);
    fi.pFilePtr = fi.pFileMap;
    fi.pszName  = szFile;

    try {
        switch(PTR_TO_ID(type)) {
        case PTR_TO_ID(RT_BITMAP): {

            LPBITMAPFILEHEADER pBFH;
            UPBITMAPINFOHEADER upBIH;
            LPBYTE             lpBits;
            DWORD              cx;
            DWORD              cy;
            WORD               planes;
            WORD               bpp;
            DWORD              cbSizeImage = 0;
            DWORD              cbSizeFile;
            DWORD              cbSizeBits;

            /*
             * Set the BitmapFileHeader and BitmapInfoHeader pointers.
             */
            pBFH  = (LPBITMAPFILEHEADER)fi.pFileMap;
            upBIH = (UPBITMAPINFOHEADER)(fi.pFileMap + BITMAPFILEHEADER_SIZE);

            /*
             * Are we dealing with a bitmap file.
             */
            if (pBFH->bfType != BFT_BITMAP)
                break;

            /*
             * We need to check the filesize against the potential size of
             * the image.  Bad-Bitmaps would otherwise be able to slam us
             * if they lied about the size (and/or) the file is truncated.
             */
            if (upBIH->biSize == sizeof(BITMAPCOREHEADER)) {

                cx     = ((UPBITMAPCOREHEADER)upBIH)->bcWidth;
                cy     = ((UPBITMAPCOREHEADER)upBIH)->bcHeight;
                bpp    = ((UPBITMAPCOREHEADER)upBIH)->bcBitCount;
                planes = ((UPBITMAPCOREHEADER)upBIH)->bcPlanes;

            } else {

                cx     = upBIH->biWidth;
                cy     = upBIH->biHeight;
                bpp    = upBIH->biBitCount;
                planes = upBIH->biPlanes;

                if (upBIH->biSizeImage >= sizeof(BITMAPINFOHEADER)) {
                    cbSizeImage = upBIH->biSizeImage;
                }
            }

            cbSizeFile = (DWORD)(fi.pFileEnd - fi.pFileMap);
            cbSizeBits = BitmapSize(cx, cy, planes, bpp);

            if ((!cbSizeImage && ((cbSizeFile - MINHEADERS_SIZE) < cbSizeBits)) ||
            (cbSizeImage && ((cbSizeFile - MINHEADERS_SIZE) < cbSizeImage))) {

                break;
            }

            /*
             * Get the bits-offset in the file.
             */
            if ((pBFH->bfOffBits >= (sizeof(BITMAPFILEHEADER) + sizeof(BITMAPCOREHEADER))) &&
                (pBFH->bfOffBits <= (cbSizeFile - cbSizeImage))) {

                lpBits = ((LPBYTE)upBIH) + pBFH->bfOffBits - sizeof(BITMAPFILEHEADER);

            } else {

                lpBits = NULL;
            }

            /*
             * Convert the dib-on-file to a bitmap-handle.  This can
             * convert both CORE and INFO formats.
             */
            hObj = ConvertDIBBitmap(upBIH,
                                    cxDesired,
                                    cyDesired,
                                    LR_flags,
                                    NULL,
                                    &lpBits);  // use these bits!
        }
        break;

        case PTR_TO_ID(RT_CURSOR):
        case PTR_TO_ID(RT_ICON):
        {
            RTAG           *prtag;
            ICONFILEHEADER *pifh;

            /*
             * Is this a RIFF file?
             */
            prtag = (RTAG *)fi.pFileMap;

            if (prtag->ckID != FOURCC_RIFF) {

                NEWHEADER nh;

                pifh = (ICONFILEHEADER *)fi.pFileMap;

                /*
                 * BUG?: looks like we can load icons as cursors and cursors
                 * as icons.  Does this work?  Is this desired? (SAS)
                 */
                if ((pifh->iReserved != 0) ||
                    ((pifh->iResourceType != IMAGE_ICON) &&
                        (pifh->iResourceType != IMAGE_CURSOR)) ||
                    (pifh->cresIcons < 1))

                    break;

                nh.ResType  = ((type == RT_ICON) ? IMAGE_ICON : IMAGE_CURSOR);
                nh.ResCount = pifh->cresIcons;
                nh.Reserved = 0;

                /*
                 * Get the size of the it and meanwhile seek the file pointer
                 * to point at the DIB we want.  Files that have more than one
                 * icon/cursor are treated like a group.  In other words,
                 * each image is treated like an individual element in the res
                 * dir.  So we need to pick the best fit one...
                 */
                hObj = IconFromBestImage(pifh,
                                     &nh,
                                     cxDesired,
                                     cyDesired,
                                     LR_flags);
            } else {

                BOOL fAni;

                hObj = LoadCursorIconFromFileMap(&fi,
                                                 &type,
                                                 cxDesired,
                                                 cyDesired,
                                                 LR_flags,
                                                 &fAni);
                }
            }
        break;

        default:
            UserAssert(FALSE);
            break;
        } // switch
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        hObj = NULL;
    }
CloseDone:

    if (fi.pFileMap != NULL)
        UnmapViewOfFile(fi.pFileMap);

    if (hFileMap)
        CloseHandle(hFileMap);

    if (hFile && (hFile != INVALID_HANDLE_VALUE))
        CloseHandle(hFile);

Done:
#if DBG
    if (hObj == NULL) {
        RIPMSG1(RIP_WARNING,
                "RtlLoadObjectFromDIBFile: Couldn't read resource from %ws",
                lpszName);
    }
#endif

    return hObj;
}

/***************************************************************************\
* IconFromBestImage
*
* Creates HICON from best fitting image in the given file.
*
\***************************************************************************/

HICON IconFromBestImage(
    ICONFILEHEADER  *pifh,
    LPNEWHEADER      lpnhSrc,
    int              cxDesired,
    int              cyDesired,
    UINT             LR_flags)
{
    UINT             iImage;
    UINT             iImageBest;
    LPNEWHEADER      lpnhDst;
    LPRESDIR         lprd;
    LPBYTE           lpRes;
    DWORD            cbDIB;
    HICON            hIcon = NULL;
    IMAGEFILEHEADER *pimh;

    if (lpnhSrc->ResCount > 1) {

        /*
         * First, alloc dummy group resource.
         */
        lpnhDst = (LPNEWHEADER)UserLocalAlloc(0,
                sizeof(NEWHEADER) + (lpnhSrc->ResCount * sizeof(RESDIR)));

        if (lpnhDst == NULL)
            goto Done;

        *lpnhDst = *lpnhSrc;
        lprd = (LPRESDIR)(lpnhDst + 1);

        /*
         * Build up an image directory from the file's image header info.
         */

        for (pimh = pifh->imh, iImage=0;
             iImage < lpnhDst->ResCount;
             iImage++, lprd++, pimh++) {

            /*
             * Fill in RESDIR
             */
            lprd->Icon.Width  = pimh->cx;
            lprd->Icon.Height = pimh->cy;
            lprd->Icon.reserved = 0;
            lprd->BytesInRes = pimh->cbDIB;
            lprd->idIcon = (WORD)iImage; // Make fake ID:  the index of the image.

            if (lpnhDst->ResType == IMAGE_ICON) {
                /*
                 * 10/18/2000 - dwaynen
                 *
                 * For icons, this is really an ICONDIRENTRY (which has 
                 * wPlanes and wBitCount fields that overlap xHotSpot and
                 * yHotSpot!
                 */
                lprd->Icon.ColorCount = pimh->nColors;
                lprd->Planes     = pimh->xHotSpot;
                lprd->BitCount   = pimh->yHotSpot;
            } else {
                /*
                 * 10/18/2000 - dwaynen
                 *
                 * Hopefully, cursors will only have one image.  Otherwise,
                 * our selection logic is gonna be screwed up because we don't
                 * store the color bit depth!  I suppose we could dig out the
                 * actual bitmap header and find the info there.  Consider doing
                 * this if we ever want to support multi-resource cursors.
                 */
                lprd->Icon.ColorCount = 0;
                lprd->Planes     = 0;
                lprd->BitCount   = 0;
            }
        }

        /*
         * Find the best image in the group
         */
        iImageBest = LookupIconIdFromDirectoryEx((PBYTE)lpnhDst,
                                                 (lpnhDst->ResType == IMAGE_ICON),
                                                 cxDesired,
                                                 cyDesired,
                                                 LR_flags);
        /*
         * Get rid of fake group resource
         */
        UserLocalFree(lpnhDst);

    } else {
        iImageBest = 0;
    }

    /*
     * Point to selected image.
     */
    pimh  = &pifh->imh[iImageBest];
    cbDIB = pimh->cbDIB;

    /*
     * If we're creating a cursor, we have to whack in HOTSPOT in front
     * Regardless of which type we are making, we need to make sure
     * the resource is aligned.  Thus we always copy.
     */
    if (lpnhSrc->ResType == IMAGE_CURSOR)
        cbDIB += sizeof(POINTS);

    lpRes = (LPBYTE)UserLocalAlloc(0, cbDIB);
    if (lpRes == NULL)
        goto Done;

    if (lpnhSrc->ResType == IMAGE_CURSOR)
        lpRes += sizeof(POINTS);

    RtlCopyMemory(lpRes,
                  ((LPBYTE)pifh) + pimh->offsetDIB,
                  pimh->cbDIB);

    if (lpnhSrc->ResType == IMAGE_CURSOR) {

        lpRes -= sizeof(POINTS);
        ((LPPOINTS)lpRes)->x = pimh->xHotSpot;
        ((LPPOINTS)lpRes)->y = pimh->yHotSpot;
    }

    hIcon = CreateIconFromResourceEx(lpRes,
                                     cbDIB,
                                     (lpnhSrc->ResType == IMAGE_ICON),
                                     0x00030000, // was WIN32VER40
                                     cxDesired,
                                     cyDesired,
                                     LR_flags);

    UserLocalFree(lpRes);

Done:

    return hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\reader.c ===
/****************************** Module Header ******************************\
* Module Name: reader.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Implements support reader-mode routines for auto-scrolling and panning.
*
* History:
* 31-Jan-1997   vadimg    created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define TIMERID 1

__inline FReader2Dim(PREADERINFO prdr)
{
    return ((prdr->dwFlags & (RDRMODE_HORZ | RDRMODE_VERT)) ==
            (RDRMODE_HORZ | RDRMODE_VERT));
}
__inline FReaderVert(PREADERINFO prdr)
{
    return (prdr->dwFlags & RDRMODE_VERT);
}
__inline FReaderHorz(PREADERINFO prdr)
{
    return (prdr->dwFlags & RDRMODE_HORZ);
}
__inline FReaderDiag(PREADERINFO prdr)
{
    return (prdr->dwFlags & RDRMODE_DIAG);
}

/***************************************************************************\
* ReaderSetCursor
*
\***************************************************************************/

void ReaderSetCursor(PREADERINFO prdr, UINT uCursor)
{
    if (prdr->uCursor != uCursor) {
        NtUserSetCursor(LoadCursor(NULL, MAKEINTRESOURCE(uCursor)));
        prdr->uCursor = uCursor;
    }
}

/***************************************************************************\
* ReaderMouseMove
*
* Calculate dx and dy based on the flags passed in.  Provide visual
* feedback for the reader mode by setting the correct cursor.
*
* 2-Feb-1997   vadimg   created
\***************************************************************************/

void ReaderMouseMove(PWND pwnd, PREADERINFO prdr, LPARAM lParam)
{
    int dx = 0, dy = 0;
    LPRECT prc = KPRECT_TO_PRECT(&pwnd->rcWindow);
    UINT uCursor;
    POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

    _ClientToScreen(pwnd, &pt);

    if (FReaderVert(prdr)) {
        if (pt.y < prc->top) {
            dy = pt.y - prc->top;
        } else if (pt.y > prc->bottom) {
            dy = pt.y - prc->bottom;
        }
    }

    if (FReaderHorz(prdr)) {
        if (pt.x < prc->left) {
            dx = pt.x - prc->left;
        } else if (pt.x > prc->right) {
            dx = pt.x - prc->right;
        }
    }

    if (FReader2Dim(prdr)) {
        if (dx == 0 && dy == 0) {
            ReaderSetCursor(prdr, OCR_RDR2DIM);
            goto Exit;
        }
        if (!FReaderDiag(prdr)) {
            if (prdr->dy != 0) {
                if (abs(dx) > abs(prdr->dy)) {
                    dy = 0;
                } else {
                    dx = 0;
                }
            } else if (prdr->dx != 0) {
                if (abs(dy) > abs(prdr->dx)) {
                    dx = 0;
                } else {
                    dy = 0;
                }
            } else if (dy != 0) {
                dx = 0;
            }
        }
    } else if (FReaderVert(prdr) && dy == 0) {
        ReaderSetCursor(prdr, OCR_RDRVERT);
        goto Exit;
    } else if (FReaderHorz(prdr) && dx == 0) {
        ReaderSetCursor(prdr, OCR_RDRHORZ);
        goto Exit;
    }

    if (dx == 0) {
        uCursor = (dy > 0) ? OCR_RDRSOUTH : OCR_RDRNORTH;
    } else if (dx > 0) {
        if (dy == 0) {
            uCursor = OCR_RDREAST;
        } else {
            uCursor = (dy > 0) ? OCR_RDRSOUTHEAST : OCR_RDRNORTHEAST;
        }
    } else if (dx < 0) {
        if (dy == 0) {
            uCursor = OCR_RDRWEST;
        } else {
            uCursor = (dy > 0) ? OCR_RDRSOUTHWEST : OCR_RDRNORTHWEST;
        }
    }

    ReaderSetCursor(prdr, uCursor);

Exit:
    prdr->dx = dx;
    prdr->dy = dy;
}

/***************************************************************************\
* ReaderFeedback
*
* 2-Feb-1997   vadimg   created
\***************************************************************************/

void ReaderFeedback(PWND pwnd, PREADERINFO prdr)
{
    if (prdr->dx == 0 && prdr->dy == 0)
        return;

    if (prdr->pfnReaderModeProc(prdr->lParam, RDRCODE_SCROLL,
            prdr->dx, prdr->dy) == 0) {
        NtUserDestroyWindow(PtoH(pwnd));
    }
}

/***************************************************************************\
* ReaderWndProc
*
* 31-Jan-1997   vadimg   created
\***************************************************************************/

LRESULT CALLBACK ReaderWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc, hdcMem;
    HPEN hpen, hpenOld;
    HBRUSH hbrOld;
    HRGN hrgn;
    RECT rc;
    POINT pt;
    int nBitmap, cx, cy;
    PREADERINFO prdr;
    PWND pwnd;
    LPCREATESTRUCT pcs;
    PREADERMODE prdrm;
    BITMAP bmp;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    prdr = ((PREADERWND)pwnd)->prdr;

    switch (msg) {
    case WM_TIMER:
        ReaderFeedback(pwnd, prdr);
        return 0;

    case WM_MOUSEWHEEL:
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_XBUTTONUP:
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_XBUTTONDOWN:
    case WM_KEYDOWN:
        ReleaseCapture();
        return 0;

    case WM_MOUSEMOVE:
        ReaderMouseMove(pwnd, prdr, lParam);
        return 0;

    case WM_MBUTTONUP:
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        GetClientRect(hwnd, &rc);
        if (!PtInRect(&rc, pt)) {
            ReleaseCapture();
        }
        return 0;

    case WM_CAPTURECHANGED:
        NtUserDestroyWindow(hwnd);
        return 0;

    case WM_NCDESTROY:
        NtUserKillTimer(hwnd, TIMERID);

        prdr->pfnReaderModeProc(prdr->lParam, RDRCODE_END, 0, 0);

        if (prdr->hbm != NULL) {
            DeleteObject(prdr->hbm);
        }
        UserLocalFree(prdr);
        return 0;

    case WM_CREATE:
        if ((prdr = UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(READERINFO))) == NULL)
            return -1;

        pcs = (LPCREATESTRUCT)lParam;
        prdrm = (PREADERMODE)pcs->lpCreateParams;
        RtlCopyMemory(prdr, prdrm, sizeof(READERMODE));
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)prdr);

        if (prdr->pfnReaderModeProc == NULL) {
            return -1;
        }

        if (FReader2Dim(prdr)) {
            nBitmap = OBM_RDR2DIM;
        } else if (FReaderVert(prdr)) {
            nBitmap = OBM_RDRVERT;
        } else if (FReaderHorz(prdr)) {
            nBitmap = OBM_RDRHORZ;
        } else {
            return -1;
        }

        SetWindowLong(hwnd, GWL_EXSTYLE, WS_EX_TOOLWINDOW);
        SetWindowLong(hwnd, GWL_STYLE, WS_POPUP | WS_CLIPSIBLINGS);

        prdr->hbm = LoadBitmap(hmodUser, MAKEINTRESOURCE(nBitmap));
        if (prdr->hbm == NULL ||
                GetObject(prdr->hbm, sizeof(BITMAP), &bmp) == 0) {
            return -1;
        }

        if (prdr->pfnReaderModeProc(prdr->lParam, RDRCODE_START, 0, 0) == 0) {
            return -1;
        }

        prdr->dxBmp = bmp.bmWidth;
        prdr->dyBmp = bmp.bmHeight;

        cx = bmp.bmWidth + 1;
        cy = bmp.bmHeight + 1;

        GetCursorPos(&pt);
        pt.x -= cx/2;
        pt.y -= cy/2;

        if ((hrgn = CreateEllipticRgn(0, 0, cx, cy)) != NULL) {
            SetWindowRgn(hwnd, hrgn, FALSE);
        }

        NtUserSetWindowPos(hwnd, HWND_TOPMOST, pt.x, pt.y, cx, cy,
                SWP_SHOWWINDOW | SWP_NOACTIVATE);

        NtUserSetCapture(hwnd);
        NtUserSetFocus(hwnd);
        NtUserSetTimer(hwnd, TIMERID, 10, NULL);
        return 0;

    case WM_ERASEBKGND:
        hdc = (HDC)wParam;

        if ((hdcMem = CreateCompatibleDC(hdc)) == NULL)
            return FALSE;

        SelectObject(hdcMem, prdr->hbm);
        hpen = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
        hpenOld = (HPEN)SelectObject(hdc, hpen);
        hbrOld = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));

        BitBlt(hdc, 0, 0, prdr->dxBmp, prdr->dyBmp, hdcMem, 0, 0, SRCCOPY);
        Ellipse(hdc, 0, 0, prdr->dxBmp, prdr->dyBmp);

        SelectObject(hdc, hpenOld);
        SelectObject(hdc, hbrOld);

        DeleteObject(hpen);
        DeleteObject(hdcMem);
        return TRUE;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

/***************************************************************************\
* ReaderProcInternal
*
\***************************************************************************/

LONG ReaderProcInternal(LPARAM lParam, int nCode, int dx, int dy)
{
    DWORD dwDelay;
    UINT uMsg, uCode;
    int n, nAbs;

    if (nCode != RDRCODE_SCROLL)
        return TRUE;

    if (dy != 0) {
        uCode = SB_LINEUP;
        uMsg = WM_VSCROLL;
        n = dy;
    } else {
        uCode = SB_LINELEFT;
        uMsg = WM_HSCROLL;
        n = dx;
    }

    nAbs = abs(n);
    if (nAbs >= 120) {
        uCode += 2;
        dwDelay = 0;
    } else {
        dwDelay = 1000 - (nAbs / 2) * 15;
    }

    if (n > 0) {
        uCode += 1;
    }

    SendMessage((HWND)lParam, uMsg, MAKELONG(uCode, dwDelay), 0);
    UpdateWindow((HWND)lParam);
    return TRUE;
}

/***************************************************************************\
* EnterReaderMode
*
\***************************************************************************/

#define READERCLASS L"User32_ReaderMode"
ATOM gatomReaderMode = 0;

BOOL EnterReaderMode(PREADERMODE prdrm)
{
    WNDCLASSEX wce;

    if (GetCapture() != NULL)
        return FALSE;

    if (gatomReaderMode == 0) {
        wce.cbSize = sizeof(wce);
        wce.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
        wce.lpfnWndProc = ReaderWndProc;
        wce.cbClsExtra = 0;
        wce.cbWndExtra = sizeof(PREADERINFO);
        wce.hInstance = hmodUser;
        wce.hIcon = NULL;
        wce.hCursor = LoadCursor(NULL, IDC_ARROW);
        wce.hbrBackground = GetStockObject(WHITE_BRUSH);
        wce.lpszMenuName = NULL;
        wce.lpszClassName = READERCLASS;
        wce.hIconSm = NULL;

        if ((gatomReaderMode = RegisterClassExWOWW(&wce, NULL, FNID_DDE_BIT, 0)) == 0) {
            RIPMSG0(RIP_WARNING, "EnterReaderMode: failed to register ReaderMode");
            return 0;
        }
    }

    return (_CreateWindowEx(0, READERCLASS, NULL, 0, 0, 0, 0, 0,
            NULL, NULL, hmodUser, (PVOID)prdrm, 0) != NULL);
}

/***************************************************************************\
* FScrollEnabled
*
\***************************************************************************/

BOOL FScrollEnabled(PWND pwnd, BOOL fVert)
{
    PSBINFO pw;
    int nFlags;

    if (!TestWF(pwnd, fVert ? WFVPRESENT : WFHPRESENT))
        return FALSE;

    if ((pw = (PSBINFO)REBASEALWAYS(pwnd, pSBInfo)) == NULL)
        return FALSE;

    nFlags = fVert ? (pw->WSBflags >> 2) : pw->WSBflags;

    if ((nFlags & SB_DISABLE_MASK) == SB_DISABLE_MASK)
        return FALSE;

    return TRUE;
}

/***************************************************************************\
* EnterReaderModeHelper
*
\***************************************************************************/

BOOL EnterReaderModeHelper(HWND hwnd)
{
    PWND pwnd = ValidateHwnd(hwnd);
    READERMODE rdrm;

    rdrm.cbSize = sizeof(READERMODE);
    rdrm.pfnReaderModeProc = ReaderProcInternal;
    rdrm.lParam = (LPARAM)hwnd;
    rdrm.dwFlags = 0;

    if (FScrollEnabled(pwnd, TRUE)) {
        rdrm.dwFlags |= RDRMODE_VERT;
    }
    if (FScrollEnabled(pwnd, FALSE)) {
        rdrm.dwFlags |= RDRMODE_HORZ;
    }

    return EnterReaderMode(&rdrm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include $(WINCORE_PATH)\core.inc

MAJORCOMP=user
MINORCOMP=client

TARGETNAME=user32
TARGETNAMEP=user32p
TARGETTYPE=DYNLINK
DLLDEF=$(O)\$(TARGETNAME).def
DLLENTRY=UserClientDllInitialize

DELAYLOAD=advapi32.dll;msimg32.dll;powrprof.dll;winsta.dll
DLOAD_ERROR_HANDLER=kernel32

TARGETPATH=$(_OBJ_DIR)
PASS1_PUBLISH=\
    {$(DYNLINK_LIB)=$(SDK_LIB_DEST)\$(DYNLINK_LIBDIR)} \
    {$(DYNLINK_LIBP)=$(WINDOWS_LIB_DEST)\$(DYNLINK_LIBPDIR)}

TARGETLIBS=$(SDK_LIB_PATH)\kernl32p.lib     \
           $(WINDOWS_LIB_PATH)\gdi32p.lib   \
           $(SDK_LIB_PATH)\advapi32.lib     \
           $(SDK_LIB_PATH)\msimg32.lib      \
           $(SDK_LIB_PATH)\powrprof.lib     \
           $(SDK_LIB_PATH)\winsta.lib       \
           $(SDK_LIB_PATH)\uuid.lib
           

USE_NTDLL=1

LINKLIBS=$(WUMODE_PATH)\$(ALT_PROJECT)\$(O)\w32umode.lib \
         $(NTUSER_PATH)\rtl\client\$(ALT_PROJECT)\$(O)\userrtl.lib    \
         $(WINCORE_PATH)\rtl\client\$(O)\w32crtl.lib

COMMONTARGETS=$(DYNLINK_LIBP)

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -D_USER32_ -DUNICODE -DSURROGATE

LINKER_FLAGS=$(LINKER_FLAGS) /WX

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

NTTARGETFILE1=$(COMMONTARGETS)
NTTARGETFILE0=$(O)\dispcb.c             \
              $(O)\$(TARGETNAME).def

INCLUDES=..;                            \
         ..\..\inc;                     \
         ..\..\inc\$(ALT_PROJECT)\$(O); \
         $(WINCORE_PATH)\w32inc;        \
         $(WINCORE_PATH)\w32inc\$(O);   \
         $(NTGDI_PATH)\inc;             \
         $(BASE_INC_PATH);              \
         $(SHELL_INC_PATH)

NT_UP=0


DLLORDER=..\$(TARGETNAME).prf

SOURCES=..\res.rc     \
        ..\immhotky.c \
        ..\acons.c    \
        ..\btnctl.c   \
        ..\callback.c \
        ..\classc.c   \
        ..\cldib.c    \
        ..\clenum.c   \
        ..\clglobal.c \
        ..\clhook.c   \
        ..\client.c   \
        ..\clientw.c  \
        ..\clinit.c   \
        ..\clmenu.c   \
        ..\clmsg.c    \
        ..\clrect.c   \
        ..\clres.c    \
        ..\combo.c    \
        ..\combodir.c \
        ..\comboini.c \
        ..\connect.c  \
        ..\crecv.c    \
        ..\csendw.c   \
        ..\csrstubs.c \
        ..\drawtext.c \
        ..\ddemlcli.c \
        ..\ddemlwp.c  \
        ..\ddetrack.c \
        $(O)\dispcb.c \
        ..\dlgbegin.c \
        ..\dlgend.c   \
        ..\dlgmgr.c   \
        ..\dlgmgr2.c  \
        ..\dlgmgrc.c  \
        ..\dmmnem.c   \
        ..\draw.c     \
        ..\edecrare.c \
        ..\editec.c   \
        ..\editml.c   \
        ..\editsl.c   \
        ..\edmlrare.c \
        ..\edmlonce.c \
        ..\edslrare.c \
        ..\extract.c  \
        ..\fntsweep.c \
        ..\getsetc.c  \
        ..\handles.c  \
        ..\hdata.c    \
        ..\help.c     \
        ..\hsz.c      \
        ..\instance.c \
        ..\keybrdc.c  \
        ..\lb1.c      \
        ..\lboxctl1.c \
        ..\lboxctl2.c \
        ..\lboxctl3.c \
        ..\lboxmult.c \
        ..\lboxrare.c \
        ..\lboxvar.c  \
        ..\mdimenu.c  \
        ..\mdiwin.c   \
        ..\menuc.c    \
        ..\menuddc.c  \
        ..\mmcl.c     \
        ..\mngrayc.c  \
        ..\monitor.c  \
        ..\msgbox.c   \
        ..\ntstubs.c  \
        ..\oemxlate.c \
        ..\queuec.c   \
        ..\random.c   \
        ..\reader.c   \
        ..\reason.c   \
        ..\register.c \
        ..\rtlinit.c  \
        ..\rtlres.c   \
        ..\sbapi.c    \
        ..\statctl.c  \
        ..\stdptcl.c  \
        ..\strings.c  \
        ..\util.c     \
        ..\winable.c  \
        ..\winmgrc.c  \
        ..\wow.c      \
        ..\wsprintf.c \
        ..\wstrings.c \
        ..\xact.c     \
        ..\clienta.c  \
        ..\csenda.c   \
        ..\fareast.c  \
        ..\imectl.c

UMTYPE=windows

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\util.c ===
/****************************** Module Header ******************************\
* Module Name: util.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager general utility functions (and some JANUS stuff).
*
* Created: 11/3/91 Sanford Staab
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* AddLink
*
* Description:
* Adds an advise link to the conversation's info.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL
AddLink(
    PCONV_INFO pcoi,
    GATOM gaItem,
    WORD wFmt,
    WORD wType)
{
    PADVISE_LINK aLinkNew;
    int cLinks;
    LATOM la;
    PCL_INSTANCE_INFO pcii;

    /*
     * if the link already exists, update its flags, otherwise create a
     * new one.
     */

    aLinkNew = pcoi->aLinks;
    cLinks = pcoi->cLinks;
    la = GlobalToLocalAtom(gaItem);     // aLinkNew copy
    while (cLinks) {
        if (aLinkNew->laItem == la && aLinkNew->wFmt == wFmt) {
            aLinkNew->wType = wType;
            aLinkNew->state = 0;
            DeleteAtom(la);
            return TRUE;
        }
        aLinkNew++;
        cLinks--;
    }

    if (pcoi->aLinks == NULL) {
        aLinkNew = (PADVISE_LINK)DDEMLAlloc(sizeof(ADVISE_LINK));
    } else {
        aLinkNew = (PADVISE_LINK)DDEMLReAlloc(pcoi->aLinks,
                sizeof(ADVISE_LINK) * (pcoi->cLinks + 1));
    }
    if (aLinkNew == NULL) {
        SetLastDDEMLError(pcoi->pcii, DMLERR_MEMORY_ERROR);
        DeleteAtom(la);
        return FALSE;
    }
    pcoi->aLinks = aLinkNew;
    aLinkNew += pcoi->cLinks;
    pcoi->cLinks++;

    aLinkNew->laItem = la;
    aLinkNew->wFmt = wFmt;
    aLinkNew->wType = wType;
    aLinkNew->state = 0;

    if (!(pcoi->state & ST_CLIENT)) {
        /*
         * Add count for this link
         */
        pcii = pcoi->pcii;

        for (aLinkNew->pLinkCount = pcii->pLinkCount;
                aLinkNew->pLinkCount;
                    aLinkNew->pLinkCount = aLinkNew->pLinkCount->next) {
            if (aLinkNew->pLinkCount->laTopic == pcoi->laTopic &&
                    aLinkNew->pLinkCount->gaItem == gaItem &&
                    aLinkNew->pLinkCount->wFmt == wFmt) {
                aLinkNew->pLinkCount->Total++;
                return(TRUE);
            }
        }

        /*
         * Not found - add an entry
         */
        aLinkNew->pLinkCount = (PLINK_COUNT)DDEMLAlloc(sizeof(LINK_COUNT));
        if (aLinkNew->pLinkCount == NULL) {
            SetLastDDEMLError(pcoi->pcii, DMLERR_MEMORY_ERROR);
            return FALSE;
        }
        aLinkNew->pLinkCount->next = pcii->pLinkCount;
        pcii->pLinkCount = aLinkNew->pLinkCount;

        aLinkNew->pLinkCount->laTopic = IncLocalAtomCount(pcoi->laTopic); // LinkCount copy
        aLinkNew->pLinkCount->gaItem = IncGlobalAtomCount(gaItem); // LinkCount copy
        aLinkNew->pLinkCount->laItem = IncLocalAtomCount(la); // LinkCount copy

        aLinkNew->pLinkCount->wFmt = wFmt;
        aLinkNew->pLinkCount->Total = 1;
        // doesn't matter: aLinkNew->pLinkCount->Count = 0;
    }

    return TRUE;
}



/*
 * The LinkCount array is a list of all active links grouped by topic
 * and item.  The Total field is the number of active links total for
 * that particular topic/item pair for the entire instance.  The count
 * field is used to properly set up the links to go field of the XTYP_ADVREQ
 * callback.  Whenever links are added or removed, DeleteLinkCount or
 * AddLink need to be called to keep thses counts correct.
 */
VOID
DeleteLinkCount(
    PCL_INSTANCE_INFO pcii,
    PLINK_COUNT pLinkCountDelete)
{
    PLINK_COUNT pLinkCount, pLinkCountPrev;

    if (--pLinkCountDelete->Total != 0) {
        return;
    }

    pLinkCountPrev = NULL;
    pLinkCount     = pcii->pLinkCount;
    while (pLinkCount) {

        if (pLinkCount == pLinkCountDelete) {
            GlobalDeleteAtom(pLinkCount->gaItem);
            DeleteAtom(pLinkCount->laItem);
            DeleteAtom(pLinkCount->laTopic);
            if (pLinkCountPrev == NULL) {
                pcii->pLinkCount = pLinkCount->next;
            } else {
                pLinkCountPrev->next = pLinkCount->next;
            }
            DDEMLFree(pLinkCount);
            return;
        }

        pLinkCountPrev = pLinkCount;
        pLinkCount = pLinkCount->next;
    }
}

/***************************************************************************\
* GetTokenHandle
*
* Get handle of token for current thread.
\***************************************************************************/
BOOL
GetTokenHandle(
    PHANDLE pTokenHandle)
{
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                         TRUE,
                         pTokenHandle)) {
        if (GetLastError() == ERROR_NO_TOKEN) {
            /*
             * This means we are not impersonating anybody. Instead, let's
             * get the token out of the process.
             */
            if (!OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                  pTokenHandle)) {
                return FALSE;
            }
        } else {
            return FALSE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* GetUserSid
*
*  Well, actually it gets a pointer to a newly allocated TOKEN_USER,
*  which contains a SID, somewhere.
*  Caller must remember to free it when it's been used.
*
* History:
*   10-16-98 Chienho      stole from spooler
*
\***************************************************************************/
BOOL
GetUserSid(
    PTOKEN_USER *ppTokenUser)
{
    HANDLE      TokenHandle;
    PTOKEN_USER pTokenUser = NULL;
    DWORD       cbTokenUser = 0;
    DWORD       cbNeeded;
    BOOL        bRet = FALSE;

    if (!GetTokenHandle(&TokenHandle)) {
        return FALSE;
    }

    bRet = GetTokenInformation(TokenHandle,
                               TokenUser,
                               pTokenUser,
                               cbTokenUser,
                               &cbNeeded);

    /*
     * We've passed a NULL pointer and 0 for the amount of memory
     * allocated.  We expect to fail with bRet = FALSE and
     * GetLastError = ERROR_INSUFFICIENT_BUFFER. If we do not
     * have these conditions we will return FALSE.
     */

    if (!bRet && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        pTokenUser = UserLocalAlloc(HEAP_ZERO_MEMORY, cbNeeded);
        if (pTokenUser == NULL) {
            goto GetUserSidDone;
        }

        cbTokenUser = cbNeeded;

        bRet = GetTokenInformation(TokenHandle,
                                   TokenUser,
                                   pTokenUser,
                                   cbTokenUser,
                                   &cbNeeded);
    } else {
        /*
         * Any other case -- return FALSE.
         */
        bRet = FALSE;
    }

GetUserSidDone:
    if (bRet == TRUE) {
        *ppTokenUser = pTokenUser;
    } else if (pTokenUser != NULL) {
        UserLocalFree(pTokenUser);
    }

    CloseHandle(TokenHandle);

    return bRet;
}

BOOL
GetCurrentProcessName(
    WCHAR *pszProcessName,
    int cch)
{
    BOOL bRetVal;

    if (GetModuleFileName(NULL, pszProcessName, MAX_PATH)) {
        WCHAR *pwcs = wcsrchr(pszProcessName, TEXT('\\'));
        if (pwcs != NULL) {
            ++pwcs;
            lstrcpy(pszProcessName, pwcs);
        }
        bRetVal = TRUE;
    } else {
        LoadString(hmodUser, STR_UNKNOWN, pszProcessName, cch);
        bRetVal = FALSE;
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\winable.c ===
/****************************** Module Header ******************************\
* Module Name: winable.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains
*
* History:
* 20-Feb-1992 DarrinM   Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
*
* GetWindowInfo()
* PRIVATE
*
* Gets information about a window in one self-consistent big block.
*
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, GetWindowInfo, HWND, hwnd, PWINDOWINFO, pwi)
BOOL WINAPI
GetWindowInfo(HWND hwnd, PWINDOWINFO pwi)
{
    PWND pwnd;
    UINT cBorders;
    PCLS pclsT;

    if (pwi->cbSize != sizeof(WINDOWINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "WINDOWINFO.cbSize %d is wrong", pwi->cbSize);
    }
    /*
     * Validate the window
     */
    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL) {
        return FALSE;
    }

    try {
        // Window rect
        pwi->rcWindow = pwnd->rcWindow;

        // Client rect
        pwi->rcClient = pwnd->rcClient;

        // Style
        pwi->dwStyle = pwnd->style;
        pwi->dwExStyle = pwnd->ExStyle;
        pwi->dwWindowStatus = 0;
        if (TestWF(pwnd, WFFRAMEON))
            pwi->dwWindowStatus |= WS_ACTIVECAPTION;

        // Borders
        cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
        pwi->cxWindowBorders = cBorders * SYSMET(CXBORDER);
        pwi->cyWindowBorders = cBorders * SYSMET(CYBORDER);

        // Type
        pclsT = (PCLS)REBASEALWAYS(pwnd, pcls);
        pwi->atomWindowType = pclsT->atomNVClassName;

        // Version
        if (TestWF(pwnd, WFWIN50COMPAT)) {
            pwi->wCreatorVersion = VER50;
        } else if (TestWF(pwnd, WFWIN40COMPAT)) {
            pwi->wCreatorVersion = VER40;
        } else if (TestWF(pwnd, WFWIN31COMPAT)) {
            pwi->wCreatorVersion = VER31;
        } else {
            pwi->wCreatorVersion = VER30;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                RIP_WARNING,
                "Window %x no longer valid",
                hwnd);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\usercli.h ===
/****************************** Module Header ******************************\
* Module Name: usercli.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used exclusively by the User
* client-side DLL.
*
* History:
* 04-27-91 DarrinM      Created from PROTO.H, MACRO.H and STRTABLE.H
\***************************************************************************/

#ifndef _USERCLI_
#define _USERCLI_

#define OEMRESOURCE 1

#include <windows.h>
#include <winnls32.h>

#include <w32gdip.h>
#include <w32err.h>
#include <ddeml.h>
#include "ddemlp.h"
#include "winuserp.h"
#include "w32wow64.h"
#include "winuserk.h"
#include <dde.h>
#include <ddetrack.h>
#include "kbd.h"
#include <wowuserp.h>
#include "immstruc.h"
#include "immuser.h"
#include <winbasep.h>

#include "user.h"
#include "callproc.h"


#if DBG
/*
 * This structure allows apps to set RIP flags locally to their process.
 * This is mostly intended for naughty/penetration apps.
 *
 * dwTouchedMask is used to determine which fields have been locally set.
 * For those that have not been, we'll return the global/kernel values.
 */
#define USERDBG_TAGSTOUCHED     0x1
#define USERDBG_PIDTOUCHED      0x2
#define USERDBG_FLAGSTOUCHED    0x4
typedef struct _USERDBGGLOBALS {
    DWORD adwDBGTAGFlags[DBGTAG_Max + 1];
    DWORD dwRIPPID;
    DWORD dwRIPFlags;
    DWORD dwTouchedMask;
} USERDBGGLOBALS, *PUSERDBGGLOBALS;
#endif

/*
 * This prototype is needed in client\globals.h which is included unintentionally
 * from usersrv.h
 */
typedef LRESULT (APIENTRY *CFNSCSENDMESSAGE)(HWND, UINT, WPARAM, LPARAM,
        ULONG_PTR, DWORD, BOOL);

/***************************************************************************\
* Typedefs and Macros
*
* Here are defined all types and macros that are shared across the User's
* client-side code modules.  Types and macros that are unique to a single
* module should be defined at the head of that module, not in this file.
*
\***************************************************************************/

#define MIRRORED_HDC(hdc)     (GetLayout(hdc) & LAYOUT_RTL)
#define MIRRORED_HWND(hwnd)   (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)

#ifdef LAZY_CLASS_INIT
BOOL UserRegisterControls(
    VOID);
BOOL UserRegisterDDEML(
    VOID);
extern BOOL gbClassesRegistered;

__inline VOID LazyInitClasses(
    VOID)
{
    if (!gbClassesRegistered) {
        gbClassesRegistered = TRUE;
        UserRegisterControls();
        UserRegisterDDEML();
    }
}
#endif

#if DBG

__inline void DebugUserGlobalUnlock(HANDLE h)
{
    UserAssert(
            "GlobalUnlock on bad handle" &&
            !(GlobalFlags(h) == GMEM_INVALID_HANDLE));

    GlobalUnlock((HANDLE) h);
}

/*
 * Bug 262144 - joejo
 *
 * Changed function to accept a pointer to the handle so we
 * can trash the handle and return it as trashed.
 *
 * Added a local handle variable to accept the return from GlobalFree
 * so we can return it as expected.
 *
 * Trash incoming handle freed so we can track any invalid access on
 * it after it's been free'd.
 */
__inline HANDLE DebugUserGlobalFree(HANDLE* ph)
{
    HANDLE th;

    UserAssert(
            "GlobalFree on bad handle" &&
            !(GlobalFlags(*ph) == GMEM_INVALID_HANDLE));

    th = GlobalFree(*ph);
#if defined(_WIN64)
    *ph = (HANDLE)(PVOID)0xBAADF00DBAADF00D;
#else
    *ph = (HANDLE)(PVOID)0xBAADF00D;
#endif
    return th;
}

__inline HANDLE DebugUserGlobalAlloc(UINT uFlags, SIZE_T dwBytes)
{
    HANDLE h = GlobalAlloc(uFlags, dwBytes);

    /*
     * Assert that FreeDDElParam and _ClientFreeDDEHandle assumption is correct.
     */
    if (h != NULL) {
        UserAssert(h > (HANDLE)0xFFFF);
    }

    return h;
}

#define USERGLOBALUNLOCK(h)             DebugUserGlobalUnlock((HANDLE)(h))
#define UserGlobalFree(h)               DebugUserGlobalFree((HANDLE*)(&h))
#define UserGlobalAlloc(flags, size)    DebugUserGlobalAlloc(flags, size)

#else

#define USERGLOBALUNLOCK(h)             GlobalUnlock((HANDLE)(h))
#define UserGlobalFree(h)               GlobalFree((HANDLE)(h))
#define UserGlobalAlloc(flags, size)    GlobalAlloc(flags, size)
#endif

#define USERGLOBALLOCK(h, p)   p = GlobalLock((HANDLE)(h))
#define UserGlobalReAlloc(pmem, cnt, flags) GlobalReAlloc(pmem,cnt,flags)
#define UserGlobalSize(pmem)                GlobalSize(pmem)
#define WOWGLOBALFREE(pmem)                 GlobalFree(pmem)

#define RESERVED_MSG_BITS   (0xFFFE0000)



/*
 * A macro for testing bits in the message bit-arrays.  Messages in the
 * the bit arrays must be processed
 */
#define FDEFWINDOWMSG(msg, procname) \
    ((msg <= (gSharedInfo.procname.maxMsgs)) && \
            ((gSharedInfo.procname.abMsgs)[msg / 8] & (1 << (msg & 7))))
#define FWINDOWMSG(msg, fnid) \
    ((msg <= (gSharedInfo.awmControl[fnid - FNID_START].maxMsgs)) && \
            ((gSharedInfo.awmControl[fnid - FNID_START].abMsgs)[msg / 8] & (1 << (msg & 7))))

#define CsSendMessage(hwnd, msg, wParam, lParam, xParam, pfn, bAnsi) \
        (((msg) >= WM_USER) ? \
            NtUserMessageCall(hwnd, msg, wParam, lParam, xParam, pfn, bAnsi) : \
            gapfnScSendMessage[MessageTable[msg].iFunction](hwnd, msg, wParam, lParam, xParam, pfn, bAnsi))

#define GetWindowProcess(hwnd) NtUserQueryWindow(hwnd, WindowProcess)
#define GETPROCESSID() (NtCurrentTeb()->ClientId.UniqueProcess)
#define GETTHREADID()  (NtCurrentTeb()->ClientId.UniqueThread)

/*
 * Macro to mask off uniqueness bits for WOW handles
 */
#define SAMEWOWHANDLE(h1, h2)  ((BOOL)!(((ULONG_PTR)(h1) ^ (ULONG_PTR)(h2)) & 0xffff))
#define DIFFWOWHANDLE(h1, h2)  (!SAMEWOWHANDLE(h1, h2))

/*
 * For callbacks to the client - for msg and hook thunks, callback addresses
 * are passed as addresses, not function indexes as they are from client to
 * server.
 */
typedef INT_PTR (WINAPI *GENERICPROC)();

#define CALLPROC(p) ((GENERICPROC)p)
#define PACTCTXT(pwnd) (pwnd ? pwnd->pActCtx : NULL)

extern PFNWOWDLGPROCEX      pfnWowDlgProcEx;
extern PFNWOWWNDPROCEX      pfnWowWndProcEx;

BOOL UserCallDlgProcCheckWow(PACTIVATION_CONTEXT pActCtx, DLGPROC pfn,
        HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, PVOID pww, INT_PTR * pret);
LRESULT UserCallWinProcCheckWow(PACTIVATION_CONTEXT pActCtx, WNDPROC pfn,
        HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, PVOID pww, BOOL fEnableLiteHooks);


/***************************************************************************\
* IsMsgOverride
*
* Returns if a message should be sent to USERAPIHOOK OverrideWndProc()
* hooks.  The message should only be sent if its "index" is within the range
* specified by the hook and its "bit" is on.  It is very important to
* actually check guah.cbMsgMask instead of sizeof(gbLiteHookMsg) because the
* hook may have a smaller MsgMask in which case anything past the end fails.
*
* History:
* 27-Apr-2000  jstall     Created
\***************************************************************************/

__inline BOOL IsMsgOverride(UINT msg, MSGMASK * pmm)
{
    UINT idxMajor = msg / 8;
    if ((pmm->rgb != NULL) && (idxMajor < pmm->cb)) {
        return (pmm->rgb[idxMajor] & (1 << (msg & 7)));
    }

    return FALSE;
}



#define RevalidateHwnd(hwnd)    ((PWND)HMValidateHandleNoSecure(hwnd, TYPE_WINDOW))

#define VALIDATEHMENU(hmenu)        ((PMENU)HMValidateHandle(hmenu, TYPE_MENU))
#define VALIDATEHMONITOR(hmonitor)  ((PMONITOR)HMValidateSharedHandle(hmonitor, TYPE_MONITOR))


/*
 * REBASE macros take kernel desktop addresses and convert them into
 * user addresses.
 *
 * REBASEALWAYS converts a kernel address contained in an object
 * REBASEPWND casts REBASEALWAYS to a PWND
 * REBASE only converts if the address is in kernel space.  Also works for NULL
 * REBASEPTR converts a random kernel address
 */

#define REBASEALWAYS(p, elem) ((PVOID)((KERNEL_ULONG_PTR)(p) + ((KERNEL_ULONG_PTR)(p)->elem - (KERNEL_ULONG_PTR)(p)->head.pSelf)))
#define REBASEPTR(obj, p) ((PVOID)((KERNEL_ULONG_PTR)(p) - ((KERNEL_ULONG_PTR)(obj)->head.pSelf - (KERNEL_ULONG_PTR)(obj))))

#define REBASE(p, elem) ((KERNEL_ULONG_PTR)((p)->elem) <= (KERNEL_ULONG_PTR)gHighestUserAddress ? \
        ((PVOID)(KERNEL_ULONG_PTR)(p)->elem) : REBASEALWAYS(p, elem))
#define REBASEPWND(p, elem) ((PWND)REBASE(p, elem))

#ifndef USEREXTS

PTHREADINFO PtiCurrent(VOID);

/*
 * Window Proc Window Validation macro. This macro assumes
 * that pwnd and hwnd are existing variables pointing to the window.
 * Checking the BUTTON is for Mavis Beacon.
 */

#define VALIDATECLASSANDSIZE(pwnd, inFNID)                                      \
    switch ((pwnd)->fnid) {                                                     \
    case inFNID:                                                                \
        break;                                                                  \
                                                                                \
    case 0:                                                                     \
        if ((pwnd->cbwndExtra + sizeof(WND)) < (DWORD)(CBFNID(inFNID))) {       \
            RIPMSG3(RIP_ERROR,                                                  \
                   "(%#p %lX) needs at least (%ld) window words for this proc", \
                    pwnd, pwnd->cbwndExtra,                                     \
                    (DWORD)(CBFNID(inFNID)) - sizeof(WND));                     \
            return 0;                                                           \
        }                                                                       \
                                                                                \
        if (inFNID == FNID_BUTTON && *((KPULONG_PTR)(pwnd + 1))) {              \
                                                                                \
            RIPMSG3(RIP_WARNING, "Window (%#p) fnid = %lX overrides "           \
                "the extra pointer with %#p\n",                                 \
                pwnd, inFNID, *((KPULONG_PTR)(pwnd + 1)));                      \
                                                                                \
            NtUserSetWindowLongPtr(hwnd, 0, 0, FALSE);                          \
        }                                                                       \
                                                                                \
        NtUserSetWindowFNID(hwnd, inFNID);                                      \
        break;                                                                  \
                                                                                \
    case (inFNID | FNID_CLEANEDUP_BIT):                                         \
    case (inFNID | FNID_DELETED_BIT):                                           \
    case (inFNID | FNID_STATUS_BITS):                                           \
        return 0;                                                               \
                                                                                \
    default:                                                                    \
        RIPMSG3(RIP_WARNING,                                                    \
              "Window (%#p) not of correct class; fnid = %lX not %lX",          \
              (pwnd), (DWORD)((pwnd)->fnid), (DWORD)(inFNID));                  \
        return 0;                                                               \
    }

/*
 * This macro initializes the lookaside entry for a control.  It assumes
 * that pwnd and hwnd are existing variables pointing to the control's
 * windows and that fInit exists as a BOOL initialization flag.
 */
#define INITCONTROLLOOKASIDE(plaType, type, pwnditem, count)                \
    if (!*((KPULONG_PTR)(pwnd + 1))) {                                      \
        P ## type pType;                                                    \
        if (fInit) {                                                        \
            if (!NT_SUCCESS(InitLookaside(plaType, sizeof(type), count))) { \
                NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);              \
                NtUserDestroyWindow(hwnd);                                  \
                return FALSE;                                               \
            }                                                               \
            fInit = FALSE;                                                  \
        }                                                                   \
        if ((pType = (P ## type)AllocLookasideEntry(plaType))) {            \
            NtUserSetWindowLongPtr(hwnd, 0, (LONG_PTR)pType, FALSE);        \
            Lock(&(pType->pwnditem), pwnd);                                 \
        } else {                                                            \
            NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);                  \
            NtUserDestroyWindow(hwnd);                                      \
            return FALSE;                                                   \
        }                                                                   \
    }

#endif

#define ISREMOTESESSION()   (NtCurrentPeb()->SessionId != USER_SHARED_DATA->ActiveConsoleId)


/*
 * Bitmap related macroes.
 */
#define SetBestStretchMode(hdc, planes, bpp) \
    SetStretchBltMode(hdc, (((planes) * (bpp)) == 1 ? BLACKONWHITE : COLORONCOLOR))

#define BitmapSize(cx, cy, planes, bits) \
        (BitmapWidth(cx, bits) * (cy) * (planes))

#define BitmapWidth(cx, bpp)  (((((cx)*(bpp)) + 31) & ~31) >> 3)

#define RGBX(rgb)  RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb))

/*
 * Typedefs used for capturing string arguments to be passed
 * to the kernel.
 */
typedef struct _IN_STRING {
    UNICODE_STRING strCapture;
    PUNICODE_STRING pstr;
    BOOL fAllocated;
} IN_STRING, *PIN_STRING;

typedef struct _LARGE_IN_STRING {
    LARGE_UNICODE_STRING strCapture;
    PLARGE_UNICODE_STRING pstr;
    BOOL fAllocated;
} LARGE_IN_STRING, *PLARGE_IN_STRING;


/*
 * Lookaside definitions
 */
typedef struct _LOOKASIDE {
    PVOID LookasideBase;
    PVOID LookasideBounds;
    ZONE_HEADER LookasideZone;
    DWORD EntrySize;
#if DBG
    ULONG AllocHiWater;
    ULONG AllocCalls;
    ULONG AllocSlowCalls;
    ULONG DelCalls;
    ULONG DelSlowCalls;
#endif
} LOOKASIDE, *PLOOKASIDE;

NTSTATUS InitLookaside(PLOOKASIDE pla, DWORD cbEntry, DWORD cEntries);
PVOID AllocLookasideEntry(PLOOKASIDE pla);
VOID FreeLookasideEntry(PLOOKASIDE pla, PVOID pEntry);

/***************************************************************************\
*
* Thread and structure locking routines - we'll just define these to do
* nothing for now until we figure out what needs to be done
*
\***************************************************************************/

#undef ThreadLock
#undef ThreadLockAlways
#undef ThreadLockWithPti
#undef ThreadLockAlwaysWithPti
#undef ThreadUnlock
#undef Lock
#undef Unlock
#define CheckLock(pobj)
#define ThreadLock(pobj, ptl) DBG_UNREFERENCED_LOCAL_VARIABLE(*ptl)
#define ThreadLockAlways(pobj, ptl) DBG_UNREFERENCED_LOCAL_VARIABLE(*ptl)
#define ThreadLockWithPti(pti, pobj, ptl) DBG_UNREFERENCED_LOCAL_VARIABLE(*ptl)
#define ThreadLockAlwaysWithPti(pti, pobj, ptl) DBG_UNREFERENCED_LOCAL_VARIABLE(*ptl)
#define ThreadUnlock(ptl) (ptl)
#define Lock(ppobj, pobj) (*ppobj = pobj)
#define Unlock(ppobj) (*ppobj = NULL)

#if !defined(_USERRTL_) && !defined(USEREXTS)
typedef struct _TL {
    int iBogus;
} TL;
#endif

/***************************************************************************\
*
* Button Controls
*
\***************************************************************************/

/*
 *  Note: The button data structures are now found in user.h because the
 *        kernel needs to handle a special case of SetWindowWord on index
 *        0L to change the state of the button.
 */

#define BUTTONSTATE(pbutn)   (pbutn->buttonState)

#define BST_CHECKMASK       0x0003
#define BST_INCLICK         0x0010
#define BST_CAPTURED        0x0020
#define BST_MOUSE           0x0040
#define BST_DONTCLICK       0x0080
#define BST_INBMCLICK       0x0100

#define PBF_PUSHABLE     0x0001
#define PBF_DEFAULT      0x0002

/*
 * BNDrawText codes
 */
#define DBT_TEXT    0x0001
#define DBT_FOCUS   0x0002


/***************************************************************************\
*
* ComboBox
*
\***************************************************************************/

/*
 * ID numbers (hMenu) for the child controls in the combo box
 */
#define CBLISTBOXID 1000
#define CBEDITID    1001
#define CBBUTTONID  1002

/*
 * For CBOX.c. BoxType field, we define the following combo box styles. These
 * numbers are the same as the CBS_ style codes as defined in windows.h.
 */
#define SDROPPABLE      CBS_DROPDOWN
#define SEDITABLE       CBS_SIMPLE


#define SSIMPLE         SEDITABLE
#define SDROPDOWNLIST   SDROPPABLE
#define SDROPDOWN       (SDROPPABLE | SEDITABLE)


/*
 * CBOX.OwnerDraw & LBIV.OwnerDraw types
 */
#define OWNERDRAWFIXED 1
#define OWNERDRAWVAR   2

#define UPPERCASE   1
#define LOWERCASE   2

#define CaretCreate(plb)    ((plb)->fCaret = TRUE)

/*
 * This macro is used to isolate the combo box style bits.  Ie if it the combo
 * box is simple, atomic, dropdown, or a dropdown listbox.
 */
#define COMBOBOXSTYLE(style)   ((LOBYTE(style)) & 3)

#define IsComboVisible(pcbox) (!pcbox->fNoRedraw && IsVisible(pcbox->spwnd))

/*
 * Note that I depend on the fact that these CBN_ defines are the same as
 * their listbox counterparts.  These defines are found in windows.h.
 * #define CBN_ERRSPACE  (-1)
 * #define CBN_SELCHANGE 1
 * #define CBN_DBLCLK    2
 */


/***************************************************************************\
*
* Edit Control Types/Macros
*
\***************************************************************************/

/* Window extra bytes - we need at least this much space for compatibility */
#define CBEDITEXTRA 6

/*
 * NOTE: Text handle is sized as multiple of this constant
 *       (should be power of 2).
 */
#define CCHALLOCEXTRA   0x20

/* Maximum width in pixels for a line/rectangle */

#define MAXPIXELWIDTH   30000

#define MAXCLIPENDPOS   32764

/* Limit multiline edit controls to at most 1024 characters on a single line.
 * We will force a wrap if the user exceeds this limit.
 */

#define MAXLINELENGTH   1024

/*
 * Allow an initial maximum of 30000 characters in all edit controls since
 * some apps will run into unsigned problems otherwise.  If apps know about
 * the 64K limit, they can set the limit themselves.
 */
#define MAXTEXT         30000

/*
 * Key modifiers which have been pressed.  Code in KeyDownHandler and
 * CharHandler depend on these exact values.
 */
#define NONEDOWN   0 /* Neither shift nor control down */
#define CTRLDOWN   1 /* Control key only down */
#define SHFTDOWN   2 /* Shift key only down */
#define SHCTDOWN   3 /* Shift and control keys down = CTRLDOWN + SHFTDOWN */
#define NOMODIFY   4 /* Neither shift nor control down */


#define CALLWORDBREAKPROC(proc, pText, iStart, cch, iAction)                \
    (IsWOWProc(proc) ?                                                      \
        (* pfnWowEditNextWord)(pText, iStart, cch, iAction, PtrToUlong(proc)) :  \
        (* proc)(pText, iStart, cch, iAction))

/*
 * Types of undo supported in this ped
 */
#define UNDO_NONE   0  /* We can't undo the last operation. */
#define UNDO_INSERT 1  /* We can undo the user's insertion of characters */
#define UNDO_DELETE 2  /* We can undo the user's deletion of characters */

typedef struct tagUNDO {
    UINT    undoType;          /* Current type of undo we support */
    PBYTE   hDeletedText;      /* Pointer to text which has been deleted (for
                                  undo) -- note, the memory is allocated as fixed
                                */
    ICH     ichDeleted;        /* Starting index from which text was deleted */
    ICH     cchDeleted;        /* Count of deleted characters in buffer */
    ICH     ichInsStart;       /* Starting index from which text was
                                  inserted */
    ICH     ichInsEnd;         /* Ending index of inserted text */
} UNDO, *PUNDO;

#define Pundo(ped)             ((PUNDO)&(ped)->undoType)

/*
 * Length of the buffer for ASCII character width caching: for characters
 * 0x00 to 0xff (field charWidthBuffer in PED structure below).
 * As the upper half of the cache was not used by almost anyone and fixing
 * it's usage required a lot of conversion, we decided to get rid of it
 * MCostea #174031
 */
#define CHAR_WIDTH_BUFFER_LENGTH 128

typedef struct tagED {
    HANDLE  hText;                      /* Block of text we are editing */
    ICH     cchAlloc;                   /* Number of chars we have allocated for hText*/
    ICH     cchTextMax;                 /* Max number bytes allowed in edit control*/
    ICH     cch;                        /* Current number of bytes of actual text*/
    ICH     cLines;                     /* Number of lines of text */

    ICH     ichMinSel;                  /* Selection extent.  MinSel is first selected
                                         * char
                                         */
    ICH     ichMaxSel;                  /* MaxSel is first unselected character */
    ICH     ichCaret;                   /* Caret location. Caret is on left side of
                                         * char
                                         */
    ICH     iCaretLine;                 /* The line the caret is on. So that if word
                                         * wrapping, we can tell if the caret is at end
                                         * of a line of at beginning of next line...
                                         */
    ICH     ichScreenStart;             /* Index of left most character displayed on
                                         * screen for sl ec and index of top most line
                                         * for multiline edit controls
                                         */
    ICH     ichLinesOnScreen;           /* Number of lines we can display on screen */
    UINT    xOffset;                    /* x (horizontal) scroll position in pixels
                                         * (for multiline text horizontal scroll bar)
                                         */
    UINT    charPasswordChar;           /* If non null, display this character instead
                                         * of the real text. So that we can implement
                                         * hidden text fields.
                                         */
    int     cPasswordCharWidth;         /* Width of password char */

    HWND    hwnd;                       /* Window for this edit control */
    PWND    pwnd;                       /* Pointer to window */
    RECT    rcFmt;                      /* Client rectangle */
    HWND    hwndParent;                 /* Parent of this edit control window */

                                        /* These vars allow us to automatically scroll
                                         * when the user holds the mouse at the bottom
                                         * of the multiline edit control window.
                                         */
    POINT   ptPrevMouse;                /* Previous point for the mouse for system
                                         * timer.
                                         */
    UINT    prevKeys;                   /* Previous key state for the mouse */


    UINT     fSingle       : 1;         /* Single line edit control? (or multiline) */
    UINT     fNoRedraw     : 1;         /* Redraw in response to a change? */
    UINT     fMouseDown    : 1;         /* Is mouse button down? when moving mouse */
    UINT     fFocus        : 1;         /* Does ec have the focus ? */
    UINT     fDirty        : 1;         /* Modify flag for the edit control */
    UINT     fDisabled     : 1;         /* Window disabled? */
    UINT     fNonPropFont  : 1;         /* Fixed width font? */
    UINT     fNonPropDBCS  : 1;         /* Non-Propotional DBCS font */
    UINT     fBorder       : 1;         /* Draw a border? */
    UINT     fAutoVScroll  : 1;         /* Automatically scroll vertically */
    UINT     fAutoHScroll  : 1;         /* Automatically scroll horizontally */
    UINT     fNoHideSel    : 1;         /* Hide sel when we lose focus? */
    UINT     fDBCS         : 1;         /* Are we using DBCS font set for editing? */
    UINT     fFmtLines     : 1;         /* For multiline only. Do we insert CR CR LF at
                                         * word wrap breaks?
                                         */
    UINT     fWrap         : 1;         /* Do int  wrapping? */
    UINT     fCalcLines    : 1;         /* Recalc ped->chLines array? (recalc line
                                         * breaks?)
                                         */
    UINT     fEatNextChar  : 1;         /* Hack for ALT-NUMPAD stuff with combo boxes.
                                         * If numlock is up, we want to eat the next
                                         * character generated by the keyboard driver
                                         * if user enter num pad ascii value...
                                         */
    UINT     fStripCRCRLF  : 1;         /* CRCRLFs have been added to text. Strip them
                                         * before doing any internal edit control
                                         * stuff
                                         */
    UINT     fInDialogBox  : 1;         /* True if the ml edit control is in a dialog
                                         * box and we have to specially treat TABS and
                                         * ENTER
                                         */
    UINT     fReadOnly     : 1;         /* Is this a read only edit control? Only
                                         * allow scrolling, selecting and copying.
                                         */
    UINT     fCaretHidden  : 1;         /* This indicates whether the caret is
                                         * currently hidden because the width or height
                                         * of the edit control is too small to show it.
                                         */
    UINT     fTrueType     : 1;         /* Is the current font TrueType? */
    UINT     fAnsi         : 1;         /* is the edit control Ansi or unicode */
    UINT     fWin31Compat  : 1;         /* TRUE if created by Windows 3.1 app */
    UINT     f40Compat     : 1;         /* TRUE if created by Windows 4.0 app */
    UINT     fFlatBorder   : 1;         /* Do we have to draw this baby ourself? */
    UINT     fSawRButtonDown : 1;
    UINT     fInitialized  : 1;         /* If any more bits are needed, then   */
    UINT     fSwapRoOnUp   : 1;         /* Swap reading order on next keyup    */
    UINT     fAllowRTL     : 1;         /* Allow RTL processing                */
    UINT     fDisplayCtrl  : 1;         /* Display unicode control characters  */
    UINT     fRtoLReading  : 1;         /* Right to left reading order         */

    BOOL    fInsertCompChr  :1;         /* means WM_IME_COMPOSITION:CS_INSERTCHAR will come */
    BOOL    fReplaceCompChr :1;         /* means need to replace current composition str. */
    BOOL    fNoMoveCaret    :1;         /* means stick to current caret pos. */
    BOOL    fResultProcess  :1;         /* means now processing result. */
    BOOL    fKorea          :1;         /* for Korea */
    BOOL    fInReconversion :1;         /* In reconversion mode */
    BOOL    fLShift         :1;         /* L-Shift pressed with Ctrl */

    WORD    wImeStatus;                 /* current IME status */

    WORD    cbChar;                     /* count of bytes in the char size (1 or 2 if unicode) */
    LPICH   chLines;                    /* index of the start of each line */

    UINT    format;                     /* Left, center, or right justify multiline
                                         * text.
                                         */
    EDITWORDBREAKPROCA lpfnNextWord;    /* use CALLWORDBREAKPROC macro to call */

                                        /* Next word function */
    int     maxPixelWidth;              /* WASICH Width (in pixels) of longest line */

    UNDO;                               /* Undo buffer */

    HANDLE  hFont;                      /* Handle to the font for this edit control.
                                         * Null if system font.
                                         */
    int     aveCharWidth;               /* Ave width of a character in the hFont */
    int     lineHeight;                 /* Height of a line in the hFont */
    int     charOverhang;               /* Overhang associated with the hFont */
    int     cxSysCharWidth;             /* System font ave width */
    int     cySysCharHeight;            /* System font height */
    HWND    listboxHwnd;                /* ListBox hwnd. Non null if we are a combo box */
    LPINT   pTabStops;                  /* Points to an array of tab stops; First
                                         * element contains the number of elements in
                                         * the array
                                         */
    LPINT   charWidthBuffer;
    BYTE    charSet;                    /* Character set for currently selected font
                                         * needed for all versions
                                         */
    UINT    wMaxNegA;                   /* The biggest negative A width, */
    UINT    wMaxNegAcharPos;            /* and how many characters it can span accross */
    UINT    wMaxNegC;                   /* The biggest negative C width, */
    UINT    wMaxNegCcharPos;            /* and how many characters it can span accross */
    UINT    wLeftMargin;                /* Left margin width in pixels. */
    UINT    wRightMargin;               /* Right margin width in pixels. */

    ICH     ichStartMinSel;
    ICH     ichStartMaxSel;

    PLPKEDITCALLOUT pLpkEditCallout;
    HBITMAP hCaretBitmap;               /* Current caret bitmap handle */
    INT     iCaretOffset;               /* Offset in pixels (for LPK use) */

    HANDLE  hInstance;                  /* for WOW */
    UCHAR   seed;                       /* used to encode and decode password text */
    BOOLEAN fEncoded;                   /* is the text currently encoded */
    int     iLockLevel;                 /* number of times the text has been locked */

    BYTE    DBCSVector[MAX_LEADBYTES];  /* DBCS vector table */
    HIMC    hImcPrev;                   /* place to save hImc if we disable IME */
    POINT   ptScreenBounding;           /* top left corner of edit window in screen */
} ED, *PED, **PPED;

typedef struct tagEDITWND {
    WND wnd;
    PED ped;
} EDITWND, * KPTR_MODIFIER PEDITWND;

#ifdef FAREAST_CHARSET_BITS
#error FAREAST_CHARSET_BITS should not be defined
#endif
#define FAREAST_CHARSET_BITS   (FS_JISJAPAN | FS_CHINESESIMP | FS_WANSUNG | FS_CHINESETRAD)


// Language pack specific context menu IDs

#define ID_CNTX_RTL         0x00008000L
#define ID_CNTX_DISPLAYCTRL 0x00008001L
#define ID_CNTX_INSERTCTRL  0x00008013L
#define ID_CNTX_ZWJ         0x00008002L
#define ID_CNTX_ZWNJ        0x00008003L
#define ID_CNTX_LRM         0x00008004L
#define ID_CNTX_RLM         0x00008005L
#define ID_CNTX_LRE         0x00008006L
#define ID_CNTX_RLE         0x00008007L
#define ID_CNTX_LRO         0x00008008L
#define ID_CNTX_RLO         0x00008009L
#define ID_CNTX_PDF         0x0000800AL
#define ID_CNTX_NADS        0x0000800BL
#define ID_CNTX_NODS        0x0000800CL
#define ID_CNTX_ASS         0x0000800DL
#define ID_CNTX_ISS         0x0000800EL
#define ID_CNTX_AAFS        0x0000800FL
#define ID_CNTX_IAFS        0x00008010L
#define ID_CNTX_RS          0x00008011L
#define ID_CNTX_US          0x00008012L

/*
 * The following structure is used to store a selection block; In Multiline
 * edit controls, "StPos" and "EndPos" fields contain the Starting and Ending
 * lines of the block. In Single line edit controls, "StPos" and "EndPos"
 * contain the Starting and Ending character positions of the block;
 */
typedef struct tagBLOCK {
    ICH StPos;
    ICH EndPos;
}  BLOCK, *LPBLOCK;

/*  The following structure is used to store complete information about a
 *  a strip of text.
 */
typedef  struct {
    LPSTR   lpString;
    ICH     ichString;
    ICH     nCount;
    int     XStartPos;
}  STRIPINFO;
typedef  STRIPINFO FAR *LPSTRIPINFO;


/***************************************************************************\
*
* ListBox
*
\***************************************************************************/

#define IsLBoxVisible(plb)  (plb->fRedraw && IsVisible(plb->spwnd))

/*
 * Number of list box items we allocated whenever we grow the list box
 * structures.
 */
#define CITEMSALLOC     32

/* Return Values */
#define EQ        0
#define PREFIX    1
#define LT        2
#define GT        3

#define         SINGLESEL       0
#define         MULTIPLESEL     1
#define         EXTENDEDSEL     2

#define LBI_ADD     0x0004

/*
 *  The various bits of wFileDetails field are used as mentioned below:
 *      0x0001    Should the file name be in upper case.
 *      0x0002    Should the file size be shown.
 *      0x0004    Date stamp of the file to be shown ?
 *      0x0008    Time stamp of the file to be shown ?
 *      0x0010    The dos attributes of the file ?
 *      0x0020    In DlgDirSelectEx(), along with file name
 *                all other details also will be returned
 *
 */

#define LBUP_RELEASECAPTURE 0x0001
#define LBUP_RESETSELECTION 0x0002
#define LBUP_NOTIFY         0x0004
#define LBUP_SUCCESS        0x0008
#define LBUP_SELCHANGE      0x0010

/*
 * rgpch is set up as follows:  First there are cMac 2 byte pointers to the
 * start of the strings in hStrings or if ownerdraw, it is 4 bytes of data
 * supplied by the app and hStrings is not used.  Then if multiselection
 * listboxes, there are cMac 1 byte selection state bytes (one for each item
 * in the list box).  If variable height owner draw, there will be cMac 1 byte
 * height bytes (once again, one for each item in the list box.).
 *
 * CHANGES DONE BY SANKAR:
 *      The selection byte in rgpch is divided into two nibbles. The lower
 * nibble is the selection state (1 => Selected; 0 => de-selected)
 * and higher nibble is the display state(1 => Hilited and 0 => de-hilited).
 * You must be wondering why on earth we should store this selection state and
 * the display state seperately.Well! The reason is as follows:
 *      While Ctrl+Dragging or Shift+Ctrl+Dragging, the user can adjust the
 * selection before the mouse button is up. If the user enlarges a range and
 * and before the button is up if he shrinks the range, then the old selection
 * state has to be preserved for the individual items that do not fall in the
 * range finally.
 *      Please note that the display state and the selection state for an item
 * will be the same except when the user is dragging his mouse. When the mouse
 * is dragged, only the display state is updated so that the range is hilited
 * or de-hilited) but the selection state is preserved. Only when the button
 * goes up, for all the individual items in the range, the selection state is
 * made the same as the display state.
 */

typedef struct tagLBItem {
    LONG offsz;
    ULONG_PTR itemData;
} LBItem, *lpLBItem;

typedef struct tagLBODItem {
    ULONG_PTR itemData;
} LBODItem, *lpLBODItem;

void LBEvent(PLBIV, UINT, int);

/***************************************************************************\
*
* Static Controls
*
\***************************************************************************/

typedef struct tagSTAT {
    PWND spwnd;
    union {
        HANDLE hFont;
        BOOL   fDeleteIt;
    };
    HANDLE hImage;
    UINT cicur;
    UINT iicur;
    UINT fPaintKbdCuesOnly : 1;
} STAT, *PSTAT;

typedef struct tagSTATWND {
    WND wnd;
    PSTAT pstat;
} STATWND, * KPTR_MODIFIER PSTATWND;


typedef struct tagCURSORRESOURCE {
    WORD xHotspot;
    WORD yHotspot;
    BITMAPINFOHEADER bih;
} CURSORRESOURCE, *PCURSORRESOURCE;


#define NextWordBoundary(p)     ((PBYTE)(p) + ((ULONG_PTR)(p) & 1))
#define NextDWordBoundary(p)    ((PBYTE)(p) + ((ULONG_PTR)(-(LONG_PTR)(p)) & 3))

// DDEML stub prototypes

DWORD  Event(PEVENT_PACKET pep);
PVOID CsValidateInstance(HANDLE hInst);

/***************************************************************************\
* WOW Prototypes, Typedefs and Defines
*
* WOW registers resource callback functions so it can load 16 bit resources
* transparently for Win32.  At resource load time, these WOW functions are
* called.
*
\***************************************************************************/

BOOL  APIENTRY _FreeResource(HANDLE hResData, HINSTANCE hModule);
LPSTR APIENTRY _LockResource(HANDLE hResData, HINSTANCE hModule);
BOOL  APIENTRY _UnlockResource(HANDLE hResData, HINSTANCE hModule);

#define FINDRESOURCEA(hModule,lpName,lpType)         ((*(pfnFindResourceExA))(hModule, lpType, lpName, 0))
#define FINDRESOURCEW(hModule,lpName,lpType)         ((*(pfnFindResourceExW))(hModule, lpType, lpName, 0))
#define FINDRESOURCEEXA(hModule,lpName,lpType,wLang) ((*(pfnFindResourceExA))(hModule, lpType, lpName, wLang))
#define FINDRESOURCEEXW(hModule,lpName,lpType,wLang) ((*(pfnFindResourceExW))(hModule, lpType, lpName, wLang))
#define LOADRESOURCE(hModule,hResInfo)               ((*(pfnLoadResource))(hModule, hResInfo))
#define LOCKRESOURCE(hResData, hModule)              ((*(pfnLockResource))(hResData, hModule))
#define UNLOCKRESOURCE(hResData, hModule)            ((*(pfnUnlockResource))(hResData, hModule))
#define FREERESOURCE(hResData, hModule)              ((*(pfnFreeResource))(hResData, hModule))
#define SIZEOFRESOURCE(hModule,hResInfo)             ((*(pfnSizeofResource))(hModule, hResInfo))
#define GETEXPWINVER(hModule)                        ((*(pfnGetExpWinVer))((hModule)?(hModule):GetModuleHandle(NULL)))

/*
 * Pointers to unaligned-bits.  These are necessary for handling
 * bitmap-info's loaded from file.
 */
typedef BITMAPINFO       UNALIGNED *UPBITMAPINFO;
typedef BITMAPINFOHEADER UNALIGNED *UPBITMAPINFOHEADER;
typedef BITMAPCOREHEADER UNALIGNED *UPBITMAPCOREHEADER;

#define CCHFILEMAX      MAX_PATH

HLOCAL WINAPI DispatchLocalAlloc(
    UINT uFlags,
    UINT uBytes,
    HANDLE hInstance);

HLOCAL WINAPI DispatchLocalReAlloc(
    HLOCAL hMem,
    UINT uBytes,
    UINT uFlags,
    HANDLE hInstance,
    PVOID* ppv);

LPVOID WINAPI DispatchLocalLock(
    HLOCAL hMem,
    HANDLE hInstance);

BOOL WINAPI DispatchLocalUnlock(
    HLOCAL hMem,
    HANDLE hInstance);

UINT WINAPI DispatchLocalSize(
    HLOCAL hMem,
    HANDLE hInstance);

HLOCAL WINAPI DispatchLocalFree(
    HLOCAL hMem,
    HANDLE hInstance);

#define UserLocalAlloc(uFlag,uBytes) RtlAllocateHeap(pUserHeap, uFlag, uBytes)
#define UserLocalReAlloc(p, uBytes, uFlags) RtlReAllocateHeap(pUserHeap, uFlags, p, uBytes)
#define UserLocalFree(p)    RtlFreeHeap(pUserHeap, 0, (LPSTR)(p))
#define UserLocalSize(p)    RtlSizeHeap(pUserHeap, 0, (LPSTR)(p))

LONG TabTextOut(HDC hdc, int x, int y, LPCWSTR lpstring, int nCount,
        int nTabPositions, CONST INT *lpTabPositions, int iTabOrigin,
        BOOL fDrawTheText, int iCharset);
LONG UserLpkTabbedTextOut(HDC hdc, int x, int y, LPCWSTR lpstring,
        int nCount, int nTabPositions, CONST INT *lpTabPositions,
        int iTabOrigin, BOOL fDrawTheText, int cxCharWidth,
        int cyCharHeight, int iCharset);
void UserLpkPSMTextOut(HDC hdc, int xLeft, int yTop,
        LPWSTR lpsz, int cch, DWORD dwFlags);
void PSMTextOut(HDC hdc, int xLeft, int yTop, LPWSTR lpsz, int cch, DWORD dwFlags);
void ECUpdateFormat(PED ped, DWORD dwStyle, DWORD dwExStyle);

int  LoadStringOrError(HANDLE, UINT, LPTSTR, int, WORD);
int  RtlGetIdFromDirectory(PBYTE, BOOL, int, int, DWORD, PDWORD);
BOOL RtlCaptureAnsiString(PIN_STRING, LPCSTR, BOOL);
BOOL RtlCaptureLargeAnsiString(PLARGE_IN_STRING, LPCSTR, BOOL);
LONG BroadcastSystemMessageWorker(
    DWORD dwFlags,
    LPDWORD lpdwRecipients,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam,
    PBSMINFO pBSMInfo,
    BOOL fAnsi);

PWND FASTCALL ValidateHwnd(HWND hwnd);
PWND FASTCALL ValidateHwndNoRip(HWND hwnd);

PSTR ECLock(PED ped);
void ECUnlock(PED ped);
BOOL ECNcCreate(PED, PWND, LPCREATESTRUCT);
void ECInvalidateClient(PED ped, BOOL fErase);
BOOL ECCreate(PED ped, LONG windowStyle);
void ECWord(PED, ICH, BOOL, ICH*, ICH*);
ICH  ECFindTab(LPSTR, ICH);
void ECNcDestroyHandler(PWND, PED);
BOOL ECSetText(PED, LPSTR);
void ECSetPasswordChar(PED, UINT);
ICH  ECCchInWidth(PED, HDC, LPSTR, ICH, int, BOOL);
void ECEmptyUndo(PUNDO);
void ECSaveUndo(PUNDO pundoFrom, PUNDO pundoTo, BOOL fClear);
BOOL ECInsertText(PED, LPSTR, ICH*);
ICH  ECDeleteText(PED);
void ECResetTextInfo(PED ped);
void ECNotifyParent(PED, int);
void ECSetEditClip(PED, HDC, BOOL);
HDC  ECGetEditDC(PED, BOOL);
void ECReleaseEditDC(PED, HDC, BOOL);
ICH  ECGetText(PED, ICH, LPSTR, BOOL);
void ECSetFont(PED, HFONT, BOOL);
void ECSetMargin(PED, UINT, long, BOOL);
ICH  ECCopy(PED);
BOOL ECCalcChangeSelection(PED, ICH, ICH, LPBLOCK, LPBLOCK);
void ECFindXORblks(LPBLOCK, LPBLOCK, LPBLOCK, LPBLOCK);
BOOL ECIsCharNumeric(PED ped, DWORD keyPress);

/*
 * Combine two DBCS WM_CHAR messages to
 * a single WORD value.
 */
WORD DbcsCombine(HWND, WORD);
#define CrackCombinedDbcsLB(c)  ((BYTE)(c))
#define CrackCombinedDbcsTB(c)  ((c) >> 8)

ICH  ECAdjustIch(PED, LPSTR, ICH);
ICH  ECAdjustIchNext(PED, LPSTR, ICH);
int  ECGetDBCSVector(PED, HDC, BYTE);
BOOL ECIsDBCSLeadByte(PED, BYTE);
LPSTR ECAnsiNext(PED, LPSTR);
LPSTR ECAnsiPrev(PED, LPSTR, LPSTR);
ICH  ECPrevIch(PED, LPSTR, ICH);
ICH  ECNextIch(PED, LPSTR, ICH);

void ECEnableDisableIME( PED ped );
void ECImmSetCompositionFont( PED ped );
void ECImmSetCompositionWindow( PED ped, LONG, LONG );
void  ECSetCaretHandler(PED ped);
void  ECInitInsert(PED ped, HKL hkl);
LRESULT ECImeComposition(PED ped, WPARAM wParam, LPARAM lParam);
LRESULT EcImeRequestHandler(PED, WPARAM, LPARAM);  // NT 5.0
BOOL HanjaKeyHandler(PED ped);  // Korean Support

void ECInOutReconversionMode(PED ped, BOOL fIn);


// ECTabTheTextOut draw codes
#define ECT_CALC        0
#define ECT_NORMAL      1
#define ECT_SELECTED    2

#define ECGetCaretWidth() (gpsi->uCaretWidth)

UINT ECTabTheTextOut(HDC, int, int, int, int,
                     LPSTR, int, ICH, PED, int, BOOL, LPSTRIPINFO);
HBRUSH ECGetControlBrush(PED, HDC, LONG);
HBRUSH ECGetBrush(PED ped, HDC hdc);
int  ECGetModKeys(int);
VOID ECSize(PED, LPRECT, BOOL);

ICH  MLInsertText(PED, LPSTR, ICH, BOOL);
ICH  MLDeleteText(PED);
BOOL MLEnsureCaretVisible(PED);
VOID MLDrawText(PED, HDC, ICH, ICH, BOOL);
VOID MLBuildchLines(PED, ICH, int, BOOL, PLONG, PLONG);
VOID MLShiftchLines(PED, ICH, int);
VOID MLSetCaretPosition(PED,HDC);
VOID MLIchToXYPos(PED, HDC, ICH, BOOL, LPPOINT);
int  MLIchToLine(PED, ICH);
VOID MLMouseMotion(PED, UINT, UINT, LPPOINT);
ICH  MLLine(PED, ICH);
VOID MLStripCrCrLf(PED);
BOOL MLUndo(PED);
LRESULT MLEditWndProc(HWND, PED, UINT, WPARAM, LPARAM);
VOID MLChar(PED, DWORD, int);
VOID MLSetSelection(PED, BOOL, ICH, ICH);
LONG MLCreate(PED, LPCREATESTRUCT);
BOOL MLInsertCrCrLf(PED);
VOID MLSetHandle(PED, HANDLE);
LONG MLGetLine(PED, ICH, ICH, LPSTR);
ICH  MLLineIndex(PED, ICH);
VOID MLSize(PED, BOOL);
VOID MLChangeSelection(PED, HDC, ICH, ICH);
BOOL MLSetTabStops(PED, int, LPINT);
LONG MLScroll(PED, BOOL, int, int, BOOL);
VOID MLUpdateiCaretLine(PED ped);
ICH  MLLineLength(PED, ICH);
VOID MLReplaceSel(PED, LPSTR);

VOID SLReplaceSel(PED, LPSTR);
BOOL SLUndo(PED);
VOID SLSetCaretPosition(PED, HDC);
int  SLIchToLeftXPos(PED, HDC, ICH);
VOID SLChangeSelection(PED, HDC, ICH, ICH);
VOID SLDrawLine(PED, HDC, int, int, ICH, int, BOOL);
VOID SLDrawText(PED, HDC, ICH);
BOOL SLScrollText(PED, HDC);
VOID SLSetSelection(PED,ICH, ICH);
ICH  SLInsertText(PED, LPSTR, ICH);
VOID SLChar(PED, DWORD);
LONG SLCreate(PED, LPCREATESTRUCT);
LRESULT SLEditWndProc(HWND, PED, UINT, WPARAM, LPARAM);
LRESULT EditWndProc(PWND, UINT, WPARAM, LPARAM);

#define GETAPPVER() GetClientInfo()->dwExpWinVer
#define THREAD_HKL()      (KHKL_TO_HKL(GetClientInfo()->hKL))
#define GETCLIENTTHREADINFO()   (CLIENTTHREADINFO *)KPVOID_TO_PVOID(GetClientInfo()->pClientThreadInfo)
#define CLIENTTHREADINFO(pci)   (CLIENTTHREADINFO *)KPVOID_TO_PVOID((pci)->pClientThreadInfo)


#define ISDELIMETERA(ch) ((ch == ' ') || (ch == '\t'))
#define ISDELIMETERW(ch) ((ch == L' ') || (ch == L'\t'))

#define AWCOMPARECHAR(ped,pbyte,awchar) (ped->fAnsi ? (*(PUCHAR)(pbyte) == (UCHAR)(awchar)) : (*(LPWSTR)(pbyte) == (WCHAR)(awchar)))

/* Menu that comes up when you press the right mouse button on an edit
 * control
 */
#define ID_EC_PROPERTY_MENU      1

#define IDD_MDI_ACTIVATE         9

#ifndef _USERK_
/*
 * String IDs
 */
#define STR_ERROR                        0x00000002L
#define STR_MOREWINDOWS                  0x0000000DL
#define STR_NOMEMBITMAP                  0x0000000EL

/*
 * IME specific context menu string
 */
#define STR_IMEOPEN                 700
#define STR_IMECLOSE                701
#define STR_SOFTKBDOPEN             702
#define STR_SOFTKBDCLOSE            703
#define STR_RECONVERTSTRING         705

/*
 * Shutdown logging strings.
 */
#define STR_SHUTDOWN_SHUTDOWN       706
#define STR_SHUTDOWN_POWEROFF       707
#define STR_SHUTDOWN_REBOOT         708

/*
 * Misc. strings.
 */
#define STR_UNKNOWN                 709

/*
 * ExitWindowsEx warning dlg strings
 */
#define IDS_EXITWINDOWS_TITLE           710
#define IDS_SHUTDOWN_REMOTE             711
#define IDS_SHUTDOWN_REMOTE_OTHERUSERS  712
#define IDS_SHUTDOWN_OTHERUSERS         713
#define IDS_RESTART_OTHERUSERS          714

#endif  // !_USERK_


BOOL InitClientDrawing();

/***************************************************************************\
* Function Prototypes
*
* NOTE: Only prototypes for GLOBAL (across module) functions should be put
* here.  Prototypes for functions that are global to a single module should
* be put at the head of that module.
*
\***************************************************************************/

int InternalScrollWindowEx(HWND hwnd, int dx, int dy, CONST RECT *prcScroll,
        CONST RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate,
        UINT dwFlags, DWORD dwTime);

BOOL IsMetaFile(HDC hdc);

BOOL DrawDiagonal(HDC hdc, LPRECT lprc, HBRUSH hbrTL, HBRUSH hbrBR, UINT flags);
BOOL FillTriangle(HDC hdc, LPRECT lprc, HBRUSH hbr, UINT flags);

BOOL   _ClientFreeLibrary(HANDLE hmod);
DWORD  _ClientGetListboxString(PWND pwnd, UINT msg, WPARAM wParam, LPSTR lParam,
        ULONG_PTR xParam, PROC xpfn);
LPHLP  HFill(LPCSTR lpszHelp, DWORD ulCommand, ULONG_PTR ulData);
BOOL SetVideoTimeout(DWORD dwVideoTimeout);

DWORD _GetWindowLong(PWND pwnd, int index, BOOL bAnsi);
#ifdef _WIN64
ULONG_PTR _GetWindowLongPtr(PWND pwnd, int index, BOOL bAnsi);
#else
#define _GetWindowLongPtr   _GetWindowLong
#endif
WORD  _GetWindowWord(PWND pwnd, int index);

HWND InternalFindWindowExA(HWND hwndParent, HWND hwndChild, LPCSTR pClassName,
                          LPCSTR pWindowName, DWORD   dwFlag);
HWND InternalFindWindowExW(HWND hwndParent, HWND hwndChild, LPCTSTR pClassName,
                          LPCTSTR pWindowName, DWORD   dwFlag);


/*
 * Message thunks.
 */
#define fnCOPYDATA                      NtUserMessageCall
#define fnDDEINIT                       NtUserMessageCall
#define fnDWORD                         NtUserMessageCall
#define fnNCDESTROY                     NtUserMessageCall
#define fnDWORDOPTINLPMSG               NtUserMessageCall
#define fnGETTEXTLENGTHS                NtUserMessageCall
#define fnGETDBCSTEXTLENGTHS            NtUserMessageCall
#define fnINLPCREATESTRUCT              NtUserMessageCall
#define fnINLPCOMPAREITEMSTRUCT         NtUserMessageCall
#define fnINLPDELETEITEMSTRUCT          NtUserMessageCall
#define fnINLPDRAWITEMSTRUCT            NtUserMessageCall
#define fnINLPHELPINFOSTRUCT            NtUserMessageCall
#define fnINLPHLPSTRUCT                 NtUserMessageCall
#define fnINLPWINDOWPOS                 NtUserMessageCall
#define fnINOUTDRAG                     NtUserMessageCall
#define fnINOUTLPMEASUREITEMSTRUCT      NtUserMessageCall
#define fnINOUTLPPOINT5                 NtUserMessageCall
#define fnINOUTLPRECT                   NtUserMessageCall
#define fnINOUTLPSCROLLINFO             NtUserMessageCall
#define fnINOUTLPWINDOWPOS              NtUserMessageCall
#define fnINOUTNCCALCSIZE               NtUserMessageCall
#define fnINOUTNEXTMENU                 NtUserMessageCall
#define fnINOUTSTYLECHANGE              NtUserMessageCall
#define fnOPTOUTLPDWORDOPTOUTLPDWORD    NtUserMessageCall
#define fnOUTLPRECT                     NtUserMessageCall
#define fnPOPTINLPUINT                  NtUserMessageCall
#define fnPOUTLPINT                     NtUserMessageCall
#define fnSENTDDEMSG                    NtUserMessageCall
#define fnOUTDWORDINDWORD               NtUserMessageCall
#define fnINOUTMENUGETOBJECT            NtUserMessageCall
#define fnINCBOXSTRING                  NtUserMessageCall
#define fnINCNTOUTSTRING                NtUserMessageCall
#define fnINCNTOUTSTRINGNULL            NtUserMessageCall
#define fnINLBOXSTRING                  NtUserMessageCall
#define fnINLPMDICREATESTRUCT           NtUserMessageCall
#define fnINSTRING                      NtUserMessageCall
#define fnINSTRINGNULL                  NtUserMessageCall
#define fnINWPARAMCHAR                  NtUserMessageCall
#define fnOUTCBOXSTRING                 NtUserMessageCall
#define fnOUTLBOXSTRING                 NtUserMessageCall
#define fnOUTSTRING                     NtUserMessageCall
#define fnKERNELONLY                    NtUserMessageCall
#define fnOUTLPCOMBOBOXINFO             NtUserMessageCall
#define fnOUTLPSCROLLBARINFO            NtUserMessageCall


#define MESSAGEPROTO(func) \
LRESULT CALLBACK fn ## func(                               \
        HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, \
        ULONG_PTR xParam, DWORD xpfnWndProc, BOOL bAnsi)

MESSAGEPROTO(COPYGLOBALDATA);
MESSAGEPROTO(INDEVICECHANGE);
MESSAGEPROTO(INPAINTCLIPBRD);
MESSAGEPROTO(INSIZECLIPBRD);
MESSAGEPROTO(IMECONTROL);
MESSAGEPROTO(IMEREQUEST);
MESSAGEPROTO(INWPARAMDBCSCHAR);
MESSAGEPROTO(EMGETSEL);
MESSAGEPROTO(EMSETSEL);
MESSAGEPROTO(CBGETEDITSEL);


/*
 * clhook.c
 */
#define IsHooked(pci, fsHook) \
    ((fsHook & (pci->fsHooks | pci->pDeskInfo->fsHooks)) != 0)

LRESULT fnHkINLPCWPSTRUCTW(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR xParam);
LRESULT fnHkINLPCWPSTRUCTA(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR xParam);
LRESULT fnHkINLPCWPRETSTRUCTW(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR xParam);
LRESULT fnHkINLPCWPRETSTRUCTA(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR xParam);
LRESULT DispatchHookW(int dw, WPARAM wParam, LPARAM lParam, HOOKPROC pfn);
LRESULT DispatchHookA(int dw, WPARAM wParam, LPARAM lParam, HOOKPROC pfn);

/*
 * client.c
 */
LRESULT APIENTRY ButtonWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ButtonWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY MenuWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY MenuWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY DesktopWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY DesktopWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ScrollBarWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ScrollBarWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ListBoxWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ListBoxWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY StaticWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY StaticWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ComboBoxWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ComboBoxWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ComboListBoxWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ComboListBoxWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY MDIClientWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY MDIClientWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY MB_DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY MDIActivateDlgProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY MDIActivateDlgProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY EditWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY EditWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ImeWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ImeWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#ifdef MESSAGE_PUMP_HOOK
DWORD APIENTRY RealGetQueueStatus(UINT flags);
DWORD WINAPI RealMsgWaitForMultipleObjectsEx(DWORD nCount, CONST HANDLE *pHandles,
        DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags);
#endif
LRESULT APIENTRY RealDefWindowProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY RealDefWindowProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY DispatchDefWindowProcA(PWND pwnd, UINT msg, WPARAM wParam, LPARAM lParam, ULONG_PTR pfn);
LRESULT APIENTRY DispatchDefWindowProcW(PWND pwnd, UINT msg, WPARAM wParam, LPARAM lParam, ULONG_PTR pfn);
BOOL    InitUserApiHook(HMODULE hmod, ULONG_PTR offPfnInitUserApiHook);
BOOL    ClearUserApiHook(HMODULE hmod);
BOOL    CALLBACK DefaultOWP(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT * pr, void ** pvCookie);
void    ResetUserApiHook(USERAPIHOOK * puah);
LRESULT SendMessageWorker(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam, BOOL fAnsi);
LRESULT SendMessageTimeoutWorker(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam,
            UINT fuFlags, UINT uTimeout, PULONG_PTR lpdwResult, BOOL fAnsi);

void ClientEmptyClipboard(void);
VOID GetActiveKeyboardName(LPWSTR lpszName);
HANDLE OpenKeyboardLayoutFile(LPWSTR lpszKLName, LANGID langid,
                              PUINT puFlags, PUINT poffTable, PUINT pKbdInputLocale,
                              OUT OPTIONAL PKBDTABLE_MULTI_INTERNAL pKbdTableMulti);
VOID LoadPreloadKeyboardLayouts(void);
void SetWindowState(PWND pwnd, UINT flags);
void ClearWindowState(PWND pwnd, UINT flags);

HKL LoadKeyboardLayoutWorker(HKL hkl, LPCWSTR lpszKLName, LANGID langid, UINT uFlags, BOOL fFailSafe);
BOOL GetRemoteKeyboardLayout(PWCHAR pwszKLName, LANGID* pLangId);


/*
 * Worker routines called from both the window procs and
 * the callback thunks.
 */
LRESULT DispatchClientMessage(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR pfn);
LRESULT DefWindowProcWorker(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT RealDefWindowProcWorker(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT ButtonWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT ListBoxWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT StaticWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT ComboBoxWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT ComboListBoxWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT MDIClientWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT EditWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT DefDlgProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT ImeWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);

/*
 * Server Stubs - ntstubs.c
 */

LONG _SetWindowLong(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong,
    BOOL bAnsi);

#ifdef _WIN64
LONG_PTR _SetWindowLongPtr(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong,
    BOOL bAnsi);
#else
#define _SetWindowLongPtr   _SetWindowLong
#endif

BOOL _PeekMessage(
    LPMSG pmsg,
    HWND hwnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg,
    BOOL bAnsi);

BOOL _DefSetText(
    HWND hwnd,
    LPCWSTR pstr,
    BOOL bAnsi);

HCURSOR _GetCursorFrameInfo(
    HCURSOR hcur,
    LPWSTR id,
    int iFrame,
    LPDWORD pjifRate,
    LPINT pccur);

HWND _CreateWindowEx(
    DWORD dwExStyle,
    LPCTSTR pClassName,
    LPCTSTR pWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hwndParent,
    HMENU hmenu,
    HANDLE hModule,
    LPVOID pParam,
    DWORD dwFlags);

HWND VerNtUserCreateWindowEx(
    IN DWORD dwExStyle,
    IN PLARGE_STRING pstrClassName,
    IN PLARGE_STRING pstrWindowName OPTIONAL,
    IN DWORD dwStyle,
    IN int x,
    IN int y,
    IN int nWidth,
    IN int nHeight,
    IN HWND hwndParent,
    IN HMENU hmenu,
    IN HANDLE hModule,
    IN LPVOID pParam,
    IN DWORD dwFlags);

HKL _LoadKeyboardLayoutEx(
    HANDLE hFile,
    UINT offTable,
    PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    HKL hkl,
    LPCWSTR pwszKL,
    UINT KbdInputLocale,
    UINT Flags);

BOOL _SetCursorIconData(
    HCURSOR hCursor,
    PCURSORDATA pcur);

HCURSOR FindExistingCursorIcon(
    LPWSTR      pszModName,
    LPCWSTR     pszResName,
    PCURSORFIND pcfSearch);

HANDLE CreateLocalMemHandle(
    HANDLE hMem);

HANDLE ConvertMemHandle(
    HANDLE hMem,
    UINT cbNULL);

HHOOK _SetWindowsHookEx(
    HANDLE hmod,
    LPTSTR pszLib,
    DWORD idThread,
    int nFilterType,
    PROC pfnFilterProc,
    DWORD dwFlags);

#if 0
DWORD WINAPI ImmGetReconvertTotalSize(
    DWORD dwSize,
    REQ_CALLER eCaller,
    BOOL bAnsiTarget);

DWORD WINAPI ImmReconversionWorker(
    LPRECONVERTSTRING lpRecTo,
    LPRECONVERTSTRING lpRecFrom,
    BOOL bToAnsi,
    DWORD dwCodePage);
#endif

/*
 * classc.c
 */
ULONG_PTR _GetClassData(
    PCLS pcls,
    PWND pwnd,
    int index,
    BOOL bAnsi);

DWORD _GetClassLong(
    PWND pwnd,
    int index,
    BOOL bAnsi);

#ifdef _WIN64
ULONG_PTR _GetClassLongPtr(
    PWND pwnd,
    int index,
    BOOL bAnsi);
#else
#define _GetClassLongPtr    _GetClassLong
#endif

/*
 * mngrayc.c
 */
BOOL BitBltSysBmp(
    HDC hdc,
    int x,
    int y,
    UINT i);


/*
 * clenum.c
 */
DWORD BuildHwndList(
    HDESK hdesk,
    HWND hwndNext,
    BOOL fEnumChildren,
    DWORD idThread,
    HWND **phwndFirst);

/*
 * cltxt.h
 */
ATOM RegisterClassExWOWA(
    PWNDCLASSEXA lpWndClass,
    LPDWORD pdwWOWstuff,
    WORD fnid,
    DWORD dwFlags);

ATOM RegisterClassExWOWW(
    PWNDCLASSEXW lpWndClass,
    LPDWORD pdwWOWstuff,
    WORD fnid,
    DWORD dwFlags);

void CopyLogFontAtoW(
    PLOGFONTW pdest,
    PLOGFONTA psrc);

void CopyLogFontWtoA(
    PLOGFONTA pdest,
    PLOGFONTW psrc);

/*
 * dlgmgrc.c
 */
PWND _NextControl(
    PWND pwndDlg,
    PWND pwnd,
    UINT uFlags);

PWND _PrevControl(
    PWND pwndDlg,
    PWND pwnd,
    UINT uFlags);

PWND _GetNextDlgGroupItem(
    PWND pwndDlg,
    PWND pwnd,
    BOOL fPrev);

PWND _GetNextDlgTabItem(
    PWND pwndDlg,
    PWND pwnd,
    BOOL fPrev);

PWND _GetChildControl(
    PWND pwndDlg,
    PWND pwndLevel);

/*
 * winmgrc.c
 */
BOOL FChildVisible(
    HWND hwnd);

/*
 * draw.c
 */
BOOL PaintRect(
    HWND hwndBrush,
    HWND hwndPaint,
    HDC hdc,
    HBRUSH hbr,
    LPRECT lprc);

#define NtUserReleaseDC(hwnd,hdc)  NtUserCallOneParam((ULONG_PTR)(hdc), SFI__RELEASEDC)
#define NtUserArrangeIconicWindows(hwnd)  (UINT)NtUserCallHwndLock((hwnd), SFI_XXXARRANGEICONICWINDOWS)
#define NtUserBeginDeferWindowPos(nNumWindows) (HANDLE)NtUserCallOneParam((nNumWindows),SFI__BEGINDEFERWINDOWPOS)
#define NtUserCreateMenu()   (HMENU)NtUserCallNoParam(SFI__CREATEMENU)
#define NtUserDestroyCaret() (BOOL)NtUserCallNoParam(SFI_ZZZDESTROYCARET)
#define NtUserEnableWindow(hwnd, bEnable) (BOOL)NtUserCallHwndParamLock((hwnd), (bEnable),SFI_XXXENABLEWINDOW)
#define NtUserGetMessagePos() (DWORD)NtUserCallNoParam(SFI__GETMESSAGEPOS)
#define NtUserKillSystemTimer(hwnd,nIDEvent)  (BOOL)NtUserCallHwndParam((hwnd), (nIDEvent), SFI__KILLSYSTEMTIMER)
#define NtUserMessageBeep(wType)  (BOOL)NtUserCallOneParam((wType), SFI_XXXMESSAGEBEEP)
#define NtUserSetWindowContextHelpId(hwnd,id) (BOOL)NtUserCallHwndParam((hwnd), (id), SFI__SETWINDOWCONTEXTHELPID)
#define NtUserGetWindowContextHelpId(hwnd)   (BOOL)NtUserCallHwnd((hwnd), SFI__GETWINDOWCONTEXTHELPID)
#define NtUserRedrawFrame(hwnd)   NtUserCallHwndLock((hwnd), SFI_XXXREDRAWFRAME)
#define NtUserRedrawFrameAndHook(hwnd)  NtUserCallHwndLock((hwnd), SFI_XXXREDRAWFRAMEANDHOOK)
#define NtUserRedrawTitle(hwnd, wFlags)  NtUserCallHwndParamLock((hwnd), (wFlags), SFI_XXXREDRAWTITLE)
#define NtUserReleaseCapture()  (BOOL)NtUserCallNoParam(SFI_XXXRELEASECAPTURE)
#define NtUserSetCaretPos(X,Y)  (BOOL)NtUserCallTwoParam((DWORD)(X), (DWORD)(Y), SFI_ZZZSETCARETPOS)
#define NtUserSetCursorPos(X, Y)  (BOOL)NtUserCallTwoParam((X), (Y), SFI_ZZZSETCURSORPOS)
#define NtUserSetForegroundWindow(hwnd)  (BOOL)NtUserCallHwndLock((hwnd), SFI_XXXSTUBSETFOREGROUNDWINDOW)
#define NtUserSetSysMenu(hwnd)  NtUserCallHwndLock((hwnd), SFI_XXXSETSYSMENU)
#define NtUserSetVisible(hwnd,fSet)  NtUserCallHwndParam((hwnd), (fSet), SFI_SETVISIBLE)
#define NtUserShowCursor(bShow)   (int)NtUserCallOneParam((bShow), SFI_ZZZSHOWCURSOR)
#define NtUserUpdateClientRect(hwnd) NtUserCallHwndLock((hwnd), SFI_XXXUPDATECLIENTRECT)

#define CreateCaret         NtUserCreateCaret
#define FillWindow          NtUserFillWindow
#define GetControlBrush     NtUserGetControlBrush
#define GetControlColor     NtUserGetControlColor
#define GetDCEx             NtUserGetDCEx
#define GetWindowPlacement  NtUserGetWindowPlacement
#define RedrawWindow        NtUserRedrawWindow


/*
 * dmmnem.c
 */
int FindMnemChar(
    LPWSTR lpstr,
    WCHAR ch,
    BOOL fFirst,
    BOOL fPrefix);

/*
 * clres.c
 */
BOOL WowGetModuleFileName(
    HMODULE hModule,
    LPWSTR pwsz,
    DWORD  cchMax);

HICON WowServerLoadCreateCursorIcon(
    HANDLE hmod,
    LPTSTR lpModName,
    DWORD dwExpWinVer,
    LPCTSTR lpName,
    DWORD cb,
    PVOID pcr,
    LPTSTR lpType,
    BOOL fClient);

HANDLE InternalCopyImage(
    HANDLE hImage,
    UINT IMAGE_flag,
    int cxNew,
    int cyNew,
    UINT LR_flags);

HMENU CreateMenuFromResource(
    LPBYTE);

/*
 * acons.c
 */
#define BFT_ICON    0x4349  //  'IC'
#define BFT_BITMAP  0x4D42  //  'BM'
#define BFT_CURSOR  0x5450  //  'PT'

typedef struct _FILEINFO {
    LPBYTE  pFileMap;
    LPBYTE  pFilePtr;
    LPBYTE  pFileEnd;
    LPCWSTR pszName;
} FILEINFO, *PFILEINFO;

HANDLE LoadCursorIconFromFileMap(
    IN PFILEINFO   pfi,
    IN OUT LPWSTR *prt,
    IN DWORD       cxDesired,
    IN DWORD       cyDesired,
    IN DWORD       LR_flags,
    OUT LPBOOL     pfAni);

DWORD GetIcoCurWidth(
    DWORD cxOrg,
    BOOL  fIcon,
    UINT  LR_flags,
    DWORD cxDesired);

DWORD GetIcoCurHeight(
    DWORD cyOrg,
    BOOL  fIcon,
    UINT  LR_flags,
    DWORD cyDesired);

DWORD GetIcoCurBpp(
    UINT LR_flags);

HICON LoadIcoCur(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    LPWSTR    type,
    DWORD     cxDesired,
    DWORD     cyDesired,
    UINT      LR_flags);

HANDLE ObjectFromDIBResource(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    LPWSTR    type,
    DWORD     cxDesired,
    DWORD     cyDesired,
    UINT      LR_flags);

HANDLE RtlLoadObjectFromDIBFile(
    LPCWSTR lpszName,
    LPWSTR  type,
    DWORD   cxDesired,
    DWORD   cyDesired,
    UINT    LR_flags);

HCURSOR LoadCursorOrIconFromFile(
    LPCWSTR pszFilename,
    BOOL    fIcon);

HBITMAP ConvertDIBBitmap(
    UPBITMAPINFOHEADER lpbih,
    DWORD              cxDesired,
    DWORD              cyDesired,
    UINT               flags,
    LPBITMAPINFOHEADER *lplpbih,
    LPSTR              *lplpBits);

HICON ConvertDIBIcon(
    LPBITMAPINFOHEADER lpbih,
    HINSTANCE          hmod,
    LPCWSTR            lpName,
    BOOL               fIcon,
    DWORD              cxNew,
    DWORD              cyNew,
    UINT               LR_flags);

int SmartStretchDIBits(
    HDC          hdc,
    int          xD,
    int          yD,
    int          dxD,
    int          dyD,
    int          xS,
    int          yS,
    int          dxS,
    int          dyS,
    LPVOID       lpBits,
    LPBITMAPINFO lpbi,
    UINT         wUsage,
    DWORD        rop);


/*
 * OFFSET for different DPI resources.
 * This allows us to take a resource number and "map" to an actual resource
 * based on what DPI the user selected
 */

#define OFFSET_SCALE_DPI 000
#define OFFSET_96_DPI    100
#define OFFSET_120_DPI   200
#define OFFSET_160_DPI   300

/*
 * defines the highest resource number so we can do math on the resource
 * number.
 */

#define MAX_RESOURCE_INDEX 32768


/*
 * Parameter for xxxAlterHilite()
 */
#define HILITEONLY      0x0001
#define SELONLY         0x0002
#define HILITEANDSEL    (HILITEONLY + SELONLY)

#define HILITE     1

// LATER IanJa: these vary by country!  For US they are VK_OEM_2 VK_OEM_5.
//       Change lboxctl2.c MapVirtualKey to character - and fix the spelling?
#define VERKEY_SLASH     0xBF   /* Virtual key for '/' character */
#define VERKEY_BACKSLASH 0xDC   /* Virtual key for '\' character */

/*
 * Procedures for combo boxes.
 */
LONG  xxxCBCommandHandler(PCBOX, DWORD, HWND);
LRESULT xxxCBMessageItemHandler(PCBOX, UINT, LPVOID);
int   xxxCBDir(PCBOX, UINT, LPWSTR);
VOID  xxxCBPaint(PCBOX, HDC);
VOID  xxxCBCompleteEditWindow(PCBOX pcbox);
BOOL  xxxCBHideListBoxWindow(PCBOX pcbox, BOOL fNotifyParent, BOOL fSelEndOK);
VOID  xxxCBShowListBoxWindow(PCBOX pcbox, BOOL fTrack);
void xxxCBPosition(PCBOX pcbox);

/*
 * combo.h
 */

/* Initialization code */
long  CBNcCreateHandler(PCBOX, PWND);
LRESULT xxxCBCreateHandler(PCBOX, PWND);
void xxxCBCalcControlRects(PCBOX pcbox, LPRECT lprcList);

/* Destruction code */
VOID  xxxCBNcDestroyHandler(PWND, PCBOX);

/* Generic often used routines */
VOID  xxxCBNotifyParent(PCBOX, SHORT);
VOID  xxxCBUpdateListBoxWindow(PCBOX, BOOL);


/* Helpers' */
VOID  xxxCBInternalUpdateEditWindow(PCBOX, HDC);
VOID  xxxCBGetFocusHelper(PCBOX);
VOID  xxxCBKillFocusHelper(PCBOX);
VOID  xxxCBInvertStaticWindow(PCBOX,BOOL,HDC);
VOID  xxxCBSetFontHandler(PCBOX, HANDLE, BOOL);
VOID  xxxCBSizeHandler(PCBOX);
LONG  xxxCBSetEditItemHeight(PCBOX pcbox, int editHeight);


/*
 * String
 */

INT xxxFindString(PLBIV, LPWSTR, INT, INT, BOOL);

VOID  InitHStrings(PLBIV);

int   xxxLBInsertItem(PLBIV, LPWSTR, int, UINT);

/*
 * Selection
 */
BOOL  ISelFromPt(PLBIV, POINT, LPDWORD);
BOOL  IsSelected(PLBIV, INT, UINT);
VOID LBSetCItemFullMax(PLBIV plb);

VOID  xxxLBSelRange(PLBIV, INT, INT, BOOL);

INT xxxLBSetCurSel(PLBIV, INT);

INT LBoxGetSelItems(PLBIV, BOOL, INT, LPINT);

LONG  xxxLBSetSel(PLBIV, BOOL, INT);

VOID  xxxSetISelBase(PLBIV, INT);

VOID  SetSelected(PLBIV, INT, BOOL, UINT);


/*
 * Caret
 */
void xxxLBSetCaret(PLBIV plb, BOOL fSetCaret);
VOID  xxxCaretDestroy(PLBIV);

/*
 * LBox
 */
LONG  xxxLBCreate(PLBIV, PWND, LPCREATESTRUCT);
VOID  xxxDestroyLBox(PLBIV, PWND);
VOID  xxxLBoxDeleteItem(PLBIV, INT);

VOID  xxxLBoxDoDeleteItems(PLBIV);
VOID  xxxLBoxDrawItem(PLBIV, INT, UINT, UINT, LPRECT);


/*
 * Scroll
 */
INT   LBCalcVarITopScrollAmt(PLBIV, INT, INT);

VOID  xxxLBoxCtlHScroll(PLBIV, INT, INT);

VOID  xxxLBoxCtlHScrollMultiColumn(PLBIV, INT, INT);

VOID  xxxLBoxCtlScroll(PLBIV, INT, INT);

VOID  xxxLBShowHideScrollBars(PLBIV);

/*
 * LBoxCtl
 */
INT xxxLBoxCtlDelete(PLBIV, INT);

VOID  xxxLBoxCtlCharInput(PLBIV, UINT, BOOL);
VOID  xxxLBoxCtlKeyInput(PLBIV, UINT, UINT);
VOID  xxxLBPaint(PLBIV, HDC, LPRECT);

BOOL xxxLBInvalidateRect(PLBIV plb, LPRECT lprc, BOOL fErase);
/*
 * Miscellaneous
 */
VOID  xxxAlterHilite(PLBIV, INT, INT, BOOL, INT, BOOL);

INT CItemInWindow(PLBIV, BOOL);

VOID  xxxCheckRedraw(PLBIV, BOOL, INT);

LPWSTR GetLpszItem(PLBIV, INT);

VOID  xxxInsureVisible(PLBIV, INT, BOOL);

VOID  xxxInvertLBItem(PLBIV, INT, BOOL);

VOID  xxxLBBlockHilite(PLBIV, INT, BOOL);

int   LBGetSetItemHeightHandler(PLBIV plb, UINT message, int item, UINT height);
VOID  LBDropObjectHandler(PLBIV, PDROPSTRUCT);
LONG_PTR LBGetItemData(PLBIV, INT);

INT LBGetText(PLBIV, BOOL, BOOL, INT, LPWSTR);

VOID  xxxLBSetFont(PLBIV, HANDLE, BOOL);
int LBSetItemData(PLBIV, INT, LONG_PTR);

BOOL  LBSetTabStops(PLBIV, INT, LPINT);

VOID  xxxLBSize(PLBIV, INT, INT);
INT LastFullVisible(PLBIV);

INT xxxLbDir(PLBIV, UINT, LPWSTR);

INT xxxLbInsertFile(PLBIV, LPWSTR);

VOID  xxxNewITop(PLBIV, INT);
VOID  xxxNewITopEx(PLBIV, INT, DWORD);

VOID  xxxNotifyOwner(PLBIV, INT);

VOID  xxxResetWorld(PLBIV, INT, INT, BOOL);

VOID  xxxTrackMouse(PLBIV, UINT, POINT);
BOOL  xxxDlgDirListHelper(PWND, LPWSTR, LPBYTE, int, int, UINT, BOOL);
BOOL  DlgDirSelectHelper(LPWSTR pFileName, int cbFileName, HWND hwndListBox);
BOOL xxxLBResetContent(PLBIV plb);
VOID xxxLBSetRedraw(PLBIV plb, BOOL fRedraw);
int xxxSetLBScrollParms(PLBIV plb, int nCtl);
void xxxLBButtonUp(PLBIV plb, UINT uFlags);

/*
 * Variable Height OwnerDraw Support Routines
 */
INT CItemInWindowVarOwnerDraw(PLBIV, BOOL);

INT LBPage(PLBIV, INT, BOOL);


/*
 * Multicolumn listbox
 */
VOID  LBCalcItemRowsAndColumns(PLBIV);

/*
 * Both multicol and var height
 */
BOOL  LBGetItemRect(PLBIV, INT, LPRECT);

VOID  LBSetVariableHeightItemHeight(PLBIV, INT, INT);

INT   LBGetVariableHeightItemHeight(PLBIV, INT);

/*
 * No-data (lazy evaluation) listbox
 */
INT  xxxLBSetCount(PLBIV, INT);

UINT LBCalcAllocNeeded(PLBIV, INT);

/*
 * Storage pre-allocation support for LB_INITSTORAGE
 */
LONG xxxLBInitStorage(PLBIV plb, BOOL fAnsi, INT cItems, INT cb);

/***************************************************************************\
*
* Dialog Boxes
*
\***************************************************************************/

HWND        InternalCreateDialog(HANDLE hmod,
             LPDLGTEMPLATE lpDlgTemplate, DWORD cb,
             HWND hwndOwner , DLGPROC pfnWndProc, LPARAM dwInitParam,
             UINT fFlags);

INT_PTR     InternalDialogBox(HANDLE hmod,
             LPDLGTEMPLATE lpDlgTemplate,
             HWND hwndOwner , DLGPROC pfnWndProc, LPARAM dwInitParam,
             UINT fFlags);

PWND        _FindDlgItem(PWND pwndParent, DWORD id);
PWND        _GetDlgItem(PWND, int);
long        _GetDialogBaseUnits(VOID);
PWND        GetParentDialog(PWND pwndDialog);
VOID        xxxRemoveDefaultButton(PWND pwndDlg, PWND pwndStart);
VOID        xxxCheckDefPushButton(PWND pwndDlg, HWND hwndOldFocus, HWND hwndNewFocus);
PWND        xxxGotoNextMnem(PWND pwndDlg, PWND pwndStart, WCHAR ch);
VOID        DlgSetFocus(HWND hwnd);
void        RepositionRect(PMONITOR pMonitor, LPRECT lprc, DWORD dwStyle, DWORD dwExStyle);
BOOL        ValidateDialogPwnd(PWND pwnd);
PMONITOR    GetDialogMonitor(HWND hwndOwner, DWORD dwFlags);

HANDLE      GetEditDS(VOID);
VOID        ReleaseEditDS(HANDLE h);
VOID        TellWOWThehDlg(HWND hDlg);

UINT        GetACPCharSet();

/***************************************************************************\
*
* Menus
*
\***************************************************************************/
// cltxt.h
BOOL GetMenuItemInfoInternalW(HMENU hMenu, UINT uID, BOOL fByPosition, LPMENUITEMINFOW lpmii);

#define MENUAPI_INSERT  0
#define MENUAPI_GET     1
#define MENUAPI_SET     2

// clmenu.c
BOOL InternalInsertMenuItem(HMENU hMenu, UINT uID, BOOL fByPosition, LPCMENUITEMINFO lpmii);
BOOL ValidateMENUITEMINFO(LPMENUITEMINFOW lpmiiIn, LPMENUITEMINFOW lpmii, DWORD dwAPICode);
BOOL ValidateMENUINFO(LPCMENUINFO lpmi, DWORD dwAPICode);


// ntstubs.c
BOOL ThunkedMenuItemInfo(HMENU hMenu, UINT  nPosition, BOOL fByPosition,
                            BOOL fInsert, LPMENUITEMINFOW lpmii, BOOL fAnsi);

// menuc.c
void SetMenuItemInfoStruct(HMENU hMenu, UINT wFlags, UINT_PTR wIDNew, LPWSTR pwszNew,
                              LPMENUITEMINFOW pmii);

/***************************************************************************\
*
* Message Boxes
*
\***************************************************************************/

/* Unicode Right-To-Left mark unicode code point. Look in msgbox.c for more info */
#define UNICODE_RLM             0x200f

/***************************************************************************\
*
* MDI Windows
*
\***************************************************************************/

/* maximum number of MDI children windows listed in "Window" menu */
#define MAXITEMS         10

/*
 * MDI typedefs
 */
typedef struct tagSHORTCREATE {
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    HMENU       hMenu;
} SHORTCREATE, *PSHORTCREATE;

typedef struct tagMDIACTIVATEPOS {
    int     cx;
    int     cy;
    int     cxMin;
    int     cyMin;
} MDIACTIVATEPOS, *PMDIACTIVATEPOS;

BOOL CreateMDIChild(PSHORTCREATE pcs, LPMDICREATESTRUCT pmcs, DWORD dwExpWinVerAndFlags, HMENU *phSysMenu, PWND pwndParent);
BOOL MDICompleteChildCreation(HWND hwndChild, HMENU hSysMenu, BOOL fVisible, BOOL fDisabled);

/*
 * MDI defines
 */
#define WS_MDISTYLE     (WS_CHILD | WS_CLIPSIBLINGS | WS_SYSMENU|WS_CAPTION|WS_THICKFRAME|WS_MAXIMIZEBOX|WS_MINIMIZEBOX)
#define WS_MDICOMMANDS  (WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_MDIALLOWED   (WS_MINIMIZE | WS_MAXIMIZE | WS_CLIPCHILDREN | WS_DISABLED | WS_HSCROLL | WS_VSCROLL | 0x0000FFFFL)

#define HAS_SBVERT      0x0100
#define HAS_SBHORZ      0x0200
#define OTHERMAXING     0x0400
#define CALCSCROLL      0x0800

#define SCROLLSUPPRESS  0x0003
#define SCROLLCOUNT     0x00FF

#define CKIDS(pmdi)     (pmdi->cKids)
#define MAXED(pmdi)     (pmdi->hwndMaxedChild)
#define ACTIVE(pmdi)    (pmdi->hwndActiveChild)
#define WINDOW(pmdi)    (pmdi->hmenuWindow)
#define FIRST(pmdi)     (pmdi->idFirstChild)
#define SCROLL(pmdi)    (pmdi->wScroll)
#define ITILELEVEL(pmdi)    (pmdi->iChildTileLevel)
#define HTITLE(pmdi)    (pmdi->pTitle)

#define PROP_MDICLIENT  MAKEINTRESOURCE(0x8CAC)
#define MDIACTIVATE_PROP_NAME   L"MDIA"

PWND  FindPwndChild(PWND pwndMDI, UINT wChildID);
int   MakeMenuItem(LPWSTR lpOut, PWND pwnd);
VOID  ModifyMenuItem(PWND pwnd);
BOOL  MDIAddSysMenu(HMENU hmenuFrame, HWND hwndChild);
BOOL  MDIRemoveSysMenu(HMENU hMenuFrame, HWND hwndChild);
VOID  ShiftMenuIDs(PWND pwnd, PWND pwndVictim);
HMENU MDISetMenu(PWND,BOOL,HMENU,HMENU);
void  MDIRedrawFrame(HWND hwndChild, BOOL fAdd);

/*
 * Drag and Drop menus.
 */
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#include <ole2.h>

/*
 * Prototypes to cast function pointers
 */
typedef HRESULT (* OLEINITIALIZEPROC)(LPVOID);
typedef HRESULT (* OLEUNINITIALIZEPROC)(VOID);
typedef HRESULT (* REGISTERDDPROC)(HWND, LPDROPTARGET);
typedef HRESULT (* REVOKEDDPROC)(HWND);
typedef HRESULT (* DODDPROC)(LPDATAOBJECT, LPDROPSOURCE, DWORD, LPDWORD);

/*
 * Internal IDropTarget interface info
 */
typedef struct tagMNIDROPTARGET
{
   IDropTarget idt;                 /* Interal IDropTarget */
   DWORD dwRefCount;                /* Ref count */
   IDataObject * pido;              /* IDataObject received at DragEnter */
   IDropTarget * pidt;              /* Application IDropTarget, if any */
} MNIDROPTARGET, * PMNIDROPTARGET;

/*
 * OLE procs info (used by LoadOLEOnce GetProcAddress calls)
 */
typedef struct tagGETPROCINFO
{
    FARPROC * ppfn;
    LPCSTR lpsz;
} GETPROCINFO;

/*
 * Special value used by __ClientLoadOLE.
 */
#define OLEWONTLOAD (HINSTANCE)IntToPtr(0xFFFFFFFF)

/*
 * Accelerator table resources list.
 */
typedef struct tagACCELCACHE
{
    struct tagACCELCACHE *pacNext;
    UINT dwLockCount;
    HACCEL hAccel;
    PVOID pRes;
} ACCELCACHE, *PACCELCACHE;


/*
 * x86 callback return function prototype
 */
#if defined(_X86_) && !defined(BUILD_WOW6432)
NTSTATUS
FASTCALL
XyCallbackReturn(
    IN PVOID Buffer,
    IN ULONG Length,
    IN NTSTATUS Status
    );

#define UserCallbackReturn XyCallbackReturn
#else
#define UserCallbackReturn NtCallbackReturn
#endif

/*
 * Reader mode support
 */
typedef LONG (CALLBACK* READERMODEPROC)(LPARAM lParam, int nCode, int dx, int dy);

typedef struct tagREADERMODE {  // rdrm
    UINT cbSize;
    DWORD dwFlags;
    READERMODEPROC pfnReaderModeProc;
    LPARAM lParam;
} READERMODE, *PREADERMODE, *LPREADERMODE;

#define RDRMODE_VERT    0x00000001
#define RDRMODE_HORZ    0x00000002
#define RDRMODE_DIAG    0x00000004

#define RDRCODE_START   1
#define RDRCODE_SCROLL  2
#define RDRCODE_END     3

typedef struct tagREADERINFO {
    READERMODE;
    int dx;
    int dy;
    UINT uCursor;
    HBITMAP hbm;
    UINT dxBmp;
    UINT dyBmp;
} READERINFO, *PREADERINFO;

typedef struct tagREADERWND {
    WND wnd;
    PREADERINFO prdr;
} READERWND, * KPTR_MODIFIER PREADERWND;

BOOL EnterReaderModeHelper(HWND hwnd);

#include "ddemlcli.h"
#include "globals.h"
#include "cscall.h"
#include "ntuser.h"

/***************************************************************************\
*
* DBCS MESSAGING
*
\***************************************************************************/
/*
 * Message keeper for ...
 *
 * Client to Client.
 */
#define GetDispatchDbcsInfo()          (&(GetClientInfo()->achDbcsCF[0]))
/*
 * Client to Server.
 */
#define GetForwardDbcsInfo()           (&(GetClientInfo()->achDbcsCF[1]))
/*
 * Server to Client.
 */
#define GetCallBackDbcsInfo()          (&(GetClientInfo()->msgDbcsCB))

/*
 * Macros for DBCS Messaging for Recieve side.
 */
#define GET_DBCS_MESSAGE_IF_EXIST(_apiName,_pmsg,_wMsgFilterMin,_wMsgFilterMax,bRemoveMsg)  \
                                                                                            \
        if (GetCallBackDbcsInfo()->wParam) {                                                \
            /*                                                                              \
             * Check message filter... only WM_CHAR message will be pushed                  \
             * into CLIENTINFO. Then if WM_CHAR is filtered out, we should                  \
             * get message from queue...                                                    \
             */                                                                             \
            if ((!(_wMsgFilterMin) && !(_wMsgFilterMax)) ||                                 \
                ((_wMsgFilterMin) <= WM_CHAR && (_wMsgFilterMax) >= WM_CHAR)) {             \
                PKERNEL_MSG pmsgDbcs = GetCallBackDbcsInfo();                               \
                /*                                                                          \
                 * Get pushed message.                                                      \
                 *                                                                          \
                 * Backup current message. this backupped message will be used              \
                 * when Apps peek (or get) message from thier WndProc.                      \
                 * (see GetMessageA(), PeekMessageA()...)                                   \
                 *                                                                          \
                 * pmsg->hwnd    = pmsgDbcs->hwnd;                                          \
                 * pmsg->message = pmsgDbcs->message;                                       \
                 * pmsg->wParam  = pmsgDbcs->wParam;                                        \
                 * pmsg->lParam  = pmsgDbcs->lParam;                                        \
                 * pmsg->time    = pmsgDbcs->time;                                          \
                 * pmsg->pt      = pmsgDbcs->pt;                                            \
                 */                                                                         \
                COPY_KERNELMSG_TO_MSG((_pmsg),pmsgDbcs);                                   \
                /*                                                                          \
                 * if we don't want to clear the cached data, just leave it there.          \
                 */                                                                         \
                if (bRemoveMsg) {                                                           \
                    /*                                                                      \
                     * Invalidate pushed message in CLIENTINFO.                             \
                     */                                                                     \
                    pmsgDbcs->wParam = 0;                                                   \
                }                                                                           \
                /*                                                                          \
                 * Set return value to TRUE.                                                \
                 */                                                                         \
                retval = TRUE;                                                              \
                /*                                                                          \
                 * Exit function..                                                          \
                 */                                                                         \
                goto Exit ## _apiName;                                                      \
            }                                                                               \
        }

/*
 * Macros for DBCS Messaging for Send side.
 */
#define BUILD_DBCS_MESSAGE_TO_SERVER_FROM_CLIENTA(_msg,_wParam,_RetVal)                     \
                                                                                            \
        if (IS_DBCS_ENABLED() && (((_msg) == WM_CHAR) || ((_msg) == EM_SETPASSWORDCHAR))) { \
            /*                                                                              \
             * Chech wParam is DBCS character or not.                                       \
             */                                                                             \
            if (IS_DBCS_MESSAGE((_wParam))) {                                               \
                if ((_wParam) & WMCR_IR_DBCSCHAR) {                                         \
                    /*                                                                      \
                     * This message sent with IR_DBCSCHAR, already aligned for conversion   \
                     */                                                                     \
                } else {                                                                    \
                    /*                                                                      \
                     * Make IR_DBCSCHAR compatible DBCS packed message                      \
                     */                                                                     \
                    (_wParam) = MAKEWPARAM(MAKE_IR_DBCSCHAR(LOWORD((_wParam))),0);          \
                }                                                                           \
            } else {                                                                        \
                PBYTE pchDbcsCF = GetForwardDbcsInfo();                                     \
                /*                                                                          \
                 * If we have cached Dbcs LeadingByte character, build A Dbcs character     \
                 * with the TrailingByte in wParam...                                       \
                 */                                                                         \
                if (*pchDbcsCF) {                                                           \
                    WORD DbcsLeadChar = (WORD)(*pchDbcsCF);                                 \
                    /*                                                                      \
                     * HIBYTE(LOWORD(wParam)) = Dbcs LeadingByte.                           \
                     * LOBYTE(LOWORD(wParam)) = Dbcs TrailingByte.                          \
                     */                                                                     \
                    (_wParam) |= (DbcsLeadChar << 8);                                       \
                    /*                                                                      \
                     * Invalidate cached data..                                             \
                     */                                                                     \
                    *pchDbcsCF = 0;                                                         \
                } else if (IsDBCSLeadByteEx(THREAD_CODEPAGE(),LOBYTE(LOWORD(_wParam)))) { \
                    /*                                                                      \
                     * if this is Dbcs LeadByte character, we should wait Dbcs TrailingByte \
                     * to convert this to Unicode. then we cached it here...                \
                     */                                                                     \
                    *pchDbcsCF = LOBYTE(LOWORD((_wParam)));                                 \
                    /*                                                                      \
                     * Right now, we have nothing to do for this, just return with TRUE.    \
                     */                                                                     \
                    return((_RetVal));                                                      \
                }                                                                           \
            }                                                                               \
        }

#define BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_CLIENTA(_msg,_wParam,_RetVal)                    \
                                                                                            \
        if (IS_DBCS_ENABLED() && (((_msg) == WM_CHAR) || ((_msg) == EM_SETPASSWORDCHAR))) { \
            /*                                                                              \
             * Check wParam is DBCS character or not.                                       \
             */                                                                             \
            if (IS_DBCS_MESSAGE((_wParam))) {                                               \
                if ((_wParam) & WMCR_IR_DBCSCHAR) {                                         \
                    /*                                                                      \
                     * This message sent with IR_DBCSCHAR, already aligned for conversion   \
                     */                                                                     \
                } else {                                                                    \
                    /*                                                                      \
                     * Make IR_DBCSCHAR compatible DBCS packed message                      \
                     */                                                                     \
                    (_wParam) = MAKEWPARAM(MAKE_IR_DBCSCHAR(LOWORD((_wParam))),0);          \
                }                                                                           \
            } else {                                                                        \
                PBYTE pchDbcsCF = GetDispatchDbcsInfo();                                    \
                /*                                                                          \
                 * If we have cached Dbcs LeadingByte character, build A Dbcs character     \
                 * with the TrailingByte in wParam...                                       \
                 */                                                                         \
                if (*pchDbcsCF) {                                                           \
                    WORD DbcsLeadChar = (WORD)(*pchDbcsCF);                                 \
                    /*                                                                      \
                     * HIBYTE(LOWORD(wParam)) = Dbcs LeadingByte.                           \
                     * LOBYTE(LOWORD(wParam)) = Dbcs TrailingByte.                          \
                     */                                                                     \
                    (_wParam) |= (DbcsLeadChar << 8);                                       \
                    /*                                                                      \
                     * Invalidate cached data..                                             \
                     */                                                                     \
                    *pchDbcsCF = 0;                                                         \
                } else if (IsDBCSLeadByteEx(THREAD_CODEPAGE(),LOBYTE(LOWORD(_wParam)))) { \
                    /*                                                                      \
                     * if this is Dbcs LeadByte character, we should wait Dbcs TrailingByte \
                     * to convert this to Unicode. then we cached it here...                \
                     */                                                                     \
                    *pchDbcsCF = LOBYTE(LOWORD((_wParam)));                                 \
                    /*                                                                      \
                     * Right now, we have nothing to do for this, just return with TRUE.    \
                     */                                                                     \
                    return((_RetVal));                                                      \
                }                                                                           \
            }                                                                               \
        }

#define BUILD_DBCS_MESSAGE_TO_CLIENTA_FROM_SERVER(_pmsg,_dwAnsi,_bIrDbcsFormat,bSaveMsg)    \
        /*                                                                                  \
         * _bIrDbcsFormat parameter is only effective WM_CHAR/EM_SETPASSWORDCHAR message    \
         *                                                                                  \
         * (_bIrDbcsFormat == FALSE) dwAnsi has ....                                        \
         *                                                                                  \
         * HIBYTE(LOWORD(_dwAnsi)) = DBCS TrailingByte character.                           \
         * LOBYTE(LOWORD(_dwAnsi)) = DBCS LeadingByte character                             \
         *                           or SBCS character.                                     \
         *                                                                                  \
         * (_bIrDbcsFormat == TRUE) dwAnsi has ....                                         \
         *                                                                                  \
         * HIBYTE(LOWORD(_dwAnsi)) = DBCS LeadingByte character.                            \
         * LOBYTE(LOWORD(_dwAnsi)) = DBCS TrailingByte character                            \
         *                           or SBCS character.                                     \
         */                                                                                 \
    if (IS_DBCS_ENABLED())                                                 \
        switch ((_pmsg)->message) {                                                         \
        case WM_CHAR:                                                                       \
        case EM_SETPASSWORDCHAR:                                                            \
            if (IS_DBCS_MESSAGE((_dwAnsi))) {                                               \
                /*                                                                          \
                 * This is DBCS character..                                                 \
                 */                                                                         \
                if ((_pmsg)->wParam & WMCR_IR_DBCSCHAR) {                                   \
                    /*                                                                      \
                     * Build IR_DBCSCHAR format message.                                    \
                     */                                                                     \
                    if ((_bIrDbcsFormat)) {                                                 \
                        (_pmsg)->wParam = (WPARAM)(LOWORD((_dwAnsi)));                      \
                    } else {                                                                \
                        (_pmsg)->wParam = MAKE_IR_DBCSCHAR(LOWORD((_dwAnsi)));              \
                    }                                                                       \
                } else {                                                                    \
                    PKERNEL_MSG pDbcsMsg = GetCallBackDbcsInfo();                           \
                    if ((_bIrDbcsFormat)) {                                                 \
                        /*                                                                  \
                         * if the format is IR_DBCSCHAR format, adjust it to regular        \
                         * WPARAM format...                                                 \
                         */                                                                 \
                        (_dwAnsi) = MAKE_WPARAM_DBCSCHAR((_dwAnsi));                        \
                    }                                                                       \
                    if ((bSaveMsg)) {                                                       \
                        /*                                                                  \
                         * Copy this message to CLIENTINFO for next GetMessage              \
                         * or PeekMesssage() call.                                          \
                         */                                                                 \
                        COPY_MSG_TO_KERNELMSG(pDbcsMsg,(_pmsg));                            \
                        /*                                                                  \
                         * Only Dbcs Trailingbyte is nessesary for pushed message. we'll    \
                         * pass this message when GetMessage/PeekMessage is called at next. \
                         */                                                                 \
                        pDbcsMsg->wParam = (WPARAM)(((_dwAnsi) & 0x0000FF00) >> 8);         \
                    }                                                                       \
                    /*                                                                      \
                     * Return DbcsLeading byte to Apps.                                     \
                     */                                                                     \
                    (_pmsg)->wParam =  (WPARAM)((_dwAnsi) & 0x000000FF);                    \
                }                                                                           \
            } else {                                                                        \
                /*                                                                          \
                 * This is single byte character... set it to wParam.                       \
                 */                                                                         \
                (_pmsg)->wParam = (WPARAM)((_dwAnsi) & 0x000000FF);                         \
            }                                                                               \
            break;                                                                          \
        case WM_IME_CHAR:                                                                   \
        case WM_IME_COMPOSITION:                                                            \
            /*                                                                              \
             * if the message is not adjusted to IR_DBCSCHAR format yet,                    \
             * Build WM_IME_xxx format message.                                             \
             */                                                                             \
            if (!(_bIrDbcsFormat)) {                                                        \
                (_pmsg)->wParam = MAKE_IR_DBCSCHAR(LOWORD((_dwAnsi)));                      \
            }                                                                               \
            break;                                                                          \
        default:                                                                            \
            (_pmsg)->wParam = (WPARAM)(_dwAnsi);                                            \
            break;                                                                          \
        } /* switch */                                                                      \
    else                                                                                    \

#define BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_SERVER(_msg,_wParam)                             \
                                                                                            \
        if (((_msg) == WM_CHAR) || ((_msg) == EM_SETPASSWORDCHAR)) {                        \
            /*                                                                              \
             * Only LOWORD of WPARAM is valid for WM_CHAR....                               \
             * (Mask off DBCS messaging information.)                                       \
             */                                                                             \
            (_wParam) &= 0x0000FFFF;                                                        \
        }

#define BUILD_DBCS_MESSAGE_TO_CLIENTA_FROM_CLIENTW(_hwnd,_msg,_wParam,_lParam,_time,_pt,_bDbcs) \
                                                                                                \
        if (IS_DBCS_ENABLED() && (((_msg) == WM_CHAR) || ((_msg) == EM_SETPASSWORDCHAR))) {     \
            /*                                                                                  \
             * Check this message is DBCS Message or not..                                      \
             */                                                                                 \
            if (IS_DBCS_MESSAGE((_wParam))) {                                                   \
                PKERNEL_MSG pmsgDbcsCB = GetCallBackDbcsInfo();                                 \
                /*                                                                              \
                 * Mark this is DBCS character.                                                 \
                 */                                                                             \
                (_bDbcs) = TRUE;                                                                \
                /*                                                                              \
                 * Backup current message. this backupped message will be used                  \
                 * when Apps peek (or get) message from thier WndProc.                          \
                 * (see GetMessageA(), PeekMessageA()...)                                       \
                 */                                                                             \
                pmsgDbcsCB->hwnd    = (_hwnd);                                                  \
                pmsgDbcsCB->message = (_msg);                                                   \
                pmsgDbcsCB->lParam  = (_lParam);                                                \
                pmsgDbcsCB->time    = (_time);                                                  \
                pmsgDbcsCB->pt      = (_pt);                                                    \
                /*                                                                              \
                 * DbcsLeadByte will be sent below soon, we just need DbcsTrailByte             \
                 * for further usage..                                                          \
                 */                                                                             \
                pmsgDbcsCB->wParam = ((_wParam) & 0x000000FF);                                  \
                /*                                                                              \
                 * Pass the LeadingByte of the DBCS character to an ANSI WndProc.               \
                 */                                                                             \
                (_wParam) = ((_wParam) & 0x0000FF00) >> 8;                                      \
            } else {                                                                            \
                /*                                                                              \
                 * Validate only BYTE for WM_CHAR.                                              \
                 */                                                                             \
                (_wParam) &= 0x000000FF;                                                        \
            }                                                                                   \
        }

#define DISPATCH_DBCS_MESSAGE_IF_EXIST(_msg,_wParam,_bDbcs,_apiName)                            \
        /*                                                                                      \
         * Check we need to send trailing byte or not, if the wParam has Dbcs character         \
         */                                                                                     \
        if (IS_DBCS_ENABLED() && (_bDbcs) && (GetCallBackDbcsInfo()->wParam)) {                 \
            PKERNEL_MSG pmsgDbcsCB = GetCallBackDbcsInfo();                                            \
            /*                                                                                  \
             * If an app didn't peek (or get) the trailing byte from within                     \
             * WndProc, and then pass the DBCS TrailingByte to the ANSI WndProc here            \
             * pmsgDbcsCB->wParam has DBCS TrailingByte here.. see above..                      \
             */                                                                                 \
            (_wParam) = KERNEL_WPARAM_TO_WPARAM(pmsgDbcsCB->wParam);                            \
            /*                                                                                  \
             * Invalidate cached message.                                                       \
             */                                                                                 \
            pmsgDbcsCB->wParam = 0;                                                             \
            /*                                                                                  \
             * Send it....                                                                      \
             */                                                                                 \
            goto _apiName ## Again;                                                             \
        }

#define CalcAnsiStringLengthW(_unicodestring,_unicodeLength,_ansiLength)                        \
        /*                                                                                      \
         * Get AnsiStringLength from UnicodeString,UnicodeLength                                \
         */                                                                                     \
        {                                                                                       \
            RtlUnicodeToMultiByteSize((ULONG *)(_ansiLength),                                   \
                                      (LPWSTR)(_unicodestring),                                 \
                                      (ULONG)((_unicodeLength)*sizeof(WCHAR)));                 \
        }

#define CalcAnsiStringLengthA(_ansistring,_unicodeLength,_ansiLength)                           \
        /*                                                                                      \
         * Get AnsiStringLength from AnsiString,UnicodeLength                                   \
         */                                                                                     \
        {                                                                                       \
            LPSTR _string = (_ansistring);                                                      \
            LONG  _length = (LONG)(_unicodeLength);                                             \
            (*(_ansiLength)) = 0;                                                               \
            while(*_string && _length) {                                                        \
                if (IsDBCSLeadByte(*_string)) {                                                 \
                    (*(_ansiLength)) += 2; _string++;                                           \
                } else {                                                                        \
                    (*(_ansiLength))++;                                                         \
                }                                                                               \
                _string++; _length--;                                                           \
            }                                                                                   \
        }

#define CalcUnicodeStringLengthA(_ansistring,_ansiLength,_unicodeLength)                        \
        /*                                                                                      \
         * Get UnicodeLength from AnsiString,AnsiLength                                         \
         */                                                                                     \
        {                                                                                       \
            RtlMultiByteToUnicodeSize((ULONG *)(_unicodeLength),                                \
                                      (LPSTR)(_ansistring),                                     \
                                      (ULONG)(_ansiLength));                                    \
            (*(_unicodeLength)) /= sizeof(WCHAR);                                               \
        }

#define CalcUnicodeStringLengthW(_unicodestring,_ansiLength,_unicodeLength)                     \
        /*                                                                                      \
         * Get UnicodeLength from UnicodeString,AnsiLength                                      \
         */                                                                                     \
        {                                                                                       \
            LPWSTR _string = (_unicodestring);                                                  \
            LONG   _length = (LONG)(_ansiLength);                                               \
            LONG   _charlength;                                                                 \
            (*(_unicodeLength)) = 0;                                                            \
            while(*_string && (_length > 0)) {                                                  \
                CalcAnsiStringLengthW(_string,1,&_charlength);                                  \
                _length -= _charlength;                                                         \
                if (_length >= 0) {                                                             \
                    (*(_unicodeLength))++;                                                      \
                }                                                                               \
                _string++;                                                                      \
            }                                                                                   \
        }


/*
 * DBCS function defined in userrtl.lib (see ..\rtl\userrtl.h)
 */
DWORD UserGetCodePage(HDC hdc);
BOOL  UserIsFullWidth(DWORD dwCodePage,WCHAR wChar);
BOOL  UserIsFELineBreak(DWORD dwCodePage,WCHAR wChar);


// FE_IME   // fareast.c
typedef struct {
    BOOL (WINAPI* ImmWINNLSEnableIME)(HWND, BOOL);
    BOOL (WINAPI* ImmWINNLSGetEnableStatus)(HWND);
    LRESULT (WINAPI* ImmSendIMEMessageExW)(HWND, LPARAM);
    LRESULT (WINAPI* ImmSendIMEMessageExA)(HWND, LPARAM);
    BOOL (WINAPI* ImmIMPGetIMEW)(HWND, LPIMEPROW);
    BOOL (WINAPI* ImmIMPGetIMEA)(HWND, LPIMEPROA);
    BOOL (WINAPI* ImmIMPQueryIMEW)(LPIMEPROW);
    BOOL (WINAPI* ImmIMPQueryIMEA)(LPIMEPROA);
    BOOL (WINAPI* ImmIMPSetIMEW)(HWND, LPIMEPROW);
    BOOL (WINAPI* ImmIMPSetIMEA)(HWND, LPIMEPROA);

    HIMC (WINAPI* ImmAssociateContext)(HWND, HIMC);
    LRESULT (WINAPI* ImmEscapeA)(HKL, HIMC, UINT, LPVOID);
    LRESULT (WINAPI* ImmEscapeW)(HKL, HIMC, UINT, LPVOID);
    LONG (WINAPI* ImmGetCompositionStringA)(HIMC, DWORD, LPVOID, DWORD);
    LONG (WINAPI* ImmGetCompositionStringW)(HIMC, DWORD, LPVOID, DWORD);
    BOOL (WINAPI* ImmGetCompositionWindow)(HIMC, LPCOMPOSITIONFORM);
    HIMC (WINAPI* ImmGetContext)(HWND);
    HWND (WINAPI* ImmGetDefaultIMEWnd)(HWND);
    BOOL (WINAPI* ImmIsIME)(HKL);
    BOOL (WINAPI* ImmReleaseContext)(HWND, HIMC);
    BOOL (*ImmRegisterClient)(PSHAREDINFO, HINSTANCE);

    BOOL (WINAPI* ImmGetCompositionFontW)(HIMC, LPLOGFONTW);
    BOOL (WINAPI* ImmGetCompositionFontA)(HIMC, LPLOGFONTA);
    BOOL (WINAPI* ImmSetCompositionFontW)(HIMC, LPLOGFONTW);
    BOOL (WINAPI* ImmSetCompositionFontA)(HIMC, LPLOGFONTA);

    BOOL (WINAPI* ImmSetCompositionWindow)(HIMC, LPCOMPOSITIONFORM);
    BOOL (WINAPI* ImmNotifyIME)(HIMC, DWORD, DWORD, DWORD);
    PINPUTCONTEXT (WINAPI* ImmLockIMC)(HIMC);
    BOOL (WINAPI* ImmUnlockIMC)(HIMC);
    BOOL (WINAPI* ImmLoadIME)(HKL);
    BOOL (WINAPI* ImmSetOpenStatus)(HIMC, BOOL);
    BOOL (WINAPI* ImmFreeLayout)(DWORD);
    BOOL (WINAPI* ImmActivateLayout)(HKL);
    BOOL (WINAPI* ImmGetCandidateWindow)(HIMC, DWORD, LPCANDIDATEFORM);
    BOOL (WINAPI* ImmSetCandidateWindow)(HIMC, LPCANDIDATEFORM);
    BOOL (WINAPI* ImmConfigureIMEW)(HKL, HWND, DWORD, LPVOID);
    BOOL (WINAPI* ImmGetConversionStatus)(HIMC, LPDWORD, LPDWORD);
    BOOL (WINAPI* ImmSetConversionStatus)(HIMC, DWORD, DWORD);
    BOOL (WINAPI* ImmSetStatusWindowPos)(HIMC, LPPOINT);
    BOOL (WINAPI* ImmGetImeInfoEx)(PIMEINFOEX, IMEINFOEXCLASS, PVOID);
    PIMEDPI (WINAPI* ImmLockImeDpi)(HKL);
    VOID (WINAPI* ImmUnlockImeDpi)(PIMEDPI);
    BOOL (WINAPI* ImmGetOpenStatus)(HIMC);
    BOOL (*ImmSetActiveContext)(HWND, HIMC, BOOL);
    BOOL (*ImmTranslateMessage)(HWND, UINT, WPARAM, LPARAM);
    BOOL (*ImmLoadLayout)(HKL, PIMEINFOEX);
    DWORD (WINAPI* ImmProcessKey)(HWND, HKL, UINT, LPARAM, DWORD);
    LRESULT (*ImmPutImeMenuItemsIntoMappedFile)(HIMC);
    DWORD (WINAPI* ImmGetProperty)(HKL hKL, DWORD dwIndex);
    BOOL (WINAPI* ImmSetCompositionStringA)(
        HIMC hImc, DWORD dwIndex, LPCVOID lpComp, DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen);
    BOOL (WINAPI* ImmSetCompositionStringW)(
        HIMC hImc, DWORD dwIndex, LPCVOID lpComp, DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen);
    BOOL (WINAPI* ImmEnumInputContext)(
        DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
    LRESULT (WINAPI* ImmSystemHandler)(HIMC, WPARAM, LPARAM);

#ifdef CUAS_ENABLE
    // Cicero
    HRESULT (WINAPI* CtfImmTIMActivate)(HKL hKL);
    void (WINAPI* CtfImmRestoreToolbarWnd)(DWORD dwPrevSts);
    DWORD (WINAPI* CtfImmHideToolbarWnd)(void);
    LRESULT (WINAPI* CtfImmDispatchDefImeMessage)(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif // CUAS_ENABLE
} ImmApiEntries;

extern ImmApiEntries gImmApiEntries;
extern HMODULE ghImm32;
VOID InitializeImmEntryTable(VOID);
VOID GetImmFileName(PWSTR);
VOID CliImmInitializeHotKeys(DWORD dwAction, HKL hkl);

#define fpImmAssociateContext       gImmApiEntries.ImmAssociateContext
#define fpImmEscapeA                gImmApiEntries.ImmEscapeA
#define fpImmEscapeW                gImmApiEntries.ImmEscapeW
#define fpImmGetContext             gImmApiEntries.ImmGetContext
#define fpImmGetCompositionStringA  gImmApiEntries.ImmGetCompositionStringA
#define fpImmGetCompositionStringW  gImmApiEntries.ImmGetCompositionStringW
#define fpImmGetCompositionWindow   gImmApiEntries.ImmGetCompositionWindow
#define fpImmGetDefaultIMEWnd       gImmApiEntries.ImmGetDefaultIMEWnd
#define fpImmIsIME                  gImmApiEntries.ImmIsIME
#define fpImmLockIMC                gImmApiEntries.ImmLockIMC
#define fpImmReleaseContext         gImmApiEntries.ImmReleaseContext
#define fpImmRegisterClient         gImmApiEntries.ImmRegisterClient
#define fpImmGetCompositionFontW    gImmApiEntries.ImmGetCompositionFontW
#define fpImmGetCompositionFontA    gImmApiEntries.ImmGetCompositionFontA
#define fpImmSetCompositionFontW    gImmApiEntries.ImmSetCompositionFontW
#define fpImmSetCompositionFontA    gImmApiEntries.ImmSetCompositionFontA
#define fpImmSetCompositionFont     gImmApiEntries.ImmSetCompositionFont
#define fpImmSetCompositionWindow   gImmApiEntries.ImmSetCompositionWindow
#define fpImmNotifyIME              gImmApiEntries.ImmNotifyIME
#define fpImmUnlockIMC              gImmApiEntries.ImmUnlockIMC
#define fpImmLoadIME                gImmApiEntries.ImmLoadIME
#define fpImmSetOpenStatus          gImmApiEntries.ImmSetOpenStatus
#define fpImmFreeLayout             gImmApiEntries.ImmFreeLayout
#define fpImmActivateLayout         gImmApiEntries.ImmActivateLayout
#define fpImmGetCandidateWindow     gImmApiEntries.ImmGetCandidateWindow
#define fpImmSetCandidateWindow     gImmApiEntries.ImmSetCandidateWindow
#define fpImmConfigureIMEW          gImmApiEntries.ImmConfigureIMEW
#define fpImmGetConversionStatus    gImmApiEntries.ImmGetConversionStatus
#define fpImmSetConversionStatus    gImmApiEntries.ImmSetConversionStatus
#define fpImmSetStatusWindowPos     gImmApiEntries.ImmSetStatusWindowPos
#define fpImmGetImeInfoEx           gImmApiEntries.ImmGetImeInfoEx
#define fpImmLockImeDpi             gImmApiEntries.ImmLockImeDpi
#define fpImmUnlockImeDpi           gImmApiEntries.ImmUnlockImeDpi
#define fpImmGetOpenStatus          gImmApiEntries.ImmGetOpenStatus
#define fpImmSetActiveContext       gImmApiEntries.ImmSetActiveContext
#define fpImmTranslateMessage       gImmApiEntries.ImmTranslateMessage
#define fpImmLoadLayout             gImmApiEntries.ImmLoadLayout
#define fpImmProcessKey             gImmApiEntries.ImmProcessKey
#define fpImmPutImeMenuItemsIntoMappedFile gImmApiEntries.ImmPutImeMenuItemsIntoMappedFile
#define fpImmGetProperty            gImmApiEntries.ImmGetProperty
#define fpImmSetCompositionStringA  gImmApiEntries.ImmSetCompositionStringA
#define fpImmSetCompositionStringW  gImmApiEntries.ImmSetCompositionStringW
#define fpImmEnumInputContext       gImmApiEntries.ImmEnumInputContext
#define fpImmSystemHandler          gImmApiEntries.ImmSystemHandler

BOOL SyncSoftKbdState(HIMC hImc, LPARAM lParam); // imectl.c

#ifdef CUAS_ENABLE
// Cicero
#define fpCtfImmTIMActivate            gImmApiEntries.CtfImmTIMActivate
#define fpCtfImmRestoreToolbarWnd      gImmApiEntries.CtfImmRestoreToolbarWnd
#define fpCtfImmHideToolbarWnd         gImmApiEntries.CtfImmHideToolbarWnd
#define fpCtfImmDispatchDefImeMessage  gImmApiEntries.CtfImmDispatchDefImeMessage

#endif


// end FE_IME

/*
 * Rebasing functions for shared memory. Need to located after
 * inclusion of globals.h.
 */
__inline PVOID
REBASESHAREDPTRALWAYS(KERNEL_PVOID p)
{
    return (PVOID)(((KERNEL_UINT_PTR)p) - gSharedInfo.ulSharedDelta);
}

__inline PVOID
REBASESHAREDPTR(KERNEL_PVOID p)
{
    return (p) ? REBASESHAREDPTRALWAYS(p) : NULL;
}

/*
 * Multimonitor macros used in RTL. There are similar definitions
 * in kernel\userk.h
 */
__inline PDISPLAYINFO
GetDispInfo(VOID)
{
    return gSharedInfo.pDispInfo;
}

__inline PMONITOR
GetPrimaryMonitor(VOID)
{
    return REBASESHAREDPTR(GetDispInfo()->pMonitorPrimary);
}


/*
 * UserApiHook functions
 */

__inline BOOL IsInsideUserApiHook(
    VOID)
{
    return (ghmodUserApiHook != NULL) && gfUserApiHook;
}

__inline BOOL _BeginIfHookedUserApiHook()
{
    UserAssert(gcCallUserApiHook < MAXLONG);

    InterlockedIncrement(&gcCallUserApiHook);
    if (!IsInsideUserApiHook()) {
        InterlockedDecrement(&gcCallUserApiHook);
        return FALSE;
    } else {
        UserAssertMsg0(ghmodUserApiHook != NULL, "Should not reach 0 while outstanding call");
        return TRUE;
    }
}

VOID _EndUserApiHook(VOID);

#define BEGIN_USERAPIHOOK()                                                 \
    {                                                                       \
        BOOL fInsideHook = IsInsideUserApiHook();                           \
                                                                            \
        if (!gfServerProcess && !fInsideHook && TEST_SRVIF(SRVIF_HOOKED)) { \
            if (!RtlIsThreadWithinLoaderCallout()) {                        \
                NtUserCallNoParam(SFI_XXXLOADUSERAPIHOOK);                  \
            }                                                               \
        }                                                                   \
                                                                            \
        fInsideHook = _BeginIfHookedUserApiHook();                          \
        try {                                                               \


#define END_USERAPIHOOK()               \
        } finally {                     \
            if (fInsideHook) {          \
                _EndUserApiHook();      \
            }                           \
        }                               \
    }                                   \


#ifdef MESSAGE_PUMP_HOOK

__inline BOOL IsInsideMessagePumpHook()
{
    PCLIENTTHREADINFO pcti = GetClientInfo()->pClientThreadInfo;
    return gfMessagePumpHook && (pcti != NULL) && (pcti->cMessagePumpHooks > 0);
}

#define BEGIN_MESSAGEPUMPHOOK()                         \
    {                                                   \
        BOOL fInsideHook = IsInsideMessagePumpHook();   \


#define END_MESSAGEPUMPHOOK()           \
    }                                   \

#endif


int RealSetScrollInfo(HWND hwnd, int fnBar, LPCSCROLLINFO lpsi, BOOL fRedraw);
BOOL RealGetScrollInfo(HWND hwnd, int code, LPSCROLLINFO lpsi);
BOOL RealEnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows);
BOOL RealAdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle);
BOOL RealSetWindowRgn(HWND hwnd, HRGN hrgn, BOOL bRedraw);
int RealGetSystemMetrics(int index);
BOOL RealSystemParametersInfoA(UINT wFlag, UINT wParam, PVOID lParam, UINT flags);
BOOL RealSystemParametersInfoW(UINT wFlag, UINT wParam, PVOID lParam, UINT flags);
BOOL ForceResetUserApiHook(HMODULE hmod);
BOOL RealDrawFrameControl(HDC hdc, LPRECT lprc, UINT wType, UINT wState);
BOOL RealDrawCaption(HWND hwnd, HDC hdc, CONST RECT *lprc, UINT flags);
void RealMDIRedrawFrame(HWND hwndChild, BOOL fAdd);


/*
 * Event logging stuff
 */
BOOL GetCurrentProcessName(WCHAR *pszProcessName, int cch);
BOOL GetUserSid(PTOKEN_USER *ppTokenUser);

#ifdef _JANUS_
BOOL InitInstrument(LPDWORD lpEMIControl);
#endif

#define MAX_ATOM_LEN    256

#define FREE_LIBRARY_SAVE_ERROR(hModule)                                    \
{                                                                           \
    DWORD SaveLastError = NtCurrentTeb()->LastErrorValue;                   \
    FreeLibrary(hModule);                                                   \
    NtCurrentTeb()->LastErrorValue = SaveLastError;                         \
}

BOOL VersionRegisterClass(LPWSTR lpzClassName, LPWSTR lpzDllName, PACTIVATION_CONTEXT lpActivationContext, HMODULE *phModule);
LPWSTR ClassNameToVersion (LPCWSTR lpClassName, LPWSTR pClassVerName, LPWSTR* lpDllName, PACTIVATION_CONTEXT* lppActivationContext, BOOL bIsANSI);

#define ARRAYSIZE(a)    (sizeof(a) / sizeof(a[0]))

#define TEST_DUSER_WMH 0

#if TEST_DUSER_WMH

DECLARE_HANDLE(HDCONTEXT);

typedef struct tagINITGADGET
{
    DWORD       cbSize;         // Size of structure
    UINT        nThreadMode;    // Threading model
    UINT        nMsgMode;       // DirectUser/Core messaging subsystem mode
    HDCONTEXT   hctxShare;      // Existing context to share with
} INITGADGET;

typedef HDCONTEXT (WINAPI * InitGadgetsProc)(INITGADGET * pInit);
extern HDCONTEXT g_hctx;        // DirectUser Context

#define IGTM_SEPARATE           (2)     // | MT with single thread per context

#define IGMM_STANDARD           (3)     // | Standard mode on Whistler

#endif

#ifdef LAME_BUTTON
#define LAMEBUTTON_PROP_NAME L"LAME"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\statctl.c ===
/****************************************************************************\
*
*  STATIC.C
*
*  Copyright (c) 1985 - 1999, Microsoft Corporation
*
*  Static Dialog Controls Routines
*
*  13-Nov-1990 mikeke   from win3
*  29-Jan-1991 IanJa    StaticPaint -> xxxStaticPaint; partial revalidation
*  01-Nov-1994 ChrisWil merged in Daytona/Chicago w/Ani-Icons.
*
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Local Routines.
 */
VOID xxxNextAniIconStep(PSTAT);
HANDLE xxxSetStaticImage(PSTAT,HANDLE,BOOL);
VOID xxxStaticLoadImage(PSTAT,LPWSTR);


/*
 * Type table; this is used for validation of the image types.
 */
#define IMAGE_STMMAX    IMAGE_ENHMETAFILE+1

static BYTE rgbType[IMAGE_STMMAX] = {
    SS_BITMAP,       // IMAGE_BITMAP
    SS_ICON,         // IMAGE_CURSOR
    SS_ICON,         // IMAGE_ICON
    SS_ENHMETAFILE   // IMAGE_ENHMETAFILE
};


/*
 * LOBYTE of SS_ style is index into this array
 */
#define STK_OWNER       0x00
#define STK_IMAGE       0x01
#define STK_TEXT        0x02
#define STK_GRAPHIC     0x03
#define STK_TYPE        0x03

#define STK_ERASE       0x04
#define STK_USEFONT     0x08
#define STK_USETEXT     0x10

BYTE rgstk[] = {
    STK_TEXT | STK_ERASE | STK_USEFONT | STK_USETEXT,       // SS_LEFT
    STK_TEXT | STK_ERASE | STK_USEFONT | STK_USETEXT,       // SS_CENTER
    STK_TEXT | STK_ERASE | STK_USEFONT | STK_USETEXT,       // SS_RIGHT
    STK_IMAGE,                                              // SS_ICON
    STK_GRAPHIC,                                            // SS_BLACKRECT
    STK_GRAPHIC,                                            // SS_GRAYRECT
    STK_GRAPHIC,                                            // SS_WHITERECT
    STK_GRAPHIC,                                            // SS_BLACKFRAME
    STK_GRAPHIC,                                            // SS_GRAYFRAME
    STK_GRAPHIC,                                            // SS_WHITEFRAME
    STK_OWNER,                                              // SS_USERITEM
    STK_TEXT | STK_USEFONT | STK_USETEXT,                   // SS_SIMPLE
    STK_TEXT | STK_ERASE | STK_USEFONT | STK_USETEXT,       // SS_LEFTNOWORDWRAP
    STK_OWNER | STK_USEFONT | STK_USETEXT,                  // SS_OWNERDRAW
    STK_IMAGE,                                              // SS_BITMAP
    STK_IMAGE | STK_ERASE,                                  // SS_ENHMETAFILE
    STK_GRAPHIC,                                            // SS_ETCHEDHORZ
    STK_GRAPHIC,                                            // SS_ETCHEDVERT
    STK_GRAPHIC                                             // SS_ETCHEDFRAME
};

LOOKASIDE StaticLookaside;

/*
 * Common macros for image handling.
 */
#define IsValidImage(imageType, realType, max) \
    ((imageType < max) && (rgbType[imageType] == realType))


/***************************************************************************\
* xxxSetStaticImage
*
* Sets bitmap/icon of static guy, either in response to a STM_SETxxxx
* message, or at create time.
\***************************************************************************/
HANDLE xxxSetStaticImage(
    PSTAT  pstat,
    HANDLE hImage,
    BOOL   fDeleteIt)
{
    UINT   bType;
    RECT   rc;
    RECT   rcWindow;
    HANDLE hImageOld;
    DWORD  dwRate;
    UINT   cicur;
    BOOL   fAnimated = FALSE;
    PWND   pwnd = pstat->spwnd;
    HWND   hwnd = HWq(pwnd);

    CheckLock(pwnd);

    bType = TestWF(pwnd, SFTYPEMASK);

    /*
     * If this is an old-ani-icon, then delete its timer.
     */
    if (bType == SS_ICON && pstat->cicur > 1) {
        /*
         * Old cursor was an animated cursor, so kill the timer that is used
         * to animate it.
         */
        NtUserKillTimer(hwnd, IDSYS_STANIMATE);
    }

    /*
     * Initialize the old-image return value.
     */
    hImageOld = pstat->hImage;

    rc.right = rc.bottom = 0;

    if (hImage != NULL) {

        switch (bType) {

            case SS_ENHMETAFILE: {
                /*
                 * We do NOT resize the window.
                 */
                rc.right  = pwnd->rcClient.right  - pwnd->rcClient.left;
                rc.bottom = pwnd->rcClient.bottom - pwnd->rcClient.top;
                break;
            }

            case SS_BITMAP: {

                    BITMAP bmp;

                    if (GetObject(hImage, sizeof(BITMAP), &bmp)) {
                        rc.right  = bmp.bmWidth;
                        rc.bottom = bmp.bmHeight;
                    }
                }
                break;

            case SS_ICON: {

                    NtUserGetIconSize(hImage, 0, &rc.right, &rc.bottom);
                    rc.bottom /= 2;

                    pstat->cicur = 0;
                    pstat->iicur = 0;

                    if (GetCursorFrameInfo(hImage, NULL, 0, &dwRate, &cicur)) {
                        fAnimated = (cicur > 1);
                        pstat->cicur = cicur;
                    }
                }
                break;
        }
    }

    pstat->hImage = hImage;
    pstat->fDeleteIt = fDeleteIt;


    /*
     * Resize static to fit. Do NOT do this for SS_CENTERIMAGE or
     * SS_REALSIZECONTROL.
     */
    if (!TestWF(pwnd, SFCENTERIMAGE) && !TestWF(pwnd, SFREALSIZECONTROL)) {
        /*
         * Get current window rect in parent's client coordinates.
         */
        GetRect(pwnd, &rcWindow, GRECT_WINDOW | GRECT_PARENTCOORDS);

        /*
         * Get new window dimensions.
         */
        rc.left = 0;
        rc.top = 0;

        if (rc.right && rc.bottom) {
            _AdjustWindowRectEx(&rc, pwnd->style, FALSE, pwnd->ExStyle);
            rc.right  -= rc.left;
            rc.bottom -= rc.top;
        }

        NtUserSetWindowPos(hwnd,
                           HWND_TOP,
                           0,
                           0,
                           rc.right,
                           rc.bottom,
                           SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
    }

    if (TestWF(pwnd, WFVISIBLE)) {
        NtUserInvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }


    /*
     * If this is an aimated-icon, then start the timer for the animation
     * sequence.
     */
    if(fAnimated) {
        GetCursorFrameInfo(pstat->hImage, NULL, pstat->iicur, &dwRate, &cicur);
        dwRate = max(200, dwRate * 100 / 6);
        NtUserSetTimer(hwnd, IDSYS_STANIMATE, dwRate, NULL);
    }

    return hImageOld;
}


/***************************************************************************\
* StaticLoadImage
*
* Loads the icon or bitmap from the app's resource file if a name was
* specified in the dialog template.  We assume that the name is the name of
* the resource to load.
\***************************************************************************/
VOID xxxStaticLoadImage(
    PSTAT pstat,
    LPWSTR lpszName)
{
    HANDLE hImage = NULL;
    PWND pwnd = pstat->spwnd;

    CheckLock(pwnd);

    if (lpszName && *lpszName) {

        /*
         * Only try to load the icon/bitmap if the string is non null.
         */
        if (*(BYTE FAR *)lpszName == 0xFF)
            lpszName = MAKEINTRESOURCE(((LPWORD)lpszName)[1]);

        /*
         * Load the image.  If it can't be found in the app, try the
         * display driver.
         */
        if (lpszName) {

            switch (TestWF(pwnd, SFTYPEMASK)) {
            case SS_BITMAP:

                /*
                 * If the window is not owned by the server, first call
                 * back out to the client.
                 */
                if (!gfServerProcess && pwnd->hModule) {
                    hImage = LoadBitmap(KHANDLE_TO_HANDLE(pwnd->hModule), lpszName);
                }

                /*
                 * If the above didn't load it, try loading it from the
                 * display driver (hmod == NULL).
                 */
                if (hImage == NULL) {
                    hImage = LoadBitmap(NULL, lpszName);
                }
                break;

            case SS_ICON:
                if (TestWF(pwnd, SFREALSIZEIMAGE)) {
                    if (!gfServerProcess && pwnd->hModule) {
                        hImage = LoadImage(KHANDLE_TO_HANDLE(pwnd->hModule), lpszName, IMAGE_ICON, 0, 0, 0);
                    }
                } else {
                    /*
                     * If the window is not owned by the server, first call
                     * back out to the client.  Try loading both icons/cursor
                     * types.
                     */
                    if (!gfServerProcess && pwnd->hModule) {
                        hImage = LoadIcon(KHANDLE_TO_HANDLE(pwnd->hModule),
                                          lpszName);

                        /*
                         * We will also try to load a cursor-format if the
                         * window is 4.0 compatible. Icons/Cursors are really
                         * the same. We don't do this for 3.x apps for the
                         * usual compatibility reasons.
                         */
                        if (hImage == NULL && TestWF(pwnd, WFWIN40COMPAT)) {
                            hImage = LoadCursor(KHANDLE_TO_HANDLE(pwnd->hModule), lpszName);
                        }
                    }

                    /*
                     * If the above didn't load it, try loading it from the
                     * display driver (hmod == NULL).
                     */
                    if (hImage == NULL) {
                        hImage = LoadIcon(NULL, lpszName);
                    }
                }

                break;
            }

            /*
             * Set the image if it was loaded.
             */
            if (hImage) {
                xxxSetStaticImage(pstat, hImage, TRUE);
            }
        }
    }
}


/***************************************************************************\
* StaticCallback
*
* Draws text statics, called by DrawState.
\***************************************************************************/
BOOL CALLBACK StaticCallback(
    HDC hdc,
    LPARAM lData,
    WPARAM wData,
    int cx,
    int cy)
{
    PWND pwnd = (PWND)lData;
    UINT style;
    LPWSTR lpszName;
    RECT rc;
    BYTE bType;

    UNREFERENCED_PARAMETER(wData);

    bType = TestWF(pwnd, SFTYPEMASK);
    UserAssert(rgstk[bType] & STK_USETEXT);

    if (pwnd->strName.Length) {
        lpszName = REBASE(pwnd, strName.Buffer);

        style = DT_NOCLIP | DT_EXPANDTABS;

        if (bType != LOBYTE(SS_LEFTNOWORDWRAP)) {
            style |= DT_WORDBREAK;
            style |= (UINT)(bType - LOBYTE(SS_LEFT));

            if (TestWF(pwnd, SFEDITCONTROL)) {
                style |= DT_EDITCONTROL;
            }
        }

        switch (TestWF(pwnd, SFELLIPSISMASK)) {
        case HIBYTE(LOWORD(SS_ENDELLIPSIS)):
            style |= DT_END_ELLIPSIS | DT_SINGLELINE;
            break;

        case HIBYTE(LOWORD(SS_PATHELLIPSIS)):
            style |= DT_PATH_ELLIPSIS | DT_SINGLELINE;
            break;

        case HIBYTE(LOWORD(SS_WORDELLIPSIS)):
            style |= DT_WORD_ELLIPSIS | DT_SINGLELINE;
            break;
        }

        if (TestWF(pwnd, SFNOPREFIX)) {
            style |= DT_NOPREFIX;
        }

        if (TestWF(pwnd, SFCENTERIMAGE)) {
            style |= DT_VCENTER | DT_SINGLELINE;
        }

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = cx;
        rc.bottom   = cy;

        if (TestWF(pwnd, WEFPUIACCELHIDDEN)) {
            style |= DT_HIDEPREFIX;
        } else if (((PSTATWND)pwnd)->pstat->fPaintKbdCuesOnly) {
            style |= DT_PREFIXONLY;
        }

        DrawTextExW(hdc, lpszName, -1, &rc, (DWORD)style, NULL);

    }

    return TRUE;
}


/***************************************************************************\
* xxxStaticPaint
*
* History:
\***************************************************************************/
VOID xxxStaticPaint(
    PSTAT pstat,
    HDC hdc,
    BOOL fClip)
{
    PWND pwndParent;
    RECT rc;
    UINT cmd;
    BYTE bType;
    BOOL fFont;
    HBRUSH hbrControl;
    UINT oldAlign;
    DWORD dwOldLayout = 0;
    HANDLE hfontOld = NULL;
    PWND pwnd = pstat->spwnd;
    HWND hwnd = HWq(pwnd);

    CheckLock(pwnd);

    if (TestWF(pwnd, WEFRTLREADING)) {
        oldAlign = GetTextAlign(hdc);
        SetTextAlign(hdc, oldAlign | TA_RTLREADING);
    }

    bType = TestWF(pwnd, SFTYPEMASK);
    _GetClientRect(pwnd, &rc);

    if (fClip) {
        IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
    }

    fFont = (rgstk[bType] & STK_USEFONT) && (pstat->hFont != NULL);

    if (fFont) {
        hfontOld = SelectObject(hdc, pstat->hFont);
    }


    /*
     * Send WM_CTLCOLORSTATIC to all statics (even frames) for 1.03
     * compatibility.
     */
    SetBkMode(hdc, OPAQUE);
    hbrControl = GetControlBrush(hwnd, hdc, WM_CTLCOLORSTATIC);


    /*
     * Do we erase the background?  We don't for SS_OWNERDRAW
     * and STK_GRAPHIC kind of things.
     */
    pwndParent = REBASEPWND(pwnd, spwndParent);
    if ((rgstk[bType] & STK_ERASE) && !pstat->fPaintKbdCuesOnly) {
        PaintRect(HW(pwndParent), hwnd, hdc, hbrControl, &rc);
    }

    switch (LOBYTE(bType)) {
    case SS_ICON:

        if (pstat->hImage) {

            int     cx;
            int     cy;
            POINT   pt;

            if (TestWF(pwnd,WEFLAYOUTRTL)) {
                dwOldLayout = SetLayoutWidth(hdc, -1, 0);
            }
            /*
             * Perform the correct rect-setup.
             */
            if (TestWF(pwnd,SFCENTERIMAGE)) {

                NtUserGetIconSize(pstat->hImage, pstat->iicur, &cx, &cy);
                cy >>= 1;

                rc.left   = (rc.right  - cx) / 2;
                rc.right  = (rc.left   + cx);
                rc.top    = (rc.bottom - cy) / 2;
                rc.bottom = (rc.top    + cy);

            } else {

                cx = rc.right  - rc.left;
                cy = rc.bottom - rc.top;
            }


            /*
             * Output the icon.  If it's animated, we indicate
             * the step-frame to output.
             */
            if (GETFNID(pwndParent) == FNID_DESKTOP) {
                SetBrushOrgEx(hdc, 0, 0, &pt);
            } else {
                SetBrushOrgEx(
                        hdc,
                        pwndParent->rcClient.left - pwnd->rcClient.left,
                        pwndParent->rcClient.top - pwnd->rcClient.top,
                        &pt);
            }

            DrawIconEx(hdc, rc.left, rc.top, pstat->hImage, cx, cy,
                       pstat->iicur, hbrControl, DI_NORMAL);

            SetBrushOrgEx(hdc, pt.x, pt.y, NULL);
            if (TestWF(pwnd,WEFLAYOUTRTL)) {
                SetLayoutWidth(hdc, -1, dwOldLayout);
            }
        } else {

            /*
             * Empty!  Need to erase.
             */
            PaintRect(HW(pwndParent), hwnd, hdc, hbrControl, &rc);
        }
        break;

    case SS_BITMAP:

        if (pstat->hImage) {

            BITMAP  bmp;
            HBITMAP hbmpT;
            RECT    rcTmp;
            BOOL    fErase;


            /*
             * Get the bitmap information.  If this fails, then we
             * can assume somethings wrong with its format...don't
             * draw in this case.
             */
            if (GetObject(pstat->hImage, sizeof(BITMAP), &bmp)) {

                if (TestWF(pwnd, SFCENTERIMAGE)) {

                    fErase = ((bmp.bmWidth  < rc.right) ||
                              (bmp.bmHeight < rc.bottom));

                    rc.left   = (rc.right  - bmp.bmWidth)  >> 1;
                    rc.right  = (rc.left   + bmp.bmWidth);
                    rc.top    = (rc.bottom - bmp.bmHeight) >> 1;
                    rc.bottom = (rc.top    + bmp.bmHeight);

                } else {

                    fErase = FALSE;
                }

                /*
                 * Select in the bitmap and blt it to the client-surface.
                 */
                RtlEnterCriticalSection(&gcsHdc);
                hbmpT = SelectObject(ghdcBits2, pstat->hImage);
                StretchBlt(hdc, rc.left, rc.top, rc.right-rc.left,
                           rc.bottom-rc.top, ghdcBits2, 0, 0, bmp.bmWidth,
                           bmp.bmHeight, SRCCOPY|NOMIRRORBITMAP);

                /*
                 * Only need to erase the background if the image is
                 * centered and it's smaller than the client-area.
                 */
                if (fErase) {

                    HBRUSH hbr;

                    if (hbr = CreateSolidBrush(GetPixel(ghdcBits2, 0, 0))) {

                        POLYPATBLT PolyData;

                        ExcludeClipRect(hdc, rc.left, rc.top,
                                        rc.right, rc.bottom);

                        _GetClientRect(pwnd, &rcTmp);

                        PolyData.x  = 0;
                        PolyData.y  = 0;
                        PolyData.cx = rcTmp.right;
                        PolyData.cy = rcTmp.bottom;
                        PolyData.BrClr.hbr = hbr;

                        PolyPatBlt(hdc,PATCOPY,&PolyData,1,PPB_BRUSH);

                        DeleteObject(hbr);
                    }
                }

                if (hbmpT) {
                    SelectObject(ghdcBits2, hbmpT);
                }
                RtlLeaveCriticalSection(&gcsHdc);
            }
        }
        break;

    case SS_ENHMETAFILE:

        if (pstat->hImage) {

            RECT rcl;

            rcl.left   = rc.left;
            rcl.top    = rc.top;
            rcl.right  = rc.right;
            rcl.bottom = rc.bottom;

            PlayEnhMetaFile(hdc, pstat->hImage, &rcl);
        }
        break;

    case SS_OWNERDRAW: {

            DRAWITEMSTRUCT dis;

            dis.CtlType    = ODT_STATIC;
            dis.CtlID      = PtrToUlong(pwnd->spmenu);
            dis.itemAction = ODA_DRAWENTIRE;
            dis.itemState  = (TestWF(pwnd, WFDISABLED) ? ODS_DISABLED : 0);
            dis.hwndItem   = hwnd;
            dis.hDC        = hdc;
            dis.itemData   = 0L;
            dis.rcItem     = rc;

            if (TestWF(pwnd, WEFPUIACCELHIDDEN)) {
                dis.itemState |= ODS_NOACCEL;
            }

            /*
             * Send a WM_DRAWITEM message to the parent.
             */
            SendMessage(HW(pwndParent), WM_DRAWITEM, (WPARAM)dis.CtlID, (LPARAM)&dis);
        }
        break;

    case SS_LEFT:
    case SS_CENTER:
    case SS_RIGHT:
    case SS_LEFTNOWORDWRAP:

        if (pwnd->strName.Length) {

            UINT dstFlags;

            dstFlags = DST_COMPLEX;

            if (TestWF(pwnd, WFDISABLED)) {
                dstFlags |= DSS_DISABLED;
            }

            DrawState(hdc,
                      SYSHBR(WINDOWTEXT),
                      StaticCallback,
                      (LPARAM)pwnd,
                      (WPARAM)TRUE,
                      rc.left,
                      rc.top,
                      rc.right - rc.left,
                      rc.bottom - rc.top,
                      dstFlags);
        }
        break;

    case SS_SIMPLE: {
            LPWSTR lpName;
            UINT cchName;

            /*
             * The "Simple" bType assumes everything, including the following:
             *  1. The Text exists and fits on one line.
             *  2. The Static item is always enabled.
             *  3. The Static item is never changed to be a shorter string.
             *  4. The Parent never responds to the CTLCOLOR message
             */
            if (pwnd->strName.Length) {
                lpName = REBASE(pwnd, strName.Buffer);
                cchName = pwnd->strName.Length / sizeof(WCHAR);
            } else {
                lpName = (LPWSTR)szNull;
                cchName = 0;
            }

            if (TestWF(pwnd,SFNOPREFIX)) {
                ExtTextOut(hdc, rc.left, rc.top, ETO_OPAQUE | ETO_CLIPPED,
                                &rc, lpName, cchName, 0L);
            } else {
                /*
                 * Use OPAQUE for speed.
                 */
                DWORD dwFlags;
                if (TestWF(pwnd, WEFPUIACCELHIDDEN)) {
                    dwFlags = DT_HIDEPREFIX;
                } else if (pstat->fPaintKbdCuesOnly) {
                    dwFlags = DT_PREFIXONLY;
                } else {
                    dwFlags = 0;
                }

                PSMTextOut(hdc, rc.left, rc.top,
                        lpName, cchName, dwFlags);
            }
        }
        break;

    case SS_BLACKFRAME:
        cmd = (COLOR_3DDKSHADOW << 3);
        goto StatFrame;

    case SS_GRAYFRAME:
        cmd = (COLOR_3DSHADOW << 3);
        goto StatFrame;

    case SS_WHITEFRAME:
        cmd = (COLOR_3DHILIGHT << 3);
StatFrame:
        DrawFrame(hdc, &rc, 1, cmd);
        break;

    case SS_BLACKRECT:
        hbrControl = SYSHBR(3DDKSHADOW);
        goto StatRect;

    case SS_GRAYRECT:
        hbrControl = SYSHBR(3DSHADOW);
        goto StatRect;

    case SS_WHITERECT:
        hbrControl = SYSHBR(3DHILIGHT);
StatRect:
        PaintRect(HW(pwndParent), hwnd, hdc, hbrControl, &rc);
        break;

    case SS_ETCHEDFRAME:
        DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT);
        break;
    }

    if (hfontOld) {
        SelectObject(hdc, hfontOld);
    }

    if (TestWF(pwnd, WEFRTLREADING)) {
        SetTextAlign(hdc, oldAlign);
    }

}


/***************************************************************************\
*
*  StaticRepaint()
*
\***************************************************************************/
VOID StaticRepaint(
    PSTAT pstat)
{
    PWND pwnd = pstat->spwnd;

    if (IsVisible(pwnd)) {
        HDC hdc;
        HWND hwnd = HWq(pwnd);

        if (hdc = NtUserGetDC(hwnd)) {
            xxxStaticPaint(pstat, hdc, TRUE);
            NtUserReleaseDC(hwnd, hdc);
        }
    }
}


/***************************************************************************\
*
*  StaticNotifyParent()
*
*  Sends WM_COMMAND notification messages.
*
\***************************************************************************/

// LATER mikeke why do we have multiple versions of notifyparent?

LRESULT FAR PASCAL StaticNotifyParent(
    PWND pwnd,
    PWND pwndParent,
    int  nCode)
{
    LRESULT lret;
    TL   tlpwndParent;

    UserAssert(pwnd);

    if (!pwndParent) {
        pwndParent = REBASEPWND(pwnd, spwndParent);
    }

    ThreadLock(pwndParent, &tlpwndParent);
    lret = SendMessage(HW(pwndParent), WM_COMMAND,
                       MAKELONG(PTR_TO_ID(pwnd->spmenu), nCode), (LPARAM)HWq(pwnd));
    ThreadUnlock(&tlpwndParent);

    return lret;
}

/***************************************************************************\
* StaticWndProc
*
* History:
\***************************************************************************/

LRESULT APIENTRY StaticWndProcWorker(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    BYTE bType;
    PSTAT pstat;
    static BOOL fInit = TRUE;

    CheckLock(pwnd);

    VALIDATECLASSANDSIZE(pwnd, FNID_STATIC);
    INITCONTROLLOOKASIDE(&StaticLookaside, STAT, spwnd, 8);

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_STATIC))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);

    /*
     * Get the pstat for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,0,pstat) when
     * we initially created the static control.
     */
    pstat = ((PSTATWND)pwnd)->pstat;

    /*
     * Get the control's type
     */
    bType = TestWF(pwnd, SFTYPEMASK);

    switch (message) {
    case STM_GETICON:
        wParam = IMAGE_ICON;

    case STM_GETIMAGE:
        if (IsValidImage(wParam, bType, IMAGE_STMMAX)) {
            return (LRESULT)pstat->hImage;
        }
        break;

    case STM_SETICON:
        lParam = (LPARAM)wParam;
        wParam = IMAGE_ICON;

    case STM_SETIMAGE:
        if (IsValidImage(wParam, bType, IMAGE_STMMAX)) {
            return (LRESULT)xxxSetStaticImage(pstat, (HANDLE)lParam, FALSE);
        }
        break;

    case WM_ERASEBKGND:

        /*
         * The control will be erased in xxxStaticPaint().
         */
        return TRUE;

    case WM_PRINTCLIENT:
        xxxStaticPaint(pstat, (HDC)wParam, FALSE);
        break;

    case WM_PAINT:
        {
            HDC         hdc;
            PAINTSTRUCT ps;

            if ((hdc = (HDC)wParam) == NULL) {
                hdc = NtUserBeginPaint(hwnd, &ps);
            }

            if (IsVisible(pwnd)) {
                xxxStaticPaint(pstat, hdc, !wParam);
            }

            /*
             * If hwnd was destroyed, BeginPaint was automatically undone.
             */
            if (!wParam) {
                NtUserEndPaint(hwnd, &ps);
            }
        }
        break;

    case WM_CREATE:

        if ((rgstk[bType] & STK_TYPE) == STK_IMAGE) {
            /*
             *  Pull the name from LPCREATESTRUCT like Win95 does
             */
            LPWSTR lpszName;
            LPSTR lpszAnsiName;
            struct {
                WORD tag;
                BYTE ordLo;
                BYTE ordHi;
            } dwUnicodeOrdinal;

            if (fAnsi) {
                /*
                 * Convert the ANSI string to unicode if it exists.
                 */
                lpszAnsiName = (LPSTR)((LPCREATESTRUCT)lParam)->lpszName;
                if (lpszAnsiName) {
                    if (lpszAnsiName[0] == (CHAR)0xff) {
                        /*
                         * Convert ANSI ordinal to UNICODE ordinal
                         */
                        dwUnicodeOrdinal.tag = 0xFFFF;
                        dwUnicodeOrdinal.ordLo = lpszAnsiName[1];
                        dwUnicodeOrdinal.ordHi = lpszAnsiName[2];
                        lpszName = (LPWSTR)&dwUnicodeOrdinal;
                    } else {
                        MBToWCSEx(0, lpszAnsiName, -1, &lpszName, -1, TRUE);
                    }
                } else {
                    lpszName = NULL;
                }
            } else {
                lpszName = (LPWSTR)(((LPCREATESTRUCT)lParam)->lpszName);
            }

            /*
             * Load the image
             */
            xxxStaticLoadImage(pstat, lpszName);

            if (fAnsi && lpszName && lpszName != (LPWSTR)&dwUnicodeOrdinal) {
                /*
                 * Free the converted ANSI string.
                 */
                UserLocalFree(lpszName);
            }
        } else if (bType == SS_ETCHEDHORZ || bType == SS_ETCHEDVERT) {
            /*
             * Resize static window to fit edge. Horizontal dudes make
             * bottom one edge from top, vertical dudes make right edge one
             * edge from left.
             */
            RECT rcClient;

            _GetClientRect(pwnd, &rcClient);
            if (bType == SS_ETCHEDHORZ) {
                rcClient.bottom = SYSMET(CYEDGE);
            } else {
                rcClient.right = SYSMET(CXEDGE);
            }

            NtUserSetWindowPos(hwnd,
                               HWND_TOP,
                               0,
                               0,
                               rcClient.right,
                               rcClient.bottom,
                               SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
        break;

    case WM_DESTROY:
        if (((rgstk[bType] & STK_TYPE) == STK_IMAGE) &&
            (pstat->hImage != NULL)                  &&
            (pstat->fDeleteIt)) {

            if (bType == SS_BITMAP) {
                DeleteObject(pstat->hImage);
            } else if (bType == SS_ICON) {
                if (pstat->cicur > 1) {
                    /*
                     *  Kill the animated cursor timer
                     */
                    NtUserKillTimer(hwnd, IDSYS_STANIMATE);
                }
                NtUserDestroyCursor((HCURSOR)(pstat->hImage), CURSOR_CALLFROMCLIENT);
            }
        }
        break;

    case WM_NCCREATE:
        if (TestWF(pwnd,WEFRIGHT)) {
            NtUserAlterWindowStyle(hwnd, SS_TYPEMASK, SS_RIGHT);
        }

        if (TestWF(pwnd, SFSUNKEN) ||
            ((bType == LOBYTE(SS_ETCHEDHORZ)) || (bType == LOBYTE(SS_ETCHEDVERT)))) {
            SetWindowState(pwnd, WEFSTATICEDGE);
        }
        goto CallDWP;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        if (pstat) {
            Unlock(&pstat->spwnd);
            FreeLookasideEntry(&StaticLookaside, pstat);
        }
        NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);
        break;

    case WM_NCHITTEST:
        return (TestWF(pwnd, SFNOTIFY) ? HTCLIENT : HTTRANSPARENT);

    case WM_LBUTTONDOWN:
    case WM_NCLBUTTONDOWN:
        if (TestWF(pwnd, SFNOTIFY)) {

            /*
             * It is acceptable for an app to destroy a static label
             * in response to a STN_CLICKED notification.
             */
            StaticNotifyParent(pwnd, NULL, STN_CLICKED);
        }
        break;

    case WM_LBUTTONDBLCLK:
    case WM_NCLBUTTONDBLCLK:
        if (TestWF(pwnd, SFNOTIFY)) {

            /*
             * It is acceptable for an app to destroy a static label in
             * response to a STN_DBLCLK notification.
             */
            StaticNotifyParent(pwnd, NULL, STN_DBLCLK);
        }
        break;

    case WM_SETTEXT:
        /*
         *  No more hack to set icon/bitmap via WM_SETTEXT!
         */
        if (rgstk[bType] & STK_USETEXT) {
            if (_DefSetText(hwnd, (LPWSTR)lParam, fAnsi)) {
                StaticRepaint(pstat);
                return TRUE;
            }
        }
        break;

    case WM_ENABLE:
        StaticRepaint(pstat);
        if (TestWF(pwnd, SFNOTIFY)) {
            StaticNotifyParent(pwnd, NULL, (wParam ? STN_ENABLE : STN_DISABLE));
        }
        break;

    case WM_GETDLGCODE:
        return (LONG)DLGC_STATIC;

    case WM_SETFONT:

        /*
         * wParam - handle to the font
         * lParam - if true, redraw else don't
         */
        if (rgstk[bType] & STK_USEFONT) {

            pstat->hFont = (HANDLE)wParam;

            if (lParam && TestWF(pwnd, WFVISIBLE)) {
                NtUserInvalidateRect(hwnd, NULL, TRUE);
                UpdateWindow(hwnd);
            }
        }
        break;

    case WM_GETFONT:
        if (rgstk[bType] & STK_USEFONT) {
            return (LRESULT)pstat->hFont;
        }
        break;

    case WM_TIMER:
        if (wParam == IDSYS_STANIMATE) {
            xxxNextAniIconStep(pstat);
        }
        break;

    /*
     *  case WM_GETTEXT:
     *  No more hack to get icon/bitmap via WM_GETTEXT!
     */

    case WM_INPUTLANGCHANGEREQUEST:
        if (IS_IME_ENABLED() || IS_MIDEAST_ENABLED()) {
            /*
             * #115190
             * If the window is one of controls on top of dialogbox,
             * let the parent dialog handle it.
             */
            if (TestwndChild(pwnd) && pwnd->spwndParent) {
                PWND pwndParent = REBASEALWAYS(pwnd, spwndParent);
                if (pwndParent) {
                    PCLS pclsParent = REBASEALWAYS(pwndParent, pcls);

                    UserAssert(pclsParent != NULL);
                    if (pclsParent->atomClassName == gpsi->atomSysClass[ICLS_DIALOG]) {
                        return SendMessageWorker(pwndParent, message, wParam, lParam, FALSE);
                    }
                }
            }
        }
        goto CallDWP;

    case WM_UPDATEUISTATE:
        {
            /*
             * DWP will change the UIState bits accordingly
             */
            DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);

            if (HIWORD(wParam) & UISF_HIDEACCEL) {
                /*
                 * Change in AccelHidden state: need to repaint
                 */
                if (ISSSTEXTOROD(bType)) {
                    pstat->fPaintKbdCuesOnly = TRUE;
                    StaticRepaint(pstat);
                    pstat->fPaintKbdCuesOnly = FALSE;
                }
            }
        }
        break;

    default:
CallDWP:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }

    return 0;
}


LRESULT WINAPI StaticWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return 0;
    }

    return StaticWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI StaticWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return 0;
    }

    return StaticWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}

/***************************************************************************\
* Next Animated Icon Step
*
* Advances to the next step in an animaged icon.
\***************************************************************************/
VOID xxxNextAniIconStep(
    PSTAT pstat)
{
    DWORD dwRate;
    PWND pwnd = pstat->spwnd;
    HWND hwnd = HWq(pwnd);

    /*
     * Stop the timer for the next animation step.
     */
    NtUserKillTimer(hwnd, IDSYS_STANIMATE);

    if (++(pstat->iicur) >= pstat->cicur) {
        pstat->iicur = 0;
    }

    GetCursorFrameInfo(pstat->hImage, NULL, pstat->iicur, &dwRate, &pstat->cicur);
    dwRate = max(200, dwRate * 100 / 6);

    NtUserInvalidateRect(hwnd, NULL, FALSE);
    UpdateWindow(hwnd);

    NtUserSetTimer(hwnd, IDSYS_STANIMATE, dwRate, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\winmgrc.c ===
/****************************** Module Header ******************************\
* Module Name: winmgrc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains
*
* History:
* 20-Feb-1992 DarrinM   Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define CONSOLE_WINDOW_CLASS (L"ConsoleWindowClass")

/***************************************************************************\
* GetWindowWord (API)
*
* Return a window word.  Positive index values return application window words
* while negative index values return system window words.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 20-Feb-1992 DarrinM   Wrote.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, WORD, DUMMYCALLINGTYPE, GetWindowWord, HWND, hwnd, int, index)
WORD GetWindowWord(
    HWND hwnd,
    int  index)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    /*
     * If it's a dialog window the window data is on the server side
     * We just call the "long" routine instead of have two thunks.
     * We know there is enough data if its DWLP_USER so we won't fault.
     */
    if (TestWF(pwnd, WFDIALOGWINDOW) && (index == DWLP_USER)) {
        return (WORD)_GetWindowLong(pwnd, index, FALSE);
    }

    return _GetWindowWord(pwnd, index);
}


BOOL FChildVisible(
    HWND hwnd)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    return (_FChildVisible(pwnd));
}


FUNCLOG4(LOG_GENERAL, BOOL, WINAPI, AdjustWindowRectEx, LPRECT, lpRect, DWORD, dwStyle, BOOL, bMenu, DWORD, dwExStyle)
BOOL WINAPI AdjustWindowRectEx(
    LPRECT lpRect,
    DWORD dwStyle,
    BOOL bMenu,
    DWORD dwExStyle)
{
    ConnectIfNecessary(0);

    return _AdjustWindowRectEx(lpRect, dwStyle, bMenu, dwExStyle);
}



FUNCLOG3(LOG_GENERAL, int, WINAPI, GetClassNameW, HWND, hwnd, LPWSTR, lpClassName, int, nMaxCount)
int WINAPI GetClassNameW(
    HWND hwnd,
    LPWSTR lpClassName,
    int nMaxCount)
{
    UNICODE_STRING strClassName;

    strClassName.MaximumLength = (USHORT)(nMaxCount * sizeof(WCHAR));
    strClassName.Buffer = lpClassName;
    return NtUserGetClassName(hwnd, FALSE, &strClassName);
}


HWND GetFocus(VOID)
{
    return (HWND)NtUserGetThreadState(UserThreadStateFocusWindow);
}


HWND GetCapture(VOID)
{
    /*
     * If no captures are currently taking place, just return NULL.
     */
    if (gpsi->cCaptures == 0) {
        return NULL;
    }
    return (HWND)NtUserGetThreadState(UserThreadStateCaptureWindow);
}

/***************************************************************************\
* AnyPopup (API)
*
*
*
* History:
* 12-Nov-1990 DarrinM   Ported.
\***************************************************************************/

BOOL AnyPopup(VOID)
{
    PWND pwnd = _GetDesktopWindow();

    for (pwnd = REBASEPWND(pwnd, spwndChild); pwnd; pwnd = REBASEPWND(pwnd, spwndNext)) {

        if ((pwnd->spwndOwner != NULL) && TestWF(pwnd, WFVISIBLE))
            return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* GetInputState
*
*
*
* History:
\***************************************************************************/

BOOL GetInputState(VOID)
{
    CLIENTTHREADINFO *pcti = GETCLIENTTHREADINFO();

    if ((pcti == NULL) || (pcti->fsChangeBits & (QS_MOUSEBUTTON | QS_KEY)))
        return (BOOL)NtUserGetThreadState(UserThreadStateInputState);

    return FALSE;
}

/***************************************************************************\
* MapWindowPoints
*
*
*
* History:
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, int, DUMMYCALLINGTYPE, MapWindowPoints, HWND, hwndFrom, HWND, hwndTo, LPPOINT, lppt, UINT, cpt)
int MapWindowPoints(
    HWND    hwndFrom,
    HWND    hwndTo,
    LPPOINT lppt,
    UINT    cpt)
{
    PWND pwndFrom;
    PWND pwndTo;

    if (hwndFrom != NULL) {

        if ((pwndFrom = ValidateHwnd(hwndFrom)) == NULL)
            return 0;

    } else {

        pwndFrom = NULL;
    }

    if (hwndTo != NULL) {


        if ((pwndTo = ValidateHwnd(hwndTo)) == NULL)
            return 0;

    } else {

        pwndTo = NULL;
    }

    return _MapWindowPoints(pwndFrom, pwndTo, lppt, cpt);
}

/***************************************************************************\
* GetLastActivePopup
*
*
*
* History:
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, GetLastActivePopup, HWND, hwnd)
HWND GetLastActivePopup(
    HWND hwnd)
{
    PWND pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return NULL;

    pwnd = _GetLastActivePopup(pwnd);

    return HW(pwnd);
}

/**************************************************************************\
* PtiWindow
*
* Gets the PTHREADINFO of window or NULL if not valid.
*
* 12-Feb-1997 JerrySh   Created.
\**************************************************************************/

PTHREADINFO PtiWindow(
    HWND hwnd)
{
    PHE phe;
    DWORD dw;
    WORD uniq;

    dw = HMIndexFromHandle(hwnd);
    if (dw < gpsi->cHandleEntries) {
        phe = &gSharedInfo.aheList[dw];
        if ((phe->bType == TYPE_WINDOW) && !(phe->bFlags & HANDLEF_DESTROY)) {
            uniq = HMUniqFromHandle(hwnd);
            if (   uniq == phe->wUniq
#if !defined(_WIN64) && !defined(BUILD_WOW6432)
                || uniq == 0
                || uniq == HMUNIQBITS
#endif
                ) {
                return phe->pOwner;
            }
        }
    }
    UserSetLastError(ERROR_INVALID_WINDOW_HANDLE);
    return NULL;
}

/***************************************************************************\
* GetWindowThreadProcessId
*
* Get's windows process and thread ids.
*
* 24-Jun-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, GetWindowThreadProcessId, HWND, hwnd, LPDWORD, lpdwProcessId)
DWORD GetWindowThreadProcessId(
    HWND    hwnd,
    LPDWORD lpdwProcessId)
{
    PTHREADINFO ptiWindow;
    DWORD dwThreadId;

    if ((ptiWindow = PtiWindow(hwnd)) == NULL)
        return 0;

    /*
     * For non-system threads get the info from the thread info structure
     */
    if (ptiWindow == PtiCurrent()) {

        if (lpdwProcessId != NULL)
            *lpdwProcessId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess);
        dwThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread);

    } else {

        /*
         * Make this better later on.
         */
        if (lpdwProcessId != NULL)
            *lpdwProcessId = HandleToUlong(NtUserQueryWindow(hwnd, WindowProcess));
        dwThreadId = HandleToUlong(NtUserQueryWindow(hwnd, WindowThread));
    }

    return dwThreadId;
}

/***************************************************************************\
* GetScrollPos
*
* Returns the current position of a scroll bar
*
* !!! WARNING a similiar copy of this code is in server\sbapi.c
*
* History:
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetScrollPos, HWND, hwnd, int, code)
int GetScrollPos(
    HWND hwnd,
    int  code)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    switch (code) {
    case SB_CTL:
        return (int)SendMessageWorker(pwnd, SBM_GETPOS, 0, 0, FALSE);

    case SB_HORZ:
    case SB_VERT:
        if (pwnd->pSBInfo != NULL) {
            PSBINFO pSBInfo = (PSBINFO)(REBASEALWAYS(pwnd, pSBInfo));
            return (code == SB_VERT) ? pSBInfo->Vert.pos : pSBInfo->Horz.pos;
        } else {
            RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
        }
        break;

    default:
        /*
         * Win3.1 validation layer code.
         */
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
    }

    return 0;
}

/***************************************************************************\
* GetScrollRange
*
* !!! WARNING a similiar copy of this code is in server\sbapi.c
*
* History:
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetScrollRange, HWND, hwnd, int, code, LPINT, lpposMin, LPINT, lpposMax)
BOOL GetScrollRange(
    HWND  hwnd,
    int   code,
    LPINT lpposMin,
    LPINT lpposMax)
{
    PSBINFO pSBInfo;
    PWND    pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return FALSE;

    switch (code) {
    case SB_CTL:
        SendMessageWorker(pwnd, SBM_GETRANGE, (WPARAM)lpposMin, (LPARAM)lpposMax, FALSE);
        return TRUE;

    case SB_VERT:
    case SB_HORZ:
        if (pSBInfo = REBASE(pwnd, pSBInfo)) {
            PSBDATA pSBData;
            pSBData = KPSBDATA_TO_PSBDATA((code == SB_VERT) ? &pSBInfo->Vert : &pSBInfo->Horz);
            *lpposMin = pSBData->posMin;
            *lpposMax = pSBData->posMax;
        } else {
            RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
            *lpposMin = 0;
            *lpposMax = 0;
        }

        return TRUE;

    default:
        /*
         * Win3.1 validation layer code.
         */
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        return FALSE;
    }
}


FUNCLOG4(LOG_GENERAL, int, DUMMYCALLINGTYPE, SetScrollInfo, HWND, hwnd, int, fnBar, LPCSCROLLINFO, lpsi, BOOL, fRedraw)
int SetScrollInfo(
    HWND            hwnd,
    int             fnBar,
    LPCSCROLLINFO   lpsi,
    BOOL            fRedraw)
{
    int ret;

    BEGIN_USERAPIHOOK()
        ret = guah.pfnSetScrollInfo(hwnd, fnBar, lpsi, fRedraw);
    END_USERAPIHOOK()

    return ret;
}


int RealSetScrollInfo(
    HWND            hwnd,
    int             fnBar,
    LPCSCROLLINFO   lpsi,
    BOOL            fRedraw)
{
    return NtUserSetScrollInfo(hwnd, fnBar, lpsi, fRedraw);
}



FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetScrollInfo, HWND, hwnd, int, code, LPSCROLLINFO, lpsi)
BOOL GetScrollInfo(
    HWND         hwnd,
    int          code,
    LPSCROLLINFO lpsi)
{
    int ret;

    BEGIN_USERAPIHOOK()
        ret = guah.pfnGetScrollInfo(hwnd, code, lpsi);
    END_USERAPIHOOK()

    return ret;
}

/***************************************************************************\
* RealGetScrollInfo
*
* !!! WARNING a similiar copy of this code is in server\winmgrc.c
*
\***************************************************************************/

BOOL RealGetScrollInfo(
    HWND         hwnd,
    int          code,
    LPSCROLLINFO lpsi)
{
    PWND    pwnd;
    PSBINFO pSBInfo;
    PSBDATA pSBData;

    if (lpsi->cbSize != sizeof(SCROLLINFO)) {

        if (lpsi->cbSize != sizeof(SCROLLINFO) - 4) {
            RIPMSG0(RIP_WARNING, "SCROLLINFO: Invalid cbSize");
            return FALSE;

        } else {
            RIPMSG0(RIP_WARNING, "SCROLLINFO: Invalid cbSize");
        }
    }

    if (lpsi->fMask & ~SIF_MASK) {
        RIPMSG0(RIP_WARNING, "SCROLLINFO: Invalid fMask");
        return FALSE;
    }

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return FALSE;

    switch (code) {
    case SB_CTL:
        SendMessageWorker(pwnd, SBM_GETSCROLLINFO, 0, (LPARAM)lpsi, FALSE);
        return TRUE;

    case SB_HORZ:
    case SB_VERT:
        if (pwnd->pSBInfo == NULL) {
            RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
            return FALSE;
        }

        /*
         * Rebase rgwScroll so probing will work
         */
        pSBInfo = (PSBINFO)REBASEALWAYS(pwnd, pSBInfo);

        pSBData = KPSBDATA_TO_PSBDATA((code == SB_VERT) ? &pSBInfo->Vert : &pSBInfo->Horz);

        return(NtUserSBGetParms(hwnd, code, pSBData, lpsi));

    default:
        /*
         * Win3.1 validation layer code.
         */
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        return FALSE;
    }
}

/****************************************************************************\
* _GetActiveWindow (API)
*
*
* 23-Oct-1990 MikeHar   Ported from Windows.
* 12-Nov-1990 DarrinM   Moved from getset.c to here.
\****************************************************************************/

HWND GetActiveWindow(VOID)
{
    return (HWND)NtUserGetThreadState(UserThreadStateActiveWindow);
}

/****************************************************************************\
* GetCursor
*
*
* History:
\****************************************************************************/

HCURSOR GetCursor(VOID)
{
    return (HCURSOR)NtUserGetThreadState(UserThreadStateCursor);
}

/***************************************************************************\
* BOOL IsMenu(HMENU);
*
* Verifies that the handle passed in is a menu handle.
*
* Histroy:
* 10-Jul-1992 MikeHar   Created.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsMenu, HMENU, hMenu)
BOOL IsMenu(
   HMENU hMenu)
{
   if (HMValidateHandle(hMenu, TYPE_MENU))
      return TRUE;

   return FALSE;
}

/***************************************************************************\
* GetAppCompatFlags
*
* Compatibility flags for < Win 3.1 apps running on 3.1
*
* History:
* 01-Apr-1992 ScottLu   Created.
* 04-May-1992 DarrinM   Moved to USERRTL.DLL.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, GetAppCompatFlags, PTHREADINFO, pti)
DWORD GetAppCompatFlags(
    PTHREADINFO pti)
{
    UNREFERENCED_PARAMETER(pti);

    ConnectIfNecessary(0);

    return GetClientInfo()->dwCompatFlags;
}

/***************************************************************************\
* GetAppCompatFlags2
*
* Compatibility flags for <= wVer apps.  Newer apps will get no hacks
* from this DWORD.
*
* History:
* 06-29-98 MCostea      Created.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, GetAppCompatFlags2, WORD, wVer)
DWORD GetAppCompatFlags2(
    WORD wVer)
{
    ConnectIfNecessary(0);
    /*
     * Newer apps should behave, so they get no hacks
     */
    if (wVer < GETAPPVER()) {
        return 0;
    }
    return GetClientInfo()->dwCompatFlags2;
}

/**************************************************************************\
* IsWindowUnicode
*
* 25-Feb-1992 IanJa     Created
\**************************************************************************/

BOOL IsWindowUnicode(
    IN HWND hwnd)
{
    PWND pwnd;


    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return FALSE;

    return !TestWF(pwnd, WFANSIPROC);
}

/**************************************************************************\
* TestWindowProcess
*
* 14-Nov-1994 JimA      Created.
\**************************************************************************/

BOOL TestWindowProcess(
    PWND pwnd)
{
    /*
     * If the threads are the same, don't bother going to the kernel
     * to get the window's process id.
     */
    if (GETPTI(pwnd) == PtiCurrent()) {
        return TRUE;
    }

    return (GetWindowProcess(HW(pwnd)) == GETPROCESSID());
}

/**************************************************************************\
* IsHungAppWindow
*
* 11-14-94 JimA         Created.
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsHungAppWindow, HWND, hwnd)
BOOL IsHungAppWindow(
    HWND hwnd)
{
    return (NtUserQueryWindow(hwnd, WindowIsHung) != NULL);
}

/***************************************************************************\
* CreateSystemThreads
*
* Simply calls xxxCreateSystemThreads, which will call the appropriate
* thread routine (depending on uThreadID).
*
* History:
* 20-Aug-00 MSadek      Created.
\***************************************************************************/
WINUSERAPI
DWORD
WINAPI
CreateSystemThreads (
    LPVOID pUnused)
{
    UNREFERENCED_PARAMETER(pUnused);

    NtUserCallOneParam(TRUE, SFI_XXXCREATESYSTEMTHREADS);
    ExitThread(0);
}

/***************************************************************************\
* PtiCurrent
*
* Returns the THREADINFO structure for the current thread.
* LATER: Get DLL_THREAD_ATTACH initialization working right and we won't
*        need this connect code.
*
* History:
* 10-28-90 DavidPe      Created.
\***************************************************************************/

PTHREADINFO PtiCurrent(VOID)
{
    ConnectIfNecessary(0);
    return (PTHREADINFO)NtCurrentTebShared()->Win32ThreadInfo;
}


/***************************************************************************\
* _AdjustWindowRectEx (API)
*
*
*
* History:
* 10-24-90 darrinm      Ported from Win 3.0.
\***************************************************************************/

BOOL _AdjustWindowRectEx(
    LPRECT lprc,
    DWORD style,
    BOOL fMenu,
    DWORD dwExStyle)
{
    BOOL ret;

    BEGIN_USERAPIHOOK()
        ret = guah.pfnAdjustWindowRectEx(lprc, style, fMenu, dwExStyle);
    END_USERAPIHOOK()

    return ret;
}


BOOL RealAdjustWindowRectEx(
    LPRECT lprc,
    DWORD style,
    BOOL fMenu,
    DWORD dwExStyle)
{
    //
    // Here we add on the appropriate 3D borders for old and new apps.
    //
    // Rules:
    //   (1) Do nothing for windows that have 3D border styles.
    //   (2) If the window has a dlgframe border (has a caption or is a
    //          a dialog), then add on the window edge style.
    //   (3) We NEVER add on the CLIENT STYLE.  New apps can create
    //          it if they want.  This is because it screws up alignment
    //          when the app doesn't know about it.
    //

    if (NeedsWindowEdge(style, dwExStyle, GETAPPVER() >= VER40))
        dwExStyle |= WS_EX_WINDOWEDGE;
    else
        dwExStyle &= ~WS_EX_WINDOWEDGE;

    //
    // Space for a menu bar
    //
    if (fMenu)
        lprc->top -= SYSMET(CYMENU);

    //
    // Space for a caption bar
    //
    if ((HIWORD(style) & HIWORD(WS_CAPTION)) == HIWORD(WS_CAPTION)) {
        lprc->top -= (dwExStyle & WS_EX_TOOLWINDOW) ? SYSMET(CYSMCAPTION) : SYSMET(CYCAPTION);
    }

    //
    // Space for borders (window AND client)
    //
    {
        int cBorders;

        //
        // Window AND Client borders
        //

        if (cBorders = GetWindowBorders(style, dwExStyle, TRUE, TRUE))
            InflateRect(lprc, cBorders*SYSMET(CXBORDER), cBorders*SYSMET(CYBORDER));
    }

    return TRUE;
}

/***************************************************************************\
* ShowWindowNoRepaint
\***************************************************************************/

void ShowWindowNoRepaint(PWND pwnd)
{
    HWND hwnd = HWq(pwnd);
    PCLS pcls = REBASE(pwnd, pcls);
    NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE |
            SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER |
            SWP_NOREDRAW | SWP_SHOWWINDOW | SWP_NOACTIVATE |
            ((pcls->style & CS_SAVEBITS) ? SWP_CREATESPB : 0));
}

/***************************************************************************\
* AnimateBlend
*
* 6-Mar-1997    vadimg      created
\***************************************************************************/

#define ALPHASTART 40
#define ONEFRAME 10

BOOL AnimateBlend(PWND pwnd, HDC hdcScreen, HDC hdcImage, DWORD dwTime, BOOL fHide, BOOL fActivateWindow)
{
    HWND hwnd = HWq(pwnd);
    SIZE size;
    POINT ptSrc = {0, 0}, ptDst;
    BLENDFUNCTION blend;
    DWORD dwElapsed;
    BYTE bAlpha = ALPHASTART;
    LARGE_INTEGER liFreq, liStart, liDiff;
    LARGE_INTEGER liIter;
    DWORD dwIter;
    BOOL fFirstFrame = TRUE;

    if (QueryPerformanceFrequency(&liFreq) == 0)
        return FALSE;

    SetLastError(0);

    SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE) | WS_EX_LAYERED);

    if (GetLastError() != 0) {
        return FALSE;
    }

    if (fHide) {
        /*
         * Give up the time slice and sleep just a touch to allow windows
         * below invalidated by the SetWindowLong(WS_EX_LAYERED) call to
         * repaint enough for the sprite to get good background image.
         */
        Sleep(10);
    }

    ptDst.x = pwnd->rcWindow.left;
    ptDst.y = pwnd->rcWindow.top;
    size.cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
    size.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

    blend.BlendOp     = AC_SRC_OVER;
    blend.BlendFlags  = 0;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = fHide ? (255 - bAlpha) : bAlpha;

    /*
     * Copy the initial image with the initial alpha.
     */
    NtUserUpdateLayeredWindow(hwnd, NULL, &ptDst, &size, hdcImage, &ptSrc, 0,
            &blend, ULW_ALPHA);

    if (!fHide) {
        ShowWindowNoRepaint(pwnd);
    }

    /*
     * Time and start the animation cycle.
     */
    dwElapsed = (dwTime * ALPHASTART + 255) / 255 + 10;
    QueryPerformanceCounter(&liStart);
    liStart.QuadPart = liStart.QuadPart - dwElapsed * liFreq.QuadPart / 1000;

    while (dwElapsed < dwTime) {

        if (fHide) {
            blend.SourceConstantAlpha = (BYTE)((255 * (dwTime - dwElapsed)) / dwTime);
        } else {
            blend.SourceConstantAlpha = (BYTE)((255 * dwElapsed) / dwTime);
        }

        QueryPerformanceCounter(&liIter);

        if (fFirstFrame && fActivateWindow) {
            NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                               SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER);
        }
        fFirstFrame = FALSE;

        NtUserUpdateLayeredWindow(hwnd, NULL, NULL, NULL, NULL, NULL, 0,
                &blend, ULW_ALPHA);

        QueryPerformanceCounter(&liDiff);

        /*
         * Calculate how long in ms the previous frame took.
         */
        liIter.QuadPart = liDiff.QuadPart - liIter.QuadPart;
        dwIter = (DWORD)((liIter.QuadPart * 1000) / liFreq.QuadPart);

        if (dwIter < ONEFRAME) {
            Sleep(ONEFRAME - dwIter);
        }

        liDiff.QuadPart -= liStart.QuadPart;
        dwElapsed = (DWORD)((liDiff.QuadPart * 1000) / liFreq.QuadPart);
    }

    /*
     * Hide the window before removing the layered bit to make sure that
     * the bits for the window are not left on the screen.
     */
    if (fHide) {
        NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_HIDEWINDOW |
                SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE) &
            ~WS_EX_LAYERED);

    if (!fHide) {
        BitBlt(hdcScreen, 0, 0, size.cx, size.cy, hdcImage, 0, 0, SRCCOPY | NOMIRRORBITMAP);
    }

    return TRUE;
}


/***************************************************************************\
* TakeWindowSnapshot
*
* Helper routine to grab the visual appearance of a window to a bitmap.
*
\***************************************************************************/
HBITMAP TakeWindowSnapshot(HWND hwnd, HDC hdcWindow, HDC hdcSnapshot)
{
    PWND pwnd;
    int cx;
    int cy;
    HBITMAP hbmOld, hbmSnapshot;
    BOOL fOK = FALSE;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL)
        return NULL;
    cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
    cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

    hbmSnapshot = CreateCompatibleBitmap(hdcWindow, cx, cy);
    if (hbmSnapshot == NULL) {
        return NULL;
    }

    hbmOld = SelectObject(hdcSnapshot, hbmSnapshot);

    /*
     * Try redirection first.
     */
    /*
    if (NtUserPrintWindow(hwnd, hdcSnapshot, 0)) {
        fOK = TRUE;
    } else */ {
        /*
         * We failed to redirect the window!  This can be caused by windows
         * with class or parent DCs.  Maybe other reasons as well.  Revert to
         * the old way of sending a WM_PRINT to the window.
         */
        
        UINT uBounds;
        RECT rcBounds;
        DWORD dwOldLayout = GDI_ERROR;
        BOOL fError = TRUE;

        /*
         * The WM_PRINT message expects a "normal" layout setting on the DC.
         * The message will handle RTL stuff itself.
         */
        dwOldLayout = SetLayout(hdcSnapshot, 0);

        /*
         * Clear the dirty bounds so we can tell if anything was painted.
         */
        SetBoundsRect(hdcSnapshot, NULL, DCB_RESET | DCB_ENABLE);

        /*
         * Get the actual image. The windows participating here must implement
         * WM_PRINTCLIENT or they will look ugly.
         */
        SendMessage(hwnd, WM_PRINT, (WPARAM)hdcSnapshot, PRF_CLIENT | PRF_NONCLIENT | PRF_CHILDREN | PRF_ERASEBKGND);

        /*
         * Check to see if the app painted in our DC.  We do this by checking to
         * see if the bounding rect of operations performed on the DC is set.
         */
        uBounds = GetBoundsRect(hdcSnapshot, &rcBounds, 0);
        if ((uBounds & DCB_RESET) && (!(uBounds & DCB_ACCUMULATE))) {
            goto Cleanup;
        }
    
        fOK = TRUE;

Cleanup:
        SetLayout(hdcSnapshot, dwOldLayout);
    }

    SelectObject(hdcSnapshot, hbmOld);

    if (!fOK) {
        DeleteObject(hbmSnapshot);
        hbmSnapshot = NULL;
    }

    return hbmSnapshot;
}

/***************************************************************************\
* AnimateWindow (API)
*
* Hide animations are done by updating a la full-drag.  Uses window's window
* region to do some of the magic.
*
* We have to put in the CLIPCHILDREN hack to work around a bug with the
* DC cache resetting attributes even if DCX_USESTYLE is not used whe
* the DC cache is invalidated.
*
* History:
* 9-Sep-1996    vadimg      created
\***************************************************************************/

#define AW_HOR          (AW_HOR_POSITIVE | AW_HOR_NEGATIVE | AW_CENTER)
#define AW_VER          (AW_VER_POSITIVE | AW_VER_NEGATIVE | AW_CENTER)

__inline int AnimInc(int x, int y, int z)
{
    return MultDiv(x, y, z);
}

__inline int AnimDec(int x, int y, int z)
{
    return x - AnimInc(x, y, z);
}


FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, AnimateWindow, HWND, hwnd, DWORD, dwTime, DWORD, dwFlags)
BOOL WINAPI AnimateWindow(HWND hwnd, DWORD dwTime, DWORD dwFlags)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    HDC hdc = NULL, hdcMem = NULL;
    PCLS pcls = NULL;
    HRGN hrgnOriginal = NULL, hrgnUpdate = NULL, hrgnOldAnim = NULL, hrgnAnim = NULL;
    HBITMAP hbmMem = NULL, hbmOld;
    BOOL fHide = dwFlags & AW_HIDE, fRet = FALSE, fSlide = dwFlags & AW_SLIDE;
    BOOL fRestoreClipChildren = FALSE;
    BOOL fRestoreOriginalRegion = FALSE;
    BOOL fShowWindow = FALSE;
    BOOL fHideWindow = FALSE;
    BOOL fActivateWindow = FALSE;
    BOOL fFirstFrame = TRUE;
    BOOL fRedrawParentWindow = FALSE;
    HWND hwndParent;
    int x, y, nx, ny, cx, cy, ix, iy, ixLast, iyLast, xWin, yWin;
    int xReal, yReal, xMem, yMem, xRgn, yRgn;
    DWORD dwStart, dwElapsed;
    RECT rcAnim, rcWin;
    PWND pwnd;
    BOOL fRTL = FALSE;

#if DBG
    int cAnimationFrames = 0;
    DWORD dwElapsed2 = 0;
#endif

    /*
     * Check to see if we have nothing to do or the flags didn't validate.
     */
    if ((dwFlags & ~AW_VALID) != 0 ||
        (dwFlags & (AW_HOR_POSITIVE | AW_HOR_NEGATIVE | AW_CENTER | AW_VER_POSITIVE | AW_VER_NEGATIVE | AW_BLEND)) == 0)
        return FALSE;
    
    /*
     * Convert the HWND to a PWND.  Fail if this is an invalid window.
     */
    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL)
        return FALSE;

    /*
     * The animation effect is applied to a window that is changing from being
     * hidden to being visible, or from being visible to being hidden.  If the
     * window is already in the final state, there is nothing to do.
     */
    if (!IsWindowVisible(hwnd)) {
        if (fHide) {
            return FALSE;
        }
    } else {
        if (!fHide) {
            return FALSE;
        }
    }

    /*
     * Grab a DC for this window.
     */
    if ((hdc = GetDCEx(hwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE)) == NULL) {
        return FALSE;
    }
    fRTL = (GetLayout(hdc) & LAYOUT_RTL) ? TRUE : FALSE;

    /*
     * ----------------------------------------------------------------------
     * After this point, we will not return directly.  Instead, we will fall
     * out through the cleanup section at the bottom!  Up until this point
     * we may have bailed out for any number of easily-detected problems.
     * From now on, we have resources we'll need to clean up.
     * ----------------------------------------------------------------------
     */
 
    /*
     * Remember to hide/show/activate the window as requested.
     */
    if (dwFlags & AW_HIDE) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Need to hide window");
        fHideWindow = TRUE;
    } else {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Need to show window");
        fShowWindow = TRUE;
    }
    if (dwFlags & AW_ACTIVATE) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Need to activate window");
        fActivateWindow = TRUE;
    }

    /*
     * If this is a child window we are animating, then we may need to
     * repaint the parent every time we move the child so that the
     * background can be refreshed.
     */
    if (TestWF(pwnd, WFCHILD) && (pwnd->spwndParent != NULL)) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Animating a child window" );
        if (dwFlags & AW_BLEND) {
            TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Can not fade a child window!" );
            goto Cleanup;
        }
        fRedrawParentWindow = TRUE;
        hwndParent = HW(_GetParent(pwnd));
    }

    /*
     * In the process of animating the window, we are going to draw directly
     * on top of the window region ourselves.  As such, we don't want any
     * "holes" in the window region due to it clipping out the children.  But
     * we will need to restore this setting when we are all done, so we set
     * a flag here and check it at the end.
     */
    if (TestWF(pwnd, WFCLIPCHILDREN)) {
        fRestoreClipChildren = TRUE;
        ClearWindowState(pwnd, WFCLIPCHILDREN);
    }

    /*
     * Remember the original window region.  We will restore this when we are
     * all done.
     */
    if (pwnd->hrgnClip != NULL) {
        hrgnOriginal = CreateRectRgn(0, 0, 0, 0);
        if (hrgnOriginal == NULL) {
            goto Cleanup;
        }

        if (GetWindowRgn(hwnd, hrgnOriginal) == ERROR) {
            goto Cleanup;
        }
    }
    fRestoreOriginalRegion = TRUE;

    /*
     * Precreate the regions we use.
     */
    if (((hrgnUpdate = CreateRectRgn(0, 0, 0, 0)) == NULL) ||
        ((hrgnOldAnim = CreateRectRgn(0, 0, 0, 0)) == NULL)) {
        goto Cleanup;
    }

    rcWin = pwnd->rcWindow;
    xWin = rcWin.left;
    yWin = rcWin.top;
    cx = rcWin.right - rcWin.left;
    cy = rcWin.bottom - rcWin.top;

    /*
     * Initialize the "old" animation region to be:
     * 1) Empty, if the window is being show.
     * 2) Full, if the window is being hiddem.
     */
    if (fHide) {
        if (hrgnOriginal != NULL) {
            if (CombineRgn(hrgnOldAnim, hrgnOriginal, NULL, RGN_COPY) == ERROR) {
                goto Cleanup;
            }
        } else {
            if (SetRectRgn(hrgnOldAnim, 0, 0, cx, cy) == 0) {
                goto Cleanup;
            }
        }
    } else {
        if (SetRectRgn(hrgnOldAnim, 0, 0, 0, 0) == 0) {
            goto Cleanup;
        }
    }


    /*
     * The window needs to be visible since we are going to be drawing parts
     * of it.  If the window is being hidden, then it is currently visible.
     * If the window is being shown, then we go ahead and make it visible
     * now but we don't repaint it.
     */
    if (!(dwFlags & AW_BLEND)) {
        HRGN hrgnWin = NULL;

        /*
         * Set window region to nothing, so that if the window draws during
         * callbacks in WM_PRINT, it doesn't happen on screen.
         */
        if ((hrgnWin = CreateRectRgn(0, 0, 0, 0)) == NULL) {
            goto Cleanup;
        }
        RealSetWindowRgn(hwnd, hrgnWin, FALSE);
    
        if (!fHide) {
            ShowWindowNoRepaint(pwnd);
            fShowWindow = FALSE;
        }
    }    

    /*
     * Set up an offscreen DC, and back it to a bitmap.  We will use this to
     * capture the visual representation of the window being animated.
     */
    if ((hdcMem = CreateCompatibleDC(hdc)) == NULL) {
        goto Cleanup;
    }
    hbmMem = TakeWindowSnapshot(hwnd, hdc, hdcMem);
    if (hbmMem != NULL) {
        /*
         * If the window changed its size while we were taking a snapshot,
         * we need to do it again.  For instance, like RAID does with
         * combo boxes by resizing them on WM_CTLCOLOR from WM_ERASEBKGND.
         */
        if (!EqualRect(&rcWin, KPRECT_TO_PRECT(&pwnd->rcWindow))) {
            /*
             * Update all of our variables taking into account the new size.
             */
            TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Size change on paint!");
            TAGMSG4(DBGTAG_AnimateWindow, "AnimateWindow: Old = (%d,%d)-(%d,%d)", rcWin.left, rcWin.top, rcWin.right, rcWin.bottom);
            rcWin = pwnd->rcWindow;
            TAGMSG4(DBGTAG_AnimateWindow, "AnimateWindow: New = (%d,%d)-(%d,%d)", rcWin.left, rcWin.top, rcWin.right, rcWin.bottom);
            xWin = rcWin.left;
            yWin = rcWin.top;
            cx = rcWin.right - rcWin.left;
            cy = rcWin.bottom - rcWin.top;

            if (hrgnOriginal != NULL) {
                if (GetWindowRgn(hwnd, hrgnOriginal) == ERROR) {
                    goto Cleanup;
                }
            }

            /*
             * Initialize the "old" animation region to be:
             * 1) Empty, if the window is being show.
             * 2) Full, if the window is being hiddem.
             */
            if (fHide) {
                if (hrgnOriginal != NULL) {
                    if (CombineRgn(hrgnOldAnim, hrgnOriginal, NULL, RGN_COPY) == ERROR) {
                        goto Cleanup;
                    }
                } else {
                    if (SetRectRgn(hrgnOldAnim, 0, 0, cx, cy) == 0) {
                        goto Cleanup;
                    }
                }
            } else {
                if (SetRectRgn(hrgnOldAnim, 0, 0, 0, 0) == 0) {
                    goto Cleanup;
                }
            }

            DeleteObject(hbmMem);
            hbmMem = TakeWindowSnapshot(hwnd, hdc, hdcMem);
        }

        if (hbmMem != NULL) {
            hbmOld = SelectBitmap(hdcMem, hbmMem);
        } else {
            goto Cleanup;
        }
    } else {
        goto Cleanup;
    }

    /*
     * Use the default animation duration if the caller didn't specify it.
     */
    if (dwTime == 0) {
        dwTime = CMS_QANIMATION;
    }

    /*
     * If we are doing an alpha blend animation, call a separate routine to
     * do it and then return.
     */
    if (dwFlags & AW_BLEND) {
        fRet = AnimateBlend(pwnd, hdc, hdcMem, dwTime, fHide, fActivateWindow);
        if (fRet) {
            fHideWindow = FALSE;
            fShowWindow = FALSE;
        }
        goto Cleanup;
    }

    /*
     * Our central animation routine uses an equation to update the new
     * position of the window during the animation.  This equation uses some
     * variables so that it is configurable.
     *
     * x and y describe where the left and top edges are caluclated relative
     * to.  xReal and yReal are the result of that calculation.
     *
     * nx and ny are used to control in which direction the the top and left
     * edges are offset from x and y.  The left/top edges are either fixed in
     * place (nx and ny are set to 0), or are calculated as a negative offset
     * from the right/bottom edges (nx and ny are set to -1).
     *
     * ix, and iy are the amount of the width and height that the
     * animation should be showing at a particular iteration through the
     * loop.  If we are showing the window, this amount starts at
     * 0 and increments towards the window's true dimension.  If we are
     * hiding a window, this amount starts at the window's true dimension
     * and decrements towards 0.
     */
    ix = iy = 0;
    ixLast = fHide ? cx : 0; // The opposite condition of what signals we're done.
    iyLast = fHide ? cy : 0; // The opposite condition of what signals we're done.

    if (dwFlags & AW_CENTER) {
        /*
         * Expand the window from the center.  The left edge is calculated as
         * a negative offset from the center.  As the width either grows or
         * shrinks, the left edge will be repositioned.
         */
        x = cx / 2;
        nx = -1;
        fSlide = FALSE;
    } else if (dwFlags & AW_HOR_POSITIVE) {
        if (fHide) {
            /*
             * Slide/Roll to the right.  The left edge moves to the right, and
             * the right edge stays put.  Thus, the width gets smaller.  The
             * left edge is calculated as a negative offset from the right
             * edge.
             */
            x = cx;
            nx = -1;
        } else {
            /*
             * Slide/Roll to the right.  The left edge stays put, and the right
             * edge moves to the right.  Thus, the width gets bigger.  The
             * left edge is always 0.
             */
            x = 0;
            nx = 0;
        }
    } else if (dwFlags & AW_HOR_NEGATIVE) {
        if (fHide) {
            /*
             * Slide/Roll to the left.  The left edge stays put, and the right
             * edge moves to the left.  Thus, the width gets smaller.  The
             * left edge is always 0.
             */
            x = 0;
            nx = 0;
        } else {
            /*
             * Slide/Roll to the left.  The left edge moves to the left, and
             * the right edge stays put.  Thus, the width gets bigger.
             * The left edge is calculated as a negative offset from the right
             * edge.
             */
            x = cx;
            nx = -1;
        }
    } else {
        /*
         * There is not supposed to be any horizontal animation.  The
         * animation is always as wide as the window.
         */
        x = 0;
        nx = 0;
        ix = cx;
    }

    if (dwFlags & AW_CENTER) {
        /*
         * Expand the window from the center.  The top edge is calculated as
         * a negative offset from the center.  As the height either grows or
         * shrinks, the top edge will be repositioned.
         */
        y = cy / 2;
        ny = -1;
    } else if (dwFlags & AW_VER_POSITIVE) {
        if (fHide) {
            /*
             * Slide/Roll down.  The top edge moves down, and the bottom
             * edge stays put.  Thus, the height gets smaller.  The top edge
             * is calculated as a negative offset from the bottom edge.
             */
            y = cy;
            ny = -1;
        } else {
            /*
             * Slide/Roll down.  The top edge stays put, and the bottom edge
             * moves down.  Thus, the height gets bigger.  The top edge is
             * always 0.
             */
            y = 0;
            ny = 0;
        }
    } else if (dwFlags & AW_VER_NEGATIVE) {
        if (fHide) {
            /*
             * Slide/Roll up.  The top edge stays put, and the bottom edge
             * moves up.  Thus, the height gets smaller.  The top edge is
             * always 0.
             */
            y = 0;
            ny = 0;
        } else {
            /*
             * Slide/Roll up.  The top edge moves up, and the bottom edge
             * stays put.  Thus, the height gets bigger.  The top edge is
             * calculated as a negative offset from the bottom edge.
             */
            y = cy;
            ny = -1;
        }
    } else {
        /*
         * There is not supposed to be any vertical animation.  The
         * animation is always as tall as the window.
         */
        y = 0;
        ny = 0;
        iy = cy;
    }

    /*
     * Summary of the animation loop:
     *
     * We sit in a tight loop and update the positions of the left and
     * top edges of the window, as well as the width and height.  We set
     * a window region with these dimensions on the window so that windows
     * behind it will be updated properly.  Then we draw the cached snapshot
     * of the window on top of (and clipped to) this region.
     *
     * dwTime is the amount of time the animation should take.  dwStart
     * was the value of the internal tick counter when we started the
     * animation loop.  dwElapsed counts how many ticks (nilliseconds)
     * have passed at the start of each pass through the animation loop.
     *
     * ixLast and iyLast are simply the values of ix and iy the last
     * time we went through the loop.  If these are the same, there is
     * no work to be done, and we force our thread to be rescheduled by
     * calling Sleep(1).
     */
    dwStart = GetTickCount();

#if DBG
    cAnimationFrames = 0;
#endif

    while (TRUE) {
        dwElapsed = GetTickCount() - dwStart;

        /*
         * Calculate the amount of the window width we should be showing.
         */
        if (dwFlags & AW_HOR) {
            ix = (fHide ? AnimDec : AnimInc)(cx, dwElapsed, dwTime);
        }

        /*
         * Calculate the amount of the window height we should be showing.
         */
        if (dwFlags & AW_VER) {
            iy = (fHide ? AnimDec : AnimInc)(cy, dwElapsed, dwTime);
        }

        /*
         * We have exceeded our time, make sure we draw the final frame.
         */
        if (dwElapsed > dwTime) {
            TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Exceeded animation time. Drawing fimal frame.");
            ix = fHide ? 0 : cx;
            iy = fHide ? 0 : cy;
        }
        
        if (ixLast == ix && iyLast == iy) {
            /*
             * There was no change in the amount of the window we are
             * supposed to show since last time.  Chances are we are
             * being animated really slowly or a short distance.  Either
             * way, sitting in this tight loop is kind of a waste.  So
             * force the thread to get rescheduled.
             */
            TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Drawing frames faster than needed. Sleeping." );
            Sleep(1);
        } else {
            /*
             * Calculate the new positions of the left and top edges of the
             * window being animated.
             */
            if (dwFlags & AW_CENTER) {
                xReal = x + nx * (ix / 2);
                yReal = y + ny * (iy / 2);
            } else {
                xReal = x + nx * ix;
                yReal = y + ny * iy;
            }

            /*
             * Calculate new animation dimensions on the screen.
             */
            rcAnim.left = xReal;
            rcAnim.top = yReal;
            rcAnim.right = rcAnim.left + ix;
            rcAnim.bottom = rcAnim.top + iy;

            TAGMSG5(DBGTAG_AnimateWindow, "AnimateWindow: Frame %d = (%d,%d)-(%d,%d)", cAnimationFrames, rcAnim.left, rcAnim.top, rcAnim.right, rcAnim.bottom);

            /*
             * Calculate the offset of this animation rectangle in the bitmap.
             */
            if (fSlide) {
                if (dwFlags & AW_HOR_POSITIVE) {
                    xMem = fHide ? 0: cx - ix;
                } else if (dwFlags & AW_HOR_NEGATIVE) {
                    xMem = fHide ? cx - ix : 0;
                } else {
                    xMem = xReal;
                }
                xRgn = xMem ? -xMem : xReal;

                if (dwFlags & AW_VER_POSITIVE) {
                    yMem = fHide ? 0 : cy - iy;
                } else if (dwFlags & AW_VER_NEGATIVE) {
                    yMem = fHide ? cy - iy : 0;
                } else {
                    yMem = yReal;
                }

                yRgn = yMem ? -yMem : yReal;
            } else {
                xMem = xReal;
                yMem = yReal;
                xRgn = 0;
                yRgn = 0;
            }

            /*
             * Create a new region that spans the animation rectangle.  We
             * have to create a new region every time because when we set
             * it into the window, the system will take ownership of it.
             */
            hrgnAnim = CreateRectRgnIndirect(&rcAnim);
            if (hrgnAnim == NULL) {
                goto Cleanup;
            }

            /*
             * If the original window had a region, we need to merge it
             * with the animation rectangle.  We may have to offset the
             * original region to accomplish effects like slides.
             */
            if (hrgnOriginal != NULL) {
                if (OffsetRgn(hrgnOriginal, xRgn, yRgn) == ERROR) {
                    goto Cleanup;
                }
                if (CombineRgn(hrgnAnim, hrgnOriginal, hrgnAnim, RGN_AND) == ERROR) {
                    goto Cleanup;
                }
                if (OffsetRgn(hrgnOriginal, -xRgn, -yRgn) == ERROR) {
                    goto Cleanup;
                }
            }

            /*
             * Now calculate how much of the screen (ie desktop window)
             * we need to update.  All we really need to paint is the
             * difference in the new animation region and the old
             * animation region.  Note that we have to convert to
             * coordinates in the regions to be relative to the desktop
             * window instead of being relative to the window being
             * animated.
             */
            if (CombineRgn(hrgnUpdate, hrgnOldAnim, hrgnAnim, RGN_DIFF) == ERROR) {
                goto Cleanup;
            }
            if (fRTL) {
                MirrorRgn(hwnd, hrgnUpdate);
            }
            if (OffsetRgn(hrgnUpdate, xWin, yWin) == ERROR) {
                goto Cleanup;
            }

            /*
             * The system will own the region when we set it into the
             * window.  We need to keep it around so that we can
             * calculate the update region on the next pass through
             * the animation loop.  So we make a copy.
             */
            if (CombineRgn(hrgnOldAnim, hrgnAnim, NULL, RGN_COPY) == ERROR) {
                goto Cleanup;
            }

            /*
             * Set the window region.  Note that we haven't actually moved
             * the window.  And that the coordinates in the region are all
             * relative to the window.  After this call, the system owns
             * the hrgnAnim.  Then repaint the update region of the
             * DESKTOP window.  This is the region under/around the window
             * that we have exposed.
             *
             * Note: We use the RealSetWindowRgn to work around theming.
             * The theming system will hook the standard SetWindowRgn API
             * and revoke the theming of the window since it detects us
             * setting our own region.  The idea being that if we are setting
             * a region, we must have a "custom" look in mind for the window.
             * Which we dont, we just want to hide parts of it temporarily.
             */
            if(0 == RealSetWindowRgn(hwnd, hrgnAnim, FALSE)) {
                goto Cleanup;
            } else {
                /*
                 * The system now owns the region.  Lets simply forget about
                 * it to be safe.
                 */
                hrgnAnim = NULL;
            }

            /*
             * If we are supposed to activate the window, do so on the first
             * frame of the animation.  This will cause the window to be
             * z-ordered properly.  Note that we leave the flag set to
             * true so that we will activate it again at the end.  This will
             * force a repaint since we are currently drawing the bits of the
             * window that doesn't look activated.
             */
            if (fFirstFrame && fActivateWindow) {
                NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                                   SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER | SWP_NOREDRAW);
            }
            fFirstFrame = FALSE;

            if (RedrawWindow(NULL, NULL, hrgnUpdate, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN) == 0) {
                goto Cleanup;
            }
            if (fRedrawParentWindow) {
                if (NtUserCallHwndParamLock(hwndParent, (ULONG_PTR)hrgnUpdate, SFI_XXXUPDATEWINDOWS) == 0) {
                    TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Warning: xxxUpdateWindows failed!");
                    goto Cleanup;
                }
            }

            /*
             * Now draw the cached snapshot of the window on top of the window
             * itself.  We do this by drawing into the window's DC.  Since we
             * applied a region already, all clipping is done for us.
             */
            if (BitBlt(hdc, xReal, yReal, ix, iy, hdcMem, xMem, yMem, SRCCOPY | NOMIRRORBITMAP) == 0) {
                goto Cleanup;
            }

#if DBG
            cAnimationFrames++;
            dwElapsed2 = GetTickCount() - dwStart;
            dwElapsed2 -= dwElapsed;
#endif
            TAGMSG2(DBGTAG_AnimateWindow, "AnimateWindow: Frame %d took %lums", cAnimationFrames, dwElapsed2 );

            ixLast = ix;
            iyLast = iy;

            /*
             * Break out of the animation loop when, either:
             * 1) We've exceeded the animation time.
             * 2) We're hiding the window and one of the dimensions is 0.
             *    The window is completely hidden now anyways,
             * 3) We're showing the window and both dimensions are at their
             *    full size.  The window is completely shown now anyways.
             */
            if (dwElapsed > dwTime) {
                TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Done with the animation late!");
                break;
            }
            if ((fHide && (ix == 0 || iy == 0)) ||
                (!fHide && (ix == cx && iy == cy))) {
                TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Done with the animation on time or early!");
                break;
            }
        }
    }

    TAGMSG2(DBGTAG_AnimateWindow, "AnimateWindow: Animation completed after %lums, drawing %d frames.", dwElapsed, cAnimationFrames);
    fRet = TRUE;

    if (fHide) {
        UserAssert(ixLast == 0 || iyLast == 0);

        /*
         * We are supposed to be hiding the window.  Go ahead and restore the
         * child clipping setting, and hide the window.
         */
        if (fRestoreClipChildren) {
            SetWindowState(pwnd, WFCLIPCHILDREN);
            fRestoreClipChildren = FALSE;
        }

        NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                           SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOREDRAW | SWP_HIDEWINDOW | SWP_NOACTIVATE);
        fHideWindow = FALSE;
    } else {
        UserAssert(ixLast == cx && iyLast == cy);

        /*
         * We successfully finished the animation loop!  Validate the entire window since
         * we claimed responsibility for drawing it correctly.
         */
        RedrawWindow(hwnd, NULL, NULL, RDW_NOERASE | RDW_NOFRAME | RDW_NOINTERNALPAINT | RDW_VALIDATE);
    }

Cleanup:
    /*
     * Things to do on cleanup.  Make sure we restore the "children clipping"
     * setting of the window if we removed it!
     */
    if (fRestoreClipChildren) {
        SetWindowState(pwnd, WFCLIPCHILDREN);
        fRestoreClipChildren = FALSE;
    }

    /*
     * Hide the window if needed before we reapply the window region.
     */
    if (fHideWindow) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Hiding the window during cleanup" );
        NtUserShowWindow(hwnd, SW_HIDE);
    }

    /*
     * Restore the original window region.  Note that the system now owns
     * the handle, so we should not delete it.  Also, if the original
     * handle was NULL, this removes any regions we inflicted on the window
     * in order to do the animation.
     */
    if (fRestoreOriginalRegion) {
        RealSetWindowRgn(hwnd, hrgnOriginal, FALSE);
        hrgnOriginal = NULL;
        fRestoreOriginalRegion = FALSE;
    }

    /*
     * More things to do on cleanup.  Make sure we show/activate the window
     * if needed!
     */
    if (fShowWindow && fActivateWindow) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Showing and activating the window during cleanup" );
        NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_DRAWFRAME | SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER);
        fShowWindow = FALSE;
        fActivateWindow = FALSE;
    }
    if (fShowWindow) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Showing the window during cleanup" );
        NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                           SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER);
        fShowWindow = FALSE;
    }
    if (fActivateWindow) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Activating the window during cleanup" );
        NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                           SWP_DRAWFRAME | SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER);
        fActivateWindow = FALSE;
    }

    if (hdcMem != NULL) {
        DeleteDC(hdcMem);
    }

    if (hbmMem != NULL) {
        DeleteObject(hbmMem);
    }

    if (hdc != NULL) {
        ReleaseDC(hwnd, hdc);
    }

    if (hrgnAnim != NULL) {
        DeleteObject(hrgnAnim);
        hrgnAnim = NULL;
    }
    
    if (hrgnOldAnim != NULL) {
        DeleteObject(hrgnOldAnim);
        hrgnOldAnim = NULL;
    }

    if (hrgnUpdate != NULL) {
        DeleteObject(hrgnUpdate);
        hrgnUpdate = NULL;
    }

    return fRet;
}

/***************************************************************************\
* SmoothScrollWindowEx
*
* History:
* 24-Sep-1996   vadimg      wrote
\***************************************************************************/

#define MINSCROLL 10
#define MAXSCROLLTIME 200

int SmoothScrollWindowEx(HWND hwnd, int dx, int dy, CONST RECT *prcScroll,
        CONST RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, DWORD dwFlags,
        DWORD dwTime)
{
    RECT rc, rcT, rcUpdate;
    int dxStep, dyStep, dxDone, dyDone, xSrc, ySrc, xDst, yDst, dxBlt, dyBlt;
    int nRet = ERROR, nClip;
    BOOL fNegX = FALSE, fNegY = FALSE;
    HDC hdc, hdcMem = NULL;
    HBITMAP hbmMem = NULL, hbmOld;
    DWORD dwSleep;
    BOOL fCalcSubscroll = FALSE;
    PWND pwnd = ValidateHwnd(hwnd);
    HRGN hrgnScroll = NULL, hrgnErase = NULL;
    MSG msg;
    UINT uBounds;
    RECT rcBounds;

    if (pwnd == NULL)
        return ERROR;
    /*
     * Keep track of the signs so we don't have to mess with abs all the time.
     */
    if (dx < 0) {
        fNegX = TRUE;
        dx = -dx;
    }

    if (dy < 0) {
        fNegY = TRUE;
        dy = -dy;
    }

    /*
     * Set up the client rectangle.
     */
    if (prcScroll != NULL) {
        rc = *prcScroll;
    } else {
        rc.left = rc.top = 0;
        rc.right = pwnd->rcClient.right - pwnd->rcClient.left;
        rc.bottom = pwnd->rcClient.bottom - pwnd->rcClient.top;
    }

    /*
     * If they want to scroll less than we can let them, or more than
     * one page, or need repainting send them to the API.
     */
    if (pwnd->hrgnUpdate != NULL || (dx == 0 && dy == 0) ||
        (dx != 0 && dx > rc.right) ||
        (dy != 0 && dy > rc.bottom)) {
        return NtUserScrollWindowEx(hwnd, fNegX ? -dx : dx, fNegY ? -dy : dy,
                prcScroll, prcClip, hrgnUpdate, prcUpdate,
                dwFlags | SW_ERASE | SW_INVALIDATE);
    }

    if ((hdc = GetDCEx(hwnd, NULL, DCX_USESTYLE | DCX_CACHE)) == NULL) {
        return ERROR;
    }

    /*
     * Part of the window may be obscured, which means that more may be
     * invisible and may need to be bltted. Take that into account by
     * gettting the clip box.
     */
    nClip = GetClipBox(hdc, &rcT);
    if (nClip == ERROR || nClip == NULLREGION) {
        goto Cleanup;
    }

    /*
     * Set up the offscreen dc and send WM_PRINT to get the image.
     */
    if ((hbmMem = CreateCompatibleBitmap(hdc, rc.right, rc.bottom)) == NULL) {
        goto Cleanup;
    }
    if ((hdcMem = CreateCompatibleDC(hdc)) == NULL) {
        goto Cleanup;
    }
    hbmOld = SelectBitmap(hdcMem, hbmMem);

    SetBoundsRect(hdcMem, NULL, DCB_RESET | DCB_ENABLE);

    SendMessage(hwnd, WM_PRINT, (WPARAM)hdcMem, PRF_CLIENT |
            PRF_ERASEBKGND | ((dwFlags & SW_SCROLLCHILDREN) ? PRF_CHILDREN : 0));

    /*
     * If the client rect changes during the callback, send WM_PRINT
     * again to get the correctly sized image.
     */
    if (prcScroll == NULL) {
        rcT.left = rcT.top = 0;
        rcT.right = pwnd->rcClient.right - pwnd->rcClient.left;
        rcT.bottom = pwnd->rcClient.bottom - pwnd->rcClient.top;

        if (!EqualRect(&rc, &rcT)) {
            rc = rcT;

            SelectObject(hdcMem, hbmOld);
            DeleteObject(hbmMem);

            if ((hbmMem = CreateCompatibleBitmap(hdc, rc.right, rc.bottom)) == NULL) {
                goto Cleanup;
            }

            SelectObject(hdcMem, hbmMem);
            SendMessage(hwnd, WM_PRINT, (WPARAM)hdcMem, PRF_CLIENT |
                    PRF_ERASEBKGND | ((dwFlags & SW_SCROLLCHILDREN) ? PRF_CHILDREN : 0));
        }
    }

    /*
     * Check to see if the app painted in our DC.
     */
    uBounds = GetBoundsRect(hdcMem, &rcBounds, 0);
    if ((uBounds & DCB_RESET) && (!(uBounds & DCB_ACCUMULATE))) {
        goto Cleanup;
    }

    if ((hrgnScroll = CreateRectRgn(0, 0, 0, 0)) == NULL) {
        goto Cleanup;
    }
    if ((hrgnErase = CreateRectRgn(0, 0, 0, 0)) == NULL) {
        goto Cleanup;
    }
    SetRectEmpty(&rcUpdate);

    /*
     * Start off with MINSCROLL and adjust it based on available time after
     * the first iteration. We should consider adding a NOTIMELIMIT flag.
     */
    xDst = xSrc = 0;
    yDst = ySrc = 0;

    dxBlt = rc.right;
    dyBlt = rc.bottom;

    if (dx == 0) {
        dxDone = rc.right;
        dxStep = 0;
    } else {
        dxDone = 0;
        dxStep = max(dx / MINSCROLL, 1);
    }

    if (dy == 0) {
        dyDone = rc.bottom;
        dyStep = 0;
    } else {
        dyDone = 0;
        dyStep = max(dy / MINSCROLL, 1);
    }

    if (dwTime == 0) {
        dwTime = MAXSCROLLTIME;
    }
    dwSleep = dwTime / MINSCROLL;

    do {

        /*
         * When the dc is scrolled, the part that's revealed cannot be
         * updated properly. We set up the variables to blt just the part that
         * was just uncovered.
         */
        if (dx != 0) {
            if (dxDone + dxStep > dx) {
                dxStep = dx - dxDone;
            }
            dxDone += dxStep;

            xDst = dx - dxDone;
            dxBlt = rc.right - xDst;
            if (!fNegX) {
                xSrc = xDst;
                xDst = 0;
            }
        }

        if (dy != 0) {
            if (dyDone + dyStep > dy) {
                dyStep = dy - dyDone;
            }
            dyDone += dyStep;

            yDst = dy - dyDone;
            dyBlt = rc.bottom - yDst;
            if (!fNegY) {
                ySrc = yDst;
                yDst = 0;
            }
        }

        /*
         * This is a hack for ReaderMode to be smoothly continuous. We'll make an
         * attempt for the scrolling to take as close to dwTime
         * as possible. We'll also dispatch MOUSEMOVEs to the ReaderMode window, so it
         * can update mouse cursor.
         */
        if (MsgWaitForMultipleObjects(0, NULL, FALSE, dwSleep, QS_MOUSEMOVE) == WAIT_OBJECT_0) {
            if (PeekMessage(&msg, NULL, WM_MOUSEMOVE, WM_MOUSEMOVE, MAKELONG(PM_NOREMOVE, QS_INPUT))) {
                PWND pwndPeek = ValidateHwnd(msg.hwnd);
                if (pwndPeek != NULL) {
                    PCLS pcls = (PCLS)REBASEALWAYS(pwndPeek, pcls);
                    if (pcls->atomClassName == gatomReaderMode) {
                        if (PeekMessage(&msg, msg.hwnd, WM_MOUSEMOVE, WM_MOUSEMOVE, MAKELONG(PM_REMOVE, QS_INPUT))) {
                            DispatchMessage(&msg);
                        }
                    }
                }
            }
        }

        if ((nRet = NtUserScrollWindowEx(hwnd, fNegX ? -dxStep : dxStep,
                fNegY ? -dyStep : dyStep, prcScroll, prcClip,
                hrgnScroll, &rcT, dwFlags)) == ERROR)
            goto Cleanup;

        UnionRect(&rcUpdate, &rcUpdate, &rcT);

        /*
         * Blt the uncovered part.
         */
        BitBlt(hdc, xDst, yDst, dxBlt, dyBlt, hdcMem, xSrc, ySrc, SRCCOPY | NOMIRRORBITMAP);

        SetRectRgn(hrgnErase, xDst, yDst, xDst + dxBlt, yDst + dyBlt);
        CombineRgn(hrgnErase, hrgnScroll, hrgnErase, RGN_DIFF);
        RedrawWindow(hwnd, NULL, hrgnErase, RDW_ERASE | RDW_INVALIDATE | RDW_ERASENOW);

    } while (dxDone < dx || dyDone < dy);

    if (prcUpdate != NULL) {
        *prcUpdate = rcUpdate;
    }
    if (hrgnUpdate != NULL) {
        SetRectRgn(hrgnUpdate, rcUpdate.left, rcUpdate.top,
                rcUpdate.right, rcUpdate.bottom);
    }

Cleanup:
    if (hdcMem != NULL) {
        DeleteDC(hdcMem);
    }
    if (hbmMem != NULL) {
        DeleteObject(hbmMem);
    }
    if (hdc != NULL) {
        ReleaseDC(hwnd, hdc);
    }
    if (hrgnErase != NULL) {
        DeleteObject(hrgnErase);
    }
    if (hrgnScroll != NULL) {
        DeleteObject(hrgnScroll);
    }
    return nRet;
}

/***************************************************************************\
* ScrollWindowEx (API)
*
\***************************************************************************/

int ScrollWindowEx(HWND hwnd, int dx, int dy, CONST RECT *prcScroll,
        CONST RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate,
        UINT dwFlags)
{
    if (dwFlags & SW_SMOOTHSCROLL) {
        return SmoothScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip,
                hrgnUpdate, prcUpdate, LOWORD(dwFlags), HIWORD(dwFlags));
    } else {
        return NtUserScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip,
                hrgnUpdate, prcUpdate, dwFlags);
    }
}

/***************************************************************************\
* IsGUIThread (API)
*
* Checks whether the current thread is a GUI thread. If bConvert is TRUE, will
* convert the current thread to GUI, if necessary.
*
* History:
* 22-Jun-2000 JasonSch   Wrote.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsGUIThread, BOOL, bConvert)
BOOL IsGUIThread(BOOL bConvert)
{
    BOOL bIsGUI = (NtCurrentTebShared()->Win32ThreadInfo != NULL);

    if (!bIsGUI && bConvert) {
        bIsGUI = (BOOL)USERTHREADCONNECT();
        if (!bIsGUI) {
            UserSetLastError(ERROR_OUTOFMEMORY);
        }
    }

    return bIsGUI;
}

/***************************************************************************\
* IsWindowInDestroy (API)
*
* Checks whether the current window is in the process of being destroyed.
*
* History:
* 02-Jan-2001 Mohamed   Wrote.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsWindowInDestroy, HWND, hwnd)
BOOL IsWindowInDestroy(IN HWND hwnd)
{
    PWND pwnd;
    
    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return FALSE;
    }
    return TestWF(pwnd, WFINDESTROY);
}

/***************************************************************************\
* IsServerSideWindow (API)
*
* Checks whether the current window is marked as having a server side WndProc.
*
* History:
* 13-Jun-2001 Mohamed   Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsServerSideWindow, HWND, hwnd)
BOOL IsServerSideWindow(IN HWND hwnd)
{
    PWND pwnd;
    
    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return FALSE;
    }
    return TestWF(pwnd, WFSERVERSIDEPROC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\stdptcl.c ===
/****************************** Module Header ******************************\
* Module Name: stdptcl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager DDE protocol transaction management functions
*
* NITTY GRITTY GUCK of DDE
*
* Created: 11/3/91 Sanford Staab
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*

    StartFunctions:
        These are used to fill in a preallocated pxi with transaction
        specific data. They then start the desired transaction and
        link the pxi into the conversation's transaction queue.
        fSuccess is return ed. On error, SetLastDDEMLError is called
        by these functions and the pxi is untouched, ready for
        reuse on a subsequent call. Note that the pxi->gaItem field
        is a global atom and needs to be deleted by the caller on
        failure as apropriate. Success implies the transaction
        is started successfully.

    RespFunctions:
        These are called via the pxi->pfnRespnose field in response
        to expected DDE messages. If the msg parameter is 0, these
        functions assume transaction cleanup is being done. FALSE
        is only return ed if CBR_BLOCK was returned from a callback.

    SpontFunctions:
        These are called in response to a spontaneous (unexpected) DDE
        message. These functions may create a pxi and link it into the
        conversation's transaction queue to properly handle expected
        replies. FALSE is only return ed if CBR_BLOCK was returned
        from a callback.

    The prefixes Sv and Cl indicate which side of the DDE conversation
    is doing the work.

    Weaknesses: Can't deal well with failed PostMessage() or
                 lParam acessing/allocation failures. Hoping these
                 are rare enough (ie never) to not matter. If they
                 do fail, the tracking layer will eventually shut down
                 the conversation.

*/

//--------------------------------ADVISE-------------------------------//

/***************************************************************************\
* ClStartAdvise
*
* Description:
* CLIENT side Advise link processing
* Post WM_DDE_ADVISE message
* Link pxi for responding WM_DDE_ACK message.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL ClStartAdvise(
PXACT_INFO pxi)
{
    DWORD dwError;

    //
    // protocol quirk: DDE_FRELEASE is always assumed set in a WM_DDE_ADVISE
    // message. We set it here just in case the person on the other end
    // pays attention to it.
    //
    pxi->hDDESent = AllocAndSetDDEData(NULL, sizeof(DDE_DATA),
            (WORD)(((pxi->wType << 12) & (DDE_FDEFERUPD | DDE_FACKREQ)) | DDE_FRELEASE),
            pxi->wFmt);
    if (!pxi->hDDESent) {
        SetLastDDEMLError(pxi->pcoi->pcii, DMLERR_MEMORY_ERROR);
        return (FALSE);
    }

    IncGlobalAtomCount(pxi->gaItem); // message copy
    dwError = PackAndPostMessage(pxi->pcoi->hwndPartner, 0, WM_DDE_ADVISE,
            pxi->pcoi->hwndConv, 0, (UINT_PTR)pxi->hDDESent, pxi->gaItem);
    if (dwError) {
        SetLastDDEMLError(pxi->pcoi->pcii, dwError);
        WOWGLOBALFREE(pxi->hDDESent);
        pxi->hDDESent = 0;
        GlobalDeleteAtom(pxi->gaItem); // message copy
        return (FALSE);
    }

    pxi->state = XST_ADVSENT;
    pxi->pfnResponse = (FNRESPONSE)ClRespAdviseAck;
    LinkTransaction(pxi);
    return (TRUE);
}


/***************************************************************************\
* SvSpontAdvise
*
* Description:
* SERVER side WM_DDE_ADVISE processing
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL SvSpontAdvise(
PSVR_CONV_INFO psi,
LPARAM lParam)
{
    UINT_PTR uiHi;
    HANDLE hDDE;
    WORD wFmt, wStatus;
    ULONG_PTR dwRet = 0;
    DWORD dwError;
    LATOM la;

    UnpackDDElParam(WM_DDE_ADVISE, lParam, (PUINT_PTR)&hDDE, &uiHi);
    if (psi->ci.pcii->afCmd & CBF_FAIL_ADVISES) {
        goto Ack;
    }

    if (!ExtractDDEDataInfo(hDDE, &wStatus, &wFmt)) {
        goto Ack;
    }

    if (wStatus & DDE_FDEFERUPD) {
        wStatus &= ~DDE_FACKREQ;   // warm links shouldn't have this flag set
    }

    la = GlobalToLocalAtom((GATOM)uiHi);
    dwRet = (ULONG_PTR)DoCallback(psi->ci.pcii,
        XTYP_ADVSTART,
        wFmt, psi->ci.hConv,
        NORMAL_HSZ_FROM_LATOM(psi->ci.laTopic),
        NORMAL_HSZ_FROM_LATOM(la),
        (HDDEDATA)0, 0, 0);
    DeleteAtom(la);

    // check CBR_BLOCK case

    if (dwRet == (ULONG_PTR)CBR_BLOCK) {
        return (FALSE);
    }

    if (dwRet) {
        //
        // If we fail to add the link internally, dwRet == 0 -> NACK
        //
        dwRet = AddLink((PCONV_INFO)psi, (GATOM)uiHi, wFmt,
                (WORD)(wStatus & (WORD)(DDE_FDEFERUPD | DDE_FACKREQ)));
        if (dwRet) {
            MONLINK(psi->ci.pcii, TRUE, wStatus & DDE_FDEFERUPD, psi->ci.laService,
                    psi->ci.laTopic, (GATOM)uiHi, wFmt, TRUE,
                    (HCONV)psi->ci.hwndConv, (HCONV)psi->ci.hwndPartner);
        }
    }

Ack:
    if (dwRet) {
        WOWGLOBALFREE(hDDE); // hOptions - NACK -> HE frees it.
    }
    // IncGlobalAtomCount((GATOM)uiHi);         // message copy - reuse
    dwError = PackAndPostMessage(psi->ci.hwndPartner, WM_DDE_ADVISE, WM_DDE_ACK,
            psi->ci.hwndConv, lParam, dwRet ? DDE_FACK : 0, uiHi);
    if (dwError) {
        SetLastDDEMLError(psi->ci.pcii, dwError);
        GlobalDeleteAtom((ATOM)uiHi); // message copy
    }

    return (TRUE);
}



/***************************************************************************\
* ClRespAdviseAck
*
* Description:
* Client's response to an expected Advise Ack.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL ClRespAdviseAck(
PXACT_INFO pxi,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;

    if (msg) {
        if (msg != WM_DDE_ACK) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        UnpackDDElParam(WM_DDE_ACK, lParam, &uiLo, &uiHi);
#if DBG
        if ((GATOM)uiHi != pxi->gaItem) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }
#endif

        GlobalDeleteAtom((ATOM)uiHi); // message copy

        pxi->state = XST_ADVACKRCVD;
        pxi->wStatus = (WORD)uiLo;

        if (pxi->wStatus & DDE_FACK) {
            if (AddLink(pxi->pcoi, pxi->gaItem, pxi->wFmt,
                    (WORD)((pxi->wType << 12) & (DDE_FACKREQ | DDE_FDEFERUPD)))) {
                //
                // only server side reports links on local conversations.
                //
                if (!(pxi->pcoi->state & ST_ISLOCAL)) {
                    MONLINK(pxi->pcoi->pcii, TRUE, (WORD)uiLo & DDE_FDEFERUPD,
                            pxi->pcoi->laService, pxi->pcoi->laTopic, pxi->gaItem,
                            pxi->wFmt, FALSE, (HCONV)pxi->pcoi->hwndPartner,
                            (HCONV)pxi->pcoi->hwndConv);
                }
            } else {
                pxi->wStatus = 0;  // memory failure - fake a NACK.
            }
        } else {
            WOWGLOBALFREE(pxi->hDDESent);  // Nack free.
        }

        if (TransactionComplete(pxi,
                (pxi->wStatus & DDE_FACK) ? (HDDEDATA)1L : (HDDEDATA)0L)) {
            goto Cleanup;
        }
    } else {
Cleanup:
        GlobalDeleteAtom(pxi->gaItem); // pxi copy
        UnlinkTransaction(pxi);
        DDEMLFree(pxi);
    }
    if (msg) {
        FreeDDElParam(msg, lParam);
    }
    return (TRUE);
}

//-------------------------ADVISE LINK UPDATE--------------------------//


/***************************************************************************\
* SvStartAdviseUpdate
*
* Description:
* Starts a single link update transaction. The return value is TRUE only
* if pxi was queued.
*
* History:
* 11-19-91 sanfords Created.
* 8-24-92  sanfords Added cLinksToGo
\***************************************************************************/
BOOL SvStartAdviseUpdate(
PXACT_INFO pxi,
DWORD cLinksToGo)
{
    HDDEDATA hData = NULL;
    PDDE_DATA pdde;
    DWORD dwError;
    HANDLE hDDE;
    LATOM al;

    CheckDDECritIn;

    if (pxi->wType & DDE_FDEFERUPD) {
        hDDE = 0;
    } else {
        al = GlobalToLocalAtom(pxi->gaItem);
        hData = DoCallback(pxi->pcoi->pcii,
                           XTYP_ADVREQ,
                           pxi->wFmt,
                           pxi->pcoi->hConv,
                           NORMAL_HSZ_FROM_LATOM(pxi->pcoi->laTopic),
                           NORMAL_HSZ_FROM_LATOM(al),
                           (HDDEDATA)0,
                           MAKELONG(cLinksToGo, 0),
                           0);
        DeleteAtom(al);
        if (!hData) {
            // app doesn't honor the advise.
            return (FALSE); // reuse pxi
        }
        hDDE = UnpackAndFreeDDEMLDataHandle(hData, FALSE);
        if (!hDDE) {

            /*
             * failed - must be execute type data
             */
            InternalFreeDataHandle(hData, FALSE);
            SetLastDDEMLError(pxi->pcoi->pcii, DMLERR_DLL_USAGE);
            return (FALSE);
        }
        /*
         * Set fAckReq bit apropriately - note APPOWNED handles will already
         * have the fAckReq bit set so this will not change their state.
         */
        USERGLOBALLOCK(hDDE, pdde);
        if (pdde == NULL) {
            return (FALSE);
        }
        if (pdde->wFmt != pxi->wFmt) {

            /*
             * bogus data - wrong format!
             */
            USERGLOBALUNLOCK(hDDE);
            InternalFreeDataHandle(hData, FALSE);
            SetLastDDEMLError(pxi->pcoi->pcii, DMLERR_DLL_USAGE);
            return (FALSE);
        }
        if (!(pdde->wStatus & DDE_FRELEASE)) {
            pxi->wType |= DDE_FACKREQ; // dare not allow neither flag set!
        }
        pdde->wStatus |= (pxi->wType & DDE_FACKREQ);
        USERGLOBALUNLOCK(hDDE);
    }

    IncGlobalAtomCount(pxi->gaItem); // message copy
    dwError = PackAndPostMessage(pxi->pcoi->hwndPartner, 0, WM_DDE_DATA,
            pxi->pcoi->hwndConv, 0, (UINT_PTR)hDDE, pxi->gaItem);
    if (dwError) {
        if (hData) {
            InternalFreeDataHandle(hData, FALSE);
        }
        SetLastDDEMLError(pxi->pcoi->pcii, dwError);
        GlobalDeleteAtom(pxi->gaItem); // message copy
        return (FALSE);
    }

    pxi->state = XST_ADVDATASENT;
    if (pxi->wType & DDE_FACKREQ) {
        pxi->hDDESent = hDDE;
        pxi->pfnResponse = (FNRESPONSE)SvRespAdviseDataAck;
        LinkTransaction(pxi);
        return (TRUE); // prevents reuse - since its queued.
    } else {
        return (FALSE); // causes pxi to be reused for next advdata message.
    }
}



/***************************************************************************\
* ClSpontAdviseData
*
* Description:
* Handles WM_DDE_DATA messages that are not request data.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClSpontAdviseData(
PCL_CONV_INFO pci,
LPARAM lParam)
{
    UINT_PTR uiHi;
    DWORD dwError;
    HANDLE hDDE = 0;
    HDDEDATA hData, hDataReturn;
    PDDE_DATA pdde;
    WORD wFmt;
    WORD wStatus;
    LATOM la;
    PADVISE_LINK paLink;
    int iLink;

    UnpackDDElParam(WM_DDE_DATA, lParam, (PUINT_PTR)&hDDE, &uiHi);
    UserAssert(!hDDE || GlobalSize(hDDE));
    wFmt = 0;
    wStatus = 0;
    hDataReturn = 0;
    la = GlobalToLocalAtom((GATOM)uiHi);
    if (hDDE) {
        USERGLOBALLOCK(hDDE, pdde);
        if (pdde == NULL) {
            hData = 0;
        } else {
            wFmt = pdde->wFmt;
            wStatus = pdde->wStatus;
            USERGLOBALUNLOCK(hDDE);

            /*
             * if data is coming in, create a data handle for the app
             */
            hData = InternalCreateDataHandle(pci->ci.pcii, (LPBYTE)hDDE,
                    (DWORD)-1, 0, HDATA_NOAPPFREE | HDATA_READONLY, 0, 0);
        }
        if (hData) {
            hDataReturn = DoCallback(pci->ci.pcii, XTYP_ADVDATA,
                    wFmt, pci->ci.hConv,
                    NORMAL_HSZ_FROM_LATOM(pci->ci.laTopic),
                    NORMAL_HSZ_FROM_LATOM(la),
                    hData, 0, 0);
            if (hDataReturn != CBR_BLOCK) {
                UnpackAndFreeDDEMLDataHandle(hData, FALSE);
                if (((ULONG_PTR)hDataReturn & DDE_FACK) || !(wStatus & DDE_FACKREQ)) {
                    /*
                     * Nacked Advise data with fAckReq set is server's
                     * responsibility to free!
                     */
                    FreeDDEData(hDDE, FALSE, TRUE);
                }
            }
        }
    } else {
        /*
         * WARM LINK CASE
         *
         * Search through the client's link info to find what formats this
         * puppy is on. We let the client know for each format being supported
         * on this item that is warm-linked. The last hDataReturn determines
         * the ACK returned - for lack of a better method.
         */
        for (paLink = pci->ci.aLinks, iLink = 0; iLink < pci->ci.cLinks; iLink++, paLink++) {
            if ((paLink->laItem == la) && (paLink->wType & DDE_FDEFERUPD)) {
                hDataReturn = DoCallback(pci->ci.pcii, XTYP_ADVDATA,
                        paLink->wFmt, pci->ci.hConv,
                        NORMAL_HSZ_FROM_LATOM(pci->ci.laTopic),
                        NORMAL_HSZ_FROM_LATOM(la),
                        0, 0, 0);
                if (hDataReturn == CBR_BLOCK) {
                    DeleteAtom(la);
                    return (FALSE);
                }
            }
        }
    }
    DeleteAtom(la);
    if (hDataReturn == CBR_BLOCK) {
        return (FALSE);
    }

    if (wStatus & DDE_FACKREQ) {

        (ULONG_PTR)hDataReturn &= ~DDE_FACKRESERVED;
        // reuse uiHi
        if (dwError = PackAndPostMessage(pci->ci.hwndPartner, WM_DDE_DATA,
                WM_DDE_ACK, pci->ci.hwndConv, lParam, (UINT_PTR)hDataReturn, uiHi)) {
            SetLastDDEMLError(pci->ci.pcii, dwError);
        }
    } else {
        GlobalDeleteAtom((ATOM)uiHi); // data message copy
        FreeDDElParam(WM_DDE_DATA, lParam); // not reused so free it.
    }
    return (TRUE);
}




/***************************************************************************\
* SvRespAdviseDataAck
*
* Description:
* Handles expected Advise Data ACK message.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SvRespAdviseDataAck(
PXACT_INFO pxi,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;
    int iLink;
    PADVISE_LINK paLink;
    PXACT_INFO pxiNew;
    LATOM la;
    BOOL fSwapped;
#if DBG
    int cLinks;
#endif

    if (msg) {
        if (msg != WM_DDE_ACK) {
            return (SpontaneousServerMessage((PSVR_CONV_INFO)pxi->pcoi, msg, lParam));
        }
        UnpackDDElParam(WM_DDE_ACK, lParam, &uiLo, &uiHi);
        if ((GATOM)uiHi != pxi->gaItem) {
            RIPMSG0(RIP_ERROR, "DDE Protocol violation: Data ACK had wrong item");
            return (SpontaneousServerMessage((PSVR_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        GlobalDeleteAtom((ATOM)uiHi); // message copy
        FreeDDElParam(WM_DDE_ACK, lParam);

        if (!((uiLo & DDE_FACK) && pxi->hDDESent)) {
            FreeDDEData(pxi->hDDESent, FALSE, TRUE);
        }

        #if DBG
        /*
         * Rememeber the number of links so we can assert if they change during the loop below
         */
        cLinks = pxi->pcoi->cLinks;
        #endif
        /*
         * locate link info and clear ADVST_WAITING bit
         */
        la = GlobalToLocalAtom((GATOM)uiHi);
        paLink = pxi->pcoi->aLinks;
        for (iLink = 0; iLink < pxi->pcoi->cLinks; iLink++, paLink++) {
            if (paLink->laItem == la &&
                    paLink->state & ADVST_WAITING) {
                paLink->state &= ~ADVST_WAITING;
                /*
                 * We have to allocate pxiNew because it may become linked
                 * into pcoi->pxiIn.
                 */
                pxiNew = (PXACT_INFO)DDEMLAlloc(sizeof(XACT_INFO));

                if (pxiNew && !UpdateLinkIfChanged(paLink, pxiNew, pxi->pcoi,
                        &pxi->pcoi->aLinks[pxi->pcoi->cLinks - 1], &fSwapped,
                        CADV_LATEACK)) {
                    /*
                     * Not used, free it.
                     */
                    DDEMLFree(pxiNew);
                }
                break;
            }
        }
        #if DBG
        if (cLinks != pxi->pcoi->cLinks) {
            RIPMSG1(RIP_ERROR, "SvRespAdviseDataAck: cLinks changed. pxi:%#p", pxi);
        }
        #endif

        DeleteAtom(la);
    }
    GlobalDeleteAtom(pxi->gaItem); // pxi copy
    UnlinkTransaction(pxi);
    DDEMLFree(pxi);
    return (TRUE);
}



//------------------------------UNADVISE-------------------------------//

/***************************************************************************\
* ClStartUnadvise
*
* Description:
* Starts a WM_DDE_UNADVISE transaction.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClStartUnadvise(
PXACT_INFO pxi)
{
    DWORD dwError;

    IncGlobalAtomCount(pxi->gaItem); // message copy
    dwError = PackAndPostMessage(pxi->pcoi->hwndPartner, 0, WM_DDE_UNADVISE,
            pxi->pcoi->hwndConv, 0, pxi->wFmt, pxi->gaItem);
    if (dwError) {
        SetLastDDEMLError(pxi->pcoi->pcii, dwError);
        GlobalDeleteAtom(pxi->gaItem); // message copy
        return (FALSE);
    }

    //
    // only server side reports links on local conversations.
    //
    if (!(pxi->pcoi->state & ST_ISLOCAL)) {
        MONLINK(pxi->pcoi->pcii, FALSE, 0,
                pxi->pcoi->laService, pxi->pcoi->laTopic, pxi->gaItem,
                pxi->wFmt, FALSE, (HCONV)pxi->pcoi->hwndPartner,
                (HCONV)pxi->pcoi->hwndConv);
    }
    pxi->state = XST_UNADVSENT;
    pxi->pfnResponse = (FNRESPONSE)ClRespUnadviseAck;
    LinkTransaction(pxi);
    return (TRUE);
}
/***************************************************************************\
* CloseTransaction
*
* Description:
* Remove all outstanding pxi coresponding to the transaction
* that will be closed in responds to a WM_DDE_UNADVISE message.
*
* History:
* 6-4-96 clupu Created.
\***************************************************************************/
void CloseTransaction(
    PCONV_INFO pci,
    ATOM       atom)
{
    PXACT_INFO pxi;
    PXACT_INFO pxiD;

    pxi = pci->pxiOut;

    while (pxi && (pxi->gaItem == atom)) {
        pxiD = pxi;
        pxi  = pxi->next;
        DDEMLFree(pxiD);
    }
    pci->pxiOut = pxi;

    if (pxi == NULL) {
        pci->pxiIn = NULL;
        return;
    }

    while (pxi->next) {
        if (pxi->next->gaItem == atom) {
            pxiD = pxi->next;
            pxi->next = pxiD->next;
            DDEMLFree(pxiD);
        } else
            pxi = pxi->next;
    }
    pci->pxiIn = pxi;
}

/***************************************************************************\
* SvSpontUnadvise
*
* Description:
* Responds to a WM_DDE_UNADVISE message.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SvSpontUnadvise(
PSVR_CONV_INFO psi,
LPARAM lParam)
{
    ULONG_PTR dwRet = 0;
    DWORD dwError;
    INT iLink;
    PADVISE_LINK aLink;
    LATOM la;

    la = GlobalToLocalAtom((GATOM)HIWORD(lParam));

    CloseTransaction(&psi->ci, HIWORD(lParam));

    for (aLink = psi->ci.aLinks, iLink = 0; iLink < psi->ci.cLinks;) {

        if (la == 0 || aLink->laItem == la &&
                (LOWORD(lParam) == 0 || LOWORD(lParam) == aLink->wFmt)) {

            if (!(psi->ci.pcii->afCmd & CBF_FAIL_ADVISES)) {
                /*
                 * Only do the callbacks if he wants them.
                 */
                dwRet = (ULONG_PTR)DoCallback(psi->ci.pcii,
                    (WORD)XTYP_ADVSTOP, aLink->wFmt, psi->ci.hConv,
                    NORMAL_HSZ_FROM_LATOM(psi->ci.laTopic),
                    NORMAL_HSZ_FROM_LATOM(la),
                    (HDDEDATA)0, 0L, 0L);
                if (dwRet == (ULONG_PTR)CBR_BLOCK) {
                    DeleteAtom(la);
                    return(FALSE);
                }
            }
            /*
             * Notify any DDESPY apps.
             */
            MONLINK(psi->ci.pcii, TRUE, 0, psi->ci.laService,
                    psi->ci.laTopic, HIWORD(lParam), aLink->wFmt, TRUE,
                    (HCONV)psi->ci.hwndConv, (HCONV)psi->ci.hwndPartner);
            /*
             * Remove link info
             */
            DeleteAtom(aLink->laItem);  // aLink copy
            DeleteLinkCount(psi->ci.pcii, aLink->pLinkCount);
            if (--psi->ci.cLinks) {
                memmove((LPSTR)aLink, (LPSTR)(aLink + 1),
                        sizeof(ADVISE_LINK) * (psi->ci.cLinks - iLink));
            }
        } else {
            aLink++;
            iLink++;
        }
    }

    DeleteAtom(la);

    /*
     * Now ACK the unadvise message.
     */
    dwError = PackAndPostMessage(psi->ci.hwndPartner, 0,
            WM_DDE_ACK, psi->ci.hwndConv, 0, DDE_FACK, HIWORD(lParam));
    if (dwError) {
        SetLastDDEMLError(psi->ci.pcii, dwError);
        GlobalDeleteAtom((ATOM)HIWORD(lParam));      // message copy
        // FreeDDElParam(WM_DDE_UNADVISE, lParam);   // no unpack needed
    }

    return (TRUE);
}

/***************************************************************************\
* ClRespUnadviseAck
*
* Description:
* Client's response to an expected Unadvise Ack.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL ClRespUnadviseAck(
PXACT_INFO pxi,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;
    LATOM al;
    PADVISE_LINK aLink;
    int iLink;

    if (msg) {
        if (msg != WM_DDE_ACK) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        UnpackDDElParam(WM_DDE_ACK, lParam, &uiLo, &uiHi);
        if ((GATOM)uiHi != pxi->gaItem) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        al = GlobalToLocalAtom((ATOM)uiHi);
        for (aLink = pxi->pcoi->aLinks, iLink = 0;
                iLink < pxi->pcoi->cLinks;
                    ) {
            if (aLink->laItem == al &&
                    (pxi->wFmt == 0 || aLink->wFmt == pxi->wFmt)) {
                DeleteAtom(al);  // aLink copy
                if (--pxi->pcoi->cLinks) {
                    memmove((LPSTR)aLink, (LPSTR)(aLink + 1),
                            sizeof(ADVISE_LINK) * (pxi->pcoi->cLinks - iLink));
                }
            } else {
                aLink++;
                iLink++;
            }
        }
        DeleteAtom(al);  // local copy
        GlobalDeleteAtom((ATOM)uiHi);   // message copy

        pxi->state = XST_UNADVACKRCVD;
        pxi->wStatus = (WORD)uiLo;
        if (TransactionComplete(pxi, (HDDEDATA)1)) {
            goto Cleanup;
        }
    } else {
Cleanup:
        GlobalDeleteAtom(pxi->gaItem);   // pxi copy
        UnlinkTransaction(pxi);
        if (pxi->hXact) {
            DestroyHandle(pxi->hXact);
        }
        DDEMLFree(pxi);
    }
    if (msg) {
        FreeDDElParam(msg, lParam);
    }
    return (TRUE);
}


//-------------------------------EXECUTE-------------------------------//


/***************************************************************************\
* MaybeTranslateExecuteData
*
* Description:
* Translates DDE execute data if needed.
*
* History:
* 1/28/92 sanfords created
\***************************************************************************/
HANDLE MaybeTranslateExecuteData(
HANDLE hDDE,
BOOL fUnicodeFrom,
BOOL fUnicodeTo,
BOOL fFreeSource)
{
    PSTR pstr;
    PWSTR pwstr;
    DWORD cb;
    HANDLE hDDEnew;

    if (fUnicodeFrom && !fUnicodeTo) {
        USERGLOBALLOCK(hDDE, pwstr);
        // translate data from UNICODE to ANSII
        cb = WideCharToMultiByte(0, 0, (LPCWSTR)pwstr, -1, NULL, 0, NULL, NULL);
        hDDEnew = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, cb);
        USERGLOBALLOCK(hDDEnew, pstr);
        if (pstr != NULL && pwstr != NULL) {
            WCSToMB(pwstr, -1, &pstr, cb, FALSE);
        }
        if (pwstr) {
            USERGLOBALUNLOCK(hDDE);
        }
        if (pstr) {
            USERGLOBALUNLOCK(hDDEnew);
        }
    } else if (!fUnicodeFrom && fUnicodeTo) {
        USERGLOBALLOCK(hDDE, pstr);
        // translate data from ANSII to UNICODE
        cb = 2 * MultiByteToWideChar(0, 0, (LPCSTR)pstr, -1, NULL, 0);
        hDDEnew = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, cb);
        USERGLOBALLOCK(hDDEnew, pwstr);
        if (pwstr != NULL && pstr != NULL) {
            MBToWCS(pstr, -1, &pwstr, cb, FALSE);
        }
        if (pstr) {
            USERGLOBALUNLOCK(hDDE);
        }
        if (pwstr) {
            USERGLOBALUNLOCK(hDDEnew);
        }
    } else {
        return (hDDE); // no translation needed.
    }
    if (fFreeSource) {
        WOWGLOBALFREE(hDDE);
    }
    return (hDDEnew);
}


/***************************************************************************\
* ClStartExecute
*
* Description:
* Starts an execute transaction.
*
* History:
* 11-19-91 sanfords Created.
* 1/28/92 sanfords added UNICODE support.
\***************************************************************************/
BOOL ClStartExecute(
PXACT_INFO pxi)
{
    DWORD dwError;

    pxi->hDDESent = MaybeTranslateExecuteData(pxi->hDDESent,
            pxi->pcoi->pcii->flags & IIF_UNICODE,
            pxi->pcoi->state & ST_UNICODE_EXECUTE,
            TRUE);

    dwError = PackAndPostMessage(pxi->pcoi->hwndPartner, 0, WM_DDE_EXECUTE,
            pxi->pcoi->hwndConv, 0, 0, (UINT_PTR)pxi->hDDESent);
    if (dwError) {
        SetLastDDEMLError(pxi->pcoi->pcii, dwError);
        return (FALSE);
    }
    pxi->state = XST_EXECSENT;
    pxi->pfnResponse = (FNRESPONSE)ClRespExecuteAck;
    LinkTransaction(pxi);
    return (TRUE);
}


/***************************************************************************\
* SvSpontExecute
*
* Description:
* Responds to a WM_DDE_EXECUTE message.
*
* History:
* 11-19-91 sanfords Created.
* 1/28/92 sanfords added UNICODE support.
\***************************************************************************/
BOOL SvSpontExecute(
PSVR_CONV_INFO psi,
LPARAM lParam)
{
    HANDLE hDDE, hDDEx;
    ULONG_PTR dwRet = 0;
    DWORD dwError;
    HDDEDATA hData = 0;

    hDDEx = hDDE = (HANDLE)lParam; // UnpackDDElParam(msg, lParam, NULL, &hDDE);
    if (psi->ci.pcii->afCmd & CBF_FAIL_EXECUTES) {
        goto Ack;
    }

    /*
     * Note that if unicode translation is needed, we use the translated
     * handle for the callback and then destroy it but the ACK is always
     * the original hDDE so that the protocol isn't violated:
     *
     * DDE COMMANDMENT #324: Thou shalt pass back the exact same data
     * handle in an execute ACK that you were given by the execute
     * message.
     */
    hDDEx = MaybeTranslateExecuteData(hDDE,
            psi->ci.state & ST_UNICODE_EXECUTE,
            psi->ci.pcii->flags & IIF_UNICODE,
            FALSE);

    hData = InternalCreateDataHandle(psi->ci.pcii, (LPBYTE)hDDEx, (DWORD)-1, 0,
        HDATA_EXECUTE | HDATA_READONLY | HDATA_NOAPPFREE, 0, 0);
    if (!hData) {
        SetLastDDEMLError(psi->ci.pcii, DMLERR_MEMORY_ERROR);
        goto Ack;
    }

    dwRet = (ULONG_PTR)DoCallback(psi->ci.pcii,
            XTYP_EXECUTE, 0, psi->ci.hConv,
            NORMAL_HSZ_FROM_LATOM(psi->ci.laTopic), 0, hData, 0, 0);
    UnpackAndFreeDDEMLDataHandle(hData, TRUE);

    if (dwRet == (ULONG_PTR)CBR_BLOCK) {
        if (hDDEx != hDDE) {
            WOWGLOBALFREE(hDDEx);
        }
        return (FALSE);
    }

Ack:
    dwRet &= ~DDE_FACKRESERVED;
    dwError = PackAndPostMessage(psi->ci.hwndPartner, WM_DDE_EXECUTE,
            WM_DDE_ACK, psi->ci.hwndConv, lParam, dwRet, (UINT_PTR)hDDE);
    if (dwError) {
        SetLastDDEMLError(psi->ci.pcii, dwError);
    }

    if (hDDEx != hDDE) {
        WOWGLOBALFREE(hDDEx);
    }

    return (TRUE);
}



/***************************************************************************\
* ClRespExecuteAck
*
* Description:
* Responds to a WM_DDE_ACK in response to a WM_DDE_EXECUTE message.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClRespExecuteAck(
PXACT_INFO pxi,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;

    if (msg) {
        if (msg != WM_DDE_ACK) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        UnpackDDElParam(WM_DDE_ACK, lParam, &uiLo, &uiHi);
        if (uiHi != (UINT_PTR)pxi->hDDESent) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        WOWGLOBALFREE((HANDLE)uiHi);

        pxi->state = XST_EXECACKRCVD;
        pxi->wStatus = (WORD)uiLo;

        if (TransactionComplete(pxi, (HDDEDATA)((ULONG_PTR)(pxi->wStatus & DDE_FACK ? 1 : 0)))) {
            goto Cleanup;
        }
    } else {
Cleanup:
        GlobalDeleteAtom(pxi->gaItem); // pxi copy
        UnlinkTransaction(pxi);
        if (pxi->hXact) {
            DestroyHandle(pxi->hXact);
        }
        DDEMLFree(pxi);
    }
    if (msg) {
        FreeDDElParam(msg, lParam);
    }
    return (TRUE);
}



//----------------------------------POKE-------------------------------//


/***************************************************************************\
* ClStartPoke
*
* Description:
* Initiates a poke transaction.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClStartPoke(
PXACT_INFO pxi)
{
    DWORD dwError;

    IncGlobalAtomCount(pxi->gaItem); // message copy
    dwError = PackAndPostMessage(pxi->pcoi->hwndPartner, 0, WM_DDE_POKE,
            pxi->pcoi->hwndConv, 0, (UINT_PTR)pxi->hDDESent, pxi->gaItem);
    if (dwError) {
        SetLastDDEMLError(pxi->pcoi->pcii, dwError);
        GlobalDeleteAtom(pxi->gaItem); // message copy
        return (FALSE);
    }

    pxi->state = XST_POKESENT;
    pxi->pfnResponse = (FNRESPONSE)ClRespPokeAck;
    LinkTransaction(pxi);
    return (TRUE);
}


/***************************************************************************\
* SvSpontPoke
*
* Description:
* Handles WM_DDE_POKE messages.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SvSpontPoke(
PSVR_CONV_INFO psi,
LPARAM lParam)
{
    UINT_PTR uiHi;
    HANDLE hDDE = 0;
    HDDEDATA hData;
    ULONG_PTR dwRet = 0;
    DWORD dwError;
    WORD wFmt, wStatus;
    LATOM al;

    // See what we have

    UnpackDDElParam(WM_DDE_DATA, lParam, (PUINT_PTR)&hDDE, &uiHi);

    if (!(psi->ci.pcii->afCmd & CBF_FAIL_POKES)) {
        if (!hDDE) {
            goto Ack;
        }
        if (!ExtractDDEDataInfo(hDDE, &wStatus, &wFmt)) {
            FreeDDEData(hDDE, FALSE, TRUE);             // free message data
            goto Ack;
        }

        hData = InternalCreateDataHandle(psi->ci.pcii, (LPBYTE)hDDE, (DWORD)-1, 0,
                HDATA_NOAPPFREE | HDATA_READONLY, 0, 0);
        if (!hData) {
            SetLastDDEMLError(psi->ci.pcii, DMLERR_MEMORY_ERROR);
            FreeDDEData(hDDE, FALSE, TRUE);       // free message data
            goto Ack;                             // Nack it.
            return(TRUE);
        }

        al = GlobalToLocalAtom((GATOM)uiHi);
            dwRet = (ULONG_PTR)DoCallback(psi->ci.pcii, XTYP_POKE,
                    wFmt, psi->ci.hConv,
                    NORMAL_HSZ_FROM_LATOM(psi->ci.laTopic),
                    NORMAL_HSZ_FROM_LATOM(al),
                    hData, 0, 0);
        DeleteAtom(al);
        UnpackAndFreeDDEMLDataHandle(hData, FALSE);
    }
    if (dwRet == (ULONG_PTR)CBR_BLOCK) {

        // Note: this code makes an app that return s CBR_BLOCK unable to
        // access the data after the callback return .

        return (FALSE);
    }
    if (dwRet & DDE_FACK) {
        FreeDDEData(hDDE, FALSE, TRUE);
    }

Ack:
    dwRet &= ~DDE_FACKRESERVED;
    dwError = PackAndPostMessage(psi->ci.hwndPartner, WM_DDE_POKE, WM_DDE_ACK,
            psi->ci.hwndConv, lParam, dwRet, uiHi);
    if (dwError) {
        SetLastDDEMLError(psi->ci.pcii, dwError);
    }
    return (TRUE);
}


/***************************************************************************\
* ClRespPokeAck
*
* Description:
* Response to a WM_DDE_ACK message in response to a WM_DDE_POKE message.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClRespPokeAck(
PXACT_INFO pxi,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;

    if (msg) {
        if (msg != WM_DDE_ACK) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        UnpackDDElParam(WM_DDE_ACK, lParam, &uiLo, &uiHi);
        if ((GATOM)uiHi != pxi->gaItem) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        GlobalDeleteAtom((ATOM)uiHi); // message copy

        pxi->state = XST_POKEACKRCVD;
        pxi->wStatus = (WORD)uiLo;

        if (!((WORD)uiLo & DDE_FACK)) {
            //
            // NACKs make it our business to free the poked data.
            //
            FreeDDEData(pxi->hDDESent, FALSE, TRUE);
        }

        if (TransactionComplete(pxi,
                (HDDEDATA)((ULONG_PTR)(pxi->wStatus & DDE_FACK ? 1 : 0)))) {
            goto Cleanup;
        }
    } else {
Cleanup:
        GlobalDeleteAtom(pxi->gaItem); // pxi copy
        UnlinkTransaction(pxi);
        if (pxi->hXact) {
            DestroyHandle(pxi->hXact);
        }
        DDEMLFree(pxi);
    }
    if (msg) {
        FreeDDElParam(msg, lParam);
    }
    return (TRUE);
}


//-------------------------------REQUEST-------------------------------//

/***************************************************************************\
* ClStartRequest
*
* Description:
* Start a request transaction.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClStartRequest(
PXACT_INFO pxi)
{
    DWORD dwError;

    IncGlobalAtomCount(pxi->gaItem); // message copy
    dwError = PackAndPostMessage(pxi->pcoi->hwndPartner, 0, WM_DDE_REQUEST,
            pxi->pcoi->hwndConv, 0, pxi->wFmt, pxi->gaItem);
    if (dwError) {
        SetLastDDEMLError(pxi->pcoi->pcii, dwError);
        GlobalDeleteAtom(pxi->gaItem); // message copy
        return (FALSE);
    }

    pxi->state = XST_REQSENT;
    pxi->pfnResponse = (FNRESPONSE)ClRespRequestData;
    LinkTransaction(pxi);
    return (TRUE);
}



/***************************************************************************\
* SvSpontRequest
*
* Description:
* Respond to a WM_DDE_REQUEST message.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SvSpontRequest(
PSVR_CONV_INFO psi,
LPARAM lParam)
{
    HANDLE hDDE = 0;
    HDDEDATA hDataRet;
    WORD wFmt, wStatus;
    DWORD dwError;
    LATOM la;

    if (psi->ci.pcii->afCmd & CBF_FAIL_REQUESTS) {
        goto Nack;
    }
    // See what we have

    // UnpackDDElParam(lParam, WM_DDE_REQUEST, .... Requests arn't packed
    wFmt = LOWORD(lParam);
    la = GlobalToLocalAtom((GATOM)HIWORD(lParam));
    hDataRet = DoCallback(psi->ci.pcii, XTYP_REQUEST,
            wFmt, psi->ci.hConv,
            NORMAL_HSZ_FROM_LATOM(psi->ci.laTopic),
            NORMAL_HSZ_FROM_LATOM(la),
            (HDDEDATA)0, 0, 0);
    DeleteAtom(la);

    if (hDataRet == CBR_BLOCK) {
        return (FALSE);
    }

    if (hDataRet) {

        hDDE = UnpackAndFreeDDEMLDataHandle(hDataRet, FALSE);
        if (!hDDE) {
            SetLastDDEMLError(psi->ci.pcii, DMLERR_DLL_USAGE);
            goto Nack;
        }
        if (!ExtractDDEDataInfo(hDDE, &wStatus, &wFmt)) {
            SetLastDDEMLError(psi->ci.pcii, DMLERR_DLL_USAGE);
            goto Nack;
        }
        if (!(wStatus & DDE_FRELEASE)) {
            // Its APPOWNED or relayed from another server - only safe
            // thing to do is use a copy.
            hDDE = CopyDDEData(hDDE, FALSE);
            if (!hDDE) {
                SetLastDDEMLError(psi->ci.pcii, DMLERR_MEMORY_ERROR);
                goto Nack;
            }
        }

        // Keep it simple, DDEML servers never ask for acks from requests.

        wStatus = DDE_FRELEASE | DDE_FREQUESTED;
        AllocAndSetDDEData((LPBYTE)hDDE, (DWORD)-1, wStatus, wFmt);

        // just reuse HIWORD(lParam) (aItem) - message copy
        if (dwError = PackAndPostMessage(psi->ci.hwndPartner, WM_DDE_REQUEST,
                WM_DDE_DATA, psi->ci.hwndConv, 0, (UINT_PTR)hDDE, HIWORD(lParam))) {
            SetLastDDEMLError(psi->ci.pcii, dwError);
            GlobalDeleteAtom(HIWORD(lParam)); // message copy
        }

    } else {
Nack:
        // just reuse HIWORD(lParam) (aItem) - message copy
        dwError = PackAndPostMessage(psi->ci.hwndPartner, WM_DDE_REQUEST,
                WM_DDE_ACK, psi->ci.hwndConv, 0, 0, HIWORD(lParam));
        if (dwError) {
            SetLastDDEMLError(psi->ci.pcii, dwError);
            GlobalDeleteAtom(HIWORD(lParam)); // message copy
        }
    }

    return (TRUE);
}


/***************************************************************************\
* ClRespRequestData
*
* Description:
* Handles response to either a WM_DDE_ACK or WM_DDE_DATA in response to
* a WM_DDE_REQUEST message.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClRespRequestData(
PXACT_INFO pxi,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;
    WORD wFmt, wStatus;
    DWORD dwError;

    if (msg) {
        switch (msg) {
        case WM_DDE_DATA:
            UnpackDDElParam(WM_DDE_DATA, lParam, (PUINT_PTR)&pxi->hDDEResult, &uiHi);
            if (!pxi->hDDEResult) {
                // must be an advise data message with NODATA.
                return (ClSpontAdviseData((PCL_CONV_INFO)pxi->pcoi, lParam));
            }
            if (!ExtractDDEDataInfo(pxi->hDDEResult, &wStatus, &wFmt)) {
                return (ClSpontAdviseData((PCL_CONV_INFO)pxi->pcoi, lParam));
            }
            if (!(wStatus & DDE_FREQUESTED)) {
                // must be advise data
                return (ClSpontAdviseData((PCL_CONV_INFO)pxi->pcoi, lParam));
            }
            if (wStatus & DDE_FACKREQ) {

                // if DDE_FRELEASE is not set, and this is a synchronous
                // transaction, we need to make a copy here so the user
                // can free at his leisure.

                // reuse uiHi - message copy
                dwError = PackAndPostMessage(pxi->pcoi->hwndPartner,
                        WM_DDE_DATA, WM_DDE_ACK, pxi->pcoi->hwndConv, 0,
                        pxi->wFmt == wFmt && pxi->gaItem == (GATOM)uiHi ?
                            DDE_FACK : 0, uiHi);
                if (dwError) {
                    SetLastDDEMLError(pxi->pcoi->pcii, dwError);
                }
            } else {
                GlobalDeleteAtom((GATOM)uiHi);     // message copy
            }
            if (wFmt != pxi->wFmt || (GATOM)uiHi != pxi->gaItem) {
                /*
                 * BOGUS returned data!  Just free it and make it look like
                 * a NACK
                 */
                FreeDDEData(pxi->hDDEResult, FALSE, TRUE);
                pxi->hDDEResult = 0;
                if (TransactionComplete(pxi, 0)) {
                    goto Cleanup;
                }
            } else {
                if (TransactionComplete(pxi, (HDDEDATA)-1)) {
                    goto Cleanup;
                }
            }
            break;

        case WM_DDE_ACK:
            UnpackDDElParam(WM_DDE_ACK, lParam, &uiLo, &uiHi);
            if ((GATOM)uiHi != pxi->gaItem) {
                return(SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
            }
            pxi->state = XST_DATARCVD;
            pxi->wStatus = (WORD)uiLo;
            GlobalDeleteAtom((GATOM)uiHi); // message copy
            if (TransactionComplete(pxi, 0)) {
                goto Cleanup;
            }
            break;

        default:
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

    } else {

Cleanup:
        GlobalDeleteAtom(pxi->gaItem); // pxi copy
        if (pxi->hDDEResult) {
            FreeDDEData(pxi->hDDEResult, FALSE, TRUE);  // free message data
        }
        UnlinkTransaction(pxi);
        DDEMLFree(pxi);
    }
    if (msg) {
        FreeDDElParam(msg, lParam);
    }
    return (TRUE);
}

//----------------------SPONTANEOUS CLIENT MESSAGE---------------------//

/***************************************************************************\
* SpontaneousClientMessage
*
* Description:
* General unexpected message client side handler.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SpontaneousClientMessage(
PCL_CONV_INFO pci,
UINT msg,
LPARAM lParam)
{
    switch (msg) {
    case WM_DDE_DATA:
        return (ClSpontAdviseData(pci, lParam));
        break;

    default:
        DumpDDEMessage(!(pci->ci.state & ST_INTRA_PROCESS), msg, lParam);
        ShutdownConversation((PCONV_INFO)pci, TRUE);
        return (TRUE);
    }
}

//----------------------SPONTANEOUS SERVER MESSAGE---------------------//

/***************************************************************************\
* SpontaneousServerMessage
*
* Description:
* General unexpected message server side handler.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SpontaneousServerMessage(
PSVR_CONV_INFO psi,
UINT msg,
LPARAM lParam)
{
    switch (msg) {
    case WM_DDE_ADVISE:
        return (SvSpontAdvise(psi, lParam));
        break;

    case WM_DDE_UNADVISE:
        return (SvSpontUnadvise(psi, lParam));
        break;

    case WM_DDE_EXECUTE:
        return (SvSpontExecute(psi, lParam));
        break;

    case WM_DDE_POKE:
        return (SvSpontPoke(psi, lParam));
        break;

    case WM_DDE_REQUEST:
        return (SvSpontRequest(psi, lParam));
        break;

    default:
        DumpDDEMessage(!(psi->ci.state & ST_INTRA_PROCESS), msg, lParam);

        /*
         * It use to call ShutdownConversation here. Don't call it
         * anymore. Fix for bugs: 49063, 70906
         */
        //ShutdownConversation((PCONV_INFO)psi, TRUE);
        return (TRUE);
    }
}



//-------------------------HELPER FUNCTIONS----------------------------//



/***************************************************************************\
* AllocAndSetDDEData
*
* Description:
* Worker function to create a data handle of size cb with wStatus and
* wFmt initialized. If cb == -1 pSrc is assumed to be a valid hDDE
* that is to have its data set.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
HANDLE AllocAndSetDDEData(
LPBYTE pSrc,
DWORD cb,
WORD wStatus,
WORD wFmt) // a 0 format implied execute data
{
    HANDLE hDDE;
    DWORD cbOff;
    PDDE_DATA pdde;
    DWORD fCopyIt;

    if (cb == -1) {
        hDDE = (HANDLE)pSrc;
        cb = (DWORD)GlobalSize(hDDE);
        fCopyIt = FALSE;
    } else {
        hDDE = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE | GMEM_ZEROINIT,
                (wFmt ? (cb + 4) : cb));
        fCopyIt = (pSrc != NULL);
    }
    if (hDDE == NULL) {
        return(0);
    }
    USERGLOBALLOCK(hDDE, pdde);
    if (pdde == NULL) {
        WOWGLOBALFREE(hDDE);
        return (0);
    }
    if (wFmt) {
        pdde->wStatus = wStatus;
        pdde->wFmt = wFmt;
        cbOff = 4;
    } else {
        cbOff = 0;
    }
    if (fCopyIt) {
        RtlCopyMemory((PBYTE)pdde + cbOff, pSrc, cb);
    }
    USERGLOBALUNLOCK(hDDE);

    return (hDDE);
}



/***************************************************************************\
* PackAndPostMessage
*
* Description:
* Worker function to provide common functionality. An error code is
* return ed on failure. 0 on success.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
DWORD PackAndPostMessage(
HWND hwndTo,
UINT msgIn,
UINT msgOut,
HWND hwndFrom,
LPARAM lParam,
UINT_PTR uiLo,
UINT_PTR uiHi)
{
    DWORD retval;

    lParam = ReuseDDElParam(lParam, msgIn, msgOut, uiLo, uiHi);
    if (!lParam) {
        return (DMLERR_MEMORY_ERROR);
    }
    CheckDDECritIn;
    LeaveDDECrit;
    CheckDDECritOut;

    retval = (DWORD)PostMessage(hwndTo, msgOut, (WPARAM)hwndFrom, lParam);
    switch (retval) {
    case FAIL_POST:
#if (FAIL_POST != FALSE)
#error FAIL_POST must be defined as PostMessage's failure return value.
#endif
        FreeDDElParam(msgOut, lParam);
        RIPMSG0(RIP_WARNING, "PostMessage failed.");
        /* Fall through */

    case FAILNOFREE_POST:
        retval = DMLERR_POSTMSG_FAILED;
        break;

    default:
#if (FAKE_POST != TRUE)
#error FAKE_POST must be defined as PostMessage's success return value.
#endif
        UserAssert(retval == TRUE);
        retval = 0;
    }

    EnterDDECrit;
    return (retval);
}



/***************************************************************************\
* ExtractDDEDataInfo
*
* Description:
* Worker function to retrieve wStatus and wFmt from a standard DDE data
* handle - NOT FOR EXECUTE HANDLES.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ExtractDDEDataInfo(
HANDLE hDDE,
LPWORD pwStatus,
LPWORD pwFmt)
{
    PDDE_DATA pdde;

    USERGLOBALLOCK(hDDE, pdde);
    if (pdde == NULL) {
        return (FALSE);
    }
    *pwStatus = pdde->wStatus;
    *pwFmt = pdde->wFmt;
    USERGLOBALUNLOCK(hDDE);
    return (TRUE);
}



/***************************************************************************\
* TransactionComplete
*
* Description:
* Called when a response function completes a transaction. pxi->wStatus,
* pxi->flags, pxi->wFmt, pxi->gaItem, pxi->hXact, and hData are expected
* to be set apropriately for a XTYP_XACT_COMPLETE callback.
*
* fCleanup is returned - TRUE implies the calling function needs to
* cleanup its pxi before returning.  (fAsync case.)
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL TransactionComplete(
PXACT_INFO pxi,
HDDEDATA hData)
{
    LATOM al;
    BOOL fMustFree;

    if (pxi->flags & XIF_ABANDONED) {
        UserAssert(!(pxi->flags & XIF_SYNCHRONOUS));
        return (TRUE);
    }
    pxi->flags |= XIF_COMPLETE;
    if (pxi->flags & XIF_SYNCHRONOUS) {
        PostMessage(pxi->pcoi->hwndConv, WM_TIMER, TID_TIMEOUT, 0);
        return (FALSE);
    } else {
        if (hData == (HDDEDATA)(-1)) {
            fMustFree = TRUE;
            hData = InternalCreateDataHandle(pxi->pcoi->pcii,
                (LPBYTE)pxi->hDDEResult, (DWORD)-1, 0,
                HDATA_NOAPPFREE | HDATA_READONLY, 0, 0);
        } else {
            fMustFree = FALSE;
        }
        al = GlobalToLocalAtom(pxi->gaItem);

        if (!(pxi->wStatus & DDE_FACK)) {
            if (pxi->wStatus & DDE_FBUSY) {
                SetLastDDEMLError(pxi->pcoi->pcii, DMLERR_BUSY);
            } else {
                SetLastDDEMLError(pxi->pcoi->pcii, DMLERR_NOTPROCESSED);
            }
        }

        /*
         * During the callback the app may disconnect or otherwise kill
         * this conversation so we unlink the pxi FIRST so cleanup code
         * doesn't destroy it before this transaction code exits.
         */
        UnlinkTransaction(pxi);

        DoCallback(
            pxi->pcoi->pcii,
            (WORD)XTYP_XACT_COMPLETE,
            pxi->wFmt,
            pxi->pcoi->hConv,
            NORMAL_HSZ_FROM_LATOM(pxi->pcoi->laTopic),
            (HSZ)al,
            hData,
            (ULONG_PTR)pxi->hXact,
            (DWORD)pxi->wStatus);
        DeleteAtom(al);
        if (fMustFree) {
            InternalFreeDataHandle(hData, FALSE);
            pxi->hDDEResult = 0;
        }

        /*
         * during the callback is the only time the app has to access the
         * transaction information.   pxi->hXact will be invalid once he
         * returns.
         */
        if (pxi->hXact) {
            DestroyHandle(pxi->hXact);
            pxi->hXact = 0;
        }
        return (TRUE);
    }
}



/***************************************************************************\
* UnpackAndFreeDDEMLDataHandle
*
* Description:
* Removes DDEML data handle wrapping from a DDE data handle. If the
* data handle is APPOWNED the wrapping is NOT freed. The hDDE is
* return ed or 0 on failure. If fExec is FALSE, this call fails on
* HDATA_EXECUTE type handles.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
HANDLE UnpackAndFreeDDEMLDataHandle(
HDDEDATA hData,
BOOL fExec)
{
    PDDEMLDATA pdd;
    HANDLE hDDE;

    CheckDDECritIn;

    if (hData == 0) {
        return (0);
    }
    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData, HTYPE_DATA_HANDLE,
            HINST_ANY);
    if (pdd == NULL) {
        return (0);
    }
    if (!fExec && pdd->flags & HDATA_EXECUTE) {
        return (0);
    }

    hDDE = pdd->hDDE;
    if (pdd->flags & HDATA_APPOWNED) {
        return (hDDE); // don't destroy appowned data handles
    }
    DDEMLFree(pdd);
    DestroyHandle((HANDLE)hData);
    return (hDDE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\strings.c ===
/****************************** Module Header ******************************\
* Module Name: strings.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the string handling APIs and functions.  Since
* they don't access server-specific data they belong here in the client DLL.
*
* History:
* 10-18-90 DarrinM      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/* LATER these should be in a public header file!!!
 * Assorted defines used to support the standard Windows ANSI code page
 * (now known as code page 1252 and officially registered by IBM).
 * This is intended only for the PDK release.  Subsequent releases will
 * use the NLSAPI and Unicode.
 */
#define LATIN_CAPITAL_LETTER_A_GRAVE    (CHAR)0xc0
#define LATIN_CAPITAL_LETTER_THORN      (CHAR)0xde
#define LATIN_SMALL_LETTER_SHARP_S      (CHAR)0xdf
#define LATIN_SMALL_LETTER_Y_DIAERESIS  (CHAR)0xff
#define DIVISION_SIGN                   (CHAR)0xf7
#define MULTIPLICATION_SIGN             (CHAR)0xd7


/***************************************************************************\
* CharLowerA (API)
*
* Convert either a single character or an entire string to lower case.  The
* two cases are differentiated by checking the high-word of psz.  If it is
* 0 then we just convert the low-word of psz.
*
* History:
* 11-26-90 DarrinM      Created non-NLS version.
* 06-22-91 GregoryW     Modified to support code page 1252.  This is for
*                       the PDK release only.  After the PDK this routine
*                       will be modified to use the NLSAPI.  Also renamed
*                       API to conform to new naming conventions.  AnsiLower
*                       is now a #define which resolves to this routine.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, LPSTR, WINAPI, CharLowerA, LPSTR, psz)
LPSTR WINAPI CharLowerA(
    LPSTR psz)
{
    NTSTATUS st;

    /*
     * Early out for NULL string or '\0'
     */
    if (psz == NULL) {
        return psz;
    }

    if (!IS_PTR(psz)) {
        WCHAR wch;

#ifdef FE_SB // CharLowerA()
        /*
         * if only DBCS Leadbyte was passed, just return the character.
         * Same behavior as Windows 3.1J and Windows 95 FarEast version.
         */
        if (IS_DBCS_ENABLED() && IsDBCSLeadByte((BYTE)(ULONG_PTR)psz)) {
            return psz;
        }
#endif // FE_SB

        //
        // LATER 14 Feb 92 GregoryW
        //    For DBCS code pages is a double byte character ever
        //    passed in the low word of psz or is the high nibble
        //    of the low word always ignored?
        //
        st = RtlMultiByteToUnicodeN(&wch, sizeof(WCHAR), NULL, (PCH)&psz, sizeof(CHAR));
        if (!NT_SUCCESS(st)) {
            /*
             * Failed!  Caller is not expecting failure, CharLowerA does not
             * have a failure indicator, so just return the original character.
             */
            RIPMSG1(RIP_WARNING, "CharLowerA(%#p) failed\n", psz);
        } else {
            /*
             * The next two calls never fail.
             */
            LCMapStringW(LOCALE_USER_DEFAULT, LCMAP_LOWERCASE, &wch, 1, &wch, 1);
            RtlUnicodeToMultiByteN((PCH)&psz, sizeof(CHAR), NULL, &wch, sizeof(WCHAR));
        }
        return psz;

    }

    /*
     * psz is a null-terminated string
     */
    CharLowerBuffA(psz, strlen(psz)+1);
    return psz;
}


/***************************************************************************\
* CharUpperA (API)
*
* Convert either a single character or an entire string to upper case.  The
* two cases are differentiated by checking the high-word of psz.  If it is
* 0 then we just convert the low-word of psz.
*
* History:
* 12-03-90 IanJa        derived from DarrinM's non-NLS AnsiLower
* 06-22-91 GregoryW     Modified to support code page 1252.  This is for
*                       the PDK release only.  After the PDK this routine
*                       will be modified to use the NLSAPI.  Also renamed
*                       API to conform to new naming conventions.  AnsiUpper
*                       is now a #define which resolves to this routine.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, LPSTR, WINAPI, CharUpperA, LPSTR, psz)
LPSTR WINAPI CharUpperA(
    LPSTR psz)
{
    NTSTATUS st;

    /*
     * Early out for NULL string or '\0'
     */
    if (psz == NULL) {
        return psz;
    }

    if (!IS_PTR(psz)) {
        WCHAR wch;

#ifdef FE_SB // CharLowerA()
        /*
         * if only DBCS Leadbyte was passed, just return the character.
         * Same behavior as Windows 3.1J and Windows 95 FarEast version.
         */
        if (IS_DBCS_ENABLED() && IsDBCSLeadByte((BYTE)(ULONG_PTR)psz)) {
            return psz;
        }
#endif // FE_SB

        //
        // LATER 14 Feb 92 GregoryW
        //    For DBCS code pages is a double byte character ever
        //    passed in the low word of psz or is the high nibble
        //    of the low word always ignored?
        //
        st = RtlMultiByteToUnicodeN(&wch, sizeof(WCHAR), NULL, (PCH)&psz, sizeof(CHAR));
        if (!NT_SUCCESS(st)) {
            /*
             * Failed!  Caller is not expecting failure, CharUpperA does not
             * have a failure indicator, so return the original character.
             */
            RIPMSG1(RIP_WARNING, "CharUpperA(%#p) failed\n", psz);
        } else {
            /*
             * The next two calls never fail.
             */
            LCMapStringW(LOCALE_USER_DEFAULT, LCMAP_UPPERCASE, &wch, 1, &wch, 1);
            RtlUnicodeToMultiByteN((PCH)&psz, sizeof(CHAR), NULL, &wch, sizeof(WCHAR));
        }
        return psz;

    }

    /*
     * psz is a null-terminated string
     */
    CharUpperBuffA(psz, strlen(psz)+1);
    return psz;
}


/***************************************************************************\
* CharNextA (API)
*
* Move to next character in string unless already at '\0' terminator
* DOES NOT WORK CORRECTLY FOR DBCS (eg: Japanese)
*
* History:
* 12-03-90 IanJa        Created non-NLS version.
* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.
*                       AnsiNext is now a #define which resolves to this
*                       routine.  This routine is only intended to support
*                       code page 1252 for the PDK release.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, LPSTR, WINAPI, CharNextA, LPCSTR, lpCurrentChar)
LPSTR WINAPI CharNextA(
    LPCSTR lpCurrentChar)
{
#ifdef FE_SB // CharNextA(): dbcs enabling
    if (IS_DBCS_ENABLED() && IsDBCSLeadByte(*lpCurrentChar)) {
        lpCurrentChar++;
    }
    /*
     * if we have only DBCS LeadingByte, we will point string-terminaler.
     */
#endif // FE_SB

    if (*lpCurrentChar) {
        lpCurrentChar++;
    }
    return (LPSTR)lpCurrentChar;
}


/***************************************************************************\
* CharNextExA (API)
*
* Move to next character in string unless already at '\0' terminator.
*
* History:
* 05-01-95 GregoryW     Ported from Win95.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, LPSTR, WINAPI, CharNextExA, WORD, CodePage, LPCSTR, lpCurrentChar, DWORD, dwFlags)
LPSTR WINAPI CharNextExA(
    WORD CodePage,
    LPCSTR lpCurrentChar,
    DWORD dwFlags)
{
    if (lpCurrentChar == (LPSTR)NULL)
    {
        return (LPSTR)lpCurrentChar;
    }

    if (IsDBCSLeadByteEx(CodePage, *lpCurrentChar))
    {
        lpCurrentChar++;
    }

    if (*lpCurrentChar)
    {
        lpCurrentChar++;
    }
    return (LPSTR)lpCurrentChar;

    UNREFERENCED_PARAMETER(dwFlags);
}


/***************************************************************************\
* CharPrevA (API)
*
* Move to previous character in string, unless already at start
* DOES NOT WORK CORRECTLY FOR DBCS (eg: Japanese)
*
* History:
* 12-03-90 IanJa        Created non-NLS version.
* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.
*                       AnsiPrev is now a #define which resolves to this
*                       routine.  This routine is only intended to support
*                       code page 1252 for the PDK release.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, LPSTR, WINAPI, CharPrevA, LPCSTR, lpStart, LPCSTR, lpCurrentChar)
LPSTR WINAPI CharPrevA(
    LPCSTR lpStart,
    LPCSTR lpCurrentChar)
{
#ifdef FE_SB // CharPrevA : dbcs enabling
    if (lpCurrentChar > lpStart) {
        if (IS_DBCS_ENABLED()) {
            LPCSTR lpChar;
            BOOL bDBC = FALSE;

            for (lpChar = --lpCurrentChar - 1 ; lpChar >= lpStart ; lpChar--) {
                if (!IsDBCSLeadByte(*lpChar))
                    break;
                bDBC = !bDBC;
            }

            if (bDBC)
                lpCurrentChar--;
        }
        else
            lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;
#else
    if (lpCurrentChar > lpStart) {
        lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;
#endif // FE_SB
}

/***************************************************************************\
* CharPrevExA (API)
*
* Move to previous character in string, unless already at start.
*
* History:
* 05-01-95 GregoryW     Ported from Win95.
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, LPSTR, WINAPI, CharPrevExA, WORD, CodePage, LPCSTR, lpStart, LPCSTR, lpCurrentChar, DWORD, dwFlags)
LPSTR WINAPI CharPrevExA(
    WORD CodePage,
    LPCSTR lpStart,
    LPCSTR lpCurrentChar,
    DWORD dwFlags)
{
    if (lpCurrentChar > lpStart) {
        LPCSTR lpChar;
        BOOL bDBC = FALSE;

        for (lpChar = --lpCurrentChar - 1 ; lpChar >= lpStart ; lpChar--) {
            if (!IsDBCSLeadByteEx(CodePage, *lpChar))
                break;
            bDBC = !bDBC;
        }

        if (bDBC)
            lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;

    UNREFERENCED_PARAMETER(dwFlags);
}


/***************************************************************************\
* CharLowerBuffA (API)
*
* History:
* 14-Jan-1991 mikeke from win 3.0
* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.
*                       AnsiLowerBuff is now a #define which resolves to this
*                       routine.  This routine is only intended to support
*                       code page 1252 for the PDK release.
* 02-20-1992 GregoryW   Modified to use NLS API.
\***************************************************************************/
#define CCH_LOCAL_BUFF 256


FUNCLOG2(LOG_GENERAL, DWORD, WINAPI, CharLowerBuffA, LPSTR, psz, DWORD, nLength)
DWORD WINAPI CharLowerBuffA(
    LPSTR psz,
    DWORD nLength)
{
    ULONG cb;
    WCHAR awchLocal[CCH_LOCAL_BUFF];
    LPWSTR pwszT = awchLocal;
    int cwch;

    if (nLength == 0) {
        return(0);
    }

    /*
     * Convert ANSI to Unicode.
     * Use awchLocal if it is big enough, otherwise allocate space.
     */
    cwch = MBToWCS(
            psz,       // ANSI buffer
            nLength,   // length of buffer
            &pwszT,    // address of Unicode string
            (nLength > CCH_LOCAL_BUFF ? -1 : nLength),
            (nLength > CCH_LOCAL_BUFF) );

    if (cwch != 0) {
        CharLowerBuffW(pwszT, cwch);

        /*
         * This can't fail
         */
        RtlUnicodeToMultiByteN(
                  psz,                   // ANSI string
                  nLength,               // given to us
                  &cb,                   // result length
                  pwszT,                 // Unicode string
                  cwch * sizeof(WCHAR)); // length IN BYTES

        if (pwszT != awchLocal) {
            UserLocalFree(pwszT);
        }

        return (DWORD)cb;
    }

    /*
     * MBToWCS failed!  The caller is not expecting failure,
     * so we convert the string to lower case as best we can.
     */
    RIPMSG2(RIP_WARNING,
            "CharLowerBuffA(%#p, %lx) failed\n", psz, nLength);

    for (cb=0; cb < nLength; cb++) {
#ifdef FE_SB // CharLowerBuffA(): skip double byte character
        if (IS_DBCS_ENABLED() && IsDBCSLeadByte(psz[cb])) {
            cb++;
        } else if (IsCharUpperA(psz[cb])) {
            psz[cb] += 'a'-'A';
        }
#else
        if (IsCharUpperA(psz[cb])) {
            psz[cb] += 'a'-'A';
        }
#endif // FE_SB
    }

    return nLength;
}


/***************************************************************************\
* CharUpperBuffA (API)
*
* History:
* 14-Jan-1991 mikeke from win 3.0
* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.
*                       AnsiUpperBuff is now a #define which resolves to this
*                       routine.  This routine is only intended to support
*                       code page 1252 for the PDK release.
* 02-Feb-1992 GregoryW   Modified to use NLS API.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, DWORD, WINAPI, CharUpperBuffA, LPSTR, psz, DWORD, nLength)
DWORD WINAPI CharUpperBuffA(
    LPSTR psz,
    DWORD nLength)
{
    DWORD cb;
    WCHAR awchLocal[CCH_LOCAL_BUFF];
    LPWSTR pwszT = awchLocal;
    int cwch;

    if (nLength==0) {
        return(0);
    }

    /*
     * Convert ANSI to Unicode.
     * Use awchLocal if it is big enough, otherwise allocate space.
     */
    cwch = MBToWCS(
            psz,       // ANSI buffer
            nLength,   // length of buffer
            &pwszT,    // address of Unicode string
            (nLength > CCH_LOCAL_BUFF ? -1 : nLength),
            (nLength > CCH_LOCAL_BUFF) );

    if (cwch != 0) {
        CharUpperBuffW(pwszT, cwch);

        RtlUnicodeToMultiByteN(
                  psz,                   // address of ANSI string
                  nLength,               // given to us
                  &cb,                   // result length
                  pwszT,                 // Unicode string
                  cwch * sizeof(WCHAR)); // length IN BYTES

        if (pwszT != awchLocal) {
            UserLocalFree(pwszT);
        }

        return (DWORD)cb;
    }

    /*
     * MBToWCS failed!  The caller is not expecting failure,
     * so we convert the string to upper case as best we can.
     */
    RIPMSG2(RIP_WARNING,
            "CharLowerBuffA(%#p, %lx) failed\n", psz, nLength);

    for (cb=0; cb < nLength; cb++) {
#ifdef FE_SB // CharUpperBuffA(): skip double byte characters
        if (IS_DBCS_ENABLED() && IsDBCSLeadByte(psz[cb])) {
            cb++;
        } else if (IsCharLowerA(psz[cb]) &&
                   /*
                    * Sometime, LATIN_xxxx code is DBCS LeadingByte depending on ACP.
                    * In that case, we never come here...
                    */
                   (psz[cb] != LATIN_SMALL_LETTER_SHARP_S) &&
                   (psz[cb] != LATIN_SMALL_LETTER_Y_DIAERESIS)) {
            psz[cb] += 'A'-'a';
        }
#else
        if (IsCharLowerA(psz[cb]) &&
            (psz[cb] != LATIN_SMALL_LETTER_SHARP_S) &&
            (psz[cb] != LATIN_SMALL_LETTER_Y_DIAERESIS)) {
            psz[cb] += 'A'-'a';
        }
#endif // FE_SB
    }

    return nLength;
}


/***************************************************************************\
* IsCharLowerA (API)
*
* History:
* 14-Jan-1991 mikeke from win 3.0
* 22-Jun-1991 GregoryW   Modified to support code page 1252 (Windows ANSI
*                        code page).  This is for the PDK only.  After the
*                        PDK this routine will be rewritten to use the
*                        NLSAPI.
* 02-Feb-1992 GregoryW   Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharLowerA, char, cChar)
BOOL WINAPI IsCharLowerA(
    char cChar)
{
    WORD ctype1info = 0;
    WCHAR wChar = 0;

#ifdef FE_SB // IsCharLowerA()
    /*
     * if only DBCS Leadbyte was passed, just return FALSE.
     * Same behavior as Windows 3.1J and Windows 95 FarEast version.
     */
    if (IS_DBCS_ENABLED() && IsDBCSLeadByte(cChar)) {
        return FALSE;
    }
#endif // FE_SB

    /*
     * The following 2 calls cannot fail here
     */
    RtlMultiByteToUnicodeN(&wChar, sizeof(WCHAR), NULL, &cChar, sizeof(CHAR));
    GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info);
    return (ctype1info & C1_LOWER) == C1_LOWER;
}


/***************************************************************************\
* IsCharUpperA (API)
*
* History:
* 22-Jun-1991 GregoryW   Created to support code page 1252 (Windows ANSI
*                        code page).  This is for the PDK only.  After the
*                        PDK this routine will be rewritten to use the
*                        NLSAPI.
* 02-Feb-1992 GregoryW   Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharUpperA, char, cChar)
BOOL WINAPI IsCharUpperA(
    char cChar)
{
    WORD ctype1info = 0;
    WCHAR wChar = 0;

#ifdef FE_SB // IsCharUpperA()
    /*
     * if only DBCS Leadbyte was passed, just return FALSE.
     * Same behavior as Windows 3.1J and Windows 95 FarEast version.
     */
    if (IS_DBCS_ENABLED() && IsDBCSLeadByte(cChar)) {
        return FALSE;
    }
#endif // FE_SB

    /*
     * The following 2 calls cannot fail here
     */
    RtlMultiByteToUnicodeN(&wChar, sizeof(WCHAR), NULL, &cChar, sizeof(CHAR));
    GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info);
    return (ctype1info & C1_UPPER) == C1_UPPER;
}


/***************************************************************************\
* IsCharAlphaNumericA (API)
*
* Returns TRUE if character is alphabetical or numerical, otherwise FALSE
*
* History:
* 12-03-90 IanJa        Created non-NLS stub version.
* 06-22-91 GregoryW     Modified to support code page 1252 (Windows ANSI
*                       code page).  This is for the PDK only.  After the
*                       PDK this routine will be rewritten to use the
*                       NLSAPI.
* 02-20-92 GregoryW     Modified to use the NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharAlphaNumericA, char, cChar)
BOOL WINAPI IsCharAlphaNumericA(
    char cChar)
{
    WORD ctype1info = 0;
    WCHAR wChar = 0;

    /*
     * The following 2 calls cannot fail here
     */
    RtlMultiByteToUnicodeN(&wChar, sizeof(WCHAR), NULL, &cChar, sizeof(CHAR));
    GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info);
#ifdef FE_SB // IsCharAlphaNumericA()
    if (ctype1info & C1_ALPHA) {
        WORD ctype3info = 0;
        if (!IS_DBCS_ENABLED()) {
            return TRUE;
        }
        /*
         * We don't want to return TRUE for halfwidth katakana.
         * Katakana is linguistic character (C1_ALPHA), but it is not
         * alphabet character.
         */
        GetStringTypeW(CT_CTYPE3, &wChar, 1, &ctype3info);
        return ((ctype3info & (C3_KATAKANA|C3_HIRAGANA)) ? FALSE : TRUE);
    }
    /* Otherwise, it might be digits ? */
    return !!(ctype1info & C1_DIGIT);
#else
    return (ctype1info & C1_ALPHA) || (ctype1info & C1_DIGIT);
#endif // FE_SB
}


/***************************************************************************\
* IsCharAlphaA (API)
*
* Returns TRUE if character is alphabetical, otherwise FALSE
*
* History:
* 06-22-91 GregoryW     Created to support code page 1252 (Windows ANSI
*                       code page).  This is for the PDK only.  After the
*                       PDK this routine will be rewritten to use the
*                       NLSAPI.
* 02-20-92 GregoryW     Modified to use the NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharAlphaA, char, cChar)
BOOL WINAPI IsCharAlphaA(
    char cChar)
{
    WORD ctype1info = 0;
    WCHAR wChar = 0;

    /*
     * The following 2 calls cannot fail here
     */
    RtlMultiByteToUnicodeN(&wChar, sizeof(WCHAR), NULL, &cChar, sizeof(CHAR));
    GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info);
#ifdef FE_SB // IsCharAlphaA()
    if ((ctype1info & C1_ALPHA) == C1_ALPHA) {
        WORD ctype3info = 0;
        if (!IS_DBCS_ENABLED()) {
            return TRUE;
        }
        /*
         * We don't want to return TRUE for halfwidth katakana.
         * Katakana is linguistic character (C1_ALPHA), but it is not
         * alphabet character.
         */
        GetStringTypeW(CT_CTYPE3, &wChar, 1, &ctype3info);
        return ((ctype3info & (C3_KATAKANA|C3_HIRAGANA)) ? FALSE : TRUE);
    }
    return (FALSE);
#else
    return (ctype1info & C1_ALPHA) == C1_ALPHA;
#endif // FE_SB
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\wow64\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\wow.c ===
/****************************** Module Header ******************************\
* Module Name: wow.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains shared code between USER32 and USER16
* No New CODE should be added to this file, unless its shared
* with USER16.
*
* History:
* 29-DEC-93 NanduriR      shared user32/user16 code.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* ValidateHwnd
*
* Verify that the handle is valid.  If the handle is invalid or access
* cannot be granted fail.
*
* History:
* 03-18-92 DarrinM      Created from pieces of misc server-side funcs.
\***************************************************************************/
PWND FASTCALL ValidateHwnd(
    HWND hwnd)
{
    PCLIENTINFO pci = GetClientInfo();

    /*
     * Attempt fast window validation.
     */
    if (hwnd != NULL && hwnd == pci->CallbackWnd.hwnd) {
        return pci->CallbackWnd.pwnd;
    }

    /*
     * Validate that the handle is of the proper type.
     */
    return HMValidateHandle(hwnd, TYPE_WINDOW);
}


PWND FASTCALL ValidateHwndNoRip(
    HWND hwnd)
{
    PCLIENTINFO pci = GetClientInfo();

    /*
     * Attempt fast window validation.
     */
    if (hwnd != NULL && hwnd == pci->CallbackWnd.hwnd) {
        return pci->CallbackWnd.pwnd;
    }

    /*
     * Validate the handle is of the proper type.
     */
    return HMValidateHandleNoRip(hwnd, TYPE_WINDOW);
}




FUNCLOG3(LOG_GENERAL, int, WINAPI, GetClassNameA, HWND, hwnd, LPSTR, lpClassName, int, nMaxCount)
int WINAPI GetClassNameA(
    HWND hwnd,
    LPSTR lpClassName,
    int nMaxCount)
{
    PCLS pcls;
    LPSTR lpszClassNameSrc;
    PWND pwnd;
    int cchSrc;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return FALSE;

    try {
        if (nMaxCount != 0) {
            pcls = (PCLS)REBASEALWAYS(pwnd, pcls);
            lpszClassNameSrc = REBASEPTR(pwnd, pcls->lpszAnsiClassName);
            cchSrc = lstrlenA(lpszClassNameSrc);
            nMaxCount = min(cchSrc, nMaxCount - 1);
            RtlCopyMemory(lpClassName, lpszClassNameSrc, nMaxCount);
            lpClassName[nMaxCount] = '\0';
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        nMaxCount = 0;
    }

    return nMaxCount;
}

/***************************************************************************\
* _GetDesktopWindow (API)
*
* History:
* 11-07-90 darrinm      Implemented.
\***************************************************************************/
PWND _GetDesktopWindow(
    VOID)
{
    PCLIENTINFO pci;

    ConnectIfNecessary(0);

    pci = GetClientInfo();
    return (PWND)((KERNEL_ULONG_PTR)pci->pDeskInfo->spwnd - pci->ulClientDelta);
}


HWND GetDesktopWindow(
    VOID)
{
    PWND pwnd = _GetDesktopWindow();
    PCLIENTINFO pci = GetClientInfo();

    /*
     * Validate the parent window's handle if a restricted process.
     */
    if (pci && (pci->dwTIFlags & TIF_RESTRICTED)) {
        if (ValidateHwnd(HW(pwnd)) == NULL) {
            return NULL;
        }
    }

    return HW(pwnd);
}


PWND _GetDlgItem(
    PWND pwnd,
    int id)
{
    if (pwnd != NULL) {
        pwnd = REBASEPWND(pwnd, spwndChild);
        while (pwnd != NULL) {
            if (PtrToLong(pwnd->spmenu) == id) {
                break;
            }
            pwnd = REBASEPWND(pwnd, spwndNext);
        }
    }

    return pwnd;
}


FUNCLOG2(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, GetDlgItem, HWND, hwnd, int, id)
HWND GetDlgItem(
    HWND hwnd,
    int id)
{
    PWND pwnd;
    HWND hwndRet;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return NULL;
    }

    pwnd = _GetDlgItem(pwnd, id);

    hwndRet = HW(pwnd);

    if (hwndRet == (HWND)0) {
        RIPERR0(ERROR_CONTROL_ID_NOT_FOUND, RIP_VERBOSE, "");
    }

    return hwndRet;
}



FUNCLOG1(LOG_GENERAL, HMENU, DUMMYCALLINGTYPE, GetMenu, HWND, hwnd)
HMENU GetMenu(
    HWND hwnd)
{
    PWND pwnd;
    PMENU pmenu;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return 0;
    }

    /*
     * Some ill-behaved apps use GetMenu to get the child id, so
     * only map to the handle for non-child windows.
     */
    if (!TestwndChild(pwnd)) {
        pmenu = REBASE(pwnd, spmenu);
        return (HMENU)PtoH(pmenu);
    } else {
        return (HMENU)KPVOID_TO_PVOID(pwnd->spmenu);
    }
}


/***************************************************************************\
* GetMenuItemCount
*
* Returns a count of the number of items in the menu. Returns -1 if
* invalid menu.
*
* History:
\***************************************************************************/
FUNCLOG1(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetMenuItemCount, HMENU, hMenu)
int GetMenuItemCount(
    HMENU hMenu)
{
    PMENU pMenu;

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return -1;
    }

    return pMenu->cItems;
}

/***************************************************************************\
* GetMenuItemID
*
* Return the ID of a menu item at the specified position.
*
* History:
\***************************************************************************/
FUNCLOG2(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, GetMenuItemID, HMENU, hMenu, int, nPos)
UINT GetMenuItemID(
    HMENU hMenu,
    int nPos)
{
    PMENU pMenu;
    PITEM pItem;

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return (UINT)-1;
    }

    /*
     * If the position is valid and the item is not a popup, get the ID
     * Don't allow negative indexes, because that'll cause an access violation.
     */
    if (nPos < (int)pMenu->cItems && nPos >= 0) {
        pItem = &((PITEM)REBASEALWAYS(pMenu, rgItems))[nPos];
        if (pItem->spSubMenu == NULL) {
            return pItem->wID;
        }
    }

    return (UINT)-1;
}



FUNCLOG3(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, GetMenuState, HMENU, hMenu, UINT, uId, UINT, uFlags)
UINT GetMenuState(
    HMENU hMenu,
    UINT uId,
    UINT uFlags)
{
    PMENU pMenu;

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL || (uFlags & ~MF_VALID) != 0) {
        return (UINT)-1;
    }

    return _GetMenuState(pMenu, uId, uFlags);
}



FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsWindow, HWND, hwnd)
BOOL IsWindow(
    HWND hwnd)
{
    PWND pwnd;

    /*
     * Validate the handle is of type window
     */
    pwnd = ValidateHwndNoRip(hwnd);

    /*
     * And validate this handle is valid for this desktop by trying to read it
     */
    if (pwnd != NULL) {
        try {
            if (pwnd->fnid & FNID_DELETED_BIT) {
                pwnd = 0;
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            RIPMSG1(RIP_WARNING, "IsWindow: Window %#p not of this desktop",
                    pwnd);
            pwnd = 0;
        }
    }

    return !!pwnd;
}


FUNCLOG2(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, GetWindow, HWND, hwnd, UINT, wCmd)
HWND GetWindow(
    HWND hwnd,
    UINT wCmd)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return NULL;
    }

    pwnd = _GetWindow(pwnd, wCmd);
    return HW(pwnd);
}


FUNCLOG1(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, GetParent, HWND, hwnd)
HWND GetParent(
    HWND hwnd)
{
    PWND        pwnd;
    PCLIENTINFO pci;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return NULL;
    }

    try {
        pwnd = _GetParent(pwnd);
        hwnd = HW(pwnd);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        hwnd = NULL;
    }

    pci = GetClientInfo();

    /*
     * validate the parent window's handle if a restricted process
     */
    if (pci && (pci->dwTIFlags & TIF_RESTRICTED)) {
        if (ValidateHwnd(hwnd) == NULL) {
            return NULL;
        }
    }

    return hwnd;
}


FUNCLOG2(LOG_GENERAL, HMENU, DUMMYCALLINGTYPE, GetSubMenu, HMENU, hMenu, int, nPos)
HMENU GetSubMenu(
    HMENU hMenu,
    int nPos)
{
    PMENU pMenu;

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return 0;
    }

    pMenu = _GetSubMenu(pMenu, nPos);
    return (HMENU)PtoH(pMenu);
}



FUNCLOG1(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, GetSysColor, int, nIndex)
DWORD GetSysColor(
    int nIndex)
{
    /*
     * Return 0 if the index is out of range.
     */
    if (nIndex < 0 || nIndex >= COLOR_MAX) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"nIndex\" (%ld) to GetSysColor",
                nIndex);

        return 0;
    }

    return gpsi->argbSystem[nIndex];
}



FUNCLOG1(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetSystemMetrics, int, index)
int GetSystemMetrics(
    int index)
{
    int ret;

    BEGIN_USERAPIHOOK()
        ret = guah.pfnGetSystemMetrics(index);
    END_USERAPIHOOK()

    return ret;
}


int RealGetSystemMetrics(
    int index)
{
    ConnectIfNecessary(0);

    /*
     * First check for values that aren't in the aiSysMet array.
     */
    switch (index) {
    case SM_REMOTESESSION:
        return ISREMOTESESSION();
    }

    /*
     * If it's in the BOOLEAN system metric range then do our magic.
     */
    if (index >= SM_STARTBOOLRANGE && index <= SM_ENDBOOLRANGE) {
        return SYSMETBOOL2(index);
    }

    if (index < 0 || index >= SM_CMETRICS) {
        return 0;
    }

    switch (index) {
    case SM_DBCSENABLED:
#ifdef FE_SB
        return TEST_SRVIF(SRVIF_DBCS);
#else
        return FALSE;
#endif
    case SM_IMMENABLED:
#ifdef FE_IME
        return TEST_SRVIF(SRVIF_IME);
#else
        return FALSE;
#endif

    case SM_MIDEASTENABLED:
        return TEST_SRVIF(SRVIF_MIDEAST);
    }

    if (!Is400Compat(GetClientInfo()->dwExpWinVer)) {
        /*
         * SCROLL BAR
         * before 4.0, the scroll bars and the border overlapped by a pixel.  Many apps
         * rely on this overlap when they compute dimensions.  Now, in 4.0, this pixel
         * overlap is no longer there.  So for old apps, we lie and pretend the overlap
         * is there by making the scroll bar widths one bigger.
         *
         * DLGFRAME
         * In Win3.1, SM_CXDLGFRAME & SM_CYDLGFRAME were border space MINUS 1
         * In Win4.0, they are border space
         *
         * CAPTION
         * In Win3.1, SM_CYCAPTION was the caption height PLUS 1
         * In Win4.0, SM_CYCAPTION is the caption height
         *
         * MENU
         * In Win3.1, SM_CYMENU was the menu height MINUS 1
         * In Win4.0, SM_CYMENU is the menu height
         */

        switch (index) {

        case SM_CXDLGFRAME:
        case SM_CYDLGFRAME:
        case SM_CYMENU:
        case SM_CYFULLSCREEN:
            return gpsi->aiSysMet[index] - 1;

        case SM_CYCAPTION:
        case SM_CXVSCROLL:
        case SM_CYHSCROLL:
            return gpsi->aiSysMet[index] + 1;
        }
    }

    return gpsi->aiSysMet[index];
}

/***************************************************************************\
* GetTopWindow (API)
*
* This poorly named API should really be called 'GetFirstChild', which is
* what it does.
*
* History:
* 11-12-90 darrinm      Ported.
* 02-19-91 JimA         Added enum access check
* 05-04-02 DarrinM      Removed enum access check and moved to USERRTL.DLL
\***************************************************************************/
FUNCLOG1(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, GetTopWindow, HWND, hwnd)
HWND GetTopWindow(
    HWND hwnd)
{
    PWND pwnd;

    /*
     * Allow a NULL hwnd to go through here.
     */
    if (hwnd == NULL) {
        pwnd = _GetDesktopWindow();
    } else {
        pwnd = ValidateHwnd(hwnd);
    }

    if (pwnd == NULL) {
        return NULL;
    }

    pwnd = REBASEPWND(pwnd, spwndChild);
    return HW(pwnd);
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsChild, HWND, hwndParent, HWND, hwnd)
BOOL IsChild(
    HWND hwndParent,
    HWND hwnd)
{
    PWND pwnd, pwndParent;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return FALSE;
    }

    pwndParent = ValidateHwnd(hwndParent);
    if (pwndParent == NULL) {
        return FALSE;
    }

    return _IsChild(pwndParent, pwnd);
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsIconic, HWND, hwnd)
BOOL IsIconic(
    HWND hwnd)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return FALSE;
    }

    return _IsIconic(pwnd);
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsWindowEnabled, HWND, hwnd)
BOOL IsWindowEnabled(
    HWND hwnd)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return FALSE;
    }

    return _IsWindowEnabled(pwnd);
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsWindowVisible, HWND, hwnd)
BOOL IsWindowVisible(
    HWND hwnd)
{
    PWND pwnd;
    BOOL bRet;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        bRet = FALSE;
    } else {
        try {
            bRet = _IsWindowVisible(pwnd);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            bRet = FALSE;
        }
    }

    return bRet;
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsZoomed, HWND, hwnd)
BOOL IsZoomed(
    HWND hwnd)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return FALSE;
    }

    return _IsZoomed(pwnd);
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ClientToScreen, HWND, hwnd, LPPOINT, ppoint)
BOOL ClientToScreen(
    HWND hwnd,
    LPPOINT ppoint)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return FALSE;
    }

    _ClientToScreen(pwnd, ppoint);
    return TRUE;
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetClientRect, HWND, hwnd, LPRECT, prect)
BOOL GetClientRect(
    HWND   hwnd,
    LPRECT prect)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return FALSE;
    }

    _GetClientRect(pwnd, prect);
    return TRUE;
}



FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetCursorPos, LPPOINT, lpPoint)
BOOL GetCursorPos(
    LPPOINT lpPoint)
{
    return  (BOOL)NtUserCallOneParam((ULONG_PTR)lpPoint, SFI_XXXGETCURSORPOS);
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetWindowRect, HWND, hwnd, LPRECT, prect)
BOOL GetWindowRect(
    HWND hwnd,
    LPRECT prect)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return FALSE;
    }

    _GetWindowRect(pwnd, prect);
    return TRUE;
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ScreenToClient, HWND, hwnd, LPPOINT, ppoint)
BOOL ScreenToClient(
    HWND hwnd,
    LPPOINT ppoint)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return FALSE;
    }

    _ScreenToClient(pwnd, ppoint);
    return TRUE;
}


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnableMenuItem, HMENU, hMenu, UINT, uIDEnableItem, UINT, uEnable)
BOOL EnableMenuItem(
    HMENU hMenu,
    UINT uIDEnableItem,
    UINT uEnable)
{
    PMENU pMenu;
    PITEM pItem;

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return (BOOL)-1;
    }

    /*
     * Get a pointer the the menu item.
     */
    if ((pItem = MNLookUpItem(pMenu, uIDEnableItem, (BOOL) (uEnable & MF_BYPOSITION), NULL)) == NULL) {
        return (DWORD)-1;
    }

    /*
     * If the item is already in the state we're
     * trying to set, just return.
     */
    if ((pItem->fState & MFS_GRAYED) == (uEnable & MFS_GRAYED)) {
        return pItem->fState & MFS_GRAYED;
    }

    return NtUserEnableMenuItem(hMenu, uIDEnableItem, uEnable);
}

/***************************************************************************\
* CallNextHookEx
*
* This routine is called to call the next hook in the hook chain.
*
* 05-09-91 ScottLu Created.
\***************************************************************************/
FUNCLOG4(LOG_GENERAL, LRESULT, WINAPI, CallNextHookEx, HHOOK, hhk, int, nCode, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI CallNextHookEx(
    HHOOK hhk,
    int nCode,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT nRet;
    BOOL bAnsi;
    DWORD dwHookCurrent;
    PCLIENTINFO pci;
    ULONG_PTR dwHookData;
    ULONG_PTR dwFlags;

    UNREFERENCED_PARAMETER(hhk);

    ConnectIfNecessary(0);

    pci = GetClientInfo();
    dwHookCurrent = pci->dwHookCurrent;
    bAnsi = LOWORD(dwHookCurrent);

    /*
     * If this is the last hook in the hook chain then return 0; we're done.
     */
    if (PhkNextValid((PHOOK)((KERNEL_ULONG_PTR)pci->phkCurrent - pci->ulClientDelta)) == NULL) {
        return 0;
    }

    switch ((INT)(SHORT)HIWORD(dwHookCurrent)) {
    case WH_CALLWNDPROC:
    case WH_CALLWNDPROCRET:
        /*
         * This is the hardest of the hooks because we need to thunk through
         * the message hooks in order to deal with synchronously sent messages
         * that point to structures - to get the structures passed across
         * alright, etc.
         *
         * This will call a special kernel-side routine that'll rebundle the
         * arguments and call the hook in the right format.
         *
         * Currently, the message thunk callbacks to the client-side don't take
         * enough parameters to pass wParam (which == fInterThread send msg).
         * To do this, save the state of wParam in the CLIENTINFO structure.
         */
        dwFlags = KERNEL_ULONG_PTR_TO_ULONG_PTR(pci->CI_flags) & CI_INTERTHREAD_HOOK;
        dwHookData = KERNEL_ULONG_PTR_TO_ULONG_PTR(pci->dwHookData);
        if (wParam) {
            pci->CI_flags |= CI_INTERTHREAD_HOOK;
        } else {
            pci->CI_flags &= ~CI_INTERTHREAD_HOOK;
        }

        if ((INT)(SHORT)HIWORD(dwHookCurrent) == WH_CALLWNDPROC) {
            nRet = CsSendMessage(
                    ((LPCWPSTRUCT)lParam)->hwnd,
                    ((LPCWPSTRUCT)lParam)->message,
                    ((LPCWPSTRUCT)lParam)->wParam,
                    ((LPCWPSTRUCT)lParam)->lParam,
                    0, FNID_HKINLPCWPEXSTRUCT, bAnsi);
        } else {
            pci->dwHookData = ((LPCWPRETSTRUCT)lParam)->lResult;
            nRet = CsSendMessage(
                    ((LPCWPRETSTRUCT)lParam)->hwnd,
                    ((LPCWPRETSTRUCT)lParam)->message,
                    ((LPCWPRETSTRUCT)lParam)->wParam,
                    ((LPCWPRETSTRUCT)lParam)->lParam,
                    0, FNID_HKINLPCWPRETEXSTRUCT, bAnsi);
        }

        /*
         * Restore previous hook state.
         */
        pci->CI_flags ^= ((pci->CI_flags ^ dwFlags) & CI_INTERTHREAD_HOOK);
        pci->dwHookData = dwHookData;
        break;

    default:
        nRet = NtUserCallNextHookEx(nCode, wParam, lParam, bAnsi);
    }

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\wsprintf.c ===
/****************************** Module Header ******************************\
* Module Name: wsprintf.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*  sprintf.c
*
*  Implements Windows friendly versions of sprintf and vsprintf
*
*  History:
*   2-15-89  craigc     Initial
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define out(c) if (cchLimit) {*lpOut++=(c); cchLimit--;} else goto errorout

/***************************************************************************\
* SP_PutNumber
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
\***************************************************************************/

int SP_PutNumber(
    LPSTR   lpstr,
    ULONG64 n,
    int     limit,
    DWORD   radix,
    int     uppercase)
{
    DWORD mod;
    int count = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (count < limit) {
        do  {
            mod =  (ULONG)(n % radix);
            n /= radix;

            mod += '0';
            if (mod > '9')
                mod += uppercase;
            *lpstr++ = (char)mod;
            count++;
        } while((count < limit) && n);
    }

    return count;
}

/***************************************************************************\
* SP_Reverse
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
\***************************************************************************/

void SP_Reverse(
    LPSTR lpFirst,
    LPSTR lpLast)
{
    char ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}

/***************************************************************************\
* SP_GetFmtValue
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

LPCSTR SP_GetFmtValue(
    LPCSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= '0' && *lpch <= '9') {
        ii *= 10;
        ii += (int)(*lpch - '0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* SP_GetFmtValueW
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
*  07-27-92  GregoryW   Created Unicode version (copied from SP_GetFmtValue)
\***************************************************************************/

LPCWSTR SP_GetFmtValueW(
    LPCWSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= L'0' && *lpch <= L'9') {
        ii *= 10;
        ii += (int)(*lpch - L'0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* wvsprintfA (API)
*
* Windows version of vsprintf().  Does not support floating point or
* pointer types, and all strings are assumed to be FAR.  Supports only
* the left alignment flag.
*
* Takes pointers to an output buffer, where the string is built, a
* pointer to an input buffer, and a pointer to a list of parameters.
*
* The cdecl function wsprintf() calls this function.
*
* History:
* 11-12-90 MikeHar      Ported from windows 3
* 12-11-90 GregoryW     after %d format is parsed lpParms needs to be aligned
*                       to a dword boundary.
* 09-Aug-1991 mikeke    no it doesn't
* 11-19-91 DarrinM      Now wvsprintf and wsprintf treat parameters the same
*                       (as if they originated from a DWORD-aligned stack).
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, wvsprintfA, LPSTR, lpOut, LPCSTR, lpFmt, va_list, arglist)
int wvsprintfA(
    LPSTR lpOut,
    LPCSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem;
    char prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = WSPRINTF_LIMIT, cch;
    LPSTR lpT, lpTMB;
    LPWSTR pwsz;
    va_list varglist = arglist;
    union {
        LONG64 l;
        ULONG64 ul;
        char sz[2];
        WCHAR wsz[2];
    } val;

    while (*lpFmt != 0) {
        if (*lpFmt == '%') {
            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == '-')
                    left++;
                else if (*lpFmt == '#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == '0') {
                fillch = '0';
                lpFmt++;
            } else
                fillch = ' ';

            /*
             * read the width specification
             */
            lpFmt = SP_GetFmtValue((LPCSTR)lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == '.') {
                lpFmt = SP_GetFmtValue((LPCSTR)++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * 64bit number: size == 3
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if (*lpFmt == 'w') {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == 'l') {
                size = 1;
                lpFmt++;
            } else if (*lpFmt == 't') {
                size = 0;
                lpFmt++;
            } else if (*lpFmt == 'I') {
                if (*(lpFmt+1) == '3' && *(lpFmt+2) == '2') {
                    size = 1;
                    lpFmt += 3;
                } else if (*(lpFmt+1) == '6' && *(lpFmt+2) == '4') {
                    size = 3;
                    lpFmt += 3;
                } else {
                    size = (sizeof(INT_PTR) == sizeof(LONG)) ? 1 : 3;
                    lpFmt++;
                }
            } else {
                size = 0;
                if (*lpFmt == 'h') {
                    lpFmt++;
                    hprefix = 1;
                } else if ((*lpFmt == 'i') || (*lpFmt == 'd')) {
                    // %i or %d specified (no modifiers) - use long
                    // %u seems to have always been short - leave alone
                    size = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case 'i':
            case 'd':
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case 'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = ' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 * if size == 3, "%p" was specified
                 */
                if (size == 3) {
                    val.l = va_arg(varglist, LONG64);
                } else if (size) {
                    val.l = va_arg(varglist, long);
                } else if (sign) {
                    val.l = (long)va_arg(varglist, short);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                /*
                 * Unless printing a full 64-bit value, ensure values
                 * here are not in canonical longword format to prevent
                 * the sign extended upper 32-bits from being printed.
                 */
                if (size != 3) {
                    val.l &= MAXULONG;
                }

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 */
                cch = SP_PutNumber(lpOut, val.l, cchLimit, radix, upper);
                if (!(cchLimit -= cch))
                    goto errorout;

                lpOut += cch;
                width -= cch;
                prec -= cch;
                if (prec > 0)
                    width -= prec;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out('0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != '0') {
                        if (sign) {
                            sign = 0;
                            out('-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out('0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out('-');

                    if (prefix) {
                        out(prefix);
                        out('0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    SP_Reverse(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out('-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out('0');
                    }

                    /*
                     * reverse the string in place
                     */
                    SP_Reverse(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case 'p':
                size = (sizeof(PVOID) == sizeof(LONG)) ? 1 : 3;
                if (prec == -1) {
                    prec = 2 * sizeof(PVOID);
                }

                /*** FALL THROUGH to case 'X' ***/

            case 'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case 'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = 'X';
                    else
                        prefix = 'x';
                goto donumeric;

            case 'C':
                /*
                 * explicit size specifier overrides case
                 */
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'c' ***/

            case 'c':
                /*
                 * if size == 0, "%c" or "%hc" or "%tc" was specified (CHAR)
                 * if size == 1, "%C" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0x0000;
                    pwsz = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    lpT = val.sz;
                    goto putstring;
                }

            case 'S':
                /*
                 * explicit size specifier overrides case
                 */
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 's' ***/

            case 's':
                /*
                 * if size == 0, "%s" or "%hs" or "%ts" was specified (LPSTR);
                 * if size == 1, "%S" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" was specified (LPWSTR)
                 */
                if (size) {
                    pwsz = va_arg(varglist, LPWSTR);
                    if (pwsz == NULL) {
                        cch = 0;
                    } else {
                        cch = wcslen(pwsz);
                    }
putwstring:
                    cch = WCSToMB(pwsz, cch, &lpTMB, -1, TRUE);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTMB;
                } else {
                    lpT = va_arg(varglist, LPSTR);
                    if (lpT == NULL) {
                        cch = 0;
                    } else {
                        cch = strlen(lpT);
                    }
putstring:
                    fAllocateMem = FALSE;
                }

                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (fAllocateMem) {
                    if (cch + (width < 0 ? 0 : width) >= cchLimit) {
                        UserLocalFree(lpTMB);
                        goto errorout;
                    }
                }

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     UserLocalFree(lpTMB);
                }
                break;

            default:
normalch:
                out(*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    return WSPRINTF_LIMIT - cchLimit;
}

/***************************************************************************\
* StringPrintfA (API)
*
* Windows version of sprintf
*
* History:
* 11-12-90 MikeHar      Ported from windows 3
* 02-05-90 DarrinM      Cleaned up with STDARG.h vararg stuff.
\***************************************************************************/

int WINAPIV wsprintfA(
    LPSTR lpOut,
    LPCSTR lpFmt,
    ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvsprintfA(lpOut, lpFmt, arglist);
    va_end(arglist);
    return ret;
}

/***************************************************************************\
* SP_PutNumberW
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

int SP_PutNumberW(
    LPWSTR  lpstr,
    ULONG64 n,
    int     limit,
    DWORD   radix,
    int     uppercase)
{
    DWORD mod;
    int count = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (count < limit) {
        do  {
            mod =  (ULONG)(n % radix);
            n /= radix;

            mod += '0';
            if (mod > '9')
            mod += uppercase;
            *lpstr++ = (WCHAR)mod;
            count++;
        } while((count < limit) && n);
    }

    return count;
}

/***************************************************************************\
* SP_ReverseW
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

void SP_ReverseW(
    LPWSTR lpFirst,
    LPWSTR lpLast)
{
    WCHAR ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}


/***************************************************************************\
* wvsprintfW (API)
*
* wsprintfW() calls this function.
*
* History:
*    11-Feb-1992 GregoryW copied xwvsprintf
*         Temporary hack until we have C runtime support
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, wvsprintfW, LPWSTR, lpOut, LPCWSTR, lpFmt, va_list, arglist)
int wvsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem;
    WCHAR prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = WSPRINTF_LIMIT, cch;
    LPWSTR lpT, lpTWC;
    LPBYTE psz;
    va_list varglist = arglist;
    union {
        LONG64 l;
        ULONG64 ul;
        char sz[2];
        WCHAR wsz[2];
    } val;

    while (*lpFmt != 0) {
        if (*lpFmt == L'%') {

            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == L'-')
                    left++;
                else if (*lpFmt == L'#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == L'0') {
                fillch = L'0';
                lpFmt++;
            } else
                fillch = L' ';

            /*
             * read the width specification
             */
            lpFmt = SP_GetFmtValueW(lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == L'.') {
                lpFmt = SP_GetFmtValueW(++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * 64bit number: size == 3
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if ((*lpFmt == L'w') || (*lpFmt == L't')) {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == L'l') {
                size = 1;
                lpFmt++;
            } else if (*lpFmt == L'I') {
                if (*(lpFmt+1) == L'3' && *(lpFmt+2) == L'2') {
                    size = 1;
                    lpFmt += 3;
                } else if (*(lpFmt+1) == L'6' && *(lpFmt+2) == L'4') {
                    size = 3;
                    lpFmt += 3;
                } else {
                    size = (sizeof(INT_PTR) == sizeof(LONG)) ? 1 : 3;
                    lpFmt++;
                }
            } else {
                size = 0;
                if (*lpFmt == L'h') {
                    lpFmt++;
                    hprefix = 1;
                } else if ((*lpFmt == L'i') || (*lpFmt == L'd')) {
                    // %i or %d specified (no modifiers) - use long
                    // %u seems to have always been short - leave alone
                    size = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case L'i':
            case L'd':
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case L'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = L' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 * if size == 3, "%p" was specified
                 */
                if (size == 3) {
                    val.l = va_arg(varglist, LONG64);
                } else if (size) {
                    val.l = va_arg(varglist, LONG);
                } else if (sign) {
                    val.l = va_arg(varglist, SHORT);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                /*
                 * Unless printing a full 64-bit value, ensure values
                 * here are not in canonical longword format to prevent
                 * the sign extended upper 32-bits from being printed.
                 */
                if (size != 3) {
                    val.l &= MAXULONG;
                }

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 */
                cch = SP_PutNumberW(lpOut, val.l, cchLimit, radix, upper);
                if (!(cchLimit -= cch))
                    goto errorout;

                lpOut += cch;
                width -= cch;
                prec -= cch;
                if (prec > 0)
                    width -= prec;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out(L'0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != L'0') {
                        if (sign) {
                            sign = 0;
                            out(L'-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out(L'0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out(L'-');

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out(L'-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case L'p':
                size = (sizeof(PVOID) == sizeof(LONG)) ? 1 : 3;
                if (prec == -1) {
                    prec = 2 * sizeof(PVOID);
                }

                /*** FALL THROUGH to case 'X' ***/

            case L'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case L'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = L'X';
                    else
                        prefix = L'x';
                goto donumeric;

            case L'c':
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'C' ***/

            case L'C':
                /*
                 * if size == 0, "%C" or "%hc" was specified (CHAR);
                 * if size == 1, "%c" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" or "%tc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0;
                    lpT = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    psz = val.sz;
                    goto putstring;
                }

            case L's':
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 'S' ***/

            case L'S':
                /*
                 * if size == 0, "%S" or "%hs" was specified (LPSTR)
                 * if size == 1, "%s" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" or "%ts" was specified (LPWSTR)
                 */
                if (size) {
                    lpT = va_arg(varglist, LPWSTR);
                    if (lpT == NULL) {
                        cch = 0;
                    } else {
                        cch = wcslen(lpT);
                    }
putwstring:
                    fAllocateMem = FALSE;
                } else {
                    psz = va_arg(varglist, LPBYTE);
                    if (psz == NULL) {
                        cch = 0;
                    } else {
                        cch = strlen(psz);
                    }
putstring:
                    cch = MBToWCS(psz, cch, &lpTWC, -1, TRUE);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTWC;
                }

                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (fAllocateMem) {
                    if (cch + (width < 0 ? 0 : width) >= cchLimit) {
                        UserLocalFree(lpTWC);
                        goto errorout;
                    }
                }

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     UserLocalFree(lpTWC);
                }

                break;

            default:
normalch:
                out((WCHAR)*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    return WSPRINTF_LIMIT - cchLimit;
}

int WINAPIV wsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvsprintfW(lpOut, lpFmt, arglist);
    va_end(arglist);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\wstrings.c ===
/****************************** Module Header ******************************\
* Module Name: wstrings.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 03-20-91 IanJa      Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/* LATER these should be in a public header file!!!
 * Assorted defines used to support the standard Windows ANSI code page
 * (now known as code page 1252 and officially registered by IBM).
 * This is intended only for the PDK release.  Subsequent releases will
 * use the NLSAPI and Unicode.
 */
#define LATIN_CAPITAL_LETTER_A_GRAVE    (WCHAR)0xc0
#define LATIN_CAPITAL_LETTER_THORN      (WCHAR)0xde
#define LATIN_SMALL_LETTER_SHARP_S      (WCHAR)0xdf
#define LATIN_SMALL_LETTER_Y_DIAERESIS  (WCHAR)0xff
#define DIVISION_SIGN                   (WCHAR)0xf7
#define MULTIPLICATION_SIGN             (WCHAR)0xd7


/*
 * Temporary defines to support Unicode block 1 (0x0000 - 0x00ff).
 */
#define WCTOA(wch)  ((wch) & 0xff)
#define IS_UNICODE_BLK1(wch)  ((int)(wch) <= 0x00ff)


/***************************************************************************\
* CharLowerW (API)
*
* Convert either a single character or an entire string to lower case.  The
* two cases are differentiated by checking the high-word of pwsz.  If it is
* 0 then we just convert the low-word of pwsz.
*
* History:
* 06-24-91 GregoryW     Created.  Supports Unicode equivalent of code
*                       page 1252 (simple zero extension).  This is for
*                       the PDK release only.  After the PDK this routine
*                       will be modified to use the NLSAPI.
* 02-11-93 IanJa        Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, LPWSTR, WINAPI, CharLowerW, LPWSTR, pwsz)
LPWSTR WINAPI CharLowerW(
    LPWSTR pwsz)
{
    /*
     * Early out for NULL string or '\0'
     */
    if (pwsz == NULL) {
        return pwsz;
    }

    if (!IS_PTR(pwsz)) {
        if (!LCMapStringW(
                 LOCALE_USER_DEFAULT,
                 LCMAP_LOWERCASE,
                 (LPWSTR)&pwsz,
                 1,
                 (LPWSTR)&pwsz,
                 1
                 )) {
            /*
             * We don't expect LCMapString to fail!  The caller is not expecting
             * failure, CharLowerW does not have a failure indicator, so we do
             * nothing.
             */
            RIPMSG1(RIP_WARNING, "CharLowerW(%#p): LCMapString failed\n", pwsz);
        }

        return pwsz;
    }

    /*
     * pwsz is a null-terminated string
     */
    CharLowerBuffW(pwsz, wcslen(pwsz)+1);
    return pwsz;
}


/***************************************************************************\
* CharUpperW (API)
*
* Convert either a single character or an entire string to upper case.  The
* two cases are differentiated by checking the high-word of pwsz.  If it is
* 0 then we just convert the low-word of pwsz.
*
* History:
* 06-24-91 GregoryW     Created.  Supports Unicode equivalent of code
*                       page 1252 (simple zero extension).  This is for
*                       the PDK release only.  After the PDK this routine
*                       will be modified to use the NLSAPI.
* 02-11-93 IanJa        Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, LPWSTR, WINAPI, CharUpperW, LPWSTR, pwsz)
LPWSTR WINAPI CharUpperW(
    LPWSTR pwsz)
{
    /*
     * Early out for NULL string or '\0'
     */
    if (pwsz == NULL) {
        return pwsz;
    }

    if (!IS_PTR(pwsz)) {
        if (!LCMapStringW(
                 LOCALE_USER_DEFAULT,
                 LCMAP_UPPERCASE,
                 (LPWSTR)&pwsz,
                 1,
                 (LPWSTR)&pwsz,
                 1
                 )) {
            /*
             * We don't expect LCMapString to fail!  The caller is not expecting
             * failure, CharLowerW does not have a failure indicator, so we do
             * nothing.
             */
            RIPMSG1(RIP_WARNING, "CharUpperW(%#p): LCMapString failed", pwsz);
        }

        return pwsz;
    }

    /*
     * pwsz is a null-terminated string
     */
    CharUpperBuffW(pwsz, wcslen(pwsz)+1);
    return pwsz;
}


/***************************************************************************\
* CharNextW (API)
*
* Move to next character in string unless already at '\0' terminator
*
* History:
* 06-24-91 GregoryW     Created.  This routine will not work for non-spacing
*                       characters!!  This version is only intended for
*                       limited use in the PDK release.
* 02-20-92 GregoryW     Modified to work with combining marks (formerly known
*                       as non-spacing).
* 09-21-93 JulieB       Added ALPHA to combining mark code.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, LPWSTR, WINAPI, CharNextW, LPCWSTR, lpwCurrentChar)
LPWSTR WINAPI CharNextW(
    LPCWSTR lpwCurrentChar)
{
    WORD ctype3info;

    if (*lpwCurrentChar) {
        //
        // Examine each code element.  Skip all combining elements.
        //
        while (*(++lpwCurrentChar)) {
            if (!GetStringTypeW(
                    CT_CTYPE3,
                    lpwCurrentChar,
                    1,
                    &ctype3info)) {
                /*
                 * GetStringTypeW failed!  The caller is not expecting failure,
                 * CharNextW does not have a failure indicator, so just return
                 * a pointer to the character we couldn't analyze.
                 */
                RIPMSG2(RIP_WARNING, "CharNextW failed, L'\\x%.4x' at %#p",
                        *lpwCurrentChar, lpwCurrentChar);
                break;
            }
            if (!((ctype3info & C3_NONSPACING) && (!(ctype3info & C3_ALPHA)))) {
                break;
            }
        }
    }

    return (LPWSTR)lpwCurrentChar;
}


/***************************************************************************\
* CharPrevW (API)
*
* Move to previous character in string, unless already at start
*
* History:
* 06-24-91 GregoryW     Created.  This routine will not work for non-spacing
*                       characters!!  This version is only intended for
*                       limited use in the PDK release.
* 02-20-92 GregoryW     Modified to work with combining marks (formerly
*                       known as non-spacing).
* 09-21-93 JulieB       Added ALPHA to combining mark code.
* 12-06-93 JulieB       Fixed combining mark code.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, LPWSTR, WINAPI, CharPrevW, LPCWSTR, lpwStart, LPCWSTR, lpwCurrentChar)
LPWSTR WINAPI CharPrevW(
    LPCWSTR lpwStart,
    LPCWSTR lpwCurrentChar)
{
    WORD ctype3info;
    LPWSTR lpwValidChar = (LPWSTR)lpwCurrentChar;


    if (lpwCurrentChar > lpwStart) {
        //
        // Examine each code element.  Skip all combining elements.
        //
        while (lpwCurrentChar-- > lpwStart) {
            if (!GetStringTypeW(
                    CT_CTYPE3,
                    lpwCurrentChar,
                    1,
                    &ctype3info)) {
                /*
                 * GetStringTypeW failed!  The caller is not expecting failure,
                 * CharPrevW does not have a failure indicator, so just return
                 * a pointer to the character we couldn't analyze.
                 */
                RIPMSG2(RIP_WARNING, "CharPrevW failed, L'\\x%.4x' at %#p",
                        *lpwCurrentChar, lpwCurrentChar);
                break;
            }
            if (!((ctype3info & C3_NONSPACING) && (!(ctype3info & C3_ALPHA)))) {
                lpwValidChar = (LPWSTR)lpwCurrentChar;
                break;  // found non-combining code element
            }
        }

        /*
         * We need to always go back one character. If we've looped through
         * the entire buffer and haven't found a "legitimate" character, just
         * step back. See bug #27649.
         */
        if(lpwCurrentChar < lpwStart){
            --lpwValidChar;
            UserAssert(lpwValidChar >= lpwStart);
        }
    }

    return (LPWSTR)lpwValidChar;
}


/***************************************************************************\
* CharLowerBuffW (API)
*
* History:
* 06-24-91 GregoryW     Created.  This version only supports Unicode
*                       block 1 (0x0000 - 0x00ff).  All other code points
*                       are copied verbatim.  This version is intended
*                       only for the PDK release.
* 02-11-93 IanJa        Modified to use NLS API.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, DWORD, WINAPI, CharLowerBuffW, LPWSTR, pwsz, DWORD, cwch)
DWORD WINAPI CharLowerBuffW(
    LPWSTR pwsz,
    DWORD cwch)
{
    int cwchT;
    DWORD i;

    if (cwch == 0) {
        return 0;
    }

    cwchT = LCMapStringW(LOCALE_USER_DEFAULT, LCMAP_LOWERCASE,
                pwsz, cwch, pwsz, cwch);

    if (cwchT != 0) {
        return cwchT;
    }

    /*
     * LCMapString failed!  The caller is not expecting failure,
     * CharLowerBuffW does not have a failure indicator, so we
     * convert the buffer to lower case as best we can.
     */
    RIPMSG1(RIP_WARNING, "CharLowerBuffW(%ls) failed", pwsz);

    for (i=0; i < cwch; i++) {
        if (IS_UNICODE_BLK1(pwsz[i]) && IsCharUpperA((char)pwsz[i])) {
            pwsz[i] += 'a'-'A';
        }
    }

    return cwch;
}


/***************************************************************************\
* CharUpperBuffW (API)
*
* History:
* 06-24-91 GregoryW     Created.  This version only supports Unicode
*                       block 1 (0x0000 - 0x00ff).  All other code points
*                       are copied verbatim.  This version is intended
*                       only for the PDK release.
* 02-11-93 IanJa        Modified to use NLS API.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, DWORD, WINAPI, CharUpperBuffW, LPWSTR, pwsz, DWORD, cwch)
DWORD WINAPI CharUpperBuffW(
    LPWSTR pwsz,
    DWORD cwch)
{
    int cwchT;
    DWORD i;

    if (cwch == 0) {
        return 0;
    }

    cwchT = LCMapStringW(LOCALE_USER_DEFAULT, LCMAP_UPPERCASE,
                pwsz, cwch, pwsz, cwch);

    if (cwchT != 0) {
        return cwchT;
    }

    /*
     * LCMapString failed!  The caller is not expecting failure,
     * CharUpperBuffW does not have a failure indicator, so we
     * convert the buffer to upper case as best we can.
     */
    RIPMSG1(RIP_WARNING, "CharUpperBuffW(%ls) failed", pwsz);

    for (i=0; i < cwch; i++) {
        if (IS_UNICODE_BLK1(pwsz[i]) &&
                IsCharLowerA((char)pwsz[i]) &&
                (pwsz[i] != LATIN_SMALL_LETTER_SHARP_S) &&
                (pwsz[i] != LATIN_SMALL_LETTER_Y_DIAERESIS)) {
            pwsz[i] += (WCHAR)('A'-'a');
        }
    }

    return cwch;
}



/***************************************************************************\
* IsCharLowerW (API)
*
* History:
* 06-24-91 GregoryW     Created.  This version only supports Unicode
*                       block 1 (0x0000 - 0x00ff).  FALSE is returned
*                       for all other code points. This version is intended
*                       only for the PDK release.
* 02-20-92 GregoryW     Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharLowerW, WCHAR, wChar)
BOOL WINAPI IsCharLowerW(
    WCHAR wChar)
{
    WORD ctype1info;

    if (GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info)) {
        if (ctype1info & C1_LOWER) {
            return TRUE;
        } else {
            return FALSE;
        }
    }

    /*
     * GetStringTypeW failed!  The caller is not expecting
     * failure, IsCharLowerW does not have a failure indicator, so we
     * determine the case as best we can.
     */
    RIPMSG1(RIP_WARNING, "IsCharLowerW(L'\\x%.4lx') failed", wChar);

    if (IS_UNICODE_BLK1(wChar)) {
        return IsCharLowerA((CHAR)wChar);
    } else {
        return FALSE;
    }
}


/***************************************************************************\
* IsCharUpperW (API)
*
* History:
* 06-24-91 GregoryW     Created.  This version only supports Unicode
*                       block 1 (0x0000 - 0x00ff).  FALSE is returned
*                       for all other code points. This version is intended
*                       only for the PDK release.
* 02-20-92 GregoryW     Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharUpperW, WCHAR, wChar)
BOOL WINAPI IsCharUpperW(
    WCHAR wChar)
{
    WORD ctype1info;

    if (GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info)) {
        if (ctype1info & C1_UPPER) {
            return TRUE;
        } else {
            return FALSE;
        }
    }

    /*
     * GetStringTypeW failed!  The caller is not expecting
     * failure, IsCharLowerW does not have a failure indicator, so we
     * determine the case as best we can.
     */
    RIPMSG1(RIP_WARNING, "IsCharUpper(L'\\x%.4lx') failed", wChar);

    if (IS_UNICODE_BLK1(wChar)) {
        return IsCharUpperA((CHAR)wChar);
    } else {
        return FALSE;
    }
}


/***************************************************************************\
* IsCharAlphaNumericW (API)
*
* Returns TRUE if character is alphabetical or numerical, otherwise FALSE
*
* History:
* 06-24-91 GregoryW     Created.  This version only supports Unicode
*                       block 1 (0x0000 - 0x00ff).
*                       This version is intended only for the PDK release.
* 02-20-92 GregoryW     Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharAlphaNumericW, WCHAR, wChar)
BOOL WINAPI IsCharAlphaNumericW(
    WCHAR wChar)
{
    WORD ctype1info;

    if (!GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info)) {
        //
        // GetStringTypeW returned an error!  IsCharAlphaNumericW has no
        // provision for returning an error...  The best we can do is to
        // return FALSE
        //
        UserAssert(FALSE);
        return FALSE;
    }
    //
    // LATER 20 Feb 92 GregoryW
    //    We may need to check ctype 3 info if we want to check for
    //    digits other than ASCII '0'-'9' (such as Lao digits or
    //    Tibetan digits, etc.).
    //
#ifdef FE_SB // IsCharAlphaNumericW()
    if (ctype1info & C1_ALPHA) {
        WORD ctype3info = 0;
        /*
         * We don't want to return TRUE for halfwidth katakana.
         * Katakana is linguistic character (C1_ALPHA), but it is not
         * alphabet character.
         */
        if (!GetStringTypeW(CT_CTYPE3, &wChar, 1, &ctype3info)) {
            UserAssert(FALSE);
            /*
             * Assume, it is alphabet character, because it has
             * C1_ALPHA attribute.
             */
            return TRUE;
        }

        if (ctype3info & (C3_KATAKANA|C3_HIRAGANA)) {
            /*
             * This is 'Katakana'.
             */
            return FALSE;
        } else {
            return TRUE;
        }
    } else if (ctype1info & C1_DIGIT) {
        return TRUE;
    } else {
        return FALSE;
    }
#else
    if ((ctype1info & C1_ALPHA) || (ctype1info & C1_DIGIT)) {
        return TRUE;
    } else {
        return FALSE;
    }
#endif // FE_SB
}


/***************************************************************************\
* IsCharAlphaW (API)
*
* Returns TRUE if character is alphabetical, otherwise FALSE
*
* History:
* 06-24-91 GregoryW     Created.  This version only supports Unicode
*                       block 1 (0x0000 - 0x00ff).
*                       This version is intended only for the PDK release.
* 02-20-92 GregoryW     Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharAlphaW, WCHAR, wChar)
BOOL WINAPI IsCharAlphaW(
    WCHAR wChar)
{
    WORD ctype1info;

    if (!GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info)) {
        //
        // GetStringTypeW returned an error!  IsCharAlphaW has no
        // provision for returning an error...  The best we can do
        // is to return FALSE
        //
        UserAssert(FALSE);
        return FALSE;
    }
    if (ctype1info & C1_ALPHA) {
#ifdef FE_SB // IsCharAlphaA()
        WORD ctype3info = 0;
        /*
         * We don't want to return TRUE for halfwidth katakana.
         * Katakana is linguistic character (C1_ALPHA), but it is not
         * alphabet character.
         */
        if (!GetStringTypeW(CT_CTYPE3, &wChar, 1, &ctype3info)) {
            UserAssert(FALSE);
            /*
             * Assume, it is alphabet character, because it has
             * C1_ALPHA attribute.
             */
            return TRUE;
        }

        if (ctype3info & (C3_KATAKANA|C3_HIRAGANA)) {
            /*
             * This is 'Katakana'.
             */
            return FALSE;
        } else {
            return TRUE;
        }
#else
        return TRUE;
#endif // FE_SB
    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\i386\callret.asm ===
title  "User Callback Return"
;++
;
; Copyright (c) 1985 - 1999, Microsoft Corporation
;
; Module Name:
;
;    callret.asm
;
; Abstract:
;
;    This module implements the fastpath callback return.
;
; Author:
;
;    David N. Cutler (davec) 21-Dec-95
;
; Environment:
;
;    User mode.
;
; Revision History:
;
;--

.386p
        .xlist
include callconv.inc            ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Return from User Mode Callback"

ifndef BUILD_WOW6432
;++
;
; NTSTATUS
; FASTCALL
; XyCallbackReturn (
;    IN PVOID OutputBuffer OPTIONAL,
;    IN ULONG OutputLength,
;    IN NTSTATUS Status
;    )
;
; Routine Description:
;
;    This function returns from a user mode callout to the kernel mode
;    caller of the user mode callback function.
;
; Arguments:
;
;    OutputBuffer (ecx) - Supplies an optional pointer to an output buffer.
;
;    OutputLength (edx) - Supplies the length of the output buffer.
;
;    Status (esp + 4) - Supplies the status value returned to the caller of the
;        callback function.
;
; Return Value:
;
;    Normally there is no return from this function. If a callbac is not active,
;    then the error status is returned to the caller.
;
;--

cPublicFastCall XyCallbackReturn, 3

        mov     eax,[esp] + 4           ; get return status value
        int     02bH                    ; call fast path system service
        fstRET  XyCallbackReturn        ; return status to caller

fstENDP XyCallbackReturn
endif

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\clwinnls.c ===
/****************************** Module Header ******************************\
* Module Name: clwinnls.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the code for the NT 3.x IMM API functions.
*
* History:
* 11-Jan-1995 wkwok      Created.
* 07-May-1996 takaok     Cleaned up.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL CheckCountry();
BOOL ImmEnableIME( HWND hwnd, BOOL fEnable );
BOOL IMPGetIMEWorker( HKL hkl, LPIMEPROW lpImeProW );
VOID ConvertImeProWtoA( LPIMEPROA lpImeProA, LPIMEPROW lpImeProW );
LRESULT SendIMEMessageAll( HWND hwndApp, HANDLE lParam, BOOL fAnsi );

BOOL ImmWINNLSEnableIME(
    HWND  hwndApp,
    BOOL  bFlag)
{
    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }
    return ImmEnableIME( hwndApp, bFlag );
}

//
// returns the "enable/disable" state of the
// caller thread's default input context.
//
BOOL ImmWINNLSGetEnableStatus(
    HWND hwndApp)
{
    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }

    return (ImmGetSaveContext(hwndApp, IGSC_WINNLSCHECK) != NULL_HIMC);
}


UINT WINAPI ImmWINNLSGetIMEHotkey(
    HWND hwndIme)
{
    UNREFERENCED_PARAMETER(hwndIme);

    //
    // Win95/NT3.51 behavior, i.e. always return 0.
    //
    return 0;
}


/***************************************************************************\
*
*         IME APIs
*
\***************************************************************************/

LRESULT WINAPI ImmSendIMEMessageExW(
    HWND   hwndApp,
    LPARAM lParam)
{
    return SendIMEMessageAll( hwndApp, (HANDLE)lParam, FALSE );
}

LRESULT WINAPI ImmSendIMEMessageExA(
    HWND   hwndApp,
    LPARAM lParam)
{
    return SendIMEMessageAll( hwndApp, (HANDLE)lParam, TRUE );
}

LRESULT SendIMEMessageAll(
    HWND hwndApp,
    HANDLE hMemImeStruct,
    BOOL fAnsi )
{
    HWND hWnd;
    LPIMESTRUCT lpIme;
    LRESULT lResult;

#ifdef LATER
  // Need for MSTEST30a(32bit)...
  // If different process of hWnd in SendIMEMessageEx, then we should be inter-send messag
on this.
    if (PtiCurrent() != pti) {
        HWND hDefIMEWnd = ImmGetDefaultIMEWnd(hWnd);
        if (hDefIMEWnd)
            return SendMessage(hDefIMEWnd,WM_CONVERTREQUESTEX,(WPARAM)hWnd,lParam);
    }
#endif

    //
    // the passed handle must be the handle of
    // global memory block.
    //
    lpIme = (LPIMESTRUCT)GlobalLock( hMemImeStruct );
    if ( lpIme == NULL ) {
        return (FALSE);
    }

    if ( ! CheckCountry( ) ) {

        lpIme->wParam = IME_RS_INVALID;
        GlobalUnlock( hMemImeStruct );
        return (FALSE);
    }

    //
    // We don't need to handle if it's non-IME layout
    //
    if ( ! ImmIsIME( GetKeyboardLayout(0) ) ) {

        lpIme->wParam = IME_RS_INVALID;
        GlobalUnlock( hMemImeStruct );
        return (FALSE);
    }

    //
    // check if the initialize of IMM has been done.
    //
    if ( !IsWindow(ImmGetDefaultIMEWnd(hwndApp)) ) {
        //
        // for Win3.1/Win95 compatibility
        // we need to return TRUE here.
        //
        // PPT4 calls SendImeMessage at the very
        // early stage of initialization. If we
        // return FALSE here, it thinks IME is
        // not available.
        //
        if ( lpIme->fnc == 0x07 )  // IME_GETVERSION
            //
            // Excel5.0J calls this function at the early stage
            // and we need to return version number.
            //
            lResult = IMEVER_31;
        else
            lResult = TRUE;

        GlobalUnlock( hMemImeStruct );
        return lResult;
    }

    //
    // caller may give us NULL window handle...
    //
    if ( !IsWindow(hwndApp) ) {
        hWnd = GetFocus();
    } else {
        hWnd = hwndApp;
    }

    lResult = TranslateIMESubFunctions( hWnd, lpIme, fAnsi );
    GlobalUnlock( hMemImeStruct );

    return lResult;
}


/***************************************************************************\
*
*        IMP APIs
*
\***************************************************************************/


BOOL WINAPI ImmIMPGetIMEW(
    HWND hwndApp,
    LPIMEPROW lpImeProW)
{
    UNREFERENCED_PARAMETER(hwndApp);

    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }
    return IMPGetIMEWorker( GetKeyboardLayout(0), lpImeProW );

}

BOOL WINAPI ImmIMPGetIMEA(
    HWND hwndApp,
    LPIMEPROA lpImeProA)
{
    IMEPROW ImeProW;

    UNREFERENCED_PARAMETER(hwndApp);

    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }
    if ( IMPGetIMEWorker( GetKeyboardLayout(0), &ImeProW ) ) {
        ConvertImeProWtoA( lpImeProA, &ImeProW );
        return TRUE;
    }
    return FALSE;
}

VOID ConvertImeProWtoA( LPIMEPROA lpImeProA, LPIMEPROW lpImeProW )
{
    lpImeProA->hWnd = lpImeProW->hWnd;
    lpImeProA->InstDate = lpImeProW->InstDate;
    lpImeProA->wVersion = lpImeProW->wVersion;

    WideCharToMultiByte( CP_ACP, 0,
                         lpImeProW->szDescription, -1,
                         lpImeProA->szDescription, sizeof(lpImeProA->szDescription),
                         NULL, NULL );

    WideCharToMultiByte( CP_ACP, 0,
                         lpImeProW->szName, -1,
                         lpImeProA->szName, sizeof(lpImeProA->szName),
                         NULL, NULL );

    lpImeProA->szOptions[0] = '\0';
}

DATETIME   CleanDate = {0};

BOOL IMPGetIMEWorker( HKL hkl, LPIMEPROW lpImeProW )
{
    IMEINFOEX iiex;

    if ( ImmGetImeInfoEx( &iiex, ImeInfoExKeyboardLayout, (PVOID)&hkl) ) {

        lpImeProW->hWnd = NULL;
        lpImeProW->InstDate = CleanDate;
        lpImeProW->wVersion = iiex.dwImeWinVersion;
        lstrcpynW( lpImeProW->szDescription, iiex.wszImeDescription, 50 );
        lstrcpynW( lpImeProW->szName, iiex.wszImeFile, 80 );
        lstrcpynW( lpImeProW->szOptions, TEXT(""), 1 );

        return TRUE;
    }

    return FALSE;
}


BOOL WINAPI ImmIMPQueryIMEW(
    LPIMEPROW lpImeProW)
{
    BOOL fResult = FALSE;
    INT numLayouts = 0;
    HKL *phklRoot = NULL;
    HKL *phkl = NULL;

    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }

    //
    // get the number of keyboard layouts available
    //
    numLayouts = GetKeyboardLayoutList( 0, NULL );
    if ( numLayouts > 0 ) {
        //
        // allocate the buffer for the array of layouts.
        // +1 for a NULL sentinel
        //
        phklRoot = ImmLocalAlloc( 0, (numLayouts+1) * sizeof(HKL) );
        if ( phklRoot != NULL ) {
            //
            // get the keyboard layouts
            //
            if ( GetKeyboardLayoutList( numLayouts, phklRoot ) == numLayouts ) {
                //
                // put a NULL sentinel at the end of the buffer
                //
                *(phklRoot+numLayouts) = (HKL)NULL;

                if ( lpImeProW->szName[0] == L'\0' ) {
                //
                // This is the first call of IMPQueryIME
                // We will start at the first layout.
                //
                    phkl = phklRoot;

                } else {
                //
                // The caller specifies the name of IME.
                // We will start at the next layout.
                // Note this assumes that the order of keyboard  layouts
                // returned by GetKeyboardLayoutList() is not changed
                // between calls. ( Though actually there is no such
                // guarantee, we ignore the chance of the changing
                // the list of keyboard layouts for now. )
                //
                    IMEINFOEX iiex;
                    //
                    // Let's retrieve the corresponding hkl
                    // from the IME filename specified by the caller.
                    //
                    if ( ImmGetImeInfoEx( &iiex,
                                         ImeInfoExImeFileName,
                                         (PVOID)lpImeProW->szName ) ) {
                        //
                        // let phkl point to the next hkl
                        //
                        phkl = phklRoot;
                        while ( *phkl != NULL ) {
                            if ( *phkl++ == iiex.hkl ) {
                                break;
                            }
                        }
                    }
                }
                if ( phkl != NULL ) {
                    while ( *phkl != NULL ) {
                        //
                        // IMPGetIMEWorker will return FALSE if
                        // the hkl specified is a non-IME layout.
                        //
                        if ( fResult = IMPGetIMEWorker(*phkl++, lpImeProW) ) {
                            break;
                        }
                    }
                }
            }
            ImmLocalFree( phklRoot );
        }
    }
    return fResult;
}

BOOL WINAPI ImmIMPQueryIMEA(
    LPIMEPROA lpImeProA)
{

    IMEPROW    ImeProW;

    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }

    if ( lpImeProA->szName[0] != '\0' ) {
    //
    // Convert MultiByteString(szName) to UnicodeString
    //
        INT i;

        i = MultiByteToWideChar( CP_ACP, (DWORD)MB_PRECOMPOSED,
                                 lpImeProA->szName,
                                 -1,
                                 ImeProW.szName,
                                 (INT)sizeof(ImeProW.szName)/sizeof(WCHAR));
        if ( i == 0 ) {
            return FALSE;
        }

    } else {
        ImeProW.szName[0] = L'\0';
    }

    if ( ImmIMPQueryIMEW( &ImeProW ) ) {
        ConvertImeProWtoA( lpImeProA, &ImeProW );
        return TRUE;
    }
    return FALSE;
}

BOOL WINAPI ImmIMPSetIMEW(
    HWND hwndApp,
    LPIMEPROW lpImeProW)
{
    IMEINFOEX iiex;
    HKL hkl = NULL;

    UNREFERENCED_PARAMETER(hwndApp);

    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }

    if ( lpImeProW->szName[0] != L'\0' ) {
    //
    // IME name is specified. Switch to the IME specified.
    //
        if ( ImmGetImeInfoEx(&iiex,ImeInfoExImeFileName,(PVOID)lpImeProW->szName) ) {
            hkl = iiex.hkl;
        }
    } else {
    //
    // IME name is not specified. Switch to a non-IME layout
    //
        INT numLayouts;
        HKL   *phkl;
        HKL   *phklRoot;

        numLayouts = GetKeyboardLayoutList( 0, NULL );
        if ( numLayouts > 0 ) {
            phkl = phklRoot = ImmLocalAlloc( 0, (numLayouts + 1) * sizeof(HKL) );
            if ( phkl != NULL ) {
                if ( GetKeyboardLayoutList( numLayouts, phkl ) == numLayouts ) {
                    *(phklRoot+numLayouts) = (HKL)NULL;
                    while ( *phkl != NULL ) {
                        if ( ! ImmIsIME( *phkl ) ) {
                            hkl = *phkl;
                            break;
                        }
                        phkl++;
                    }
                }
                ImmLocalFree( phklRoot );
            }
        }
    }

    if ( hkl != NULL && GetKeyboardLayout(0) != hkl ) {
        HWND hwndFocus;

        hwndFocus = GetFocus();
        if ( hwndFocus != NULL ) {
            PostMessage( hwndFocus,
                         WM_INPUTLANGCHANGEREQUEST,
                         DEFAULT_CHARSET,
                         (LPARAM)hkl);
            return TRUE;
        }
    }
    return FALSE;
}

BOOL WINAPI ImmIMPSetIMEA(
    HWND hwndApp,
    LPIMEPROA lpImeProA)
{
    IMEPROW ImeProW;

    UNREFERENCED_PARAMETER(hwndApp);

    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }

    if ( lpImeProA->szName[0] != '\0' ) {
    //
    // Convert MultiByteString(szName) to UnicodeString
    //
        INT i;

        i = MultiByteToWideChar( CP_ACP, (DWORD)MB_PRECOMPOSED,
                                 lpImeProA->szName,
                                 -1,
                                 ImeProW.szName,
                                 (INT)sizeof(ImeProW.szName)/sizeof(WCHAR));
        if ( i == 0 ) {
            return FALSE;
        }

    } else {
        ImeProW.szName[0] = L'\0';
    }
    return ImmIMPSetIMEW(hwndApp, &ImeProW);
}

//
// if the "enable/disable" state of the default input context
// of the caller thread is same as the state specified by
// fEnalble parameter, this function does nothing but returns
// the current "enable/disable" state.
//
// if fEnable is FALSE, this function disables the default
// input context of caller thread.
//
// if fEnable is TRUE, this function enables the default
// input context of caller thread.
//
//
BOOL ImmEnableIME(
    HWND hwnd,
    BOOL fEnable
    )
{
    HIMC hImc;
    PCLIENTIMC pClientImc;
    BOOL fCurrentState;
    HWND hwndFocus;
    BOOL fImeInitialized;

    //
    // Get the caller thread's default input context
    //
    hImc = (HIMC)NtUserGetThreadState(UserThreadStateDefaultInputContext);
    if ( hImc == NULL_HIMC ) {
        return FALSE;
    }
    pClientImc = ImmLockClientImc( hImc );
    if ( pClientImc == NULL ) {
        return FALSE;
    }

    //
    // we will return the curren t"enable/disable" state of the input context
    //
    fCurrentState =  TestICF(pClientImc, IMCF_WINNLSDISABLE) ? FALSE : TRUE;

    //
    // if the current thread (caller thread) doesn't have the focus window,
    // UI windows will not be updated. When we're called later, we will end
    // up to just return the fCurrentState without calling ImmSetActiveContext.
    // To avoid that, the "same status" check below is disabled...

    if ( (fCurrentState && fEnable) || (!fCurrentState && !fEnable) ) {
       ImmUnlockClientImc( pClientImc );
        //
        // nothing has been changed. return the current state
        //
        return fCurrentState;
    }


    if ( ! IsWindow(hwnd) ) {
        hwndFocus = GetFocus();
    } else {
        hwndFocus = hwnd;
    }

    //
    // check if the initialize of IMM has been done.
    //
    if ( IsWindow(ImmGetDefaultIMEWnd(hwndFocus)) ) {
        fImeInitialized = TRUE;
    } else {
        fImeInitialized = FALSE;
    }

    if ( fImeInitialized ) {
        if ( ! fEnable ) {
        //
        // we're going to disable the target IMC
        //
            //
            // make the target IMC non-active
            //
            ImmSetActiveContext( hwndFocus, hImc, FALSE );

        } else {
        //
        // we're going to enable the target IMC
        //
            //
            // make NULL context non-active
            //
            ImmSetActiveContext( hwndFocus, NULL_HIMC, FALSE );
        }
    }

    //
    // update the state of the input context
    //
    if ( fEnable )
        ClrICF( pClientImc, IMCF_WINNLSDISABLE );
    else
        SetICF( pClientImc, IMCF_WINNLSDISABLE );
    ImmUnlockClientImc( pClientImc );


    if ( fImeInitialized ) {
        if ( fEnable ) {
        //
        // we're going to enable the target IMC
        //
            //
            // make the target IMC active
            //
            ImmSetActiveContext( hwndFocus, hImc, TRUE );
        } else {
        //
        // we're going to disable the target IMC
        //
            //
            // make NULL context active
            //
            ImmSetActiveContext( hwndFocus, NULL_HIMC, TRUE );
        }
    }

    //
    // the return value is previous state
    //
    return fCurrentState;
}

BOOL CheckCountry()
{
    WORD LangId;

    LangId = PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID()));
    if ( LangId == LANG_JAPANESE || LangId == LANG_KOREAN ) {
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\i386\callproc.asm ===
title   "Callback Routines"
;++
;
;  Copyright (c) 1985 - 1999, Microsoft Corporation
;
;  Module Name:
;
;     callproc.asm
;
;  Abstract:
;
;     This module implements stack cleanup to gaurd against cdecl
;     declared wndprocs.
;     Bug 234292
;
;  Author:
;
;     Joseph Jones (joejo) 12/4/98
;
;
;  Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132


;++
;
;LRESULT
;InternalCallWinProc(
;    WNDPROC winproc,
;    HWND hwnd,
;    UINT message,
;    WPARAM wParam,
;    LPARAM lParam
;    )
;
; Routine Description:
;
;    this function cals an x86 window procedure. It protects against
;    window procedures that don't preserve EBX or fail to clean up
;    enough stack.
;
;    The only register that the window proc cannot trash is ESI.
;
; Arguments:
;
;    winproc - x86 Procedure to call
;
;    hwnd - window handle that sent the message
;
;    message - message being sent
;
;    wParam - wParam argument to window procedure
;
;    lParam - lParam argument to window proc
;
; Return Value:
;
;    LRESULT return value from called window procedure
;
;--

cPublicProc _InternalCallWinProc , 5

winproc         equ [ebp + 8]
hwnd            equ [ebp + 12]
message         equ [ebp + 16]
wParam          equ [ebp + 20]
lParam          equ [ebp + 24]

StackGuard      equ 0DCBAABCDh

        push    ebp
        mov     ebp, esp

        push    esi
        push    edi
        push    ebx

        push    StackGuard  ; push guard on the stack
        push    esi         ; push another DWORD on the stack
                            ; so that bogus apps that treat &lParam
                            ; as an LPPOINT don't corrupt the StackGuard

        push    lParam
        push    wParam
        push    message
        push    hwnd
        call    winproc

        cmp     DWORD PTR [esp+4], StackGuard
        je      goodCalling

;--
;       Bug 386625: fix for Corel Presentation 9.0 that restores the stack
;                   for 5 parameters instead of 4
;--

        cmp     DWORD PTR [esp], StackGuard
        jne     fixupTheStack
        sub     esp, 04h
        jmp     goodCalling

fixupTheStack:
        add     esp, 010h   ; fix up the stack

goodCalling:
        add     esp, 08h    ; pop the extra DWORD
                            ; pop the second StackGuard

        pop     ebx
        pop     edi
        pop     esi

        pop     ebp
        stdRET  _InternalCallWinProc
stdENDP _InternalCallWinProc


;/*
; * Bug 246472 - joejo
; * fixup all DDE Callbacks since some apps make their callbacks
; * C-Style instead of PASCAL.
; */

;++
;
;HDDEDATA
;UserCallDDECallback(
;    UINT wType,
;    UINT wFmt,
;    HCONV hConv,
;    HSZ hsz1,
;    HSZ hsz2,
;    HDDEDATA hData,
;    ULONG_PTR dwData1,
;    ULONG_PTR dwData2
;    )
;
; Routine Description:
;
;    this function cals an x86 DDE Callback procedure. It protects against
;    callback procedures that don't preserve EBX or fail to clean up
;    enough stack.
;
;    The only register that the window proc cannot trash is ESI.
;
; Arguments:
;
;       pfnDDECallback - DDE Callback function pointer
;       wType
;       wFmt
;       hConv
;       hsz1
;       hsz2
;       hData
;       dwData1
;       dwData2
;
; Return Value:
;
;    HDDEDATA   - Handle to a returnded DDE Data object
;
;--

cPublicProc _UserCallDDECallback , 9

pfnDDECallback  equ [ebp + 8]
wType           equ [ebp + 12]
wFmt            equ [ebp + 16]
hConv           equ [ebp + 20]
hsz1            equ [ebp + 24]
hsz2            equ [ebp + 28]
hData           equ [ebp + 32]
dwData1         equ [ebp + 36]
dwData2         equ [ebp + 40]


        push    ebp
        mov     ebp, esp
        push    esi         ; save esi across the call
        push    edi         ; save edi across the call
        push    ebx         ; save ebx on the stack across the call
        mov     esi,esp     ; save the stack pointer in esi across the call
        push    dwData2
        push    dwData1
        push    hData
        push    hsz2
        push    hsz1
        push    hConv
        push    wFmt
        push    wType
        call    pfnDDECallback
        mov     esp,esi     ; restore the stack pointer in case callee forgot to clean up
        pop     ebx         ; restore ebx
        pop     edi         ; restore edi
        pop     esi         ; restore esi
        pop     ebp
        stdRET  _UserCallDDECallback
stdENDP _UserCallDDECallback



_TEXT   ends


        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\client\xact.c ===
/****************************** Module Header ******************************\
* Module Name: xact.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager transaction processing module
*
* Created: 11/3/91 Sanford Staab
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* DdeClientTransaction (DDEML API)
*
* Description:
* Initiates all DDE transactions.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG8(LOG_GENERAL, HDDEDATA, DUMMYCALLINGTYPE, DdeClientTransaction, LPBYTE, pData, DWORD, cbData, HCONV, hConv, HSZ, hszItem, UINT, wFmt, UINT, wType, DWORD, ulTimeout, LPDWORD, pulResult)
HDDEDATA DdeClientTransaction(
LPBYTE pData,
DWORD cbData,
HCONV hConv,
HSZ hszItem,
UINT wFmt,
UINT wType,
DWORD ulTimeout,
LPDWORD pulResult)
{
    MSG msg;
    PCL_INSTANCE_INFO pcii = NULL;
    HDDEDATA hRet = 0;
    PCL_CONV_INFO pci;
    PDDEMLDATA pdd = NULL;
    PXACT_INFO pxi;
    BOOL fStarted;
    PDDE_DATA pdde;

    EnterDDECrit;

    pci = (PCL_CONV_INFO)ValidateCHandle((HANDLE)hConv,
            HTYPE_CLIENT_CONVERSATION, HINST_ANY);
    if (pci == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    pcii = pci->ci.pcii;
    if (ulTimeout != TIMEOUT_ASYNC && GetClientInfo()->CI_flags & CI_IN_SYNC_TRANSACTION) {
        SetLastDDEMLError(pcii, DMLERR_REENTRANCY);
        goto Exit;
    }
    if (!(pci->ci.state & ST_CONNECTED)) {
        SetLastDDEMLError(pcii, DMLERR_NO_CONV_ESTABLISHED);
        goto Exit;
    }

    switch (wType) {
    case XTYP_POKE:
    case XTYP_ADVSTART:
    case XTYP_ADVSTART | XTYPF_NODATA:
    case XTYP_ADVSTART | XTYPF_ACKREQ:
    case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:
    case XTYP_REQUEST:
    case XTYP_ADVSTOP:
        if (hszItem == 0) {
            SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
            goto Exit;
        }
        break;

    case XTYP_EXECUTE: // just ignore wFmt & hszItem
        break;

    default:
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    pxi = DDEMLAlloc(sizeof(XACT_INFO));
    if (pxi == NULL) {
        SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
        goto Exit;
    }

    switch (wType) {
    case XTYP_EXECUTE:
    case XTYP_POKE:
        if ((LONG)cbData == -1L) {

            // We are accepting an existing data handle for export to another
            // app.

            pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)pData,
                    HTYPE_DATA_HANDLE, HINST_ANY);
            if (pdd == NULL) {
InvParam:
                SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
                DDEMLFree(pxi);
                goto Exit;
            }

            // make sure data handle holds apropriate data for this transaction

            if ((pdd->flags & HDATA_EXECUTE && wType != XTYP_EXECUTE) ||
                    (!(pdd->flags & HDATA_EXECUTE) && wType == XTYP_EXECUTE)) {
                goto InvParam;
            }

            // To simplify life, use a copy if this handle is potentially
            // a relay or APPOWNED handle.

            if (pdd->flags & (HDATA_APPOWNED | HDATA_NOAPPFREE)) {
                pxi->hDDESent = CopyDDEData(pdd->hDDE, wType == XTYP_EXECUTE);
                if (!pxi->hDDESent) {
MemErr:
                    DDEMLFree(pxi);
                    SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
                    goto Exit;
                }
                USERGLOBALLOCK(pxi->hDDESent, pdde);
                if (pdde == NULL) {
                    FreeDDEData(pxi->hDDESent, TRUE, TRUE);
                    goto MemErr;
                }
                pdde->wStatus = DDE_FRELEASE;
                USERGLOBALUNLOCK(pxi->hDDESent);
            } else {
                pxi->hDDESent = pdd->hDDE;
            }

            // make sure handle has proper format

            if (wType == XTYP_POKE) {
                USERGLOBALLOCK(pxi->hDDESent, pdde);
                if (pdde == NULL) {
                    goto InvParam;
                }
                pdde->wFmt = (WORD)wFmt;
                USERGLOBALUNLOCK(pxi->hDDESent);
            }

        } else {  // Convert data in buffer into an apropriate hDDE

            if (wType == XTYP_POKE) {
                pxi->hDDESent = AllocAndSetDDEData(pData, cbData,
                        DDE_FRELEASE, (WORD)wFmt);
            } else {
                pxi->hDDESent = AllocAndSetDDEData(pData, cbData, 0, 0);
            }
            if (!pxi->hDDESent) {
                goto MemErr;
            }
        }
    }

    // FINALLY - start the transaction

    pxi->pcoi = (PCONV_INFO)pci;
    pxi->gaItem = LocalToGlobalAtom(LATOM_FROM_HSZ(hszItem)); // pxi copy
    pxi->wFmt = (WORD)wFmt;
    pxi->wType = (WORD)wType;

    switch (wType) {
    case XTYP_ADVSTART:
    case XTYP_ADVSTART | XTYPF_NODATA:
    case XTYP_ADVSTART | XTYPF_ACKREQ:
    case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:
        fStarted = ClStartAdvise(pxi);
        break;

    case XTYP_ADVSTOP:
        fStarted = ClStartUnadvise(pxi);
        break;

    case XTYP_EXECUTE:
        fStarted = ClStartExecute(pxi);
        break;

    case XTYP_POKE:
        fStarted = ClStartPoke(pxi);
        break;

    case XTYP_REQUEST:
        fStarted = ClStartRequest(pxi);
    }

    if (!fStarted) {
        // if we copied or allocated data - free it.
        if (pxi->hDDESent && (pdd == NULL || pxi->hDDESent != pdd->hDDE)) {
            FreeDDEData(pxi->hDDESent, FALSE, TRUE);     // free data copy
        }
        GlobalDeleteAtom(pxi->gaItem); // pxi copy
        DDEMLFree(pxi);
        goto Exit;
    }

    if (pdd != NULL && !(pdd->flags & (HDATA_NOAPPFREE | HDATA_APPOWNED))) {

        // invalidate given handle on success - unless we copied it because
        // the app will either be return ing it from a callback or potentially
        // using it again.

        DDEMLFree(pdd);
        DestroyHandle((HANDLE)pData);
    }

    if (ulTimeout == TIMEOUT_ASYNC) {

        // asynchronous transaction

        if (pulResult != NULL) {
            pxi->hXact = CreateHandle((ULONG_PTR)pxi, HTYPE_TRANSACTION,
                    InstFromHandle(pcii->hInstClient));
            *pulResult = HandleToUlong(pxi->hXact);
        }
        hRet = (HDDEDATA)TRUE;

    } else {

        // synchronous transaction

        GetClientInfo()->CI_flags |= CI_IN_SYNC_TRANSACTION;
        pcii->flags |= IIF_IN_SYNC_XACT;

        pxi->flags |= XIF_SYNCHRONOUS;
        NtUserSetTimer(pci->ci.hwndConv, TID_TIMEOUT, ulTimeout, NULL);

        LeaveDDECrit;
        CheckDDECritOut;

        GetMessage(&msg, (HWND)NULL, 0, 0);

        /*
         * stay in modal loop until a timeout happens.
         */
        while (msg.hwnd != pci->ci.hwndConv || msg.message != WM_TIMER ||
            (msg.wParam != TID_TIMEOUT)) {

            if (!CallMsgFilter(&msg, MSGF_DDEMGR))
                DispatchMessage(&msg);

            GetMessage(&msg, (HWND)NULL, 0, 0);
        }

        EnterDDECrit;

        NtUserKillTimer(pci->ci.hwndConv, TID_TIMEOUT);
        GetClientInfo()->CI_flags &= ~CI_IN_SYNC_TRANSACTION;
        pcii->flags &= ~IIF_IN_SYNC_XACT;

        if (pxi->flags & XIF_COMPLETE) {
            if (pulResult != NULL) {
                *pulResult = pxi->wStatus; // NACK status bits
            }
            switch (wType) {
            case XTYP_ADVSTART:
            case XTYP_ADVSTART | XTYPF_NODATA:
            case XTYP_ADVSTART | XTYPF_ACKREQ:
            case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:
            case XTYP_ADVSTOP:
            case XTYP_EXECUTE:
            case XTYP_POKE:
                hRet = (HDDEDATA)((ULONG_PTR)((pxi->wStatus & DDE_FACK) ? TRUE : FALSE));
                if (!hRet) {
                    if (pxi->wStatus & DDE_FBUSY) {
                        SetLastDDEMLError(pcii, DMLERR_BUSY);
                    } else {
                        SetLastDDEMLError(pcii, DMLERR_NOTPROCESSED);
                    }
                }
                break;

            case XTYP_REQUEST:
                if (pxi->hDDEResult == 0) {
                    hRet = (HDDEDATA)((ULONG_PTR)((pxi->wStatus & DDE_FACK) ? TRUE : FALSE));
                    if (!hRet) {
                        if (pxi->wStatus & DDE_FBUSY) {
                            SetLastDDEMLError(pcii, DMLERR_BUSY);
                        } else {
                            SetLastDDEMLError(pcii, DMLERR_NOTPROCESSED);
                        }
                    }
                    break;
                }
                // Note that if the incoming data didn't have the DDE_FRELEASE
                // bit set, the transaction code would have made a copy so
                // the app is free to keep is as long as he likes.

                hRet = InternalCreateDataHandle(pcii, (LPBYTE)pxi->hDDEResult, (DWORD)-1, 0,
                        HDATA_READONLY, 0, 0);
                pxi->hDDEResult = 0; // so cleanup doesn't free it.
            }

            (pxi->pfnResponse)((struct tagXACT_INFO *)pxi, 0, 0); // cleanup transaction

        } else {    // Timed out

            // abandon the transaction and make it asyncronous so it will
            // clean itself up when the response finally comes in.

            pxi->flags &= ~XIF_SYNCHRONOUS;
            pxi->flags |= XIF_ABANDONED;

            switch (wType) {
            case XTYP_ADVSTART:
            case XTYP_ADVSTART | XTYPF_NODATA:
            case XTYP_ADVSTART | XTYPF_ACKREQ:
            case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:
                SetLastDDEMLError(pcii, DMLERR_ADVACKTIMEOUT);
                break;
            case XTYP_ADVSTOP:
                SetLastDDEMLError(pcii, DMLERR_UNADVACKTIMEOUT);
                break;
            case XTYP_EXECUTE:
                SetLastDDEMLError(pcii, DMLERR_EXECACKTIMEOUT);
                break;
            case XTYP_POKE:
                SetLastDDEMLError(pcii, DMLERR_POKEACKTIMEOUT);
                break;
            case XTYP_REQUEST:
                SetLastDDEMLError(pcii, DMLERR_DATAACKTIMEOUT);
                break;
            }
            // cleanup of pxi happens when transaction actually completes.
        }
    }
    if (pci->ci.state & ST_FREE_CONV_RES_NOW) {
        /*
         * The conversation was terminated during the synchronous transaction
         * so we need to clean up now that we are out of the loop.
         */
         FreeConversationResources((PCONV_INFO)pci);
    }

Exit:
    /*
     * Because this API is capable of blocking DdeUninitialize(), we check
     * before exit to see if it needs to be called.
     */
    if (pcii != NULL &&
            (pcii->afCmd & APPCMD_UNINIT_ASAP) &&
            // !(pcii->flags & IIF_IN_SYNC_XACT) &&
            !pcii->cInDDEMLCallback) {
        DdeUninitialize(HandleToUlong(pcii->hInstClient));
        hRet = 0;
    }
    LeaveDDECrit;
    return (hRet);
}




/***************************************************************************\
* GetConvContext
*
* Description:
* Retrieves conversation context information from the DDEML client window
* given. pl points to a CONVCONTEXT structure.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
VOID GetConvContext(
HWND hwnd,
LONG *pl)
{
    int i;

    for (i = 0; i < sizeof(CONVCONTEXT); i += 4) {
        *pl++ = GetWindowLong(hwnd, GWL_CONVCONTEXT + i);
    }
}

/***************************************************************************\
* SetConvContext
*
* Description:
*
* History:
* 11-19-92 sanfords Created.
\***************************************************************************/
VOID SetConvContext(
HWND hwnd,
LONG *pl)
{
    int i;

    for (i = 0; i < sizeof(CONVCONTEXT); i += 4) {
        SetWindowLong(hwnd, GWL_CONVCONTEXT + i, *pl++);
    }
}




/***************************************************************************\
* DdeQueryConvInfo (DDEML API)
*
* Description:
* Retrieves detailed conversation information on a per conversation/
* transaction basis.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, DdeQueryConvInfo, HCONV, hConv, DWORD, idTransaction, PCONVINFO, pConvInfo)
UINT DdeQueryConvInfo(
HCONV hConv,
DWORD idTransaction,
PCONVINFO pConvInfo)
{
    PCONV_INFO pcoi;
    PXACT_INFO pxi;
    CONVINFO ci;
    UINT uiRet = 0;

    EnterDDECrit;

    if (!ValidateTransaction(hConv, (HANDLE)LongToHandle( idTransaction ), &pcoi, &pxi)) {
        goto Exit;
    }

    try {
        if (pConvInfo->cb > sizeof(CONVINFO)) {
            SetLastDDEMLError(pcoi->pcii, DMLERR_INVALIDPARAMETER);
            goto Exit;
        }
        ci.cb = pConvInfo->cb;
        ci.hConvPartner = 0; // no longer supported.
        ci.hszSvcPartner = NORMAL_HSZ_FROM_LATOM(pcoi->laService);
        ci.hszServiceReq = NORMAL_HSZ_FROM_LATOM(pcoi->laServiceRequested);
        ci.hszTopic = NORMAL_HSZ_FROM_LATOM(pcoi->laTopic);
        ci.wStatus = pcoi->state;
        ci.wLastError = (WORD)pcoi->pcii->LastError;
        if (pcoi->state & ST_CLIENT) {
            ci.hConvList = ((PCL_CONV_INFO)pcoi)->hConvList;
            GetConvContext(pcoi->hwndConv, (LONG *)&ci.ConvCtxt);
        } else {
            ci.hConvList = 0;
            if (pcoi->state & ST_ISLOCAL) {
                GetConvContext(pcoi->hwndPartner, (LONG *)&ci.ConvCtxt);
            } else {
                ci.ConvCtxt = DefConvContext;
            }
        }
        if (pxi == NULL) {
            ci.hUser = pcoi->hUser;
            ci.hszItem = 0;
            ci.wFmt = 0;
            ci.wType = 0;
            ci.wConvst = XST_CONNECTED;
        } else {
            ci.hUser = pxi->hUser;
            // BUG - not fixable - This will result in extra local atoms
            // since we can never know when he is done with them.
            ci.hszItem = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom(pxi->gaItem));
            ci.wFmt = pxi->wFmt;
            ci.wType = pxi->wType;
            ci.wConvst = pxi->state;
        }
        ci.hwnd = pcoi->hwndConv;
        ci.hwndPartner = pcoi->hwndPartner;
        RtlCopyMemory((LPSTR)pConvInfo, (LPSTR)&ci, pConvInfo->cb);
    } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
        SetLastDDEMLError(pcoi->pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    uiRet = TRUE;

Exit:
    LeaveDDECrit;
    return (uiRet);
}


/***************************************************************************\
* DdeSetUserHandle (DDEML API)
*
* Description:
* Sets a user DWORD on a per conversation/transaction basis.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeSetUserHandle, HCONV, hConv, DWORD, id, DWORD_PTR, hUser)
BOOL DdeSetUserHandle(
HCONV hConv,
DWORD id,
DWORD_PTR hUser)
{
    PCONV_INFO pcoi;
    PXACT_INFO pxi;
    BOOL fRet = FALSE;

    EnterDDECrit;

    if (!ValidateTransaction(hConv, (HANDLE)LongToHandle( id ), &pcoi, &pxi)) {
        goto Exit;
    }
    if (pxi == NULL) {
        pcoi->hUser = hUser;
    } else {
        pxi->hUser = hUser;
    }
    fRet = TRUE;

Exit:
    LeaveDDECrit;
    return (fRet);
}



VOID AbandonTransaction(
PCONV_INFO pcoi,
PXACT_INFO pxi)
{
    if (pxi != NULL) {
        pxi->flags |= XIF_ABANDONED;
    } else {
        for (pxi = pcoi->pxiIn; pxi != NULL; pxi = pxi->next) {
            pxi->flags |= XIF_ABANDONED;
        }
    }
}



BOOL AbandonEnumerateProc(
HWND hwnd,
LPARAM idTransaction)
{
    PCONV_INFO pcoi;

    pcoi = (PCONV_INFO)GetWindowLongPtr(hwnd, GWLP_PCI);
    if (!pcoi || !(pcoi->state & ST_CLIENT)) {
        return(TRUE);
    }
    while (pcoi) {
        AbandonTransaction(pcoi, (PXACT_INFO)idTransaction);
        pcoi = pcoi->next;
    }
    return(TRUE);
}



/***************************************************************************\
* DdeAbandonTransaction (DDEML API)
*
* Description:
* Cancels application interest in completing an asynchronous transaction.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeAbandonTransaction, DWORD, idInst, HCONV, hConv, DWORD, idTransaction)
BOOL DdeAbandonTransaction(
DWORD idInst,
HCONV hConv,
DWORD idTransaction)
{
    PCONV_INFO pcoi;
    PXACT_INFO pxi;
    PCL_INSTANCE_INFO pcii;
    BOOL fRet = FALSE;

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));

    if (hConv == 0 && idTransaction == 0) {
        EnumChildWindows(pcii->hwndMother, AbandonEnumerateProc, 0);
        goto Exit;
    }
    if (idTransaction == 0) {
        idTransaction = QID_SYNC;
    }
    if (!ValidateTransaction(hConv, (HANDLE)LongToHandle( idTransaction ), &pcoi, &pxi)) {
        goto Exit;
    }
    if (pcii == NULL || pcoi->pcii != pcii) {
        SetLastDDEMLError(pcoi->pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    AbandonTransaction(pcoi, pxi);
    fRet = TRUE;

Exit:
    LeaveDDECrit;
    return (fRet);
}




/***************************************************************************\
* UpdateLinkIfChanged
*
* Description:
*   Helper function for updating a link
*
* Returns: TRUE if pxi was used - ie fMustReallocPxi
*
* History:
* 3-11-92   sanfords    Created.
* 8-24-92   sanfords    added cLinksToGo
\***************************************************************************/
BOOL UpdateLinkIfChanged(
PADVISE_LINK paLink,
PXACT_INFO pxi,
PCONV_INFO pcoi,
PADVISE_LINK paLinkLast,
PBOOL pfSwapped,
DWORD cLinksToGo)
{
    ADVISE_LINK aLinkT;

    CheckDDECritIn;

    *pfSwapped = FALSE;
    if (paLink->state & ADVST_CHANGED && !(paLink->state & ADVST_WAITING)) {
        pxi->pfnResponse = SvRespAdviseDataAck;
        pxi->pcoi = pcoi;
        pxi->gaItem = LocalToGlobalAtom(paLink->laItem);    // pxi copy
        pxi->wFmt = paLink->wFmt;
        pxi->wType = paLink->wType;
        paLink->state &= ~ADVST_CHANGED;
        if (SvStartAdviseUpdate(pxi, cLinksToGo)) {
            if (pxi->wType & DDE_FACKREQ) {
                paLink->state |= ADVST_WAITING;
                /*
                 * swap paLink with the last non-moved link to make ack search find
                 * oldest updated format.
                 */
                if (paLink != paLinkLast) {
                    aLinkT = *paLink;
                    RtlMoveMemory(paLink, paLink + 1,
                            (PBYTE)paLinkLast - (PBYTE)paLink);
                    *paLinkLast = aLinkT;
                    *pfSwapped = TRUE;
                }
            }
            return(TRUE);
        } else {
            GlobalDeleteAtom(pxi->gaItem);  // pxi copy
            return(FALSE);
        }
    }
    return(FALSE);
}


/***************************************************************************\
* DdePostAdvise     (DDEML API)
*
* Description:
* Updates outstanding server advise links as needed.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdePostAdvise, DWORD, idInst, HSZ, hszTopic, HSZ, hszItem)
BOOL DdePostAdvise(
DWORD idInst,
HSZ hszTopic,
HSZ hszItem)
{
    PCL_INSTANCE_INFO pcii;
    PSVR_CONV_INFO psi;
    PXACT_INFO pxi;
    PADVISE_LINK paLink;
    BOOL fRet = FALSE, fSwapped, fFound;
    int iServer, iLink;
    PLINK_COUNT pLinkCount;
#if DBG
    int cLinks;
#endif

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if ((ValidateHSZ(hszTopic) == HSZT_INVALID) ||
            (ValidateHSZ(hszItem) == HSZT_INVALID)) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    /*
     * Initialize all link counters and check if any links qualify
     */
    fFound = FALSE;
    for (pLinkCount = pcii->pLinkCount;
            pLinkCount; pLinkCount = pLinkCount->next) {
        pLinkCount->Count = pLinkCount->Total;
        fFound |= pLinkCount->laTopic == LATOM_FROM_HSZ(hszTopic) &&
                  pLinkCount->laItem == LATOM_FROM_HSZ(hszItem);
    }
    if (!fFound && hszTopic && hszItem) {
        fRet = TRUE;
        goto Exit;
    }

    /*
     * preallocate incase we are low on memory.
     */
    pxi = DDEMLAlloc(sizeof(XACT_INFO));
    if (pxi == NULL) {
        SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
        fRet = FALSE;
        goto Exit;
    }

    /*
     * For each server window on the specified topic
     */
    for (iServer = 0; iServer < pcii->cServerLookupAlloc; iServer++) {
        if (hszTopic == 0 ||
                pcii->aServerLookup[iServer].laTopic == LATOM_FROM_HSZ(hszTopic)) {

            /*
             * For each conversation within that window
             */
            psi = (PSVR_CONV_INFO)GetWindowLongPtr(
                    pcii->aServerLookup[iServer].hwndServer, GWLP_PSI);
            UserAssert(psi != NULL && psi->ci.pcii == pcii);    // sanity check
            while (psi != NULL) {


                /*
                 * UpdateLinkIfChanged might leave the critical section so lock this conversation
                 */
                psi->ci.cLocks++;

                #if DBG
                /*
                 * Rememeber the number of links so we can assert if they change during the loop below
                 */
                cLinks = psi->ci.cLinks;
                #endif
                /*
                 * For each active link on the given item...
                 */
                for (paLink = psi->ci.aLinks, iLink = 0;
                        iLink < psi->ci.cLinks; paLink++, iLink++) {
                    if (hszItem == 0 ||
                            paLink->laItem == LATOM_FROM_HSZ(hszItem)) {

// Bit of a hack here. For FACKREQ links, we don't want the server to
// outrun the client so we set the ADVST_WAITING bit till the ack is
// received. When the ack comes in, the protocol code has to search
// the aLinks array again to locate the apropriate link state flags and
// clear the ADVST_WAITING flag. At that time, if the ADVST_CHANGED flag
// is set, it is cleared and another SvStartAdviseUpdate transaction
// is started to get the link up to date.  To complicate matters,
// the ACK contains no format information.  Thus we need to move
// the Link info to the end of the list so that the right format
// is updated when the ack comes in.

                        paLink->state |= ADVST_CHANGED;
                        if (UpdateLinkIfChanged(paLink, pxi, &psi->ci,
                                &psi->ci.aLinks[psi->ci.cLinks - 1],
                                &fSwapped, --paLink->pLinkCount->Count)) {
                            if (fSwapped) {
                                paLink--;
                            }
                            /*
                             * preallocate for next advise
                             */
                            pxi = DDEMLAlloc(sizeof(XACT_INFO));
                            if (pxi == NULL) {
                                SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
                                /*
                                 * Unlock the conversation
                                 */
                                psi->ci.cLocks--;
                                if ((psi->ci.cLocks == 0) && (psi->ci.state & ST_FREE_CONV_RES_NOW)) {
                                    RIPMSG1(RIP_ERROR, "DdePostAdvise: Conversation terminated. psi:%#p", psi);
                                    FreeConversationResources((PCONV_INFO)psi);
                                }
                                goto Exit;
                            }
                        }
                        /*
                         * We might have left the crit sect...
                         */
                        UserAssert(pcii == ValidateInstance((HANDLE)LongToHandle( idInst )));
                    }
                }
                #if DBG
                if (cLinks != psi->ci.cLinks) {
                    RIPMSG1(RIP_ERROR, "DdePostAdvise: cLinks changed. psi:%#p", psi);
                }
                #endif

                /*
                 * If the converstaion got nuked, stop working on this conversation chain.
                 */
                psi->ci.cLocks--;
                if ((psi->ci.cLocks == 0) && (psi->ci.state & ST_FREE_CONV_RES_NOW)) {
                    RIPMSG1(RIP_ERROR, "DdePostAdvise: Conversation terminated. psi:%#p", psi);
                    FreeConversationResources((PCONV_INFO)psi);
                    break;
                }

                psi = (PSVR_CONV_INFO)psi->ci.next;     // next conversation
            }
        }
    }
    DDEMLFree(pxi);
    fRet = TRUE;

Exit:
    /*
     * Because callbacks are capable of blocking DdeUninitialize(), we check
     * before exit to see if it needs to be called.
     */
    UserAssert(pcii == ValidateInstance((HANDLE)LongToHandle( idInst )));
    if (pcii != NULL &&
            pcii->afCmd & APPCMD_UNINIT_ASAP &&
            !(pcii->flags & IIF_IN_SYNC_XACT) &&
            !pcii->cInDDEMLCallback) {
        DdeUninitialize(HandleToUlong(pcii->hInstClient));
        fRet = TRUE;
    }
    LeaveDDECrit;
    return (fRet);
}


/***************************************************************************\
* LinkTransaction
*
* Description:
* Adds a transaction structure to the associated conversation's transaction
* queue.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
VOID LinkTransaction(
PXACT_INFO pxi)
{
    CheckDDECritIn;

    pxi->next = NULL;
    if (pxi->pcoi->pxiOut == NULL) {
        pxi->pcoi->pxiIn = pxi->pcoi->pxiOut = pxi;
    } else {
        pxi->pcoi->pxiIn->next = pxi;
        pxi->pcoi->pxiIn = pxi;
    }
#if DBG
    /*
     * Temporary check to find stress bug - make sure pxi list is not
     * looped on itself.  If it is, this loop will never exit and things
     * will get investigated. (sanfords)
     */
    {
        PXACT_INFO pxiT;

        for (pxiT = pxi->pcoi->pxiOut; pxiT != NULL; pxiT = pxiT->next) {
            ;
        }
    }
#endif // DBG
}


/***************************************************************************\
* UnlinkTransaction
*
* Description:
* Removes a transaction structure from the associated conversation's transaction
* queue.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
VOID UnlinkTransaction(
PXACT_INFO pxi)
{
    CheckDDECritIn;
    if (pxi == pxi->pcoi->pxiOut) {
        pxi->pcoi->pxiOut = pxi->next;
        if (pxi->next == NULL) {
            pxi->pcoi->pxiIn = NULL;
        }
    }
}


/***************************************************************************\
* ValidateTransaction
*
* Description:
* Common validation code for DDEML APIs that take a conversation handle
* and a transaction ID. *ppxi may be null on return if hXact was 0.
* Returns fSuccess.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL ValidateTransaction(
HCONV hConv,
HANDLE hXact,
PCONV_INFO *ppcoi,
PXACT_INFO *ppxi)
{
    PCL_INSTANCE_INFO pcii;

    *ppcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
            HTYPE_CLIENT_CONVERSATION, HINST_ANY);
    if (*ppcoi == NULL) {
        *ppcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
                HTYPE_SERVER_CONVERSATION, HINST_ANY);
    }
    if (*ppcoi == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        return (FALSE);
    }
    pcii = ValidateInstance((*ppcoi)->pcii->hInstClient);
    if (pcii != (*ppcoi)->pcii) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        return (FALSE);
    }

    if (hXact == (HANDLE)IntToPtr( QID_SYNC )) {
        *ppxi = NULL;
    } else {
        *ppxi = (PXACT_INFO)ValidateCHandle(hXact, HTYPE_TRANSACTION,
                InstFromHandle((*ppcoi)->pcii->hInstClient));
        if (*ppxi == NULL) {
            SetLastDDEMLError((*ppcoi)->pcii, DMLERR_INVALIDPARAMETER);
            return (FALSE);
        }
    }
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\ctxtinfo.c ===
/**************************************************************************\
* Module Name: ctxtinfo.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Get/set routines of various Input context information for imm32.dll
*
* History:
* 26-Feb-1996 wkwok
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// Helper function:
// Converts RECONVERTSTRING structure between ANSI and UNICODE.
extern DWORD ImmReconversionWorker(LPRECONVERTSTRING lpRecTo, LPRECONVERTSTRING lpRecFrom, BOOL bToAnsi, DWORD dwCodePage);


int UnicodeToMultiByteSize(DWORD dwCodePage, LPCWSTR pwstr)
{
    char dummy[2], *lpszDummy = dummy;
    return WCSToMBEx((WORD)dwCodePage, pwstr, 1, &lpszDummy, sizeof(WCHAR), FALSE);
}


/***************************************************************************\
* ImmGetCompositionStringA
*
* Query composition string information specified by dwIndex.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

LONG WINAPI ImmGetCompositionStringA(
    HIMC   hImc,
    DWORD  dwIndex,
    LPVOID lpBuf,
    DWORD  dwBufLen)
{
    PCLIENTIMC     pClientImc;
    PINPUTCONTEXT  pInputContext;
    PCOMPOSITIONSTRING pCompStr;
    BOOL           fAnsi;
    LONG           lRet = 0;
    DWORD          dwCodePage;

    if (dwBufLen != 0 && lpBuf == NULL) {
        RIPMSG0(RIP_WARNING, "ImmGetCompositionStringW: NULL lpBuf.");
        return lRet;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmGetCompositionStringA: Invalid hImc %lx.", hImc);
        return lRet;
    }

    fAnsi = !TestICF(pClientImc, IMCF_UNICODE);
    dwCodePage = CImcCodePage(pClientImc);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionStringA: Lock hImc %lx failed.", hImc);
        return lRet;
    }

    pCompStr = (PCOMPOSITIONSTRING)ImmLockIMCC(pInputContext->hCompStr);
    if (pCompStr == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionStringA: Lock hCompStr %x failed",
              pInputContext->hCompStr);
        ImmUnlockIMC(hImc);
        return lRet;
    }

#if !defined(CUAS_ENABLE)
    lRet = InternalGetCompositionStringA(pCompStr, dwIndex,
                     lpBuf, dwBufLen, fAnsi, dwCodePage);
#else
    lRet = InternalGetCompositionStringA(hImc, pCompStr, dwIndex,
                     lpBuf, dwBufLen, fAnsi, dwCodePage);
#endif

    ImmUnlockIMCC(pInputContext->hCompStr);
    ImmUnlockIMC(hImc);

    return lRet;
}


/***************************************************************************\
* ImmGetCompositionStringA
*
* Query composition string information specified by dwIndex.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

LONG WINAPI ImmGetCompositionStringW(
    HIMC   hImc,
    DWORD  dwIndex,
    LPVOID lpBuf,
    DWORD  dwBufLen)
{
    PCLIENTIMC     pClientImc;
    PINPUTCONTEXT  pInputContext;
    PCOMPOSITIONSTRING pCompStr;
    BOOL           fAnsi;
    LONG           lRet = 0;
    DWORD          dwCodePage;

    if (dwBufLen != 0 && lpBuf == NULL) {
        RIPMSG0(RIP_WARNING, "ImmGetCompositionStringW: NULL lpBuf.");
        return lRet;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmGetCompositionStringW: Invalid hImc %lx.", hImc);
        return lRet;
    }

    fAnsi = !TestICF(pClientImc, IMCF_UNICODE);
    dwCodePage = CImcCodePage(pClientImc);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionStringW: Lock hImc %lx failed.", hImc);
        return lRet;
    }

    pCompStr = (PCOMPOSITIONSTRING)ImmLockIMCC(pInputContext->hCompStr);
    if (pCompStr == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionStringA: Lock hCompStr %x failed",
              pInputContext->hCompStr);
        ImmUnlockIMC(hImc);
        return lRet;
    }

#if !defined(CUAS_ENABLE)
    lRet = InternalGetCompositionStringW(pCompStr, dwIndex,
                     lpBuf, dwBufLen, fAnsi, dwCodePage);
#else
    lRet = InternalGetCompositionStringW(hImc, pCompStr, dwIndex,
                     lpBuf, dwBufLen, fAnsi, dwCodePage);
#endif

    ImmUnlockIMCC(pInputContext->hCompStr);
    ImmUnlockIMC(hImc);

    return lRet;
}


/***************************************************************************\
* ImmSetCompositionStringA
*
* Set composition string information specified by dwIndex.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmSetCompositionStringA(
    HIMC    hImc,
    DWORD   dwIndex,
    LPVOID lpComp,
    DWORD   dwCompLen,
    LPVOID lpRead,
    DWORD   dwReadLen)
{
    return ImmSetCompositionStringWorker(hImc, dwIndex, lpComp,
                                dwCompLen, lpRead, dwReadLen, TRUE);
}


/***************************************************************************\
* ImmSetCompositionStringW
*
* Set composition string information specified by dwIndex.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmSetCompositionStringW(
    HIMC    hImc,
    DWORD   dwIndex,
    LPVOID lpComp,
    DWORD   dwCompLen,
    LPVOID lpRead,
    DWORD   dwReadLen)
{
    return ImmSetCompositionStringWorker(hImc, dwIndex, lpComp,
                                dwCompLen, lpRead, dwReadLen, FALSE);
}


LONG CompositionString(
    HIMC               hImc,
    PINPUTCONTEXT      *ppInputContext,
    PCOMPOSITIONSTRING *ppCompStr,
    BOOL               fCheckSize)
{
    PINPUTCONTEXT      pInputContext;
    PCOMPOSITIONSTRING pCompStr;

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "CompositionString: Lock hImc %lx failed.", hImc);
        return (LONG)IMM_ERROR_GENERAL;
    }

    if (!pInputContext->hCompStr) {
        ImmUnlockIMC(hImc);
        return (LONG)IMM_ERROR_NODATA;
    }

    pCompStr = (PCOMPOSITIONSTRING)ImmLockIMCC(pInputContext->hCompStr);
    if (!pCompStr) {
        RIPMSG1(RIP_WARNING,
              "CompositionString: Lock hCompStr %lx failed.", pInputContext->hCompStr);
        ImmUnlockIMC(hImc);
        return (LONG)IMM_ERROR_GENERAL;
    }

    if (fCheckSize && pCompStr->dwSize < sizeof(COMPOSITIONSTRING)) {
        RIPMSG0(RIP_WARNING, "CompositionString: no composition string.");
        ImmUnlockIMCC(pInputContext->hCompStr);
        ImmUnlockIMC(hImc);
        return (LONG)IMM_ERROR_NODATA;
    }

    *ppInputContext = pInputContext;
    *ppCompStr = pCompStr;

    return (1);
}


BOOL CheckAttribute(
    LPBYTE  lpComp,        // the attr from apps
    DWORD   dwCompLen,     // the attr length from apps
    LPBYTE  lpAttr,        // the attr from IMC
    DWORD   dwAttrLen,     // the attr length from IMC
    LPDWORD lpClause,      // the clause from IMC
    DWORD   dwClauseLen)   // the clause length from IMC
{
    DWORD dwCnt;
    DWORD dwBound;
    BYTE bAttr;

    UNREFERENCED_PARAMETER(dwClauseLen);

    if (!lpClause) {
        RIPMSG0(RIP_WARNING, "CheckAttribute: no Clause. Pass it to IME.");
        return (TRUE);
    }

    if (!lpAttr) {
        RIPMSG0(RIP_WARNING, "CheckAttribute: no Attr. Not pass it to IME.");
        return (FALSE);
    }

    if (dwCompLen != dwAttrLen) {
        RIPMSG0(RIP_WARNING, "CheckAttribute: wrong length. Not pass it to IME.");
        return (FALSE);
    }

    /*
     * The attr. of chars of one clause have to be same.
     */
    while (*lpClause < dwCompLen) {
        dwBound = *(lpClause+1) - *lpClause;
        bAttr = *lpComp++;
        for (dwCnt = 1; dwCnt < dwBound; dwCnt++)
            if (bAttr != *lpComp++) {
                RIPMSG0(RIP_WARNING,
                      "CheckAttribute: mismatch clause att. Not Pass it to IME");
                return (FALSE);
            }
        lpClause++;
    }

    return (TRUE);
}


BOOL CheckClause(
    LPDWORD lpComp,        // the clause from apps
    DWORD   dwCompLen,     // the clause length from apps
    LPDWORD lpClause,      // the clause from IMC
    DWORD   dwClauseLen)   // the clause length from IMC
{
    UINT nCnt;
    INT  diff = 0;

    if (!dwClauseLen || !dwCompLen) {
        RIPMSG0(RIP_WARNING, "CheckClause: no Clause. Not Pass it to IME.");
        return (FALSE);
    }

    if (*lpComp || *lpClause) {
        RIPMSG0(RIP_WARNING, "CheckClause: lpClause[0] have to be ZERO.");
        return (FALSE);
    }

    for (nCnt = 0; nCnt < (UINT)(dwClauseLen/4); nCnt++)
    {
        if (*lpComp++ != *lpClause++)
        {
            diff++;
            if (dwCompLen > dwClauseLen)
                lpClause--;
            if (dwCompLen < dwClauseLen)
                lpComp--;
        }
        if (diff > 1)
            return (FALSE);
    }

    return (TRUE);
}


LPBYTE InternalSCS_SETSTR(
    LPCVOID  lpCompRead,
    DWORD    dwCompReadLen,
    LPVOID  *lplpNewCompRead,
    DWORD   *lpdwNewCompReadLen,
    BOOL     fAnsi,
    DWORD    dwCodePage)
{
    LPBYTE   lpBufRet;
    DWORD    dwBufSize;
    LPSTR    lpBufA;
    LPWSTR   lpBufW;
    INT      i;
    BOOL     bUDC;

    if (lpCompRead == NULL || dwCompReadLen == 0)
        return NULL;

    dwBufSize = dwCompReadLen * sizeof(WCHAR) * 2;

    lpBufRet = ImmLocalAlloc(0, dwBufSize);
    if (lpBufRet == NULL) {
        RIPMSG0(RIP_WARNING, "InternalSCS_SETSTR: memory failure.");
        return NULL;
    }

    lpBufW = (LPWSTR)lpBufRet;
    lpBufA = (LPSTR)(lpBufW + dwCompReadLen);

    if (fAnsi) {

        RtlCopyMemory(lpBufA, lpCompRead, dwCompReadLen);

        i = MultiByteToWideChar(dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpBufA,                  // src
                                (INT)dwCompReadLen,
                                (LPWSTR)lpBufW,                 // dest
                                (INT)dwCompReadLen);

        *lplpNewCompRead    = lpBufW;
        *lpdwNewCompReadLen = (DWORD)(i * sizeof(WCHAR));
    }
    else {

        RtlCopyMemory(lpBufW, lpCompRead, dwCompReadLen);

        i = WideCharToMultiByte(dwCodePage,
                                (DWORD)0,
                                lpBufW,                         // src
                                (INT)dwCompReadLen/sizeof(WCHAR),
                                (LPSTR)lpBufA,                  // dest
                                (INT)dwCompReadLen,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);

        *lplpNewCompRead    = lpBufA;
        *lpdwNewCompReadLen = (DWORD)(i * sizeof(CHAR));
    }

    return lpBufRet;
}


LPBYTE InternalSCS_CHANGEATTR(
    HIMC     hImc,
    LPCVOID  lpCompRead,
    DWORD    dwCompReadLen,
    DWORD    dwIndex,
    LPVOID  *lplpNewCompRead,
    DWORD   *lpdwNewCompReadLen,
    BOOL     fAnsi,
    DWORD    dwCodePage)
{
    LPBYTE lpBufRet;
    LPBYTE lpAttr, lpAttrA, lpAttrW;
    DWORD  dwBufLenA, dwBufLenW;
    LPSTR  lpStrBufA, lpBufA;
    LPWSTR lpStrBufW, lpBufW;
    CHAR   c;
    WCHAR  wc;
    ULONG  MultiByteSize;

    if (lpCompRead == NULL || dwCompReadLen == 0)
        return NULL;

    if (fAnsi) {

        dwBufLenA = ImmGetCompositionStringA(hImc, dwIndex, NULL, 0);

        lpStrBufA = ImmLocalAlloc(0, dwBufLenA);
        if (lpStrBufA == NULL) {
            RIPMSG0(RIP_WARNING, "InternalSCS_CHANGEATTR: memory failure.");
            return NULL;
        }

        ImmGetCompositionStringA(hImc, dwIndex, lpStrBufA, dwBufLenA);

        lpBufRet = ImmLocalAlloc(0, dwBufLenA);
        if (lpBufRet == NULL) {
            RIPMSG0(RIP_WARNING, "InternalSCS_CHANGEATTR: memory failure.");
            ImmLocalFree(lpStrBufA);
            return NULL;
        }

        lpBufA  = lpStrBufA;
        lpAttrA = (LPBYTE)lpCompRead;
        lpAttr  = lpBufRet;

        while (dwBufLenA != 0 && (c=*lpBufA++) != 0) {
            if (IsDBCSLeadByteEx(dwCodePage, c)) {
                if (dwBufLenA >= 2) {
                    *lpAttr++ = *lpAttrA++;
                    dwBufLenA--;
                } else {
                    *lpAttr++ = *lpAttrA;
                }
                lpBufA++;
            } else {
                *lpAttr++ = *lpAttrA;
            }
            lpAttrA++;
            dwBufLenA--;
        }

        ImmLocalFree(lpStrBufA);
    }
    else {

        dwBufLenW = ImmGetCompositionStringW(hImc, dwIndex, NULL, 0);

        lpStrBufW = ImmLocalAlloc(0, dwBufLenW);
        if (lpStrBufW == NULL) {
            RIPMSG0(RIP_WARNING, "InternalSCS_CHANGEATTR: memory failure.");
            return NULL;
        }

        ImmGetCompositionStringW(hImc, dwIndex, lpStrBufW, dwBufLenW);

        lpBufRet = ImmLocalAlloc(0, dwBufLenW);
        if (lpBufRet == NULL) {
            RIPMSG0(RIP_WARNING, "InternalSCS_CHANGEATTR: memory failure.");
            ImmLocalFree(lpStrBufW);
            return NULL;
        }

        lpBufW  = lpStrBufW;
        lpAttrW = (LPBYTE)lpCompRead;
        lpAttr  = lpBufRet;

        while (dwBufLenW != 0 && (wc=*lpBufW++) != L'\0') {
            MultiByteSize = UnicodeToMultiByteSize(dwCodePage, &wc);
            if (MultiByteSize == 2) {
                *lpAttr++ = *lpAttrW;
            }
            *lpAttr++ = *lpAttrW++;
            dwBufLenW -= sizeof(WCHAR);
        }

        ImmLocalFree(lpStrBufW);
    }

    *lplpNewCompRead    = lpBufRet;
    *lpdwNewCompReadLen = (DWORD)(lpAttr - (PBYTE)lpBufRet);

    return lpBufRet;
}


LPBYTE InternalSCS_CHANGECLAUSE(
    HIMC     hImc,
    LPCVOID  lpCompRead,
    DWORD    dwCompReadLen,
    DWORD    dwIndex,
    LPDWORD *lplpNewCompRead,
    DWORD   *lpdwNewCompReadLen,
    BOOL     fAnsi,
    DWORD    dwCodePage)
{
    LPDWORD lpdw, lpNewdw, lpBufRet;
    DWORD   dwBufLenA, dwBufLenW;
    LPSTR   lpStrBufA = NULL;
    LPWSTR  lpStrBufW = NULL;
    INT     i;

    if (lpCompRead == NULL || dwCompReadLen == 0)
        return NULL;

    lpdw = (LPDWORD)lpCompRead;

    lpBufRet = ImmLocalAlloc(0, dwCompReadLen);
    if (lpBufRet == NULL) {
        RIPMSG0(RIP_WARNING, "InternalSCS_CHANGECLAUSE: memory failure.");
        return NULL;
    }

    if (fAnsi) {

        dwBufLenA = ImmGetCompositionStringA(hImc, dwIndex, NULL, 0);

        lpStrBufA = ImmLocalAlloc(0, dwBufLenA);
        if (lpStrBufA == NULL) {
            RIPMSG0(RIP_WARNING, "InternalSCS_CHANGECLAUSE: memory failure.");
            ImmLocalFree(lpBufRet);
            return NULL;
        }

        ImmGetCompositionStringA(hImc, dwIndex, lpStrBufA, dwBufLenA);
    }
    else {

        dwBufLenW = ImmGetCompositionStringW(hImc, dwIndex, NULL, 0);

        lpStrBufW = ImmLocalAlloc(0, dwBufLenW);
        if (lpStrBufW == NULL) {
            RIPMSG0(RIP_WARNING, "InternalSCS_CHANGECLAUSE: memory failure.");
            ImmLocalFree(lpBufRet);
            return NULL;
        }

        ImmGetCompositionStringW(hImc, dwIndex, lpStrBufW, dwBufLenW);
    }

    *lplpNewCompRead = lpNewdw = lpBufRet;
    *lpdwNewCompReadLen = dwCompReadLen;

    for (i = 0; i < (INT)(dwCompReadLen / sizeof(DWORD)); i++) {
        *lpNewdw++ = fAnsi ? CalcCharacterPositionAtoW(*lpdw++, lpStrBufA, dwCodePage)
                           : CalcCharacterPositionWtoA(*lpdw++, lpStrBufW, dwCodePage);
    }

    if (lpStrBufA) {
        ImmLocalFree(lpStrBufA);
        UserAssert(lpStrBufW == NULL);
    } else {
        UserAssert(lpStrBufW);
        ImmLocalFree(lpStrBufW);
    }

    return (LPBYTE)lpBufRet;
}


LPBYTE InternalSCS_RECONVERTSTRING(
    LPRECONVERTSTRING  lpReconv,
    DWORD              dwReconvLen,
    LPRECONVERTSTRING *lplpNewReconv,
    DWORD             *lpdwNewReconvLen,
    BOOL               fAnsi,
    DWORD              dwCodePage)
{
    LPRECONVERTSTRING lpNewReconv;
    DWORD dwBufSize;

    if (lpReconv == NULL || dwReconvLen == 0)
        return NULL;

    if (fAnsi) {
        // AtoW
        dwBufSize = (lpReconv->dwSize - sizeof *lpReconv + 1) * sizeof(WCHAR) + sizeof *lpReconv;
    }
    else {
        dwBufSize = lpReconv->dwSize + sizeof(BYTE);
    }
    lpNewReconv = ImmLocalAlloc(0, dwBufSize);
    if (lpNewReconv == NULL) {
        RIPMSG0(RIP_WARNING, "InternalSCS_RECONVERTSTRING: memory failure.");
        return NULL;
    }

    lpNewReconv->dwVersion = 0;
    lpNewReconv->dwSize=  dwBufSize;

    lpNewReconv->dwSize = ImmReconversionWorker(lpNewReconv, lpReconv, !fAnsi, dwCodePage);
    if (lpNewReconv->dwSize == 0) {
        ImmLocalFree(lpNewReconv);
        return NULL;;
    }
    *lpdwNewReconvLen = lpNewReconv->dwSize;
    *lplpNewReconv = lpNewReconv;

    return (LPBYTE)lpNewReconv;
}


/***************************************************************************\
* ImmSetCompositionStringWorker
*
* Worker function of ImmSetCompositionStringA/ImmSetCompositionStringW
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL ImmSetCompositionStringWorker(
    HIMC    hImc,
    DWORD   dwIndex,
    LPVOID lpComp,
    DWORD   dwCompLen,
    LPVOID lpRead,
    DWORD   dwReadLen,
    BOOL    fAnsi)
{
    PINPUTCONTEXT      pInputContext;
    PCOMPOSITIONSTRING pCompStr;
    DWORD              dwThreadId;
    PIMEDPI            pImeDpi;
    LPBYTE             lpCompBuf, lpReadBuf;
    LPBYTE             lpNewComp = NULL, lpNewRead = NULL;
    DWORD              dwNewCompLen, dwNewReadLen;
    BOOL               fRet = FALSE;
    BOOL               fCheckSize = TRUE;
    BOOL               fNeedAWConversion;
    LPBYTE             lpOrgComp, lpOrgRead;
    DWORD              dwOrgCompLen, dwOrgReadLen;

    dwThreadId = GetInputContextThread(hImc);
    if (dwThreadId != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetCompositionString: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pImeDpi = ImmLockImeDpi(GetKeyboardLayout(dwThreadId));
    if (pImeDpi == NULL)
        return FALSE;

    lpCompBuf = lpReadBuf = NULL;

    // Backup original pointers to copyback for QUERY.
    lpOrgComp = lpComp;
    lpOrgRead = lpRead;
    dwOrgCompLen = dwCompLen;
    dwOrgReadLen = dwReadLen;

    /*
     * Check if we need ANSI/Unicode conversion
     */
    if (( fAnsi && !(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) ||
        (!fAnsi &&  (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE))) {
        /*
         * No A/W conversion needed.
         */
        fNeedAWConversion = FALSE;
        goto start_scs;
    }
    fNeedAWConversion = TRUE;

    switch (dwIndex) {
    case SCS_SETSTR:
        if ( lpComp &&
            (lpCompBuf = InternalSCS_SETSTR(lpComp, dwCompLen,
                                &lpNewComp, &dwNewCompLen, fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;
        if ( lpRead &&
            (lpReadBuf = InternalSCS_SETSTR(lpRead, dwReadLen,
                                &lpNewRead, &dwNewReadLen, fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;

        fCheckSize = FALSE;
        break;

    case SCS_CHANGEATTR:
        if ( lpComp &&
            (lpCompBuf = InternalSCS_CHANGEATTR(
                                hImc, lpComp, dwCompLen, GCS_COMPSTR,
                                &lpNewComp, &dwNewCompLen, fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;
        if ( lpRead &&
            (lpReadBuf = InternalSCS_CHANGEATTR(
                                hImc, lpRead, dwReadLen, GCS_COMPREADSTR,
                                &lpNewRead, &dwNewReadLen, fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;
        break;

    case SCS_CHANGECLAUSE:
       if ( lpComp &&
           (lpCompBuf = InternalSCS_CHANGECLAUSE(
                                hImc, lpComp, dwCompLen, GCS_COMPSTR,
                                (LPDWORD *)&lpNewComp, &dwNewCompLen, fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;
        if ( lpRead &&
            (lpReadBuf = InternalSCS_CHANGECLAUSE(
                                hImc, lpRead, dwReadLen, GCS_COMPREADSTR,
                                (LPDWORD *)&lpNewRead, &dwNewReadLen, fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;
        break;

    case SCS_SETRECONVERTSTRING:
    case SCS_QUERYRECONVERTSTRING:
        if (lpComp &&
            (lpCompBuf = InternalSCS_RECONVERTSTRING((LPRECONVERTSTRING)lpComp, dwCompLen,
                                (LPRECONVERTSTRING *)&lpNewComp, &dwNewCompLen,
                                fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;
        if (lpRead &&
            (lpReadBuf = InternalSCS_RECONVERTSTRING((LPRECONVERTSTRING)lpRead, dwReadLen,
                                (LPRECONVERTSTRING *)&lpNewRead, &dwNewReadLen,
                                fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;

        fCheckSize = FALSE;
        break;

    default:
        goto callime_scs;
    }

    if (lpCompBuf != NULL) {
        lpComp    = lpNewComp;
        dwCompLen = dwNewCompLen;
    }

    if (lpReadBuf != NULL) {
        lpRead    = lpNewRead;
        dwReadLen = dwNewReadLen;
    }

start_scs:

    if (CompositionString(hImc, &pInputContext, &pCompStr, fCheckSize) <= 0)
        goto callime_scs;

    switch (dwIndex)
    {
    case SCS_SETSTR:
        fRet = TRUE;
        break;

    case SCS_CHANGEATTR:
        if ( lpComp &&
            !CheckAttribute((LPBYTE)lpComp, dwCompLen,
                    (LPBYTE)((LPBYTE)pCompStr + pCompStr->dwCompAttrOffset),
                    pCompStr->dwCompAttrLen,
                    (LPDWORD)((LPBYTE)pCompStr + pCompStr->dwCompClauseOffset),
                    pCompStr->dwCompClauseLen)) break;

        if ( lpRead &&
            !CheckAttribute((LPBYTE)lpRead, dwReadLen,
                    (LPBYTE)((LPBYTE)pCompStr + pCompStr->dwCompReadAttrOffset),
                    pCompStr->dwCompReadAttrLen,
                    (LPDWORD)((LPBYTE)pCompStr + pCompStr->dwCompReadClauseOffset),
                    pCompStr->dwCompReadClauseLen)) break;
        fRet = TRUE;
        break;

    case SCS_CHANGECLAUSE:
        if ( lpComp &&
            !CheckClause((LPDWORD)lpComp, dwCompLen,
                         (LPDWORD)((LPBYTE)pCompStr + pCompStr->dwCompClauseOffset),
                         pCompStr->dwCompClauseLen)) break;
        if ( lpRead &&
            !CheckClause((LPDWORD)lpRead, dwReadLen,
                         (LPDWORD)((LPBYTE)pCompStr + pCompStr->dwCompReadClauseOffset),
                         pCompStr->dwCompReadClauseLen)) break;
        fRet = TRUE;
        break;

    case SCS_SETRECONVERTSTRING:
    case SCS_QUERYRECONVERTSTRING:
        if (pImeDpi->ImeInfo.fdwSCSCaps & SCS_CAP_SETRECONVERTSTRING) {
            fRet = TRUE;
        }
        break;

    default:
        break;
    }

    ImmUnlockIMCC(pInputContext->hCompStr);
    ImmUnlockIMC(hImc);

callime_scs:

    if (fRet) {
        fRet = (*pImeDpi->pfn.ImeSetCompositionString)(hImc, dwIndex,
                                    lpComp, dwCompLen, lpRead, dwReadLen);
    }

    /*
     * Check if we need ANSI/Unicode back conversion
     */
    if (fNeedAWConversion) {
        LPBYTE lpCompBufBack = NULL, lpReadBufBack = NULL;
        /*
         * A/W back conversion needed.
         */
        switch (dwIndex) {
        case SCS_QUERYRECONVERTSTRING:
            if (lpOrgComp &&
                (lpCompBufBack = InternalSCS_RECONVERTSTRING((LPRECONVERTSTRING)lpComp, dwCompLen,
                                    (LPRECONVERTSTRING *)&lpNewComp, &dwNewCompLen,
                                    !fAnsi, IMECodePage(pImeDpi)))) {
                if (dwOrgCompLen < dwNewCompLen) {
                    // lpOrgComp buffer length is too small.
                    fRet = FALSE;
                }
                else {
                    RtlCopyMemory(lpOrgComp, lpNewComp, dwNewCompLen);
                }
            }
            if (lpOrgRead &&
                (lpReadBufBack = InternalSCS_RECONVERTSTRING(
                                    (LPRECONVERTSTRING)lpRead, dwReadLen,
                                    (LPRECONVERTSTRING *)&lpNewRead, &dwNewReadLen,
                                    !fAnsi, IMECodePage(pImeDpi)))) {
                if (dwOrgReadLen < dwNewReadLen) {
                    // lpOrgRead buffer length is too small.
                    fRet = FALSE;
                }
                else {
                    RtlCopyMemory(lpOrgRead, lpNewRead, dwNewReadLen);
                }
            }
        }
        if (lpCompBufBack != NULL)
            LocalFree(lpCompBufBack);
        if (lpReadBufBack != NULL)
            LocalFree(lpReadBufBack);
    }

    if (lpCompBuf != NULL)
        ImmLocalFree(lpCompBuf);
    if (lpReadBuf != NULL)
        ImmLocalFree(lpReadBuf);

    ImmUnlockImeDpi(pImeDpi);

    return fRet;
}


/***************************************************************************\
* ImmGetCandidateListCountA
*
* Query the byte count and list count to receive all candidate list.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetCandidateListCountA(
    HIMC    hImc,
    LPDWORD lpdwListCount)      // the buffer pointer for list count
{
    return ImmGetCandidateListCountWorker(hImc, lpdwListCount, TRUE);
}


/***************************************************************************\
* ImmGetCandidateListCountW
*
* Query the byte count and list count to receive all candidate list.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetCandidateListCountW(
    HIMC    hImc,
    LPDWORD lpdwListCount)      // the buffer pointer for list count
{
    return ImmGetCandidateListCountWorker(hImc, lpdwListCount, FALSE);
}


/***************************************************************************\
* ImmGetCandidateListCountWorker
*
* Worker function of ImmGetCandidateListCountA/ImmGetCandidateListCountW.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD ImmGetCandidateListCountWorker(
    HIMC    hImc,
    LPDWORD lpdwListCount,
    BOOL    fAnsi)
{
    PCLIENTIMC      pClientImc;
    PINPUTCONTEXT   pInputContext;
    LPCANDIDATEINFO lpCandInfo;
    DWORD           dwRet = 0;
    INT             i;
    DWORD           dwCodePage;

    if (lpdwListCount) {
        *lpdwListCount = 0;
    } else {
        RIPMSG0(RIP_WARNING, "ImmGetCandidateListCount: NULL lpdwListCount.");
        return dwRet;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCandidateListCount: Invalid hImc %lx.", hImc);
        goto GetCandListCntExit;
    }
    dwCodePage = CImcCodePage(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCandidateListCount: Lock hImc %lx failed.", hImc);
        goto GetCandListCntUnlockClientImc;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(pInputContext->hCandInfo);
    if (!lpCandInfo) {
        RIPMSG1(RIP_WARNING,
              "ImmGetCandidateListCount: Lock hCandInfo %x failed.",
              pInputContext->hCandInfo);
        goto GetCandListCntUnlockIMC;
    }

    if (lpCandInfo->dwSize < sizeof(CANDIDATEINFO)) {
        RIPMSG0(RIP_WARNING, "ImmGetCandidateListCount: no candidate list.");
        goto GetCandListCntUnlockIMC;
    }

    *lpdwListCount = lpCandInfo->dwCount;

    if (fAnsi && TestICF(pClientImc, IMCF_UNICODE)) {
        LPCANDIDATELIST lpCandListW;

        dwRet = DWORD_ALIGN(sizeof(CANDIDATEINFO))
              + DWORD_ALIGN(lpCandInfo->dwPrivateSize);

        for (i = 0; i < (INT)lpCandInfo->dwCount; i++) {
            lpCandListW = (LPCANDIDATELIST)((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[i]);
            dwRet += InternalGetCandidateListWtoA(lpCandListW, NULL, 0, dwCodePage);
        }
    }
    else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE)) {
        LPCANDIDATELIST lpCandListA;

        dwRet = DWORD_ALIGN(sizeof(CANDIDATEINFO))
              + DWORD_ALIGN(lpCandInfo->dwPrivateSize);

        for (i = 0; i < (INT)lpCandInfo->dwCount; i++) {
            lpCandListA = (LPCANDIDATELIST)((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[i]);
            dwRet += InternalGetCandidateListAtoW(lpCandListA, NULL, 0, dwCodePage);
        }
    }
    else {
        dwRet = lpCandInfo->dwSize;
    }

    ImmUnlockIMCC(pInputContext->hCandInfo);

GetCandListCntUnlockIMC:
    ImmUnlockIMC(hImc);

GetCandListCntUnlockClientImc:
    ImmUnlockClientImc(pClientImc);

GetCandListCntExit:
    return dwRet;
}


/***************************************************************************\
* ImmGetCandidateListA
*
* Gets the candidate list information specified by dwIndex.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetCandidateListA(
    HIMC            hImc,
    DWORD           dwIndex,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen)
{
    return ImmGetCandidateListWorker(hImc, dwIndex,
                                     lpCandList, dwBufLen, TRUE);
}


/***************************************************************************\
* ImmGetCandidateListW
*
* Gets the candidate list information specified by dwIndex.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetCandidateListW(
    HIMC            hImc,
    DWORD           dwIndex,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen)
{
    return ImmGetCandidateListWorker(hImc, dwIndex,
                                     lpCandList, dwBufLen, FALSE);
}


/***************************************************************************\
* ImmGetCandidateListWorker
*
* Worker function of ImmGetCandidateListA/ImmGetCandidateListW.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD ImmGetCandidateListWorker(
    HIMC            hImc,
    DWORD           dwIndex,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen,
    BOOL            fAnsi)
{
    PCLIENTIMC      pClientImc;
    PINPUTCONTEXT   pInputContext;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandListTemp;
    DWORD           dwBufLenTemp;
    DWORD           dwRet = 0;
    DWORD           dwCodePage;

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCandidateList: Invalid hImc %lx.", hImc);
        goto GetCandListExit;

    }

    dwCodePage = CImcCodePage(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCandidateList: Lock hImc %lx failed.", hImc);
        goto GetCandListUnlockClientImc;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(pInputContext->hCandInfo);
    if (!lpCandInfo) {
        RIPMSG1(RIP_WARNING, "ImmGetCandidateList: Lock hCandInfo %x failed",
              pInputContext->hCandInfo);
        goto GetCandListUnlockIMC;
    }

    if (lpCandInfo->dwSize < sizeof(CANDIDATEINFO)) {
        RIPMSG0(RIP_WARNING, "ImmGetCandidateList: no candidate list.");
        goto GetCandListUnlockIMCC;
    }

    /*
     * invalid access
     */
    if (dwIndex >= lpCandInfo->dwCount) {
        RIPMSG0(RIP_WARNING, "ImmGetCandidateList: dwIndex >= lpCandInfo->dwCount.");
        goto GetCandListUnlockIMCC;
    }

    lpCandListTemp = (LPCANDIDATELIST)((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[dwIndex]);

    if (fAnsi && TestICF(pClientImc, IMCF_UNICODE)) {
        /*
         * ANSI Caller with an Unicode hImc.
         */
        dwBufLenTemp = InternalGetCandidateListWtoA(lpCandListTemp, NULL, 0, dwCodePage);
    }
    else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE)) {
        /*
         * Unicode Caller with an ANSI hImc.
         */
        dwBufLenTemp = InternalGetCandidateListAtoW(lpCandListTemp, NULL, 0, dwCodePage);
    }
    else {
        /*
         * No conversion required.
         */
        dwBufLenTemp = lpCandListTemp->dwSize;
    }

    /*
     * Query buffer size or early exit on error
     */
    if (dwBufLen == 0 || dwBufLenTemp == 0) {
        dwRet = dwBufLenTemp;
    }
    else if (!lpCandList) {
        RIPMSG0(RIP_WARNING, "ImmGetCandidateList: Null lpCandList.");
    }
    else if (dwBufLen < dwBufLenTemp) {
        RIPMSG2(RIP_WARNING, "ImmGetCandidateList: dwBufLen = %d too small, require = %d.",
              dwBufLen, dwBufLenTemp);
    } else {
        if (fAnsi && TestICF(pClientImc, IMCF_UNICODE)) {
            dwRet = InternalGetCandidateListWtoA(lpCandListTemp, lpCandList, dwBufLenTemp, dwCodePage);
        }
        else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE)) {
            dwRet = InternalGetCandidateListAtoW(lpCandListTemp, lpCandList, dwBufLenTemp, dwCodePage);
        }
        else {
            RtlCopyMemory((LPBYTE)lpCandList, (LPBYTE)lpCandListTemp, dwBufLenTemp);
            dwRet = dwBufLenTemp;
        }
    }

GetCandListUnlockIMCC:
    ImmUnlockIMCC(pInputContext->hCandInfo);

GetCandListUnlockIMC:
    ImmUnlockIMC(hImc);

GetCandListUnlockClientImc:
    ImmUnlockClientImc(pClientImc);

GetCandListExit:
    return dwRet;
}


/***************************************************************************\
* ImmGetGuideLineA
*
* Gets the guide line information reported by the IME.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetGuideLineA(
    HIMC    hImc,
    DWORD   dwIndex,
    LPSTR   lpszBuf,
    DWORD   dwBufLen)
{
    return ImmGetGuideLineWorker(hImc, dwIndex,
                                 (LPBYTE)lpszBuf, dwBufLen, TRUE);
}


/***************************************************************************\
* ImmGetGuideLineW
*
* Gets the guide line information reported by the IME.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetGuideLineW(
    HIMC    hImc,
    DWORD   dwIndex,
    LPWSTR  lpwszBuf,
    DWORD   dwBufLen)
{
    return ImmGetGuideLineWorker(hImc, dwIndex,
                                 (LPBYTE)lpwszBuf, dwBufLen, FALSE);
}


/***************************************************************************\
* ImmGetGuideLineWorker
*
* Worker function of ImmGetGuideLineA/ImmGetGuideLineW.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD ImmGetGuideLineWorker(
    HIMC    hImc,
    DWORD   dwIndex,
    LPBYTE  lpBuf,
    DWORD   dwBufLen,
    BOOL    fAnsi)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    LPGUIDELINE   lpGuideLine;
    LPBYTE        lpBufTemp;
    DWORD         dwRet = 0;
    DWORD         dwBufLenNeeded;
    BOOL          bUDC;
    DWORD         dwCodePage;

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetGuideLine: Invalid hImc %lx.", hImc);
        goto GetGuideLineExit;
    }
    dwCodePage = CImcCodePage(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetGuideLine: Lock hImc %lx failed.", hImc);
        goto GetGuideLineUnlockClientImc;
    }

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(pInputContext->hGuideLine);
    if (!lpGuideLine) {
        RIPMSG1(RIP_WARNING, "ImmGetGuideLine: Lock hGuideLine %lx failed.",
              pInputContext->hGuideLine);
        goto GetGuideLineUnlockIMC;
    }

    switch (dwIndex) {
    case GGL_LEVEL:
        dwRet = lpGuideLine->dwLevel;
        break;

    case GGL_INDEX:
        dwRet = lpGuideLine->dwIndex;
        break;

    case GGL_STRING:

        lpBufTemp = (LPBYTE)lpGuideLine + lpGuideLine->dwStrOffset;

        /*
         * Calculate the required buffer length.
         */
        if (fAnsi && TestICF(pClientImc, IMCF_UNICODE)) {
            dwBufLenNeeded = WideCharToMultiByte(dwCodePage,
                                                 (DWORD)0,
                                                 (LPWSTR)lpBufTemp,
                                                 (INT)lpGuideLine->dwStrLen,
                                                 (LPSTR)NULL,
                                                 (INT)0,
                                                 (LPSTR)NULL,
                                                 (LPBOOL)&bUDC);
        }
        else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE)) {
            dwBufLenNeeded = MultiByteToWideChar(dwCodePage,
                                                 (DWORD)MB_PRECOMPOSED,
                                                 (LPSTR)lpBufTemp,
                                                 (INT)lpGuideLine->dwStrLen,
                                                 (LPWSTR)NULL,
                                                 (INT)0);
            dwBufLenNeeded *= sizeof(WCHAR);
        }
        else {
            dwBufLenNeeded = lpGuideLine->dwStrLen;
            /*
             * The dwStrLen records the strlen and not the byte count.
             */
            if (TestICF(pClientImc, IMCF_UNICODE))
                dwBufLenNeeded *= sizeof(WCHAR);
        }

        /*
         * Query GuideLine string size only or early exit on error
         */
        if (dwBufLen == 0 || dwBufLenNeeded == 0) {
            dwRet = dwBufLenNeeded;
            goto GetGuideLineUnlockIMCC;
        }

        if (lpBuf == NULL || dwBufLen < dwBufLenNeeded)
            goto GetGuideLineUnlockIMCC;

        if (fAnsi && TestICF(pClientImc, IMCF_UNICODE)) {
            dwRet = WideCharToMultiByte(dwCodePage,
                                        (DWORD)0,
                                        (LPWSTR)lpBufTemp,
                                        (INT)lpGuideLine->dwStrLen,
                                        (LPSTR)lpBuf,
                                        (INT)dwBufLen,
                                        (LPSTR)NULL,
                                        (LPBOOL)&bUDC);
        }
        else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE)) {
            dwRet = MultiByteToWideChar(dwCodePage,
                                        (DWORD)MB_PRECOMPOSED,
                                        (LPSTR)lpBufTemp,
                                        (INT)lpGuideLine->dwStrLen,
                                        (LPWSTR)lpBuf,
                                        (INT)dwBufLen/sizeof(WCHAR));
            dwRet *= sizeof(WCHAR);
        }
        else {
            RtlCopyMemory(lpBuf, lpBufTemp, dwBufLenNeeded);
            dwRet = dwBufLenNeeded;
        }

        break;

    case GGL_PRIVATE:

        lpBufTemp = (LPBYTE)lpGuideLine + lpGuideLine->dwPrivateOffset;

        /*
         * The dwPrivateOffset is an offset to a CANDIDATELIST when
         * lpGuideLine->dwIndex == GL_ID_REVERSECONVERSION. Do conversion
         * for this case only.
         */
        if (fAnsi && TestICF(pClientImc, IMCF_UNICODE) &&
                lpGuideLine->dwIndex == GL_ID_REVERSECONVERSION) {
            dwBufLenNeeded = InternalGetCandidateListWtoA(
                        (LPCANDIDATELIST)lpBufTemp, (LPCANDIDATELIST)NULL, 0, dwCodePage);
        }
        else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE) &&
                lpGuideLine->dwIndex == GL_ID_REVERSECONVERSION) {
            dwBufLenNeeded = InternalGetCandidateListAtoW(
                        (LPCANDIDATELIST)lpBufTemp, (LPCANDIDATELIST)NULL, 0, dwCodePage);
        }
        else {
            dwBufLenNeeded = lpGuideLine->dwPrivateSize;
        }

        /*
         * Query dwPrivateSize size only or early exit on error
         */
        if (dwBufLen == 0 || dwBufLenNeeded == 0) {
            dwRet = dwBufLenNeeded;
            goto GetGuideLineUnlockIMCC;
        }

        if (lpBuf == NULL || dwBufLen < dwBufLenNeeded)
            goto GetGuideLineUnlockIMCC;

        if (fAnsi && TestICF(pClientImc, IMCF_UNICODE) &&
                lpGuideLine->dwIndex == GL_ID_REVERSECONVERSION) {
            dwRet = InternalGetCandidateListWtoA(
                    (LPCANDIDATELIST)lpBufTemp, (LPCANDIDATELIST)lpBuf, dwBufLenNeeded, dwCodePage);
        }
        else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE) &&
                lpGuideLine->dwIndex == GL_ID_REVERSECONVERSION) {
            dwRet = InternalGetCandidateListAtoW(
                    (LPCANDIDATELIST)lpBufTemp, (LPCANDIDATELIST)lpBuf, dwBufLenNeeded, dwCodePage);
        }
        else {
            RtlCopyMemory(lpBuf, lpBufTemp, dwBufLenNeeded);
            dwRet = dwBufLenNeeded;
        }

        break;

    default:
        break;
    }

GetGuideLineUnlockIMCC:
    ImmUnlockIMCC(pInputContext->hGuideLine);

GetGuideLineUnlockIMC:
    ImmUnlockIMC(hImc);

GetGuideLineUnlockClientImc:
    ImmUnlockClientImc(pClientImc);

GetGuideLineExit:
    return dwRet;
}


/***************************************************************************\
* ImmGetConversionStatus
*
* Gets current conversion status.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetConversionStatus(     // Get the conversion status
    HIMC    hImc,
    LPDWORD lpfdwConversion,
    LPDWORD lpfdwSentence)
{
    PINPUTCONTEXT pInputContext;

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetConversionStatus: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    if (lpfdwConversion != NULL)
        *lpfdwConversion = pInputContext->fdwConversion;

    if (lpfdwSentence != NULL)
        *lpfdwSentence = pInputContext->fdwSentence;

    ImmUnlockIMC(hImc);

    return TRUE;
}


/***************************************************************************\
* ImmSetConversionStatus
*
* Sets current conversion status.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmSetConversionStatus(
    HIMC  hImc,
    DWORD fdwConversion,
    DWORD fdwSentence)
{
    PINPUTCONTEXT pInputContext;
    DWORD         fdwOldConversion;
    DWORD         fdwOldSentence;
    BOOL          fConvModeChg;
    BOOL          fSentenceChg;
    HWND          hWnd;
    DWORD         dwOpenStatus;
    DWORD         dwConversion;

#if defined(CUAS_ENABLE)
    BOOL          fMakeNotifyAlways = FALSE;
    HKL           hKL = GetKeyboardLayout(0);
    if (!IS_IME_KBDLAYOUT(hKL) && IS_CICERO_ENABLED_AND_NOT16BIT())
        fMakeNotifyAlways = TRUE;
#endif

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetConversionStatus: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmSetConversionStatus: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    fConvModeChg = FALSE;
    fSentenceChg = FALSE;

    if (pInputContext->fdwConversion != fdwConversion) {
        if ((fdwConversion & IME_CMODE_LANGUAGE) == IME_CMODE_KATAKANA) {
            RIPMSG0(RIP_WARNING, "ImmSetConversionStatus: wrong fdwConversion");
        }
        fdwOldConversion = pInputContext->fdwConversion;
        pInputContext->fdwConversion = fdwConversion;
        fConvModeChg = TRUE;
    }

    if (pInputContext->fdwSentence != fdwSentence) {
        fdwOldSentence = pInputContext->fdwSentence;
        pInputContext->fdwSentence = fdwSentence;
        fSentenceChg = TRUE;
    }

    hWnd = pInputContext->hWnd;
    if ( fConvModeChg ) {

        dwOpenStatus = (DWORD)pInputContext->fOpen;
        dwConversion = pInputContext->fdwConversion;
    }

    ImmUnlockIMC(hImc);

#ifdef LATER
    // Do uNumLangVKey and uNumVKey checking later.
#endif

    /*
     * inform IME and UI about the conversion mode changes.
     */
#if !defined(CUAS_ENABLE)
    if (fConvModeChg) 
#else
    if (fConvModeChg || fMakeNotifyAlways) 
#endif
    {
        MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, fdwOldConversion,
                IMC_SETCONVERSIONMODE, IMN_SETCONVERSIONMODE, 0L);

        /*
         * notify shell and keyboard the conversion mode change
         */
#if defined(CUAS_ENABLE)
        if (fConvModeChg) 
#endif
            NtUserNotifyIMEStatus( hWnd, dwOpenStatus, dwConversion );
    }

    /*
     * inform IME and UI about the sentence mode changes.
     */
#if !defined(CUAS_ENABLE)
    if (fSentenceChg) 
#else
    if (fSentenceChg || fMakeNotifyAlways) 
#endif
    {
        MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, fdwOldSentence,
                IMC_SETSENTENCEMODE, IMN_SETSENTENCEMODE, 0L);
    }

    return TRUE;
}


/***************************************************************************\
* ImmGetOpenStatus
*
* Gets the open or close status of the IME.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetOpenStatus(
    HIMC hImc)
{
    PINPUTCONTEXT pInputContext;
    BOOL          fOpen;

    if (hImc == NULL_HIMC)
        return FALSE;

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGetOpenStatus: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    fOpen = pInputContext->fOpen;
    ImmUnlockIMC(hImc);

    return (fOpen);
}


/***************************************************************************\
* ImmSetOpenStatus
*
* Opens or closes the IME.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmSetOpenStatus(
    HIMC hImc,
    BOOL fOpen)
{
    PINPUTCONTEXT pInputContext;
    HWND          hWnd;
    DWORD         dwOpenStatus;
    DWORD         dwConversion;
    BOOL          fOpenChg = FALSE;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetOpenStatus: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmSetOpenStatus: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    if (pInputContext->fOpen != fOpen) {
        fOpenChg = TRUE;
        pInputContext->fOpen = fOpen;
    }

    if ( fOpenChg ) {
        hWnd = (HWND)pInputContext->hWnd;
        dwOpenStatus = (DWORD)pInputContext->fOpen;
        dwConversion = (DWORD)pInputContext->fdwConversion;
    }

    ImmUnlockIMC(hImc);

    /*
     * inform IME and UI about the conversion mode changes.
     */
    if (fOpenChg) {
        MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, (DWORD)0,
                IMC_SETOPENSTATUS, IMN_SETOPENSTATUS, 0L);

        NtUserNotifyIMEStatus( hWnd, dwOpenStatus, dwConversion );
    }

    return TRUE;
}


/***************************************************************************\
* ImmGetCompositionFontA
*
* Opens or closes the IME.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetCompositionFontA(
    HIMC       hImc,
    LPLOGFONTA lpLogFontA)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    LOGFONTW      LogFontW;
    BOOL          fUnicode, fRet;

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionFontA: Invalid hImc %lx.", hImc);
        return FALSE;
    }

    fUnicode = TestICF(pClientImc, IMCF_UNICODE);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionFontA: Lock hImc %lx failed.", hImc);
        return FALSE;
    }

    if (fUnicode) {

        ImmUnlockIMC(hImc);

        if (ImmGetCompositionFontW(hImc, &LogFontW)) {
            LFontWtoLFontA(&LogFontW, lpLogFontA);
            return (TRUE);
        }

        return FALSE;
    }

    if ((pInputContext->fdwInit & INIT_LOGFONT) == INIT_LOGFONT) {
        *lpLogFontA = pInputContext->lfFont.A;
        fRet = TRUE;
    }
    else {
        fRet = FALSE;
    }

    ImmUnlockIMC(hImc);

    return fRet;
}


/***************************************************************************\
* ImmGetCompositionFontW
*
* Opens or closes the IME.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetCompositionFontW(
    HIMC       hImc,
    LPLOGFONTW lpLogFontW)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    LOGFONTA      LogFontA;
    BOOL          fUnicode, fRet;

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionFontW: Invalid hImc %lx.", hImc);
        return FALSE;
    }

    fUnicode = TestICF(pClientImc, IMCF_UNICODE);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionFontW: Lock hImc %lx failed.", hImc);
        return (FALSE);
    }

    if (!fUnicode) {

        ImmUnlockIMC(hImc);

        if (ImmGetCompositionFontA(hImc, &LogFontA)) {
            LFontAtoLFontW(&LogFontA, lpLogFontW);
            return (TRUE);
        }

        return FALSE;
    }

    if ((pInputContext->fdwInit & INIT_LOGFONT) == INIT_LOGFONT) {
        *lpLogFontW = pInputContext->lfFont.W;
        fRet = TRUE;
    }
    else {
        fRet = FALSE;
    }

    ImmUnlockIMC(hImc);

    return fRet;
}


BOOL WINAPI ImmSetCompositionFontA(
    HIMC       hImc,
    LPLOGFONTA lpLogFontA)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    LOGFONTW      LogFontW;
    HWND          hWnd;
    BOOL          fUnicode;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetCompositionFontA: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmSetCompositionFontA: Invalid hImc %lx.", hImc);
        return FALSE;
    }

    fUnicode = TestICF(pClientImc, IMCF_UNICODE);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmSetCompositionFontA: Lock hImc %lx failed.", hImc);
        return (FALSE);
    }

    if (fUnicode) {

        ImmUnlockIMC(hImc);

        LFontAtoLFontW(lpLogFontA, &LogFontW);

        return ImmSetCompositionFontW(hImc, &LogFontW);
    }

    /*
     * Japanese 3.x applications need to receive 3.x compatible notification message.
     *
     */
    if ( (GetClientInfo()->dwExpWinVer < VER40) &&
         (PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) == LANG_JAPANESE)   &&
         ! (pInputContext->fdw31Compat & F31COMPAT_MCWHIDDEN) &&
         (pInputContext->cfCompForm.dwStyle != CFS_DEFAULT) ) {

        PostMessageA( pInputContext->hWnd, WM_IME_REPORT, IR_CHANGECONVERT, (LPARAM)NULL);
    }

    pInputContext->lfFont.A = *lpLogFontA;
    pInputContext->fdwInit |= INIT_LOGFONT;
    hWnd = pInputContext->hWnd;

    ImmUnlockIMC(hImc);

    /*
     * inform IME and UI about the change of composition font.
     */
    MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, 0L,
            IMC_SETCOMPOSITIONFONT, IMN_SETCOMPOSITIONFONT, 0L);


    return TRUE;
}


BOOL WINAPI ImmSetCompositionFontW(
    HIMC       hImc,
    LPLOGFONTW lpLogFontW)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    LOGFONTA      LogFontA;
    HWND          hWnd;
    BOOL          fUnicode;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetCompositionFontW: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmSetCompositionFontW: Invalid hImc %lx.", hImc);
        return (FALSE);
    }

    fUnicode = TestICF(pClientImc, IMCF_UNICODE);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmSetCompositionFontW: Lock hImc %lx failed.", hImc);
        return (FALSE);
    }

    if (!fUnicode) {

        ImmUnlockIMC(hImc);

        LFontWtoLFontA(lpLogFontW, &LogFontA);

        return ImmSetCompositionFontA(hImc, &LogFontA);
    }

    /*
     * Japanese 3.x applications need to receive 3.x compatible notification message.
     *
     */
    if ( (GetClientInfo()->dwExpWinVer < VER40) &&
         (PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) == LANG_JAPANESE)   &&
         ! (pInputContext->fdw31Compat & F31COMPAT_MCWHIDDEN) &&
         (pInputContext->cfCompForm.dwStyle != CFS_DEFAULT) ) {

        PostMessageW( pInputContext->hWnd, WM_IME_REPORT, IR_CHANGECONVERT, (LPARAM)NULL);
    }
    pInputContext->lfFont.W = *lpLogFontW;
    pInputContext->fdwInit |= INIT_LOGFONT;
    hWnd = pInputContext->hWnd;

    ImmUnlockIMC(hImc);

    /*
     * inform IME and UI about the change of composition font.
     */
    MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, 0L,
            IMC_SETCOMPOSITIONFONT, IMN_SETCOMPOSITIONFONT, 0L);

    return TRUE;
}


/***************************************************************************\
* ImmGetConversionListA
*
* Obtains the list of FE character or word from one character or word.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetConversionListA(
    HKL             hKL,
    HIMC            hImc,
    LPCSTR          lpszSrc,
    LPCANDIDATELIST lpCandListA,
    DWORD           dwBufLen,
    UINT            uFlag)
{
    PIMEDPI pImeDpi;
    DWORD   dwRet;
    LPWSTR  lpwszSrc;
    DWORD   dwBufTemp;
    LPCANDIDATELIST lpCandListW;
    INT     i;
    DWORD   dwCodePage;

    pImeDpi = FindOrLoadImeDpi(hKL);

    if (pImeDpi == NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmGetConversionListA: cannot find DPI entry for hkl=%lx", hKL);
        return (0);
    }

    dwCodePage = IMECodePage(pImeDpi);

    if (!(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
        /*
         * This is an ANSI call to an ANSI IME.
         */
        dwRet = (*pImeDpi->pfn.ImeConversionList.a)(hImc, lpszSrc,
                                        lpCandListA, dwBufLen, uFlag);
        ImmUnlockImeDpi(pImeDpi);
        return dwRet;
    }

    ImmUnlockImeDpi(pImeDpi);

    /*
     * This is an ANSI call to an Unicode IME.
     */
    if (lpszSrc != NULL) {

        dwBufTemp = (strlen(lpszSrc) + 1) * sizeof(WCHAR);

        lpwszSrc = ImmLocalAlloc(0, dwBufTemp);
        if (lpwszSrc == NULL)
            return (0);

        i = MultiByteToWideChar(dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszSrc,              // src
                                (INT)strlen(lpszSrc),
                                (LPWSTR)lpwszSrc,            // dest
                                (INT)dwBufTemp/sizeof(WCHAR));

        lpwszSrc[i] = '\0';
    }
    else {
        lpwszSrc = NULL;
    }

    /*
     * Query the CandidateListW size required.
     */
    dwBufTemp = ImmGetConversionListW(hKL, hImc, lpwszSrc, NULL, 0, uFlag);

    if (dwBufTemp == 0 || (lpCandListW = ImmLocalAlloc(0, dwBufTemp)) == NULL) {
        if (lpwszSrc)
            ImmLocalFree(lpwszSrc);
        return (0);
    }

    /*
     * Now get the actual CandidateListW.
     */
    dwBufTemp = ImmGetConversionListW(hKL, hImc, lpwszSrc,
                                        lpCandListW, dwBufTemp, uFlag);

    /*
     * Query the CandidateListA size required.
     */
    if (dwBufTemp != 0) {
        dwBufTemp = InternalGetCandidateListWtoA(lpCandListW, NULL, 0, dwCodePage);
    }

    if (dwBufLen == 0 || dwBufTemp == 0) {
        /*
         * Query required buffer size or error has happened.
         */
        dwRet = dwBufTemp;
    }
    else if (dwBufLen < dwBufTemp) {
        /*
         * Not enough buffer area.
         */
        dwRet = 0;
    }
    else {
        /*
         * Get the actual CandidateListA
         */
        dwRet = InternalGetCandidateListWtoA(lpCandListW, lpCandListA, dwBufLen, dwCodePage);
    }

    if (lpwszSrc)
        ImmLocalFree(lpwszSrc);
    ImmLocalFree(lpCandListW);

    return dwRet;

}


/***************************************************************************\
* ImmGetConversionListW
*
* Obtains the list of FE character or word from one character or word.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetConversionListW(
    HKL             hKL,
    HIMC            hImc,
    LPCWSTR         lpwszSrc,
    LPCANDIDATELIST lpCandListW,
    DWORD           dwBufLen,
    UINT            uFlag)
{
    PIMEDPI pImeDpi;
    DWORD   dwRet;
    LPSTR   lpszSrc;
    DWORD   dwBufTemp;
    LPCANDIDATELIST lpCandListA;
    BOOL    bUDC;
    INT     i;
    DWORD   dwCodePage;

    pImeDpi = FindOrLoadImeDpi(hKL);

    if (pImeDpi == NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmGetConversionListW: cannot find DPI entry for hkl=%lx", hKL);
        return (0);
    }

    dwCodePage = IMECodePage(pImeDpi);

    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        /*
         * This is an Unicode call to an Unicode IME.
         */
        dwRet = (*pImeDpi->pfn.ImeConversionList.w)(hImc, lpwszSrc,
                                        lpCandListW, dwBufLen, uFlag);
        ImmUnlockImeDpi(pImeDpi);
        return dwRet;
    }

    ImmUnlockImeDpi(pImeDpi);

    /*
     * This is an Unicode call to an ANSI IME.
     */
    if (lpwszSrc != NULL) {

        dwBufTemp = (wcslen(lpwszSrc) + 1) * sizeof(WCHAR);

        lpszSrc = ImmLocalAlloc(0, dwBufTemp);
        if (lpszSrc == NULL)
            return (0);

        i = WideCharToMultiByte(dwCodePage,
                                (DWORD)0,
                                lpwszSrc,
                                (INT)wcslen(lpwszSrc),
                                (LPSTR)lpszSrc,
                                (INT)dwBufTemp,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);

        lpszSrc[i] = '\0';
    }
    else {
        lpszSrc = NULL;
    }

    /*
     * Query the CandidateListA size required.
     */
    dwBufTemp = ImmGetConversionListA(hKL, hImc, lpszSrc, NULL, 0, uFlag);

    if (dwBufTemp == 0 || (lpCandListA = ImmLocalAlloc(0, dwBufTemp)) == NULL) {
        if (lpszSrc)
            ImmLocalFree(lpszSrc);

        return (0);
    }

    /*
     * Now get the actual CandidateListA.
     */
    dwBufTemp = ImmGetConversionListA(hKL, hImc, lpszSrc,
                                        lpCandListA, dwBufTemp, uFlag);

    /*
     * Query the CandidateListW size required.
     */
    if (dwBufTemp != 0) {
        dwBufTemp = InternalGetCandidateListAtoW(lpCandListA, NULL, 0, dwCodePage);
    }

    if (dwBufLen == 0 || dwBufTemp == 0) {
        /*
         * Query required buffer size or error has happened.
         */
        dwRet = dwBufTemp;
    }
    else if (dwBufLen < dwBufTemp) {
        /*
         * Not enough buffer area.
         */
        dwRet = 0;
    }
    else {
        /*
         * Get the actual CandidateListW
         */
        dwRet = InternalGetCandidateListAtoW(lpCandListA, lpCandListW, dwBufLen, dwCodePage);
    }

    if (lpszSrc)
        ImmLocalFree(lpszSrc);
    ImmLocalFree(lpCandListA);

    return dwRet;
}


/***************************************************************************\
* ImmGetStatusWindowPos
*
* Gets the position, in screen coordinates, of the status window.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetStatusWindowPos(
    HIMC    hImc,
    LPPOINT lpptPos)
{
    PINPUTCONTEXT pInputContext;
    BOOL fStatusWndPosInited;

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGetStatusWindowPos: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    fStatusWndPosInited = ((pInputContext->fdwInit & INIT_STATUSWNDPOS) == INIT_STATUSWNDPOS);
    ImmUnlockIMC(hImc);

    if (fStatusWndPosInited) {
        *lpptPos = pInputContext->ptStatusWndPos;
        return TRUE;
    }

    return FALSE;
}


BOOL WINAPI ImmSetStatusWindowPos(
    HIMC     hImc,
    LPPOINT  lpptPos)
{
    PINPUTCONTEXT pInputContext;
    HWND          hWnd;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetStatusWindowPos: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmSetStatusWindowPos: Lock hImc %lx failed", hImc);
        return (FALSE);
    }

    pInputContext->ptStatusWndPos = *lpptPos;
    pInputContext->fdwInit |= INIT_STATUSWNDPOS;

    hWnd = pInputContext->hWnd;

    ImmUnlockIMC(hImc);

    /*
     * inform IME and UI about the change of composition font.
     */
    MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, 0L,
            IMC_SETSTATUSWINDOWPOS, IMN_SETSTATUSWINDOWPOS, 0L);

    return TRUE;
}


/***************************************************************************\
* ImmGetCompositionWindow
*
* Gets the information of the composition window.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetCompositionWindow(
    HIMC              hImc,
    LPCOMPOSITIONFORM lpCompForm)
{
    PINPUTCONTEXT pInputContext;
    BOOL fCompFormInited;

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionWindow: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    fCompFormInited = ((pInputContext->fdwInit & INIT_COMPFORM) == INIT_COMPFORM);
    ImmUnlockIMC(hImc);

    if (fCompFormInited) {
        *lpCompForm = pInputContext->cfCompForm;
        return TRUE;
    }

    return FALSE;
}


BOOL WINAPI ImmSetCompositionWindow(
    HIMC              hImc,
    LPCOMPOSITIONFORM lpCompForm)
{
    PINPUTCONTEXT pInputContext;
    HWND          hWnd;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetCompositionWindow: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmSetCompositionWindow: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    pInputContext->cfCompForm = *lpCompForm;
    pInputContext->fdwInit |= INIT_COMPFORM;

    /*
     * Only WINNLS.DLL set F31COMPAT_MCWHIDDEN.
     * When the apps or edit control calls this API, we need to remove
     * F31COMPAT_MCWHIDDEN.
     */
    if (pInputContext->fdw31Compat & F31COMPAT_CALLFROMWINNLS)
       pInputContext->fdw31Compat &= ~F31COMPAT_CALLFROMWINNLS;
    else
       pInputContext->fdw31Compat &= ~F31COMPAT_MCWHIDDEN;

    hWnd = pInputContext->hWnd;

    ImmUnlockIMC(hImc);

    /*
     * inform IME and UI about the change of composition window.
     */
    MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, 0L,
            IMC_SETCOMPOSITIONWINDOW, IMN_SETCOMPOSITIONWINDOW, 0L);

    return TRUE;
}


/***************************************************************************\
* ImmGetCandidateWindow
*
* Gets the information of the candidate window specified by dwIndex.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetCandidateWindow(
    HIMC              hImc,
    DWORD             dwIndex,
    LPCANDIDATEFORM   lpCandForm)
{
    PINPUTCONTEXT pInputContext;

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGetCandidateWindow: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    if (pInputContext->cfCandForm[dwIndex].dwIndex == -1) {
        ImmUnlockIMC(hImc);
        return (FALSE);
    }

    *lpCandForm = pInputContext->cfCandForm[dwIndex];
    ImmUnlockIMC(hImc);
    return TRUE;
}


BOOL WINAPI ImmSetCandidateWindow(
    HIMC              hImc,
    LPCANDIDATEFORM   lpCandForm)
{
    PINPUTCONTEXT pInputContext;
    HWND          hWnd;

    if (lpCandForm->dwIndex >= 4)      // over flow candidate index
        return (FALSE);

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetCandidateWindow: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmSetCandidateWindow: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    pInputContext->cfCandForm[lpCandForm->dwIndex] = *lpCandForm;

    hWnd = pInputContext->hWnd;

    ImmUnlockIMC(hImc);

    /*
     * inform IME and UI about the change of composition window.
     */
    MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, 0L, IMC_SETCANDIDATEPOS,
            IMN_SETCANDIDATEPOS, (LPARAM)(0x01 << lpCandForm->dwIndex));

    return TRUE;
}


#define GetCompInfoA(Component)                                                \
        if (!dwBufLen) {    /* query required buffer size */                   \
                            /* not include \0             */                   \
            dwBufLen = pCompStr->dw ## Component ## Len * sizeof(CHAR);        \
        } else {                                                               \
            if (dwBufLen > pCompStr->dw ## Component ## Len * sizeof(CHAR)) {  \
                dwBufLen = pCompStr->dw ## Component ## Len * sizeof(CHAR);    \
            }                                                                  \
            /* don't copy \0, maybe there is actually none */                  \
            RtlCopyMemory((LPBYTE)lpBuf, (LPBYTE)pCompStr +                    \
                pCompStr->dw ## Component ## Offset, dwBufLen);                \
        }

#define GetCompInfoW(Component)                                                \
        if (!dwBufLen) {    /* query required buffer size */                   \
                            /* not include \0             */                   \
            dwBufLen = pCompStr->dw ## Component ## Len * sizeof(WCHAR);       \
        } else {                                                               \
            if (dwBufLen > pCompStr->dw ## Component ## Len * sizeof(WCHAR)) { \
                dwBufLen = pCompStr->dw ## Component ## Len * sizeof(WCHAR);   \
            }                                                                  \
            /* don't copy \0, maybe there is actually none */                  \
            RtlCopyMemory((LPBYTE)lpBuf, (LPBYTE)pCompStr +                    \
                pCompStr->dw ## Component ## Offset, dwBufLen);                \
        }

#ifdef CUAS_ENABLE

#define GetPrivInfoA(pv, Component)                                                \
        if (!dwBufLen) {    /* query required buffer size */                   \
                            /* not include \0             */                   \
            dwBufLen = ## pv ## ->dw ## Component ## Len * sizeof(CHAR);       \
        } else {                                                               \
            if (dwBufLen > ## pv ## ->dw ## Component ## Len * sizeof(CHAR)) { \
                dwBufLen = ## pv ## ->dw ## Component ## Len * sizeof(CHAR);   \
            }                                                                  \
            /* don't copy \0, maybe there is actually none */                  \
            RtlCopyMemory((LPBYTE)lpBuf, (LPBYTE) ## pv ## +                   \
                 ## pv ## ->dw ## Component ## Offset, dwBufLen);              \
        }

#define GetPrivInfoW(pv, Component)                                            \
        if (!dwBufLen) {    /* query required buffer size */                   \
                            /* not include \0             */                   \
            dwBufLen = ## pv ## ->dw ## Component ## Len * sizeof(WCHAR);      \
        } else {                                                               \
            if (dwBufLen > ## pv ## ->dw ## Component ## Len * sizeof(WCHAR)) {\
                dwBufLen = ## pv ## ->dw ## Component ## Len * sizeof(WCHAR);  \
            }                                                                  \
            /* don't copy \0, maybe there is actually none */                  \
            RtlCopyMemory((LPBYTE)lpBuf, (LPBYTE) ## pv ##  +                  \
                ## pv ## ->dw ## Component ## Offset, dwBufLen);               \
        }

#endif // CUAS_ENABLE

/***************************************************************************\
* InternalGetCompositionStringA
*
* Internal version of ImmGetCompositionStringA.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

LONG InternalGetCompositionStringA(
#ifdef CUAS_ENABLE
    HIMC               hImc,
#endif // CUAS_ENABLE
    PCOMPOSITIONSTRING pCompStr,
    DWORD              dwIndex,
    LPVOID             lpBuf,
    DWORD              dwBufLen,
    BOOL               fAnsiImc,
    DWORD              dwCodePage)
{
    if (fAnsiImc) {
        /*
         * Composition string in input context is of ANSI style.
         */
        switch (dwIndex) {
        case GCS_COMPSTR:
            GetCompInfoA(CompStr);
            break;
        case GCS_COMPATTR:
            GetCompInfoA(CompAttr);
            break;
        case GCS_COMPREADSTR:
            GetCompInfoA(CompReadStr);
            break;
        case GCS_COMPREADATTR:
            GetCompInfoA(CompReadAttr);
            break;
        case GCS_COMPREADCLAUSE:
            GetCompInfoA(CompReadClause);
            break;
        case GCS_CURSORPOS:
            dwBufLen = (LONG)pCompStr->dwCursorPos;
            break;
        case GCS_DELTASTART:
            dwBufLen = (LONG)pCompStr->dwDeltaStart;
            break;
        case GCS_RESULTSTR:
            GetCompInfoA(ResultStr);
            break;
        case GCS_RESULTCLAUSE:
            GetCompInfoA(ResultClause);
            break;
        case GCS_RESULTREADSTR:
            GetCompInfoA(ResultReadStr);
            break;
        case GCS_RESULTREADCLAUSE:
            GetCompInfoA(ResultReadClause);
            break;
        case GCS_COMPCLAUSE:
            GetCompInfoA(CompClause);
            break;
#ifdef CUAS_ENABLE
        case GCS_COMPGUIDATTR:
            if (CtfImmIsGuidMapEnable(hImc) && (pCompStr->dwPrivateSize >= sizeof(GUIDMAPATTRIBUTE)))
            {
                PGUIDMAPATTRIBUTE pGuidMap = (PGUIDMAPATTRIBUTE)((PBYTE)pCompStr + pCompStr->dwPrivateOffset);
                if (pGuidMap != NULL)
                {
                    GetPrivInfoA(pGuidMap, GuidMapAttr);
                }
                else
                {
                    dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
                }
            }
            else
            {
                dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
            }
            break;
#endif // CUAS_ENABLE
        default:
            dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
            break;
        }

        return (LONG)dwBufLen;
    }

    /*
     * ANSI caller, Unicode input context/composition string.
     */
    switch (dwIndex) {
    case GCS_COMPSTR:
    case GCS_COMPREADSTR:
    case GCS_RESULTSTR:
    case GCS_RESULTREADSTR:
    {
        DWORD  dwStrSize;
        LPWSTR lpStrW;
        BOOL   bUDC;

        /*
         * Get ANSI string from Unicode composition string.
         */
#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringW(pCompStr, dwIndex,
                                            NULL, 0, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringW(hImc, pCompStr, dwIndex,
                                            NULL, 0, fAnsiImc, dwCodePage);
#endif

        lpStrW = ImmLocalAlloc(HEAP_ZERO_MEMORY, dwStrSize + sizeof(WCHAR));
        if (lpStrW == NULL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringA: memory failure.");
            return (LONG)IMM_ERROR_GENERAL;
        }

#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringW(pCompStr, dwIndex,
                                            lpStrW, dwStrSize, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringW(hImc, pCompStr, dwIndex,
                                            lpStrW, dwStrSize, fAnsiImc, dwCodePage);
#endif

        dwBufLen = WideCharToMultiByte(dwCodePage,
                                       (DWORD)0,
                                       lpStrW,          // src
                                       wcslen(lpStrW),
                                       (LPSTR)lpBuf,    // dest
                                       dwBufLen,
                                       (LPSTR)NULL,
                                       (LPBOOL)&bUDC);

        ImmLocalFree(lpStrW);
        break;
    }

    case GCS_COMPATTR:
    case GCS_COMPREADATTR:
#ifdef CUAS_ENABLE
    case GCS_COMPGUIDATTR:
#endif // CUAS_ENABLE
    {
        DWORD dwAttrLenW, dwIndexStr, dwStrSize;
        PBYTE lpAttrA, lpAttrW;
        LPSTR lpStrA, lpStrT;
        CHAR  c;

        /*
         * Get ANSI attribute from Unicode composition attribute.
         */
        switch (dwIndex) {
        case GCS_COMPATTR:
            lpAttrW = (PBYTE)pCompStr + pCompStr->dwCompAttrOffset;
            dwAttrLenW = pCompStr->dwCompAttrLen;
            dwIndexStr = GCS_COMPSTR;
            break;
        case GCS_COMPREADATTR:
            lpAttrW = (PBYTE)pCompStr + pCompStr->dwCompReadAttrOffset;
            dwAttrLenW = pCompStr->dwCompReadAttrLen;
            dwIndexStr = GCS_COMPREADSTR;
            break;
#ifdef CUAS_ENABLE
        case GCS_COMPGUIDATTR:
            if (CtfImmIsGuidMapEnable(hImc) && (pCompStr->dwPrivateSize >= sizeof(GUIDMAPATTRIBUTE)))
            {
                PGUIDMAPATTRIBUTE pGuidMap = (PGUIDMAPATTRIBUTE)((PBYTE)pCompStr + pCompStr->dwPrivateOffset);
                if (pGuidMap != NULL)
                {
                    lpAttrW = (PBYTE)pGuidMap + pGuidMap->dwGuidMapAttrOffset;
                    dwAttrLenW = pGuidMap->dwGuidMapAttrLen;
                    dwIndexStr = GCS_COMPSTR;
                    break;
                }
                else
                {
                    return (DWORD)(LONG)IMM_ERROR_GENERAL;
                }
            }
            else
            {
                return (DWORD)(LONG)IMM_ERROR_GENERAL;
            }
            break;
#endif // CUAS_ENABLE
        }

        if (dwAttrLenW == 0) {
            /*
             * No CompAttr or CompReadAttr exists, do nothing.
             */
            return 0;
        }

#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringA(pCompStr,
                                        dwIndexStr, NULL, 0, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringA(hImc, pCompStr,
                                        dwIndexStr, NULL, 0, fAnsiImc, dwCodePage);
#endif

        if (dwStrSize == (DWORD)(LONG)IMM_ERROR_GENERAL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringA: IMM_ERROR_GENERAL.");
            return (LONG)IMM_ERROR_GENERAL;
        }

        /*
         * Query required size or early exit on error.
         */
        if (dwBufLen == 0 || dwStrSize == 0)
            return dwStrSize;

        lpStrA = ImmLocalAlloc(HEAP_ZERO_MEMORY, dwStrSize + sizeof(CHAR));
        if (lpStrA == NULL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringA: memory failure.");
            return (LONG)IMM_ERROR_GENERAL;
        }

#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringA(pCompStr,
                                        dwIndexStr, lpStrA, dwStrSize, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringA(hImc, pCompStr,
                                        dwIndexStr, lpStrA, dwStrSize, fAnsiImc, dwCodePage);
#endif

        if (dwStrSize == (LONG)IMM_ERROR_GENERAL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringA: IMM_ERROR_GENERAL.");
            ImmLocalFree(lpStrA);
            return (LONG)IMM_ERROR_GENERAL;
        }

        lpStrT = lpStrA;
        lpAttrA = (PBYTE)lpBuf;

        while ((c=*lpStrT++) != '\0' && dwBufLen != 0 && dwAttrLenW-- != 0) {
            if (IsDBCSLeadByteEx(dwCodePage, c)) {
                if (dwBufLen >= 2) {
                    *lpAttrA++ = *lpAttrW;
                    *lpAttrA++ = *lpAttrW;
                    dwBufLen--;
                }
                else {
                    *lpAttrA++ = *lpAttrW;
                }
                lpStrT++;
            }
            else {
                *lpAttrA++ = *lpAttrW;
            }
            lpAttrW++;
            dwBufLen--;
        }

        dwBufLen = (DWORD)(lpAttrA - (PBYTE)lpBuf);

        ImmLocalFree(lpStrA);
        break;
    }

    case GCS_COMPCLAUSE:
    case GCS_COMPREADCLAUSE:
    case GCS_RESULTCLAUSE:
    case GCS_RESULTREADCLAUSE:
    {
        LPWSTR  lpStrW;
        DWORD   dwClauseLen, dwBufLenA;
        LPDWORD lpdwSrc, lpdwDst;
        UINT    i;

        /*
         * Get ANSI clause from Unicode composition clause.
         */
        switch (dwIndex) {
        case GCS_COMPCLAUSE:
            lpStrW = (LPWSTR)((PBYTE)pCompStr + pCompStr->dwCompStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwCompClauseOffset);
            dwClauseLen = pCompStr->dwCompClauseLen;
            break;
        case GCS_COMPREADCLAUSE:
            lpStrW = (LPWSTR)((PBYTE)pCompStr + pCompStr->dwCompReadStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwCompReadClauseOffset);
            dwClauseLen = pCompStr->dwCompReadClauseLen;
            break;
        case GCS_RESULTCLAUSE:
            lpStrW = (LPWSTR)((PBYTE)pCompStr + pCompStr->dwResultStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwResultClauseOffset);
            dwClauseLen = pCompStr->dwResultClauseLen;
            break;
        case GCS_RESULTREADCLAUSE:
            lpStrW = (LPWSTR)((PBYTE)pCompStr + pCompStr->dwResultReadStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwResultReadClauseOffset);
            dwClauseLen = pCompStr->dwResultReadClauseLen;
            break;
        }

        /*
         * Query clause length or early exit on error.
         */
        if (dwBufLen == 0 || (LONG)dwClauseLen < 0) {
            dwBufLen = dwClauseLen;
            break;
        }

        lpdwDst = (LPDWORD)lpBuf;
        dwBufLenA = dwBufLen / sizeof(DWORD);

        for (i = 0; i < dwClauseLen / sizeof(DWORD) && dwBufLenA != 0; i++) {
            *lpdwDst++ = CalcCharacterPositionWtoA(*lpdwSrc++, lpStrW, dwCodePage);
            dwBufLenA--;
        }

        dwBufLen = i * sizeof(DWORD);
        break;
    }

    case GCS_CURSORPOS:
    case GCS_DELTASTART:
        /*
         * Get ANSI cursor/delta start position from Unicode composition string.
         */
        switch (dwIndex) {
        case GCS_CURSORPOS:
            dwBufLen = pCompStr->dwCursorPos;
            break;
        case GCS_DELTASTART:
            dwBufLen = pCompStr->dwDeltaStart;
            break;
        }

        if ((LONG)dwBufLen > 0) {
            dwBufLen = CalcCharacterPositionWtoA(dwBufLen,
                            (LPWSTR)((PBYTE)pCompStr + pCompStr->dwCompStrOffset),
                            dwCodePage);
        }
        break;

    default:
        dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
    }

    return (LONG)dwBufLen;
}


/***************************************************************************\
* InternalGetCompositionStringW
*
* Internal version of ImmGetCompositionStringW.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

LONG InternalGetCompositionStringW(
#ifdef CUAS_ENABLE
    HIMC               hImc,
#endif // CUAS_ENABLE
    PCOMPOSITIONSTRING pCompStr,
    DWORD              dwIndex,
    LPVOID             lpBuf,
    DWORD              dwBufLen,
    BOOL               fAnsiImc,
    DWORD              dwCodePage)
{
    if (!fAnsiImc) {
        /*
         * Composition string in input context is of Unicode style.
         */
        switch (dwIndex) {
        case GCS_COMPSTR:
            GetCompInfoW(CompStr);
            break;
        case GCS_COMPATTR:              // ANSI-only
            GetCompInfoA(CompAttr);
            break;
        case GCS_COMPREADSTR:
            GetCompInfoW(CompReadStr);
            break;
        case GCS_COMPREADATTR:          // ANSI-only
            GetCompInfoA(CompReadAttr);
            break;
        case GCS_COMPREADCLAUSE:        // ANSI-only
            GetCompInfoA(CompReadClause);
            break;
        case GCS_CURSORPOS:
            dwBufLen = (LONG)pCompStr->dwCursorPos;
            break;
        case GCS_DELTASTART:
            dwBufLen = (LONG)pCompStr->dwDeltaStart;
            break;
        case GCS_RESULTSTR:
            GetCompInfoW(ResultStr);
            break;
        case GCS_RESULTCLAUSE:          // ANSI-only
            GetCompInfoA(ResultClause);
            break;
        case GCS_RESULTREADSTR:
            GetCompInfoW(ResultReadStr);
            break;
        case GCS_RESULTREADCLAUSE:      // ANSI-only
            GetCompInfoA(ResultReadClause);
            break;
        case GCS_COMPCLAUSE:            // ANSI-only
            GetCompInfoA(CompClause);
            break;
#ifdef CUAS_ENABLE
        case GCS_COMPGUIDATTR:          // ANSI-only
            if (CtfImmIsGuidMapEnable(hImc) && (pCompStr->dwPrivateSize >= sizeof(GUIDMAPATTRIBUTE)))
            {
                PGUIDMAPATTRIBUTE pGuidMap = (PGUIDMAPATTRIBUTE)((PBYTE)pCompStr + pCompStr->dwPrivateOffset);
                if (pGuidMap != NULL)
                {
                    GetPrivInfoA(pGuidMap, GuidMapAttr);
                }
                else
                {
                    dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
                }
            }
            else
            {
                dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
            }
            break;
#endif // CUAS_ENABLE
        default:
            dwBufLen = (DWORD)IMM_ERROR_GENERAL;
            break;
        }

        return (LONG)dwBufLen;
    }

    /*
     * Unicode caller, ANSI input context/composition string.
     */
    switch (dwIndex) {
    case GCS_COMPSTR:
    case GCS_COMPREADSTR:
    case GCS_RESULTSTR:
    case GCS_RESULTREADSTR:
    {
        DWORD  dwStrSize;
        LPSTR lpStrA;

        /*
         * Get Unicode string from ANSI composition string.
         */
#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringA(pCompStr, dwIndex,
                                            NULL, 0, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringA(hImc, pCompStr, dwIndex,
                                            NULL, 0, fAnsiImc, dwCodePage);
#endif

        lpStrA = ImmLocalAlloc(HEAP_ZERO_MEMORY, dwStrSize + sizeof(CHAR));
        if (lpStrA == NULL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringW: memory failure.");
            return (LONG)IMM_ERROR_GENERAL;
        }

#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringA(pCompStr, dwIndex,
                                            lpStrA, dwStrSize, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringA(hImc, pCompStr, dwIndex,
                                            lpStrA, dwStrSize, fAnsiImc, dwCodePage);
#endif

        dwBufLen = MultiByteToWideChar(dwCodePage,
                                       (DWORD)MB_PRECOMPOSED,
                                       lpStrA,              // src
                                       strlen(lpStrA),
                                       (LPWSTR)lpBuf,        // dest
                                       (INT)dwBufLen);

        dwBufLen *= sizeof(WCHAR);     // return number of bytes required.

        ImmLocalFree(lpStrA);
        break;
    }

    case GCS_COMPATTR:
    case GCS_COMPREADATTR:
#ifdef CUAS_ENABLE
    case GCS_COMPGUIDATTR:
#endif // CUAS_ENABLE
    {
        DWORD  dwAttrLenA, dwIndexStr, dwStrSize;
        PBYTE  lpAttrA, lpAttrW;
        LPWSTR lpStrW, lpStrT;
        ULONG  MultiByteSize;
        WCHAR  wc;

        /*
         * Get Unicode attribute from ANSI composition attribute.
         */
        switch (dwIndex) {
        case GCS_COMPATTR:
            lpAttrA = (PBYTE)pCompStr + pCompStr->dwCompAttrOffset;
            dwAttrLenA = pCompStr->dwCompAttrLen;
            dwIndexStr = GCS_COMPSTR;
            break;
        case GCS_COMPREADATTR:
            lpAttrA = (PBYTE)pCompStr + pCompStr->dwCompReadAttrOffset;
            dwAttrLenA = pCompStr->dwCompReadAttrLen;
            dwIndexStr = GCS_COMPREADSTR;
            break;
#ifdef CUAS_ENABLE
        case GCS_COMPGUIDATTR:
            if (CtfImmIsGuidMapEnable(hImc) && (pCompStr->dwPrivateSize >= sizeof(GUIDMAPATTRIBUTE)))
            {
                PGUIDMAPATTRIBUTE pGuidMap = (PGUIDMAPATTRIBUTE)((PBYTE)pCompStr + pCompStr->dwPrivateOffset);
                if (pGuidMap != NULL)
                {
                    lpAttrA = (PBYTE)pGuidMap + pGuidMap->dwGuidMapAttrOffset;
                    dwAttrLenA = pGuidMap->dwGuidMapAttrLen;
                    dwIndexStr = GCS_COMPSTR;
                    break;
                }
                else
                {
                    return (DWORD)(LONG)IMM_ERROR_GENERAL;
                }
            }
            else
            {
                return (DWORD)(LONG)IMM_ERROR_GENERAL;
            }
            break;
#endif // CUAS_ENABLE
        }

        if (dwAttrLenA == 0) {
            /*
             * No CompAttr or CompReadAttr exists, do nothing.
             */
            return 0;
        }

#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringW(pCompStr,
                                        dwIndexStr, NULL, 0, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringW(hImc, pCompStr,
                                        dwIndexStr, NULL, 0, fAnsiImc, dwCodePage);
#endif

        if (dwStrSize == (DWORD)(LONG)IMM_ERROR_GENERAL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringA: IMM_ERROR_GENERAL.");
            return (LONG)IMM_ERROR_GENERAL;
        }

        /*
         * Query required size or early exit on error.
         */
        if (dwBufLen == 0 || dwStrSize == 0)
            return dwStrSize / sizeof(WCHAR);

        lpStrW = ImmLocalAlloc(HEAP_ZERO_MEMORY, dwStrSize + sizeof(WCHAR));
        if (lpStrW == NULL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringW: memory failure.");
            return (LONG)IMM_ERROR_GENERAL;
        }

#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringW(pCompStr,
                                        dwIndexStr, lpStrW, dwStrSize, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringW(hImc, pCompStr,
                                        dwIndexStr, lpStrW, dwStrSize, fAnsiImc, dwCodePage);
#endif

        if (dwStrSize == (LONG)IMM_ERROR_GENERAL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringA: IMM_ERROR_GENERAL.");
            ImmLocalFree(lpStrW);
            return (LONG)IMM_ERROR_GENERAL;
        }

        lpStrT = lpStrW;
        lpAttrW = (PBYTE)lpBuf;

        while ((wc=*lpStrT++) != L'\0' && dwBufLen != 0 && dwAttrLenA-- != 0) {
            MultiByteSize = UnicodeToMultiByteSize(dwCodePage, &wc);
            if (MultiByteSize == 2 && dwAttrLenA != 0) {
                *lpAttrW++ = *lpAttrA++;
                dwAttrLenA--;
            }
            else {
                *lpAttrW++ = *lpAttrA;
            }
            lpAttrA++;
            dwBufLen--;
        }

        dwBufLen = (DWORD)(lpAttrW - (PBYTE)lpBuf);

        ImmLocalFree(lpStrW);
        break;
    }

    case GCS_COMPCLAUSE:
    case GCS_COMPREADCLAUSE:
    case GCS_RESULTCLAUSE:
    case GCS_RESULTREADCLAUSE:
    {
        LPSTR   lpStrA;
        DWORD   dwClauseLen, dwBufLenW;
        LPDWORD lpdwSrc, lpdwDst;
        UINT    i;

        /*
         * Get Unicode clause from ANSI composition clause.
         */
        switch (dwIndex) {
        case GCS_COMPCLAUSE:
            lpStrA = (LPSTR)((PBYTE)pCompStr + pCompStr->dwCompStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwCompClauseOffset);
            dwClauseLen = pCompStr->dwCompClauseLen;
            break;
        case GCS_COMPREADCLAUSE:
            lpStrA = (LPSTR)((PBYTE)pCompStr + pCompStr->dwCompReadStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwCompReadClauseOffset);
            dwClauseLen = pCompStr->dwCompReadClauseLen;
            break;
        case GCS_RESULTCLAUSE:
            lpStrA = (LPSTR)((PBYTE)pCompStr + pCompStr->dwResultStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwResultClauseOffset);
            dwClauseLen = pCompStr->dwResultClauseLen;
            break;
        case GCS_RESULTREADCLAUSE:
            lpStrA = (LPSTR)((PBYTE)pCompStr + pCompStr->dwResultReadStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwResultReadClauseOffset);
            dwClauseLen = pCompStr->dwResultReadClauseLen;
            break;
        }


        /*
         * Query clause length or early exit on error.
         */
        if (dwBufLen == 0 || (LONG)dwClauseLen < 0) {
            dwBufLen = dwClauseLen;
            break;
        }

        lpdwDst = (LPDWORD)lpBuf;
        dwBufLenW = dwBufLen / sizeof(DWORD);

        for (i = 0; i < dwClauseLen / sizeof(DWORD) && dwBufLenW != 0; i++) {
            *lpdwDst++ = CalcCharacterPositionAtoW(*lpdwSrc++, lpStrA, dwCodePage);
            dwBufLenW--;
        }

        dwBufLen = i * sizeof(DWORD);
        break;
    }

    case GCS_CURSORPOS:
    case GCS_DELTASTART:
        /*
         * Get Unicode cursor/delta start position from ANSI composition string.
         */
        switch (dwIndex) {
        case GCS_CURSORPOS:
            dwBufLen = pCompStr->dwCursorPos;
            break;
        case GCS_DELTASTART:
            dwBufLen = pCompStr->dwDeltaStart;
            break;
        }

        if ((LONG)dwBufLen > 0) {
            dwBufLen = CalcCharacterPositionAtoW(dwBufLen,
                            (LPSTR)((PBYTE)pCompStr + pCompStr->dwCompStrOffset),
                            dwCodePage);
        }
        break;

    default:
        dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
    }

    return (LONG)dwBufLen;
}


DWORD InternalGetCandidateListAtoW(
    LPCANDIDATELIST     lpCandListA,
    LPCANDIDATELIST     lpCandListW,
    DWORD               dwBufLen,
    DWORD               dwCodePage)
{
    LPWSTR lpCandStrW;
    LPSTR  lpCandStrA;
    INT    i, j;
    DWORD  dwCandListLen;

    dwCandListLen = sizeof(CANDIDATELIST);

    /*
     * CANDIDATELIST has already contained the dwOffset[0]
     */
    if (lpCandListA->dwCount > 0)
        dwCandListLen += sizeof(DWORD) * (lpCandListA->dwCount - 1);

    for (i = 0; i < (INT)lpCandListA->dwCount; i++) {

        lpCandStrA = (LPSTR)((LPBYTE)lpCandListA + lpCandListA->dwOffset[i]);

        j = MultiByteToWideChar(dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                lpCandStrA,
                                -1,
                                (LPWSTR)NULL,
                                0);

        dwCandListLen += (j * sizeof(WCHAR));
    }

    dwCandListLen = DWORD_ALIGN(dwCandListLen);

    if (dwBufLen == 0)
        return dwCandListLen;

    if (dwBufLen < dwCandListLen) {
        RIPMSG0(RIP_WARNING, "InternalGetCandidateListAtoW: dwBufLen too small.");
        return 0;
    }

    lpCandListW->dwSize = dwBufLen;
    lpCandListW->dwStyle = lpCandListA->dwStyle;
    lpCandListW->dwCount = lpCandListA->dwCount;
    lpCandListW->dwSelection = lpCandListA->dwSelection;
    lpCandListW->dwPageStart = lpCandListA->dwPageStart;
    lpCandListW->dwPageSize = lpCandListA->dwPageSize;
    lpCandListW->dwOffset[0] = sizeof(CANDIDATELIST);
    if (lpCandListW->dwCount > 0)
        lpCandListW->dwOffset[0] += sizeof(DWORD) * (lpCandListW->dwCount - 1);

    dwCandListLen = dwBufLen - lpCandListW->dwOffset[0];

    for  (i = 0; i < (INT)lpCandListW->dwCount; i++) {

        lpCandStrA = (LPSTR) ((LPBYTE)lpCandListA + lpCandListA->dwOffset[i]);
        lpCandStrW = (LPWSTR)((LPBYTE)lpCandListW + lpCandListW->dwOffset[i]);

        j = MultiByteToWideChar(dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                lpCandStrA,
                                -1,
                                lpCandStrW,
                                (INT)dwCandListLen/sizeof(WCHAR));

        dwCandListLen -= (j * sizeof(WCHAR));

        if (i < (INT)lpCandListW->dwCount - 1)
            lpCandListW->dwOffset[i+1] = lpCandListW->dwOffset[i] + j * sizeof(WCHAR);
    }

    return dwBufLen;
}


DWORD InternalGetCandidateListWtoA(
    LPCANDIDATELIST     lpCandListW,
    LPCANDIDATELIST     lpCandListA,
    DWORD               dwBufLen,
    DWORD               dwCodePage)
{
    LPWSTR lpCandStrW;
    LPSTR  lpCandStrA;
    INT    i, j;
    DWORD  dwCandListLen;
    BOOL   bUDC;

    dwCandListLen = sizeof(CANDIDATELIST);

    /*
     * CANDIDATELIST has already contained the dwOffset[0]
     */
    if (lpCandListW->dwCount > 0)
        dwCandListLen += sizeof(DWORD) * (lpCandListW->dwCount - 1);

    for (i = 0; i < (INT)lpCandListW->dwCount; i++) {

        lpCandStrW = (LPWSTR)((LPBYTE)lpCandListW + lpCandListW->dwOffset[i]);

        j = WideCharToMultiByte(dwCodePage,
                                (DWORD)0,
                                lpCandStrW,
                                -1,
                                (LPSTR)NULL,
                                (INT)0,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);

        dwCandListLen += (j * sizeof(CHAR));
    }

    dwCandListLen = DWORD_ALIGN(dwCandListLen);

    if (dwBufLen == 0)
        return dwCandListLen;

    if (dwBufLen < dwCandListLen) {
        RIPMSG0(RIP_WARNING, "InternalGetCandidateListWtoA: dwBufLen too small.");
        return 0;
    }

    lpCandListA->dwSize = dwBufLen;
    lpCandListA->dwStyle = lpCandListW->dwStyle;
    lpCandListA->dwCount = lpCandListW->dwCount;
    lpCandListA->dwSelection = lpCandListW->dwSelection;
    lpCandListA->dwPageStart = lpCandListW->dwPageStart;
    lpCandListA->dwPageSize = lpCandListW->dwPageSize;
    lpCandListA->dwOffset[0] = sizeof(CANDIDATELIST);
    if (lpCandListA->dwCount > 0)
        lpCandListA->dwOffset[0] += sizeof(DWORD) * (lpCandListA->dwCount - 1);

    dwCandListLen = dwBufLen - lpCandListA->dwOffset[0];

    for  (i = 0; i < (INT)lpCandListA->dwCount; i++) {

        lpCandStrA = (LPSTR) ((LPBYTE)lpCandListA + lpCandListA->dwOffset[i]);
        lpCandStrW = (LPWSTR)((LPBYTE)lpCandListW + lpCandListW->dwOffset[i]);

        j = WideCharToMultiByte(dwCodePage,
                                (DWORD)0,
                                lpCandStrW,
                                -1,
                                (LPSTR)lpCandStrA,
                                (INT)dwCandListLen,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);

        dwCandListLen -= (j * sizeof(CHAR));

        if (i < (INT)lpCandListA->dwCount - 1)
            lpCandListA->dwOffset[i+1] = lpCandListA->dwOffset[i] + j * sizeof(CHAR);
    }

    return dwBufLen;
}

/***************************************************************************\
* CalcCharacterPositionAtoW
*
* Calculate Unicode character position to ANSI character position.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD CalcCharacterPositionAtoW(
    DWORD dwCharPosA,
    LPSTR lpszCharStr,
    DWORD dwCodePage)
{
    DWORD dwCharPosW = 0;

    while (dwCharPosA != 0) {
        if (IsDBCSLeadByteEx(dwCodePage, *lpszCharStr)) {
            if (dwCharPosA >= 2) {
                dwCharPosA -= 2;
            }
            else {
                dwCharPosA--;
            }
            lpszCharStr += 2;
        }
        else {
            dwCharPosA--;
            lpszCharStr++;
        }
        dwCharPosW++;
    }

    return dwCharPosW;
}


/***************************************************************************\
* CalcCharacterPositionWtoA
*
* Calculate ANSI character position to Unicode character position.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD CalcCharacterPositionWtoA(
    DWORD dwCharPosW,
    LPWSTR lpwszCharStr,
    DWORD  dwCodePage)
{
    DWORD dwCharPosA = 0;
    ULONG MultiByteSize;

    while (dwCharPosW != 0) {
        MultiByteSize = UnicodeToMultiByteSize(dwCodePage, lpwszCharStr);
        if (MultiByteSize == 2) {
            dwCharPosA += 2;
        }
        else {
            dwCharPosA++;
        }
        dwCharPosW--;
        lpwszCharStr++;
    }

    return dwCharPosA;
}


VOID LFontAtoLFontW(
    LPLOGFONTA lpLogFontA,
    LPLOGFONTW lpLogFontW)
{
    INT i;

    RtlCopyMemory(lpLogFontW, lpLogFontA, sizeof(LOGFONTA)-LF_FACESIZE);

    i = MultiByteToWideChar(CP_ACP,     // Note: font face name should use ACP for A/W conversion.
                            MB_PRECOMPOSED,
                            lpLogFontA->lfFaceName,
                            strlen(lpLogFontA->lfFaceName),
                            lpLogFontW->lfFaceName,
                            LF_FACESIZE);

    lpLogFontW->lfFaceName[i] = L'\0';

    return;
}


VOID LFontWtoLFontA(
    LPLOGFONTW lpLogFontW,
    LPLOGFONTA lpLogFontA)
{
    INT  i;
    BOOL bUDC;

    RtlCopyMemory(lpLogFontA, lpLogFontW, sizeof(LOGFONTA)-LF_FACESIZE);

    i = WideCharToMultiByte(CP_ACP,     // Note: font face name should use ACP for A/W conversion.
                            0,
                            lpLogFontW->lfFaceName,
                            wcslen(lpLogFontW->lfFaceName),
                            lpLogFontA->lfFaceName,
                            LF_FACESIZE,
                            (LPSTR)NULL,
                            &bUDC);

    lpLogFontA->lfFaceName[i] = '\0';

    return;
}


BOOL MakeIMENotify(
    HIMC   hImc,
    HWND   hWnd,
    DWORD  dwAction,
    DWORD  dwIndex,
    DWORD  dwValue,
    WPARAM wParam,
    LPARAM lParam)
{
    PIMEDPI pImeDpi;
    DWORD   dwThreadId;

#ifdef LATER
    // implement MakeIMENotifyEvent() later
#endif

    if (dwAction != 0 && (dwThreadId = GetInputContextThread(hImc)) != 0) {

        pImeDpi = ImmLockImeDpi(GetKeyboardLayout(dwThreadId));

        if (pImeDpi != NULL) {
            (*pImeDpi->pfn.NotifyIME)(hImc, dwAction, dwIndex, dwValue);
            ImmUnlockImeDpi(pImeDpi);
        }
    }

    if (hWnd != NULL && wParam != 0)
        SendMessage(hWnd, WM_IME_NOTIFY, wParam, lParam);

    return TRUE;
}



//////////////////////////////////////////////////////////////////////
// Reconversion support
//////////////////////////////////////////////////////////////////////

typedef enum {FROM_IME, FROM_APP} REQ_CALLER;

///////////////////////////////////////////////////////////////////////////////////
// ImmGetReconvertTotalSize
//
// calculate the appropriate size of the buffer, based on caller/ansi information
//
// History:
// 28-Feb-1997   hiroyama   Created
///////////////////////////////////////////////////////////////////////////////////

DWORD ImmGetReconvertTotalSize(DWORD dwSize, REQ_CALLER eCaller, BOOL bAnsiTarget)
{
    if (dwSize < sizeof(RECONVERTSTRING)) {
        return 0;
    }
    if (bAnsiTarget) {
        dwSize -= sizeof(RECONVERTSTRING);
        if (eCaller == FROM_IME) {
            dwSize /= 2;
        } else {
            dwSize *= 2;
        }
        dwSize += sizeof(RECONVERTSTRING);
    }
    return dwSize;
}

DWORD ImmReconversionWorker(
        LPRECONVERTSTRING lpRecTo,
        LPRECONVERTSTRING lpRecFrom,
        BOOL bToAnsi,
        DWORD dwCodePage)
{
    INT i;
    DWORD dwSize = 0;

    UserAssert(lpRecTo);
    UserAssert(lpRecFrom);

    if (lpRecFrom->dwVersion != 0 || lpRecTo->dwVersion != 0) {
        RIPMSG0(RIP_WARNING, "ImmReconversionWorker: dwVersion in lpRecTo or lpRecFrom is incorrect.");
        return 0;
    }
    // Note:
    // In any IME related structures, use the following principal.
    // 1) xxxStrOffset is an actual offset, i.e. byte count.
    // 2) xxxStrLen is a number of characters, i.e. TCHAR count.
    //
    // CalcCharacterPositionXtoY() takes TCHAR count so that we
    // need to adjust xxxStrOffset if it's being converted. But you
    // should be careful, because the actual position of the string
    // is always at something like (LPBYTE)lpStruc + lpStruc->dwStrOffset.
    //
    if (bToAnsi) {
        // Convert W to A
        lpRecTo->dwStrOffset = sizeof *lpRecTo;
        i = WideCharToMultiByte(dwCodePage,
                                (DWORD)0,
                                (LPWSTR)((LPSTR)lpRecFrom + lpRecFrom->dwStrOffset), // src
                                (INT)lpRecFrom->dwStrLen,
                                (LPSTR)lpRecTo + lpRecTo->dwStrOffset,  // dest
                                (INT)lpRecFrom->dwStrLen * DBCS_CHARSIZE,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpRecTo->dwCompStrOffset =
            CalcCharacterPositionWtoA(lpRecFrom->dwCompStrOffset / sizeof(WCHAR),
                                      (LPWSTR)((LPBYTE)lpRecFrom + lpRecFrom->dwStrOffset),
                                      dwCodePage)
                            * sizeof(CHAR);

        lpRecTo->dwCompStrLen =
            (CalcCharacterPositionWtoA(lpRecFrom->dwCompStrOffset / sizeof(WCHAR) +
                                      lpRecFrom->dwCompStrLen,
                                      (LPWSTR)((LPBYTE)lpRecFrom + lpRecFrom->dwStrOffset),
                                      dwCodePage)
                            * sizeof(CHAR))
            - lpRecTo->dwCompStrOffset;

        lpRecTo->dwTargetStrOffset =
            CalcCharacterPositionWtoA(lpRecFrom->dwTargetStrOffset / sizeof(WCHAR),
                                      (LPWSTR)((LPBYTE)lpRecFrom +
                                                lpRecFrom->dwStrOffset),
                                      dwCodePage)
                            * sizeof(CHAR);

        lpRecTo->dwTargetStrLen =
            (CalcCharacterPositionWtoA(lpRecFrom->dwTargetStrOffset / sizeof(WCHAR) +
                                      lpRecFrom->dwTargetStrLen,
                                      (LPWSTR)((LPBYTE)lpRecFrom + lpRecFrom->dwStrOffset),
                                       dwCodePage)
                            * sizeof(CHAR))
            - lpRecTo->dwTargetStrOffset;

        ((LPSTR)lpRecTo)[lpRecTo->dwStrOffset + i] = '\0';
        lpRecTo->dwStrLen = i * sizeof(CHAR);

        dwSize = sizeof(RECONVERTSTRING) + ((i + 1) * sizeof(CHAR));

    } else {

        // AtoW
        lpRecTo->dwStrOffset = sizeof *lpRecTo;
        i = MultiByteToWideChar(dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,  // src
                                (INT)lpRecFrom->dwStrLen,
                                (LPWSTR)((LPSTR)lpRecTo + lpRecTo->dwStrOffset), // dest
                                (INT)lpRecFrom->dwStrLen);

        lpRecTo->dwCompStrOffset =
            CalcCharacterPositionAtoW(lpRecFrom->dwCompStrOffset,
                                      (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                      dwCodePage) * sizeof(WCHAR);

        lpRecTo->dwCompStrLen =
            ((CalcCharacterPositionAtoW(lpRecFrom->dwCompStrOffset +
                                       lpRecFrom->dwCompStrLen,
                                       (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                        dwCodePage)  * sizeof(WCHAR))
            - lpRecTo->dwCompStrOffset) / sizeof(WCHAR);

        lpRecTo->dwTargetStrOffset =
            CalcCharacterPositionAtoW(lpRecFrom->dwTargetStrOffset,
                                      (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                      dwCodePage) * sizeof(WCHAR);

        lpRecTo->dwTargetStrLen =
            ((CalcCharacterPositionAtoW(lpRecFrom->dwTargetStrOffset +
                                       lpRecFrom->dwTargetStrLen,
                                       (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                       dwCodePage)  * sizeof(WCHAR))
            - lpRecTo->dwTargetStrOffset) / sizeof(WCHAR);

        lpRecTo->dwStrLen = i;  // Length is TCHAR count.
        if (lpRecTo->dwSize >= (DWORD)(lpRecTo->dwStrOffset + (i + 1)* sizeof(WCHAR))) {
            LPWSTR lpW = (LPWSTR)((LPSTR)lpRecTo + lpRecTo->dwStrOffset);
            lpW[i] = L'\0';
        }
        dwSize = sizeof(RECONVERTSTRING) + ((i + 1) * sizeof(WCHAR));
    }
    return dwSize;
}

///////////////////////////////////////////////////////////////////////////////////
// ImmRequestMessageWorker
//
// worker function for WM_IME_REQUEST message
//
// History:
// 30-Mar-1997   hiroyama   Created
///////////////////////////////////////////////////////////////////////////////////

LRESULT ImmRequestMessageWorker(HIMC hIMC, PWND pwnd, WPARAM wParam, LPARAM lParam, BOOL bAnsiOrigin)
{
    // the (least) size of the structure given in lParam: for valid pointer checking
    static CONST int nReqBufSize[][7] = {
        {   // sizes if IME is UNICODE
            sizeof(COMPOSITIONFORM),    // IMR_COMPOSITIONWINDOW
            sizeof(CANDIDATEFORM),      // IMR_CANDIDATEWINDOW
            sizeof(LOGFONTW),           // IMR_COMPOSITIONFONT
            sizeof(RECONVERTSTRING),    // IMR_RECONVERTSTRING
            sizeof(RECONVERTSTRING),    // IMR_CONFIRMRECONVERTSTRING
            sizeof(IMECHARPOSITION),    // IMR_QUERYCHARPOSITION
            sizeof(RECONVERTSTRING),    // IMR_DOCUMENTFEED
        },
        {   // sizes if IME is ANSI
            sizeof(COMPOSITIONFORM),    // IMR_COMPOSITIONWINDOW
            sizeof(CANDIDATEFORM),      // IMR_CANDIDATEWINDOW
            sizeof(LOGFONTA),           // IMR_COMPOSITIONFONT
            sizeof(RECONVERTSTRING),    // IMR_RECONVERTSTRING
            sizeof(RECONVERTSTRING),    // IMR_CONFIRMRECONVERTSTRING
            sizeof(IMECHARPOSITION),    // IMR_QUERYCHARPOSITION
            sizeof(RECONVERTSTRING),    // IMR_DOCUMENTFEED
        }
    };
    LRESULT lRet = 0L;
    CONST BOOLEAN bAnsiTarget = !!TestWF(pwnd, WFANSIPROC);    // TRUE if the target Window Proc is ANSI
    LPBYTE lpReq = (LPBYTE)lParam;                          // return buffer (maybe allocated buffer)
    LPBYTE lpNew = NULL;                                    // buffer allocated within this function
    DWORD dwSaveCharPos;
    PCLIENTIMC pClientImc;
    DWORD dwCodePage;

#define SEND_MESSAGE(bAnsi)   ((bAnsi) ? SendMessageA : SendMessageW)

    //////////////////////////////////////////////
    // Parameter checking

    // check wParam as sub messages
    if (wParam == 0 || wParam > IMR_DOCUMENTFEED) {  // wParam is not a proper sub message
        RIPMSG1(RIP_WARNING, "ImmRequestMessageWorker: wParam(%lx) out of range.", wParam);
        return 0L;
    }

    // Check if the pointer which is given through lParam points the proper memory block.
    UserAssert(bAnsiOrigin == 0 || bAnsiOrigin == 1);   // we'll use bAnsiOrigin as an index

    // The first sub message IMR_COMPOSITIONWINDOW is 1, so substract 1 from wParam
    if (lpReq && IsBadWritePtr(lpReq, nReqBufSize[bAnsiOrigin][wParam - 1])) {
        RIPMSG0(RIP_WARNING, "ImmRequestMessageWorker: Bad pointer passed from IME to write");
        return 0L;
    }

    // check the lpReq(==lParam): the spec does not allow lParam as NULL
    // except IMR_RECONVERTSTRING and IMR_DOCUMENTFEED
    if (wParam == IMR_RECONVERTSTRING || wParam == IMR_DOCUMENTFEED) {
        //
        // check version number
        //
        if (lpReq != NULL) {
            LPRECONVERTSTRING lpReconv = (LPRECONVERTSTRING)lParam;
            if (lpReconv->dwVersion != 0) {
                RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid version number: %d",
                        lpReconv->dwVersion);
                return 0L;
            }
            if (lpReconv->dwSize < sizeof(RECONVERTSTRING)) {
                RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid dwSize: %d",
                        lpReconv->dwSize);
                return 0L;
            }
        }
    } else if (wParam == IMR_CONFIRMRECONVERTSTRING) {
        // check if lParam is not NULL, and version of the structure is correct.
        if (lpReq == NULL || ((LPRECONVERTSTRING)lpReq)->dwVersion != 0) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid argument or invalid version number");
            return 0L;
        }
    } else if (lpReq == NULL) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING,
                "ImmRequestMessageWorker: lParam should not be NULL with this wParam(%lx).",
                wParam);
        return 0L;
    }
    // end parameter checking
    ////////////////////////////////////////////

    pClientImc = ImmLockClientImc(hIMC);
    if (pClientImc != NULL) {
        dwCodePage = CImcCodePage(pClientImc);
        ImmUnlockClientImc(pClientImc);
    }
    else {
        dwCodePage = CP_ACP;
    }

    // allocate and prepare required buffer if we need A/W conversion
    switch (wParam) {
    case IMR_CONFIRMRECONVERTSTRING:
    case IMR_RECONVERTSTRING:
    case IMR_DOCUMENTFEED:
        if (bAnsiOrigin != bAnsiTarget) {
            if (lpReq != NULL) {
                // IME wants not only the buffer size but the real reconversion information
                DWORD dwSize = ImmGetReconvertTotalSize(((LPRECONVERTSTRING)lpReq)->dwSize, FROM_IME, bAnsiTarget);
                LPRECONVERTSTRING lpReconv;

                lpNew = ImmLocalAlloc(0, dwSize + sizeof(WCHAR));
                if (lpNew == NULL) {
                    RIPMSG0(RIP_WARNING, "ImmRequestMessageWorker: failed to allocate a buffer for reconversion.");
                    return 0L;
                }
                lpReconv = (LPRECONVERTSTRING)lpNew;
                // setup the information in the allocated structure
                lpReconv->dwVersion = 0;
                lpReconv->dwSize = dwSize;

                //
                // if it's confirmation message, we need to translate the contents
                //
                if (wParam == IMR_CONFIRMRECONVERTSTRING) {
                    ImmReconversionWorker(lpReconv, (LPRECONVERTSTRING)lParam, bAnsiTarget, dwCodePage);
                }
            }
        }
        break;

    case IMR_COMPOSITIONFONT:
        UserAssert(lpReq != NULL);      // has been checked so far
        if (bAnsiOrigin != bAnsiTarget) {
            if (bAnsiTarget) {
                lpNew = ImmLocalAlloc(0, sizeof(LOGFONTA));
            } else {
                lpNew = ImmLocalAlloc(0, sizeof(LOGFONTW));
            }
            if (lpNew == NULL) {
                RIPMSG0(RIP_WARNING, "ImmRequestMessageWorker: IMR_COMPOSITIONFONT: failed to allocate memory for A/W conversion.");
                return 0L;
            }
        }
        break;

    case IMR_QUERYCHARPOSITION:
        UserAssert(lpReq != NULL);
        if (bAnsiOrigin != bAnsiTarget) {
#define lpIMEPOS    ((LPIMECHARPOSITION)lParam)
            LPVOID lpstr;
            DWORD dwLen;

            dwSaveCharPos = lpIMEPOS->dwCharPos;

            dwLen = (!bAnsiOrigin ? ImmGetCompositionStringW : ImmGetCompositionStringA)(hIMC, GCS_COMPSTR, 0, 0);
            if (dwLen == 0) {
                RIPMSG0(RIP_WARNING, "ImmRequestMessageWorker: IMR_QUERYCHARPOSITION no compositiong string.");
                return 0L;
            }

            lpstr = ImmLocalAlloc(0, (dwLen + 1) * (!bAnsiOrigin ? sizeof(WCHAR) : sizeof(CHAR)));
            if (lpstr == NULL) {
                RIPMSG0(RIP_WARNING, "ImmRequestMessageWorker: IMR_QUERYCHARPOSITION: failed to allocate memory for A/W conversion.");
                return 0L;
            }

            (!bAnsiOrigin ? ImmGetCompositionStringW : ImmGetCompositionStringA)(hIMC, GCS_COMPSTR, lpstr, dwLen);
            if (bAnsiTarget) {
                lpIMEPOS->dwCharPos = CalcCharacterPositionWtoA(lpIMEPOS->dwCharPos, lpstr, dwCodePage);
            } else {
                lpIMEPOS->dwCharPos = CalcCharacterPositionAtoW(lpIMEPOS->dwCharPos, lpstr, dwCodePage);
            }

            ImmLocalFree(lpstr);
        }
        break;

    default:
        UserAssert(lpReq != NULL);      // has been checked so far
        break;
    }

    if (lpNew) {
        // if we allocated the buffer, let lpReq point it; lpNew is used later to free memory
        lpReq = lpNew;
    }

    //////////////////////////////////
    lRet = SEND_MESSAGE(bAnsiTarget)(HW(pwnd), WM_IME_REQUEST, wParam, (LPARAM)lpReq);
    //////////////////////////////////

    // copy back the results from WinProc to IME's buffer (only if conversion is needed)
    if (bAnsiOrigin != bAnsiTarget) {
        switch (wParam) {
        case IMR_RECONVERTSTRING:
        case IMR_DOCUMENTFEED:
            // Note: by definition, we don't have to do back-conversion for IMR_CONFIRMRECONVERTSTRING
            if (lRet != 0) {
                // IME wants the buffer size
                lRet = ImmGetReconvertTotalSize((DWORD)lRet, FROM_APP, bAnsiTarget);
                if (lRet < sizeof(RECONVERTSTRING)) {
                    RIPMSG1(RIP_WARNING, "ImmRequestMessageWorker: return value from application %d is invalid.", lRet);
                    lRet = 0;
                } else if (lpReq) {
                    // We need to perform the A/W conversion of the contents
                    if (!ImmReconversionWorker((LPRECONVERTSTRING)lParam, (LPRECONVERTSTRING)lpReq, bAnsiOrigin, dwCodePage)) {
                        lRet = 0;   // Error !
                    }
                }
            }
            break;
        case IMR_COMPOSITIONFONT:
            if (bAnsiOrigin) {
                LFontWtoLFontA((LPLOGFONTW)lpNew, (LPLOGFONTA)lParam);
            } else {
                LFontAtoLFontW((LPLOGFONTA)lpNew, (LPLOGFONTW)lParam);
            }
            break;
        case IMR_QUERYCHARPOSITION:
            UserAssert((LPVOID)lParam != NULL);
            lpIMEPOS->dwCharPos = dwSaveCharPos;
    #undef lpIMEPOS
            break;
        default:
            break;
        }

    }
    if (lpNew) {
        // buffer has been allocated, free it before returning
        ImmLocalFree(lpNew);
    }
    return lRet;
}

/**************************************************************************\
* ImmRequestMessage: Send WM_IME_REQUEST message to the given HIMC window
*
* IME function
*
* 27-Feb-1997 hiroyama      Created
\**************************************************************************/
LRESULT ImmRequestMessageAorW(HIMC hIMC, WPARAM wParam, LPARAM lParam, BOOL bAnsiOrigin)
{
    LPINPUTCONTEXT lpInputContext;
    PWND pwnd;
    LRESULT lRet = 0L;
    DWORD dwThreadId = GetInputContextThread(hIMC);

    if (dwThreadId != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmRequestMessageAorW:: Invalid input context access %lx.", hIMC);
        return lRet;
    }

    if (hIMC == NULL || (lpInputContext = ImmLockIMC(hIMC)) == NULL) {
        RIPMSG1(RIP_WARNING, "ImmRequestMessage: Invalid hImc %lx.", hIMC);
        return 0L;
    }

    // check if the window of the input context is valid
    if ((pwnd = ValidateHwnd(lpInputContext->hWnd)) == NULL) {
        RIPMSG1(RIP_WARNING, "ImmRequestMessage: Invalid hWnd %lx.", lpInputContext->hWnd);
    } else {
        // check if the message is being sent inter thread
        if (PtiCurrent() != GETPTI(pwnd)) {
            RIPMSG0(RIP_WARNING, "ImmRequestMessage: IME Attempt to send IMR_ message to different thread.");
        } else {
            lRet = ImmRequestMessageWorker(hIMC, pwnd, wParam, lParam, bAnsiOrigin);
        }
    }

    ImmUnlockIMC(hIMC);

    return lRet;
}

LRESULT WINAPI ImmRequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam)
{
    return ImmRequestMessageAorW(hIMC, wParam, lParam, TRUE /* ANSI */);
}

LRESULT WINAPI ImmRequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam)
{
    return ImmRequestMessageAorW(hIMC, wParam, lParam, FALSE /* not ANSI */);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\com.c ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    com.c

Abstract:

    This file implements the COM entry.

Author:

Revision History:

Notes:

--*/

#include "precomp.h"
#define COBJMACROS
#include "msctf.h"
#include "tlapi.h"
#include "apcompat.h"


#ifdef CUAS_ENABLE

#ifndef RtlIsThreadWithinLoaderCallout 
BOOLEAN NTAPI RtlIsThreadWithinLoaderCallout (VOID);
#endif

HRESULT CtfAImmCreateInputContext(HIMC himc);
HRESULT ActivateOrDeactivateTIM( BOOL fActivate);
DWORD GetCoInitCountSkip();
DWORD IncCoInitCountSkip();
DWORD DecCoInitCountSkip();
HRESULT Internal_CoInitializeEx(void* pv, DWORD dw);


//+---------------------------------------------------------------------------
//
// For InitializeSpy
//
//----------------------------------------------------------------------------

typedef struct _IMMISPY
{
  IInitializeSpy;
  ULONG cref;
} IMMISPY;

//+---------------------------------------------------------------------------
//
// CTFIMMTLS
//
//----------------------------------------------------------------------------

typedef struct _CTFIMMTLS
{
    IMMISPY *pimmispy;
    ULARGE_INTEGER uliISpyCookie;
    DWORD dwInRefCountSkipMode;
    DWORD dwRefCountSkip;
    BOOL  fInCtfImmCoUninitialize;
} CTFIMMTLS;

CTFIMMTLS* GetTLS();

IMMISPY *AllocIMMISPY();
void DeleteIMMISPY(IMMISPY *pimmispy);

//+---------------------------------------------------------------------------
//
// _InsideLoaderLock()
//
//----------------------------------------------------------------------------

BOOL _InsideLoaderLock()
{
    return (NtCurrentTeb()->ClientId.UniqueThread ==
           ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread);
}

//+---------------------------------------------------------------------------
//
// PImmISpyFromPISpy
//
//----------------------------------------------------------------------------

IMMISPY *PImmISpyFromPISpy(IInitializeSpy *pispy)
{
    return (IMMISPY *)pispy;
}

//+---------------------------------------------------------------------------
//
// ISPY_AddRef
//
//----------------------------------------------------------------------------

ULONG ISPY_AddRef(IInitializeSpy *pispy)
{
    IMMISPY *pimmispy = PImmISpyFromPISpy(pispy);

    pimmispy->cref++;
    return pimmispy->cref;
}

//+---------------------------------------------------------------------------
//
// ISPY_Release
//
//----------------------------------------------------------------------------

ULONG ISPY_Release(IInitializeSpy *pispy)
{
    IMMISPY *pimmispy = PImmISpyFromPISpy(pispy);

    pimmispy->cref--;
    if (!pimmispy->cref)
    {
        DeleteIMMISPY(pimmispy);
        return 0;
    }

    return pimmispy->cref;
}

//+---------------------------------------------------------------------------
//
// ISPY_QueryInterface
//
//----------------------------------------------------------------------------

HRESULT ISPY_QueryInterface(IInitializeSpy *pispy,
                            REFIID riid,
                            void **ppvObject)
{

    if (!ppvObject)
        return E_INVALIDARG;

    *ppvObject = NULL;

    if (IsEqualIID(riid, &IID_IUnknown) ||
        IsEqualIID(riid, &IID_IInitializeSpy))
    {
        ISPY_AddRef(pispy);
        *ppvObject = pispy;
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
// ISPY_PreInitialize
//
//----------------------------------------------------------------------------

HRESULT ISPY_PreInitialize(IInitializeSpy * pispy,
                           DWORD dwCoInit,
                           DWORD dwCurThreadAptRefs)
{
    DWORD dwRet = IncCoInitCountSkip();

    UNREFERENCED_PARAMETER(pispy);

    //
    // If we already initialize com and a 2nd initialization is MT,
    // we should disable CUAS. So the CoInit(MT) from caller will work.
    //
    if (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED)
    {
        if ((dwCurThreadAptRefs == (dwRet + 1)) &&  
            (dwCoInit == COINIT_MULTITHREADED))
        {
             ActivateOrDeactivateTIM(FALSE);
             CtfImmCoUninitialize();
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ISPY_PostInitialize
//
//----------------------------------------------------------------------------

HRESULT ISPY_PostInitialize(IInitializeSpy * pispy,
                            HRESULT hrCoInit,
                            DWORD dwCoInit,
                            DWORD dwNewThreadAptRefs)
{
    DWORD dwRet = GetCoInitCountSkip();
    UNREFERENCED_PARAMETER(pispy);
    UNREFERENCED_PARAMETER(dwCoInit);

    //
    // If we already initialize com and got a 2nd initialization,
    // change the return value to S_OK. So the caller think
    // that it is the first initialization.
    //
    if (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED)
    {
        if ((hrCoInit == S_FALSE) && (dwNewThreadAptRefs == (dwRet + 2)))
        {
            return S_OK;
        }
    }

    return hrCoInit;
}

//+---------------------------------------------------------------------------
//
// ISPY_PreUninitialize
//
//----------------------------------------------------------------------------

HRESULT ISPY_PreUninitialize(IInitializeSpy * pispy,
                             DWORD dwCurThreadAptRefs)
{
    UNREFERENCED_PARAMETER(pispy);
    UNREFERENCED_PARAMETER(dwCurThreadAptRefs);

    //
    // #607467
    //
    // Norton Systemworks setup calls CoUninitialize() without calling
    // CoInitialize(). So we got under ref problem.
    // If the last ref count is ours, we recover it by calling
    // CoInitializeEx().
    //
    if (dwCurThreadAptRefs == 1)
    {
        if (!RtlDllShutdownInProgress() &&
            !_InsideLoaderLock() &&
            (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED))
        {
            CTFIMMTLS* ptls = GetTLS();
            if (ptls && !ptls->fInCtfImmCoUninitialize)
            {
                Internal_CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
            }
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ISPY_PostUninitialize
//
//----------------------------------------------------------------------------

HRESULT ISPY_PostUninitialize(IInitializeSpy * pispy,
                              DWORD dwNewThreadAptRefs)
{
    UNREFERENCED_PARAMETER(pispy);
    UNREFERENCED_PARAMETER(dwNewThreadAptRefs);

    DecCoInitCountSkip();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// g_vtbnlISPY
//
//----------------------------------------------------------------------------

IInitializeSpyVtbl g_vtblISPY = {
    ISPY_QueryInterface,
    ISPY_AddRef,
    ISPY_Release,
    ISPY_PreInitialize,
    ISPY_PostInitialize,
    ISPY_PreUninitialize,
    ISPY_PostUninitialize,
};

//+---------------------------------------------------------------------------
//
// AllocIMMISPY
//
//----------------------------------------------------------------------------

IMMISPY *AllocIMMISPY()
{
    IMMISPY *pimmispy = ImmLocalAlloc(0, sizeof(IMMISPY));
    if (!pimmispy)
        return NULL;

    pimmispy->lpVtbl = &g_vtblISPY;
    pimmispy->cref = 1;

    return pimmispy;
}

//+---------------------------------------------------------------------------
//
// DeletIMMISPY
//
//----------------------------------------------------------------------------

void DeleteIMMISPY(IMMISPY *pimmispy)
{
    ImmLocalFree(pimmispy);
}


//////////////////////////////////////////////////////////////////////////////
//
// TLS
//
//////////////////////////////////////////////////////////////////////////////

DWORD g_dwTLSIndex = (DWORD)-1;

//+---------------------------------------------------------------------------
//
// InitTLS
//
//----------------------------------------------------------------------------

void InitTLS()
{
    RtlEnterCriticalSection(&gcsImeDpi);
    if (g_dwTLSIndex == (DWORD)-1)
        g_dwTLSIndex = TlsAlloc();
    RtlLeaveCriticalSection(&gcsImeDpi);
}

//+---------------------------------------------------------------------------
//
// InternalAllocateTLS
//
//----------------------------------------------------------------------------

CTFIMMTLS* InternalAllocateTLS()
{
    CTFIMMTLS* ptls;

    if (g_dwTLSIndex == (DWORD)-1)
        return NULL;

    ptls = (CTFIMMTLS*)TlsGetValue(g_dwTLSIndex);
    if (ptls == NULL)
    {
        if ((ptls = (CTFIMMTLS*)ImmLocalAlloc(HEAP_ZERO_MEMORY, 
                                              sizeof(CTFIMMTLS))) == NULL)
            return NULL;

        if (!TlsSetValue(g_dwTLSIndex, ptls))
        {
            ImmLocalFree(ptls);
            return NULL;
        }
    }
    return ptls;
}

//+---------------------------------------------------------------------------
//
// GetTLS
//
//----------------------------------------------------------------------------

CTFIMMTLS* GetTLS()
{
    if (g_dwTLSIndex == (DWORD)-1)
        return NULL;

    return (CTFIMMTLS*)TlsGetValue(g_dwTLSIndex);
}

//+---------------------------------------------------------------------------
//
// CtfImmEnterCoInitCountSkipMode
//
//----------------------------------------------------------------------------

BOOL WINAPI CtfImmEnterCoInitCountSkipMode()
{
    CTFIMMTLS* ptls = GetTLS();
    if (!ptls)
        return FALSE;

    ptls->dwInRefCountSkipMode++;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CtfImmLeaveCoInitCountSkip
//
//----------------------------------------------------------------------------

BOOL WINAPI CtfImmLeaveCoInitCountSkipMode()
{
    CTFIMMTLS* ptls = GetTLS();
    if (!ptls)
        return FALSE;

    if (ptls->dwInRefCountSkipMode < 1)
    {
        UserAssert(0);
        return FALSE;
    }

    ptls->dwInRefCountSkipMode--;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetCoInitCountSkip
//
//----------------------------------------------------------------------------

DWORD GetCoInitCountSkip()
{
    CTFIMMTLS* ptls = GetTLS();
    if (!ptls)
        return 0;

    return ptls->dwRefCountSkip;
}

//+---------------------------------------------------------------------------
//
// IncCoInitCountSkip
//
//----------------------------------------------------------------------------

DWORD IncCoInitCountSkip()
{
    DWORD dwRet = 0;
    CTFIMMTLS* ptls = GetTLS();
    if (!ptls)
        return dwRet;

    dwRet = ptls->dwRefCountSkip;
    if (ptls->dwInRefCountSkipMode)
        ptls->dwRefCountSkip++;

    return dwRet;
}

//+---------------------------------------------------------------------------
//
// DecCoInitCountSkip
//
//----------------------------------------------------------------------------

DWORD DecCoInitCountSkip()
{
    DWORD dwRet = 0;
    CTFIMMTLS* ptls = GetTLS();
    if (!ptls)
        return dwRet;

    dwRet = ptls->dwRefCountSkip;
    if (ptls->dwInRefCountSkipMode)
    {
        if (ptls->dwRefCountSkip < 1)
        {
            UserAssert(0);
            return dwRet;
        }
        ptls->dwRefCountSkip--;
    }
    return dwRet;
}

//+---------------------------------------------------------------------------
//
// InternalDestroyTLS
//
//----------------------------------------------------------------------------

BOOL InternalDestroyTLS()
{
    CTFIMMTLS* ptls;

    ptls = (CTFIMMTLS*)TlsGetValue(g_dwTLSIndex);
    if (ptls != NULL)
    {
        ImmLocalFree(ptls);
        TlsSetValue(g_dwTLSIndex, NULL);
        return TRUE;
    }
    return FALSE;
}


/*
 * Text frame service processing is disabled for all the thread in the current process
 */
BOOL g_disable_CUAS_flag = FALSE;

//+---------------------------------------------------------------------------
//
// delay load
//
//----------------------------------------------------------------------------

FARPROC GetFn(HINSTANCE *phInst, TCHAR *pchLib, char *pchFunc)
{
    if (*phInst == NULL)
    {
        *phInst = LoadLibrary(pchLib);
        if (*phInst == NULL)
        {
            UserAssert(0);
            return NULL;
        }
    }

    return GetProcAddress(*phInst, pchFunc);
}


HINSTANCE g_hOle32 = NULL;

HRESULT Internal_CoInitializeEx(void* pv, DWORD dw)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hOle32 == NULL) {
        pfn = GetFn(&g_hOle32, L"ole32.dll", "CoInitializeEx");
        if (pfn == NULL) {
            UserAssert(0);
            return E_FAIL;
        }
    }
    return (HRESULT)(*pfn)(pv, dw);
}

void Internal_CoUninitialize()
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hOle32 == NULL) {
        pfn = GetFn(&g_hOle32, L"ole32.dll", "CoUninitialize");
        if (pfn == NULL) {
            UserAssert(0);
            return;
        }
    }
    (*pfn)();
}


HRESULT Internal_CoRegisterInitializeSpy(LPINITIALIZESPY pSpy, 
                                         ULARGE_INTEGER *puliCookie)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hOle32 == NULL) {
        pfn = GetFn(&g_hOle32, L"ole32.dll", "CoRegisterInitializeSpy");
        if (pfn == NULL) {
            UserAssert(0);
            return E_FAIL;
        }
    }
    return (HRESULT)(*pfn)(pSpy, puliCookie);
}

HRESULT Internal_CoRevokeInitializeSpy(ULARGE_INTEGER uliCookie)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hOle32 == NULL) {
        pfn = GetFn(&g_hOle32, L"ole32.dll", "CoRevokeInitializeSpy");
        if (pfn == NULL) {
            UserAssert(0);
            return E_FAIL;
        }
    }
    return (HRESULT)(*pfn)(uliCookie);
}



HINSTANCE g_hMsctf = NULL;

HRESULT Internal_TF_CreateLangBarMgr(ITfLangBarMgr** pv)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hMsctf == NULL) {
        pfn = GetFn(&g_hMsctf, L"msctf.dll", "TF_CreateLangBarMgr");
        if (pfn == NULL) {
            UserAssert(0);
            return E_FAIL;
        }
    }
    return (HRESULT)(*pfn)(pv);
}

DWORD Internal_TF_CicNotify(int nCode, WPARAM wParam, LPARAM lParam)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hMsctf == NULL) {
        pfn = GetFn(&g_hMsctf, L"msctf.dll", "TF_CicNotify");
        if (pfn == NULL) {
            UserAssert(0);
            return E_FAIL;
        }
    }
    return (DWORD)(*pfn)(nCode, wParam, lParam);
}


#if 0
HINSTANCE g_hNtdll = NULL;

BOOLEAN Internal_RtlIsThreadWithinLoaderCallout(VOID)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hNtdll == NULL) {
        pfn = GetFn(&g_hNtdll, L"ntdll.dll", "RtlIsThreadWithinLoaderCallout");
        if (pfn == NULL) {
            UserAssert(0);
            return FALSE;
        }
    }
    return (BOOLEAN)(*pfn)();
}
#endif


//+---------------------------------------------------------------------------
//
// CtfImmCoInitialize
//
//----------------------------------------------------------------------------

HRESULT
CtfImmCoInitialize()
{
    //
    // CoInitializeEx
    //
    HRESULT hr = E_NOINTERFACE;

    //
    // Check CI flag
    //
    if (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED) 
        return S_OK;

    hr = Internal_CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hr))
    {
        RIPMSG0(RIP_VERBOSE, "CtfImmCoInitialize succeeded.");

        //
        // Set CI flag
        //
        GetClientInfo()->CI_flags |= CI_CUAS_COINIT_CALLED;

        {
            CTFIMMTLS* ptls;
            //
            // Initialize CoInitSpy.
            //
            InitTLS();
            ptls = InternalAllocateTLS();

            if (ptls && !ptls->pimmispy)
            {
                ptls->pimmispy = AllocIMMISPY();
                if (ptls->pimmispy)
                {
                    HRESULT hrTemp;
                    hrTemp = Internal_CoRegisterInitializeSpy((LPINITIALIZESPY)ptls->pimmispy,
                                                          &(ptls->uliISpyCookie));

                    if (FAILED(hrTemp))
                    {
                        DeleteIMMISPY(ptls->pimmispy);
                        ptls->pimmispy = NULL;
                        memset(&ptls->uliISpyCookie, 0, sizeof(ULARGE_INTEGER));

                    }
                }
            }
        }

        hr = S_OK;
    }
    else
    {
        RIPMSG1(RIP_WARNING, "CtfImmCoInitialize failed. err=%x", hr);
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
// CtfImmCoUninitialize
//
//----------------------------------------------------------------------------

void WINAPI
CtfImmCoUninitialize()
{
    if (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED)
    {
        CTFIMMTLS* ptls = GetTLS();
        if (ptls)
        {
             ptls->fInCtfImmCoUninitialize = TRUE;
             Internal_CoUninitialize();
             ptls->fInCtfImmCoUninitialize = FALSE;
             GetClientInfo()->CI_flags &= ~CI_CUAS_COINIT_CALLED;
        }

        {
            CTFIMMTLS* ptls;
            //
            // revoke initialize spy
            //
            ptls = InternalAllocateTLS();
            if (ptls && ptls->pimmispy)
            {
                Internal_CoRevokeInitializeSpy(ptls->uliISpyCookie);
                ISPY_Release((IInitializeSpy *)ptls->pimmispy);
                ptls->pimmispy = NULL;
                memset(&ptls->uliISpyCookie, 0, sizeof(ULARGE_INTEGER));
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
// CtfImmTIMActivate
//
//----------------------------------------------------------------------------

HRESULT
CtfImmTIMActivate(
    HKL hKL)
{
    HRESULT hr = S_OK;

    /*
     * Text frame service processing is disabled for all the thread in the current process
     */
    if (g_disable_CUAS_flag) {
        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: g_disable_CUAS_flag is ON.");
        /*
         * set client info flag.
         */
        GetClientInfo()->CI_flags |= CI_CUAS_DISABLE;
        return hr;
    }

    /*
     * Check client info flag.
     */
    if (GetClientInfo()->CI_flags & CI_CUAS_DISABLE) {
        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: CI_CUAS_DISABLE is ON.");
        return hr;
    }

    /*
     * Check Disable Advanced Text Services switch.
     * If it is On, doesn't activate TIM.
     */
    if (IsDisabledTextServices()) {
        /*
         * set client info flag.
         */
        GetClientInfo()->CI_flags |= CI_CUAS_DISABLE;

        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: Disabled Text Services.");
        return hr;
    }

    /*
     * Check a interactive user logon.
     */
    if (!IsInteractiveUserLogon() || IsRunningInMsoobe()) {
        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: Not a interactive user logon. or MSOOBE mode");
        return hr;
    }

    /*
     * Check CUAS switch. If CUAS is OFF, doesn't activate TIM.
     */
    if (! IsCUASEnabled()) {
        /*
         * If AIMM enabled, then return S_OK;
         */
        DWORD dwImeCompatFlags = ImmGetAppCompatFlags(NULL);
        if (dwImeCompatFlags & (IMECOMPAT_AIMM12 | IMECOMPAT_AIMM_LEGACY_CLSID | IMECOMPAT_AIMM12_TRIDENT)) {
            return S_OK;
        }

        /*
         * set client info flag.
         */
        GetClientInfo()->CI_flags |= CI_CUAS_DISABLE;

        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: CUAS switch is OFF.");
        return hr;
    }

    /*
     *  
     *  KACF_DISABLECICERO is already defined in private/Lab06_DEV
     *  we will use this flag later.
     *  
     *    APPCOMPATFLAG(KACF_DISABLECICERO)
     *    KACF_DISABLECICERO is 0x100
     */
    #ifndef KACF_DISABLECICERO
    #define KACF_DISABLECICERO 0x00000100    // If set. Cicero support for the current process
                                             // is disabled.
    #endif

    if (APPCOMPATFLAG(KACF_DISABLECICERO)) {
        /*
         * set client info flag.
         */
        GetClientInfo()->CI_flags |= CI_CUAS_DISABLE;

        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: KACF_DISABLECICERO app compatiblity flag is ON.");
        return hr;
    }

    if (RtlIsThreadWithinLoaderCallout())
    {
        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: we're in DllMain().");
        return hr;
    }

    if (_InsideLoaderLock()) {
        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: we're in DllMain.");
        return hr;
    }

    if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
        HINSTANCE hCtf = NULL;

        if (IS_IME_KBDLAYOUT(hKL)) {
             LANGID lg = LOWORD(HandleToUlong(hKL));
             hKL = (HKL)LongToHandle( MAKELONG(lg, lg) );
        }

        if (!ImmLoadIME(hKL)) {
            //
            RIPMSG1(RIP_VERBOSE, "CtfImmTIMActivate: ImmLoadIME=%lx fail.", hKL);
            //
            // Cicero keyboard layout doesn't loaded yet.
            // MSCTF ! TF_InvalidAssemblyListCacheIfExist load Cicero assembly.
            //
            hCtf = LoadLibrary(TEXT("msctf.dll"));
            if (hCtf) {
                typedef BOOL (WINAPI* PFNINVALIDASSEMBLY)();
                PFNINVALIDASSEMBLY pfn;
                pfn = (PFNINVALIDASSEMBLY)GetProcAddress(hCtf, "TF_InvalidAssemblyListCacheIfExist");
                if (pfn) {
                    pfn();
                }
            }
        }

        /*
         * Initialize COM for Cicero IME.
         */
        CtfImmCoInitialize();

        if (  (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED) &&
            ! (GetClientInfo()->CI_flags & CI_CUAS_TIM_ACTIVATED)) {
            /*
             * Create and Activate TIM
             */
            hr = Internal_CtfImeCreateThreadMgr();
            if (SUCCEEDED(hr)) {
                GetClientInfo()->CI_flags |= CI_CUAS_TIM_ACTIVATED;
                RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: Succeeded CtfImeCreateThreadMgr.");
            }
            else {
                RIPMSG0(RIP_WARNING, "CtfImmTIMActivate: Fail CtfImeCreateThreadMgr.");
            }
        }

        if (hCtf) {
            FreeLibrary(hCtf);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfImmTIMCreateInputContext
//
//----------------------------------------------------------------------------

HRESULT
CtfImmTIMCreateInputContext(
    HIMC hImc)
{
    PCLIENTIMC pClientImc;
    HRESULT hr = S_FALSE;
    DWORD dwThreadId;

    if (GetClientInfo()->CI_flags & CI_CUAS_AIMM12ACTIVATED)
    {
        if ((pClientImc = ImmLockClientImc(hImc)) == NULL)
            return E_FAIL;

        /*
         * check fCtfImeContext first
         */
        if (pClientImc->fCtfImeContext) 
            goto Exit;

        pClientImc->fCtfImeContext = TRUE;
        hr = CtfAImmCreateInputContext(hImc);
        if (SUCCEEDED(hr)) {
            RIPMSG0(RIP_VERBOSE, "CtfImmTIMCreateInputContext: Succeeded CtfImeCreateInputContext.");
        }
        else {
            pClientImc->fCtfImeContext = FALSE;

            RIPMSG0(RIP_WARNING, "CtfImmTIMCreateInputContext: Fail CtfImeCreateInputContext.");
        }
        goto Exit;
    }

    if (!(GetClientInfo()->CI_flags & CI_CUAS_TIM_ACTIVATED))
    {
        //
        // Tim is not activated. We don't have to create the InputContext.
        //
        return S_OK;
    }

    if ((pClientImc = ImmLockClientImc(hImc)) == NULL)
        return E_FAIL;

    /*
     * check fCtfImeContext first
     */
    if (pClientImc->fCtfImeContext) 
        goto Exit;

    dwThreadId = GetInputContextThread(hImc);
    if (dwThreadId != GetCurrentThreadId())
        goto Exit;

    if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
            /*
             * Set fCtfImeContext before calling ctfime to avoid recursion 
             * call.
             */
            pClientImc->fCtfImeContext = TRUE;

            /*
             * Create Input Context
             */
            hr = Internal_CtfImeCreateInputContext(hImc);
            if (SUCCEEDED(hr)) {
                RIPMSG0(RIP_VERBOSE, "CtfImmTIMCreateInputContext: Succeeded CtfImeCreateInputContext.");
            }
            else {
                pClientImc->fCtfImeContext = FALSE;

                RIPMSG0(RIP_WARNING, "CtfImmTIMCreateInputContext: Fail CtfImeCreateInputContext.");
            }
    }

Exit:
    ImmUnlockClientImc(pClientImc);

    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfImmTIMDestroyInputContext
//
//----------------------------------------------------------------------------

HRESULT
CtfImmTIMDestroyInputContext(
    HIMC hImc)
{
    HRESULT hr = E_NOINTERFACE;

    if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
        /*
         * Destroy Input Context.
         */
        hr = Internal_CtfImeDestroyInputContext(hImc);
        if (SUCCEEDED(hr)) {
            RIPMSG0(RIP_VERBOSE, "CtfImmTIMDestroyInputContext: Succeeded CtfImeDestroyInputContext.");
        }
        else {
            RIPMSG0(RIP_WARNING, "CtfImmTIMDestroyInputContext: Fail CtfImeDestroyInputContext.");
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfImmRestoreToolbarWnd
//
//----------------------------------------------------------------------------

void
CtfImmRestoreToolbarWnd(
    DWORD dwStatus)
{
    ITfLangBarMgr* plbm;

    if (SUCCEEDED(Internal_TF_CreateLangBarMgr(&plbm)))
    {
        if (dwStatus)
        {
            ITfLangBarMgr_ShowFloating(plbm, dwStatus);
        }
        ITfLangBarMgr_Release(plbm);
    }
    return;
}

//+---------------------------------------------------------------------------
//
// CtfImmHideToolbarWnd
//
//----------------------------------------------------------------------------

DWORD
CtfImmHideToolbarWnd()
{
    ITfLangBarMgr* plbm;
    DWORD _dwPrev = 0;

    if (SUCCEEDED(Internal_TF_CreateLangBarMgr(&plbm)))
    {
        if (SUCCEEDED(ITfLangBarMgr_GetShowFloatingStatus(plbm, &_dwPrev)))
        {
            BOOL fHide = TRUE;
            if (_dwPrev & TF_SFT_DESKBAND)
                fHide = FALSE;

            //
            // mask for show/hide
            //
            _dwPrev &= (TF_SFT_SHOWNORMAL |
                        TF_SFT_DOCK |
                        TF_SFT_MINIMIZED |
                        TF_SFT_HIDDEN);

            if (fHide)
                ITfLangBarMgr_ShowFloating(plbm, TF_SFT_HIDDEN);
        }
        ITfLangBarMgr_Release(plbm);
    }

    return _dwPrev;
}

//+---------------------------------------------------------------------------
//
// CtfImmGetGuidAtom
//
//----------------------------------------------------------------------------

HRESULT
CtfImmGetGuidAtom(HIMC hImc, BYTE bAttr, DWORD* pGuidAtom)
{
    HRESULT hr = E_FAIL;

    *pGuidAtom = 0;

    if (IS_CICERO_ENABLED_AND_NOT16BIT()) {

        PIMEDPI       pImeDpi;
        DWORD         dwImcThreadId = (DWORD)NtUserQueryInputContext(hImc, InputContextThread);
        HKL           hKL = GetKeyboardLayout(dwImcThreadId);

        if (IS_IME_KBDLAYOUT(hKL)) {
            RIPMSG1(RIP_WARNING, "CtfImmGetGuidAtom: hKL=%lx.", hKL);
            return FALSE;
        }

        pImeDpi = FindOrLoadImeDpi(hKL);
        if (pImeDpi == NULL) {
            RIPMSG0(RIP_WARNING, "CtfImmGetGuidAtom: no pImeDpi entry.");
        }
        else {
            /*
             * Get GUID atom value
             */
            hr = (*pImeDpi->pfn.CtfImeGetGuidAtom)(hImc, bAttr, pGuidAtom);
            if (SUCCEEDED(hr)) {
                RIPMSG0(RIP_VERBOSE, "CtfImmGetGuidAtom: Succeeded CtfImeGetGuidAtom.");
            }
            else {
                RIPMSG0(RIP_WARNING, "CtfImmGetGuidAtom: Fail CtfImeGetGuidAtom.");
            }
            ImmUnlockImeDpi(pImeDpi);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfImmIsGuidMapEnable
//
//----------------------------------------------------------------------------

BOOL
CtfImmIsGuidMapEnable(HIMC hImc)
{
    BOOL ret = FALSE;

    if (IS_CICERO_ENABLED_AND_NOT16BIT()) {

        PIMEDPI       pImeDpi;
        DWORD         dwImcThreadId = (DWORD)NtUserQueryInputContext(hImc, InputContextThread);
        HKL           hKL = GetKeyboardLayout(dwImcThreadId);

        if (IS_IME_KBDLAYOUT(hKL)) {
            RIPMSG1(RIP_WARNING, "CtfImmIsGuidMapEnable: hKL=%lx.", hKL);
            return FALSE;
        }

        pImeDpi = FindOrLoadImeDpi(hKL);
        if (pImeDpi == NULL) {
            RIPMSG0(RIP_WARNING, "CtfImmIsGuidMapEnable: no pImeDpi entry.");
        }
        else {
            /*
             * Get GUID atom value
             */
            ret = (*pImeDpi->pfn.CtfImeIsGuidMapEnable)(hImc);
            ImmUnlockImeDpi(pImeDpi);
        }
    }

    return ret;
}

//+---------------------------------------------------------------------------
//
// CtfImmSetAppCompatFlags
//
//----------------------------------------------------------------------------

DWORD g_aimm_compat_flags = 0;

VOID
CtfImmSetAppCompatFlags(
    DWORD dwFlag)
{
    if (dwFlag & ~(IMECOMPAT_AIMM_LEGACY_CLSID |
                   IMECOMPAT_AIMM_TRIDENT55 |
                   IMECOMPAT_AIMM12_TRIDENT |
                   IMECOMPAT_AIMM12))
    {
        return;
    }

    g_aimm_compat_flags = dwFlag;
}

//+---------------------------------------------------------------------------
//
// ActivateOrDeactivateTIM
//
//----------------------------------------------------------------------------

HRESULT
ActivateOrDeactivateTIM(
    BOOL fActivate)
{
    HRESULT hr = S_OK;

    if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
        if (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED) {
            if (! fActivate) {
                /*
                 * Deactivate TIM
                 */
                if (GetClientInfo()->CI_flags & CI_CUAS_TIM_ACTIVATED) {
                    hr = Internal_CtfImeDestroyThreadMgr();
                    if (SUCCEEDED(hr)) {
                        GetClientInfo()->CI_flags &= ~CI_CUAS_TIM_ACTIVATED;
                        RIPMSG0(RIP_VERBOSE, "CtfImmLastEnabledWndDestroy: Succeeded CtfImeDestroyThreadMgr.");
                    }
                    else {
                        RIPMSG0(RIP_WARNING, "CtfImmLastEnabledWndDestroy: Fail CtfImeDestroyThreadMgr.");
                    }

                }
            }
            else {
                /*
                 * Activate TIM
                 */
                if (! (GetClientInfo()->CI_flags & CI_CUAS_TIM_ACTIVATED)) {
                    hr = Internal_CtfImeCreateThreadMgr();
                    if (SUCCEEDED(hr)) {
                        GetClientInfo()->CI_flags |= CI_CUAS_TIM_ACTIVATED;
                        RIPMSG0(RIP_VERBOSE, "CtfImmLastEnabledWndDestroy: Succeeded CtfImeDestroyThreadMgr.");
                    }
                    else {
                        RIPMSG0(RIP_WARNING, "CtfImmLastEnabledWndDestroy: Fail CtfImeDestroyThreadMgr.");
                    }
                }
            }
        }

    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfImmLastEnabledWndDestroy
//     LPARAM 0 = Deactivate TIM.
//            ! 0 = Activate TIM.
//
//----------------------------------------------------------------------------

HRESULT 
CtfImmLastEnabledWndDestroy(
    LPARAM lParam)
{
    return ActivateOrDeactivateTIM(lParam ? TRUE : FALSE);
}

//+---------------------------------------------------------------------------
//
// ImmSetLangBand
//
//----------------------------------------------------------------------------

// TM_LANGUAGEBAND is defined in "shell\inc\trayp.h"
#define TM_LANGUAGEBAND     WM_USER+0x105

typedef struct _LANG_BAND {
    HWND hwndTray;
    BOOL fLangBand;
} LANG_BAND;

DWORD
DelaySetLangBand(
    LANG_BAND* langband)
{
    HWND hwndIME;

    //
    // Delay 3000msec.
    // If this delay value is not enough, Explorer takes CPU power 100%.
    // printui!CTrayNotify::_ResetAll
    //
    Sleep(3000);

    hwndIME = ImmGetDefaultIMEWnd(langband->hwndTray);
    if (hwndIME) {
        DWORD_PTR dwResult;
        LRESULT lResult = (LRESULT)0;

        lResult = SendMessageTimeout(hwndIME,
                                     WM_IME_SYSTEM,
                                     langband->fLangBand ? IMS_SETLANGBAND : IMS_RESETLANGBAND,
                                     (LPARAM)langband->hwndTray,
                                     SMTO_ABORTIFHUNG | SMTO_BLOCK,
                                     5000,
                                     &dwResult);

        //
        // Checking the language band setting fail case
        //
        if (!lResult || dwResult != langband->fLangBand)
        {
            // UserAssert(0);
        }
    }

    ImmLocalFree(langband);

    return 0;
}

LRESULT
CtfImmSetLangBand(
    HWND hwndTray,
    BOOL fLangBand)
{
    DWORD_PTR dwResult = 0;
    PWND pwnd;

    // check if the window of the Explorer Tray is valid
    if ((pwnd = ValidateHwnd(hwndTray)) == NULL) {
        RIPMSG1(RIP_WARNING, "CtfImmSetLangBand: Invalid hwndTray %lx.", hwndTray);
    } else {
        if (TestWF(pwnd, WFISINITIALIZED)) {    // TRUE if the Explorer Tray is initialized
            LRESULT lResult = (LRESULT)0;

            lResult = SendMessageTimeout(hwndTray,
                                         TM_LANGUAGEBAND,
                                         0,
                                         fLangBand,
                                         SMTO_ABORTIFHUNG | SMTO_BLOCK,
                                         5000,
                                         &dwResult);

            //
            // Checking the language band setting fail case
            //
            if (!lResult || dwResult != fLangBand)
            {
                // UserAssert(0);
            }
        }
        else {
            LANG_BAND* langband = (LANG_BAND*) ImmLocalAlloc(0, sizeof(LANG_BAND));
            if (langband != NULL) {
                HANDLE hThread;
                DWORD ThreadId;

                langband->hwndTray = hwndTray;
                langband->fLangBand = fLangBand;

                hThread = CreateThread(NULL,
                                       0,
                                       DelaySetLangBand,
                                       langband,
                                       0,
                                       &ThreadId);
                if (hThread) {
                    CloseHandle(hThread);
                }
            }
        }
    }
    return dwResult;
}

BOOL
CtfImmIsCiceroEnabled()
{
    return IS_CICERO_ENABLED();
}

BOOL
CtfImmIsCiceroStartedInThread()
{
    return (GetClientInfo()->CI_flags & CI_CUAS_MSCTF_RUNNING) ? TRUE : FALSE;
}

HRESULT
CtfImmSetCiceroStartInThread(BOOL fSet)
{
    if (fSet)
        GetClientInfo()->CI_flags |= CI_CUAS_MSCTF_RUNNING;
    else
        GetClientInfo()->CI_flags &= ~CI_CUAS_MSCTF_RUNNING;
    return S_OK;
}

BOOL
IsCUASEnabled()
{
    LONG lRet;
    HKEY hKeyCtf;
    DWORD dwType;
    DWORD dwCUAS;
    DWORD dwTmp;

    lRet = RegOpenKey(HKEY_LOCAL_MACHINE, gszRegCtfShared, &hKeyCtf);
    if ( lRet != ERROR_SUCCESS ) {
        return FALSE;
    }

    dwType = 0;
    dwCUAS = 0;
    dwTmp = sizeof(DWORD);
    lRet = RegQueryValueEx(hKeyCtf,
                           gszValCUASEnable,
                           NULL,
                           &dwType,
                           (LPBYTE)&dwCUAS,
                           &dwTmp);
    RegCloseKey(hKeyCtf);

    if ( lRet != ERROR_SUCCESS  ||  dwType != REG_DWORD) {
        return FALSE;
    }

    return (BOOL)dwCUAS;
}

//+---------------------------------------------------------------------------
//
// ImmDisableTextFrameService
//
//----------------------------------------------------------------------------

BOOL
ImmDisableTextFrameService(DWORD idThread)
{
    HRESULT hr = S_OK;

    if (idThread == -1)
    {
        // Text frame service processing is disabled for all the thread in the current process
        g_disable_CUAS_flag = TRUE;
    }

    if ((idThread == 0 || g_disable_CUAS_flag) &&
        (! (GetClientInfo()->CI_flags & CI_CUAS_DISABLE)))
    {
        /*
         * set client info flag.
         */
        GetClientInfo()->CI_flags |= CI_CUAS_DISABLE;

        if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
            if (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED) {
                /*
                 * Deactivate TIM
                 */
                if (GetClientInfo()->CI_flags & CI_CUAS_TIM_ACTIVATED) {
                    hr = Internal_CtfImeDestroyThreadMgr();
                    if (SUCCEEDED(hr)) {
                        GetClientInfo()->CI_flags &= ~CI_CUAS_TIM_ACTIVATED;
                        RIPMSG0(RIP_VERBOSE, "ImmDisableTextFrameService: Succeeded CtfImeDestroyThreadMgr.");
                    }
                    else {
                        RIPMSG0(RIP_WARNING, "ImmDisableTextFrameService: Fail CtfImeDestroyThreadMgr.");
                    }

                    if (SUCCEEDED(hr)) {
                        /*
                         * CoUninitialize
                         */
                        CtfImmCoUninitialize();
                    }
                }
            }
        }
    }

    return hr == S_OK ? TRUE : FALSE;
}

BOOL
CtfImmIsTextFrameServiceDisabled()
{
    return (GetClientInfo()->CI_flags & CI_CUAS_DISABLE) ? TRUE : FALSE;
}

BOOL
IsDisabledTextServices()
{
    static const TCHAR c_szCTFKey[]     = TEXT("SOFTWARE\\Microsoft\\CTF");
    static const TCHAR c_szDiableTim[]  = TEXT("Disable Thread Input Manager");

    HKEY hKey;

    if (RegOpenKey(HKEY_CURRENT_USER, c_szCTFKey, &hKey) == ERROR_SUCCESS)
    {
        DWORD cb;
        DWORD dwDisableTim = 0;

        cb = sizeof(DWORD);

        RegQueryValueEx(hKey,
                        c_szDiableTim,
                        NULL,
                        NULL,
                        (LPBYTE)&dwDisableTim,
                        &cb);

        RegCloseKey(hKey);

        //
        // Ctfmon disabling flag is set.
        //
        if (dwDisableTim)
            return TRUE;
    }

    return FALSE;
}

BOOL
IsInteractiveUserLogon()
{
    PSID InteractiveSid;
    BOOL bCheckSucceeded;
    BOOL bAmInteractive = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  1,
                                  SECURITY_INTERACTIVE_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &InteractiveSid))
    {
        return FALSE;
    }

    //
    // This checking is for logged on user or not. So we can blcok running
    // ctfmon.exe process from non-authorized user.
    //
    bCheckSucceeded = CheckTokenMembership(NULL,
                                           InteractiveSid,
                                           &bAmInteractive);

    if (InteractiveSid)
        FreeSid(InteractiveSid);

    return (bCheckSucceeded && bAmInteractive);
}

//+---------------------------------------------------------------------------
//
// IsRunningInMsoobe()
//
//----------------------------------------------------------------------------
BOOL IsRunningInMsoobe()
{
static const TCHAR c_szMsoobeModule[] = TEXT("msoobe.exe");

    TCHAR  szFileName[MAX_PATH];
    TCHAR szModuleName[MAX_PATH];
    LPTSTR pszFilePart = NULL;

    if (GetModuleFileName(NULL, szFileName, sizeof(szFileName)/sizeof(szFileName[0])) == 0)
        return FALSE;

    GetFullPathName(szFileName, 
                    sizeof(szFileName)/sizeof(szFileName[0]),
                    szModuleName,
                    &pszFilePart);

    if (pszFilePart == NULL)
        return FALSE;

    if (lstrcmpiW(pszFilePart, c_szMsoobeModule) == 0)
        return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// LoadCtfIme
//
//----------------------------------------------------------------------------

BOOL CheckAndApplyAppCompat(LPWSTR wszImeFile);

typedef HRESULT (CALLBACK* PFNCREATETHREADMGR)();
typedef HRESULT (CALLBACK* PFNDESTROYTHREADMGR)();
typedef HRESULT (CALLBACK* PFNCREATEINPUTCONTEXT)(HIMC);
typedef HRESULT (CALLBACK* PFNDESTROYINPUTCONTEXT)(HIMC);
typedef HRESULT (CALLBACK* PFNSETACTIVECONTEXTALWAYS)(HIMC, BOOL, HWND, HKL);
typedef BOOL    (CALLBACK* PFNPROCESSCICHOTKEY)(HIMC, UINT, LPARAM);
typedef LRESULT (CALLBACK* PFNDISPATCHDEFIMEMESSAGE)(HWND, UINT, WPARAM, LPARAM);
typedef BOOL    (CALLBACK* PFNIMEISIME)(HKL);



PFNCREATETHREADMGR           g_pfnCtfImeCreateThreadMgr = NULL;
PFNDESTROYTHREADMGR          g_pfnCtfImeDestroyThreadMgr = NULL;
PFNCREATEINPUTCONTEXT        g_pfnCtfImeCreateInputContext = NULL;
PFNDESTROYINPUTCONTEXT       g_pfnCtfImeDestroyInputContext= NULL;
PFNSETACTIVECONTEXTALWAYS    g_pfnCtfImeSetActiveContextAlways= NULL;
PFNPROCESSCICHOTKEY          g_pfnCtfImeProcessCicHotkey = NULL;
PFNDISPATCHDEFIMEMESSAGE     g_pfnCtfImeDispatchDefImeMessage = NULL;
PFNIMEISIME                  g_pfnCtfImeIsIME = NULL;

#define GET_CTFIMEPROC(x) \
    if (!(g_pfn##x = (PVOID) GetProcAddress(g_hCtfIme, #x))) {   \
        RIPMSG0(RIP_WARNING, "LoadCtfIme: " #x " not supported"); \
        goto LoadCtfIme_ErrOut; }

HMODULE g_hCtfIme = NULL; 

HMODULE LoadCtfIme()
{
    IMEINFOEX iiex;

    RtlEnterCriticalSection(&gcsImeDpi);

    if (g_hCtfIme)
        goto Exit;

    if (ImmLoadLayout((HKL)0x04090409, &iiex)) {
        WCHAR wszImeFile[MAX_PATH];

        GetSystemPathName(wszImeFile, iiex.wszImeFile, MAX_PATH);

        if (!CheckAndApplyAppCompat(wszImeFile)) {
            RIPMSG1(RIP_WARNING, "LoadCtfIme: IME (%ws) blocked by appcompat", wszImeFile);
        }
        else {
            g_hCtfIme = LoadLibraryW(wszImeFile);
            if (g_hCtfIme) {
                GET_CTFIMEPROC(CtfImeCreateThreadMgr);
                GET_CTFIMEPROC(CtfImeDestroyThreadMgr);
                GET_CTFIMEPROC(CtfImeCreateInputContext);
                GET_CTFIMEPROC(CtfImeDestroyInputContext);
                GET_CTFIMEPROC(CtfImeSetActiveContextAlways);
                GET_CTFIMEPROC(CtfImeProcessCicHotkey);
                GET_CTFIMEPROC(CtfImeDispatchDefImeMessage);
                GET_CTFIMEPROC(CtfImeIsIME);
            }
        }
    }
    goto Exit;

LoadCtfIme_ErrOut:
    if (g_hCtfIme) {
        FreeLibrary(g_hCtfIme);
        g_hCtfIme = NULL;
    }

Exit:

    RtlLeaveCriticalSection(&gcsImeDpi);
    return g_hCtfIme;
}


//+---------------------------------------------------------------------------
//
// CtfAImmCreateInputContext
//
//----------------------------------------------------------------------------

HRESULT CtfAImmCreateInputContext(HIMC himc)
{
    return Internal_CtfImeCreateInputContext(himc);
}

//+---------------------------------------------------------------------------
//
// EnumIMC
//
//----------------------------------------------------------------------------

BOOL EnumIMC(HIMC hIMC, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    CtfAImmCreateInputContext(hIMC);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CtfAImmActivate
//
//----------------------------------------------------------------------------

HRESULT CtfAImmActivate(HMODULE* phMod)
{
    HRESULT hr = E_FAIL;
    HMODULE hCtfIme = LoadCtfIme();

    hr = Internal_CtfImeCreateThreadMgr();
    if (hr == S_OK)
    {

        GetClientInfo()->CI_flags |= CI_CUAS_AIMM12ACTIVATED;

        /*
         * reset client info flag.
         * Bug#525583 - Reset CU_CUAS_DISABLE flag before create
         * the input context.
         */
        GetClientInfo()->CI_flags &= ~CI_CUAS_DISABLE;

        ImmEnumInputContext(0, EnumIMC, 0);
    }

    if (phMod)
        *phMod = hCtfIme;

    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfAImmDectivate
//
//----------------------------------------------------------------------------

HRESULT CtfAImmDeactivate(HMODULE hMod)
{
    HRESULT hr = E_FAIL;

    //
    // Load CTFIME and destroy TIM.
    //
    if (hMod)
    {
        hr = Internal_CtfImeDestroyThreadMgr();
        if (hr == S_OK)
        {
            GetClientInfo()->CI_flags &= ~CI_CUAS_AIMM12ACTIVATED;
            /*
             * set client info flag.
             */
            GetClientInfo()->CI_flags |= CI_CUAS_DISABLE;
        }
        //
        // Win BUG: 611569
        //
        // Don't call FreeLibrary because LoadCtfIme() hold CTFIME module handle in global.
        //
        // FreeLibrary(hMod);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfAImmIsIME
//
//----------------------------------------------------------------------------

BOOL CtfAImmIsIME(HKL hkl)
{
    if (LoadCtfIme())
        return (g_pfnCtfImeIsIME)(hkl);

    return ImmIsIME(hkl);
}

//+---------------------------------------------------------------------------
//
// CtfImmDispatchDefImeMessage
//
//----------------------------------------------------------------------------

LRESULT CtfImmDispatchDefImeMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{

    if (RtlDllShutdownInProgress() || _InsideLoaderLock())
        return 0;

    if (LoadCtfIme())
    {
        return (g_pfnCtfImeDispatchDefImeMessage)(hwnd, message, wParam, lParam);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
// Internal_CtfImeCreateThreadMgr
//
//----------------------------------------------------------------------------

HRESULT Internal_CtfImeCreateThreadMgr()
{
    if (!LoadCtfIme())
        return E_FAIL;

    return (g_pfnCtfImeCreateThreadMgr)();
}

//+---------------------------------------------------------------------------
//
// Internal_CtfImeDestroyThreadMgr
//
//----------------------------------------------------------------------------

HRESULT Internal_CtfImeDestroyThreadMgr()
{
    if (!LoadCtfIme())
        return E_FAIL;

    return (g_pfnCtfImeDestroyThreadMgr)();
}
            
//+---------------------------------------------------------------------------
//
// Internal_CtfImeProcessCicHotkey
//
//----------------------------------------------------------------------------

BOOL Internal_CtfImeProcessCicHotkey(HIMC hIMC, UINT uVKey, LPARAM lParam)
{
    if (!LoadCtfIme())
        return FALSE;

    return (g_pfnCtfImeProcessCicHotkey)(hIMC, uVKey, lParam);
}

//+---------------------------------------------------------------------------
//
// Internal_CtfImeCreateInputContext
//
//----------------------------------------------------------------------------

HRESULT Internal_CtfImeCreateInputContext(HIMC himc)
{
    if (!LoadCtfIme())
        return E_FAIL;

    return (g_pfnCtfImeCreateInputContext)(himc);
}

//+---------------------------------------------------------------------------
//
// Internal_CtfImeDestroyInputContext
//
//----------------------------------------------------------------------------

HRESULT Internal_CtfImeDestroyInputContext(HIMC himc)
{
    if (!LoadCtfIme())
        return E_FAIL;

    return (g_pfnCtfImeDestroyInputContext)(himc);
}

//+---------------------------------------------------------------------------
//
// Internal_CtfImeSetActiveContextAlways
//
//----------------------------------------------------------------------------

HRESULT Internal_CtfImeSetActiveContextAlways(HIMC himc, BOOL fActive, HWND hwnd, HKL hkl)
{
    if (!LoadCtfIme())
        return E_FAIL;

    return (g_pfnCtfImeSetActiveContextAlways)(himc, fActive, hwnd, hkl);
}



#else
void CtfImmGetGuidAtom() { }
void CtfImmHideToolbarWnd() { }
void CtfImmIsGuidMapEnable() { }
void CtfImmRestoreToolbarWnd() { }
void CtfImmSetAppCompatFlags() { }
void CtfImmTIMActivate() { }
void CtfImmIsCiceroEnabled() { }
void CtfImmDispatchDefImeMessage() { }
#endif // CUAS_ENABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\context.c ===
/**************************************************************************\
* Module Name: context.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Context management routines for imm32 dll
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define IMCC_ALLOC_TOOLARGE             0x1000


/**************************************************************************\
* ImmCreateContext
*
* Creates and initializes an input context.
*
* 17-Jan-1996 wkwok       Created
\**************************************************************************/

HIMC WINAPI ImmCreateContext(void)
{
    PCLIENTIMC pClientImc;
    HIMC       hImc = NULL_HIMC;

    if (!IS_IME_ENABLED()) {
        return NULL_HIMC;
    }

    pClientImc = ImmLocalAlloc(HEAP_ZERO_MEMORY, sizeof(CLIENTIMC));

    if (pClientImc != NULL) {

        hImc = NtUserCreateInputContext((ULONG_PTR)pClientImc);
        if (hImc == NULL_HIMC) {
            ImmLocalFree(pClientImc);
            return NULL_HIMC;
        }

        InitImcCrit(pClientImc);
        pClientImc->dwImeCompatFlags = (DWORD)NtUserGetThreadState(UserThreadStateImeCompatFlags);
    }

    return hImc;
}


/**************************************************************************\
* ImmDestroyContext
*
* Destroys an input context.
*
* 17-Jan-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmDestroyContext(
    HIMC hImc)
{
    if (!IS_IME_ENABLED()) {
        return FALSE;
    }

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmDestroyContext: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    return DestroyInputContext(hImc, GetKeyboardLayout(0), FALSE);
}


/**************************************************************************\
* ImmAssociateContext
*
* Associates an input context to the specified window handle.
*
* 17-Jan-1996 wkwok       Created
\**************************************************************************/

HIMC WINAPI ImmAssociateContext(
    HWND hWnd,
    HIMC hImc)
{
    PWND  pWnd;
    HIMC  hPrevImc;
    AIC_STATUS Status;

    // early out
    if (!IS_IME_ENABLED()) {
        return NULL_HIMC;
    }

    if ((pWnd = ValidateHwnd(hWnd)) == (PWND)NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmAssociateContext: invalid window handle %x", hWnd);
        return NULL_HIMC;
    }



    if (hImc != NULL_HIMC &&
            GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmAssociateContext: Invalid input context access %lx.", hImc);
        return NULL_HIMC;
    }

    /*
     * associate to the same input context, do nothing.
     */
    if (pWnd->hImc == hImc)
        return hImc;

    hPrevImc = KHIMC_TO_HIMC(pWnd->hImc);

    Status = NtUserAssociateInputContext(hWnd, hImc, 0);

    switch (Status) {
    case AIC_FOCUSCONTEXTCHANGED:
        if (IsWndEqual(NtUserQueryWindow(hWnd, WindowFocusWindow), hWnd)) {
            ImmSetActiveContext(hWnd, hPrevImc, FALSE);
            ImmSetActiveContext(hWnd, hImc, TRUE);
        }

        // Fall thru.

    case AIC_SUCCESS:
        return hPrevImc;

    default:
        return NULL_HIMC;
    }
}


BOOL WINAPI ImmAssociateContextEx(
    HWND hWnd,
    HIMC hImc,
    DWORD dwFlag)
{
    HWND hWndFocus;
    PWND pWndFocus;
    HIMC hImcFocusOld;
    AIC_STATUS Status;

    if (!IS_IME_ENABLED()) {
        return FALSE;
    }

    hWndFocus = NtUserQueryWindow(hWnd, WindowFocusWindow);

    if (hImc != NULL_HIMC && !(dwFlag & IACE_DEFAULT) &&
            GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmAssociateContextEx: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    if ((pWndFocus = ValidateHwnd(hWndFocus)) != (PWND)NULL)
        hImcFocusOld = KHIMC_TO_HIMC(pWndFocus->hImc);
    else
        hImcFocusOld = NULL_HIMC;

    Status = NtUserAssociateInputContext(hWnd, hImc, dwFlag);

    switch (Status) {
    case AIC_FOCUSCONTEXTCHANGED:
        if ((pWndFocus = ValidateHwnd(hWndFocus)) != (PWND)NULL) {
            hImc = KHIMC_TO_HIMC(pWndFocus->hImc);
            if (hImc != hImcFocusOld) {
                ImmSetActiveContext(hWndFocus, hImcFocusOld, FALSE);
                ImmSetActiveContext(hWndFocus, hImc, TRUE);
            };
        };

        // Fall thru.

    case AIC_SUCCESS:
        return TRUE;

    default:
        return FALSE;
    }
}


/**************************************************************************\
* ImmGetContext
*
* Retrieves the input context that is associated to the given window.
*
* 17-Jan-1996 wkwok       Created
\**************************************************************************/

HIMC WINAPI ImmGetContext(
    HWND hWnd)
{
    if ( hWnd == NULL ) {
        RIPMSG1(RIP_WARNING,
              "ImmGetContext: invalid window handle %x", hWnd);
        return NULL_HIMC;
    }
    /*
     * for non-NULL hWnd, ImmGetSaveContext will do the
     * validation and "same process" checking.
     */
    return ImmGetSaveContext( hWnd, IGSC_WINNLSCHECK );
}


/**************************************************************************\
* ImmGetSaveContext
*
* Retrieves the input context that is associated to the given window.
*
* 15-Mar-1996 wkwok       Created
\**************************************************************************/

HIMC ImmGetSaveContext(
    HWND  hWnd,
    DWORD dwFlag)
{
    HIMC       hRetImc;
    PCLIENTIMC pClientImc;
    PWND  pwnd;

    if (!IS_IME_ENABLED()) {
        return NULL_HIMC;
    }

    if (hWnd == NULL) {
        /*
         * Retrieves the default input context of current thread.
         */
        hRetImc = (HIMC)NtUserGetThreadState(UserThreadStateDefaultInputContext);
    }
    else {
        /*
         * Retrieves the input context associated to the given window.
         */
        if ((pwnd = ValidateHwnd(hWnd)) == (PWND)NULL) {
            RIPMSG1(RIP_WARNING,
                  "ImmGetSaveContext: invalid window handle %x", hWnd);
            return NULL_HIMC;
        }
        /*
         * Don't allow other process to access input context
         */
        if (!TestWindowProcess(pwnd)) {
            RIPMSG0(RIP_WARNING,
                  "ImmGetSaveContext: can not get input context of other process");
            return NULL_HIMC;
        }
        hRetImc = KHIMC_TO_HIMC(pwnd->hImc);

        if (hRetImc == NULL_HIMC && (dwFlag & IGSC_DEFIMCFALLBACK)) {
            /*
             * hWnd associated with NULL input context, retrieves the
             * default input context of the hWnd's creator thread.
             */
            hRetImc = (HIMC)NtUserQueryWindow(hWnd, WindowDefaultInputContext);
        }
    }

    pClientImc = ImmLockClientImc(hRetImc);
    if (pClientImc == NULL)
        return NULL_HIMC;

    if ((dwFlag & IGSC_WINNLSCHECK) && TestICF(pClientImc, IMCF_WINNLSDISABLE))
        hRetImc = NULL_HIMC;

    ImmUnlockClientImc(pClientImc);

    return hRetImc;
}


/**************************************************************************\
* ImmReleaseContext
*
* Releases the input context retrieved by ImmGetContext().
*
* 17-Jan-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmReleaseContext(
    HWND hWnd,
    HIMC hImc)
{
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(hImc);

    return TRUE;
}


/**************************************************************************\
* ImmSetActiveContext
*
* 15-Mar-1996 wkwok       Created
\**************************************************************************/

BOOL ImmSetActiveContext(
    HWND hWnd,
    HIMC hImc,
    BOOL fActivate)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    PIMEDPI       pImeDpi;
    DWORD         dwISC;
    HIMC          hSaveImc;
    HWND          hDefImeWnd;
    DWORD         dwOpenStatus = 0;
    DWORD         dwConversion = 0;
#ifdef DEBUG
    PWND          pWnd = ValidateHwnd(hWnd);

    if (pWnd != NULL && GETPTI(pWnd) != PtiCurrent()) {
        RIPMSG1(RIP_WARNING, "hWnd (=%lx) is not of current thread.", hWnd);
    }
#endif

    if (!IS_IME_ENABLED()) {
        return FALSE;
    }

    dwISC = ISC_SHOWUIALL;

    pClientImc = ImmLockClientImc(hImc);

    if (!fActivate) {
        if (pClientImc != NULL)
            ClrICF(pClientImc, IMCF_ACTIVE);
        goto NotifySetActive;
    }

    if (hImc == NULL_HIMC) {
        hSaveImc = ImmGetSaveContext(hWnd, IGSC_DEFIMCFALLBACK);
        pInputContext = ImmLockIMC(hSaveImc);
        if (pInputContext != NULL) {
            pInputContext->hWnd = hWnd;
            ImmUnlockIMC(hSaveImc);
        }
        goto NotifySetActive;
    }

    /*
     * Non-NULL input context, window handle have to be updated.
     */
    if (pClientImc == NULL)
        return FALSE;

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        ImmUnlockClientImc(pClientImc);
        return FALSE;
    }

    pInputContext->hWnd = hWnd;
    SetICF(pClientImc, IMCF_ACTIVE);

#ifdef LATER
    // Do uNumLangVKey checking later
#endif

    if (pInputContext->fdw31Compat & F31COMPAT_MCWHIDDEN)
        dwISC = ISC_SHOWUIALL - ISC_SHOWUICOMPOSITIONWINDOW;

    dwOpenStatus = (DWORD)pInputContext->fOpen;
    dwConversion = pInputContext->fdwConversion;
    ImmUnlockIMC(hImc);

NotifySetActive:

#ifdef CUAS_ENABLE
    {
        HKL hKL = GetKeyboardLayout(0);
        //
        // call msctfime's ImeSetActiveContextAlways() no matter what is the cuurnet
        // hkl if we in Cicero Unaware App Support.
        //
        if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
            Internal_CtfImeSetActiveContextAlways(hImc, fActivate, hWnd, hKL);
        }
    }
#endif // CUAS_ENABLE

#if !defined(CUAS_ENABLE)
    pImeDpi = ImmLockImeDpi(GetKeyboardLayout(0));
    if (pImeDpi != NULL) {
        (*pImeDpi->pfn.ImeSetActiveContext)(hImc, fActivate);
        ImmUnlockImeDpi(pImeDpi);
    }
#else
    //
    // msctfime's SetFocus might be change hKL to Cicero.
    //
    // call IME's ImeSetActiveContext().
    //
    {
        HKL hKL;
        pImeDpi = ImmLockImeDpi(hKL=GetKeyboardLayout(0));
        if (pImeDpi != NULL) {
            if (IS_IME_KBDLAYOUT(hKL)) {
                (*pImeDpi->pfn.ImeSetActiveContext)(hImc, fActivate);
            }
            ImmUnlockImeDpi(pImeDpi);
        }
    }
#endif

    /*
     * Notify UI
     */
    if (IsWindow(hWnd)) {
        SendMessage(hWnd, WM_IME_SETCONTEXT, fActivate, dwISC);

        /*
         * send notify to shell / keyboard driver
         */
        if ( fActivate )
            NtUserNotifyIMEStatus( hWnd, dwOpenStatus, dwConversion );
    }
    else if (!fActivate) {
        /*
         * Because hWnd is not there (maybe destroyed), we send
         * WM_IME_SETCONTEXT to the default IME window.
         */
        if ((hDefImeWnd = ImmGetDefaultIMEWnd(NULL)) != NULL) {
            SendMessage(hDefImeWnd, WM_IME_SETCONTEXT, fActivate, dwISC);
        }
        else {
            RIPMSG0(RIP_WARNING,
                  "ImmSetActiveContext: can't send WM_IME_SETCONTEXT(FALSE).");
        }
    }
#ifdef DEBUG
    else {
        RIPMSG0(RIP_WARNING,
              "ImmSetActiveContext: can't send WM_IME_SETCONTEXT(TRUE).");
    }
#endif

#ifdef LATER
    // Implements ProcessIMCEvent() later.
#endif

    if (pClientImc != NULL)
        ImmUnlockClientImc(pClientImc);

    return TRUE;
}

/**************************************************************************\
* ModeSaver related routines
*
* Dec-1998 hiroyama     Created
\**************************************************************************/

PIMEMODESAVER GetImeModeSaver(
    PINPUTCONTEXT pInputContext,
    HKL hkl)
{
    PIMEMODESAVER pModeSaver;
    USHORT langId = PRIMARYLANGID(HKL_TO_LANGID(hkl));

    for (pModeSaver = pInputContext->pImeModeSaver; pModeSaver; pModeSaver = pModeSaver->next) {
        if (pModeSaver->langId == langId) {
            break;
        }
    }

    if (pModeSaver == NULL) {


        TAGMSG1(DBGTAG_IMM, "GetImeModeSaver: creating ModeSaver for langId=%04x", langId);
        pModeSaver = ImmLocalAlloc(HEAP_ZERO_MEMORY, sizeof *pModeSaver);
        if (pModeSaver == NULL) {
            RIPMSG1(RIP_WARNING, "GetImeModeSaver: failed to create ModeSaver for langId=%04x", langId);
            return NULL;
        }
        pModeSaver->langId = langId;
        pModeSaver->next = pInputContext->pImeModeSaver;
        pInputContext->pImeModeSaver = pModeSaver;
    }

    return pModeSaver;
}

VOID DestroyImeModeSaver(
    PINPUTCONTEXT pInputContext)
{
    PIMEMODESAVER pModeSaver = pInputContext->pImeModeSaver;

    //
    // Destroy mode savers
    //
    while (pModeSaver) {
        PIMEMODESAVER pNext = pModeSaver->next;
        PIMEPRIVATEMODESAVER pPrivateModeSaver = pModeSaver->pImePrivateModeSaver;

        //
        // Destroy private mode savers
        //
        while (pPrivateModeSaver) {
            PIMEPRIVATEMODESAVER pPrivateNext = pPrivateModeSaver->next;
            ImmLocalFree(pPrivateModeSaver);
            pPrivateModeSaver = pPrivateNext;
        }

        ImmLocalFree(pModeSaver);
        pModeSaver = pNext;
    }

    pInputContext->pImeModeSaver = NULL;
}

PIMEPRIVATEMODESAVER GetImePrivateModeSaver(
    PIMEMODESAVER pImeModeSaver,
    HKL hkl)
{
    PIMEPRIVATEMODESAVER pPrivateModeSaver;

    for (pPrivateModeSaver = pImeModeSaver->pImePrivateModeSaver; pPrivateModeSaver; pPrivateModeSaver = pPrivateModeSaver->next) {
        if (pPrivateModeSaver->hkl == hkl) {
            break;
        }
    }

    if (pPrivateModeSaver == NULL) {
        TAGMSG1(DBGTAG_IMM, "GetImePrivateModeSaver: creating private mode saver for hkl=%08x", hkl);
        pPrivateModeSaver = ImmLocalAlloc(0, sizeof *pPrivateModeSaver);
        if (pPrivateModeSaver == NULL) {
            RIPMSG1(RIP_WARNING, "GetImePrivateModeSaver: failed to create PrivateModeSaver for hlk=%08x", hkl);
            return NULL;
        }
        pPrivateModeSaver->hkl = hkl;
        pPrivateModeSaver->fdwSentence = 0;
        pPrivateModeSaver->next = pImeModeSaver->pImePrivateModeSaver;
        pImeModeSaver->pImePrivateModeSaver = pPrivateModeSaver;
    }

    return pPrivateModeSaver;
}

BOOL SavePrivateMode(
    PINPUTCONTEXT pInputContext,
    PIMEMODESAVER pImeModeSaver,
    HKL hkl)
{
    PIMEPRIVATEMODESAVER pPrivateModeSaver = GetImePrivateModeSaver(pImeModeSaver, hkl);

    if (pPrivateModeSaver == NULL) {
        return FALSE;
    }

    //
    // Save private sentence mode
    //
    pPrivateModeSaver->fdwSentence = pInputContext->fdwSentence & 0xffff0000;
    return TRUE;
}

BOOL RestorePrivateMode(
    PINPUTCONTEXT pInputContext,
    PIMEMODESAVER pImeModeSaver,
    HKL hkl)
{
    PIMEPRIVATEMODESAVER pPrivateModeSaver = GetImePrivateModeSaver(pImeModeSaver, hkl);

    if (pPrivateModeSaver == NULL) {
        return FALSE;
    }

    //
    // Restore private sentence mode
    //
    ImmAssert(LOWORD(pPrivateModeSaver->fdwSentence) == 0);
    pInputContext->fdwSentence |= pPrivateModeSaver->fdwSentence;
    return TRUE;
}

/**************************************************************************\
* CreateInputContext
*
* 20-Feb-1996 wkwok       Created
\**************************************************************************/

BOOL CreateInputContext(
    HIMC hImc,
    HKL  hKL,
    BOOL fCanCallImeSelect)
{
    PIMEDPI            pImeDpi;
    PCLIENTIMC         pClientImc;
    DWORD              dwPrivateDataSize;
    DWORD              fdwInitConvMode = 0;    // do it later
    BOOL               fInitOpen = FALSE;      // do it later
    PINPUTCONTEXT      pInputContext;
    PCOMPOSITIONSTRING pCompStr;
    PCANDIDATEINFO     pCandInfo;
    PGUIDELINE         pGuideLine;
    int                i;

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "CreateContext: Lock hIMC %x failure", hImc);
        goto CrIMCLockErrOut;
    }

    /*
     * Initialize the member of INPUTCONTEXT
     */
    pInputContext->hCompStr = ImmCreateIMCC(sizeof(COMPOSITIONSTRING));
    if (!pInputContext->hCompStr) {
        RIPMSG0(RIP_WARNING, "CreateContext: Create hCompStr failure");
        goto CrIMCUnlockIMC;
    }

    pCompStr = (PCOMPOSITIONSTRING)ImmLockIMCC(pInputContext->hCompStr);
    if (!pCompStr) {
        RIPMSG1(RIP_WARNING,
              "CreateContext: Lock hCompStr %x failure", pInputContext->hCompStr);
        goto CrIMCFreeCompStr;
    }

    pCompStr->dwSize = sizeof(COMPOSITIONSTRING);
    ImmUnlockIMCC(pInputContext->hCompStr);

    pInputContext->hCandInfo = ImmCreateIMCC(sizeof(CANDIDATEINFO));
    if (!pInputContext->hCandInfo) {
        RIPMSG0(RIP_WARNING, "CreateContext: Create hCandInfo failure");
        goto CrIMCFreeCompStr;
    }

    pCandInfo = (PCANDIDATEINFO)ImmLockIMCC(pInputContext->hCandInfo);
    if (!pCandInfo) {
        RIPMSG1(RIP_WARNING,
              "CreateContext: Lock hCandInfo %x failure", pInputContext->hCandInfo);
        goto CrIMCFreeCandInfo;
    }

    pCandInfo->dwSize = sizeof(CANDIDATEINFO);
    ImmUnlockIMCC(pInputContext->hCandInfo);

    pInputContext->hGuideLine = ImmCreateIMCC(sizeof(GUIDELINE));
    if (!pInputContext->hGuideLine) {
        RIPMSG0(RIP_WARNING, "CreateContext: Create hGuideLine failure");
        goto CrIMCFreeCandInfo;
    }

    pGuideLine = (PGUIDELINE)ImmLockIMCC(pInputContext->hGuideLine);
    if (!pGuideLine) {
        RIPMSG1(RIP_WARNING,
              "CreateContext: Lock hGuideLine %x failure", pInputContext->hGuideLine);
        goto CrIMCFreeGuideLine;
    }

    pGuideLine->dwSize = sizeof(GUIDELINE);
    ImmUnlockIMCC(pInputContext->hGuideLine);

    pInputContext->hMsgBuf = ImmCreateIMCC(sizeof(UINT));
    if (!pInputContext->hMsgBuf) {
        RIPMSG0(RIP_WARNING, "CreateContext: Create hMsgBuf failure");
        goto CrIMCFreeGuideLine;
    }

    pInputContext->dwNumMsgBuf = 0;
    pInputContext->fOpen = fInitOpen;
    pInputContext->fdwConversion = fdwInitConvMode;
    pInputContext->fdwSentence = 0;

    for (i = 0; i < 4; i++) {
        pInputContext->cfCandForm[i].dwIndex = (DWORD)(-1);
    }

    pImeDpi = ImmLockImeDpi(hKL);
    if (pImeDpi != NULL) {
        if ((pClientImc = ImmLockClientImc(hImc)) == NULL) {
            RIPMSG0(RIP_WARNING, "CreateContext: ImmLockClientImc() failure");
            ImmUnlockImeDpi(pImeDpi);
            goto CrIMCFreeMsgBuf;
        }

        /*
         * Unicode based IME expects an Uncode based input context.
         */
        if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)
            SetICF(pClientImc, IMCF_UNICODE);

        pClientImc->dwCodePage = IMECodePage(pImeDpi);

        ImmUnlockClientImc(pClientImc);

        dwPrivateDataSize = pImeDpi->ImeInfo.dwPrivateDataSize;
    }
    else {
        dwPrivateDataSize = sizeof(UINT);
    }

    pInputContext->hPrivate = ImmCreateIMCC(dwPrivateDataSize);
    if (!pInputContext->hPrivate) {
        RIPMSG0(RIP_WARNING, "CreateContext: Create hPrivate failure");
        ImmUnlockImeDpi(pImeDpi);
        goto CrIMCFreeMsgBuf;
    }

    pInputContext->pImeModeSaver = NULL;

#ifdef CUAS_ENABLE
    /*
     * Create Cicero Input Context.
     */
    CtfImmTIMCreateInputContext(hImc);
#endif // CUAS_ENABLE

#if !defined(CUAS_ENABLE)
    if (pImeDpi != NULL) {
        if (fCanCallImeSelect) {
            (*pImeDpi->pfn.ImeSelect)(hImc, TRUE);
        }
        ImmUnlockImeDpi(pImeDpi);
    }
#else
    if (pImeDpi != NULL) {
        if (fCanCallImeSelect) {
            if (IS_IME_KBDLAYOUT(hKL)) {
                (*pImeDpi->pfn.ImeSelect)(hImc, TRUE);
            }
            else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
                (*pImeDpi->pfn.CtfImeSelectEx)(hImc, TRUE, hKL);
            }
        }
        if ((pClientImc = ImmLockClientImc(hImc)) != NULL) {
            pClientImc->SelectedHKL = hKL;
            ImmUnlockClientImc(pClientImc);
        }
        ImmUnlockImeDpi(pImeDpi);
    }
#endif

    ImmUnlockIMC(hImc);
    return TRUE;

    /*
     * context failure case
     */
CrIMCFreeMsgBuf:
    ImmDestroyIMCC(pInputContext->hMsgBuf);
CrIMCFreeGuideLine:
    ImmDestroyIMCC(pInputContext->hGuideLine);
CrIMCFreeCandInfo:
    ImmDestroyIMCC(pInputContext->hCandInfo);
CrIMCFreeCompStr:
    ImmDestroyIMCC(pInputContext->hCompStr);
CrIMCUnlockIMC:
    ImmUnlockIMC(hImc);
CrIMCLockErrOut:
    return FALSE;
}


/**************************************************************************\
* DestroyInputContext
*
* 20-Feb-1996 wkwok       Created
\**************************************************************************/

BOOL DestroyInputContext(
    HIMC      hImc,
    HKL       hKL,
    BOOL      bTerminate)
{
    PINPUTCONTEXT pInputContext;
    PIMEDPI       pImeDpi;
    PIMC          pImc;
    PCLIENTIMC    pClientImc;

    if (!IS_IME_ENABLED()) {
        return FALSE;

    }
    if (hImc == NULL_HIMC) {
        RIPMSG0(RIP_VERBOSE, "DestroyInputContext: hImc is NULL.");
        return FALSE;
    }

    pImc = HMValidateHandle((HANDLE)hImc, TYPE_INPUTCONTEXT);

    /*
     * Cannot destroy input context from other thread.
     */
    if (pImc == NULL || GETPTI(pImc) != PtiCurrent())
        return FALSE;

    /*
     * We are destroying this hImc so we don't bother calling
     * ImmLockClientImc() to get the pClientImc. Instead, we
     * reference the pImc->dwClientImcData directly and call
     * InterlockedIncrement(&pClientImc->cLockObj) right after
     * several quick checks.
     */
    pClientImc = (PCLIENTIMC)pImc->dwClientImcData;

    if (pClientImc == NULL) {
        /*
         * Client side Imc has not been initialzed yet.
         * We simply destroy this input context from kernel.
         */
        if (bTerminate) {
            /*
             * If called from THREAD_DETACH, we don't
             * have to destroy kernel side Input Context.
             */
            return TRUE;
        }
        return NtUserDestroyInputContext(hImc);
    }

    if (TestICF(pClientImc, IMCF_DEFAULTIMC) && !bTerminate) {
        /*
         * Cannot destroy default input context unless the
         * thread is terminating.
         */
        return FALSE;
    }

    if (TestICF(pClientImc, IMCF_INDESTROY)) {
        /*
         * This hImc is being destroyed. Returns as success.
         */
        return TRUE;
    }

    /*
     * Time to lock up the pClientImc.
     */
    InterlockedIncrement(&pClientImc->cLockObj);

    if (pClientImc->hInputContext != NULL) {

        pInputContext = ImmLockIMC(hImc);
        if (!pInputContext) {
            RIPMSG1(RIP_WARNING, "DestroyContext: Lock hImc %x failure", hImc);
            ImmUnlockClientImc(pClientImc);
            return FALSE;
        }

#ifdef CUAS_ENABLE
        /*
         * Destroy Cicero Input Context.
         */
        CtfImmTIMDestroyInputContext(hImc);
#endif // CUAS_ENABLE

#if !defined(CUAS_ENABLE)
        pImeDpi = ImmLockImeDpi(hKL);
        if (pImeDpi != NULL) {
            (*pImeDpi->pfn.ImeSelect)(hImc, FALSE);
            ImmUnlockImeDpi(pImeDpi);
        }
#else
        if (pClientImc->SelectedHKL == hKL) {
            pImeDpi = ImmLockImeDpi(hKL);
            if (pImeDpi != NULL) {
                if (IS_IME_KBDLAYOUT(hKL)) {
                    (*pImeDpi->pfn.ImeSelect)(hImc, FALSE);
                }
                else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
                    (*pImeDpi->pfn.CtfImeSelectEx)(hImc, FALSE, hKL);
                }
                ImmUnlockImeDpi(pImeDpi);
            }
            pClientImc->SelectedHKL = NULL;
        }
#endif

        ImmDestroyIMCC(pInputContext->hPrivate);
        ImmDestroyIMCC(pInputContext->hMsgBuf);
        ImmDestroyIMCC(pInputContext->hGuideLine);
        ImmDestroyIMCC(pInputContext->hCandInfo);
        ImmDestroyIMCC(pInputContext->hCompStr);

        /*
         * Free all ImeModeSaver.
         */
        DestroyImeModeSaver(pInputContext);

        ImmUnlockIMC(hImc);
    }

    SetICF(pClientImc, IMCF_INDESTROY);

    /*
     * ImmUnlockClientImc() will free up the pClientImc
     * when InterlockedDecrement(&pClientImc->cLockObj)
     * reaches 0.
     */
    ImmUnlockClientImc(pClientImc);

    return (bTerminate) ? TRUE : NtUserDestroyInputContext(hImc);
}


/**************************************************************************\
* SelectInputContext
*
* 20-Feb-1996 wkwok       Created
\**************************************************************************/

VOID SelectInputContext(
    HKL  hSelKL,
    HKL  hUnSelKL,
    HIMC hImc)
{
    PIMEDPI            pSelImeDpi, pUnSelImeDpi;
    PCLIENTIMC         pClientImc;
    PINPUTCONTEXT      pInputContext;
    DWORD              dwSelPriv = 0, dwUnSelPriv = 0, dwSize;
    HIMCC              hImcc;
    PCOMPOSITIONSTRING pCompStr;
    PCANDIDATEINFO     pCandInfo;
    PGUIDELINE         pGuideLine;
    BOOLEAN            fLogFontInited;
#ifdef CUAS_ENABLE
    BOOLEAN            fUseImeSaverForSelIme = TRUE;
    BOOLEAN            fUseImeSaverForUnSelIme = TRUE;
#endif

    TAGMSG3(DBGTAG_IMM, "SelectInputContext: called for sel=%08p unsel=%08p hImc=%08p",
            hSelKL, hUnSelKL, hImc);

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG0(RIP_VERBOSE, "SelectInputContext: cannot lock client Imc. Bailing out.");
        return;
    }

    pSelImeDpi   = ImmLockImeDpi(hSelKL);

    if (hSelKL != hUnSelKL) {
        /*
         * If those new sel and unsel do no match but
         * somehow SelectInput is called, that means
         * we should initialize the input contex again
         * without dumping the old information.
         */
        pUnSelImeDpi = ImmLockImeDpi(hUnSelKL);
    } else {
        pUnSelImeDpi = NULL;
    }

    if (pSelImeDpi != NULL) {
        /*
         * According to private memory size of the two layout, we decide
         * whether we nee to reallocate this memory block
         */
        dwSelPriv = pSelImeDpi->ImeInfo.dwPrivateDataSize;

        /*
         * Setup the code page of the newly selected IME.
         */
        pClientImc->dwCodePage = IMECodePage(pSelImeDpi);
    }
    else {
        pClientImc->dwCodePage = CP_ACP;
    }

    if (pUnSelImeDpi != NULL)
        dwUnSelPriv = pUnSelImeDpi->ImeInfo.dwPrivateDataSize;

    dwSelPriv   = max(dwSelPriv,   sizeof(UINT));
    dwUnSelPriv = max(dwUnSelPriv, sizeof(UINT));

    /*
     * Unselect the input context.
     */
#if !defined(CUAS_ENABLE)
    if (pUnSelImeDpi != NULL)
        (*pUnSelImeDpi->pfn.ImeSelect)(hImc, FALSE);
#else
    if (pClientImc->SelectedHKL == hUnSelKL) {
        if (pUnSelImeDpi != NULL) {
            if (IS_IME_KBDLAYOUT(hUnSelKL)) {
                (*pUnSelImeDpi->pfn.ImeSelect)(hImc, FALSE);
            }
            else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
                (*pUnSelImeDpi->pfn.CtfImeSelectEx)(hImc, FALSE, hUnSelKL);
            }
        }
        pClientImc->SelectedHKL = NULL;
    }

    //
    // don't use a mode saver for non IME or non CUAS.
    //
    if (CtfImmIsTextFrameServiceDisabled()) {
        if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
            if (!IS_IME_KBDLAYOUT(hSelKL))
                fUseImeSaverForSelIme = FALSE;
            if (!IS_IME_KBDLAYOUT(hUnSelKL))
                fUseImeSaverForUnSelIme = FALSE;
        }
    }
#endif

    /*
     * Reinitialize the client side input context for the selected layout.
     */
    if ((pInputContext = InternalImmLockIMC(hImc, FALSE)) != NULL) {
        DWORD fdwOldConversion = pInputContext->fdwConversion;
        DWORD fdwOldSentence = pInputContext->fdwSentence;
        BOOL fOldOpen = pInputContext->fOpen;
        PIMEMODESAVER pUnSelModeSaver, pSelModeSaver;
        const DWORD fdwConvPreserve = IME_CMODE_EUDC;

        fLogFontInited = ((pInputContext->fdwInit & INIT_LOGFONT) == INIT_LOGFONT);

        if (TestICF(pClientImc, IMCF_UNICODE) && pSelImeDpi != NULL &&
                !(pSelImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
            /*
             * Check if there is any LOGFONT to be converted.
             */
            if (fLogFontInited) {
                LOGFONTA LogFontA;

                LFontWtoLFontA(&pInputContext->lfFont.W, &LogFontA);
                RtlCopyMemory(&pInputContext->lfFont.A, &LogFontA, sizeof(LOGFONTA));
            }

            ClrICF(pClientImc, IMCF_UNICODE);
        }
        else if (!TestICF(pClientImc, IMCF_UNICODE) && pSelImeDpi != NULL &&
                 (pSelImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
            /*
             * Check if there is any LOGFONT to be converted.
             */
            if (fLogFontInited) {
                LOGFONTW LogFontW;

                LFontAtoLFontW(&pInputContext->lfFont.A, &LogFontW);
                RtlCopyMemory(&pInputContext->lfFont.W, &LogFontW, sizeof(LOGFONTW));
            }

            SetICF(pClientImc, IMCF_UNICODE);
        }

        /*
         * hPrivate
         */
        if (dwUnSelPriv != dwSelPriv) {
            hImcc = ImmReSizeIMCC(pInputContext->hPrivate, dwSelPriv);
            if (hImcc) {
                pInputContext->hPrivate = hImcc;
            }
            else {
                RIPMSG1(RIP_WARNING,
                      "SelectContext: resize hPrivate %lX failure",
                      pInputContext->hPrivate);
                ImmDestroyIMCC(pInputContext->hPrivate);
                pInputContext->hPrivate = ImmCreateIMCC(dwSelPriv);
            }
        }

        /*
         * hMsgBuf
         */
        dwSize = ImmGetIMCCSize(pInputContext->hMsgBuf);

        if (ImmGetIMCCLockCount(pInputContext->hMsgBuf) != 0 ||
                dwSize > IMCC_ALLOC_TOOLARGE) {

            RIPMSG0(RIP_WARNING, "SelectContext: create new hMsgBuf");
            ImmDestroyIMCC(pInputContext->hMsgBuf);
            pInputContext->hMsgBuf = ImmCreateIMCC(sizeof(UINT));
            pInputContext->dwNumMsgBuf = 0;
        }

        /*
         * hGuideLine
         */
        dwSize = ImmGetIMCCSize(pInputContext->hGuideLine);

        if (ImmGetIMCCLockCount(pInputContext->hGuideLine) != 0 ||
                dwSize < sizeof(GUIDELINE) || dwSize > IMCC_ALLOC_TOOLARGE) {

            RIPMSG0(RIP_WARNING, "SelectContext: create new hGuideLine");
            ImmDestroyIMCC(pInputContext->hGuideLine);
            pInputContext->hGuideLine = ImmCreateIMCC(sizeof(GUIDELINE));
            pGuideLine = (PGUIDELINE)ImmLockIMCC(pInputContext->hGuideLine);

            if (pGuideLine != NULL) {
                pGuideLine->dwSize = sizeof(GUIDELINE);
                ImmUnlockIMCC(pInputContext->hGuideLine);
            }
        }

        /*
         * hCandInfo
         */
        dwSize = ImmGetIMCCSize(pInputContext->hCandInfo);

        if (ImmGetIMCCLockCount(pInputContext->hCandInfo) != 0 ||
                dwSize < sizeof(CANDIDATEINFO) || dwSize > IMCC_ALLOC_TOOLARGE) {

            RIPMSG0(RIP_WARNING, "SelectContext: create new hCandInfo");
            ImmDestroyIMCC(pInputContext->hCandInfo);
            pInputContext->hCandInfo = ImmCreateIMCC(sizeof(CANDIDATEINFO));
            pCandInfo = (PCANDIDATEINFO)ImmLockIMCC(pInputContext->hCandInfo);

            if (pCandInfo != NULL) {
                pCandInfo->dwSize = sizeof(CANDIDATEINFO);
                ImmUnlockIMCC(pInputContext->hCandInfo);
            }
        }

        /*
         * hCompStr
         */
        dwSize = ImmGetIMCCSize(pInputContext->hCompStr);

        if (ImmGetIMCCLockCount(pInputContext->hCompStr) != 0 ||
                dwSize < sizeof(COMPOSITIONSTRING) || dwSize > IMCC_ALLOC_TOOLARGE) {

            RIPMSG0(RIP_WARNING, "SelectContext: create new hCompStr");
            ImmDestroyIMCC(pInputContext->hCompStr);
            pInputContext->hCompStr = ImmCreateIMCC(sizeof(COMPOSITIONSTRING));
            pCompStr = (PCOMPOSITIONSTRING)ImmLockIMCC(pInputContext->hCompStr);

            if (pCompStr != NULL) {
                pCompStr->dwSize = sizeof(COMPOSITIONSTRING);
                ImmUnlockIMCC(pInputContext->hCompStr);
            }
        }

        //
        // Save and restore the IME modes when the primary
        // language changes.
        //

#if !defined(CUAS_ENABLE)
        if (pUnSelImeDpi) 
#else
        if (pUnSelImeDpi && fUseImeSaverForUnSelIme)
#endif
        {
            //
            // If UnSelKL is IME, get ModeSaver per language.
            //
            pUnSelModeSaver = GetImeModeSaver(pInputContext, hUnSelKL);
            TAGMSG1(DBGTAG_IMM, "pUnSelModeSaver=%p", pUnSelModeSaver);

            if (pUnSelModeSaver) {
                //
                // Firstly save the private sentence mode per IME.
                //
                SavePrivateMode(pInputContext, pUnSelModeSaver, hUnSelKL);
            }
        }
        else {
            pUnSelModeSaver = NULL;
        }

#if !defined(CUAS_ENABLE)
        if (pSelImeDpi) 
#else
        if (pSelImeDpi && fUseImeSaverForSelIme)
#endif
        {
            //
            // If SelKL is IME, get is ModeSaver per language.
            //
            pSelModeSaver = GetImeModeSaver(pInputContext, hSelKL);
            TAGMSG1(DBGTAG_IMM, "pSelImeDpi. pImeModeSaver=%p", pSelModeSaver);
        }
        else {
            pSelModeSaver = NULL;
        }

        //
        // If the primary language of KL changes, save the current mode
        // and restore the previous modes of new language.
        //
        if (pUnSelModeSaver != pSelModeSaver) {
            //
            // If old KL is IME, save the current conversion, sentence and open mode.
            //
            if (pUnSelModeSaver) {
                pUnSelModeSaver->fOpen = (pInputContext->fOpen != FALSE);

                //
                // Don't have to save the preserved bits for conversion mode.
                //
                pUnSelModeSaver->fdwConversion = pInputContext->fdwConversion & ~fdwConvPreserve;

                pUnSelModeSaver->fdwSentence = LOWORD(pInputContext->fdwSentence);
                pUnSelModeSaver->fdwInit = pInputContext->fdwInit;
            }

            //
            // If new KL is IME, restore the previous conversion, sentence and open mode.
            //
            if (pSelModeSaver) {
                if (pInputContext->fdwDirty & IMSS_INIT_OPEN) {
                    //
                    // HKL change may be kicked from private IME hotkey, and
                    // a user wants it opened when switched.
                    //
                    pInputContext->fOpen = TRUE;
                    pInputContext->fdwDirty &= ~IMSS_INIT_OPEN;
                } else {
                    pInputContext->fOpen = pSelModeSaver->fOpen;
                }

                //
                // Some bits are preserved across the languages.
                //
                pInputContext->fdwConversion &= fdwConvPreserve;
                ImmAssert((pSelModeSaver->fdwConversion & fdwConvPreserve) == 0);
                pInputContext->fdwConversion |= pSelModeSaver->fdwConversion & ~fdwConvPreserve;

                ImmAssert(HIWORD(pSelModeSaver->fdwSentence) == 0);
                pInputContext->fdwSentence = pSelModeSaver->fdwSentence;
                pInputContext->fdwInit = pSelModeSaver->fdwInit;
            }
        }
        if (pSelModeSaver) {
            //
            // Restore the private sentence mode per IME.
            //
            RestorePrivateMode(pInputContext, pSelModeSaver, hSelKL);
        }

        /*
         * Select the input context.
         */
#if !defined(CUAS_ENABLE)
        if (pSelImeDpi != NULL)
            (*pSelImeDpi->pfn.ImeSelect)(hImc, TRUE);
#else
        if (pSelImeDpi != NULL) {
            if (IS_IME_KBDLAYOUT(hSelKL)) {
                (*pSelImeDpi->pfn.ImeSelect)(hImc, TRUE);
            }
            else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
                (*pSelImeDpi->pfn.CtfImeSelectEx)(hImc, TRUE, hSelKL);
            }
            pClientImc->SelectedHKL = hSelKL;
        }
#endif

        //
        // Set the dirty bits so that IMM can send notifications later.
        // See SendNotificatonProc.
        //
        pInputContext->fdwDirty = 0;
        if (pInputContext->fOpen != fOldOpen) {
            pInputContext->fdwDirty |= IMSS_UPDATE_OPEN;
        }
        if (pInputContext->fdwConversion != fdwOldConversion) {
            pInputContext->fdwDirty |= IMSS_UPDATE_CONVERSION;
        }
        if (pInputContext->fdwSentence != fdwOldSentence) {
            pInputContext->fdwDirty |= IMSS_UPDATE_SENTENCE;
        }
        TAGMSG4(DBGTAG_IMM, "fOpen:%d fdwConv:%08x fdwSent:%08x dirty:%02x",
                pInputContext->fOpen, pInputContext->fdwConversion, pInputContext->fdwSentence, pInputContext->fdwDirty);

        ImmUnlockIMC(hImc);
    }
    else {
        //
        // To keep the backward compatibility,
        // select the input context here.
        //
#if !defined(CUAS_ENABLE)
        if (pSelImeDpi != NULL)
            (*pSelImeDpi->pfn.ImeSelect)(hImc, TRUE);
#else
        if (pSelImeDpi != NULL) {
            if (IS_IME_KBDLAYOUT(hSelKL)) {
                (*pSelImeDpi->pfn.ImeSelect)(hImc, TRUE);
            }
            else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
                (*pSelImeDpi->pfn.CtfImeSelectEx)(hImc, TRUE, hSelKL);
            }
            pClientImc->SelectedHKL = hSelKL;
        }
#endif
    }

    ImmUnlockImeDpi(pUnSelImeDpi);
    ImmUnlockImeDpi(pSelImeDpi);
    ImmUnlockClientImc(pClientImc);
}

BOOL SendNotificationProc(
    HIMC hImc,
    LPARAM lParam)
{
    PINPUTCONTEXT pInputContext = ImmLockIMC(hImc);

    UNREFERENCED_PARAMETER(lParam);

    if (pInputContext != NULL) {
        HWND hwnd = pInputContext->hWnd;

        if (IsWindow(hwnd)) {
            TAGMSG2(DBGTAG_IMM, "SendNotificationProc: updating hImc=%08x dirty=%04x",
                    hImc, pInputContext->fdwDirty);

            if (pInputContext->fdwDirty & IMSS_UPDATE_OPEN) {
                SendMessageW(hwnd, WM_IME_NOTIFY, IMN_SETOPENSTATUS, 0);
            }
            if (pInputContext->fdwDirty & IMSS_UPDATE_CONVERSION) {
                SendMessageW(hwnd, WM_IME_NOTIFY, IMN_SETCONVERSIONMODE, 0);
            }
            if (pInputContext->fdwDirty & (IMSS_UPDATE_OPEN | IMSS_UPDATE_CONVERSION)) {
                NtUserNotifyIMEStatus(hwnd, pInputContext->fOpen, pInputContext->fdwConversion);
            }
            if (pInputContext->fdwDirty & IMSS_UPDATE_SENTENCE) {
                SendMessageW(hwnd, WM_IME_NOTIFY, IMN_SETSENTENCEMODE, 0);
            }
        }
        pInputContext->fdwDirty = 0;
    }

    return TRUE;
}

VOID ImmSendNotification(
    BOOL fForProcess)
{
    DWORD dwThreadId;

    if (fForProcess) {
        dwThreadId = -1;
    } else {
        dwThreadId = 0;
    }

    ImmEnumInputContext(dwThreadId, (IMCENUMPROC)SendNotificationProc, 0);
}

/**************************************************************************\
* ImmEnumInputContext
*
* 20-Feb-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmEnumInputContext(
    DWORD idThread,
    IMCENUMPROC lpfn,
    LPARAM lParam)
{
    UINT i;
    UINT cHimc;
    HIMC *phimcT;
    HIMC *phimcFirst;
    BOOL fSuccess = TRUE;

    /*
     * Get the himc list.  It is returned in a block of memory
     * allocated with ImmLocalAlloc.
     */
    if ((cHimc = BuildHimcList(idThread, &phimcFirst)) == 0) {
        return FALSE;
    }

    /*
     * Loop through the input contexts, call the function pointer back for
     * each one. End loop if either FALSE is returned or the end-of-list is
     * reached.
     */
    phimcT = phimcFirst;
    for (i = 0; i < cHimc; i++) {
        if (RevalidateHimc(*phimcT)) {
            if (!(fSuccess = (*lpfn)(*phimcT, lParam)))
                break;
        }
        phimcT++;
    }

    /*
     * Free up buffer and return status - TRUE if entire list was enumerated,
     * FALSE otherwise.
     */
    ImmLocalFree(phimcFirst);

    return fSuccess;
}

/**************************************************************************\
* BuildHimcList
*
* 20-Feb-1996 wkwok       Created
\**************************************************************************/

DWORD BuildHimcList(
    DWORD idThread,
    HIMC **pphimcFirst)
{
    UINT cHimc;
    HIMC *phimcFirst;
    NTSTATUS Status;
    int cTries;

    /*
     * Allocate a buffer to hold the names.
     */
    cHimc = 64;
    phimcFirst = ImmLocalAlloc(0, cHimc * sizeof(HIMC));
    if (phimcFirst == NULL)
        return 0;

    Status = NtUserBuildHimcList(idThread, cHimc, phimcFirst, &cHimc);

    /*
     * If the buffer wasn't big enough, reallocate
     * the buffer and try again.
     */
    cTries = 0;
    while (Status == STATUS_BUFFER_TOO_SMALL) {
        ImmLocalFree(phimcFirst);

        /*
         * If we can't seem to get it right,
         * call it quits
         */
        if (cTries++ == 10)
            return 0;

        phimcFirst = ImmLocalAlloc(0, cHimc * sizeof(HIMC));
        if (phimcFirst == NULL)
            return 0;

        Status = NtUserBuildHimcList(idThread, cHimc, phimcFirst, &cHimc);
    }

    if (!NT_SUCCESS(Status) || cHimc == 0) {
        ImmLocalFree(phimcFirst);
        return 0;
    }

    *pphimcFirst = phimcFirst;

    return cHimc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\globals.c ===
/****************************** Module Header ******************************\
* Module Name: global.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains global data for the imm32 dll
*
* History:
* 03-Jan-1996 wkwok    Created
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

/*
 * We get this warning if we don't explicitly initalize gZero:
 *
 * C4132: 'gZero' : const object should be initialized
 *
 * But we can't explicitly initialize it since it is a union. So
 * we turn the warning off.
 */
#pragma warning(disable:4132)
CONST ALWAYSZERO gZero;
#pragma warning(default:4132)

BOOLEAN gfInitialized;
HINSTANCE  ghInst;
PVOID pImmHeap;
PSERVERINFO gpsi = NULL;
SHAREDINFO gSharedInfo;
ULONG_PTR gHighestUserAddress;

PIMEDPI gpImeDpi = NULL;
CRITICAL_SECTION gcsImeDpi;


POINT gptRaiseEdge;
UINT  guScanCode[0xFF];          // scan code for each virtual key

#ifdef LATER
CONST WCHAR gszRegKbdLayout[]  = L"Keyboard Layouts\\";
CONST INT sizeof_gszRegKbdLayout = sizeof gszRegKbdLayout;
#else
    // current
CONST WCHAR gszRegKbdLayout[]  = L"System\\CurrentControlSet\\Control\\Keyboard Layouts";
#ifdef CUAS_ENABLE
CONST WCHAR gszRegCiceroIME[]  = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\IMM";
CONST WCHAR gszRegCtfShared[]    = L"Software\\Microsoft\\CTF\\SystemShared";
CONST WCHAR gszValCUASEnable[] = L"CUAS";
#endif // CUAS_ENABLE
#endif

CONST WCHAR gszRegKbdOrder[]   = L"Keyboard Layout\\Preload";
CONST WCHAR gszValLayoutText[] = L"Layout Text";
CONST WCHAR gszValLayoutFile[] = L"Layout File";
CONST WCHAR gszValImeFile[]    = L"Ime File";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\conime.c ===
/**************************************************************************\
* Module Name: conime.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* client side receiveing stubs
*
* History:
* 19-Sep-1995 v-HirShi Created
* 12-Jun-1996 v-HirShi Attached to SUR
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#define GUI_VKEY_MASK (0x00ff)

DWORD
ImmProcessKey(
    HWND hWnd,
    HKL  hkl,
    UINT uVKey,
    LPARAM lParam,
    DWORD dwHotKeyID
    ) ;

BOOL
ImmSetActiveContext(
    HWND   hWnd,
    HIMC   hIMC,
    BOOL   fFlag
    ) ;

DWORD
ImmCallImeConsoleIME(
    HWND   hWnd,
    UINT   Message,
    WPARAM wParam,
    LPARAM lParam,
    PUINT  puVKey
    )
/*++

Routine Description:

        Called by Console IME to convert Character
        This routine copy from user\kernel\ntimm.c :: xxxImmProcessKey
        for Console IME could not calls kernel function.

Arguments:

Return Value:
--*/
{
    DWORD          dwReturn ;
    PIMC           pImc ;
    HIMC           hImc ;
    BOOL           fDBERoman ;
    PWND           pwnd ;
    PIMEDPI        pImeDpi;
    HKL            hkl ;

    dwReturn = 0;
    pImc = NULL;
    fDBERoman = FALSE;

    //
    // we're interested in only keyboard messages.
    //
    if ( Message != WM_KEYDOWN    &&
         Message != WM_SYSKEYDOWN &&
         Message != WM_KEYUP      &&
         Message != WM_SYSKEYUP ) {

        return dwReturn;
    }

    hkl = GetKeyboardLayout( GetWindowThreadProcessId(hWnd, NULL) );
    pwnd = ValidateHwnd(hWnd);
    if ( pwnd == NULL) {
        return dwReturn;
    }
    hImc = ImmGetContext(hWnd);
    if ( hImc == NULL_HIMC ){
        return dwReturn;
    }

    *puVKey = (UINT)wParam & GUI_VKEY_MASK;

    //
    // Check input context
    //
    pImc = HMValidateHandle((HANDLE)hImc, TYPE_INPUTCONTEXT);
    if ( pImc == NULL ) {
        return dwReturn;
    }

#ifdef LATER
    //
    // If there is an easy way to check the input context open/close status
    // from the kernel side, IME_PROP_NO_KEYS_ON_CLOSE checking should be
    // done here in kernel side.  [ 3/10/96 takaok]
    //

    //
    // Check IME_PROP_NO_KEYS_ON_CLOSE bit
    //
    // if the current imc is not open and IME doesn't need
    // keys when being closed, we don't pass any keyboard
    // input to ime except hotkey and keys that change
    // the keyboard status.
    //
    if ( (piix->ImeInfo.fdwProperty & IME_PROP_NO_KEYS_ON_CLOSE) &&
         (!pimc->fdwState & IMC_OPEN)                            &&
         uVKey != VK_SHIFT                                       &&  // 0x10
         uVKey != VK_CONTROL                                     &&  // 0x11
         uVKey != VK_CAPITAL                                     &&  // 0x14
         uVKey != VK_KANA                                        &&  // 0x15
         uVKey != VK_NUMLOCK                                     &&  // 0x90
         uVKey != VK_SCROLL )                                        // 0x91
    {
      // Check if Korea Hanja conversion mode
      if( !(pimc->fdwConvMode & IME_CMODE_HANJACONVERT) ) {
          return dwReturn;
      }
    }
#endif

    //
    // if the IME doesn't need key up messages, we don't call ime.
    //
    pImeDpi = ImmLockImeDpi(hkl);
    if ( pImeDpi == NULL ) {
        return dwReturn;
    }

    if ( lParam & 0x80000000 &&          // set if key up, clear if key down
         pImeDpi->ImeInfo.fdwProperty & IME_PROP_IGNORE_UPKEYS )
    {
        ImmUnlockImeDpi(pImeDpi);
        return dwReturn;
    }

    //
    // we don't want to handle sys keys since many functions for
    // acceelerators won't work without this
    //
    fDBERoman = (BOOL)( (*puVKey == VK_DBE_ROMAN)            ||
                        (*puVKey == VK_DBE_NOROMAN)          ||
                        (*puVKey == VK_DBE_HIRAGANA)         ||
                        (*puVKey == VK_DBE_KATAKANA)         ||
                        (*puVKey == VK_DBE_CODEINPUT)        ||
                        (*puVKey == VK_DBE_NOCODEINPUT)      ||
                        (*puVKey == VK_DBE_IME_WORDREGISTER) ||
                        (*puVKey == VK_DBE_IME_DIALOG) );

    if (Message == WM_SYSKEYDOWN || Message == WM_SYSKEYUP ) {
        //
        // IME may be waiting for VK_MENU, VK_F10 or VK_DBE_xxx
        //
        if ( *puVKey != VK_MENU && *puVKey != VK_F10 && !fDBERoman ) {
            ImmUnlockImeDpi(pImeDpi);
            return dwReturn;
        }
    }

    //
    // check if the IME doesn't need ALT key
    //

    if ( !(pImeDpi->ImeInfo.fdwProperty & IME_PROP_NEED_ALTKEY) ) {
        //
        // IME doesn't need ALT key
        //
        // we don't pass the ALT and ALT+xxx except VK_DBE_xxx keys.
        //
        if ( ! fDBERoman &&
             (*puVKey == VK_MENU || (lParam & 0x20000000))  // KF_ALTDOWN
           )
        {
            ImmUnlockImeDpi(pImeDpi);
            return dwReturn;
        }
    }


    dwReturn = ImmProcessKey(hWnd, hkl, *puVKey, lParam, IME_INVALID_HOTKEY ) ;

    ImmUnlockImeDpi(pImeDpi);
    return dwReturn;
}

BOOL
ImmSetActiveContextConsoleIME(
    HWND   hWnd,
    BOOL   fFlag
    )

/*++

Routine Description:

    Set this context as active one.

Arguments:

    hWnd         - the get focus window
    fFlag        - get focus or kill focus

Return Value:

--*/

{
    HIMC hImc;

    hImc = ImmGetContext(hWnd) ;
    if (hImc == NULL_HIMC) {
        return FALSE;
    }
    return(ImmSetActiveContext(hWnd, hImc, fFlag)) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\hotkey.c ===
/**************************************************************************\
* Module Name: hotkey.c (corresponds to Win95 hotkey.c)
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IME hot key management routines for imm32 dll
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop



//
// internal functions
//
BOOL CIMENonIMEToggle(HIMC hIMC, HKL hKL, HWND hWnd, LANGID langTarget);
BOOL IMENonIMEToggle( HIMC hIMC, HKL hKL, HWND hWnd, BOOL fIME, LANGID langTarget);
BOOL JCloseOpen( HIMC hIMC, HKL hKL, HWND hWnd);
BOOL CSymbolToggle(HIMC hIMC, HKL hKL, HWND hWnd);
BOOL TShapeToggle(HIMC hIMC, HKL hKL, HWND hWnd);
BOOL KEnglishHangul( HIMC hIMC);
BOOL KShapeToggle( HIMC hIMC);
BOOL KHanjaConvert( HIMC hIMC);


/***************************************************************************\
* ImmGetHotKey()
*
* Private API for IMEs and the control panel. The caller specifies
* the IME hotkey ID:dwID. If a hotkey is registered with the specified
* ID, this function returns the modifiers, vkey and hkl of the hotkey.
*
* History:
* 25-Mar-1996 TakaoK       Created
\***************************************************************************/
BOOL WINAPI ImmGetHotKey(
    DWORD dwID,
    PUINT puModifiers,
    PUINT puVKey,
    HKL   *phkl)
{
    if (puModifiers == NULL || puVKey == NULL) {
        return FALSE;
    }
    return NtUserGetImeHotKey( dwID, puModifiers, puVKey, phkl );
}

/**********************************************************************/
/* ImmSimulateHotKey()                                                */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImmSimulateHotKey(  // simulate the functionality of that hot key
    HWND  hAppWnd,              // application window handle
    DWORD dwHotKeyID)
{
    HIMC hImc;
    HKL  hKL;
    BOOL fReturn;

    hImc = ImmGetContext( hAppWnd );
    hKL = GetKeyboardLayout( GetWindowThreadProcessId(hAppWnd, NULL) );
    fReturn = HotKeyIDDispatcher( hAppWnd, hImc, hKL, dwHotKeyID);
    ImmReleaseContext( hAppWnd, hImc );
    return fReturn;
}


/***************************************************************************\
* SaveImeHotKey()
*
*  Put/Remove the specified IME hotkey entry from the registry
*
* History:
* 25-Mar-1996 TakaoK       Created
\***************************************************************************/

/**********************************************************************/
/* HotKeyIDDispatcher                                                 */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL HotKeyIDDispatcher( HWND hWnd, HIMC hImc, HKL hKlCurrent, DWORD dwHotKeyID )
{
    /*
     * Dispatch the IME hotkey event for the specified hImc
     * only if the calling thread owns the hImc.
     */
    if (hImc != NULL_HIMC &&
            GetInputContextThread(hImc) != GetCurrentThreadId()) {
        return FALSE;
    }

    switch ( dwHotKeyID ) {
    case IME_CHOTKEY_IME_NONIME_TOGGLE:
        return CIMENonIMEToggle(hImc, hKlCurrent, hWnd, MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED));

    case IME_THOTKEY_IME_NONIME_TOGGLE:
        return CIMENonIMEToggle(hImc, hKlCurrent, hWnd, MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL));

    case IME_CHOTKEY_SYMBOL_TOGGLE:
    case IME_THOTKEY_SYMBOL_TOGGLE:
        return CSymbolToggle( hImc, hKlCurrent, hWnd);

    case IME_JHOTKEY_CLOSE_OPEN:
        return JCloseOpen( hImc, hKlCurrent, hWnd);

    case IME_KHOTKEY_ENGLISH:           // VK_HANGUL : English/Hangul mode
        return KEnglishHangul( hImc );

    case IME_KHOTKEY_SHAPE_TOGGLE:      // VK_JUNJA : full/half width
        return KShapeToggle( hImc );

    case IME_KHOTKEY_HANJACONVERT:      // VK_HANJA : convert hangul to hanja
        return KHanjaConvert( hImc );

    case IME_CHOTKEY_SHAPE_TOGGLE:
    case IME_THOTKEY_SHAPE_TOGGLE:
        return TShapeToggle( hImc, hKlCurrent, hWnd);

    default:
        /*
         * Direct swithing hotkey should have been handled in the kernel side.
         */
        ImmAssert(dwHotKeyID < IME_HOTKEY_DSWITCH_FIRST || dwHotKeyID > IME_HOTKEY_DSWITCH_LAST);

        if ( dwHotKeyID >= IME_HOTKEY_PRIVATE_FIRST &&
                    dwHotKeyID <= IME_HOTKEY_PRIVATE_LAST ) {

            PIMEDPI pImeDpi;
            BOOL    bRet = FALSE;

            if ( (pImeDpi = ImmLockImeDpi(hKlCurrent)) != NULL ) {

                bRet = (BOOL)(*pImeDpi->pfn.ImeEscape)( hImc,
                                                  IME_ESC_PRIVATE_HOTKEY,
                                                  (PVOID)&dwHotKeyID );
                ImmUnlockImeDpi(pImeDpi);
                return bRet;
            }
        }
    }
    return (FALSE);
}

/**********************************************************************/
/* JCloseOpen()                                                       */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL JCloseOpen(         // open/close toggle
    HIMC        hIMC,
    HKL         hCurrentKL,
    HWND        hWnd)
{

    if (ImmIsIME(hCurrentKL) &&
            LOWORD(HandleToUlong(hCurrentKL)) == MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT)) {
        //
        // If current KL is IME and its language is Japanese,
        // we only have to switch the open/close status.
        //
        ImmSetOpenStatus( hIMC, !ImmGetOpenStatus(hIMC) );
    } else {
        //
        // If current KL is not IME or its language is not Japanese,
        // we should find the Japanese IME and set it open.
        //
        if (IMENonIMEToggle(hIMC, hCurrentKL, hWnd, FALSE, MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT))) {
            //
            // Mark it so that later we can initialize the fOpen
            // as expected.
            //
            PINPUTCONTEXT pInputContext = ImmLockIMC(hIMC);

            if (pInputContext) {
                pInputContext->fdwDirty |= IMSS_INIT_OPEN;
                ImmUnlockIMC(hIMC);
            }
        }
    }
    return TRUE;

#if 0   // for your reference : old code ported from Win95
    LPINPUTCONTEXT pInputContext;
    PIMEDPI            pImeDpi;


    if ( (pInputContext = ImmLockIMC( hIMC )) == NULL ) {
    //
    // The return value is same as Win95.
    // Not happens so often any way.
    //
        return TRUE;
    }

    pImeDpi = ImmLockImeDpi( hCurrentKL );
    if ( pImeDpi != NULL ) {
    //
    // update Input Context
    //
        pInputContext->fOpen = !pInputContext->fOpen;

    //
    // notify IME
    //
        (*pImeDpi->pfn.NotifyIME)( hIMC,
                                   NI_CONTEXTUPDATED,
                                   0L,
                                   IMC_SETOPENSTATUS );
    //
    // inform UI
    //
        SendMessage(hWnd, WM_IME_NOTIFY, IMN_SETOPENSTATUS, 0L);
        SendMessage(hWnd, WM_IME_SYSTEM, IMS_SETOPENSTATUS, 0L);

        ImmUnlockIMC( hIMC );
        ImmUnlockImeDpi(pImeDpi);
        return TRUE;

    } else {

        if ( !pInputContext->fOpen ) {
            pInputContext->fOpen = TRUE;
            SendMessage(hWnd, WM_IME_NOTIFY, IMN_SETOPENSTATUS, 0L);
            SendMessage(hWnd, WM_IME_SYSTEM, IMS_SETOPENSTATUS, 0L);
        }
        ImmUnlockIMC( hIMC );

        return IMENonIMEToggle(hIMC, hCurrentKL, hWnd, FALSE);
    }
#endif
}

/***************************************************************************\
* HotkeyImmIsIME
*
* Checks whether the specified hKL is a HKL of an IME or not.
*
\***************************************************************************/

BOOL HotkeyImmIsIME(
    HKL hKL)
{
#if defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
        return FALSE;
#else
    if (!ImmIsIME(hKL))
        return FALSE;
#endif

    return TRUE;
}

/**********************************************************************/
/* CIMENonIMEToggle()                                                 */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL CIMENonIMEToggle(   // non-IME and IME toggle
    HIMC        hIMC,
    HKL         hKlCurrent,
    HWND        hWnd,
    LANGID      langId)
{
    if (hWnd == NULL)
        return(FALSE);

    if (!HotkeyImmIsIME(hKlCurrent) || LOWORD(HandleToUlong(hKlCurrent)) != langId) 
    {
        //
        // Current keyboard layout is not IME or its language does not match.
        // Let's try to switch to our IME.
        //
        IMENonIMEToggle(hIMC, hKlCurrent, hWnd, FALSE, langId);
        return TRUE;

    } else {

        LPINPUTCONTEXT pInputContext = ImmLockIMC( hIMC );

        if ( pInputContext == NULL ) {
            //
            // returning TRUE even if we didn't change
            //
            return TRUE;
        }
        if (!pInputContext->fOpen) {
            //
            // toggle close to open
            //
            ImmSetOpenStatus(hIMC, TRUE);
            ImmUnlockIMC(hIMC);
            return TRUE;
        } else {
            ImmUnlockIMC(hIMC);
            IMENonIMEToggle(hIMC, hKlCurrent, hWnd, TRUE, 0);
            return TRUE;
        }
    }
}

/**********************************************************************/
/* IMENonIMEToggle()                                                  */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL IMENonIMEToggle(
    HIMC        hIMC,
    HKL         hCurrentKL,
    HWND        hWnd,
    BOOL        fCurrentIsIME,
    LANGID      langTarget)
{
    HKL  hEnumKL[32], hTargetKL;
    UINT nLayouts, i;
    HKL hPrevKL;

    UNREFERENCED_PARAMETER(hIMC);

    hPrevKL = (HKL)NtUserGetThreadState( UserThreadStatePreviousKeyboardLayout );

    //
    // If we find the same layout in the layout list, let's switch to
    // the layout. If we fail, let's switch to a first-found good
    // layout.
    //

    hTargetKL = NULL;
    nLayouts = GetKeyboardLayoutList(sizeof(hEnumKL)/sizeof(HKL), hEnumKL);

    // LATER:
    // Hmm, looks like we can't simply rely on hPrevKL on multiple lanugage
    // environment..
    //
    if (hPrevKL != NULL) {
        if (langTarget == 0 || LOWORD(HandleToUlong(hPrevKL)) == langTarget) {
            //
            // If langtarget is not specified, or
            // if it matches the previous langauge.
            //
            for (i = 0; i < nLayouts; i++) {
                // valid target HKL
                if (hEnumKL[i] == hPrevKL) {
                    hTargetKL = hPrevKL;
                    break;
                }
            }
        }
    }
    if (hTargetKL == NULL) {
        for (i = 0; i < nLayouts; i++) {
            // find a valid target HKL
            if (fCurrentIsIME ^ HotkeyImmIsIME(hEnumKL[i])) {
                if (langTarget != 0 && LOWORD(HandleToUlong(hEnumKL[i])) != langTarget) {
                    // If the target language is specified, check it
                    continue;
                }
                hTargetKL = hEnumKL[i];
                break;
            }
        }
    }
    if (hTargetKL != NULL && hCurrentKL != hTargetKL) {

        // depends on multilingual message and how to get the base charset
        // wait for confirmation of multiingual spec - tmp solution
        PostMessage(hWnd, WM_INPUTLANGCHANGEREQUEST, DEFAULT_CHARSET, (LPARAM)hTargetKL);
    }
    //
    // returning TRUE, even if we failed to switch
    //
    return HotkeyImmIsIME(hTargetKL);
}

/**********************************************************************/
/* CSymbolToggle()                                                    */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL CSymbolToggle(              // symbol & non symbol toggle
    HIMC        hIMC,
    HKL         hKL,
    HWND        hWnd)
{
    LPINPUTCONTEXT pInputContext;

    //
    // Return TRUE even no layout switching - Win95 behavior
    //
    if (hWnd == NULL)
        return(FALSE);

    if ( ! HotkeyImmIsIME( hKL ) ) {
        return (FALSE);
    }

    if ( (pInputContext = ImmLockIMC( hIMC )) == NULL ) {
        //
        // The return value is same as Win95.
        // Not happens so often any way.
        //
        return TRUE;
    }

    if (pInputContext->fOpen) {
        //
        // toggle the symbol mode
        //
        ImmSetConversionStatus(hIMC,
                               pInputContext->fdwConversion ^ IME_CMODE_SYMBOL,
                               pInputContext->fdwSentence);
    }
    else {
        //
        // change close -> open
        //
        ImmSetOpenStatus(hIMC, TRUE);
    }

    ImmUnlockIMC(hIMC);
    return (TRUE);

}

/**********************************************************************/
/* TShapeToggle()                                                     */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL TShapeToggle(               // fullshape & halfshape toggle
    HIMC        hIMC,
    HKL         hKL,
    HWND        hWnd)
{
    LPINPUTCONTEXT pInputContext;

    //
    // Return TRUE even no layout switching - Win95 behavior
    //
    if (hWnd == NULL)
        return(FALSE);

    if ( ! HotkeyImmIsIME( hKL ) ) {
        return (FALSE);
    }

    if ( (pInputContext = ImmLockIMC( hIMC )) == NULL ) {
        //
        // The return value is same as Win95.
        // Not happens so often any way.
        //
        return TRUE;
    }

    if (pInputContext->fOpen) {
        //
        // toggle the symbol mode
        //
        ImmSetConversionStatus(hIMC,
                               pInputContext->fdwConversion ^ IME_CMODE_FULLSHAPE,
                               pInputContext->fdwSentence);
    }
    else {
        //
        // change close -> open
        //
        ImmSetOpenStatus(hIMC, TRUE);
    }

    ImmUnlockIMC(hIMC);
    return (TRUE);
}

/**********************************************************************/
/* KEnglishHangul() - Egnlish & Hangeul toggle                       */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL KEnglishHangul( HIMC hImc )
{
    PINPUTCONTEXT pInputContext;

    if ((pInputContext = ImmLockIMC(hImc)) != NULL) {

        ImmSetConversionStatus(hImc,
                pInputContext->fdwConversion ^ IME_CMODE_HANGEUL,
                pInputContext->fdwSentence);

        if ((pInputContext->fdwConversion & IME_CMODE_HANGEUL) ||
                (pInputContext->fdwConversion & IME_CMODE_FULLSHAPE)) {
            ImmSetOpenStatus(hImc, TRUE);
        } else {
            ImmSetOpenStatus(hImc, FALSE);
        }
        ImmUnlockIMC(hImc);
        return TRUE;
    }

    return FALSE;
}

/**********************************************************************/
/* KShapeToggle() - Fullshape & Halfshape toggle                      */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL KShapeToggle( HIMC hImc )
{
    PINPUTCONTEXT pInputContext;

    if ( (pInputContext = ImmLockIMC( hImc )) != NULL ) {

        ImmSetConversionStatus(hImc,
            pInputContext->fdwConversion ^ IME_CMODE_FULLSHAPE,
            pInputContext->fdwSentence);

        if ((pInputContext->fdwConversion & IME_CMODE_HANGEUL)
                || (pInputContext->fdwConversion & IME_CMODE_FULLSHAPE))
            ImmSetOpenStatus(hImc, TRUE);
        else
            ImmSetOpenStatus(hImc, FALSE);
        ImmUnlockIMC(hImc);
        return TRUE;
    }

    return FALSE;
}

/**********************************************************************/
/* KHanjaConvert() - Hanja conversion toggle                          */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL KHanjaConvert( HIMC hImc )
{
    PINPUTCONTEXT pInputContext;

    if ( (pInputContext = ImmLockIMC( hImc )) != NULL ) {

        ImmSetConversionStatus( hImc,
                                pInputContext->fdwConversion ^ IME_CMODE_HANJACONVERT,
                                pInputContext->fdwSentence );

        ImmUnlockIMC( hImc );
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\imemenu.c ===
//////////////////////////////////////////////////////////////////////////
// imemenu.c -     IME Menu APIs
//
// handles IME specific menu retrieval
//
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
// History:
// 23-Mar-1997 hiroyama Created
//////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#ifdef HIRO_DEBUG
#define D(x)    x
#else
#define D(x)
#endif

#define IME_MENU_FILE_NAME  L"ImmMenuInfo"
#define IME_MENU_MAXMEM     (128 * 1024)   // maximum size of mapped file

////////////////////////////////////////////////////////////
// private structurs for inter process communication
//
// NOTE for NT50: these are dedicated to internat.exe
//
// uses memory mapped file as shared buffer
// all strings expect UNICODE
// HBITMAP is de-compiled and then compiled again using
// internat.exe's context
//
////////////////////////////////////////////////////////////

typedef struct _IMEMENU_BMP_HEADER {
    struct _IMEMENU_BMP_HEADER* lpNext;
    HBITMAP hBitmap;
    LPBYTE pBits;
    BITMAPINFO bmi;
} IMEMENU_BMP_HEADER;

typedef struct {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    IMEMENU_BMP_HEADER* lpBmpChecked;
    IMEMENU_BMP_HEADER* lpBmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[IMEMENUITEM_STRING_SIZE];    // menu string: always UNICODE.
    IMEMENU_BMP_HEADER* lpBmpItem;   // NULL means no bitmap in this menu
} IMEMENU_ITEM;

typedef struct {
    DWORD dwVersion;                // holds version of this memory chunk
    DWORD dwMemSize;                // size of memory buffer allocated
    DWORD dwFlags;                  // flags returned from IME
    DWORD dwType;
    IMEMENU_ITEM* lpImeParentMenu;  // parent menu's offset (if any) passed from requester
    IMEMENU_ITEM* lpImeMenu;        // offset to first menu item (will be set by IME side)
    DWORD dwSize;                   // number of menus to fill (not byte count)
    IMEMENU_BMP_HEADER* lpBmp;      // offset to first bitmap header
    IMEMENU_BMP_HEADER* lpBmpNext;  // points next available location for bmp buffer
} IMEMENU_HEADER;


// address conversion
#define CONVTO_OFFSET(x)    ((x) = (LPVOID)((x) ? ((LPBYTE)(x) - offset) : NULL))
#define CONVTO_PTR(x)       ((x) = (LPVOID)((x) ? ((LPBYTE)(x) + offset) : NULL))

#if DBG
#define CHK_OFFSET(x)       if ((ULONG_PTR)(x) >= pHeader->dwMemSize) { \
                                RIPMSG2(RIP_WARNING, "CHK_OFFSET(%s=%lx) is out of range.", #x, (ULONG_PTR)(x)); \
                            }
#define CHK_PTR(x)          if ((LPVOID)(x) < (LPVOID)pHeader || (LPBYTE)(x) > (LPBYTE)pHeader + pHeader->dwMemSize) { \
                                if ((x) != NULL) { \
                                    RIPMSG2(RIP_WARNING, "CHK_PTR(%s=%lx) is out of range.", #x, (ULONG_PTR)(x)); \
                                    DebugBreak(); \
                                } \
                            }
#else
#define CHK_OFFSET(x)
#define CHK_PTR(x)          if ((x) != NULL) { \
                                if ((LPVOID)(x) < (LPVOID)pHeader || (LPBYTE)(x) > (LPBYTE)pHeader + pHeader->dwMemSize) { \
                                    goto cleanup; \
                                } \
                            }
#endif

int ConvertImeMenuItemInfoAtoW(LPIMEMENUITEMINFOA lpA, LPIMEMENUITEMINFOW lpW, int nCP, BOOL copyBmp)
{
    int i;

    lpW->cbSize         = lpA->cbSize;
    lpW->fType          = lpA->fType;
    lpW->fState         = lpA->fState;
    lpW->wID            = lpA->wID;
    if (copyBmp) {
        lpW->hbmpChecked    = lpA->hbmpChecked;
        lpW->hbmpUnchecked  = lpA->hbmpUnchecked;
        lpW->hbmpItem       = lpA->hbmpItem;
    }
    lpW->dwItemData     = lpA->dwItemData;

    i = MultiByteToWideChar(nCP,
                            0,
                            lpA->szString,
                            lstrlenA(lpA->szString),
                            lpW->szString,
                            IMEMENUITEM_STRING_SIZE);

    if (i >= IMEMENUITEM_STRING_SIZE) {
        return 0;
    }
    else {
        lpW->szString[i] = L'\0';
    }
    return i;
}

int ConvertImeMenuItemInfoWtoA(LPIMEMENUITEMINFOW lpW, LPIMEMENUITEMINFOA lpA, int nCP)
{
    int i;
    BOOL bUDC;

    lpA->cbSize         = lpW->cbSize;
    lpA->fType          = lpW->fType;
    lpA->fState         = lpW->fState;
    lpA->wID            = lpW->wID;
    lpA->hbmpChecked    = lpW->hbmpChecked;
    lpA->hbmpUnchecked  = lpW->hbmpUnchecked;
    lpA->dwItemData     = lpW->dwItemData;
    lpA->hbmpItem       = lpW->hbmpItem;


    i = WideCharToMultiByte(nCP,
                            0,
                            lpW->szString,
                            wcslen(lpW->szString),
                            lpA->szString,
                            IMEMENUITEM_STRING_SIZE,
                            (LPSTR)NULL,
                            &bUDC);

    if (i >= IMEMENUITEM_STRING_SIZE) {
        return 0;
    }
    else {
        lpA->szString[i] = '\0';
    }
    return i;
}


#if DBG
void DumpBytes(LPBYTE pb, UINT size)
{
    UINT i;
    TRACE(("\npbmi dump:"));
    for (i = 0; i < size; ++i) {
        TRACE(("%02X ", pb[i] & 0xff));
    }
    TRACE(("\n"));
    UNREFERENCED_PARAMETER(pb); // just in case
}
#else
#define DumpBytes(a,b)
#endif

////////////////////////////////////////////////////////////////////
// SaveBitmapToMemory

IMEMENU_BMP_HEADER* SaveBitmapToMemory(HDC hDC, HBITMAP hBmp, IMEMENU_BMP_HEADER* lpBH, IMEMENU_HEADER* pHeader)
{
    HBITMAP hTmpBmp, hBmpOld;
    IMEMENU_BMP_HEADER* lpNext = NULL;
    PBITMAPINFO pbmi = &lpBH->bmi;
    ULONG sizBMI;


    if (!hBmp) {
        RIPMSG0(RIP_WARNING, "SaveBitmapToMemory: hBmp == NULL");
        return NULL;
    }
    UserAssert(lpBH != NULL);

    //
    // Let the graphics engine to retrieve the dimension of the bitmap for us
    // GetDIBits uses the size to determine if it's BITMAPCOREINFO or BITMAPINFO
    // if BitCount != 0, color table will be retrieved
    //
    pbmi->bmiHeader.biSize = sizeof pbmi->bmiHeader;
    pbmi->bmiHeader.biBitCount = 0;             // don't get the color table
    if ((GetDIBits(hDC, hBmp, 0, 0, (LPSTR)NULL, pbmi, DIB_RGB_COLORS)) == 0) {
        RIPMSG0(RIP_WARNING, "SaveBitmapToMemory: failed to GetDIBits(NULL)");
       return NULL;
    }


    //
    // Note: 24 bits per pixel has no color table.  So, we don't have to
    // allocate memory for retrieving that.  Otherwise, we do.
    //
    switch (pbmi->bmiHeader.biBitCount) {
        case 24:                                      // has color table
            sizBMI = sizeof(BITMAPINFOHEADER);
            break;
        case 16:
        case 32:
            sizBMI = sizeof(BITMAPINFOHEADER) + sizeof(DWORD) * 3;
            break;
        default:
            sizBMI = sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * (1 << pbmi->bmiHeader.biBitCount);
            break;

    }

    //
    // check if the buffer has enough space to put bitmap
    //
    if ((LPBYTE)pHeader + pHeader->dwMemSize < (LPBYTE)lpBH + sizeof lpBH + sizBMI + pbmi->bmiHeader.biSizeImage) {
        RIPMSG0(RIP_WARNING, "SaveBitmapToMemory: size of bmp image(s) exceed limit ");
        return FALSE;
    }

    //
    // Now that we know the size of the image, let pBits point the given buffer
    //
    lpBH->pBits = (LPBYTE)pbmi + sizBMI;

    //
    // Bitmap can't be selected into a DC when calling GetDIBits
    // Assume that the hDC is the DC where the bitmap would have been selected
    // if indeed it has been selected
    //
    if (hTmpBmp = CreateCompatibleBitmap(hDC, pbmi->bmiHeader.biWidth, pbmi->bmiHeader.biHeight)) {
        hBmpOld = SelectObject(hDC, hTmpBmp);
        if (GetDIBits(hDC, hBmp, 0, pbmi->bmiHeader.biHeight, (LPSTR)lpBH->pBits, pbmi, DIB_RGB_COLORS) == 0){
            SelectObject(hDC, hBmpOld);
            RIPMSG0(RIP_WARNING, "SaveBitmapToMemory: GetDIBits() failed.");
            return NULL;
        }
        lpNext = (IMEMENU_BMP_HEADER*)((LPBYTE)pbmi + sizBMI + pbmi->bmiHeader.biSizeImage);

        DumpBytes((LPBYTE)pbmi, sizeof *pbmi);
    } else {
        RIPMSG0(RIP_WARNING, "SaveBitmapToMemory: CreateCompatibleBitmap() failed.");
        return NULL;
    }

    SelectObject(hDC, hBmpOld);
    DeleteObject(hTmpBmp);
    return lpNext;
}

//////////////////////////////////////////////////////////////////////////////
// DecompileBitmap()
//
// decompile given hBitmap into IMEMENU_BMP_HEADER
// manupilate IMEMENU_BMP_HEADER links in IMEMENU_HEADER
//
// History:
// 23-Mar-1997 HiroYama Created
//////////////////////////////////////////////////////////////////////////////

IMEMENU_BMP_HEADER* DecompileBitmap(IMEMENU_HEADER* pHeader, HBITMAP hBitmap)
{
    IMEMENU_BMP_HEADER* pBmp = pHeader->lpBmp;
    HDC hDC;

    // first search handled bitmap
    while (pBmp) {
        if (pBmp->hBitmap == hBitmap) {
            // if hBitmap is already de-compiled, return it
            return pBmp;
        }
        pBmp = pBmp->lpNext;
    }

    // not yet allocated, so prepare memory buffer
    pBmp = pHeader->lpBmpNext;
    UserAssert(pBmp != NULL);
    CHK_PTR(pBmp);
    if (pBmp == NULL) {
        RIPMSG1(RIP_WARNING, "DecompileBitmap: pBmp == NULL in L%d", __LINE__);
        return NULL;
    }

    // use desktop's DC
    hDC = GetDC(GetDesktopWindow());
    if (hDC == NULL) {
        RIPMSG1(RIP_WARNING, "DecompileBitmap: hDC == NULL in L%d", __LINE__);
        return NULL;
    }

    //
    // decompile hBitmap
    //
    pBmp->lpNext = pHeader->lpBmp;
    pHeader->lpBmpNext = SaveBitmapToMemory(hDC, hBitmap, pBmp, pHeader);
    if (pHeader->lpBmpNext == NULL) {
        RIPMSG1(RIP_WARNING, "DecompileBitmap: pHeader->lpBmpNext == NULL in L%d", __LINE__);
        // error case. restore bmp link, then returns NULL
        pHeader->lpBmpNext = pBmp;
        pHeader->lpBmp = pBmp->lpNext;
        pBmp = NULL;
        goto cleanup;
    }

    // if succeeded, mark this BITMAP_HEADER with hBitmap
    pBmp->hBitmap = hBitmap;

    //
    // put this BITMAP_HEADER in linked list
    //
    pHeader->lpBmp = pBmp;

cleanup:
    if (hDC)
        ReleaseDC(GetDesktopWindow(), hDC);
    return pBmp;
}

//////////////////////////////////////////////////////////////////////////////
// ImmPutImeMenuItemsIntoMappedFile()
//
// Interprocess IME Menu handler
//
// called from ImeSystemHandler() in user32.dll
//
// handler of WM_IME_SYSTEM:IMS_MENU_ITEM
//
// History:
// 23-Mar-1997 HiroYama Created
//////////////////////////////////////////////////////////////////////////////

LRESULT ImmPutImeMenuItemsIntoMappedFile(HIMC hImc)
{
    HANDLE hMap = NULL;
    LPVOID lpMap = NULL;
    IMEMENU_HEADER* pHeader;
    LPIMEMENUITEMINFO lpBuf = NULL;
    IMEMENU_ITEM* pMenu;
    IMEMENU_BMP_HEADER* pBmp;
    LRESULT lRet = 0;
    ULONG_PTR offset;
    DWORD i;

    // Open memory mapped file
    hMap = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, IME_MENU_FILE_NAME);
    if (hMap == NULL) {
        RIPMSG0(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: cannot open mapped file.");
        return 0L;
    }

    // Map entire view of the file into the process memory space
    lpMap = MapViewOfFile(hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);
    if (lpMap == NULL) {
        RIPMSG0(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: cannot map view of file.");
        goto cleanup;
        // I wish if I could use C++...
    }

    pHeader = (IMEMENU_HEADER*)lpMap;

    ///////////////////
    // Version check
    ///////////////////
    if (pHeader->dwVersion != 1) {
        RIPMSG1(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: dwVersion(%d) does not match.",
                pHeader->dwVersion);
        goto cleanup;
    }

    //////////////////////////////
    // convert offset to pointer
    offset = (ULONG_PTR)pHeader;
    CONVTO_PTR(pHeader->lpImeParentMenu);
    CHK_PTR(pHeader->lpImeParentMenu);
    pMenu = CONVTO_PTR(pHeader->lpImeMenu);
    CHK_PTR(pHeader->lpImeMenu);
    if (pHeader->dwSize) {
        UserAssert(pHeader->lpImeMenu);    // if dwSize is specified, we need real buffer here
        lpBuf = ImmLocalAlloc(HEAP_ZERO_MEMORY, pHeader->dwSize * sizeof(IMEMENUITEMINFOW));
        if (lpBuf == NULL) {
            RIPMSG0(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: not enough memory for receiver's buffer.");
            goto cleanup;
        }
    }


    // preparation
#if DBG
    if (pHeader->lpImeParentMenu) {
        UserAssert(!pHeader->lpImeParentMenu->lpBmpChecked &&
                   !pHeader->lpImeParentMenu->lpBmpUnchecked &&
                   !pHeader->lpImeParentMenu->lpBmpItem);
    }
#endif

    //////////////////////////////////
    // Get IME menus
    pHeader->dwSize = ImmGetImeMenuItemsW(hImc, pHeader->dwFlags, pHeader->dwType,
                                 (LPIMEMENUITEMINFOW)pHeader->lpImeParentMenu, lpBuf,
                                  pHeader->dwSize * sizeof(IMEMENUITEMINFOW));
    // now, pHeader->dwSize contains number of menu items rather than byte size
    if (pHeader->dwSize == 0) {
        goto cleanup;
    }
    //////////////////////////////////

    //
    // Copy back the information
    //
    // if lpBuf != NULL, we need to copy back information
    //
    if (lpBuf) {
        LPIMEMENUITEMINFO lpMenuW = lpBuf;

        pHeader->lpBmp = NULL;
        // lpBmpNext will point first possible memory for bmp de-compile
        pHeader->lpBmpNext = (LPVOID)((LPBYTE)pHeader + (pHeader->dwSize + 1) * sizeof(IMEMENUITEMINFOW));

        // copy menuinfo
        for (i = 0; i < pHeader->dwSize; ++i, ++pMenu, ++lpMenuW) {
            RtlCopyMemory(pMenu, lpMenuW, sizeof *lpMenuW);
            // decompile hbitmap
            if (lpMenuW->hbmpChecked) {
                if ((pMenu->lpBmpChecked = DecompileBitmap(pHeader, lpMenuW->hbmpChecked)) == NULL) {
                    RIPMSG1(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: DecompileBitmap Failed in L%d", __LINE__);
                    goto cleanup;
                }
            }
            if (lpMenuW->hbmpUnchecked) {
                if ((pMenu->lpBmpUnchecked = DecompileBitmap(pHeader, lpMenuW->hbmpUnchecked)) == NULL) {
                    RIPMSG1(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: DecompileBitmap Failed in L%d", __LINE__);
                    goto cleanup;
                }
            }
            if (lpMenuW->hbmpItem) {
                if ((pMenu->lpBmpItem = DecompileBitmap(pHeader, lpMenuW->hbmpItem)) == NULL) {
                    RIPMSG1(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: DecompileBitmap Failed in L%d", __LINE__);
                    goto cleanup;
                }
            }
        }

        //////////////////////////////////////////////////////////////////////
        //
        // convert pointer to offset
        //

        pMenu = pHeader->lpImeMenu;
        CONVTO_OFFSET(pHeader->lpImeMenu);
        // no need to convert parent menu, so let it be NULL
        D(pHeader->lpImeParentMenu = NULL);

        // pointer to BITMAP_HEADER in each menu
        for (i = 0; i < pHeader->dwSize; ++i, ++pMenu) {
            TRACE(("ImmPutImeMenuItemsIntoMappedFile: convertiong '%S'\n", pMenu->szString));
            CONVTO_OFFSET(pMenu->lpBmpChecked);
            CONVTO_OFFSET(pMenu->lpBmpUnchecked);
            TRACE(("ImmPutImeMenuItemsIntoMappedFile: before conversion (%#lx)\n", pMenu->lpBmpItem));
            CONVTO_OFFSET(pMenu->lpBmpItem);
            TRACE(("ImmPutImeMenuItemsIntoMappedFile: after  conversion (%#lx)\n", pMenu->lpBmpItem));

            // check them
            CHK_OFFSET(pMenu->lpBmpChecked);
            CHK_OFFSET(pMenu->lpBmpChecked);
            CHK_OFFSET(pMenu->lpBmpItem);
        }

        //
        // first pointer to BITMAP_HEADER linked list
        //
        pBmp = pHeader->lpBmp;
        CONVTO_OFFSET(pHeader->lpBmp);
        CHK_OFFSET(pHeader->lpBmp);
        // pHeader->lpBmpNext will not be used, so let it be NULL
        D(pHeader->lpBmpNext = NULL);

        //
        // pointers in BITMAP_HEADER linked list
        //
        while (pBmp) {
            IMEMENU_BMP_HEADER* ptBmp = pBmp->lpNext;
            CONVTO_OFFSET(pBmp->pBits);
            CONVTO_OFFSET(pBmp->lpNext);
            CHK_OFFSET(pBmp->lpNext);
            pBmp = ptBmp;
        }
        //
        // pointer conversion finished
        //
        //////////////////////////////////////////////////////////////////////
    } // end if (lpBuf)

    //
    // everything went OK
    //
    lRet = 1;

cleanup:
    if (lpBuf)
        ImmLocalFree(lpBuf);
    if (lpMap)
        UnmapViewOfFile(lpMap);
    if (hMap)
        CloseHandle(hMap);
    return lRet;
}


//////////////////////////////////////////////////////////////////////////////
// InternalImeMenuCreateBitmap()
//
// create bitmap from IMEMENU_BMP_HEADER
//////////////////////////////////////////////////////////////////////////////

HBITMAP InternalImeMenuCreateBitmap(IMEMENU_BMP_HEADER* lpBH)
{
    HDC hDC;

    if (lpBH == NULL) {
        RIPMSG1(RIP_WARNING, "InternalImeMenuCreateBitmap: lpBH == NULL in L%d", __LINE__);
        return NULL;
    }
    if (lpBH->pBits == NULL) {
        RIPMSG1(RIP_WARNING, "InternalImeMenuCreateBitmap: lpBH->pBits == NULL in L%d", __LINE__);
        return NULL;
    }

    if (lpBH->hBitmap) {
        TRACE(("InternalImeMenuCreateBitmap: lpBH->hBitmap != NULL. will return it.\n"));
        return lpBH->hBitmap;
    }

    if (hDC = GetDC(GetDesktopWindow())) {
        HDC hMyDC = CreateCompatibleDC(hDC);
        if (hMyDC) {
            // (select palette) needed ?
            lpBH->hBitmap = CreateDIBitmap(hDC, &lpBH->bmi.bmiHeader, CBM_INIT,
                                                  lpBH->pBits, &lpBH->bmi, DIB_RGB_COLORS);
            if (lpBH->hBitmap == NULL) {
                DWORD dwErr = GetLastError();
                RIPMSG1(RIP_WARNING, "InternalImeMenuCreateBitmap: CreateDIBitmap Failed. Last error=%#x\n", dwErr);
            }
            DeleteDC(hMyDC);
        }
        else {
            RIPMSG0(RIP_WARNING, "InternalImeMenuCreateBitmap: CreateCompatibleDC failed.");
        }

        ReleaseDC(GetDesktopWindow(), hDC);
    }
    else {
        RIPMSG0(RIP_WARNING, "InternalImeMenuCreateBitmap: couldn't get Desktop DC.");
    }
    return lpBH->hBitmap;
}

//////////////////////////////////////////////////////////////////////////////
// ImmGetImeMenuItemsInterProcess()
//
// Inter process IME Menu handler
// sends WM_IME_SYSTEM:IMS_GETIMEMENU
//
// History:
// 23-Mar-1997 HiroYama Created
//////////////////////////////////////////////////////////////////////////////

DWORD ImmGetImeMenuItemsInterProcess(HIMC hImc,
                                     DWORD dwFlags,
                                     DWORD dwType,
                                     LPIMEMENUITEMINFOW lpParentMenu,
                                     LPIMEMENUITEMINFOW lpMenu,
                                     DWORD dwSize)
{
    HWND hwnd;
    HANDLE hMemFile = NULL;
    DWORD dwRet = 0;
    LPBYTE lpMap = NULL;
    IMEMENU_HEADER* pHeader;
    IMEMENU_ITEM* pMenuItem;
    IMEMENU_BMP_HEADER* pBmpHeader;
    DWORD i;
    ULONG_PTR offset;

    // Get default IME window
    //
    // Note: We do not consider user created HIMC here, because this inter-process call is intended to
    // support only internat.exe, and this message is passed as just a kick to IMM's def WinProc.
    hwnd = (HWND)NtUserQueryInputContext(hImc, InputContextDefaultImeWindow);
    if (hwnd == NULL || !IsWindow(hwnd)) {
        RIPMSG1(RIP_WARNING, "ImmGetImeMenuItemsInterProcess: hwnd(%lx) is not a valid window.", hwnd);
        return 0;
    }

    RtlEnterCriticalSection(&gcsImeDpi);

    // first, create memory mapped file
    hMemFile = CreateFileMapping((HANDLE)~0, NULL, PAGE_READWRITE,
                                 0, IME_MENU_MAXMEM, IME_MENU_FILE_NAME);
    if (hMemFile == NULL) {
        RIPMSG0(RIP_WARNING, "ImmGetImeMenuItemsInterProcess: cannot allocate memory mapped file.");
        goto cleanup;
    }
    // then get a view of the mapped file
    lpMap = (LPBYTE)MapViewOfFile(hMemFile, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
    if (lpMap == NULL) {
        RIPMSG0(RIP_WARNING, "ImmGetImeMenuItemsInterProcess: cannot map view of memory mapped file.");
        goto cleanup;
    }

    //
    // shared buffer (memory mapped file) initialization
    //
    pHeader = (IMEMENU_HEADER*)lpMap;
    RtlZeroMemory(pHeader, sizeof *pHeader);
    pHeader->dwVersion = 1;
    pHeader->dwMemSize = IME_MENU_MAXMEM;
    pHeader->dwSize = dwSize / sizeof(IMEMENUITEMINFOW);    // CAUTION: dwSize could be 0.
    RIPMSG1(RIP_WARNING, "ImmGetImeMenuItemsInterProcess: pHeader->dwSize=%ld", pHeader->dwSize);
    pHeader->dwFlags = dwFlags;
    pHeader->dwType = dwType;

    //
    // 1) dwSize != 0 and lpMenu != NULL means, caller requests the given buffer filled
    // 2) if lpParentMenu is passed, we need to put its information in shared buffer
    //
    if ((dwSize && lpMenu) || lpParentMenu) {
        // if parent menu is specified, copy it here
        if (lpParentMenu) {
            IMEMENU_ITEM* pPMenu =
                pHeader->lpImeParentMenu = (IMEMENU_ITEM*)&pHeader[1];

            RtlCopyMemory(pPMenu, lpParentMenu, sizeof(IMEMENUITEMINFOW));

            // by design, IME will receive NULL hbmpItem in parent menu.
            // there is no way to guarantee the same hbmpItem is returned, thus NULL is passed.
            pPMenu->lpBmpChecked = pPMenu->lpBmpUnchecked = pPMenu->lpBmpItem = NULL;
            pHeader->lpImeMenu = pHeader->lpImeParentMenu + 1;
        }
        else {
            pHeader->lpImeParentMenu = NULL;
            pHeader->lpImeMenu = (LPVOID)&pHeader[1];
        }
        // convert pointer to offset
        offset = (ULONG_PTR)lpMap;
        CONVTO_OFFSET(pHeader->lpImeParentMenu);
        CONVTO_OFFSET(pHeader->lpImeMenu);
    }




    ///////////////////////////////////////////////////////////////////////
    if (!SendMessage(hwnd, WM_IME_SYSTEM, IMS_GETIMEMENU, (LPARAM)hImc)) {
        // if it fails
        goto cleanup;
    }
    ///////////////////////////////////////////////////////////////////////

    // NOTE: dwSize is maximum index of menu array. not a total byte size of array.
    dwSize = pHeader->dwSize;

    if (lpMenu) {
        ///////////////////////////////
        // convert offset to pointer
        ///////////////////////////////
        pMenuItem = CONVTO_PTR(pHeader->lpImeMenu);
        CHK_PTR(pMenuItem);
        // NOTE: we don't have to handle parent menu

        //
        // pointers to BITMAP_HEADER in each menu structure
        //
        for (i = 0; i < dwSize; ++i, ++pMenuItem) {
            CONVTO_PTR(pMenuItem->lpBmpChecked);
            CONVTO_PTR(pMenuItem->lpBmpUnchecked);
            CONVTO_PTR(pMenuItem->lpBmpItem);
            //
            // check the pointers
            //
            CHK_PTR(pMenuItem->lpBmpChecked);
            CHK_PTR(pMenuItem->lpBmpUnchecked);
            CHK_PTR(pMenuItem->lpBmpItem);
        }

        //
        // pointer to first BITMAP_HEADER
        //
        pBmpHeader = CONVTO_PTR(pHeader->lpBmp);

        //
        // each BITMAP_HEADER
        //
        while (pBmpHeader) {
            pBmpHeader->hBitmap = NULL;    // clear
            // pBits
            CONVTO_PTR(pBmpHeader->pBits);
            CHK_PTR(pBmpHeader->pBits);

            // next BITMAP_HEADER
            pBmpHeader = CONVTO_PTR(pBmpHeader->lpNext);
            CHK_PTR(pBmpHeader);
        }

        //
        // copy back the results
        //
        pMenuItem = pHeader->lpImeMenu;
        for (i = 0; i < dwSize; ++i, ++pMenuItem, ++lpMenu) {
            lpMenu->cbSize = pMenuItem->cbSize;
            lpMenu->fType = pMenuItem->fType;
            lpMenu->fState = pMenuItem->fState;
            lpMenu->wID = pMenuItem->wID;
            lpMenu->dwItemData = pMenuItem->dwItemData;
            wcsncpy(lpMenu->szString, pMenuItem->szString, ARRAY_SIZE(lpMenu->szString));

            // Create bitmap from memory buffer
            // hbmp will be NULL if no bmp is specified.
            if (pMenuItem->lpBmpChecked) {
                lpMenu->hbmpChecked = InternalImeMenuCreateBitmap(pMenuItem->lpBmpChecked);
            }
            else {
                lpMenu->hbmpChecked = NULL;
            }
            if (pMenuItem->lpBmpUnchecked) {
                lpMenu->hbmpUnchecked = InternalImeMenuCreateBitmap(pMenuItem->lpBmpUnchecked);
            }
            else {
                lpMenu->hbmpUnchecked = NULL;
            }
            if (pMenuItem->lpBmpItem) {
                lpMenu->hbmpItem = InternalImeMenuCreateBitmap(pMenuItem->lpBmpItem);
            }
            else {
                lpMenu->hbmpItem = NULL;
            }
        }
    }


cleanup:
    if (lpMap) {
        UnmapViewOfFile(lpMap);
    }
    RtlLeaveCriticalSection(&gcsImeDpi);
    // destroy memory mapped file
    if (hMemFile) {
        CloseHandle(hMemFile);
    }

    return dwSize;
}

//////////////////////////////////////////////////////////////////////////////
// ImmGetImeMenuItemsWorker()
//
// Handler of IME Menu
//
// if specified HIMC belongs to other process, it calls
// ImmGetImeMenuItemsInterProcess()
//
// History:
// 23-Mar-1997 HiroYama Created
//////////////////////////////////////////////////////////////////////////////


DWORD ImmGetImeMenuItemsWorker(HIMC hIMC,
                               DWORD dwFlags,
                               DWORD dwType,
                               LPVOID lpImeParentMenu,
                               LPVOID lpImeMenu,
                               DWORD dwSize,
                               BOOL bAnsiOrigin)
{
    BOOL bAnsiIme = IsAnsiIMC(hIMC);
    DWORD dwRet = 0;
    LPINPUTCONTEXT lpInputContext;
    DWORD dwThreadId;
    PIMEDPI pImeDpi = NULL;
    LPVOID lpImePTemp = lpImeParentMenu;    // keeps parent menu
    LPVOID lpImeTemp = lpImeMenu;           // points menu buffer
    IMEMENUITEMINFOA imiiParentA;
    IMEMENUITEMINFOW imiiParentW;

    //
    // check if the call will be inter process
    //
    {
        DWORD dwProcessId = GetInputContextProcess(hIMC);
        if (dwProcessId == 0) {
            RIPMSG0(RIP_WARNING, "ImmGetImeMenuItemsWorker: dwProcessId == 0");
            return 0;
        }
        if (dwProcessId != GetCurrentProcessId()) {
            //
            // going to call another process' IME
            //
            TRACE(("ImmGetImeMenuItemsWorker: Inter process.\n"));
            if (bAnsiOrigin) {
                //
                // this inter-process thing is only allowed to internat.exe or equivalent
                //
                RIPMSG0(RIP_WARNING, "ImmGetImeMenuItemsWorker: interprocess getmenu is not allowed for ANSI caller.");
                return 0;
            }
            return ImmGetImeMenuItemsInterProcess(hIMC, dwFlags, dwType, lpImeParentMenu,
                                                  lpImeMenu, dwSize);
        }
    }

    //
    // within process
    //

    if (hIMC == NULL || (lpInputContext = ImmLockIMC(hIMC)) == NULL) {
        RIPMSG2(RIP_WARNING, "ImmGetImeMenuItemsWorker: illegal hIMC(%#lx) in L%d", hIMC, __LINE__);
        return 0;
    }

    dwThreadId = GetInputContextThread(hIMC);
    if (dwThreadId == 0) {
        RIPMSG1(RIP_WARNING, "ImmGetImeMenuItemsWorker: dwThreadId = 0 in L%d", __LINE__);
        goto cleanup;
    }
    if ((pImeDpi = ImmLockImeDpi(GetKeyboardLayout(dwThreadId))) == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetImeMenuItemWorker: pImeDpi == NULL in L%d.", __LINE__);
        goto cleanup;
    }

#if 0   // NT: we don't keep version info in ImeDpi
    if (pImeDpi->dwWinVersion <= IMEVER_0310) {
        RIPMSG1(RIP_WARNING, "GetImeMenuItems: OldIME does not support this. %lx", hIMC);
        goto cleanup;
    }
#endif

    //
    // if IME does not support IME Menu, do nothing
    //
    if (pImeDpi->pfn.ImeGetImeMenuItems) {
        LPVOID lpNewBuf = NULL;

        TRACE(("ImmGetImeMenuItemsWorker: IME has menu callback.\n"));

        if (bAnsiIme != bAnsiOrigin) {
            //
            // we need A/W translation before calling IME
            //
            if (bAnsiOrigin) {
                // ANSI API and UNICODE IME.
                // A to W conversion needed here
                if (lpImeParentMenu) {
                    // parent menu is specified. need conversion
                    lpImePTemp = (LPVOID)&imiiParentW;
                    if (! ConvertImeMenuItemInfoAtoW((LPIMEMENUITEMINFOA)lpImeParentMenu,
                                                     (LPIMEMENUITEMINFOW)lpImePTemp,
                                                      CP_ACP, TRUE)) {  // ANSI app, UNICODE IME: let's use CP_ACP
                        goto cleanup;
                    }
                }
                if (lpImeMenu) {
                    // allocate memory block for temporary storage
                    DWORD dwNumBuffer = dwSize / sizeof(IMEMENUITEMINFOA);
                    dwSize = dwNumBuffer * sizeof(IMEMENUITEMINFOW);
                    if (dwSize == 0) {
                        RIPMSG0(RIP_WARNING, "ImmGetImeMenuItemsWorker: (AtoW) dwSize is 0.");
                        goto cleanup;
                    }
                    lpImeTemp = lpNewBuf = ImmLocalAlloc(0, dwSize);
                    TRACE(("ImmGetImeMenuItemsWorker: for UNICODE IME memory allocated %d bytes. lpNewBuf=%#x\n", dwSize, lpNewBuf));
                    if (lpNewBuf == NULL) {
                        RIPMSG1(RIP_WARNING, "ImmGetImeMenuItemsWorker: cannot alloc lpNewBuf in L%d", __LINE__);
                        goto cleanup;
                    }
                }
            }
            else {
                // UNICODE API and ANSI IME.
                // W to A conversion needed here
                if (lpImeParentMenu) {
                    // parent menu is speicified. need conversion
                    lpImePTemp = (LPVOID)&imiiParentA;
                    if (! ConvertImeMenuItemInfoWtoA((LPIMEMENUITEMINFOW)lpImeParentMenu,
                                                     (LPIMEMENUITEMINFOA)lpImePTemp,
                                                      pImeDpi->dwCodePage)) {   // Note: hopefully in the future, this can be changed to IMECodePage(pImeDpi)
                        goto cleanup;
                    }
                }
                if (lpImeMenu) {
                    // allocate memory block for temporary storage
                    DWORD dwNumBuffer = dwSize / sizeof(IMEMENUITEMINFOW);
                    dwSize = dwNumBuffer / sizeof(IMEMENUITEMINFOA);
                    if (dwSize == 0) {
                        RIPMSG0(RIP_WARNING, "ImmGetImeMenuItemsWorker: (WtoA) dwSize is 0.");
                        goto cleanup;
                    }
                    lpImeTemp = lpNewBuf = ImmLocalAlloc(0, dwSize);
                    RIPMSG2(RIP_WARNING, "ImmGetImeMenuItemsWorker: for ANSI IME memory allocated %d bytes. lpNewBuf=%#x", dwSize, lpNewBuf);
                    if (lpNewBuf == NULL) {
                        RIPMSG1(RIP_WARNING, "ImmGetImeMenuItemsWorker: cannot alloc lpNewBuf in L%d", __LINE__);
                        goto cleanup;
                    }
                }
            }
        }

        ////////////////////////////////////////
        dwRet = pImeDpi->pfn.ImeGetImeMenuItems(hIMC, dwFlags, dwType, lpImePTemp, lpImeTemp, dwSize);
        ////////////////////////////////////////

        //
        // back-conversion needed if:
        // 1) IME returns menus, and
        // 2) A/W is different between caller and IME, and
        // 3) caller wants the buffer to be filled
        //
        if (dwRet && bAnsiIme != bAnsiOrigin && lpImeTemp) {
            if (bAnsiOrigin) {
                // ANSI API and UNICODE IME.
                // W to A conversion needed here
                LPIMEMENUITEMINFOW lpW = (LPIMEMENUITEMINFOW)lpImeTemp;
                LPIMEMENUITEMINFOA lpA = (LPIMEMENUITEMINFOA)lpImeMenu;
                DWORD i;

                for (i = 0; i < dwRet; ++i) {
                    if (! ConvertImeMenuItemInfoWtoA((LPIMEMENUITEMINFOW)lpW++,
                                                     (LPIMEMENUITEMINFOA)lpA++,
                                                      CP_ACP)) {   // ANSI app and UNICODE IME: let's use CP_ACP
                        dwRet = 0;
                        break;
                    }
                }
            }
            else {
                // UNICODE API and ANSI IME.
                // A to W conversion needed here
                LPIMEMENUITEMINFOA lpA = (LPIMEMENUITEMINFOA)lpImeTemp;
                LPIMEMENUITEMINFOW lpW = (LPIMEMENUITEMINFOW)lpImeMenu;
                DWORD i;

                for (i = 0; i < dwSize; i++) {
                    if (! ConvertImeMenuItemInfoAtoW((LPIMEMENUITEMINFOA)lpA++,
                                                     (LPIMEMENUITEMINFOW)lpW++,
                                                     pImeDpi->dwCodePage,     // Note: hopefully in the future, this can be changed to IMECodePage(pImeDpi)
                                                     TRUE)) {  // copy hbitmap also
                        dwRet = 0;
                        break;
                    }
                }
            }
        }

        // free temporary buffer if we've allocated it
        if (lpNewBuf)
            ImmLocalFree(lpNewBuf);
    }   // end if IME has menu callback

cleanup:
    if (pImeDpi) {
        ImmUnlockImeDpi(pImeDpi);
    }

    if (hIMC != NULL) {
        ImmUnlockIMC(hIMC);
    }

    return dwRet;
}


DWORD WINAPI ImmGetImeMenuItemsA(
    HIMC    hIMC,
    DWORD   dwFlags,
    DWORD   dwType,
    LPIMEMENUITEMINFOA lpImeParentMenu,
    LPIMEMENUITEMINFOA lpImeMenu,
    DWORD   dwSize)
{
    return ImmGetImeMenuItemsWorker(hIMC, dwFlags, dwType,
                                    (LPVOID)lpImeParentMenu,
                                    (LPVOID)lpImeMenu, dwSize, TRUE /* ANSI origin */);
}


DWORD WINAPI ImmGetImeMenuItemsW(
    HIMC    hIMC,
    DWORD   dwFlags,
    DWORD   dwType,
    LPIMEMENUITEMINFOW lpImeParentMenu,
    LPIMEMENUITEMINFOW lpImeMenu,
    DWORD   dwSize)
{
    return ImmGetImeMenuItemsWorker(hIMC, dwFlags, dwType,
                                    (LPVOID)lpImeParentMenu,
                                    (LPVOID)lpImeMenu, dwSize, FALSE /* UNICODE origin */);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\immcli.h ===
/****************************** Module Header ******************************\
* Module Name: immcli.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used exclusively by the IMM
* client-side DLL.
*
* History:
* 11-Jan-96 wkwok      Created
\***************************************************************************/

#ifndef _IMMCLI_
#define _IMMCLI_

#pragma once

#define OEMRESOURCE 1

#include <windows.h>

#include <stddef.h>
#include <w32err.h>
#include <w32gdip.h>
#include "winuserp.h"
#include "winuserk.h"
#include "kbd.h"
#include <wowuserp.h>
#include <memory.h>
#include <string.h>
#include <imm.h>
#include <immp.h>
#include <ime.h>
#include <imep.h>
#include <winnls32.h>

#include "immstruc.h"
#include "immuser.h"

#include "user.h"

typedef struct _ENUMREGWORDDATA {
    union {
        REGISTERWORDENUMPROCW w;
        REGISTERWORDENUMPROCA a;
    } lpfn;
    LPVOID lpData;
    DWORD  dwCodePage;
} ENUMREGWORDDATA, *PENUMREGWORDDATA;

#define HEX_ASCII_SIZE          20

typedef struct tagIMELAYOUT {
    HKL     hImeKL;
    WCHAR   szKeyName[HEX_ASCII_SIZE];
    WCHAR   szImeName[IM_FILE_SIZE];
} IMELAYOUT, *PIMELAYOUT;

#define ImmAssert UserAssert

typedef struct tagFE_KEYBOARDS {
    BOOLEAN fJPN : 1;
    BOOLEAN fCHT : 1;
    BOOLEAN fCHS : 1;
    BOOLEAN fKOR : 1;
} FE_KEYBOARDS;

/*
 * Function pointers to registry routines in advapi32.dll.
 */
typedef struct {
    LONG (WINAPI* RegCreateKeyW)(HKEY, LPCWSTR, PHKEY);
    LONG (WINAPI* RegOpenKeyW)(HKEY, LPCWSTR, PHKEY);
    LONG (WINAPI* RegCloseKey)(HKEY);
    LONG (WINAPI* RegDeleteKeyW)(HKEY, LPCWSTR);
    LONG (WINAPI* RegCreateKeyExW)(HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);
    LONG (WINAPI* RegSetValueExW)(HKEY, LPCWSTR, DWORD Reserved, DWORD, CONST BYTE*, DWORD);
    LONG (WINAPI* RegQueryValueExW)(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
    HMODULE hModule;
    BOOLEAN fOk;
} ADVAPI_FN;

/***************************************************************************\
*
* Globals declarations
*
\***************************************************************************/

extern BOOLEAN gfInitialized;
extern HINSTANCE ghInst;
extern PVOID pImmHeap;
extern PSERVERINFO gpsi;
extern SHAREDINFO gSharedInfo;

extern PIMEDPI gpImeDpi;
extern CRITICAL_SECTION gcsImeDpi;

extern POINT     gptWorkArea;
extern POINT     gptRaiseEdge;
extern UINT      guScanCode[0XFF];

extern CONST WCHAR     gszRegKbdLayout[];
#ifdef CUAS_ENABLE
extern CONST WCHAR     gszRegCiceroIME[];
extern CONST WCHAR     gszRegCtfShared[];
extern CONST WCHAR     gszValCUASEnable[];
#endif // CUAS_ENABLE
#ifdef LATER
extern CONST INT       sizeof_gszRegKbdLayout;
#endif
extern CONST WCHAR     gszRegKbdOrder[];
extern CONST WCHAR     gszValLayoutText[];
extern CONST WCHAR     gszValLayoutFile[];
extern CONST WCHAR     gszValImeFile[];

#ifdef CUAS_ENABLE
extern DWORD g_aimm_compat_flags;
#endif // CUAS_ENABLE

/***************************************************************************\
*
* Validation handling
*
\***************************************************************************/

#define bUser32Initialized (gpsi != NULL)

#define ValidateHwnd(hwnd)   (((hwnd) == (HWND)NULL || !bUser32Initialized) \
        ? (PWND)NULL : HMValidateHandle(hwnd, TYPE_WINDOW))

#define ValidateHimc(himc)   (((himc) == (HIMC)NULL || !bUser32Initialized) \
        ? (PIMC)NULL : HMValidateHandle((HANDLE)himc, TYPE_INPUTCONTEXT))

#define RevalidateHimc(himc) (((himc) == (HIMC)NULL || !bUser32Initialized) \
        ? (PIMC)NULL : HMValidateHandleNoRip((HANDLE)himc, TYPE_INPUTCONTEXT))

/***************************************************************************\
*
* Memory management macros
*
\***************************************************************************/

LPVOID  ImmLocalAlloc(DWORD uFlag, DWORD uBytes);
#define ImmLocalReAlloc(p, uBytes, uFlags) HeapReAlloc(pImmHeap, uFlags, (LPSTR)(p), (uBytes))
#define ImmLocalFree(p)    HeapFree(pImmHeap, 0, (LPSTR)(p))
#define ImmLocalSize(p)    HeapSize(pImmHeap, 0, (LPSTR)(p))
#define ImmLocalLock(p)    (LPSTR)(p)
#define ImmLocalUnlock(p)
#define ImmLocalFlags(p)   0
#define ImmLocalHandle(p)  (HLOCAL)(p)

/***************************************************************************\
*
* Other Typedefs and Macros
*
\***************************************************************************/
#define GetInputContextProcess(himc) \
            (DWORD)NtUserQueryInputContext(himc, InputContextProcess)

#define GetInputContextThread(himc) \
            (DWORD)NtUserQueryInputContext(himc, InputContextThread)

#define GetWindowProcess(hwnd) \
            (ULONG_PTR)NtUserQueryWindow(hwnd, WindowProcess)

#define GETPROCESSID() (ULONG_PTR)(NtCurrentTeb()->ClientId.UniqueProcess)

#define DWORD_ALIGN(x) ((x+3)&~3)

#define SetICF(pClientImc, flag)  ((pClientImc)->dwFlags |= flag)

#define ClrICF(pClientImc, flag)  ((pClientImc)->dwFlags &= ~flag)

#define TestICF(pClientImc, flag) ((pClientImc)->dwFlags & flag)

#define IsWndEqual(hWnd1, hWnd2) (LOWORD(HandleToUlong(hWnd1)) == LOWORD(HandleToUlong(hWnd2)) && \
            ValidateHwnd(hWnd1) == ValidateHwnd(hWnd2))

#define HKL_TO_LANGID(hkl)      (LOWORD(HandleToUlong(hkl)))

/*
 * Obsolete, but keep this for backward compat. for a while
 */
#define LANGIDFROMHKL(hkl)      (LOBYTE(LOWORD((ULONG_PTR)hkl)))

#ifdef IMM_CONV_ON_HKL
#define IMECodePage(pImeDpi)        ((pImeDpi)->dwCodePage)
#define CImcCodePage(pClientImc)    ((pClientImc)->dwCodePage)
#else
#define IMECodePage(pImeDpi)        (CP_ACP)
#define CImcCodePage(pClientImc)    (CP_ACP)
#endif

/***************************************************************************\
*
* Function declarations
*
\***************************************************************************/

/*
 * context.c
 */
BOOL CreateInputContext(
    HIMC hImc,
    HKL  hKL,
    BOOL fCanCallImeSelect);

BOOL DestroyInputContext(
    HIMC      hImc,
    HKL       hKL,
    BOOL      bTerminate);

VOID SelectInputContext(
    HKL  hSelKL,
    HKL  hUnSelKL,
    HIMC hImc);

DWORD BuildHimcList(
    DWORD idThread,
    HIMC **pphimcFirst);

HIMC ImmGetSaveContext(
    HWND  hWnd,
    DWORD dwFlag);

/*
 * ctxtinfo.c
 */
BOOL ImmSetCompositionStringWorker(
    HIMC    hImc,
    DWORD   dwIndex,
    LPVOID lpComp,
    DWORD   dwCompLen,
    LPVOID lpRead,
    DWORD   dwReadLen,
    BOOL    fAnsi);

DWORD ImmGetCandidateListCountWorker(
    HIMC    hImc,
    LPDWORD lpdwListCount,
    BOOL    fAnsi);

DWORD ImmGetCandidateListWorker(
    HIMC            hImc,
    DWORD           dwIndex,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen,
    BOOL            fAnsi);

DWORD ImmGetGuideLineWorker(
    HIMC    hImc,
    DWORD   dwIndex,
    LPBYTE  lpBuf,
    DWORD   dwBufLen,
    BOOL    fAnsi);

LONG InternalGetCompositionStringA(
#ifdef CUAS_ENABLE
    HIMC                hImc,
#endif // CUAS_ENABLE
    LPCOMPOSITIONSTRING lpCompStr,
    DWORD               dwIndex,
    LPVOID              lpBuf,
    DWORD               dwBufLen,
    BOOL                fAnsiImc,
    DWORD               dwCodePage);

LONG InternalGetCompositionStringW(
#ifdef CUAS_ENABLE
    HIMC                hImc,
#endif // CUAS_ENABLE
    LPCOMPOSITIONSTRING lpCompStr,
    DWORD               dwIndex,
    LPVOID              lpBuf,
    DWORD               dwBufLen,
    BOOL                fAnsiImc,
    DWORD               dwCodePage);

DWORD InternalGetCandidateListAtoW(
    LPCANDIDATELIST     lpCandListA,
    LPCANDIDATELIST     lpCandListW,
    DWORD               dwBufLen,
    DWORD               dwCodePage);

DWORD InternalGetCandidateListWtoA(
    LPCANDIDATELIST     lpCandListW,
    LPCANDIDATELIST     lpCandListA,
    DWORD               dwBufLen,
    DWORD               dwCodePage);

DWORD CalcCharacterPositionAtoW(
    DWORD dwCharPosA,
    LPSTR lpszCharStr,
    DWORD dwCodePage);

DWORD CalcCharacterPositionWtoA(
    DWORD dwCharPosW,
    LPWSTR lpwszCharStr,
    DWORD  dwCodePage);

VOID LFontAtoLFontW(
    LPLOGFONTA lfFontA,
    LPLOGFONTW lfFontW);

VOID LFontWtoLFontA(
    LPLOGFONTW lfFontW,
    LPLOGFONTA lfFontA);

BOOL MakeIMENotify(
    HIMC   hImc,
    HWND   hWnd,
    DWORD  dwAction,
    DWORD  dwIndex,
    DWORD  dwValue,
    WPARAM wParam,
    LPARAM lParam);

VOID ImmSendNotification(
    BOOL fForProcess);


/*
 * immime.c
 */
BOOL InquireIme(
    PIMEDPI pImeDpi);

BOOL LoadIME(
    PIMEINFOEX piiex,
    PIMEDPI    pImeDpi);

VOID UnloadIME(
    PIMEDPI pImeDpi,
    BOOL    fTerminateIme);

PIMEDPI LoadImeDpi(
    HKL  hKL,
    BOOL fLock);

PIMEDPI FindOrLoadImeDpi(
    HKL hKL);

/*
 * layime.c
 */
VOID GetSystemPathName(PWSTR /*OUT*/ pwszPath, PWSTR pwszFileName, UINT maxChar);

BOOL LoadVersionInfo(
    PIMEINFOEX piiex);

LPWSTR MakeStringFromRegFullInfo(PKEY_VALUE_FULL_INFORMATION pKey, size_t limit);

/*
 * misc.c
 */

PINPUTCONTEXT InternalImmLockIMC(
    HIMC hImc,
    BOOL fCanCallImeSelect);

BOOL ImmIsUIMessageWorker(
    HWND   hIMEWnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL   fAnsi);


PTHREADINFO PtiCurrent(VOID);

BOOL TestInputContextProcess(
    PIMC pImc);

PIMEDPI ImmGetImeDpi(HKL hKL);
DWORD   ImmGetAppCompatFlags(HIMC hImc);

BOOL ImmPtInRect(
    int left,
    int top,
    int width,
    int height,
    LPPOINT lppt);

UINT GetKeyboardLayoutCP(
    HKL hKL);

/*
 * regword.c
 */
UINT CALLBACK EnumRegisterWordProcA(
    LPCSTR            lpszReading,
    DWORD             dwStyle,
    LPCSTR            lpszString,
    PENUMREGWORDDATA  pEnumRegWordData);

UINT CALLBACK EnumRegisterWordProcW(
    LPCWSTR          lpwszReading,
    DWORD            dwStyle,
    LPCWSTR          lpwszString,
    PENUMREGWORDDATA pEnumRegWordData);

/*
 * hotkey.c
 */


VOID ImmPostMessages(
    HWND hwnd,
    HIMC hImc,
    INT  iNum,
    PTRANSMSG pTransMsg);

BOOL HotKeyIDDispatcher( HWND hWnd, HIMC hImc, HKL hKL, DWORD dwHotKeyID );

BOOL OpenRegApi(ADVAPI_FN* pfn);
void CloseRegApi(ADVAPI_FN* pfn);

/*
 * transsub.c
 */
LRESULT TranslateIMESubFunctions(
    HWND hWndApp,
    LPIMESTRUCT lpIme,
    BOOL fAnsi);

LRESULT TransGetLevel( HWND hWndApp );
LRESULT TransSetLevel( HWND hWndApp, LPIMESTRUCT lpIme);

/*
 * kcodecnv.c
 */
LRESULT TransCodeConvert( HIMC hImc, LPIMESTRUCT lpIme);
LRESULT TransConvertList( HIMC hImc, LPIMESTRUCT lpIme);
LRESULT TransGetMNTable( HIMC hImc, LPIMESTRUCT lpIme);

/*
 * ktranmsg.c
 */
UINT WINNLSTranslateMessageK(
    int                 iNumMsg,
    PTRANSMSG           pTransMsg,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    BOOL bAnsiIMC);

/*
 * jtranmsg.c
 */
UINT WINNLSTranslateMessageJ(
    UINT                uiNumMsg,
    PTRANSMSG           pTransMsg,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    BOOL bAnsiIMC );

/*
 * input.c
 */
UINT WINNLSTranslateMessage(
    INT    iNum,         // number of messages in the source buffer
    PTRANSMSG pTransMsg, // source buffer that contains 4.0 style messages
    HIMC   hImc,         // input context handle
    BOOL   fAnsi,        // TRUE if pdwt contains ANSI messages
    DWORD  dwLangId );   // language ID ( KOREAN or JAPANESE )


/*
 * support routine: IsAnsiClientIMC
 */
__inline int IsAnsiIMC(HIMC hIMC)
{
    BOOL bAnsi;

    // get ansi mode of origin IMC
    PCLIENTIMC pClientIMC = ImmLockClientImc(hIMC);
    if (pClientIMC == NULL) {
        return -1;
    }
    bAnsi = !TestICF(pClientIMC, IMCF_UNICODE);
    ImmUnlockClientImc(pClientIMC);
    return bAnsi;
}

#ifdef CUAS_ENABLE
/*
 * com.c
 */
HRESULT CtfImmTIMCreateInputContext(HIMC hImc);
HRESULT CtfImmTIMDestroyInputContext(HIMC hImc);
HRESULT CtfImmLastEnabledWndDestroy(LPARAM lParam);
LRESULT CtfImmSetLangBand(HWND hwndTray, BOOL fLangBand);
HRESULT Internal_CtfImeCreateThreadMgr();
HRESULT Internal_CtfImeDestroyThreadMgr();
BOOL    Internal_CtfImeProcessCicHotkey(HIMC hIMC, UINT uVKey, LPARAM lParam);
HRESULT Internal_CtfImeCreateInputContext(HIMC himc);
HRESULT Internal_CtfImeDestroyInputContext(HIMC himc);
HRESULT Internal_CtfImeSetActiveContextAlways(HIMC himc, BOOL fActive, HWND hwnd, HKL hkl);
BOOL    IsCUASEnabled();
BOOL IsDisabledTextServices();
BOOL IsInteractiveUserLogon();
BOOL IsRunningInMsoobe();

#endif // CUAS_ENABLE


#define TRACE(x)

//
// Resources
//

// CHT software keyboard bitmaps
#define BACK_T1     100
#define TAB_T1      101
#define CAPS_T1     102
#define ENTER_T1    103
#define SHIFT_T1    104
#define CTRL_T1     105
#define ESC_T1      106
#define ALT_T1      107
#define LABEL_T1    108

// CHS software keyboard bitmaps
#define BACKSP_C1   201
#define TAB_C1      202
#define CAPS_C1     203
#define ENTER_C1    204
#define SHIFT_C1    205
#define INS_C1      206
#define DEL_C1      207
#define ESC_C1      208
#define LABEL_C1    209

#endif // _IMMCLI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\immime.c ===
/**************************************************************************\
* Module Name: immime.c (corresponds to Win95 ime.c)
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IME DLL related functinality
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

typedef struct tagSELECTCONTEXT_ENUM {
    HKL hSelKL;
    HKL hUnSelKL;
} SCE, *PSCE;


BOOL NotifyIMEProc(
    HIMC hImc,
    LPARAM lParam)
{
    UserAssert(lParam == CPS_COMPLETE || lParam == CPS_CANCEL);
    ImmNotifyIME(hImc, NI_COMPOSITIONSTR, (DWORD)lParam, 0);
    return TRUE;
}


BOOL SelectContextProc(
    HIMC hImc,
    PSCE psce)
{
    SelectInputContext(psce->hSelKL, psce->hUnSelKL, hImc);
    return TRUE;
}


BOOL InquireIme(
    PIMEDPI pImeDpi)
{
    WNDCLASS    wc;
    BYTE        ClassName[IM_UI_CLASS_SIZE * sizeof(WCHAR)];
    DWORD       dwSystemInfoFlags;
    PIMEINFO    pImeInfo = &pImeDpi->ImeInfo;

    /*
     * Check if this process requires the security.
     * Adding to the pid check, the current desktop check is required,
     * for there are applications run on the secure desktop.
     */
    dwSystemInfoFlags = (NtUserGetThreadState(UserThreadStateNeedsSecurity) ? IME_SYSINFO_WINLOGON : 0);

    if (GetClientInfo()->dwTIFlags & TIF_16BIT)
        dwSystemInfoFlags |= IME_SYSINFO_WOW16;

#if !defined(CUAS_ENABLE)
    (*pImeDpi->pfn.ImeInquire.w)(pImeInfo, (PVOID)ClassName, dwSystemInfoFlags);
#else
    if (! IS_IME_KBDLAYOUT(pImeDpi->hKL) && IS_CICERO_ENABLED_AND_NOT16BIT()) {
        if ((*pImeDpi->pfn.CtfImeInquireExW)(pImeInfo, (PVOID)ClassName, dwSystemInfoFlags, pImeDpi->hKL) == S_OK)
        {
        }
        else
        {
            RIPMSG0(RIP_WARNING, "InquireIme: pImeDpi->pfn.ImeInquireExW failed");
            return FALSE;
        }
    }
    else {
        (*pImeDpi->pfn.ImeInquire.w)(pImeInfo, (PVOID)ClassName, dwSystemInfoFlags);
    }
#endif

    /*
     * parameter checking for each fields.
     */
    if (pImeInfo->dwPrivateDataSize == 0)
        pImeInfo->dwPrivateDataSize = sizeof(UINT);

    if (pImeInfo->fdwProperty & ~(IME_PROP_ALL)) {
        RIPMSG0(RIP_WARNING, "wrong property");
        return FALSE;
    }

    if (pImeInfo->fdwConversionCaps & ~(IME_CMODE_ALL)) {
        RIPMSG0(RIP_WARNING, "wrong conversion capabilities");
        return FALSE;
    }

    if (pImeInfo->fdwSentenceCaps & ~(IME_SMODE_ALL)) {
        RIPMSG0(RIP_WARNING, "wrong sentence capabilities");
        return FALSE;
    }

    if (pImeInfo->fdwUICaps & ~(UI_CAP_ALL)) {
        RIPMSG0(RIP_WARNING, "wrong UI capabilities");
        return FALSE;
    }

    if (pImeInfo->fdwSCSCaps & ~(SCS_CAP_ALL)) {
        RIPMSG0(RIP_WARNING, "wrong set comp string capabilities");
        return FALSE;
    }

    if (pImeInfo->fdwSelectCaps & ~(SELECT_CAP_ALL)) {
        RIPMSG0(RIP_WARNING, "wrong select capabilities");
        return FALSE;
    }

    if (!(pImeInfo->fdwProperty & IME_PROP_UNICODE)) {

        /*
         * This is ANSI IME. Ensure that it is usable under current system
         * codepage.
         */
        if (pImeDpi->dwCodePage != GetACP() && pImeDpi->dwCodePage != CP_ACP) {
            // Note: in the future, if possible, these reference to dwCodepage
            // should be IMECodePage()...
            RIPMSG1(RIP_WARNING, "incompatible codepage(%d) for ANSI IME", pImeDpi->dwCodePage);
            return FALSE;
        }

        /*
         * ANSI -> Unicode Class name.
         */
        MultiByteToWideChar(IMECodePage(pImeDpi),
                            (DWORD)MB_PRECOMPOSED,
                            (LPSTR)ClassName,               // src
                            (INT)-1,
                            pImeDpi->wszUIClass,            // dest
                            IM_UI_CLASS_SIZE);
    } else {
        RtlCopyMemory(pImeDpi->wszUIClass, ClassName, sizeof(ClassName));
    }
    pImeDpi->wszUIClass[IM_UI_CLASS_SIZE-1] = L'\0';

    if (!GetClassInfoW((HINSTANCE)pImeDpi->hInst, pImeDpi->wszUIClass, &wc)) {
        RIPMSG1(RIP_WARNING, "UI class (%ws) not found in this IME", pImeDpi->wszUIClass);
        return FALSE;
    } else if (wc.cbWndExtra < sizeof(DWORD) * 2) {
        RIPMSG0(RIP_WARNING, "UI class cbWndExtra problem");
        return FALSE;
    }

    return TRUE;
}

BOOL CheckAndApplyAppCompat(LPWSTR wszImeFile)
{
    DWORD dwReason;
    HMODULE hAppHelp;
    typedef BOOL (*PFNApphelpCheckIME)(
        IN  LPCWSTR     pwszPath            // Unicode path to the executable (DOS_PATH)
        );
    PFNApphelpCheckIME pfnAppHelpCheckIME;
    BOOL    bRunIME = TRUE;
    //
    // tentative prototype (find out a semi-public header to include! [and a lib too])
    //
    BOOL
    WINAPI
    BaseCheckAppcompatCache(
        LPCWSTR pwszPath,
        HANDLE  hFile,
        PVOID   pEnvironment,
        DWORD*  dwReason
        );

    //
    // Assuming most of IMEs are just fine, not needing
    // Shim's help, let's check the good guy cache first
    // so that the overhead should be minimum. This API
    // is meant to be really light weight.
    //
    if (BaseCheckAppcompatCache(wszImeFile, INVALID_HANDLE_VALUE, NULL, &dwReason)) {
        // This IME is in the good guy cache. Just bail out quietly.
        return bRunIME;
    }

    // What's a good use of dwReason?

    RIPMSG1(RIP_VERBOSE, "Shim'ing this IME='%ls'", wszImeFile);

    //
    // Call the real Shim helper for this IME.
    //
    hAppHelp = GetModuleHandleW(L"apphelp.dll");
    if (hAppHelp == NULL) {
        hAppHelp = LoadLibraryW(L"apphelp.dll");
        if (hAppHelp == NULL) {
            // Failed to load apphelp.dll.
            // We have no other choice than bailing out.
            RIPMSG0(RIP_WARNING, "CheckAndApplyAppCompat: failed to load apphelp.dll");
            return bRunIME;
        }
    }
    UserAssert(hAppHelp);

    pfnAppHelpCheckIME = (PFNApphelpCheckIME)GetProcAddress(hAppHelp, "ApphelpCheckIME");
    if (pfnAppHelpCheckIME == NULL) {
        RIPMSG0(RIP_WARNING, "CheckAndApplyAppCompat: failed to getproc ApphelpCheckIME");
        return bRunIME;
    }

    //
    // return result has no meaning for this ca
    //
    bRunIME =  pfnAppHelpCheckIME(wszImeFile);

    return bRunIME;
}

BOOL LoadIME(
    PIMEINFOEX piiex,
    PIMEDPI    pImeDpi)
{
    WCHAR wszImeFile[MAX_PATH];
    BOOL  fSuccess;

    GetSystemPathName(wszImeFile, piiex->wszImeFile, MAX_PATH);

    if (!CheckAndApplyAppCompat(wszImeFile)) {
        RIPMSG1(RIP_WARNING, "LoadIME: IME (%ws) blocked by appcompat", wszImeFile);
        goto LoadIME_ErrOut;
    }

    pImeDpi->hInst = LoadLibraryW(wszImeFile);

    if (!pImeDpi->hInst) {
        RIPMSG1(RIP_WARNING, "LoadIME: LoadLibraryW(%ws) failed", wszImeFile);
        goto LoadIME_ErrOut;
    }

#define GET_IMEPROCT(x) \
    if (!(pImeDpi->pfn.##x.t = (PVOID) GetProcAddress(pImeDpi->hInst, #x))) { \
        RIPMSG1(RIP_WARNING, "LoadIME: " #x " not supported in %ws", wszImeFile);           \
        goto LoadIME_ErrOut; }

#define GET_IMEPROC(x) \
    if (!(pImeDpi->pfn.##x = (PVOID) GetProcAddress(pImeDpi->hInst, #x))) {   \
        RIPMSG1(RIP_WARNING, "LoadIME: " #x " not supported in %ws", wszImeFile);           \
        goto LoadIME_ErrOut; }

    GET_IMEPROCT(ImeInquire);
    GET_IMEPROCT(ImeConversionList);
    GET_IMEPROCT(ImeRegisterWord);
    GET_IMEPROCT(ImeUnregisterWord);
    GET_IMEPROCT(ImeGetRegisterWordStyle);
    GET_IMEPROCT(ImeEnumRegisterWord);
    GET_IMEPROC (ImeConfigure);
    GET_IMEPROC (ImeDestroy);
    GET_IMEPROC (ImeEscape);
    GET_IMEPROC (ImeProcessKey);
    GET_IMEPROC (ImeSelect);
    GET_IMEPROC (ImeSetActiveContext);
    GET_IMEPROC (ImeToAsciiEx);
    GET_IMEPROC (NotifyIME);
    GET_IMEPROC (ImeSetCompositionString);

    // 4.0 IMEs don't have this entry. could be NULL.
    pImeDpi->pfn.ImeGetImeMenuItems = (PVOID)GetProcAddress(pImeDpi->hInst, "ImeGetImeMenuItems");

#ifdef CUAS_ENABLE
    //
    // Cicero IME
    //
    if (! IS_IME_KBDLAYOUT(pImeDpi->hKL) && IS_CICERO_ENABLED_AND_NOT16BIT()) {
        GET_IMEPROC (CtfImeInquireExW);
        GET_IMEPROC (CtfImeSelectEx);
        GET_IMEPROC (CtfImeEscapeEx);
        GET_IMEPROC (CtfImeGetGuidAtom);
        GET_IMEPROC (CtfImeIsGuidMapEnable);
    }
#endif // CUAS_ENABLE

#undef GET_IMEPROCT
#undef GET_IMEPROC

    if (!InquireIme(pImeDpi)) {
        RIPMSG0(RIP_WARNING, "LoadIME: InquireIme failed");
LoadIME_ErrOut:
        FreeLibrary(pImeDpi->hInst);
        pImeDpi->hInst = NULL;
        fSuccess = FALSE;
    }
    else {
        fSuccess = TRUE;
    }

    /*
     * Update kernel side IMEINFOEX for this keyboard layout if
     * this is its first loading.
     */
    if (piiex->fLoadFlag == IMEF_NONLOAD) {
        if (fSuccess) {
            RtlCopyMemory((PBYTE)&piiex->ImeInfo,
                          (PBYTE)&pImeDpi->ImeInfo, sizeof(IMEINFO));
            RtlCopyMemory((PBYTE)piiex->wszUIClass,
                          (PBYTE)pImeDpi->wszUIClass, sizeof(pImeDpi->wszUIClass));
            piiex->fLoadFlag = IMEF_LOADED;
        }
        else {
            piiex->fLoadFlag = IMEF_LOADERROR;
            RIPMSG1(RIP_WARNING, "LoadIME: hKL=%lx piiex->fLoadFlag = IMEF_LOADERROR", piiex->hkl);
        }
        NtUserSetImeInfoEx(piiex);
    }

    return fSuccess;
}


VOID UnloadIME(
    PIMEDPI pImeDpi,
    BOOL    fTerminateIme)
{
    if (pImeDpi->hInst == NULL) {
        RIPMSG0(RIP_WARNING, "UnloadIME: No IME's hInst.");
        return;
    }

    if (fTerminateIme) {
        /*
         * Destroy IME first.
         */
        (*pImeDpi->pfn.ImeDestroy)(0);
    }

    FreeLibrary(pImeDpi->hInst);
    pImeDpi->hInst = NULL;

    return;
}

PIMEDPI LoadImeDpi(
    HKL  hKL,
    BOOL fLock)
{
    PIMEDPI        pImeDpi, pImeDpiT;
    IMEINFOEX      iiex;

    /*
     * Query the IME information.
     */
    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL)) {
        RIPMSG1(RIP_WARNING, "LoadImeDpi: ImmGetImeInfoEx(%lx) failed", hKL);
        return NULL;
    }

    /*
     * Win95 behaviour: If there was an IME load error for this layout,
     * further attempt to load the same IME layout will be rejected.
     */
    if (iiex.fLoadFlag == IMEF_LOADERROR)
    {
        RIPMSG1(RIP_WARNING, "LoadImeDpi: hKL=%lx iiex.fLoadFlag = IMEF_LOADERROR", iiex.hkl);
        return NULL;
    }

    /*
     * Allocate a new IMEDPI for this layout.
     */
    pImeDpi = (PIMEDPI)ImmLocalAlloc(HEAP_ZERO_MEMORY, sizeof(IMEDPI));
    if (pImeDpi == NULL)
        return NULL;

    pImeDpi->hKL = hKL;

    // get code page of IME
    {
        CHARSETINFO cs;
        if (TranslateCharsetInfo((DWORD*)LOWORD(HandleToUlong(hKL)), &cs, TCI_SRCLOCALE)) {
            pImeDpi->dwCodePage = cs.ciACP;
        }
        else {
            pImeDpi->dwCodePage = CP_ACP;
        }
    }

    /*
     * Load up IME DLL.
     */
    if (!LoadIME(&iiex, pImeDpi)) {
        ImmLocalFree(pImeDpi);
        return NULL;
    }

    /*
     * Link in the newly allocated entry.
     */
    RtlEnterCriticalSection(&gcsImeDpi);

    pImeDpiT = ImmGetImeDpi(hKL);

    if (pImeDpiT == NULL) {
        if (fLock) {
            /*
             * Newly loaded with lock, will unload upon unlock.
             */
            pImeDpi->cLock = 1;
            pImeDpi->dwFlag |= IMEDPI_UNLOCKUNLOAD;
        }

        /*
         * Update the global list for this new pImeDpi entry.
         */
        pImeDpi->pNext = gpImeDpi;
        gpImeDpi = pImeDpi;

        RtlLeaveCriticalSection(&gcsImeDpi);
    }
    else {

        if (!fLock) {
            pImeDpiT->dwFlag &= ~IMEDPI_UNLOCKUNLOAD;
        }

        /*
         * The same IME has been loaded, discard this extra entry.
         */
        RtlLeaveCriticalSection(&gcsImeDpi);
        UnloadIME(pImeDpi, FALSE);
        ImmLocalFree(pImeDpi);
        pImeDpi = pImeDpiT;
    }

    return pImeDpi;
}


PIMEDPI FindOrLoadImeDpi(
    HKL  hKL)
{
    PIMEDPI pImeDpi;

    /*
     * Non IME based keyboard layout doesn't have IMEDPI.
     */
#if !defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
        return (PIMEDPI)NULL;
#else
    if (! IS_IME_KBDLAYOUT(hKL) && ! IS_CICERO_ENABLED_AND_NOT16BIT())
        return (PIMEDPI)NULL;
#endif

    pImeDpi = ImmLockImeDpi(hKL);
    if (pImeDpi == NULL)
        pImeDpi = LoadImeDpi(hKL, TRUE);

    return pImeDpi;
}


BOOL WINAPI ImmLoadIME(
    HKL hKL)
{
    PIMEDPI pImeDpi;

    /*
     * Non IME based keyboard layout doesn't have IMEDPI.
     */
#if !defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
        return FALSE;
#else
    if (! IS_IME_KBDLAYOUT(hKL) && ! IS_CICERO_ENABLED_AND_NOT16BIT())
        return FALSE;
#endif

    pImeDpi = ImmGetImeDpi(hKL);
    if (pImeDpi == NULL)
        pImeDpi = LoadImeDpi(hKL, FALSE);

    return (pImeDpi != NULL);
}


BOOL WINAPI ImmUnloadIME(
    HKL hKL)
{
    PIMEDPI pImeDpi, pImeDpiT;

    RtlEnterCriticalSection(&gcsImeDpi);

    pImeDpi = gpImeDpi;

    while (pImeDpi != NULL && pImeDpi->hKL != hKL)
        pImeDpi = pImeDpi->pNext;

    if (pImeDpi == NULL) {
        RtlLeaveCriticalSection(&gcsImeDpi);
        return TRUE;
    }
    else if (pImeDpi->cLock != 0) {
        pImeDpi->dwFlag |= IMEDPI_UNLOADED;
        RtlLeaveCriticalSection(&gcsImeDpi);
        return FALSE;
    }

    /*
     * Unlink it.
     */
    if (gpImeDpi == pImeDpi) {
        gpImeDpi = pImeDpi->pNext;
    }
    else {
        pImeDpiT = gpImeDpi;

        while (pImeDpiT != NULL && pImeDpiT->pNext != pImeDpi)
            pImeDpiT = pImeDpiT->pNext;

        if (pImeDpiT != NULL)
            pImeDpiT->pNext = pImeDpi->pNext;
    }

    /*
     * Unload the IME DLL.
     */
    UnloadIME(pImeDpi, TRUE);

    ImmLocalFree(pImeDpi);

    RtlLeaveCriticalSection(&gcsImeDpi);

    return TRUE;
}


BOOL WINAPI ImmFreeLayout(
    DWORD  dwFlag)
{
    PIMEDPI pImeDpi;
    HKL   *phklRoot, hklCurrent;
    WCHAR  pwszNonImeKLID[KL_NAMELENGTH];
    UINT   nLayouts, uNonImeKLID = 0, i;

    hklCurrent = GetKeyboardLayout(0);

    switch (dwFlag) {

    case IFL_DEACTIVATEIME:
        /*
         * Do nothing if no IME to be deactivated.
         */
        if (!IS_IME_KBDLAYOUT(hklCurrent))
            return TRUE;

        /*
         * Deactivate IME based layout by activating a non-IME based
         * keyboard layout.
         */
        uNonImeKLID = (UINT)LANGIDFROMLCID(GetSystemDefaultLCID());

        nLayouts = GetKeyboardLayoutList(0, NULL);

        if (nLayouts != 0) {
            phklRoot = ImmLocalAlloc(0, nLayouts * sizeof(HKL));
            if (phklRoot == NULL)
                return FALSE;

            nLayouts = GetKeyboardLayoutList(nLayouts, phklRoot);

            for (i = 0; i < nLayouts && IS_IME_KBDLAYOUT(phklRoot[i]); i++) ;

            if (i < nLayouts)
                uNonImeKLID = HandleToUlong(phklRoot[i]) & 0xffff;

            ImmLocalFree(phklRoot);
        }

        wsprintf(pwszNonImeKLID, L"%08x", uNonImeKLID);

        if (LoadKeyboardLayoutW(pwszNonImeKLID, KLF_ACTIVATE) == NULL) {
            RIPMSG1(RIP_WARNING, "ImmFreeLayout: LoadKeyboardLayoutW(%S, KLF_ACTIVATE) failed. Trying 00000409", pwszNonImeKLID);
            // Somehow it failed (probably a bad setup), let's try
            // 409 KL, which should be installed on all localized NTs.
            if (LoadKeyboardLayoutW(L"00000409", KLF_ACTIVATE | KLF_FAILSAFE) == NULL) {
                RIPMSG0(RIP_WARNING, "LoadKeyboardLayoutW(00000409) failed either. will try NULL.");
            }
        }

        break;

    case IFL_UNLOADIME:
        RtlEnterCriticalSection(&gcsImeDpi);
UnloadImeDpiLoop:
        for (pImeDpi = gpImeDpi; pImeDpi != NULL; pImeDpi = pImeDpi->pNext) {
            if (ImmUnloadIME(pImeDpi->hKL))
                goto UnloadImeDpiLoop;        // Rescan as list was updated.
        }
        RtlLeaveCriticalSection(&gcsImeDpi);
        break;

    default:
        {
            HKL hklFlag = (HKL)LongToHandle( dwFlag );
            if (IS_IME_KBDLAYOUT(hklFlag) && hklFlag != hklCurrent) {
                ImmUnloadIME(hklFlag);
            }
        }
        break;
    }

    return TRUE;
}


BOOL WINAPI ImmActivateLayout(
    HKL    hSelKL)
{
    HKL     hUnSelKL;
    HWND    hWndDefaultIme;
    SCE     sce;
    DWORD   dwCPS;
    PIMEDPI pImeDpi;
    BOOLEAN fOptimizeActivation = TRUE;

    hUnSelKL = GetKeyboardLayout(0);

    {
        PCLIENTINFO pClientInfo = GetClientInfo();

        if (pClientInfo->CI_flags & CI_INPUTCONTEXT_REINIT) {
            fOptimizeActivation = FALSE;
        }
    }

    /*
     * if already current active, do nothing
     */
    if (hUnSelKL == hSelKL && fOptimizeActivation)
        return TRUE;

    ImmLoadIME(hSelKL);

    if (hUnSelKL != hSelKL) {
        pImeDpi = ImmLockImeDpi(hUnSelKL);
        if (pImeDpi != NULL) {
            /*
             * Send out CPS_CANCEL or CPS_COMPLETE to every input
             * context assoicated to window(s) created by this thread.
             * Starting from SUR, we only assoicate input context to window created
             * by the same thread.
             */
            dwCPS = (pImeDpi->ImeInfo.fdwProperty & IME_PROP_COMPLETE_ON_UNSELECT) ? CPS_COMPLETE : CPS_CANCEL;
            ImmUnlockImeDpi(pImeDpi);
            ImmEnumInputContext(0, NotifyIMEProc, dwCPS);
        }

        hWndDefaultIme = ImmGetDefaultIMEWnd(NULL);

        if (IsWindow(hWndDefaultIme))
            SendMessage(hWndDefaultIme, WM_IME_SELECT, FALSE, (LPARAM)hUnSelKL);

        /*
         * This is the time to update the kernel side layout handles.
         * We must do this before sending WM_IME_SELECT.
         */
        NtUserSetThreadLayoutHandles(hSelKL, hUnSelKL);
    }

    /*
     * Unselect and select input context(s).
     */
    sce.hSelKL   = hSelKL;
    sce.hUnSelKL = hUnSelKL;
    ImmEnumInputContext(0, (IMCENUMPROC)SelectContextProc, (LPARAM)&sce);

    /*
     * inform UI select after all hIMC select
     */
    if (IsWindow(hWndDefaultIme))
        SendMessage(hWndDefaultIme, WM_IME_SELECT, TRUE, (LPARAM)hSelKL);

    return (TRUE);
}


/***************************************************************************\
* ImmConfigureIMEA
*
* Brings up the configuration dialogbox of the IME with the specified hKL.
*
* History:
* 29-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmConfigureIMEA(
    HKL    hKL,
    HWND   hWnd,
    DWORD  dwMode,
    LPVOID lpData)
{
    PWND    pWnd;
    PIMEDPI pImeDpi;
    BOOL    fRet = FALSE;

    if ((pWnd = ValidateHwnd(hWnd)) == (PWND)NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmConfigureIMEA: invalid window handle %x", hWnd);
        return FALSE;
    }

    if (!TestWindowProcess(pWnd)) {
        RIPMSG1(RIP_WARNING,
              "ImmConfigureIMEA: hWnd=%lx belongs to different process!", hWnd);
        return FALSE;
    }

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmConfigureIMEA: no pImeDpi entry.");
        return FALSE;
    }

    if (!(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) || lpData == NULL) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * bring up the configuration dialogbox.
         */
            // This message handles by Console IME.
            SendMessage(hWnd, WM_IME_SYSTEM, IMS_OPENPROPERTYWINDOW, 0L);
        fRet = (*pImeDpi->pfn.ImeConfigure)(hKL, hWnd, dwMode, lpData);
            // This message handles by Console IME.
            SendMessage(hWnd, WM_IME_SYSTEM, IMS_CLOSEPROPERTYWINDOW, 0L);
        ImmUnlockImeDpi(pImeDpi);
        return fRet;
    }

    /*
     * ANSI caller, Unicode IME. Needs A/W conversion on lpData when
     * dwMode == IME_CONFIG_REGISTERWORD. In this case, lpData points
     * to a structure of REGISTERWORDA.
     */
    switch (dwMode) {
    case IME_CONFIG_REGISTERWORD:
        {
            LPREGISTERWORDA lpRegisterWordA;
            REGISTERWORDW   RegisterWordW;
            LPVOID          lpBuffer;
            ULONG           cbBuffer;
            INT             i;

            lpRegisterWordA = (LPREGISTERWORDA)lpData;
            cbBuffer = 0;
            lpBuffer = NULL;

            if (lpRegisterWordA->lpReading != NULL)
                cbBuffer += strlen(lpRegisterWordA->lpReading) + 1;

            if (lpRegisterWordA->lpWord != NULL)
                cbBuffer += strlen(lpRegisterWordA->lpWord) + 1;

            if (cbBuffer != 0) {
                cbBuffer *= sizeof(WCHAR);
                if ((lpBuffer = ImmLocalAlloc(0, cbBuffer)) == NULL) {
                    RIPMSG0(RIP_WARNING, "ImmConfigureIMEA: memory failure.");
                    break;
                }
            }

            if (lpRegisterWordA->lpReading != NULL) {
                RegisterWordW.lpReading = lpBuffer;
                i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                        (DWORD)MB_PRECOMPOSED,
                                        (LPSTR)lpRegisterWordA->lpReading,
                                        (INT)strlen(lpRegisterWordA->lpReading),
                                        (LPWSTR)RegisterWordW.lpReading,
                                        (INT)(cbBuffer/sizeof(WCHAR)));
                RegisterWordW.lpReading[i] = L'\0';
                cbBuffer -= (i * sizeof(WCHAR));
            }
            else {
                RegisterWordW.lpReading = NULL;
            }

            if (lpRegisterWordA->lpWord != NULL) {
                if (RegisterWordW.lpReading != NULL)
                    RegisterWordW.lpWord = &RegisterWordW.lpReading[i+1];
                else
                    RegisterWordW.lpWord = lpBuffer;
                i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                        (DWORD)MB_PRECOMPOSED,
                                        (LPSTR)lpRegisterWordA->lpWord,
                                        (INT)strlen(lpRegisterWordA->lpWord),
                                        (LPWSTR)RegisterWordW.lpWord,
                                        (INT)(cbBuffer/sizeof(WCHAR)));
                RegisterWordW.lpWord[i] = L'\0';
            }
            else
                RegisterWordW.lpWord = NULL;

            fRet = ImmConfigureIMEW(hKL, hWnd, dwMode, &RegisterWordW);

            if (lpBuffer != NULL)
                ImmLocalFree(lpBuffer);

            break;
        }
    default:
        fRet = ImmConfigureIMEW(hKL, hWnd, dwMode, lpData);
        break;
    }

    ImmUnlockImeDpi(pImeDpi);

    return fRet;
}


/***************************************************************************\
* ImmConfigureIMEW
*
* Brings up the configuration dialogbox of the IME with the specified hKL.
*
* History:
* 29-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmConfigureIMEW(
    HKL    hKL,
    HWND   hWnd,
    DWORD  dwMode,
    LPVOID lpData)
{
    PWND    pWnd;
    PIMEDPI pImeDpi;
    BOOL    fRet = FALSE;

    if ((pWnd = ValidateHwnd(hWnd)) == (PWND)NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmConfigureIMEA: invalid window handle %x", hWnd);
        return FALSE;
    }

    if (!TestWindowProcess(pWnd)) {
        RIPMSG1(RIP_WARNING,
              "ImmConfigureIMEA: hWnd=%lx belongs to different process!", hWnd);
        return FALSE;
    }

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmConfigureIMEA: no pImeDpi entry.");
        return FALSE;
    }

    if ((pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) || lpData == NULL) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * bring up the configuration dialogbox.
         */
            // This message handles by Console IME.
            SendMessage(hWnd, WM_IME_SYSTEM, IMS_OPENPROPERTYWINDOW, 0L);
        fRet = (*pImeDpi->pfn.ImeConfigure)(hKL, hWnd, dwMode, lpData);
            // This message handles by Console IME.
            SendMessage(hWnd, WM_IME_SYSTEM, IMS_CLOSEPROPERTYWINDOW, 0L);
        ImmUnlockImeDpi(pImeDpi);
        return fRet;
    }

    /*
     * Unicode caller, ANSI IME. Needs A/W conversion on lpData when
     * dwMode == IME_CONFIG_REGISTERWORD. In this case, lpData points
     * to a structure of REGISTERWORDW.
     */
    switch (dwMode) {
    case IME_CONFIG_REGISTERWORD:
        {
            LPREGISTERWORDW lpRegisterWordW;
            REGISTERWORDA   RegisterWordA;
            LPVOID          lpBuffer;
            ULONG           cbBuffer;
            BOOL            bUDC;
            INT             i;

            lpRegisterWordW = (LPREGISTERWORDW)lpData;
            cbBuffer = 0;
            lpBuffer = NULL;

            if (lpRegisterWordW->lpReading != NULL)
                cbBuffer += wcslen(lpRegisterWordW->lpReading) + 1;

            if (lpRegisterWordW->lpWord != NULL)
                cbBuffer += wcslen(lpRegisterWordW->lpWord) + 1;

            if (cbBuffer != 0) {
                cbBuffer *= sizeof(WCHAR);
                if ((lpBuffer = ImmLocalAlloc(0, cbBuffer)) == NULL) {
                    RIPMSG0(RIP_WARNING, "ImmConfigureIMEW: memory failure.");
                    break;
                }
            }

            if (lpRegisterWordW->lpReading != NULL) {
                RegisterWordA.lpReading = lpBuffer;
                i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                        (DWORD)0,
                                        (LPWSTR)lpRegisterWordW->lpReading,
                                        (INT)wcslen(lpRegisterWordW->lpReading),
                                        (LPSTR)RegisterWordA.lpReading,
                                        (INT)cbBuffer,
                                        (LPSTR)NULL,
                                        (LPBOOL)&bUDC);
                RegisterWordA.lpReading[i] = '\0';
                cbBuffer -= (i * sizeof(CHAR));
            }
            else {
                RegisterWordA.lpReading = NULL;
            }

            if (lpRegisterWordW->lpWord != NULL) {
                if (RegisterWordA.lpReading != NULL)
                    RegisterWordA.lpWord = &RegisterWordA.lpReading[i+1];
                else
                    RegisterWordA.lpWord = lpBuffer;
                i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                        (DWORD)0,
                                        (LPWSTR)lpRegisterWordW->lpWord,
                                        (INT)wcslen(lpRegisterWordW->lpWord),
                                        (LPSTR)RegisterWordA.lpWord,
                                        (INT)cbBuffer,
                                        (LPSTR)NULL,
                                        (LPBOOL)&bUDC);
                RegisterWordA.lpWord[i] = '\0';
            }
            else
                RegisterWordA.lpWord = NULL;

            fRet = ImmConfigureIMEA(hKL, hWnd, dwMode, &RegisterWordA);

            if (lpBuffer != NULL)
                ImmLocalFree(lpBuffer);

            break;
        }
    default:
        fRet = ImmConfigureIMEA(hKL, hWnd, dwMode, lpData);
        break;
    }

    ImmUnlockImeDpi(pImeDpi);

    return fRet;
}


#define IME_T_EUDC_DIC_SIZE 80  // the Traditional Chinese EUDC dictionary

/***************************************************************************\
* ImmEscapeA
*
* This API allows an application to access capabilities of a particular
* IME with specified hKL not directly available thru. other IMM APIs.
* This is necessary mainly for country specific functions or private
* functions in IME.
*
* History:
* 29-Feb-1995   wkwok   Created
\***************************************************************************/

LRESULT WINAPI ImmEscapeA(
    HKL    hKL,
    HIMC   hImc,
    UINT   uSubFunc,
    LPVOID lpData)
{
    PIMEDPI pImeDpi;
    LRESULT lRet = 0;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmEscapeA: no pImeDpi entry.");
        return lRet;
    }

    if ((pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) == 0 || lpData == NULL) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * bring up the configuration dialogbox.
         */
#if !defined(CUAS_ENABLE)
        lRet = (*pImeDpi->pfn.ImeEscape)(hImc, uSubFunc, lpData);
#else
        if (IS_IME_KBDLAYOUT(hKL)) {
            lRet = (*pImeDpi->pfn.ImeEscape)(hImc, uSubFunc, lpData);
        }
        else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
            lRet = (*pImeDpi->pfn.CtfImeEscapeEx)(hImc, uSubFunc, lpData, hKL);
        }
#endif
        ImmUnlockImeDpi(pImeDpi);
        return lRet;
    }

    /*
     * ANSI caller, Unicode IME. Needs A/W conversion depending on
     * uSubFunc.
     */
    switch (uSubFunc) {
    case IME_ESC_GET_EUDC_DICTIONARY:
    case IME_ESC_IME_NAME:
    case IME_ESC_GETHELPFILENAME:
        {
            WCHAR wszData[IME_T_EUDC_DIC_SIZE];
            BOOL  bUDC;
            INT   i;

            lRet = ImmEscapeW(hKL, hImc, uSubFunc, (LPVOID)wszData);

            if (lRet != 0) {

                try {
                    i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                            (DWORD)0,
                                            (LPWSTR)wszData,         // src
                                            (INT)wcslen(wszData),
                                            (LPSTR)lpData,           // dest
                                            (INT)IME_T_EUDC_DIC_SIZE,
                                            (LPSTR)NULL,
                                            (LPBOOL)&bUDC);
                    ((LPSTR)lpData)[i] = '\0';
                }
                except (EXCEPTION_EXECUTE_HANDLER) {
                    lRet = 0;
                }
            }

            break;
        }

    case IME_ESC_SET_EUDC_DICTIONARY:
    case IME_ESC_HANJA_MODE:
        {
            WCHAR wszData[IME_T_EUDC_DIC_SIZE];
            INT   i;

            i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                    (DWORD)MB_PRECOMPOSED,
                                    (LPSTR)lpData,             // src
                                    (INT)strlen(lpData),
                                    (LPWSTR)wszData,          // dest
                                    (INT)sizeof(wszData)/sizeof(WCHAR));
            wszData[i] = L'\0';

            lRet = ImmEscapeW(hKL, hImc, uSubFunc, (LPVOID)wszData);

            break;
        }

    case IME_ESC_SEQUENCE_TO_INTERNAL:
        {
            CHAR    szData[4];
            WCHAR   wszData[4];
            INT     i = 0;

            lRet = ImmEscapeW(hKL, hImc, uSubFunc, lpData);

            if (HIWORD(lRet))
                wszData[i++] = HIWORD(lRet);

            if (LOWORD(lRet))
                wszData[i++] = LOWORD(lRet);

            i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                    (DWORD)0,
                                    (LPWSTR)wszData,        // src
                                    (INT)i,
                                    (LPSTR)szData,          // dest
                                    (INT)sizeof(szData),
                                    (LPSTR)NULL,
                                    (LPBOOL)NULL);

            switch (i) {
            case 1:
                lRet = MAKELONG(MAKEWORD(szData[0], 0), 0);
                break;

            case 2:
                lRet = MAKELONG(MAKEWORD(szData[1], szData[0]), 0);
                break;

            case 3:
                lRet = MAKELONG(MAKEWORD(szData[2], szData[1]), MAKEWORD(szData[0], 0));
                break;

            case 4:
                lRet = MAKELONG(MAKEWORD(szData[3], szData[2]), MAKEWORD(szData[1], szData[0]));
                break;

            default:
                lRet = 0;
                break;
            }

            break;
        }
    default:
        lRet = ImmEscapeW(hKL, hImc, uSubFunc, lpData);
        break;
    }

    ImmUnlockImeDpi(pImeDpi);

    return lRet;
}


/***************************************************************************\
* ImmEscapeW
*
* This API allows an application to access capabilities of a particular
* IME with specified hKL not directly available thru. other IMM APIs.
* This is necessary mainly for country specific functions or private
* functions in IME.
*
* History:
* 29-Feb-1995   wkwok   Created
\***************************************************************************/

LRESULT WINAPI ImmEscapeW(
    HKL    hKL,
    HIMC   hImc,
    UINT   uSubFunc,
    LPVOID lpData)
{
    PIMEDPI pImeDpi;
    LRESULT lRet = 0;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmEscapeW: no pImeDpi entry.");
        return lRet;
    }

    if ((pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) || lpData == NULL) {
        /*
         * Doesn't need W/A conversion. Calls directly to IME to
         * bring up the configuration dialogbox.
         */
#if !defined(CUAS_ENABLE)
        lRet = (*pImeDpi->pfn.ImeEscape)(hImc, uSubFunc, lpData);
#else
        if (IS_IME_KBDLAYOUT(hKL)) {
            lRet = (*pImeDpi->pfn.ImeEscape)(hImc, uSubFunc, lpData);
        }
        else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
            lRet = (*pImeDpi->pfn.CtfImeEscapeEx)(hImc, uSubFunc, lpData, hKL);
        }
#endif
        ImmUnlockImeDpi(pImeDpi);
        return lRet;
    }

    /*
     * Unicode caller, ANSI IME. Needs W/A conversion depending on
     * uSubFunc.
     */
    switch (uSubFunc) {
    case IME_ESC_GET_EUDC_DICTIONARY:
    case IME_ESC_IME_NAME:
    case IME_ESC_GETHELPFILENAME:
        {
            CHAR szData[IME_T_EUDC_DIC_SIZE];
            INT  i;

            lRet = ImmEscapeA(hKL, hImc, uSubFunc, (LPVOID)szData);

            if (lRet != 0) {

                try {
                    i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                            (DWORD)MB_PRECOMPOSED,
                                            (LPSTR)szData,          // src
                                            (INT)strlen(szData),
                                            (LPWSTR)lpData,         // dest
                                            (INT)IME_T_EUDC_DIC_SIZE);
                    ((LPWSTR)lpData)[i] = L'\0';
                }
                except (EXCEPTION_EXECUTE_HANDLER) {
                    lRet = 0;
                }
            }

            break;
        }

    case IME_ESC_SET_EUDC_DICTIONARY:
    case IME_ESC_HANJA_MODE:
        {
            CHAR szData[IME_T_EUDC_DIC_SIZE];
            BOOL bUDC;
            INT  i;

            i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                    (DWORD)0,
                                    (LPWSTR)lpData,          // src
                                    (INT)wcslen(lpData),
                                    (LPSTR)szData,          // dest
                                    (INT)sizeof(szData),
                                    (LPSTR)NULL,
                                    (LPBOOL)&bUDC);
            szData[i] = '\0';

            lRet = ImmEscapeA(hKL, hImc, uSubFunc, (LPVOID)szData);

            break;
        }

    case IME_ESC_SEQUENCE_TO_INTERNAL:
        {
            CHAR    szData[4];
            WCHAR   wszData[4];
            INT     i = 0;

            lRet = ImmEscapeA(hKL, hImc, uSubFunc, lpData);

            if (HIBYTE(LOWORD(lRet)))
                szData[i++] = HIBYTE(LOWORD(lRet));

            if (LOBYTE(LOWORD(lRet)))
                szData[i++] = LOBYTE(LOWORD(lRet));

            i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                    (DWORD)MB_PRECOMPOSED,
                                    (LPSTR)szData,            // src
                                    i,
                                    (LPWSTR)wszData,          // dest
                                    (INT)sizeof(wszData)/sizeof(WCHAR));

            switch (i) {
            case 1:
                lRet = MAKELONG(wszData[0], 0);
                break;

            case 2:
                lRet = MAKELONG(wszData[1], wszData[0]);
                break;

            default:
                lRet = 0;
                break;
            }

            break;
        }

    default:
        lRet = ImmEscapeA(hKL, hImc, uSubFunc, lpData);
        break;
    }

    ImmUnlockImeDpi(pImeDpi);

    return lRet;
}

BOOL WINAPI ImmNotifyIME(
    HIMC  hImc,
    DWORD dwAction,
    DWORD dwIndex,
    DWORD dwValue)
{
    PIMEDPI pImeDpi;
    BOOL    bRet;

    if (hImc != NULL_HIMC &&
            GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmNotifyIME: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pImeDpi = ImmLockImeDpi(GetKeyboardLayout(0));
    if (pImeDpi == NULL)
        return FALSE;

    bRet = (*pImeDpi->pfn.NotifyIME)(hImc, dwAction, dwIndex, dwValue);

    ImmUnlockImeDpi(pImeDpi);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\imminit.c ===
/****************************** Module Header ******************************\
* Module Name: imminit.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module implements IMM32 initialization
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// required for wow.obj in userrtl.lib
extern ULONG_PTR gHighestUserAddress;


BOOL ImmInitializeGlobals(HINSTANCE hmod)
{
    SYSTEM_BASIC_INFORMATION SystemInformation;

    if (hmod) {
        /*
         * Remember IMM32.DLL's hmodule so we can grab resources from it later.
         */
        ghInst = hmod;
    }
    if (gfInitialized) {
        return TRUE;
    }
    if (!NT_SUCCESS(RtlInitializeCriticalSection(&gcsImeDpi))) {
        RIPMSG0(RIP_WARNING, "ImmInitializeGlobals: failed to initialize critical section at startup. Just bail.");
        return FALSE;
    }
    if (!NT_SUCCESS(NtQuerySystemInformation(SystemBasicInformation,
            &SystemInformation,
            sizeof(SystemInformation),
            NULL))) {
        RIPMSG0(RIP_WARNING, "ImmInitializeGlobals: failed to query system information. Just bail.");
        return FALSE;
    }
    gHighestUserAddress = SystemInformation.MaximumUserModeAddress;

    gfInitialized = TRUE;

    return TRUE;
}


BOOL ImmRegisterClient(
    IN PSHAREDINFO psiClient, HINSTANCE hmod)
{
    gSharedInfo = *psiClient;
    gpsi = gSharedInfo.psi;
    /* Raid #97316
     * Dlls loaded earlier than imm32.dll could make
     * user32 call which calls back imm routines.
     * ImmRegisterClient() is called from User32's init routine,
     * so we can expect to reach here early enough.
     * We need to initialize globals as much as possible
     * here.
     */
    return ImmInitializeGlobals(hmod);
}

BOOL ImmDllInitialize(
    IN PVOID hmod,
    IN DWORD Reason,
    IN PCONTEXT pctx OPTIONAL)
{
    UNREFERENCED_PARAMETER(pctx);

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:
        UserAssert(!gfInitialized || hmod == ghInst);

        if (!ImmInitializeGlobals(hmod))
            return FALSE;

        UserAssert(hmod != NULL);

        // Initialize USER32.DLL in case if USER32 has not bound itself to IMM32
        if (!User32InitializeImmEntryTable(IMM_MAGIC_CALLER_ID))
            return FALSE;
        break;

    case DLL_PROCESS_DETACH:
        if (gfInitialized) {
            RtlDeleteCriticalSection(&gcsImeDpi);
        }
        break;

    case DLL_THREAD_DETACH:
        if (IS_IME_ENABLED() && NtCurrentTebShared()->Win32ThreadInfo) {
            DestroyInputContext(
                (HIMC)NtUserGetThreadState(UserThreadStateDefaultInputContext),
                GetKeyboardLayout(0),
                TRUE);
        }
        break;

    default:
        break;
    }

    return TRUE;
}

PVOID UserRtlAllocMem(
    ULONG uBytes)
{
    return LocalAlloc(LPTR, uBytes);
}

VOID UserRtlFreeMem(
    PVOID pMem)
{
    LocalFree(pMem);
}

#if DBG
DWORD GetRipComponent(
    VOID)
{
    return RIP_IMM;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\layout.c ===
/**************************************************************************\
* Module Name: layout.c (corresponds to Win95 ime.c)
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IME Keyboard Layout related functionality
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Local Defines.
 */
#define szLZOpenFileW "LZOpenFileW"
#define szLZCopy      "LZCopy"
#define szLZClose     "LZClose"

typedef HFILE (WINAPI *LPFNLZOPENFILEW)(LPTSTR, LPOFSTRUCT, WORD);
typedef LONG  (WINAPI *LPFNLZCOPY)(INT, INT);
typedef VOID  (WINAPI *LPFNLZCLOSE)(INT);

/*
 * Local Routines.
 */
UINT StrToUInt(LPWSTR);
VOID UIntToStr(UINT, ULONG, LPWSTR, USHORT);
BOOL CopyImeFile(LPWSTR, LPCWSTR);
INT  GetImeLayout(PIMELAYOUT, INT);
BOOL WriteImeLayout(HKL, LPCWSTR, LPCWSTR);
HKL  AssignNewLayout(INT, PIMELAYOUT, HKL);


/***************************************************************************\
* ImmGetIMEFileNameW
*
* Gets the description of the IME with the specified HKL.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

UINT WINAPI ImmGetDescriptionW(
    HKL    hKL,
    LPWSTR lpwszDescription,
    UINT   uBufLen)
{
    IMEINFOEX iiex;
    UINT uRet;

    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return 0;

#if defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
        return 0;
#endif

    uRet = wcslen(iiex.wszImeDescription);

    /*
     * ask buffer length
     */
    if (uBufLen == 0)
        return uRet;

    if (uBufLen > uRet) {
        wcscpy(lpwszDescription, iiex.wszImeDescription);
    }
    else {
        uRet = uBufLen - 1;
        wcsncpy(lpwszDescription, iiex.wszImeDescription, uRet);
        lpwszDescription[uRet] = L'\0';
    }

    return uRet;
}


/***************************************************************************\
* ImmGetIMEFileNameA
*
* Gets the description of the IME with the specified HKL.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

UINT WINAPI ImmGetDescriptionA(
    HKL   hKL,
    LPSTR lpszDescription,
    UINT  uBufLen)
{
    IMEINFOEX iiex;
    INT       i;
    BOOL      bUDC;

    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return 0;

#if defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
        return 0;
#endif

    i = WideCharToMultiByte(CP_ACP,
                            (DWORD)0,
                            (LPWSTR)iiex.wszImeDescription,       // src
                            wcslen(iiex.wszImeDescription),
                            lpszDescription,                      // dest
                            uBufLen,
                            (LPSTR)NULL,
                            (LPBOOL)&bUDC);

    if (uBufLen != 0)
        lpszDescription[i] = '\0';

    return (UINT)i;
}


/***************************************************************************\
* ImmGetIMEFileNameW
*
* Gets the file name of the IME with the specified HKL.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

UINT WINAPI ImmGetIMEFileNameW(
    HKL    hKL,
    LPWSTR lpwszFile,
    UINT   uBufLen)
{
    IMEINFOEX iiex;
    UINT uRet;

    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return 0;

#if defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
    {
        //
        // #602631
        //
        // Ichitaro12 ATOKLIB.DLL does not check the return value of
        // ImmGetIMEFileName()
        //
        if (uBufLen)
            *lpwszFile = L'\0';
        return 0;
    }
#endif

    uRet = wcslen(iiex.wszImeFile);

    /*
     * ask buffer length
     */
    if (uBufLen == 0)
        return uRet;

    if (uBufLen > uRet) {
        wcscpy(lpwszFile, iiex.wszImeFile);
    }
    else {
        uRet = uBufLen - 1;
        wcsncpy(lpwszFile, iiex.wszImeFile, uRet);
        lpwszFile[uRet] = L'\0';
    }

    return uRet;
}


/***************************************************************************\
* ImmGetIMEFileNameA
*
* Gets the file name of the IME with the specified HKL.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

UINT WINAPI ImmGetIMEFileNameA(
    HKL   hKL,
    LPSTR lpszFile,
    UINT  uBufLen)
{
    IMEINFOEX iiex;
    INT       i;
    BOOL      bUDC;

    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return 0;

#if defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
    {
        //
        // #602631
        //
        // Ichitaro12 ATOKLIB.DLL does not check the return value of
        // ImmGetIMEFileName()
        //
        if (uBufLen)
            *lpszFile = '\0';
        return 0;
    }
#endif

    i = WideCharToMultiByte(CP_ACP,
                            (DWORD)0,
                            (LPWSTR)iiex.wszImeFile,       // src
                            wcslen(iiex.wszImeFile),
                            lpszFile,                      // dest
                            uBufLen,
                            (LPSTR)NULL,
                            (LPBOOL)&bUDC);

    if (uBufLen != 0)
        lpszFile[i] = '\0';

    return i;
}


/***************************************************************************\
* ImmGetProperty
*
* Gets the property and capability of the IME with the specified HKL.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetProperty(
    HKL     hKL,
    DWORD   dwIndex)
{
    IMEINFOEX iiex;
    PIMEDPI   pImeDpi = NULL;
    PIMEINFO  pImeInfo;
    DWORD     dwRet;

    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return 0;

    if (dwIndex == IGP_GETIMEVERSION)
        return iiex.dwImeWinVersion;

    if (iiex.fLoadFlag != IMEF_LOADED) {
        pImeDpi = FindOrLoadImeDpi(hKL);
        if (pImeDpi == NULL) {
            RIPMSG0(RIP_WARNING, "ImmGetProperty: load IME failure.");
            return 0;
        }
        pImeInfo = &pImeDpi->ImeInfo;
    }
    else {
        pImeInfo = &iiex.ImeInfo;
    }

    switch (dwIndex) {
    case IGP_PROPERTY:
        dwRet = pImeInfo->fdwProperty;
        break;

    case IGP_CONVERSION:
        dwRet = pImeInfo->fdwConversionCaps;
        break;

    case IGP_SENTENCE:
        dwRet = pImeInfo->fdwSentenceCaps;
        break;

    case IGP_UI:
        dwRet = pImeInfo->fdwUICaps;
        break;

    case IGP_SETCOMPSTR:
        dwRet = pImeInfo->fdwSCSCaps;
        break;

    case IGP_SELECT:
        dwRet = pImeInfo->fdwSelectCaps;
        break;

    default:
        RIPMSG1(RIP_WARNING, "ImmGetProperty: wrong index %lx.", dwIndex);
        dwRet = 0;
        break;
    }

    ImmUnlockImeDpi(pImeDpi);

    return dwRet;
}


HKL WINAPI ImmInstallIMEW(
    LPCWSTR lpszIMEFileName,
    LPCWSTR lpszLayoutText)
{
    LPWSTR     lpwszImeFileName;
    LPWSTR     lpwszImeFilePart;
    LPWSTR     lpwszImeCopiedPath;
    int        i, nIMEs;
    PIMELAYOUT pImeLayout = NULL;
    HKL        hImeKL, hLangKL;
    WCHAR      szKeyName[HEX_ASCII_SIZE];
    IMEINFOEX  iiex;

    lpwszImeFileName = ImmLocalAlloc(0, (MAX_PATH+1) * sizeof(WCHAR));
    if (lpwszImeFileName == NULL)
        return (HKL)0;

    lpwszImeCopiedPath = ImmLocalAlloc(0, (MAX_PATH+1) * sizeof(WCHAR));
    if (lpwszImeCopiedPath == NULL) {
        ImmLocalFree(lpwszImeFileName);
        return (HKL)0;
    }

    /*
     * Get the file name only into lpwszImeFilePart
     */
    GetFullPathNameW(lpszIMEFileName, MAX_PATH,
                lpwszImeFileName, &lpwszImeFilePart);

    CharUpper(lpwszImeFileName);

    if (lpwszImeFilePart == NULL) {
        ImmLocalFree(lpwszImeFileName);
        ImmLocalFree(lpwszImeCopiedPath);
        return (HKL)0;
    }

    hImeKL = hLangKL = iiex.hkl = (HKL)0;

    wcsncpy(iiex.wszImeFile, lpwszImeFilePart, IM_FILE_SIZE-1);
    iiex.wszImeFile[IM_FILE_SIZE - 1] = L'\0';

    if (LoadVersionInfo(&iiex) && iiex.hkl != (HKL)0) {
        hLangKL = iiex.hkl;
    }
    else {
        ImmLocalFree(lpwszImeFileName);
        ImmLocalFree(lpwszImeCopiedPath);
        return (HKL)0;
    }

    nIMEs = GetImeLayout(NULL, 0);
    if (nIMEs != 0) {
        pImeLayout = (PIMELAYOUT)ImmLocalAlloc(0, nIMEs * sizeof(IMELAYOUT));
        if (pImeLayout == NULL) {
            ImmLocalFree(lpwszImeFileName);
            ImmLocalFree(lpwszImeCopiedPath);
            return (HKL)0;
        }

        GetImeLayout(pImeLayout, nIMEs);

        for (i=0; i < nIMEs; i++) {
            if (_wcsicmp(pImeLayout[i].szImeName, lpwszImeFilePart) == 0) {
                /*
                 * We got the same IME name, ISV wants to upgrade.
                 */
                if (LOWORD(HandleToUlong(hLangKL)) != LOWORD(HandleToUlong(pImeLayout[i].hImeKL))) {
                    /*
                     * IME name conflict, blow out!
                     */
                    RIPMSG0(RIP_WARNING, "ImmInstallIME: different language!");
                    goto ImmInstallIMEWFailed;
                }

                hImeKL = pImeLayout[i].hImeKL;
                break;
            }
        }
    }

    if (ImmGetImeInfoEx(&iiex, ImeInfoExImeFileName, lpwszImeFilePart)) {
        /*
         * The specified IME has been activated. Unload it first.
         */
        if (!UnloadKeyboardLayout(iiex.hkl)) {
            hImeKL = (HKL)0;
            goto ImmInstallIMEWFailed;
        }
    }

    /*
     * We will copy to system directory
     */
#if 0
    i = (INT)GetSystemDirectory(lpwszImeCopiedPath, MAX_PATH);
    lpwszImeCopiedPath[i] = L'\0';
    AddBackslash(lpwszImeCopiedPath);
    wcscat(lpwszImeCopiedPath, lpwszImeFilePart);
#else
    GetSystemPathName(lpwszImeCopiedPath, lpwszImeFilePart, MAX_PATH);
#endif
    CharUpper(lpwszImeCopiedPath);

    if (_wcsicmp(lpwszImeFileName, lpwszImeCopiedPath) != 0) {
        /*
         * path is different, need to copy into system directory
         */
        if (!CopyImeFile(lpwszImeFileName, lpwszImeCopiedPath)) {
            hImeKL = (HKL)0;
            goto ImmInstallIMEWFailed;
        }
    }

    if (hImeKL == 0) {
        hImeKL = AssignNewLayout(nIMEs, pImeLayout, hLangKL);
    }

    if (hImeKL != 0) {
        /*
         * Write HKL under "keyboard layouts"
         */
        if (WriteImeLayout(hImeKL, lpwszImeFilePart, lpszLayoutText)) {
            UIntToStr(HandleToUlong(hImeKL), 16, szKeyName, sizeof(szKeyName));
            hImeKL = LoadKeyboardLayout(szKeyName, KLF_REPLACELANG);
        }
        else {
            hImeKL = (HKL)0;
        }
    }

ImmInstallIMEWFailed:
    if (pImeLayout != NULL)
        ImmLocalFree(pImeLayout);
    ImmLocalFree(lpwszImeFileName);
    ImmLocalFree(lpwszImeCopiedPath);

    return (HKL)hImeKL;
}


HKL WINAPI ImmInstallIMEA(
    LPCSTR lpszIMEFileName,
    LPCSTR lpszLayoutText)
{
    HKL    hKL;
    LPWSTR lpwszIMEFileName;
    LPWSTR lpwszLayoutText;
    DWORD  cbIMEFileName;
    DWORD  cbLayoutText;
    INT    i;

    cbIMEFileName = strlen(lpszIMEFileName) + sizeof(CHAR);
    cbLayoutText  = strlen(lpszLayoutText)  + sizeof(CHAR);

    lpwszIMEFileName = ImmLocalAlloc(0, cbIMEFileName * sizeof(WCHAR));
    if (lpwszIMEFileName == NULL) {
        RIPMSG0(RIP_WARNING, "ImmInstallIMEA: memory failure!");
        return (HKL)0;
    }

    lpwszLayoutText = ImmLocalAlloc(0, cbLayoutText * sizeof(WCHAR));
    if (lpwszLayoutText == NULL) {
        RIPMSG0(RIP_WARNING, "ImmInstallIMEA: memory failure!");
        ImmLocalFree(lpwszIMEFileName);
        return (HKL)0;
    }

    i = MultiByteToWideChar(CP_ACP,
                            (DWORD)MB_PRECOMPOSED,
                            (LPSTR)lpszIMEFileName,              // src
                            (INT)strlen(lpszIMEFileName),
                            (LPWSTR)lpwszIMEFileName,            // dest
                            (INT)cbIMEFileName);
    lpwszIMEFileName[i] = L'\0';

    i = MultiByteToWideChar(CP_ACP,
                            (DWORD)MB_PRECOMPOSED,
                            (LPSTR)lpszLayoutText,              // src
                            (INT)strlen(lpszLayoutText),
                            (LPWSTR)lpwszLayoutText,            // dest
                            (INT)cbLayoutText);
    lpwszLayoutText[i] = L'\0';

    hKL = ImmInstallIMEW(lpwszIMEFileName, lpwszLayoutText);

    ImmLocalFree(lpwszLayoutText);
    ImmLocalFree(lpwszIMEFileName);

    return hKL;
}


/***************************************************************************\
* ImmIsIME
*
* Checks whether the specified hKL is a HKL of an IME or not.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmIsIME(
    HKL hKL)
{
    IMEINFOEX iiex;

#if !defined(CUAS_ENABLE)
    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return FALSE;
#else
    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayoutWithCUAS, &hKL))
        return FALSE;
#endif

    return TRUE;
}


UINT StrToUInt(
    LPWSTR lpsz)
{
    UNICODE_STRING Value;
    UINT ReturnValue;

    Value.Length = wcslen(lpsz) * sizeof(WCHAR);
    Value.Buffer = lpsz;

    /*
     * Convert string to int.
     */
    RtlUnicodeStringToInteger(&Value, 16, &ReturnValue);
    return(ReturnValue);
}


VOID UIntToStr(
    UINT   Value,
    ULONG  Base,
    LPWSTR lpsz,
    USHORT dwBufLen)
{
    UNICODE_STRING String;

    String.Length = dwBufLen;
    String.MaximumLength = dwBufLen;
    String.Buffer = lpsz;

    /*
     * Convert int to string.
     */
    RtlIntegerToUnicodeString(Value, Base, &String);
}


BOOL CopyImeFile(
    LPWSTR lpwszImeFileName,
    LPCWSTR lpwszImeCopiedPath)
{
    HMODULE         hLzExpandDll;
    BOOL            fUnloadExpandDll;
    LPFNLZOPENFILEW lpfnLZOpenFileW;
    LPFNLZCOPY      lpfnLZCopy;
    LPFNLZCLOSE     lpfnLZClose;
    OFSTRUCT        ofStruc;
    HFILE           hfSource, hfDest;
    LPSTR           lpszImeCopiedPath;
    INT             i, cbBuffer;
    BOOL            fRet = FALSE;

    hLzExpandDll = GetModuleHandle(L"LZ32");
    if (hLzExpandDll) {
        fUnloadExpandDll = FALSE;
    } else {
        WCHAR szLzExpand[MAX_PATH];

        GetSystemPathName(szLzExpand, L"LZ32", MAX_PATH);
        hLzExpandDll = LoadLibrary(szLzExpand);
        if (!hLzExpandDll) {
            return FALSE;
        }

        fUnloadExpandDll = TRUE;
    }

#define GET_PROC(x) \
    if (!(lpfn##x = (PVOID) GetProcAddress(hLzExpandDll, sz##x))) { \
        goto CopyImeFileFailed; }

    GET_PROC(LZOpenFileW);
    GET_PROC(LZCopy);
    GET_PROC(LZClose);

#undef GET_PROC

    cbBuffer = (wcslen(lpwszImeCopiedPath) + 1) * sizeof(WCHAR);

    if ((lpszImeCopiedPath = ImmLocalAlloc(0, cbBuffer)) == NULL)
        goto CopyImeFileFailed;

    i = WideCharToMultiByte(CP_ACP,
                            (DWORD)0,
                            lpwszImeCopiedPath,          // src
                            wcslen(lpwszImeCopiedPath),
                            lpszImeCopiedPath,           // dest
                            cbBuffer,
                            (LPSTR)NULL,
                            (LPBOOL)NULL);
    if (i == 0) {
        ImmLocalFree(lpszImeCopiedPath);
        goto CopyImeFileFailed;
    }

    lpszImeCopiedPath[i] = '\0';

    hfSource = (*lpfnLZOpenFileW)(lpwszImeFileName, &ofStruc, OF_READ);
    if (hfSource < 0) {
        ImmLocalFree(lpszImeCopiedPath);
        goto CopyImeFileFailed;
    }

    hfDest = OpenFile(lpszImeCopiedPath, &ofStruc, OF_CREATE);
    if (hfDest != HFILE_ERROR) {
        if ((*lpfnLZCopy)(hfSource, hfDest) >= 0) {
            fRet = TRUE;
        }
        _lclose(hfDest);
    }

    (*lpfnLZClose)(hfSource);

    ImmLocalFree(lpszImeCopiedPath);

CopyImeFileFailed:
    if (fUnloadExpandDll)
        FreeLibrary(hLzExpandDll);

    return fRet;
}


INT GetImeLayout(
    PIMELAYOUT pImeLayout,
    INT        cEntery)
{
    int      i, nIMEs;
    HKEY     hKeyKbdLayout;
    HKEY     hKeyOneIME;
    WCHAR    szKeyName[HEX_ASCII_SIZE];
    WCHAR    szImeFileName[IM_FILE_SIZE];
    CONST DWORD dwKeyNameSize = ARRAY_SIZE(szKeyName);
    DWORD    dwTmp;

    RegOpenKey(HKEY_LOCAL_MACHINE, gszRegKbdLayout, &hKeyKbdLayout);

    for (i = 0, nIMEs = 0;
         RegEnumKey(hKeyKbdLayout, i, szKeyName, dwKeyNameSize) == ERROR_SUCCESS;
         i++)
    {
        if (szKeyName[0] != L'E' && szKeyName[0] != L'e')
            continue;   // this is not an IME based keyboard layout.

        if (pImeLayout != NULL) {

            if (nIMEs >= cEntery)
                break;

            RegOpenKey(hKeyKbdLayout, szKeyName, &hKeyOneIME);

            dwTmp = IM_FILE_SIZE;

            RegQueryValueEx(hKeyOneIME,
                    gszValImeFile,
                    NULL,
                    NULL,
                    (LPBYTE)szImeFileName,
                    &dwTmp);

            // avoid length problem
            szImeFileName[IM_FILE_SIZE - 1] = L'\0';

            RegCloseKey(hKeyOneIME);

            CharUpper(szImeFileName);

            pImeLayout[nIMEs].hImeKL = (HKL)IntToPtr( StrToUInt(szKeyName) );
            wcscpy(pImeLayout[nIMEs].szKeyName, szKeyName);
            wcscpy(pImeLayout[nIMEs].szImeName, szImeFileName);
        }

        nIMEs++;
    }

    RegCloseKey(hKeyKbdLayout);

    return nIMEs;
}


BOOL WriteImeLayout(
    HKL     hImeKL,
    LPCWSTR lpwszImeFilePart,
    LPCWSTR lpszLayoutText)
{
    int      i;
    HKEY     hKeyKbdLayout;
    HKEY     hKeyOneIME;
    HKEY     hKeyKbdOrder;
    WCHAR    szKeyName[HEX_ASCII_SIZE];
    WCHAR    szImeFileName[IM_FILE_SIZE];
    WCHAR    szOrderNum[HEX_ASCII_SIZE];
    WCHAR    szOrderKeyName[HEX_ASCII_SIZE];
    DWORD    dwTmp;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   gszRegKbdLayout,
                   &hKeyKbdLayout) != ERROR_SUCCESS) {
        RIPMSG0(RIP_WARNING, "WriteImeLayout: RegOpenKey() failed!");
        return FALSE;
    }

    UIntToStr(HandleToUlong(hImeKL), 16, szKeyName, sizeof(szKeyName));

    if (RegCreateKey(hKeyKbdLayout,
                szKeyName,
                &hKeyOneIME) != ERROR_SUCCESS) {
        RIPMSG0(RIP_WARNING, "WriteImeLayout: RegCreateKey() failed!");
        RegCloseKey(hKeyKbdLayout);
        return FALSE;
    }

    if (RegSetValueExW(hKeyOneIME,
                gszValImeFile,
                0,
                REG_SZ,
                (CONST BYTE*)lpwszImeFilePart,
                (wcslen(lpwszImeFilePart) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto WriteImeLayoutFail;
    }

    if (RegSetValueExW(hKeyOneIME,
                gszValLayoutText,
                0,
                REG_SZ,
                (CONST BYTE*)lpszLayoutText,
                (wcslen(lpszLayoutText) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto WriteImeLayoutFail;
    }

    switch (LANGIDFROMHKL(hImeKL)) {
        case LANG_JAPANESE:
            wcscpy(szImeFileName, L"kbdjpn.dll");
            break;
        case LANG_KOREAN:
            wcscpy(szImeFileName, L"kbdkor.dll");
            break;
        case LANG_CHINESE:
        default:
            wcscpy(szImeFileName, L"kbdus.dll");
            break;
    }

    if (RegSetValueExW(hKeyOneIME,
                gszValLayoutFile,
                0,
                REG_SZ,
                (CONST BYTE*)szImeFileName,
                (wcslen(szImeFileName) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto WriteImeLayoutFail;
    }

    RegCloseKey(hKeyOneIME);
    RegCloseKey(hKeyKbdLayout);

    /*
     * Update CurrentUser's preload keyboard layout setting
     */
    RegCreateKey(HKEY_CURRENT_USER, gszRegKbdOrder, &hKeyKbdOrder);

    for (i = 1; i < 1024; i++) {
        UIntToStr(i, 10, szOrderNum, sizeof(szOrderNum));

        dwTmp = sizeof(szOrderKeyName);
        if (RegQueryValueEx(hKeyKbdOrder,
                    szOrderNum,
                    NULL,
                    NULL,
                    (LPBYTE)szOrderKeyName,
                    &dwTmp) != ERROR_SUCCESS) {
            break;
        }

        if (_wcsicmp(szKeyName, szOrderKeyName) == 0) {
            /*
             * We have the same value in the preload!
             * OK, ISV is developing their IMEs
             * so even it is in preload, but it can not be loaded
             */
            break;
        }
    }

    if (i < 1024) {
        /*
         * Write a subkey under "preload"
         */
        RegSetValueExW(hKeyKbdOrder,
                       szOrderNum,
                       0,
                       REG_SZ,
                       (CONST BYTE*)szKeyName,
                       (lstrlen(szKeyName) + 1) * sizeof(WCHAR));
        RegCloseKey(hKeyKbdOrder);
    }
    else {
        RegCloseKey(hKeyKbdOrder);
        return FALSE;
    }

    return TRUE;

WriteImeLayoutFail:
    RegCloseKey(hKeyOneIME);
    RegDeleteKey(hKeyKbdLayout, szKeyName);
    RegCloseKey(hKeyKbdLayout);

    return FALSE;
}

#define IMELANGID(hkl) \
    LOWORD(HandleToUlong(hkl))

#define IMELAYOUTID(hkl) \
    HIWORD(HandleToUlong(hkl))

HKL AssignNewLayout(
    INT         nIMEs,
    PIMELAYOUT  pImeLayout,
    HKL         hLangKL)
{
    DWORD   dwNewId  = 0;
    DWORD   dwHighId = 0xE01F;
    DWORD   dwLowId  = 0xE0FF;
    INT     i;

    /*
     * We prefer the value higher than E01F for ISVs, we will use
     * E001 ~ E01F in Microsoft .INF file
     */

    /*
     * Find out the high and low one
     */
    for (i = 0; i < nIMEs; ++i) {
        /*
         * Let's try to keep the previous behavior, not to
         * have the duplicated hiword in hkl.
         */
        if (IMELAYOUTID(pImeLayout[i].hImeKL) > dwHighId) {
            dwHighId = IMELAYOUTID(pImeLayout[i].hImeKL);
        }
        if (IMELAYOUTID(pImeLayout[i].hImeKL) < dwLowId) {
            dwLowId = IMELAYOUTID(pImeLayout[i].hImeKL);
        }
    }

    if (dwHighId < 0xE0FF) {
        dwNewId = dwHighId + 1;
    } else if (dwLowId > 0xE001) {
        dwNewId = dwLowId - 1;
    } else {
        /*
         * Need to find out unused hKL using full search.
         * Find it one by one.
         */
        DWORD dwId;

        for (dwId = 0xE020; dwId < 0xE100; ++dwId) {
            for (i = 0; i < nIMEs; ++i) {
                if (IMELAYOUTID(pImeLayout[i].hImeKL) == dwId &&
                    IMELANGID(pImeLayout[i].hImeKL) == IMELANGID(hLangKL)) {
                    // conflicts with existing IME, try the next dwLowId
                    break;
                }
            }

            if (i >= nIMEs) {
                break;
            }

        }

        if (dwId < 0xE100) {
            dwNewId = dwId;
        }
    }

    if (dwNewId == 0) {
        return NULL;
    }

    return (HKL)UIntToPtr(MAKELONG(IMELANGID(hLangKL), dwNewId));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\layime.c ===
/**************************************************************************\
* Module Name: layout.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IMM User Mode Routines
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define VERSION_DLL       TEXT("version.dll")
#define VER_FILE_VERSION  TEXT("FileVersion")

#define SZ_BACKSLASH      TEXT("\\")

#define WCHAR_BACKSLASH   L'\\'
#define WCHAR_NULL        L'\0'

#define VERSION_GetFileVersionInfoW     "GetFileVersionInfoW"
#define VERSION_GetFileVersionInfoSizeW "GetFileVersionInfoSizeW"
#define VERSION_VerQueryValueW          "VerQueryValueW"

typedef BOOL  (WINAPI *LPFNGETFILEVERSIONINFOW)(PWSTR, DWORD, DWORD, LPVOID);
typedef DWORD (WINAPI *LPFNGETFILEVERSIONINFOSIZEW)(PWSTR, LPDWORD);
typedef BOOL  (WINAPI *LPFNVERQUERYVALUEW)(const LPVOID, PWSTR, LPVOID*, LPDWORD);
typedef VS_FIXEDFILEINFO *PFIXEDFILEINFO;

static LPFNGETFILEVERSIONINFOW     pfnGetFileVersionInfoW;
static LPFNGETFILEVERSIONINFOSIZEW pfnGetFileVersionInfoSizeW;
static LPFNVERQUERYVALUEW          pfnVerQueryValueW;


BOOL ImmLoadLayout(
    HKL        hKL,
    PIMEINFOEX piiex)
{
    UNICODE_STRING strIme;
    WCHAR    wszIme[MAX_PATH];
    HKEY     hKeyKbdLayout = NULL;
    HKEY     hKeyIme;
    NTSTATUS Status;
    DWORD    dwTmp;
    LONG     lRet;

    hKeyKbdLayout = NULL;
    hKeyIme = NULL;


#ifdef CUAS_ENABLE
    if (! IS_IME_KBDLAYOUT(hKL) && IS_CICERO_ENABLED_AND_NOT16BIT()) {
        lRet = RegOpenKey(HKEY_LOCAL_MACHINE, gszRegCiceroIME, &hKeyIme);
        if ( lRet != ERROR_SUCCESS ) {
            return FALSE;
        }
    }
    else
#endif // CUAS_ENABLE
    {

        strIme.Buffer = wszIme;
        strIme.MaximumLength = sizeof(wszIme);

        Status = RtlIntegerToUnicodeString(HandleToUlong(hKL), 16, &strIme);
        if (!NT_SUCCESS(Status)) {
            return(FALSE);
        }

        lRet = RegOpenKey(HKEY_LOCAL_MACHINE, gszRegKbdLayout, &hKeyKbdLayout);
        if ( lRet != ERROR_SUCCESS ) {
            return(FALSE);
        }

        lRet = RegOpenKey(hKeyKbdLayout, strIme.Buffer, &hKeyIme);
        if ( lRet != ERROR_SUCCESS ) {
            RegCloseKey(hKeyKbdLayout);
            return(FALSE);
        }
    }

    dwTmp = IM_FILE_SIZE;
    lRet = RegQueryValueEx(hKeyIme,
                           gszValImeFile,
                           NULL,
                           NULL,
                           (LPBYTE)piiex->wszImeFile,
                           &dwTmp);

    if ( lRet != ERROR_SUCCESS ) {
        RegCloseKey(hKeyIme);
        if (hKeyKbdLayout)
            RegCloseKey(hKeyKbdLayout);
        return(FALSE);
    }

    piiex->wszImeFile[IM_FILE_SIZE - 1] = L'\0';

    RegCloseKey(hKeyIme);
    if (hKeyKbdLayout)
        RegCloseKey(hKeyKbdLayout);

    piiex->hkl = hKL;
    piiex->fLoadFlag = IMEF_NONLOAD;

    return LoadVersionInfo(piiex);
}

// GetSystemPathName()
// create "%windir%\system32\%filename"
VOID GetSystemPathName(PWSTR /*OUT*/ pwszPath, PWSTR pwszFileName, UINT maxChar)
{
    UINT uRet;

    if (! pwszPath || ! pwszFileName || maxChar == 0) {
        pwszPath[0] = L'\0';
        return;
    }
    if (! pwszFileName[0]) {
        pwszPath[0] = L'\0';
        return;
    }

    uRet = GetSystemDirectoryW(pwszPath, maxChar);

    if (uRet >= maxChar) {
        uRet = 0;
        pwszPath[0] = L'\0';
    }
    else if (uRet) {
        UINT uLen;

        if (pwszPath[uRet - 1] != L'\\') {
            pwszPath[uRet] = L'\\';
            uRet++;
        }

        if (uRet >= maxChar) {
            uRet = 0;
            pwszPath[0] = L'\0';
        }
        else {
            uLen = wcslen(pwszFileName);
            if (maxChar - uRet > uLen) {
                wcsncpy(&pwszPath[uRet],
                        pwszFileName,
                        maxChar - uRet);
                uRet += uLen;
            }
            else {
                uRet = 0;
                pwszPath[0] = L'\0';
            }
        }
    }
}

INT
ExtractColumn(
    LPWSTR lpSrc,
    WCHAR  cSeparator,
    UINT   uiColumn
    )

/*++

Routine Description:


Arguments:

    lpSrc - "YYYY.MM.DD" or "HH:MM:SS" or "MM.NN" pointer

Return Value:

    packed int

--*/

{
    UNICODE_STRING uStr;
    WCHAR *pSep, *pStr;
    INT i;

    if (!lpSrc) {
        return 0;
    }

    pStr = pSep = NULL;

    while (uiColumn--) {
        pStr = lpSrc;

        while (*lpSrc && *lpSrc != cSeparator) {
            lpSrc++;
        }

        if (*lpSrc == cSeparator) {
            pSep = lpSrc;
            lpSrc++;
        }
    }

    if (pStr) {
        if (pSep) {
            *pSep = TEXT('\0');
            uStr.Length = (USHORT)((pSep - pStr) * sizeof(WCHAR));
        }
        else {
            uStr.Length = (USHORT)(((lpSrc - pStr) + 1) * sizeof(WCHAR));
        }
        uStr.Buffer = pStr;
        uStr.MaximumLength = (USHORT)(uStr.Length + sizeof(WCHAR));
        RtlUnicodeStringToInteger(&uStr, 0, &i);
        if (pSep) {
            *pSep = cSeparator;
        }
    } else {
        i = 0;
    }

    return i;
}


PWSTR GetVersionDatum(
    PWSTR pszVersionBuffer,
    PWSTR pszVersionKey,
    PWSTR pszName)
{
    ULONG ulSize;
    DWORD cbValue = 0;
    PWSTR pValue;

    ulSize = wcslen(pszVersionKey);
    wcscat(pszVersionKey, pszName);

    (*pfnVerQueryValueW)(pszVersionBuffer,
                          pszVersionKey,
                          (LPVOID*)&pValue,
                          &cbValue);

    pszVersionKey[ulSize] = L'\0';
    return (cbValue != 0) ? pValue : (PWSTR)NULL;
}


BOOL LoadFixVersionInfo(
    PIMEINFOEX piiex,
    PWSTR      pszVersionBuffer)
{
    PFIXEDFILEINFO pFixedVersionInfo;
    BOOL           fResult;
    DWORD          cbValue;

    fResult = (*pfnVerQueryValueW)(pszVersionBuffer,
                                   SZ_BACKSLASH,
                                   &pFixedVersionInfo,
                                   &cbValue);

    if (!fResult || cbValue == 0)
        return FALSE;

    /*
     * Check for IME file type.
     */
    if (pFixedVersionInfo->dwFileType != VFT_DRV ||
        pFixedVersionInfo->dwFileSubtype != VFT2_DRV_INPUTMETHOD) {
        return FALSE;
    }

    piiex->dwProdVersion = pFixedVersionInfo->dwProductVersionMS;

    /*
     * Currently, we only support 4.0 DLL based IME.
     */
    piiex->dwImeWinVersion = IMEVER_0400;

    return TRUE;
}

BOOL LoadVarVersionInfo(
    PIMEINFOEX piiex,
    PWSTR      pszVersionBuffer)
{
    PWSTR   pDescription;
    WORD    wLangId;
    BOOL    fResult;
    PUSHORT puXlate;
    DWORD   cbValue;
    WCHAR   szVersionKey[80];

    fResult = (*pfnVerQueryValueW)(pszVersionBuffer,
                                   L"\\VarFileInfo\\Translation",
                                   (LPVOID *)&puXlate,
                                   &cbValue);

    if (!fResult || cbValue == 0)
        return FALSE;

    wLangId = *puXlate;

    if (piiex->hkl == 0) {
        /*
         * A newly installed IME, its HKL is not assigned yet.
         */
        piiex->hkl = (HKL)LongToHandle( MAKELONG(wLangId, 0) );
    }
#if 0    // let unlocalized IME to work.
    else if (LOWORD(HandleToUlong(piiex->hkl)) != wLangId){
        /*
         * Mismatch in Lang ID, blow out
         */
        return FALSE;
    }
#endif

    /*
     * First try the language we are currently in.
     */
    wsprintf(szVersionKey, L"\\StringFileInfo\\%04X04B0\\",
             LANGIDFROMLCID(GetThreadLocale()));

    pDescription = GetVersionDatum(pszVersionBuffer, szVersionKey,
            L"FileDescription");

    if (pDescription == NULL) {
        /*
         * Now try the first translation specified in IME
         */
        wsprintf(szVersionKey, L"\\StringFileInfo\\%04X%04X\\",
                 *puXlate, *(puXlate+1));

        pDescription = GetVersionDatum(pszVersionBuffer, szVersionKey,
                L"FileDescription");
    }

    if (pDescription != NULL) {
        wcsncpy(piiex->wszImeDescription, pDescription, ARRAY_SIZE(piiex->wszImeDescription) - 1);
        piiex->wszImeDescription[ARRAY_SIZE(piiex->wszImeDescription) - 1] = L'\0';
    }
    else {
        piiex->wszImeDescription[0] = L'\0';
    }

    return TRUE;
}


BOOL LoadVersionInfo(
    PIMEINFOEX piiex)
{
    WCHAR   szPath[MAX_PATH];
    PWSTR   pszVersionBuffer;
    HANDLE  hVersion;
    DWORD   dwVersionSize;
    DWORD   dwHandle = 0;
    BOOL    fUnload, fReturn = FALSE;

    hVersion = GetModuleHandle(VERSION_DLL);
    if (hVersion != NULL) {
        fUnload = FALSE;
    }
    else {
        hVersion = LoadLibrary(VERSION_DLL);
        if (hVersion == NULL) {
            return FALSE;
        }
        fUnload = TRUE;
    }

#define GET_PROC(x) \
    if (!(pfn##x = (PVOID) GetProcAddress(hVersion, VERSION_##x))) { \
        goto LoadVerInfoUnload; }

    GET_PROC(GetFileVersionInfoW);
    GET_PROC(GetFileVersionInfoSizeW);
    GET_PROC(VerQueryValueW);

#undef GET_PROC

    // szPath = fully qualified IME file name
    GetSystemPathName(szPath, piiex->wszImeFile, ARRAY_SIZE(szPath));

    dwVersionSize = (*pfnGetFileVersionInfoSizeW)(szPath, &dwHandle);

    if (dwVersionSize == 0L)
        goto LoadVerInfoUnload;

    pszVersionBuffer = (PWSTR)ImmLocalAlloc(0, dwVersionSize);

    if (pszVersionBuffer == NULL)    // can't get memory for version info, blow out
        goto LoadVerInfoUnload;

    if (!(*pfnGetFileVersionInfoW)(szPath, dwHandle, dwVersionSize, pszVersionBuffer))
        goto LoadVerInfoFree;

    /*
     * Get the fixed block version information.
     */
    if (LoadFixVersionInfo(piiex, pszVersionBuffer)) {
        /*
         * Get the variable block version information.
         */
        fReturn = LoadVarVersionInfo(piiex, pszVersionBuffer);
    }

LoadVerInfoFree:
    ImmLocalFree((HLOCAL)pszVersionBuffer);

LoadVerInfoUnload:
    if (fUnload)
        FreeLibrary(hVersion);

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\kcodecnv.c ===
/**************************************************************************\
* Module Name: kcodecnv.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the code for the Korean code conversion functions.
*
* History:
* 15-Jul-1995
* 22-Feb-1996  bklee
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#define IDD_2BEOL    100
#define IDD_3BEOL1   101
#define IDD_3BEOL2   102

#define lpSource(lpks) (LPSTR)((LPSTR)lpks+lpks->dchSource)
#define lpDest(lpks)   (LPSTR)((LPSTR)lpks+lpks->dchDest)

#define JOHAB_CP   1361
#define WANSUNG_CP 949
#define TWO_BYTE   2
#define ONE_WORD   1

typedef struct tagHIGH_LOW              // For high byte and low byte
{
    BYTE    low, high;
}   HIGH_LOW;

typedef union tagWANSUNG                // For Wansung character code
{
    HIGH_LOW    e;
    WORD        w;
}   WANSUNG;

/* Hanguel Mnemonic Table for 2 BeolSik and 3 BeolSik */
CONST WORD HMNTable[3][96] =
{
// For 2 Beolsik.
    {
    /*  20  SP  */  0xA1A1,
    /*  21  !   */  0xA3A1,
    /*  22  "   */  0xA1A8,
    /*  23  #   */  0xA3A3,
    /*  24  $   */  0xA3A4,
    /*  25  %   */  0xA3A5,
    /*  26  &   */  0xA3A6,
    /*  27  `   */  0xA1AE,     /* A1AE ? AiA2 */
    /*  28  (   */  0xA3A8,
    /*  29  )   */  0xA3A9,
    /*  2A  *   */  0xA3AA,
    /*  2B  +   */  0xA3AB,
    /*  2C  '   */  0xA3A7,
    /*  2D  -   */  0xA3AD,
    /*  2E  .   */  0xA3AE,
    /*  2F  /   */  0xA3AF,
    /*  30  0   */  0xA3B0,
    /*  31  1   */  0xA3B1,
    /*  32  2   */  0xA3B2,
    /*  33  3   */  0xA3B3,
    /*  34  4   */  0xA3B4,
    /*  35  5   */  0xA3B5,
    /*  36  6   */  0xA3B6,
    /*  37  7   */  0xA3B7,
    /*  38  8   */  0xA3B8,
    /*  39  9   */  0xA3B9,
    /*  3A  :   */  0xA3BA,
    /*  3B  ;   */  0xA3BB,
    /*  3C  <   */  0xA3BC,
    /*  3D  =   */  0xA3BD,
    /*  3E  >   */  0xA3BE,
    /*  3F  ?   */  0xA3BF,
    /*  40  @   */  0xA3C0,
    /*  41  A   */  0xA4B1,
    /*  42  B   */  0xA4D0,
    /*  43  C   */  0xA4BA,
    /*  44  D   */  0xA4B7,
    /*  45  E   */  0xA4A8,
    /*  46  F   */  0xA4A9,
    /*  47  G   */  0xA4BE,
    /*  48  H   */  0xA4C7,
    /*  49  I   */  0xA4C1,
    /*  4A  J   */  0xA4C3,
    /*  4B  K   */  0xA4BF,
    /*  4C  L   */  0xA4D3,
    /*  4D  M   */  0xA4D1,
    /*  4E  N   */  0xA4CC,
    /*  4F  O   */  0xA4C2,
    /*  50  P   */  0xA4C6,
    /*  51  Q   */  0xA4B3,
    /*  52  R   */  0xA4A2,
    /*  53  S   */  0xA4A4,
    /*  54  T   */  0xA4B6,
    /*  55  U   */  0xA4C5,
    /*  56  V   */  0xA4BD,
    /*  57  W   */  0xA4B9,
    /*  58  X   */  0xA4BC,
    /*  59  Y   */  0xA4CB,
    /*  5A  Z   */  0xA4BB,
    /*  5B  [   */  0xA3DB,
    /*  5C  \   */  0xA1AC,
    /*  5D  ]   */  0xA3DD,
    /*  5E  ^   */  0xA3DE,
    /*  5F  _   */  0xA3DF,
    /*  60  `   */  0xA1A2,     /* A1AE ? AiA2 */
    /*  61  a   */  0xA4B1,
    /*  62  b   */  0xA4D0,
    /*  63  c   */  0xA4BA,
    /*  64  d   */  0xA4B7,
    /*  65  e   */  0xA4A7,
    /*  66  f   */  0xA4A9,
    /*  67  g   */  0xA4BE,
    /*  68  h   */  0xA4C7,
    /*  69  i   */  0xA4C1,
    /*  6A  j   */  0xA4C3,
    /*  6B  k   */  0xA4BF,
    /*  6C  l   */  0xA4D3,
    /*  6D  m   */  0xA4D1,
    /*  6E  n   */  0xA4CC,
    /*  6F  o   */  0xA4C0,
    /*  70  p   */  0xA4C4,
    /*  71  q   */  0xA4B2,
    /*  72  r   */  0xA4A1,
    /*  73  s   */  0xA4A4,
    /*  74  t   */  0xA4B5,
    /*  75  u   */  0xA4C5,
    /*  76  v   */  0xA4BD,
    /*  77  w   */  0xA4B8,
    /*  78  x   */  0xA4BC,
    /*  79  y   */  0xA4CB,
    /*  7A  z   */  0xA4BB,
    /*  7B  {   */  0xA3FB,
    /*  7C  |   */  0xA3FC,
    /*  7D  }   */  0xA3FD,
    /*  7E  ~   */  0xA1AD,
                    0x0000
    },
// For KT390.
    {
    /*  Hex Code    KSC Code */
    /*  20  SP  */  0xA1A1,
    /*  21  !   */  0xA4B8,
    /*  22  "   */  0xA1A8,
    /*  23  #   */  0xA3A3,
    /*  24  $   */  0xA3A4,
    /*  25  %   */  0xA3A5,
    /*  26  &   */  0xA3A6,
    /*  27  `   */  0xA1AE,
    /*  28  (   */  0xA3A8,
    /*  29  )   */  0xA3A9,
    /*  2A  *   */  0xA3AA,
    /*  2B  +   */  0xA3AB,
    /*  2C  '   */  0xA4BC,
    /*  2D  -   */  0xA3AD,
    /*  2E  .   */  0xA3AE,
    /*  2F  /   */  0xA4C7,
    /*  30  0   */  0xA4BB,
    /*  31  1   */  0xA4BE,
    /*  32  2   */  0xA4B6,
    /*  33  3   */  0xA4B2,
    /*  34  4   */  0xA4CB,
    /*  35  5   */  0xA4D0,
    /*  36  6   */  0xA4C1,
    /*  37  7   */  0xA4C6,
    /*  38  8   */  0xA4D2,
    /*  39  9   */  0xA4CC,
    /*  3A  :   */  0xA3BA,
    /*  3B  ;   */  0xA4B2,
    /*  3C  <   */  0xA3B2,
    /*  3D  =   */  0xA3BD,
    /*  3E  >   */  0xA3B3,
    /*  3F  ?   */  0xA3BF,
    /*  40  @   */  0xA3C0,
    /*  41  A   */  0xA4A7,
    /*  42  B   */  0xA3A1,
    /*  43  C   */  0xA4AB,
    /*  44  D   */  0xA4AA,
    /*  45  E   */  0xA4BB,
    /*  46  F   */  0xA4A2,
    /*  47  G   */  0xA3AF,
    /*  48  H   */  0xA1AF,
    /*  49  I   */  0xA3B8,
    /*  4A  J   */  0xA3B4,
    /*  4B  K   */  0xA3B5,
    /*  4C  L   */  0xA3B6,
    /*  4D  M   */  0xA3B1,
    /*  4E  N   */  0xA3B0,
    /*  4F  O   */  0xA3B9,
    /*  50  P   */  0xA3BE,
    /*  51  Q   */  0xA4BD,
    /*  52  R   */  0xA4C2,
    /*  53  S   */  0xA4A6,
    /*  54  T   */  0xA4C3,
    /*  55  U   */  0xA3B7,
    /*  56  V   */  0xA4B0,
    /*  57  W   */  0xA4BC,
    /*  58  X   */  0xA4B4,
    /*  59  Y   */  0xA3BC,
    /*  5A  Z   */  0xA4BA,
    /*  5B  [   */  0xA3DB,
    /*  5C  \   */  0xA3DC,
    /*  5D  ]   */  0xA3DD,
    /*  5E  ^   */  0xA3DE,
    /*  5F  _   */  0xA3DF,
    /*  60  `   */  0xA1AE,
    /*  61  a   */  0xA4B7,
    /*  62  b   */  0xA4CC,
    /*  63  c   */  0xA4C4,
    /*  64  d   */  0xA4D3,
    /*  65  e   */  0xA4C5,
    /*  66  f   */  0xA4BF,
    /*  67  g   */  0xA4D1,
    /*  68  h   */  0xA4A4,
    /*  69  i   */  0xA4B1,
    /*  6A  j   */  0xA4B7,
    /*  6B  k   */  0xA4A1,
    /*  6C  l   */  0xA4B8,
    /*  6D  m   */  0xA4BE,
    /*  6E  n   */  0xA4B5,
    /*  6F  o   */  0xA4BA,
    /*  70  p   */  0xA4BD,
    /*  71  q   */  0xA4B5,
    /*  72  r   */  0xA4C0,
    /*  73  s   */  0xA4A4,
    /*  74  t   */  0xA4C3,
    /*  75  u   */  0xA4A7,
    /*  76  v   */  0xA4C7,
    /*  77  w   */  0xA4A9,
    /*  78  x   */  0xA4A1,
    /*  79  y   */  0xA4A9,
    /*  7A  z   */  0xA4B1,
    /*  7B  {   */  0xA3FB,
    /*  7C  |   */  0xA3FC,
    /*  7D  }   */  0xA3FD,
    /*  7E  ~   */  0xA1AD,
                    0x0000
    },
// For 3 Beolsik Final.
    {
    /*  Hex Code    KSC Code */
    /*  20  SP  */  0xA1A1,
    /*  21  !   */  0xA4A2,
    /*  22  "   */  0xA3AE,
    /*  23  #   */  0xA4B8,
    /*  24  $   */  0xA4AF,
    /*  25  %   */  0xA4AE,
    /*  26  &   */  0xA1B0,
    /*  27  `   */  0xA3AA,
    /*  28  (   */  0xA1A2,
    /*  29  )   */  0xA1AD,
    /*  2A  *   */  0xA1B1,
    /*  2B  +   */  0xA3AB,
    /*  2C  '   */  0xA4BC,
    /*  2D  -   */  0xA3A9,
    /*  2E  .   */  0xA3AE,
    /*  2F  /   */  0xA4C7,
    /*  30  0   */  0xA4BB,
    /*  31  1   */  0xA4BE,
    /*  32  2   */  0xA4B6,
    /*  33  3   */  0xA4B2,
    /*  34  4   */  0xA4CB,
    /*  35  5   */  0xA4D0,
    /*  36  6   */  0xA4C1,
    /*  37  7   */  0xA4C6,
    /*  38  8   */  0xA4D2,
    /*  39  9   */  0xA4CC,  //0x0000
    /*  3A  :   */  0xA3B4,
    /*  3B  ;   */  0xA4B2,
    /*  3C  <   */  0xA3A7,
    /*  3D  =   */  0xA1B5,
    /*  3E  >   */  0xA3AE,
    /*  3F  ?   */  0xA3A1,
    /*  40  @   */  0xA4AA,
    /*  41  A   */  0xA4A7,
    /*  42  B   */  0xA3BF,
    /*  43  C   */  0xA4BC,
    /*  44  D   */  0xA4AC,
    /*  45  E   */  0xA4A5,
    /*  46  F   */  0xA4AB,
    /*  47  G   */  0xA4C2,
    /*  48  H   */  0xA3B0,
    /*  49  I   */  0xA3B7,
    /*  4A  J   */  0xA3B1,
    /*  4B  K   */  0xA3B2,
    /*  4C  L   */  0xA3B3,
    /*  4D  M   */  0xA1A8,
    /*  4E  N   */  0xA3AD,
    /*  4F  O   */  0xA3B8,
    /*  50  P   */  0xA3B9,
    /*  51  Q   */  0xA4BD,
    /*  52  R   */  0xA4B0,
    /*  53  S   */  0xA4A6,
    /*  54  T   */  0xA4AD,
    /*  55  U   */  0xA3B6,
    /*  56  V   */  0xA4A3,
    /*  57  W   */  0xA4BC,
    /*  58  X   */  0xA4B4,
    /*  59  Y   */  0xA3B5,
    /*  5A  Z   */  0xA4BA,
    /*  5B  [   */  0xA3A8,
    /*  5C  \   */  0xA3BA,
    /*  5D  ]   */  0xA1B4,
    /*  5E  ^   */  0xA3BD,
    /*  5F  _   */  0xA3BB,
    /*  60  `   */  0xA3AA,
    /*  61  a   */  0xA4B7,
    /*  62  b   */  0xA4CC,
    /*  63  c   */  0xA4C4,
    /*  64  d   */  0xA4D3,
    /*  65  e   */  0xA4C5,
    /*  66  f   */  0xA4BF,
    /*  67  g   */  0xA4D1,
    /*  68  h   */  0xA4A4,
    /*  69  i   */  0xA4B1,
    /*  6A  j   */  0xA4B7,
    /*  6B  k   */  0xA4A1,
    /*  6C  l   */  0xA4B8,
    /*  6D  m   */  0xA4BE,
    /*  6E  n   */  0xA4B5,
    /*  6F  o   */  0xA4BA,
    /*  70  p   */  0xA4BD,
    /*  71  q   */  0xA4B5,
    /*  72  r   */  0xA4C0,
    /*  73  s   */  0xA4A4,
    /*  74  t   */  0xA4C3,
    /*  75  u   */  0xA4A7,
    /*  76  v   */  0xA4C7,
    /*  77  w   */  0xA4A9,
    /*  78  x   */  0xA4A1,
    /*  79  y   */  0xA4B1,
    /*  7A  z   */  0xA4B1,
    /*  7B  {   */  0xA3A5,
    /*  7C  |   */  0xA3CC,
    /*  7D  }   */  0xA3AF,
    /*  7E  ~   */  0xA1AD,
                    0x0000
    }
};

CONST WORD  wKSCompCode[51] =   // from 'GiYuk' to 'Yi'.
{
    0x8841,0x8C41,0x8444,0x9041,0x8446,0x8447,0x9441,0x9841,0x9C41,0x844A,
    0x844B,0x844C,0x844D,0x844E,0x844F,0x8450,0xA041,0xA441,0xA841,0x8454,
    0xAC41,0xB041,0xB441,0xB841,0xBC41,0xC041,0xC441,0xC841,0xCC41,0xD041,
    0x8461,0x8481,0x84A1,0x84C1,0x84E1,0x8541,0x8561,0x8581,0x85A1,0x85C1,
    0x85E1,0x8641,0x8661,0x8681,0x86A1,0x86C1,0x86E1,0x8741,0x8761,0x8781,
    0x87A1
};

CONST WORD  wKSCompCode2[30] =   // from 'GiYuk' to 'HiEut'.
{
    0x8442,0x8443,0x8444,0x8445,0x8446,0x8447,0x8448,0x9841,0x8449,0x844A,
    0x844B,0x844C,0x844D,0x844E,0x844F,0x8450,0x8451,0x8453,0xA841,0x8454,
    0x8455,0x8456,0x8457,0x8458,0xBC41,0x8459,0x845A,0x845B,0x845C,0x845D
};


WORD
JunjaToBanja(
    LPSTR lpSrc,
    LPSTR lpDest
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WANSUNG wsCode;
    WORD    wCount = 0;

    while (*lpSrc)
    {
        if ((BYTE)(*lpSrc) < (BYTE)0x80)
        {
            *lpDest++ = *lpSrc++;
            wCount++;
        }
        else
        {
            wsCode.e.high = *lpSrc++;
            wsCode.e.low = *lpSrc++;
            if (wsCode.w == 0xA1A1)
            {
                *lpDest++ = ' ';
                wCount++;
            }
            else if (wsCode.w >= 0xA3A1 && wsCode.w <= 0xA3FE)
            {
                *lpDest++ = wsCode.e.low - (BYTE)0x80;
                wCount++;
            }
            else
            {
                *lpDest++ = wsCode.e.high;
                *lpDest++ = wsCode.e.low;
                wCount += 2;
            }
        }
    }
    *lpDest = '\0';
    return (wCount);
}

WORD
BanjaToJunja(
    LPSTR lpSrc,
    LPSTR lpDest
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WORD    wCount = 0;

    while (*lpSrc)
    {
        if ((BYTE)(*lpSrc) < (BYTE)0x80)
        {
            if (*lpSrc++ == ' ')
            {
                *lpDest++ = (BYTE)0xA1;
                *lpDest++ = (BYTE)0xA1;
                wCount += 2;
            }
            else
            {
                *lpDest++ = (BYTE)0xA3;
                *lpDest++ = *(lpSrc - 1) + (BYTE)0x80;
                wCount += 2;
            }
        }
        else
        {
            *lpDest++ = *lpSrc++;
            *lpDest++ = *lpSrc++;
            wCount += 2;
        }
    }
    *lpDest = '\0';
    return (wCount);
}

WORD
JohabToKs(
    LPSTR lpSrc,
    LPSTR lpDest
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WORD    wCount = 0;
#if defined(OLD_CONV)
    WANSUNG wsSCode, wsDCode;
    int     iHead = 0, iTail = 2349, iMid;
    BYTE    bCount;
#endif

    while (*lpSrc)
    {
        if ((BYTE)(*lpSrc) < (BYTE)0x80)
        {
            *lpDest++ = *lpSrc++;
            wCount++;
        }
        else
#if defined(OLD_CONV)
        {
            wsSCode.e.high = *lpSrc++;
            wsSCode.e.low = *lpSrc++;
            for (bCount = 0; bCount < 51 && wKSCompCode[bCount] != wsSCode.w; bCount++)
                ;
            wsDCode.w = (bCount == 51)? 0: bCount + 0xA4A1;
            if (wsDCode.w)
            {
                *lpDest++ = wsDCode.e.high;
                *lpDest++ = wsDCode.e.low;
                wCount += 2;
                continue;
            }
            for (bCount = 0; bCount < 30 && wKSCompCode2[bCount] != wsSCode.w; bCount++)
                ;
            wsDCode.w = (bCount == 30)? 0: bCount + 0xA4A1;
            if (wsDCode.w)
            {
                *lpDest++ = wsDCode.e.high;
                *lpDest++ = wsDCode.e.low;
                wCount += 2;
                continue;
            }
            while (iHead <= iTail && !wsDCode.w)
            {
                iMid = (iHead + iTail) / 2;
                if (wKSCharCode[iMid] > wsSCode.w)
                    iTail = iMid - 1;
                else if (wKSCharCode[iMid] < wsSCode.w)
                    iHead = iMid + 1;
                else
                    wsDCode.w = ((iMid / 94 + 0xB0) << 8) | (iMid % 94 + 0xA1);
            }
            if (wsDCode.w)
            {
                *lpDest++ = wsDCode.e.high;
                *lpDest++ = wsDCode.e.low;
                wCount += 2;
            }
            else
            {
                *lpDest++ = wsSCode.e.high;
                *lpDest++ = wsSCode.e.low;
                wCount += 2;
            }
        }
#else
        {
                // for simple implementation, converting one character by character
                // we have to change it string to string conversion.
                WCHAR wUni;
                CHAR  chTmp[2];

                chTmp[0] = *lpSrc++;
                chTmp[1] = *lpSrc++;

                MultiByteToWideChar(JOHAB_CP, MB_PRECOMPOSED, chTmp, TWO_BYTE, &wUni, ONE_WORD);

                WideCharToMultiByte(WANSUNG_CP, 0, &wUni, ONE_WORD, chTmp, TWO_BYTE, NULL, NULL);

                *lpDest++ = chTmp[0];
                *lpDest++ = chTmp[1];

                wCount += 2;
        }
#endif
    }
    *lpDest = '\0';
    return (wCount);
}

WORD
KsToJohab(
    LPSTR lpSrc,
    LPSTR lpDest
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
#if defined(OLD_CONV)
    WANSUNG wsSCode, wsDCode;
    WORD    wCount = 0, wLoc;
#else
    WORD    wCount = 0;
#endif

    while (*lpSrc)
    {
        if ((BYTE)(*lpSrc) < (BYTE)0x80)
        {
            *lpDest++ = *lpSrc++;
            wCount++;
        }
        else
#if defined(OLD_CONV)
        {
            wsSCode.e.high = *lpSrc++;
            wsSCode.e.low = *lpSrc++;
            if (wsSCode.w >= (WORD)0xA4A1 && wsSCode.w <= (WORD)0xA4D3)
            {
                wsDCode.w = wKSCompCode[wsSCode.w - 0xA4A1];
                *lpDest++ = wsDCode.e.high;
                *lpDest++ = wsDCode.e.low;
            }
            else if (wsSCode.w >= (WORD)0xB0A1 && wsSCode.w <= (WORD)0xC8FE
                    && wsSCode.e.low != (BYTE)0xFF)
            {
                wLoc = (wsSCode.e.high - 176) * 94;
                wLoc += wsSCode.e.low  - 161;
                wsDCode.w = wKSCharCode[wLoc];
                *lpDest++ = wsDCode.e.high;
                *lpDest++ = wsDCode.e.low;
            }
            else
            {
                *lpDest++ = wsSCode.e.high;
                *lpDest++ = wsSCode.e.low;
            }
            wCount += 2;
        }
#else
        {
            WCHAR wUni;
            CHAR  chTmp[2];

            chTmp[0] = *lpSrc++;
            chTmp[1] = *lpSrc++;

            MultiByteToWideChar(WANSUNG_CP, MB_PRECOMPOSED, chTmp, TWO_BYTE, &wUni, ONE_WORD);

            WideCharToMultiByte(JOHAB_CP, 0, &wUni, ONE_WORD, chTmp, TWO_BYTE, NULL, NULL);

            *lpDest++ = chTmp[0];
            *lpDest++ = chTmp[1];

            wCount += 2;
        }
#endif
    }
    *lpDest = '\0';
    return (wCount);
}

LRESULT
TransCodeConvert(
    HIMC hIMC,
    LPIMESTRUCT lpIme
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    UNREFERENCED_PARAMETER(hIMC);

    switch (lpIme->wParam)
    {
        case IME_JUNJAtoBANJA:
            lpIme->wCount = JunjaToBanja(lpSource(lpIme), lpDest(lpIme));
            break;

        case IME_BANJAtoJUNJA:
            lpIme->wCount = BanjaToJunja(lpSource(lpIme), lpDest(lpIme));
            break;

        case IME_JOHABtoKS:
            lpIme->wCount = JohabToKs(lpSource(lpIme), lpDest(lpIme));
            break;

        case IME_KStoJOHAB:
            lpIme->wCount = KsToJohab(lpSource(lpIme), lpDest(lpIme));
            break;

        default:
            lpIme->wCount = 0;
    }
    return (lpIme->wCount);
}

LRESULT TransConvertList( HIMC hImc, LPIMESTRUCT lpIme)
{
    LPSTR           lpSrc;
    LPSTR           lpDst;
    HGLOBAL         hCandList;
    LPCANDIDATELIST lpCandList;
    LPSTR           lpCandStr;
    UINT            i, uBufLen;
    LRESULT         lRet = 0;

    lpSrc = lpSource(lpIme);
    lpDst = lpDest(lpIme);
    uBufLen = ImmGetConversionListA(GetKeyboardLayout(0), hImc, (LPCSTR)lpSrc,
            NULL, 0, GCL_CONVERSION);
    if (uBufLen)
    {
        hCandList = GlobalAlloc(GHND, uBufLen);
        lpCandList = (LPCANDIDATELIST)GlobalLock(hCandList);
        if (lpCandList == NULL) {
            return 0;
        }
        lRet = ImmGetConversionListA(GetKeyboardLayout(0), hImc, (LPCSTR)lpSrc,
                lpCandList, uBufLen, GCL_CONVERSION);
        for (i = 0; i < lpCandList->dwCount; i++)
        {
            lpCandStr = (LPSTR)lpCandList + lpCandList->dwOffset[i];
            *lpDst++ = *lpCandStr++;
            *lpDst++ = *lpCandStr++;
        }
        *lpDst = '\0';
        lpIme->wCount = (WORD)lpCandList->dwCount * 2;
        GlobalUnlock(hCandList);
        GlobalFree(hCandList);
    }
    return (lRet);
}

LRESULT TransGetMNTable( HIMC hImc, LPIMESTRUCT lpIme)
{
    LPSTR   lpMnemonic;
    int     iCount, iCIM;

    UNREFERENCED_PARAMETER(hImc);

    lpMnemonic = (LPSTR)(lpIme->lParam1);
    // Better place would be Registry instead of WIN.INI,
    // but leave it for now.
    iCIM = GetProfileInt(L"WANSUNG", L"InputMethod", IDD_2BEOL) - IDD_2BEOL;
    for (iCount = 0; iCount < 96; iCount++, lpMnemonic += 2)
        {
        *lpMnemonic = LOBYTE(HMNTable[iCIM][iCount]);
        *(lpMnemonic+1) = HIBYTE(HMNTable[iCIM][iCount]);
        }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\jtranmsg.c ===
/**************************************************************************\
* Module Name: jtranmsg.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the code for the Japanese translation subroutine.
*
* History:
* 15-Aug-1995 kazum
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop


UINT
JTransCompositionA(
    LPINPUTCONTEXT lpIMC,
    LPCOMPOSITIONSTRING lpCompStrA,
    PTRANSMSG      pTransMsgSrc,
    PTRANSMSG      pTransMsgDest
    );

UINT
JTransCompositionW(
    LPINPUTCONTEXT lpIMC,
    LPCOMPOSITIONSTRING lpCompStrW,
    PTRANSMSG      pTransMsgSrc,
    PTRANSMSG      pTransMsgDest
    );

DWORD
CompStrWToUndetW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPUNDETERMINESTRUCT lpUndetW
    );

DWORD
CompStrWToUndetA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPUNDETERMINESTRUCT lpUndetA
    );

DWORD
CompStrWToStringExW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPSTRINGEXSTRUCT lpStringExW
    );

DWORD
CompStrWToStringExA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPSTRINGEXSTRUCT lpStringExA
    );

DWORD
CompStrWToStringW(
    LPCOMPOSITIONSTRING lpCompStrW,
    LPWSTR lpStringW
    );

DWORD
CompStrWToStringA(
    LPCOMPOSITIONSTRING lpCompStrW,
    LPSTR lpStringA
    );

VOID
CompStrWToCharW(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrW
    );

VOID
CompStrWToCharA(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrW
    );

DWORD
CompStrAToUndetA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPUNDETERMINESTRUCT lpUndetA,
    DWORD dwUndetABufferSize
    );

DWORD
CompStrAToUndetW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPUNDETERMINESTRUCT lpUndetW,
    DWORD dwUndetWBufferSize
    );

DWORD
CompStrAToStringExA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPSTRINGEXSTRUCT lpStringExA,
    DWORD dwStringExABufferSize
    );

DWORD
CompStrAToStringExW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPSTRINGEXSTRUCT lpStringExW,
    DWORD dwStringExWBufferSize
    );

DWORD
CompStrAToStringA(
    LPCOMPOSITIONSTRING lpCompStrA,
    LPSTR lpStringA,
    DWORD dwStringABufferSize
    );

DWORD
CompStrAToStringW(
    LPCOMPOSITIONSTRING lpCompStrA,
    LPWSTR lpStringW,
    DWORD dwStringWBufferSize
    );

VOID
CompStrAToCharA(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrA
    );

VOID
CompStrAToCharW(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrA
    );


UINT
JTransCompositionA(
    LPINPUTCONTEXT lpIMC,
    LPCOMPOSITIONSTRING lpCompStrA,
    PTRANSMSG      pTransMsgSrc,
    PTRANSMSG      pTransMsgDest
    )
{
    UINT i = 0;
    int iNum = 0;
    DWORD dwSize;
    HWND hWnd;
    WORD wTextLen = 0;
    BOOL fDoneUndet = FALSE;
    BOOL fDoneDet = FALSE;
    DWORD dwGCS;
    BOOL bAnsiWnd;

    hWnd = (HWND)lpIMC->hWnd;

    if (!IsWindow(hWnd))
        return 0;

    bAnsiWnd = (! IsWindowUnicode(hWnd)) ? TRUE : FALSE;

    dwGCS = (DWORD)pTransMsgSrc->lParam;

    if (lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN)
    {
        if (bAnsiWnd) {
            dwSize = CompStrAToUndetA(dwGCS, lpCompStrA, NULL, 0);
            if (dwSize != 0) {
                HGLOBAL hUndetA = NULL;
                LPUNDETERMINESTRUCT lpUndetA;

                if (hUndetA = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpUndetA = (LPUNDETERMINESTRUCT)GlobalLock(hUndetA)) {
                        if (CompStrAToUndetA(dwGCS, lpCompStrA, lpUndetA, dwSize)) {
                            fDoneUndet = TRUE;
                            GlobalUnlock(hUndetA);

                            if (SendMessageA(hWnd,WM_IME_REPORT,IR_UNDETERMINE, (LPARAM)hUndetA)) {
                                GlobalFree(hUndetA);
                                return 0;
                            }
                        }
                        else
                            GlobalUnlock(hUndetA);
                    }
                    GlobalFree(hUndetA);
                }
            }
        }
        else {
            dwSize = CompStrAToUndetW(dwGCS, lpCompStrA, NULL, 0);
            if (dwSize != 0) {
                HGLOBAL hUndetW = NULL;
                LPUNDETERMINESTRUCT lpUndetW;

                if (hUndetW = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpUndetW = (LPUNDETERMINESTRUCT)GlobalLock(hUndetW)) {
                        if (CompStrAToUndetW(dwGCS, lpCompStrA, lpUndetW, dwSize)) {
                            fDoneUndet = TRUE;
                            GlobalUnlock(hUndetW);

                            if (SendMessageW(hWnd,WM_IME_REPORT,IR_UNDETERMINE, (LPARAM)hUndetW)) {
                                GlobalFree(hUndetW);
                                return 0;
                            }
                        }
                        else
                            GlobalUnlock(hUndetW);
                    }
                    GlobalFree(hUndetW);
                }
            }
        }
    }

    //
    // This is generate result string routine.
    // This should be same as WINNLSSendString of WIN3.1.
    //

    if (dwGCS & GCS_RESULTSTR)
    {
        //
        // Can we generate IR_STRINGEX ?
        //

        if (dwGCS & GCS_RESULTREADSTR)
        {
            if (bAnsiWnd) {
                dwSize = CompStrAToStringExA(dwGCS, lpCompStrA, NULL, 0);
                if (dwSize != 0) {
                    HGLOBAL hStringExA = NULL;
                    LPSTRINGEXSTRUCT lpStringExA;

                    if (hStringExA = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                        if (lpStringExA = (LPSTRINGEXSTRUCT)GlobalLock(hStringExA)) {
                            if (CompStrAToStringExA(dwGCS, lpCompStrA, lpStringExA, dwSize)) {
                                GlobalUnlock(hStringExA);

                                if (SendMessageA(hWnd,WM_IME_REPORT,IR_STRINGEX, (LPARAM)hStringExA))
                                {
                                    GlobalFree(hStringExA);
                                    fDoneDet = TRUE;
                                    goto jtc_exit_30;
                                }
                            }
                            else
                                GlobalUnlock(hStringExA);
                        }
                        GlobalFree(hStringExA);
                    }
                }
            }
            else {
                dwSize = CompStrAToStringExW(dwGCS, lpCompStrA, NULL, 0);
                if (dwSize != 0) {
                    HGLOBAL hStringExW = NULL;
                    LPSTRINGEXSTRUCT lpStringExW;

                    if (hStringExW = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                        if (lpStringExW = (LPSTRINGEXSTRUCT)GlobalLock(hStringExW)) {
                            if (CompStrAToStringExW(dwGCS, lpCompStrA, lpStringExW, dwSize)) {
                                GlobalUnlock(hStringExW);

                                if (SendMessageW(hWnd,WM_IME_REPORT,IR_STRINGEX, (LPARAM)hStringExW))
                                {
                                    GlobalFree(hStringExW);
                                    fDoneDet = TRUE;
                                    goto jtc_exit_30;
                                }
                            }
                            else
                                GlobalUnlock(hStringExW);
                        }
                        GlobalFree(hStringExW);
                    }
                }
            }
        }

        //
        // generate IR_STRING
        //

        if (bAnsiWnd) {
            dwSize = CompStrAToStringA(lpCompStrA, NULL, 0);
            if (dwSize != 0) {
                HGLOBAL hStringA = NULL;
                LPSTR lpStringA;

                if (hStringA = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpStringA = (LPSTR)GlobalLock(hStringA)) {
                        if (CompStrAToStringA(lpCompStrA, lpStringA, dwSize)) {
                            GlobalUnlock(hStringA);

                            if (SendMessageA(hWnd,WM_IME_REPORT,IR_STRING, (LPARAM)hStringA))
                            {
                                GlobalFree(hStringA);
                                fDoneDet = TRUE;
                                goto jtc_exit_30;
                            }
                        }
                        else
                            GlobalUnlock(hStringA);
                    }
                    GlobalFree(hStringA);
                }
            }
            else {
                return 0;
            }
        }
        else {
            dwSize = CompStrAToStringW(lpCompStrA, NULL, 0);
            if (dwSize != 0) {
                HGLOBAL hStringW = NULL;
                LPWSTR lpStringW;

                if (hStringW = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpStringW = (LPWSTR)GlobalLock(hStringW)) {
                        if (CompStrAToStringW(lpCompStrA, lpStringW, dwSize)) {
                            GlobalUnlock(hStringW);

                            if (SendMessageW(hWnd,WM_IME_REPORT,IR_STRING, (LPARAM)hStringW))
                            {
                                GlobalFree(hStringW);
                                fDoneDet = TRUE;
                                goto jtc_exit_30;
                            }
                        }
                        else
                            GlobalUnlock(hStringW);
                    }
                    GlobalFree(hStringW);
                }
            }
            else {
                return 0;
            }
        }

        //
        // generate IR_DBCSCHAR/IR_STRINGSTART/WM_CHAR/IR_STRINGEND
        //

        if (bAnsiWnd) {
            CompStrAToCharA(hWnd, lpCompStrA);
        }
        else {
            CompStrAToCharW(hWnd, lpCompStrA);
        }

        fDoneDet = TRUE;
    }


    if (!fDoneUndet && !fDoneDet)
    {
        *pTransMsgDest = *pTransMsgSrc;
        iNum++;
    }

jtc_exit_30:

    if (!fDoneUndet && fDoneDet && (dwGCS & GCS_COMPSTR))
    {
        pTransMsgDest->message = pTransMsgSrc->message;
        pTransMsgDest->wParam  = pTransMsgSrc->wParam;
        pTransMsgDest->lParam  = (LPARAM)(dwGCS & ~(GCS_RESULT | GCS_RESULTREAD));
        iNum++;
    }

    return iNum;
}


UINT
JTransCompositionW(
    LPINPUTCONTEXT lpIMC,
    LPCOMPOSITIONSTRING lpCompStrW,
    PTRANSMSG      pTransMsgSrc,
    PTRANSMSG      pTransMsgDest
    )
{
    UINT i = 0;
    int iNum = 0;
    DWORD dwSize;
    HWND hWnd;
    WORD wTextLen = 0;
    BOOL fDoneUndet = FALSE;
    BOOL fDoneDet = FALSE;
    DWORD dwGCS;
    BOOL bAnsiWnd;

    hWnd = (HWND)lpIMC->hWnd;

    if (!IsWindow(hWnd))
        return 0;

    bAnsiWnd = (! IsWindowUnicode(hWnd)) ? TRUE : FALSE;

    dwGCS = (DWORD)pTransMsgSrc->lParam;

    if (lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN)
    {
        if (bAnsiWnd) {
            dwSize = CompStrWToUndetA(dwGCS, lpCompStrW, NULL);
            if (dwSize != 0) {
                HGLOBAL hUndetA = NULL;
                LPUNDETERMINESTRUCT lpUndetA;

                if (hUndetA = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpUndetA = (LPUNDETERMINESTRUCT)GlobalLock(hUndetA)) {
                        CompStrWToUndetA(dwGCS, lpCompStrW, lpUndetA);
                        fDoneUndet = TRUE;
                        GlobalUnlock(hUndetA);

                        if (SendMessageA(hWnd,WM_IME_REPORT,IR_UNDETERMINE, (LPARAM)hUndetA)) {
                            GlobalFree(hUndetA);
                            return 0;
                        }
                    }
                    GlobalFree(hUndetA);
                }
            }
        }
        else {
            dwSize = CompStrWToUndetW(dwGCS, lpCompStrW, NULL);
            if (dwSize != 0) {
                HGLOBAL hUndetW = NULL;
                LPUNDETERMINESTRUCT lpUndetW;

                if (hUndetW = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpUndetW = (LPUNDETERMINESTRUCT)GlobalLock(hUndetW)) {
                        CompStrWToUndetW(dwGCS, lpCompStrW, lpUndetW);
                        fDoneUndet = TRUE;
                        GlobalUnlock(hUndetW);

                        if (SendMessageW(hWnd,WM_IME_REPORT,IR_UNDETERMINE, (LPARAM)hUndetW)) {
                            GlobalFree(hUndetW);
                            return 0;
                        }
                    }
                    GlobalFree(hUndetW);
                }
            }
        }
    }

    //
    // This is generate result string routine.
    // This should be same as WINNLSSendString of WIN3.1.
    //

    if (dwGCS & GCS_RESULTSTR)
    {
        //
        // Can we generate IR_STRINGEX ?
        //

        if (dwGCS & GCS_RESULTREADSTR)
        {
            if (bAnsiWnd) {
                dwSize = CompStrWToStringExA(dwGCS, lpCompStrW, NULL);
                if (dwSize != 0) {
                    HGLOBAL hStringExA = NULL;
                    LPSTRINGEXSTRUCT lpStringExA;

                    if (hStringExA = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                        if (lpStringExA = (LPSTRINGEXSTRUCT)GlobalLock(hStringExA)) {
                            CompStrWToStringExA(dwGCS, lpCompStrW, lpStringExA);
                            GlobalUnlock(hStringExA);

                            if (SendMessageA(hWnd,WM_IME_REPORT,IR_STRINGEX, (LPARAM)hStringExA))
                            {
                                GlobalFree(hStringExA);
                                fDoneDet = TRUE;
                                goto jtc_exit_30;
                            }
                        }
                        GlobalFree(hStringExA);
                    }
                }
            }
            else {
                dwSize = CompStrWToStringExW(dwGCS, lpCompStrW, NULL);
                if (dwSize != 0) {
                    HGLOBAL hStringExW = NULL;
                    LPSTRINGEXSTRUCT lpStringExW;

                    if (hStringExW = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                        if (lpStringExW = (LPSTRINGEXSTRUCT)GlobalLock(hStringExW)) {
                            CompStrWToStringExW(dwGCS, lpCompStrW, lpStringExW);
                            GlobalUnlock(hStringExW);

                            if (SendMessageW(hWnd,WM_IME_REPORT,IR_STRINGEX, (LPARAM)hStringExW))
                            {
                                GlobalFree(hStringExW);
                                fDoneDet = TRUE;
                                goto jtc_exit_30;
                            }
                        }
                        GlobalFree(hStringExW);
                    }
                }
            }
        }

        //
        // generate IR_STRING
        //

        if (bAnsiWnd) {
            dwSize = CompStrWToStringA(lpCompStrW, NULL);
            if (dwSize != 0) {
                HGLOBAL hStringA = NULL;
                LPSTR lpStringA;

                if (hStringA = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpStringA = (LPSTR)GlobalLock(hStringA)) {
                        CompStrWToStringA(lpCompStrW, lpStringA);
                        GlobalUnlock(hStringA);

                        if (SendMessageA(hWnd,WM_IME_REPORT,IR_STRING, (LPARAM)hStringA))
                        {
                            GlobalFree(hStringA);
                            fDoneDet = TRUE;
                            goto jtc_exit_30;
                        }
                    }
                    GlobalFree(hStringA);
                }
            }
            else {
                return 0;
            }
        }
        else {
            dwSize = CompStrWToStringW(lpCompStrW, NULL);
            if (dwSize != 0) {
                HGLOBAL hStringW = NULL;
                LPWSTR lpStringW;

                if (hStringW = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpStringW = (LPWSTR)GlobalLock(hStringW)) {
                        CompStrWToStringW(lpCompStrW, lpStringW);
                        GlobalUnlock(hStringW);

                        if (SendMessageW(hWnd,WM_IME_REPORT,IR_STRING, (LPARAM)hStringW))
                        {
                            GlobalFree(hStringW);
                            fDoneDet = TRUE;
                            goto jtc_exit_30;
                        }
                    }
                    GlobalFree(hStringW);
                }
            }
            else {
                return 0;
            }
        }

        //
        // generate IR_DBCSCHAR/IR_STRINGSTART/WM_CHAR/IR_STRINGEND
        //

        if (bAnsiWnd) {
            CompStrWToCharA(hWnd, lpCompStrW);
        }
        else {
            CompStrWToCharW(hWnd, lpCompStrW);
        }

        fDoneDet = TRUE;
    }


    if (!fDoneUndet && !fDoneDet)
    {
        *pTransMsgDest = *pTransMsgSrc;
        iNum++;
    }

jtc_exit_30:

    if (!fDoneUndet && fDoneDet && (dwGCS & GCS_COMPSTR))
    {
        pTransMsgDest->message = pTransMsgSrc->message;
        pTransMsgDest->wParam  = pTransMsgSrc->wParam;
        pTransMsgDest->lParam  = (LPARAM)(dwGCS & ~(GCS_RESULT | GCS_RESULTREAD));
        iNum++;
    }

    return iNum;
}



UINT
WINNLSTranslateMessageJ(
    UINT                uiNumMsg,
    PTRANSMSG           pTransMsg,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    BOOL bAnsiIMC
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PTRANSMSG       pTransMsgBuf, pTransMsgTemp;
    UINT            uiNewNum = 0;
    UINT            uiTempNum;
    DWORD           dwTempSize;
    HWND            hDefIMEWnd;
    UINT            i;
    BOOL            bAnsiWnd;

    hDefIMEWnd = ImmGetDefaultIMEWnd((HWND)lpIMC->hWnd);

    bAnsiWnd = (! IsWindowUnicode(lpIMC->hWnd)) ? TRUE : FALSE;

    dwTempSize = uiNumMsg * sizeof(TRANSMSG);

    //
    // Allocate one more TRANSMSG and ZEROINIT the whole thing!
    //

    pTransMsgBuf = (PTRANSMSG)ImmLocalAlloc( HEAP_ZERO_MEMORY,
                                             dwTempSize + sizeof(TRANSMSG)
                                           );
    if ( pTransMsgBuf == NULL )
        goto wtmsg2_j_10;

    RtlCopyMemory(pTransMsgBuf, pTransMsg, dwTempSize);
    pTransMsgTemp = pTransMsgBuf;

    //
    // When MCW_HIDDEN mode, WM_IME_ENDCOMPOSITION will be translated to
    // IR_UNDETERMINE with 0 string. So that, this message have to be
    // generated after all messages.
    //

    if (lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN) {

        for (i = 0; i < uiNumMsg; i++, pTransMsgTemp++) {
            if (pTransMsgTemp->message == WM_IME_ENDCOMPOSITION) {
                break;
            }
        }

        if (pTransMsgTemp->message == WM_IME_ENDCOMPOSITION) {

            PTRANSMSG pTransMsgSrc = pTransMsgTemp + 1;

            while (pTransMsgSrc->message != 0) {
                *pTransMsgTemp++ = *pTransMsgSrc++;
            }

            pTransMsgTemp->message = WM_IME_ENDCOMPOSITION;
            pTransMsgTemp->wParam  = 0L;
            pTransMsgTemp->lParam  = 0L;

        }

        pTransMsgTemp = pTransMsgBuf;
    }

    while (pTransMsgTemp->message != 0) {

        switch (pTransMsgTemp->message)
        {
            case WM_IME_COMPOSITION:

                if (bAnsiIMC)
                    uiTempNum = JTransCompositionA(lpIMC,lpCompStr,pTransMsgTemp,pTransMsg);
                else
                    uiTempNum = JTransCompositionW(lpIMC,lpCompStr,pTransMsgTemp,pTransMsg);

                uiNewNum  += uiTempNum;
                pTransMsg += uiTempNum;

                if ( !(lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN) )
                {
                    if ( lpIMC->cfCompForm.dwStyle != CFS_DEFAULT ) {
                        SendMessage((HWND)lpIMC->hWnd, WM_IME_REPORT, IR_CHANGECONVERT, 0L);
                    }
                }

                break;

            case WM_IME_STARTCOMPOSITION:

                if ( !(lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN) )
                {
                    if ( lpIMC->cfCompForm.dwStyle != CFS_DEFAULT ) {
                        SendMessage((HWND)lpIMC->hWnd, WM_IME_REPORT, IR_OPENCONVERT, 0L);
                    }

                    *pTransMsg++ = *pTransMsgTemp;
                    uiNewNum++;
                }

                break;

            case WM_IME_ENDCOMPOSITION:

                if ( !(lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN) )
                {
                    if ( lpIMC->cfCompForm.dwStyle != CFS_DEFAULT ) {
                        SendMessage((HWND)lpIMC->hWnd, WM_IME_REPORT, IR_CLOSECONVERT, 0L);
                    }

                    *pTransMsg++ = *pTransMsgTemp;
                    uiNewNum++;

                }
                else {

                    HWND hWnd = (HWND)lpIMC->hWnd;
                    HGLOBAL hUndet = 0L;

                    if (hUndet = GlobalAlloc(GHND | GMEM_SHARE, sizeof(UNDETERMINESTRUCT)))
                    {
                        if (! IsWindowUnicode(lpIMC->hWnd))
                            SendMessageA(hWnd,WM_IME_REPORT, IR_UNDETERMINE, (LPARAM)hUndet);
                        else
                            SendMessageW(hWnd,WM_IME_REPORT, IR_UNDETERMINE, (LPARAM)hUndet);

                        GlobalFree(hUndet);
                    }
                }

                break;

            case WM_IME_NOTIFY:

                switch (pTransMsgTemp->wParam)
                {
                    case IMN_OPENCANDIDATE:

                        //
                        // When 3.1 Application want to set MCW_HIDDEN,
                        // the candidate window of Chicago IME go way
                        // from the restangle of the composition string
                        // that will be drawn by the application.
                        //

                        if (IsWindow((HWND)lpIMC->hWnd) &&
                            (lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN)) {
                            CANDIDATEFORM cfCandForm;
                            DWORD i;
                            DWORD dwNumCand = 0;

                            for (i = 0; i < 32; i++)
                            {
                                //
                                // Only the opened candidate should be updated.
                                //
                                if (!(pTransMsgTemp->lParam & (01L << i)))
                                    continue;

                                cfCandForm.dwIndex = i;
                                cfCandForm.dwStyle = CFS_EXCLUDE;
                                cfCandForm.ptCurrentPos = lpIMC->cfCompForm.ptCurrentPos;
                                cfCandForm.rcArea       = lpIMC->cfCompForm.rcArea;
                                SendMessage(hDefIMEWnd, WM_IME_CONTROL, IMC_SETCANDIDATEPOS,
                                               (LPARAM)(LPCANDIDATEFORM)&cfCandForm);
                            }
                        }

                        break;

                    default :
                        break;
                }

                if (!(lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN)) {
                    *pTransMsg++ = *pTransMsgTemp;
                    uiNewNum++;
                }
                else {
                    //
                    // For win31 apps who set MCW_HIDDEN, we won't give them
                    // IMN_OPENCANDIDATE here. Instead, send it directly to the
                    // default IME window.
                    //
                    SendMessage( hDefIMEWnd, 
                                 pTransMsgTemp->message,
                                 pTransMsgTemp->wParam,
                                 pTransMsgTemp->lParam
                               );
                }

                break;

            default :
                *pTransMsg++ = *pTransMsgTemp;
                uiNewNum++;
                break;
        }

        pTransMsgTemp++;
    }

    ImmLocalFree(pTransMsgBuf);

wtmsg2_j_10:
    return (uiNewNum);
}


DWORD
CompStrAToUndetA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPUNDETERMINESTRUCT lpUndetA,
    DWORD dwUndetABufferSize
    )

/*++

Routine Description:

    Convert composition string (ANSI) to undetermine string (ANSI).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    UINT  i;

    dwSize = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT)+1)) +
             DWORD_ALIGN(((lpCompStrA->dwResultStrLen+1) * sizeof(CHAR))) +
             DWORD_ALIGN((lpCompStrA->dwResultClauseLen+1)) +
             DWORD_ALIGN(((lpCompStrA->dwResultReadStrLen+1) * sizeof(CHAR))) +
             DWORD_ALIGN((lpCompStrA->dwResultReadClauseLen+1)) +
             DWORD_ALIGN((lpCompStrA->dwCompAttrLen+1)) +
             DWORD_ALIGN(((lpCompStrA->dwCompStrLen+1) * sizeof(CHAR)));

    if (lpUndetA == NULL) {
        return dwSize;
    }

    if (dwSize > dwUndetABufferSize) {
        // lpUndetA buffer is too small.
        return 0;
    }

    // Set actual lpUndetA buffer size in dwSize.
    dwSize = dwUndetABufferSize;

    dwPos = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT) + 1));
    lpUndetA->dwSize = dwSize;

    if (dwGCS & GCS_COMPSTR)
    {
        if (dwSize < dwPos) {
            // lpUndetA buffer is too small.
            return 0;
        }
        if (lpCompStrA->dwCompStrLen * sizeof(CHAR) > dwSize - dwPos) {
            // lpUndetA buffer is too small.
            return 0;
        }

        lpUndetA->uUndetTextLen = lpCompStrA->dwCompStrLen;
        lpUndetA->uUndetTextPos = dwPos;
        memcpy((PBYTE)lpUndetA   + dwPos,
               (PBYTE)lpCompStrA + lpCompStrA->dwCompStrOffset,
               lpCompStrA->dwCompStrLen * sizeof(CHAR)
              );
        *(LPSTR)((PBYTE)lpUndetA + dwPos + lpCompStrA->dwCompStrLen*sizeof(CHAR)) = '\0';
        dwPos += DWORD_ALIGN(((lpUndetA->uUndetTextLen+1)*sizeof(CHAR)));

        // Sometime Chicago IME does not generate GCS_COMPATTR
        // with GCS_COMPSTR. But uUndetAttrPos should be filled
        // when the UndetText is updated.
        if (lpCompStrA->dwCompAttrLen && !(dwGCS & GCS_COMPATTR))
            dwGCS |= GCS_COMPATTR;
    }

    if (dwGCS & GCS_COMPATTR)
    {
        if (dwSize < dwPos) {
            // lpUndetA buffer is too small.
            return 0;
        }
        if (lpCompStrA->dwCompAttrLen > dwSize - dwPos) {
            // lpUndetA buffer is too small.
            return 0;
        }

        lpUndetA->uUndetAttrPos = dwPos;
        memcpy((PBYTE)lpUndetA   + dwPos,
               (PBYTE)lpCompStrA + lpCompStrA->dwCompAttrOffset,
               lpCompStrA->dwCompAttrLen
              );
        dwPos += DWORD_ALIGN((lpUndetA->uUndetTextLen + 1));
    }

    if (dwGCS & GCS_CURSORPOS)
    {
        lpUndetA->uCursorPos = lpCompStrA->dwCursorPos;
    }

    if (dwGCS & GCS_DELTASTART)
    {
        lpUndetA->uDeltaStart = lpCompStrA->dwDeltaStart;
    }

    if (dwGCS & GCS_RESULTSTR)
    {
        if (dwSize < dwPos) {
            // lpUndetA buffer is too small.
            return 0;
        }
        if (lpCompStrA->dwResultStrLen * sizeof(CHAR) > dwSize - dwPos) {
            // lpUndetA buffer is too small.
            return 0;
        }

        lpUndetA->uDetermineTextLen = lpCompStrA->dwResultStrLen;
        lpUndetA->uDetermineTextPos = dwPos;
        memcpy((PBYTE)lpUndetA   + dwPos,
               (PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset,
               lpCompStrA->dwResultStrLen * sizeof(CHAR)
              );
        *(LPSTR)((PBYTE)lpUndetA + dwPos + lpCompStrA->dwResultStrLen*sizeof(CHAR)) = '\0';
        dwPos += DWORD_ALIGN(((lpUndetA->uDetermineTextLen + 1)*sizeof(CHAR)));
    }

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrA->dwResultClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;
        DWORD   dwClauseAPos;

        if (dwSize < dwPos) {
            // lpUndetA buffer is too small.
            return 0;
        }

        dwClauseAPos = dwPos;

        lpUndetA->uDetermineDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpUndetA + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultClauseOffset);
        for (i = 0; i < (lpCompStrA->dwResultClauseLen / sizeof(DWORD)); i++) {
            *lpw++ = *lpdw++;
            dwClauseAPos += sizeof(*lpw);
            if (dwSize < dwClauseAPos) {
                // lpUndetA buffer is too small.
                return 0;
            }
        }

        dwPos += DWORD_ALIGN((lpCompStrA->dwResultClauseLen + 1));
    }

    if (dwGCS & GCS_RESULTREADSTR)
    {
        if (dwSize < dwPos) {
            // lpUndetA buffer is too small.
            return 0;
        }
        if (lpCompStrA->dwResultReadStrLen * sizeof(CHAR) > dwSize - dwPos) {
            // lpUndetA buffer is too small.
            return 0;
        }

        lpUndetA->uYomiTextLen = lpCompStrA->dwResultReadStrLen;
        lpUndetA->uYomiTextPos = dwPos;
        memcpy((PBYTE)lpUndetA   + dwPos,
               (PBYTE)lpCompStrA + lpCompStrA->dwResultReadStrOffset,
               lpCompStrA->dwResultReadStrLen * sizeof(CHAR)
              );
        *(LPSTR)((PBYTE)lpUndetA + dwPos + lpCompStrA->dwResultReadStrLen*sizeof(CHAR)) = '\0';
        dwPos += DWORD_ALIGN(((lpUndetA->uYomiTextLen + 1)*sizeof(CHAR)));
    }

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrA->dwResultReadClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;
        DWORD   dwClauseAPos;

        if (dwSize < dwPos) {
            // lpUndetA buffer is too small.
            return 0;
        }

        dwClauseAPos = dwPos;

        lpUndetA->uYomiDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpUndetA + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadClauseOffset);
        for (i = 0; i < (lpCompStrA->dwResultReadClauseLen / sizeof(DWORD)); i++) {
            *lpw++ = *lpdw++;
            dwClauseAPos += sizeof(*lpw);
            if (dwSize < dwClauseAPos) {
                // lpUndetA buffer is too small.
                return 0;
            }
        }

        dwPos += DWORD_ALIGN((lpCompStrA->dwResultReadClauseLen + 1));
    }

    return dwSize;
}

DWORD
CompStrAToUndetW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPUNDETERMINESTRUCT lpUndetW,
    DWORD dwUndetWBufferSize
    )

/*++

Routine Description:

    Convert composition string (ANSI) to undetermine string (Unicode).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    UINT  i;

    dwSize = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT)+1)) +
             DWORD_ALIGN(((lpCompStrA->dwResultStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN((lpCompStrA->dwResultClauseLen+1)) +
             DWORD_ALIGN(((lpCompStrA->dwResultReadStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN((lpCompStrA->dwResultReadClauseLen+1)) +
             DWORD_ALIGN((lpCompStrA->dwCompAttrLen * 2)) +
             DWORD_ALIGN(((lpCompStrA->dwCompStrLen+1) * sizeof(WCHAR)));

    if (lpUndetW == NULL) {
        return dwSize;
    }

    if (dwSize > dwUndetWBufferSize) {
        // lpUndetW buffer is too small.
        return 0;
    }

    // Set actual lpUndetW buffer size in dwSize.
    dwSize = dwUndetWBufferSize;

    dwPos = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT) + 1));
    lpUndetW->dwSize = dwSize;

    if (dwGCS & GCS_COMPSTR)
    {
        if (dwSize < dwPos) {
            // lpUndetW buffer is too small.
            return 0;
        }

        i = MultiByteToWideChar( CP_ACP,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwCompStrOffset),  // src
                                (INT)lpCompStrA->dwCompStrLen,
                                (LPWSTR)((PBYTE)lpUndetW + dwPos),                         // dest
                                (INT)(dwSize - dwPos)/sizeof(WCHAR));  // Specifies the size, in wide characters.
        if (i >= (dwSize - dwPos)/sizeof(WCHAR)) {
            // lpUndetW buffer doesn't hold NULL character terminator.
            return 0;
        }

        ((LPWSTR)((PBYTE)lpUndetW + dwPos))[i] = L'\0';
        lpUndetW->uUndetTextLen = i;
        lpUndetW->uUndetTextPos = dwPos;
        dwPos += DWORD_ALIGN(((lpUndetW->uUndetTextLen + 1)*sizeof(WCHAR)));

        // Sometime Chicago IME does not generate GCS_COMPATTR
        // with GCS_COMPSTR. But uUndetAttrPos should be filled
        // when the UndetText is updated.
        if (lpCompStrA->dwCompAttrLen && !(dwGCS & GCS_COMPATTR))
            dwGCS |= GCS_COMPATTR;
    }

    if (dwGCS & GCS_COMPATTR)
    {
        if (lpUndetW->uUndetTextLen != 0) {
            LPWSTR lpwszUndetText;
            PBYTE  lpAttrW;
            PBYTE  lpAttrA;
            WCHAR  wc;
            ULONG  MultiByteSize;
            DWORD  dwAttrWPos;

            if (dwSize < dwPos) {
                // lpUndetW buffer is too small.
                return 0;
            }

            dwAttrWPos = dwPos;

            lpwszUndetText = (LPWSTR)((PBYTE)lpUndetW + lpUndetW->uUndetTextPos);
            lpAttrA = (PBYTE)lpCompStrA + lpCompStrA->dwCompAttrOffset;
            lpAttrW = (PBYTE)lpUndetW   + dwPos;

            while (wc=*lpwszUndetText++) {
                RtlUnicodeToMultiByteSize(&MultiByteSize, &wc, sizeof(WCHAR));
                if (MultiByteSize == 2) {
                    *lpAttrW++ = *lpAttrA;
                    lpAttrA += 2;
                }
                else {
                    *lpAttrW++ = *lpAttrA++;
                }

                dwAttrWPos += sizeof(*lpAttrW);
                if (dwSize < dwAttrWPos) {
                    // lpUndetW buffer is too small.
                    return 0;
                }
            }

            lpUndetW->uUndetAttrPos = dwPos;
            dwPos += DWORD_ALIGN((lpUndetW->uUndetTextLen + 1));
        }
    }

    if (dwGCS & GCS_CURSORPOS)
    {
        if (lpCompStrA->dwCursorPos != -1) {
            lpUndetW->uCursorPos = CalcCharacterPositionAtoW(lpCompStrA->dwCursorPos,
                                                             (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwCompStrOffset),
                                                             CP_ACP
                                                            );
        }
        else {
            lpUndetW->uCursorPos = lpCompStrA->dwCursorPos;
        }
    }

    if (dwGCS & GCS_DELTASTART)
    {
        if (lpCompStrA->dwDeltaStart != -1) {
            lpUndetW->uDeltaStart = CalcCharacterPositionAtoW(lpCompStrA->dwDeltaStart,
                                                              (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwCompStrOffset),
                                                              CP_ACP
                                                             );
        }
        else {
            lpUndetW->uDeltaStart = lpCompStrA->dwDeltaStart;
        }
    }

    if (dwGCS & GCS_RESULTSTR)
    {
        if (dwSize < dwPos) {
            // lpUndetW buffer is too small.
            return 0;
        }

        i = MultiByteToWideChar( CP_ACP,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset),  // src
                                (INT)lpCompStrA->dwResultStrLen,
                                (LPWSTR)((PBYTE)lpUndetW + dwPos),                           // dest
                                (INT)(dwSize - dwPos)/sizeof(WCHAR));  // Specifies the size, in wide characters.
        if (i >= (dwSize - dwPos)/sizeof(WCHAR)) {
            // lpUndetW buffer doesn't hold NULL character terminator.
            return 0;
        }

        ((LPWSTR)((PBYTE)lpUndetW + dwPos))[i] = L'\0';
        lpUndetW->uDetermineTextLen = i;
        lpUndetW->uDetermineTextPos = dwPos;
        dwPos += DWORD_ALIGN(((lpUndetW->uDetermineTextLen + 1)*sizeof(WCHAR)));
    }

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrA->dwResultClauseLen > 0) )
    {
        if (lpUndetW->uDetermineTextLen != 0) {
            LPDWORD lpw;
            LPDWORD lpdw;
            DWORD   dwClauseWPos;

            if (dwSize < dwPos) {
                // lpUndetW buffer is too small.
                return 0;
            }

            dwClauseWPos = dwPos;

            lpw  = (LPDWORD)((PBYTE)lpUndetW + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultClauseOffset);

            for (i = 0; i < (lpCompStrA->dwResultClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionAtoW(*lpdw++,
                                                   (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset),
                                                   CP_ACP
                                                  );

                dwClauseWPos += sizeof(*lpw);
                if (dwSize < dwClauseWPos) {
                    // lpUndetW buffer is too small.
                    return 0;
                }
            }

            lpUndetW->uDetermineDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrA->dwResultClauseLen + 1));
        }
    }

    if (dwGCS & GCS_RESULTREADSTR)
    {
        if (dwSize < dwPos) {
            // lpUndetW buffer is too small.
            return 0;
        }

        i = MultiByteToWideChar( CP_ACP,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadStrOffset),  // src
                                (INT)lpCompStrA->dwResultReadStrLen,
                                (LPWSTR)((PBYTE)lpUndetW + dwPos),                               // dest
                                (INT)(dwSize - dwPos)/sizeof(WCHAR));  // Specifies the size, in wide characters.
        if (i >= (dwSize - dwPos)/sizeof(WCHAR)) {
            // lpUndetW buffer doesn't hold NULL character terminator.
            return 0;
        }

        ((LPWSTR)((PBYTE)lpUndetW + dwPos))[i] = L'\0';
        lpUndetW->uYomiTextLen = i;
        lpUndetW->uYomiTextPos = dwPos;
        dwPos += DWORD_ALIGN(((lpUndetW->uYomiTextLen + 1)*sizeof(WCHAR)));
    }

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrA->dwResultReadClauseLen > 0) )
    {
        if (lpUndetW->uYomiTextLen != 0) {
            LPDWORD lpw;
            LPDWORD lpdw;
            DWORD   dwClauseWPos;

            if (dwSize < dwPos) {
                // lpUndetW buffer is too small.
                return 0;
            }

            dwClauseWPos = dwPos;

            lpw  = (LPDWORD)((PBYTE)lpUndetW + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadClauseOffset);

            for (i = 0; i < (lpCompStrA->dwResultReadClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionAtoW(*lpdw++,
                                                   (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadStrOffset),
                                                   CP_ACP
                                                  );

                dwClauseWPos += sizeof(*lpw);
                if (dwSize < dwClauseWPos) {
                    // lpUndetW buffer is too small.
                    return 0;
                }
            }

            lpUndetW->uYomiDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrA->dwResultReadClauseLen + 1));
        }
    }

    return dwSize;
}


DWORD
CompStrAToStringExA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPSTRINGEXSTRUCT lpStringExA,
    DWORD dwStringExABufferSize
    )

/*++

Routine Description:

    Convert composition string (ANSI) to StringEx (ANSI).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    UINT  i;

    dwSize = DWORD_ALIGN((sizeof(STRINGEXSTRUCT)+1)) +
             DWORD_ALIGN(((lpCompStrA->dwResultStrLen+1) * sizeof(CHAR))) +
             DWORD_ALIGN(lpCompStrA->dwResultClauseLen+1) +
             DWORD_ALIGN(((lpCompStrA->dwResultReadStrLen+1) * sizeof(CHAR))) +
             DWORD_ALIGN(lpCompStrA->dwResultReadClauseLen+1);

    if (lpStringExA == NULL) {
        return dwSize;
    }

    if (dwSize > dwStringExABufferSize) {
        // lpStringExA buffer is too small.
        return 0;
    }

    // Set actual lpStringExA buffer size in dwSize.
    dwSize = dwStringExABufferSize;

    dwPos = DWORD_ALIGN(sizeof(STRINGEXSTRUCT) + 1);
    lpStringExA->dwSize = dwSize;

    if (dwSize < dwPos) {
        // lpStringExA buffer is too small.
        return 0;
    }
    if (lpCompStrA->dwResultStrLen * sizeof(CHAR) > dwSize - dwPos) {
        // lpStringExA buffer is too small.
        return 0;
    }

    lpStringExA->uDeterminePos = dwPos;
    memcpy((PBYTE)lpStringExA + dwPos,
           (PBYTE)lpCompStrA  + lpCompStrA->dwResultStrOffset,
           lpCompStrA->dwResultStrLen * sizeof(CHAR)
          );
    *(LPSTR)((PBYTE)lpStringExA + dwPos + lpCompStrA->dwResultStrLen*sizeof(CHAR)) = '\0';
    dwPos += DWORD_ALIGN(((lpCompStrA->dwResultStrLen + 1)*sizeof(CHAR)));

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrA->dwResultClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;
        DWORD   dwClauseAPos;

        if (dwSize < dwPos) {
            // lpStringExA buffer is too small.
            return 0;
        }

        dwClauseAPos = dwPos;

        lpStringExA->uDetermineDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpStringExA + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultClauseOffset);
        for (i = 0; i < (lpCompStrA->dwResultClauseLen / sizeof(DWORD)); i++) {
            *lpw++ = *lpdw++;
            dwClauseAPos += sizeof(*lpw);
            if (dwSize < dwClauseAPos) {
                // lpStringExA buffer is too small.
                return 0;
            }
        }

        dwPos += DWORD_ALIGN((lpCompStrA->dwResultClauseLen + 1));
    }

    if (dwSize < dwPos) {
        // lpStringExA buffer is too small.
        return 0;
    }
    if (lpCompStrA->dwResultReadStrLen * sizeof(CHAR) > dwSize - dwPos) {
        // lpStringExA buffer is too small.
        return 0;
    }

    lpStringExA->uYomiPos = dwPos;
    memcpy((PBYTE)lpStringExA + dwPos,
           (PBYTE)lpCompStrA  + lpCompStrA->dwResultReadStrOffset,
           lpCompStrA->dwResultReadStrLen * sizeof(CHAR)
          );
    *(LPSTR)((PBYTE)lpStringExA + dwPos + lpCompStrA->dwResultReadStrLen*sizeof(CHAR)) = '\0';
    dwPos += DWORD_ALIGN(((lpCompStrA->dwResultReadStrLen + 1)*sizeof(CHAR)));

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrA->dwResultReadClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;
        DWORD   dwClauseAPos;

        if (dwSize < dwPos) {
            // lpStringExA buffer is too small.
            return 0;
        }

        dwClauseAPos = dwPos;

        lpStringExA->uYomiDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpStringExA + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadClauseOffset);
        for (i = 0; i < (lpCompStrA->dwResultReadClauseLen / sizeof(DWORD)); i++) {
            *lpw++ = *lpdw++;
            dwClauseAPos += sizeof(*lpw);
            if (dwSize < dwClauseAPos) {
                // lpStringExA buffer is too small.
                return 0;
            }
        }
    }

    return dwSize;
}

DWORD
CompStrAToStringExW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPSTRINGEXSTRUCT lpStringExW,
    DWORD dwStringExWBufferSize
    )

/*++

Routine Description:

    Convert composition string (ANSI) to StringEx (Unicode).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    DWORD dwLen;
    UINT  i;

    dwSize = DWORD_ALIGN((sizeof(STRINGEXSTRUCT)+1)) +
             (lpCompStrA->dwResultStrLen > 0 ? DWORD_ALIGN(((lpCompStrA->dwResultStrLen+1) * sizeof(WCHAR))) : 0) +
             (lpCompStrA->dwResultClauseLen > 0 ? DWORD_ALIGN(lpCompStrA->dwResultClauseLen+1) : 0) +
             (lpCompStrA->dwResultReadStrLen > 0 ? DWORD_ALIGN(((lpCompStrA->dwResultReadStrLen+1) * sizeof(WCHAR))) : 0)+
             (lpCompStrA->dwResultReadClauseLen > 0 ? DWORD_ALIGN(lpCompStrA->dwResultReadClauseLen+1) : 0);

    if (lpStringExW == NULL) {
        return dwSize;
    }

    if (dwSize > dwStringExWBufferSize) {
        // lpStringExW buffer is too small.
        return 0;
    }

    // Set actual lpStringExW buffer size in dwSize.
    dwSize = dwStringExWBufferSize;

    dwPos = DWORD_ALIGN(sizeof(STRINGEXSTRUCT) + 1);
    lpStringExW->dwSize = dwSize;

    if (lpCompStrA->dwResultStrLen > 0) {
        if (dwSize < dwPos) {
            // lpStringExW buffer is too small.
            return 0;
        }

        i = MultiByteToWideChar( CP_ACP,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset),  // src
                                (INT)lpCompStrA->dwResultStrLen,
                                (LPWSTR)((PBYTE)lpStringExW + dwPos),                        // dest
                                (INT)(dwSize - dwPos)/sizeof(WCHAR));  // Specifies the size, in wide characters.
        if (i >= (dwSize - dwPos)/sizeof(WCHAR)) {
            // lpStringExW buffer doesn't hold NULL character terminator.
            return 0;
        }

        ((LPWSTR)((PBYTE)lpStringExW + dwPos))[i] = L'\0';
        dwLen = i;
        lpStringExW->uDeterminePos = dwPos;
        dwPos += DWORD_ALIGN(((dwLen + 1)*sizeof(WCHAR)));
    } else {
        dwLen = 0;
        lpStringExW->uDeterminePos = 0;
    }

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrA->dwResultClauseLen > 0) )
    {
        if (dwLen != 0 && lpCompStrA->dwResultClauseLen > 0) {
            LPDWORD lpw;
            LPDWORD lpdw;
            DWORD   dwClauseWPos;

            if (dwSize < dwPos) {
                // lpStringExW buffer is too small.
                return 0;
            }

            dwClauseWPos = dwPos;

            lpw  = (LPDWORD)((PBYTE)lpStringExW + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultClauseOffset);

            for (i = 0; i < (lpCompStrA->dwResultClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionAtoW(*lpdw++,
                                                   (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset),
                                                   CP_ACP
                                                  );

                dwClauseWPos += sizeof(*lpw);
                if (dwSize < dwClauseWPos) {
                    // lpStringExW buffer is too small.
                    return 0;
                }
            }

            lpStringExW->uDetermineDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrA->dwResultClauseLen + 1));
        }
    }

    if (lpCompStrA->dwResultReadStrLen > 0) {
        if (dwSize < dwPos) {
            // lpStringExW buffer is too small.
            return 0;
        }

        i = MultiByteToWideChar( CP_ACP,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadStrOffset),  // src
                                (INT)lpCompStrA->dwResultReadStrLen,
                                (LPWSTR)((PBYTE)lpStringExW + dwPos),                            // dest
                                (INT)(dwSize - dwPos)/sizeof(WCHAR));  // Specifies the size, in wide characters.
        if (i >= (dwSize - dwPos)/sizeof(WCHAR)) {
            // lpStringExW buffer doesn't hold NULL character terminator.
            return 0;
        }

        ((LPWSTR)((PBYTE)lpStringExW + dwPos))[i] = L'\0';
        dwLen = i;
        lpStringExW->uYomiPos = dwPos;
        dwPos += DWORD_ALIGN(((dwLen + 1)*sizeof(WCHAR)));
    } else {
        dwLen = 0;
        lpStringExW->uYomiPos = 0;
    }

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrA->dwResultReadClauseLen > 0) )
    {
        if (dwLen != 0 && lpCompStrA->dwResultReadClauseLen > 0) {
            LPDWORD lpw;
            LPDWORD lpdw;
            DWORD   dwClauseWPos;

            if (dwSize < dwPos) {
                // lpStringExW buffer is too small.
                return 0;
            }

            dwClauseWPos = dwPos;

            lpw  = (LPDWORD)((PBYTE)lpStringExW + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadClauseOffset);

            for (i = 0; i < (lpCompStrA->dwResultReadClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionAtoW(*lpdw++,
                                                   (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadStrOffset),
                                                   CP_ACP
                                                  );

                dwClauseWPos += sizeof(*lpw);
                if (dwSize < dwClauseWPos) {
                    // lpStringExW buffer is too small.
                    return 0;
                }
            }

            lpStringExW->uYomiDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrA->dwResultReadClauseLen + 1));
        }
    }

    return dwSize;
}

DWORD
CompStrAToStringA(
    LPCOMPOSITIONSTRING lpCompStrA,
    LPSTR lpStringA,
    DWORD dwStringABufferSize
    )

/*++

Routine Description:

    Convert composition string (ANSI) to String (ANSI).

Arguments:

Return Value:

--*/

{
    LPSTR lpszString;
    DWORD dwSize;

    lpszString = (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset);
    dwSize = lpCompStrA->dwResultStrLen;

    if (lpStringA == NULL) {
        return ((dwSize + 1) * sizeof(CHAR));
    }

    if (dwSize > dwStringABufferSize) {
        // lpStringA buffer is too small.
        return 0;
    }

    memcpy((PBYTE)lpStringA,
           (PBYTE)lpszString,
           (dwSize * sizeof(CHAR))
          );
    lpStringA[dwSize] = '\0';

    return ((dwSize + 1) * sizeof(CHAR));
}

DWORD
CompStrAToStringW(
    LPCOMPOSITIONSTRING lpCompStrA,
    LPWSTR lpStringW,
    DWORD dwStringWBufferSize
    )

/*++

Routine Description:

    Convert composition string (ANSI) to String (Unicode).

Arguments:

Return Value:

--*/

{
    LPSTR lpszString;
    DWORD dwSize;
    UINT  i;

    lpszString = (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset);

    i = MultiByteToWideChar( CP_ACP,
                            (DWORD)MB_PRECOMPOSED,
                            (LPSTR)lpszString,              // src
                            (INT)lpCompStrA->dwResultStrLen,
                            (LPWSTR)lpStringW,              // dest
                            (INT)0);

    if (lpStringW == NULL) {
        dwSize = (i+1) * sizeof(WCHAR);
    }
    else {
        dwSize = (i+1) * sizeof(WCHAR);

        if (dwSize > dwStringWBufferSize) {
            // lpStringW buffer is too small.
            return 0;
        }

        i = MultiByteToWideChar( CP_ACP,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszString,              // src
                                (INT)lpCompStrA->dwResultStrLen,
                                (LPWSTR)lpStringW,              // dest
                                (INT)dwSize/sizeof(WCHAR));     // Specifies the size, in wide characters.
        if (i >= dwSize/sizeof(WCHAR)) {
            // lpStringW buffer doesn't hold NULL character terminator.
            return 0;
        }


        lpStringW[i] = L'\0';
        dwSize = (i+1) * sizeof(WCHAR);
    }

    return dwSize;
}

VOID
CompStrAToCharA(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrA
    )

/*++

Routine Description:

    Convert composition string (ANSI) to WM_CHAR (ANSI).

Arguments:

Return Value:

--*/

{
    LPSTR lpszString;
    BOOL  fDBCSWmChar = FALSE;
    WORD  wDBCSChar;
    BYTE  szAscii[3];

    lpszString = (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset);

    // IR_DBCSCHAR: If the app reply to this message with TRUE, we can
    // queue up double byte character in a WM_CHAR message.
    if ( GetClientInfo()->dwExpWinVer >= 0x030A ) {
        fDBCSWmChar = (BOOL)SendMessageA( hWnd,WM_IME_REPORT,IR_DBCSCHAR, 0L);
    }

    // Send IR_STRINGSTART prior to anything.
    PostMessageA( hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L );


    while(szAscii[0]=*lpszString)
    {
        if( *CharNextA(lpszString) == 0 )
        {
            PostMessageA( hWnd, WM_IME_REPORT, IR_STRINGEND, 0L );
        }
        if( IsDBCSLeadByte( szAscii[0] ) )
        {
            szAscii[1] = *((PBYTE)(lpszString+1));

            //  If fDBCSWmChar==TRUE, The app can recieve WM_CHARs which
            // have double byte code in wParam.
            if ( fDBCSWmChar )
            {
                // It's necessary to swap bytes to put 1st byte into upper
                // part of wParam, and 2nd byte into lower part.
                wDBCSChar = MAKEWORD(szAscii[1], szAscii[0]);
                PostMessageA( hWnd, WM_CHAR, (WPARAM)wDBCSChar|WMCR_IR_DBCSCHAR, 1L );
            }
            else
            {
                // Send each byte on a WM_CHAR
                PostMessageA( hWnd, WM_CHAR, (WPARAM)(szAscii[0]), 1L);
                PostMessageA( hWnd, WM_CHAR, (WPARAM)(szAscii[1]), 1L);
            }
        }
        else
        {
            PostMessageA( hWnd, WM_CHAR, (WPARAM)(szAscii[0]), 1L);
        }
        lpszString = CharNextA(lpszString);
    }
}

VOID
CompStrAToCharW(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrA
    )

/*++

Routine Description:

    Convert composition string (ANSI) to WM_CHAR (Unicode).

Arguments:

Return Value:

--*/

{
    LPSTR lpszString;
    UINT  i;
    BYTE  c;
    WCHAR  wszUnicode[2];

    lpszString = (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset);

    // IR_DBCSCHAR: If the app reply to this message with TRUE, we can
    // queue up double byte character in a WM_CHAR message.
    // SendMessageW( hWnd,WM_IME_REPORT,IR_DBCSCHAR, 0L);

    // Send IR_STRINGSTART prior to anything.
    PostMessageW( hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L );


    while(c=*lpszString)
    {
        if( *CharNextA(lpszString) == 0 )
        {
            PostMessageW( hWnd, WM_IME_REPORT, IR_STRINGEND, 0L );
        }
        if( IsDBCSLeadByte( c ) ) {
            i = MultiByteToWideChar( CP_ACP,
                                    (DWORD)MB_PRECOMPOSED,
                                    (LPSTR)lpszString,  // src
                                    (INT)2,
                                    (LPWSTR)wszUnicode, // dest
                                    (INT)ARRAY_SIZE(wszUnicode));
        }
        else {
            i = MultiByteToWideChar( CP_ACP,
                                    (DWORD)MB_PRECOMPOSED,
                                    (LPSTR)lpszString,  // src
                                    (INT)1,
                                    (LPWSTR)wszUnicode, // dest
                                    (INT)ARRAY_SIZE(wszUnicode));
        }
        if (i != 0) {
            PostMessageW( hWnd, WM_CHAR, (WPARAM)(wszUnicode[0]), 1L);
        }
        lpszString = CharNextA(lpszString);
    }
}

DWORD
CompStrWToUndetW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPUNDETERMINESTRUCT lpUndetW
    )

/*++

Routine Description:

    Convert composition string (Unicode) to undetermine string (Unicode).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    UINT  i;

    dwSize = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT)+1)) +
             DWORD_ALIGN(((lpCompStrW->dwResultStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN((lpCompStrW->dwResultClauseLen+1)) +
             DWORD_ALIGN(((lpCompStrW->dwResultReadStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN((lpCompStrW->dwResultReadClauseLen+1)) +
             DWORD_ALIGN((lpCompStrW->dwCompAttrLen+1)) +
             DWORD_ALIGN(((lpCompStrW->dwCompStrLen+1) * sizeof(WCHAR)));

    if (lpUndetW == NULL) {
        return dwSize;
    }

    dwPos = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT) + 1));
    lpUndetW->dwSize = dwSize;

    if (dwGCS & GCS_COMPSTR)
    {
        lpUndetW->uUndetTextLen = lpCompStrW->dwCompStrLen;
        lpUndetW->uUndetTextPos = dwPos;
        memcpy((PBYTE)lpUndetW   + dwPos,
               (PBYTE)lpCompStrW + lpCompStrW->dwCompStrOffset,
               lpCompStrW->dwCompStrLen * sizeof(WCHAR)
              );
        *(LPWSTR)((PBYTE)lpUndetW + dwPos + lpCompStrW->dwCompStrLen*sizeof(WCHAR)) = L'\0';
        dwPos += DWORD_ALIGN(((lpUndetW->uUndetTextLen+1)*sizeof(WCHAR)));

        // Sometime Chicago IME does not generate GCS_COMPATTR
        // with GCS_COMPSTR. But uUndetAttrPos should be filled
        // when the UndetText is updated.
        if (lpCompStrW->dwCompAttrLen && !(dwGCS & GCS_COMPATTR))
            dwGCS |= GCS_COMPATTR;
    }

    if (dwGCS & GCS_COMPATTR)
    {
        lpUndetW->uUndetAttrPos = dwPos;
        memcpy((PBYTE)lpUndetW   + dwPos,
               (PBYTE)lpCompStrW + lpCompStrW->dwCompAttrOffset,
               lpCompStrW->dwCompAttrLen
              );
        dwPos += DWORD_ALIGN((lpUndetW->uUndetTextLen + 1));
    }

    if (dwGCS & GCS_CURSORPOS)
    {
        lpUndetW->uCursorPos = lpCompStrW->dwCursorPos;
    }

    if (dwGCS & GCS_DELTASTART)
    {
        lpUndetW->uDeltaStart = lpCompStrW->dwDeltaStart;
    }

    if (dwGCS & GCS_RESULTSTR)
    {
        lpUndetW->uDetermineTextLen = lpCompStrW->dwResultStrLen;
        lpUndetW->uDetermineTextPos = dwPos;
        memcpy((PBYTE)lpUndetW   + dwPos,
               (PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset,
               lpCompStrW->dwResultStrLen * sizeof(WCHAR)
              );
        *(LPWSTR)((PBYTE)lpUndetW + dwPos + lpCompStrW->dwResultStrLen*sizeof(WCHAR)) = L'\0';
        dwPos += DWORD_ALIGN(((lpUndetW->uDetermineTextLen + 1)*sizeof(WCHAR)));
    }

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrW->dwResultClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;

        lpUndetW->uDetermineDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpUndetW + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultClauseOffset);
        for (i = 0; i < (lpCompStrW->dwResultClauseLen / sizeof(DWORD)); i++)
            *lpw++ = *lpdw++;

        dwPos += DWORD_ALIGN((lpCompStrW->dwResultClauseLen + 1));
    }

    if (dwGCS & GCS_RESULTREADSTR)
    {
        lpUndetW->uYomiTextLen = lpCompStrW->dwResultReadStrLen;
        lpUndetW->uYomiTextPos = dwPos;
        memcpy((PBYTE)lpUndetW   + dwPos,
               (PBYTE)lpCompStrW + lpCompStrW->dwResultReadStrOffset,
               lpCompStrW->dwResultReadStrLen * sizeof(WCHAR)
              );
        *(LPWSTR)((PBYTE)lpUndetW + dwPos + lpCompStrW->dwResultReadStrLen*sizeof(WCHAR)) = L'\0';
        dwPos += DWORD_ALIGN(((lpUndetW->uYomiTextLen + 1)*sizeof(WCHAR)));
    }

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrW->dwResultReadClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;

        lpUndetW->uYomiDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpUndetW + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadClauseOffset);
        for (i = 0; i < (lpCompStrW->dwResultReadClauseLen / sizeof(DWORD)); i++)
            *lpw++ = *lpdw++;

        dwPos += DWORD_ALIGN((lpCompStrW->dwResultReadClauseLen + 1));
    }

    return dwSize;
}

DWORD
CompStrWToUndetA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPUNDETERMINESTRUCT lpUndetA
    )

/*++

Routine Description:

    Convert composition string (Unicode) to undetermine string (ANSI).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    UINT  i;
    BOOL bUDC;

    dwSize = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT)+1)) +
             DWORD_ALIGN(((lpCompStrW->dwResultStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN((lpCompStrW->dwResultClauseLen+1)) +
             DWORD_ALIGN(((lpCompStrW->dwResultReadStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN((lpCompStrW->dwResultReadClauseLen+1)) +
             DWORD_ALIGN((lpCompStrW->dwCompAttrLen * 2)) +
             DWORD_ALIGN(((lpCompStrW->dwCompStrLen+1) * sizeof(WCHAR)));

    if (lpUndetA == NULL) {
        return dwSize;
    }

    dwPos = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT) + 1));
    lpUndetA->dwSize = dwSize;

    if (dwGCS & GCS_COMPSTR)
    {
        i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwCompStrOffset),  // src
                                (INT)lpCompStrW->dwCompStrLen,
                                (LPSTR)((PBYTE)lpUndetA + dwPos),                           // dest
                                (INT)dwSize - dwPos,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);
        ((LPSTR)((PBYTE)lpUndetA + dwPos))[i] = '\0';
        lpUndetA->uUndetTextLen = i;
        lpUndetA->uUndetTextPos = dwPos;
        dwPos += DWORD_ALIGN(((lpUndetA->uUndetTextLen + 1)*sizeof(CHAR)));

        // Sometime Chicago IME does not generate GCS_COMPATTR
        // with GCS_COMPSTR. But uUndetAttrPos should be filled
        // when the UndetText is updated.
        if (lpCompStrW->dwCompAttrLen && !(dwGCS & GCS_COMPATTR))
            dwGCS |= GCS_COMPATTR;
    }

    if (dwGCS & GCS_COMPATTR)
    {
        if (lpUndetA->uUndetTextLen != 0) {
            LPSTR  lpszUndetText;
            PBYTE  lpAttrW;
            PBYTE  lpAttrA;
            BYTE   c;

            lpszUndetText  = (LPSTR)((PBYTE)lpUndetA + lpUndetA->uUndetTextPos);
            lpAttrW = (PBYTE)lpCompStrW + lpCompStrW->dwCompAttrOffset;
            lpAttrA = (PBYTE)lpUndetA   + dwPos;

            while (c=*lpszUndetText++) {
                if (IsDBCSLeadByte(c)) {
                    *lpAttrA++ = *lpAttrW;
                    *lpAttrA++ = *lpAttrW;
                    lpszUndetText++;
                }
                else {
                    *lpAttrA++ = *lpAttrW;
                }
                lpAttrW++;
            }

            lpUndetA->uUndetAttrPos = dwPos;
            dwPos += DWORD_ALIGN((lpUndetA->uUndetTextLen + 1));
        }
    }

    if (dwGCS & GCS_CURSORPOS)
    {
        if (lpCompStrW->dwCursorPos != -1) {
            lpUndetA->uCursorPos = CalcCharacterPositionWtoA(lpCompStrW->dwCursorPos,
                                                             (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwCompStrOffset),
                                                             CP_ACP
                                                            );
        }
        else {
            lpUndetA->uCursorPos = lpCompStrW->dwCursorPos;
        }
    }

    if (dwGCS & GCS_DELTASTART)
    {
        if (lpCompStrW->dwDeltaStart != -1) {
            lpUndetA->uDeltaStart = CalcCharacterPositionWtoA(lpCompStrW->dwDeltaStart,
                                                              (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwCompStrOffset),
                                                              CP_ACP
                                                             );
        }
        else {
            lpUndetA->uDeltaStart = lpCompStrW->dwDeltaStart;
        }
    }

    if (dwGCS & GCS_RESULTSTR)
    {
        i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset),  // src
                                (INT)lpCompStrW->dwResultStrLen,
                                (LPSTR)((PBYTE)lpUndetA + dwPos),                             // dest
                                (INT)dwSize - dwPos,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);
        ((LPSTR)((PBYTE)lpUndetA + dwPos))[i] = '\0';
        lpUndetA->uDetermineTextLen = i;
        lpUndetA->uDetermineTextPos = dwPos;
        dwPos += DWORD_ALIGN(((lpUndetA->uDetermineTextLen + 1)*sizeof(CHAR)));
    }

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrW->dwResultClauseLen > 0) )
    {
        if (lpUndetA->uDetermineTextLen != 0) {
            LPDWORD lpw;
            LPDWORD lpdw;

            lpw  = (LPDWORD)((PBYTE)lpUndetA + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultClauseOffset);

            for (i = 0; i < (lpCompStrW->dwResultClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionWtoA(*lpdw++,
                                                   (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset),
                                                   CP_ACP
                                                  );
            }

            lpUndetA->uDetermineDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrW->dwResultClauseLen + 1));
        }
    }

    if (dwGCS & GCS_RESULTREADSTR)
    {
        i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadStrOffset),  // src
                                (INT)lpCompStrW->dwResultReadStrLen,
                                (LPSTR)((PBYTE)lpUndetA + dwPos),                                 // dest
                                (INT)dwSize - dwPos,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);
        ((LPSTR)((PBYTE)lpUndetA + dwPos))[i] = '\0';
        lpUndetA->uYomiTextLen = i;
        lpUndetA->uYomiTextPos = dwPos;
        dwPos += DWORD_ALIGN(((lpUndetA->uYomiTextLen + 1)*sizeof(CHAR)));
    }

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrW->dwResultReadClauseLen > 0) )
    {
        if (lpUndetA->uYomiTextLen != 0) {
            LPDWORD lpw;
            LPDWORD lpdw;

            lpw  = (LPDWORD)((PBYTE)lpUndetA + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadClauseOffset);

            for (i = 0; i < (lpCompStrW->dwResultReadClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionWtoA(*lpdw++,
                                                   (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadStrOffset),
                                                   CP_ACP
                                                  );
            }

            lpUndetA->uYomiDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrW->dwResultReadClauseLen + 1));
        }
    }

    return dwSize;
}


DWORD
CompStrWToStringExW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPSTRINGEXSTRUCT lpStringExW
    )

/*++

Routine Description:

    Convert composition string (Unicode) to StringEx (Unicode).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    UINT  i;

    dwSize = DWORD_ALIGN((sizeof(STRINGEXSTRUCT)+1)) +
             DWORD_ALIGN(((lpCompStrW->dwResultStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN(lpCompStrW->dwResultClauseLen+1) +
             DWORD_ALIGN(((lpCompStrW->dwResultReadStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN(lpCompStrW->dwResultReadClauseLen+1);

    if (lpStringExW == NULL) {
        return dwSize;
    }

    dwPos = DWORD_ALIGN(sizeof(STRINGEXSTRUCT) + 1);
    lpStringExW->dwSize = dwSize;

    lpStringExW->uDeterminePos = dwPos;
    memcpy((PBYTE)lpStringExW + dwPos,
           (PBYTE)lpCompStrW  + lpCompStrW->dwResultStrOffset,
           lpCompStrW->dwResultStrLen * sizeof(WCHAR)
          );
    *(LPWSTR)((PBYTE)lpStringExW + dwPos + lpCompStrW->dwResultStrLen*sizeof(WCHAR)) = L'\0';
    dwPos += DWORD_ALIGN(((lpCompStrW->dwResultStrLen + 1)*sizeof(WCHAR)));

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrW->dwResultClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;

        lpStringExW->uDetermineDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpStringExW + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultClauseOffset);
        for (i = 0; i < (lpCompStrW->dwResultClauseLen / sizeof(DWORD)); i++)
            *lpw++ = *lpdw++;

        dwPos += DWORD_ALIGN((lpCompStrW->dwResultClauseLen + 1));
    }

    lpStringExW->uYomiPos = dwPos;
    memcpy((PBYTE)lpStringExW + dwPos,
           (PBYTE)lpCompStrW  + lpCompStrW->dwResultReadStrOffset,
           lpCompStrW->dwResultReadStrLen * sizeof(WCHAR)
          );
    *(LPWSTR)((PBYTE)lpStringExW + dwPos + lpCompStrW->dwResultReadStrLen*sizeof(WCHAR)) = L'\0';
    dwPos += DWORD_ALIGN(((lpCompStrW->dwResultReadStrLen + 1)*sizeof(WCHAR)));

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrW->dwResultReadClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;

        lpStringExW->uYomiDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpStringExW + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadClauseOffset);
        for (i = 0; i < (lpCompStrW->dwResultReadClauseLen / sizeof(DWORD)); i++)
            *lpw++ = *lpdw++;
    }

    return dwSize;
}

DWORD
CompStrWToStringExA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPSTRINGEXSTRUCT lpStringExA
    )

/*++

Routine Description:

    Convert composition string (Unicode) to StringEx (ANSI).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    DWORD dwLen;
    UINT  i;
    BOOL bUDC;

    dwSize = DWORD_ALIGN((sizeof(STRINGEXSTRUCT)+1)) +
             (lpCompStrW->dwResultStrLen > 0 ? DWORD_ALIGN(((lpCompStrW->dwResultStrLen+1) * sizeof(WCHAR))) : 0) +
             (lpCompStrW->dwResultClauseLen > 0 ? DWORD_ALIGN(lpCompStrW->dwResultClauseLen+1) : 0) +
             (lpCompStrW->dwResultReadStrLen > 0 ? DWORD_ALIGN(((lpCompStrW->dwResultReadStrLen+1) * sizeof(WCHAR))) : 0)+
             (lpCompStrW->dwResultReadClauseLen > 0 ? DWORD_ALIGN(lpCompStrW->dwResultReadClauseLen+1) : 0);

    if (lpStringExA == NULL) {
        return dwSize;
    }

    dwPos = DWORD_ALIGN(sizeof(STRINGEXSTRUCT) + 1);
    lpStringExA->dwSize = dwSize;

    if (lpCompStrW->dwResultStrLen > 0) {
        i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset),  // src
                                (INT)lpCompStrW->dwResultStrLen,
                                (LPSTR)((PBYTE)lpStringExA + dwPos),                          // dest
                                (INT)dwSize - dwPos,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);
        ((LPSTR)((PBYTE)lpStringExA + dwPos))[i] = '\0';
        dwLen = i;
        lpStringExA->uDeterminePos = dwPos;
        dwPos += DWORD_ALIGN(((dwLen + 1)*sizeof(CHAR)));
    } else {
        dwLen = 0;
        lpStringExA->uDeterminePos = 0;
    }

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrW->dwResultClauseLen > 0) )
    {
        if (dwLen != 0 && lpCompStrW->dwResultClauseLen > 0) {
            LPDWORD lpw;
            LPDWORD lpdw;

            lpw  = (LPDWORD)((PBYTE)lpStringExA + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultClauseOffset);

            for (i = 0; i < (lpCompStrW->dwResultClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionWtoA(*lpdw++,
                                                   (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset),
                                                   CP_ACP
                                                  );
            }

            lpStringExA->uDetermineDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrW->dwResultClauseLen + 1));
        }
    }

    if (lpCompStrW->dwResultReadStrLen > 0) {
        i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadStrOffset),  // src
                                (INT)lpCompStrW->dwResultReadStrLen,
                                (LPSTR)((PBYTE)lpStringExA + dwPos),                              // dest
                                (INT)dwSize - dwPos,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);
        ((LPSTR)((PBYTE)lpStringExA + dwPos))[i] = '\0';
        dwLen = i;
        lpStringExA->uYomiPos = dwPos;
        dwPos += DWORD_ALIGN(((dwLen + 1)*sizeof(CHAR)));
    } else {
        dwLen = 0;
        lpStringExA->uYomiPos = 0;
    }

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrW->dwResultReadClauseLen > 0) )
    {
        if (dwLen != 0 && lpCompStrW->dwResultReadClauseLen > 0) {
            LPDWORD lpw;
            LPDWORD lpdw;

            lpw  = (LPDWORD)((PBYTE)lpStringExA + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadClauseOffset);

            for (i = 0; i < (lpCompStrW->dwResultReadClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionWtoA(*lpdw++,
                                                   (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadStrOffset),
                                                   CP_ACP
                                                  );
            }

            lpStringExA->uYomiDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrW->dwResultReadClauseLen + 1));
        }
    }

    return dwSize;
}

DWORD
CompStrWToStringW(
    LPCOMPOSITIONSTRING lpCompStrW,
    LPWSTR lpStringW
    )

/*++

Routine Description:

    Convert composition string (Unicode) to String (Unicode).

Arguments:

Return Value:

--*/

{
    LPWSTR lpwszString;
    DWORD dwSize;

    lpwszString = (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset);
    dwSize = lpCompStrW->dwResultStrLen;

    if (lpStringW == NULL) {
        return ((dwSize + 1) * sizeof(WCHAR));
    }

    memcpy((PBYTE)lpStringW,
           (PBYTE)lpwszString,
           (dwSize * sizeof(WCHAR))
          );
    lpStringW[dwSize] = L'\0';

    return ((dwSize + 1) * sizeof(WCHAR));
}

DWORD
CompStrWToStringA(
    LPCOMPOSITIONSTRING lpCompStrW,
    LPSTR lpStringA
    )

/*++

Routine Description:

    Convert composition string (Unicode) to String (ANSI).

Arguments:

Return Value:

--*/

{
    LPWSTR lpwszString;
    DWORD dwSize;
    UINT  i;
    BOOL bUDC;

    lpwszString = (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset);

    i = WideCharToMultiByte( CP_ACP,
                            (DWORD)0,
                            (LPWSTR)lpwszString,                             // src
                            (INT)lpCompStrW->dwResultStrLen,
                            (LPSTR)lpStringA,                                // dest
                            (INT)0,
                            (LPSTR)NULL,
                            (LPBOOL)&bUDC);

    if (lpStringA == NULL) {
        dwSize = (i+1) * sizeof(CHAR);
    }
    else {
        dwSize = (i+1) * sizeof(CHAR);

        i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)lpwszString,                             // src
                                (INT)lpCompStrW->dwResultStrLen,
                                (LPSTR)lpStringA,                                // dest
                                (INT)dwSize,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);

        lpStringA[i] = '\0';
        dwSize = (i+1) * sizeof(CHAR);
    }

    return dwSize;
}

VOID
CompStrWToCharW(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrW
    )

/*++

Routine Description:

    Convert composition string (Unicode) to WM_CHAR (Unicode).

Arguments:

Return Value:

--*/

{
    LPWSTR lpwszString;

    lpwszString = (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset);

    // IR_DBCSCHAR: If the app reply to this message with TRUE, we can
    // queue up double byte character in a WM_CHAR message.
    // SendMessageW( hWnd,WM_IME_REPORT,IR_DBCSCHAR, 0L);

    // Send IR_STRINGSTART prior to anything.
    PostMessageW( hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L );


    while(*lpwszString)
    {
        if( *CharNextW(lpwszString) == 0 )
        {
            PostMessageW( hWnd, WM_IME_REPORT, IR_STRINGEND, 0L );
        }
        PostMessageW( hWnd, WM_CHAR, *lpwszString, 1L);
        lpwszString = CharNextW(lpwszString);
    }
}

VOID
CompStrWToCharA(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrW
    )

/*++

Routine Description:

    Convert composition string (Unicode) to WM_CHAR (ANSI).

Arguments:

Return Value:

--*/

{
    LPWSTR lpwszString;
    BOOL   fDBCSWmChar = FALSE;
    WORD   wDBCSChar;
    UINT   i;
    BOOL   bUDC;
    BYTE   szAscii[3];

    lpwszString = (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset);

    //
    // IR_DBCSCHAR: If the app reply to this message with TRUE, we can
    // queue up double byte character in a WM_CHAR message.
    //
    //

    if ( GetClientInfo()->dwExpWinVer >= 0x030A ) {
       fDBCSWmChar = (BOOL)SendMessageA( hWnd,WM_IME_REPORT,IR_DBCSCHAR, 0L);
    }

    //
    // Send IR_STRINGSTART prior to anything.
    //

    PostMessageA( hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L );


    while (*lpwszString) {

       if ( *CharNextW(lpwszString) == 0 ) {
           PostMessageA( hWnd, WM_IME_REPORT, IR_STRINGEND, 0L );
       }

       i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)lpwszString,  // src
                                (INT)1,
                                (LPSTR)szAscii,       // dest
                                (INT)sizeof(szAscii),
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);

        if (i != 0) {

            if ( IsDBCSLeadByte( szAscii[0] ) ) {

               //
               //  If fDBCSWmChar==TRUE, The app can recieve WM_CHARs which
               // have double byte code in wParam.
               //

               if ( fDBCSWmChar )
               {
                   //
                   // It's necessary to swap bytes to put 1st byte into upper
                   // part of wParam, and 2nd byte into lower part.
                   //

                   wDBCSChar = MAKEWORD(szAscii[1], szAscii[0]);
                   PostMessageA( hWnd, WM_CHAR, wDBCSChar|WMCR_IR_DBCSCHAR, 1L );
               }
               else
               {
                   //
                   // Send each byte on a WM_CHAR
                   //

                   PostMessageA( hWnd, WM_CHAR, (WPARAM)(szAscii[0]), 1L);
                   PostMessageA( hWnd, WM_CHAR, (WPARAM)(szAscii[1]), 1L);
               }
           }
           else
           {
               PostMessageA( hWnd, WM_CHAR, (WPARAM)(szAscii[0]), 1L);
           }
       }

       lpwszString = CharNextW(lpwszString);
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\input.c ===
/**************************************************************************\
* Module Name: input.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IME key input management routines for imm32 dll
*
* History:
* 01-Apr-1996 takaok       split from hotkey.c
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef HIRO_DEBUG
#define D(x)    x
#else
#define D(x)
#endif

/***************************************************************************\
* ImmProcessKey (Callback from Win32K.SYS)
*
* Call ImeProcessKey and IME hotkey handler
*
* History:
* 01-Mar-1996 TakaoK       Created
\***************************************************************************/

DWORD WINAPI ImmProcessKey(
    HWND    hWnd,
    HKL     hkl,
    UINT    uVKey,
    LPARAM  lParam,
    DWORD   dwHotKeyID)
{
    HIMC hIMC = ImmGetContext(hWnd);
    PIMEDPI pImeDpi = ImmLockImeDpi(hkl);
    DWORD dwReturn = 0;
#if DBG
    if (dwHotKeyID >= IME_KHOTKEY_FIRST && dwHotKeyID <= IME_KHOTKEY_LAST) {
        TAGMSG2(DBGTAG_IMM, "ImmProcessKey: Kor IME Hotkeys should not come here: dwHotKeyID=%x, uVKey=%x", dwHotKeyID, uVKey);
    }
#endif

    ImmAssert(dwHotKeyID != IME_KHOTKEY_ENGLISH &&
              dwHotKeyID != IME_KHOTKEY_SHAPE_TOGGLE &&
              dwHotKeyID != IME_KHOTKEY_HANJACONVERT);

    //
    // call ImeProcessKey
    //
    if (pImeDpi != NULL) {
        PINPUTCONTEXT pInputContext = ImmLockIMC(hIMC);

        if (pInputContext != NULL) {
            BOOLEAN fTruncateWideVK = FALSE;
            BOOLEAN fCallIme = TRUE;
            BOOLEAN fSkipThisKey = FALSE;

#ifdef LATER

            //
            // if the current imc is not open and IME doesn't need
            // keys when being closed, we don't pass any keyboard
            // input to ime except hotkey and keys that change
            // the keyboard status.
            //
            if ((pImeDpi->fdwProperty & IME_PROP_NO_KEYS_ON_CLOSE) &&
                    !pInputContext->fOpen &&
                    uVKey != VK_SHIFT &&
                    uVKey != VK_CONTROL &&
                    uVKey != VK_CAPITAL &&
                    uVKey != VK_KANA &&
                    uVKey != VK_NUMLOCK &&
                    uVKey != VK_SCROLL) {
                // Check if Korea Hanja conversion mode
                if(!(pimc->fdwConvMode & IME_CMODE_HANJACONVERT)) {
                    fCallIme = FALSE;
                }
            }
            else
#endif
            //
            // Protect IMEs which are unaware of wide virtual keys.
            //
            if ((BYTE)uVKey == VK_PACKET &&
                    (pImeDpi->ImeInfo.fdwProperty & IME_PROP_ACCEPT_WIDE_VKEY) == 0) {

                if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
                    //
                    // Since this IME is not ready to accept wide VKey, we should
                    // truncate it.
                    //
                    fTruncateWideVK = TRUE;
                }
                else {
                    //
                    // Hmm, this guy is ANSI IME, and does not declare Wide Vkey awareness.
                    // Let's guess this one is not ready to accept Wide Vkey, so let's not
                    // pass it to this guy.
                    // And if it is opened, we'd better skip this key for safety.
                    //
                    fCallIme = FALSE;
                    if (pInputContext->fOpen) {
                        fSkipThisKey = TRUE;
                    }
                }
            }

            if (fCallIme) {
                PBYTE pbKeyState = (PBYTE)ImmLocalAlloc(0, 256);

                ImmAssert(fSkipThisKey == FALSE);

                if (pbKeyState != NULL) {
                    if (GetKeyboardState(pbKeyState)) {
                        UINT uVKeyIme = uVKey;
                        if (fTruncateWideVK) {
                            uVKeyIme &= 0xffff;
                        }
                        if ( (*pImeDpi->pfn.ImeProcessKey)(hIMC, uVKeyIme, lParam, pbKeyState) ) {
                            //
                            // if the return value of ImeProcessKey is TRUE,
                            // it means the key is the one that the ime is
                            // waiting for.
                            //
                            pInputContext->fChgMsg = TRUE;
                            pInputContext->uSavedVKey = uVKey;
                            dwReturn |= IPHK_PROCESSBYIME;
                        }
                    }
                    ImmLocalFree(pbKeyState);
                }
            }
            else if (fSkipThisKey) {
                dwReturn |= IPHK_SKIPTHISKEY;
                ImmAssert((dwReturn & (IPHK_PROCESSBYIME | IPHK_HOTKEY)) == 0);
            }
            ImmUnlockIMC(hIMC);
        }
        ImmUnlockImeDpi(pImeDpi);
    }

    //
    // call hotkey handler
    //
#if !defined(CUAS_ENABLE)
    if (dwHotKeyID != IME_INVALID_HOTKEY && HotKeyIDDispatcher(hWnd, hIMC, hkl, dwHotKeyID)) {
        // Backward compat:
        // On Japanese system, some applications may want VK_KANJI.
        if ((uVKey != VK_KANJI) ||
                (dwHotKeyID != IME_JHOTKEY_CLOSE_OPEN)) {
            dwReturn |= IPHK_HOTKEY;
        }
    }

#else

    //
    // Check MSCTF's keyboard hook is running in this thread. 
    // We can use MSCTF's hotkey handler only when MSCTF's keyboard hook
    // is installed and running.
    //
    if (CtfImmIsCiceroStartedInThread()) {
        BOOL fHandled = FALSE;
        if (Internal_CtfImeProcessCicHotkey(hIMC, uVKey, lParam)) {
                // Backward compat:
                // On Japanese system, some applications may want VK_KANJI.
                if ((uVKey != VK_KANJI) ||
                        (dwHotKeyID != IME_JHOTKEY_CLOSE_OPEN)) {
                    dwReturn |= IPHK_HOTKEY;
                }
                fHandled = TRUE;
        }
        if (!fHandled && IS_IME_KBDLAYOUT(hkl))
        {
            goto TryIMEHotkey;
        }
    } else {
TryIMEHotkey:
        if (dwHotKeyID != IME_INVALID_HOTKEY) {
            if (HotKeyIDDispatcher(hWnd, hIMC, hkl, dwHotKeyID)) {
                // Backward compat:
                // On Japanese system, some applications may want VK_KANJI.
                if ((uVKey != VK_KANJI) ||
                        (dwHotKeyID != IME_JHOTKEY_CLOSE_OPEN)) {
                    dwReturn |= IPHK_HOTKEY;
                }
            }
        }
    }
#endif
    
    //
    // some 3.x application doesn't like to see
    // VK_PROCESSKEY.
    //
    if (dwReturn & IPHK_PROCESSBYIME) {

        DWORD dwImeCompat = ImmGetAppCompatFlags(hIMC);

        if (dwImeCompat & IMECOMPAT_NOVKPROCESSKEY) {

            // Korea 3.x application doesn't like to see dummy finalize VK_PROCESSKEY
            // and IME hot key.

            if ( PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) == LANG_KOREAN &&
                 ( (uVKey == VK_PROCESSKEY) || (dwReturn & IPHK_HOTKEY) ) ) {
                ImmReleaseContext(hWnd, hIMC);
                return dwReturn;
            }

            ImmTranslateMessage(hWnd, WM_KEYDOWN, VK_PROCESSKEY, lParam);
            dwReturn &= ~IPHK_PROCESSBYIME;
            dwReturn |= IPHK_SKIPTHISKEY;
        }
    }
    ImmReleaseContext(hWnd, hIMC);

    return dwReturn;
}

#define TRANSMSGCOUNT 256

/***************************************************************************\
* ImmTranslateMessage (Called from user\client\ntstubs.c\TranslateMessage())
*
* Call ImeToAsciiEx()
*
* History:
* 01-Mar-1996 TakaoK       Created
\***************************************************************************/
BOOL ImmTranslateMessage(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    HIMC hImc;
    PINPUTCONTEXT pInputContext;
    BOOL fReturn = FALSE;
    HKL  hkl;
    PIMEDPI pImeDpi = NULL;
    PBYTE pbKeyState;
    PTRANSMSG pTransMsg;
    PTRANSMSGLIST pTransMsgList;
    DWORD dwSize;
    UINT uVKey;
    INT iNum;

    UNREFERENCED_PARAMETER(wParam);

    //
    // we're interested in only those keyboard messages.
    //
    switch (message) {
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        break;
    default:
        return FALSE;
    }

    //
    // input context is necessary for further handling
    //
    hImc = ImmGetContext(hwnd);
    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        ImmReleaseContext(hwnd, hImc);
        return FALSE;
    }

    //
    // At first, handle VK_PROCESSKEY generated by IME.
    //
    if (!pInputContext->fChgMsg) {

        if ((iNum=pInputContext->dwNumMsgBuf) != 0) {

            pTransMsg = (PTRANSMSG)ImmLockIMCC(pInputContext->hMsgBuf);
            if (pTransMsg != NULL) {
                ImmPostMessages(hwnd, hImc, iNum, pTransMsg);
                ImmUnlockIMCC(pInputContext->hMsgBuf);
                fReturn = TRUE;
            }

            pInputContext->dwNumMsgBuf = 0;
        }
        goto ExitITM;
    }

    pInputContext->fChgMsg = FALSE;

    //
    // retrieve the keyboard layout and IME entry points
    //
    hkl = GetKeyboardLayout( GetWindowThreadProcessId(hwnd, NULL) );
    pImeDpi = ImmLockImeDpi(hkl);
    if (pImeDpi == NULL) {
        RIPMSG1(RIP_WARNING, "ImmTranslateMessage pImeDpi is NULL(hkl=%x)", hkl);
        goto ExitITM;
    }

    pbKeyState = ImmLocalAlloc(0, 256);
    if ( pbKeyState == NULL ) {
        RIPMSG0(RIP_WARNING, "ImmTranslateMessage out of memory" );
        goto ExitITM;
    }

    if (!GetKeyboardState(pbKeyState)) {
        RIPMSG0(RIP_WARNING, "ImmTranslateMessage GetKeyboardState() failed" );
        ImmLocalFree( pbKeyState );
        goto ExitITM;
    }

    //
    // Translate the saved vkey into character code if needed
    //
    uVKey = pInputContext->uSavedVKey;

    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_KBD_CHAR_FIRST) {

        if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
            WCHAR wcTemp;

            iNum = ToUnicode(pInputContext->uSavedVKey, // virtual-key code
                             HIWORD(lParam),            // scan code
                             pbKeyState,                // key-state array
                             &wcTemp,                   // buffer for translated key
                             1,                         // size of buffer
                             0);
            if (iNum == 1) {
                //
                // hi word            : unicode character code
                // hi byte of lo word : zero
                // lo byte of lo word : virtual key
                //
                uVKey = (uVKey & 0x00ff) | ((UINT)wcTemp << 16);
            }

        } else {
            WORD wTemp = 0;

            iNum = ToAsciiEx(pInputContext->uSavedVKey, // virtual-key code
                             HIWORD(lParam),            // scan code
                             pbKeyState,                // key-state array
                             &wTemp,                    // buffer for translated key
                             0,                         // active-menu flag
                             hkl);
            ImmAssert(iNum <= 2);
            if (iNum > 0) {
                //
                // hi word            : should be zero
                // hi byte of lo word : character code
                // lo byte of lo word : virtual key
                //
                uVKey = (uVKey & 0x00FF) | ((UINT)wTemp << 8);

                if ((BYTE)uVKey == VK_PACKET) {
                    //
                    // If ANSI IME is wide vkey aware, its ImeToAsciiEx will receive the uVKey
                    // as follows:
                    //
                    //  31            24 23                         16 15                8 7             0
                    // +----------------+-----------------------------+-------------------+---------------+
                    // | 24~31:reserved | 16~23:trailing byte(if any) | 8~15:leading byte | 0~7:VK_PACKET |
                    // +----------------+-----------------------------+-------------------+---------------+
                    //
                    ImmAssert(pImeDpi->ImeInfo.fdwProperty & IME_PROP_ACCEPT_WIDE_VKEY);
                }
                else {
                    uVKey &= 0xffff;
                }
            }
        }
    }

    dwSize = FIELD_OFFSET(TRANSMSGLIST, TransMsg)
           + TRANSMSGCOUNT * sizeof(TRANSMSG);

    pTransMsgList = (PTRANSMSGLIST)ImmLocalAlloc(0, dwSize);

    if (pTransMsgList == NULL) {
        RIPMSG0(RIP_WARNING, "ImmTranslateMessage out of memory" );
        ImmLocalFree(pbKeyState);
        goto ExitITM;
    }

    pTransMsgList->uMsgCount = TRANSMSGCOUNT;
    iNum = (*pImeDpi->pfn.ImeToAsciiEx)(uVKey,
                                        HIWORD(lParam),
                                        pbKeyState,
                                        pTransMsgList,
                                        0,
                                        hImc);

    if (iNum > TRANSMSGCOUNT) {

        //
        // The message buffer is not big enough. IME put messages
        // into hMsgBuf in the input context.
        //

        pTransMsg = (PTRANSMSG)ImmLockIMCC(pInputContext->hMsgBuf);
        if (pTransMsg != NULL) {
            ImmPostMessages(hwnd, hImc, iNum, pTransMsg);
            ImmUnlockIMCC(pInputContext->hMsgBuf);
        }

#ifdef LATER
        // Shouldn't we need this ?
        fReturn = TRUE;
#endif

    } else if (iNum > 0) {
        ImmPostMessages(hwnd, hImc, iNum, &pTransMsgList->TransMsg[0]);
        fReturn = TRUE;
    }

    ImmLocalFree(pbKeyState);
    ImmLocalFree(pTransMsgList);

ExitITM:
    ImmUnlockImeDpi(pImeDpi);
    ImmUnlockIMC(hImc);
    ImmReleaseContext(hwnd, hImc);

    return fReturn;
}

/***************************************************************************\
* ImmPostMessages(Called from ImmTranslateMessage() )
*
*  Post IME messages to application. If application is 3.x, messages
*  are translated to old IME messages.
*
* History:
* 01-Mar-1996 TakaoK       Created
\***************************************************************************/

VOID
ImmPostMessages(
    HWND      hWnd,
    HIMC      hImc,
    INT       iNum,
    PTRANSMSG pTransMsg)
{
    INT i;
    BOOL fAnsiIME;
    PCLIENTIMC pClientImc;
    PTRANSMSG pTransMsgTemp, pTransMsgBuf = NULL;

    //
    // Check if the IME is unicode or not.
    // The message buffer contains unicode messages
    // if the IME is unicode.
    //
    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING,
                "ImmPostMessages: Invalid hImc %lx.", hImc);
        return;
    }

    fAnsiIME = ! TestICF(pClientImc, IMCF_UNICODE);
    ImmUnlockClientImc(pClientImc);

    //
    // translate messages to 3.x format if the App's version is 3.x.
    //
    pTransMsgTemp = pTransMsg;
    if (GetClientInfo()->dwExpWinVer < VER40) {
        DWORD dwLangId = PRIMARYLANGID(
                                      LANGIDFROMLCID(
                                                    GetSystemDefaultLCID()));
        if ( (dwLangId == LANG_KOREAN && TransGetLevel(hWnd) == 3) ||
             dwLangId == LANG_JAPANESE ) {

            pTransMsgBuf = ImmLocalAlloc(0, iNum * sizeof(TRANSMSG));
            if (pTransMsgBuf != NULL) {
                RtlCopyMemory(pTransMsgBuf, pTransMsg, iNum * sizeof(TRANSMSG));
                iNum = WINNLSTranslateMessage(iNum,
                                              pTransMsgBuf,
                                              hImc,
                                              fAnsiIME,
                                              dwLangId );
                pTransMsgTemp = pTransMsgBuf;
            }
        }
    }

    for (i = 0; i < iNum; i++) {
        if (fAnsiIME) {
            PostMessageA(hWnd,
                    pTransMsgTemp->message,
                    pTransMsgTemp->wParam,
                    pTransMsgTemp->lParam);
        } else {
            PostMessageW(hWnd,
                    pTransMsgTemp->message,
                    pTransMsgTemp->wParam,
                    pTransMsgTemp->lParam);
        }
        pTransMsgTemp++;
    }

    if (pTransMsgBuf != NULL) {
        ImmLocalFree(pTransMsgBuf);
    }
}

UINT WINNLSTranslateMessage(
    INT       iNum,        // number of messages in the source buffer
    PTRANSMSG pTransMsg,   // source buffer that contains 4.0 style messages
    HIMC      hImc,        // input context handle
    BOOL      fAnsi,       // TRUE if pdwt contains ANSI messages
    DWORD     dwLangId )   // language ID ( KOREAN or JAPANESE )
{
    LPINPUTCONTEXT      pInputContext;
    LPCOMPOSITIONSTRING pCompStr;
    UINT uiRet = 0;

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        return uiRet;
    }

    pCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC( pInputContext->hCompStr );
    if (pCompStr != NULL) {

        if (dwLangId == LANG_KOREAN) {
            uiRet = WINNLSTranslateMessageK((UINT)iNum,
                                            pTransMsg,
                                            pInputContext,
                                            pCompStr,
                                            fAnsi );
        } else if ( dwLangId == LANG_JAPANESE ) {
            uiRet = WINNLSTranslateMessageJ((UINT)iNum,
                                            pTransMsg,
                                            pInputContext,
                                            pCompStr,
                                            fAnsi );
        }

        ImmUnlockIMCC(pInputContext->hCompStr);
    }

    ImmUnlockIMC(hImc);

    return uiRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\ktranmsg.c ===
/**************************************************************************\
* Module Name: ktranmsg.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the code for the Korean translation subroutine.
*
* History:
* 15-Jul-1995
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

typedef struct tagMYIMESTRUCT {
    // This is the same as IMESTRUCT
    UINT        fnc;                // function code
    WPARAM      wParam;             // word parameter
    UINT        wCount;             // word counter
    UINT        dchSource;          // offset to pbKeyState
    UINT        dchDest;            // offset to pdwTransBuf
    LPARAM      lParam1;
    LPARAM      lParam2;
    LPARAM      lParam3;
    // My additional buffer
    BYTE        pbKeyState[256];
    DWORD       pdwTransBuf[257];
} MYIMESTRUCT;

typedef MYIMESTRUCT *LPMYIMESTRUCT;

MYIMESTRUCT myIME = { 0, 0, 0, sizeof(IMESTRUCT), sizeof(IMESTRUCT) + 256, 0};

#ifdef KILL_THIS
LRESULT CALLBACK KBHookProc(int iCode, WPARAM wParam, LPARAM lParam)
{
    HKL                 hKL;
    HWND                hWnd;
    HIMC                hIMC = NULL;
    LPINPUTCONTEXT      lpIMC = NULL;
    LPCOMPOSITIONSTRING lpCompStr;
    HTASK               hTask;
    int                 iLoop;

    if (!IsWindow(hWndSub))
        WinExec("wnlssub.exe",SW_HIDE);

    hWnd = GetFocus();
    hKL = GetKeyboardLayout(0);
    if ((hKL & 0xF000FFFFL) != 0xE0000412L || iCode < 0 || iCode == HC_NOREMOVE
        || (HIWORD(lParam) & KF_MENUMODE))
        goto CNH;
    hIMC = ImmGetContext(hWnd);
    if (hIMC == NULL || (lpIMC = ImmLockIMC(hIMC)) == NULL || !lpIMC->fOpen)
        goto CNH;

    if (wParam != VK_MENU && wParam != VK_F10)
        goto DoNext;

    // Menu is press with interim character
    if (HIWORD(lParam) & KF_UP)
        goto CNH;
    SendMsg:
    GetKeyboardState((LPBYTE)myIME.pbKeyState);
    myIME.wParam = wParam;
    myIME.lParam1 = lParam;
    myIME.pdwTransBuf[0] = 255/3;
    if (ImmEscape(hKL, hIMC, IME_ESC_AUTOMATA, (LPIMESTRUCT)&myIME) && myIME.wCount) {
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        StartStrSvr(lpIMC, lpCompStr, myIME.wCount, myIME.pdwTransBuf, TRUE);
        ImmUnlockIMCC(lpIMC->hCompStr, lpCompStr);
    }
    if (wParam == VK_PROCESSKEY) {
        ImmUnlockIMC(hIMC, lpIMC);
        return 0;
    }
    goto CNH;

    DoNext:
    if ((HIWORD(lParam) & KF_ALTDOWN) && wParam != VK_JUNJA)
        goto CNH;

    if (lpIMC->fOpen != FALSE)
        goto DoHook;

    if ((wParam != VK_HANGEUL && wParam != VK_JUNJA) || (HIWORD(lParam) & KF_UP))
        goto CNH;

    DoHook:
    for (iLoop = 0; iLoop < iIndexOfLevel; iLoop++)
        if (stSaveLevel[iLoop].hLevel == hWnd && stSaveLevel[iLoop].uLevel == 3)
            break;

    if (iLoop >= iIndexOfLevel)
        goto CNH;

    if (wParam == VK_PROCESSKEY)
        goto SendMsg;

    GetKeyboardState((LPBYTE)myIME.pbKeyState);
    myIME.wParam = wParam;
    myIME.lParam1 = lParam;
    myIME.pdwTransBuf[0] = 255/3;
    if (ImmEscape(hKL, hIMC, IME_ESC_AUTOMATA, (LPIMESTRUCT)&myIME) && myIME.wCount) {
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        StartStrSvr(lpIMC, lpCompStr, myIME.wCount, myIME.pdwTransBuf, FALSE);
        ImmUnlockIMCC(lpIMC->hCompStr, lpCompStr);
        ImmUnlockIMC(hIMC, lpIMC);
    }
    return 1;
    CNH:
    if (lpIMC)
        ImmUnlockIMC(hIMC, lpIMC);

    hTask = (hWnd)? GetWindowTask(hWnd): GetCurrentTask();
    for (iLoop = 0; iLoop < iIndexOfLevel; iLoop++)
        if (stSaveLevel[iLoop].hTask == hTask && IsTask(hTask))
            return CallNextHookEx(stSaveLevel[iLoop].hHook, iCode, wParam, lParam);
    return 0;
}
#endif

/**********************************************************************/
/* WINNLSTranslateMessageK()                                          */
/* translate messages for 3.1 apps
/* Return Value:                                                      */
/*      number of translated message                                  */
/**********************************************************************/
UINT WINNLSTranslateMessageK(int                 iNumMsg,
                             PTRANSMSG           pTransMsg,
                             LPINPUTCONTEXT      lpIMC,
                             LPCOMPOSITIONSTRING lpCompStr,
                             BOOL bAnsiIMC)
{
    HWND    hDefIMEWnd;
    int     i, j;
    static  BYTE bp1stInterim = 0;
    static  BYTE bp2ndInterim = 0;
    BOOL    bAnsiWnd;
    HWND    hWnd;
    WCHAR   wchUni;
    CHAR    chAnsi[2];
    BYTE    bchLow, bchHi, bCh;
    BOOL (WINAPI* fpPostMessage)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    LRESULT (WINAPI* fpSendMessage)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

    hWnd = (HWND)lpIMC->hWnd;

    hDefIMEWnd = ImmGetDefaultIMEWnd(hWnd);

    bAnsiWnd = !IsWindowUnicode(hWnd) ? TRUE : FALSE;
    if (bAnsiWnd) {
        fpPostMessage = PostMessageA;
        fpSendMessage = SendMessageA;
    } else {
        fpPostMessage = PostMessageW;
        fpSendMessage = SendMessageW;
    }

    for (i = 0; i < iNumMsg; i++) {

        switch (pTransMsg[i].message) {

        case WM_IME_COMPOSITION :

            if (pTransMsg[i].lParam & GCS_RESULTSTR) {

                fpPostMessage(hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L);

                for (j = 0; j < (int)lpCompStr->dwResultStrLen; j++) {
                    LPARAM  lParam = 1L;
                    bCh = 0;
                    if (bAnsiIMC) {
                        bCh = *((LPSTR)lpCompStr + lpCompStr->dwResultStrOffset + j);
                        if (bAnsiWnd) {
                            if (IsDBCSLeadByte(bCh)) {
                                lParam = (bCh >= 0xB0 && bCh <= 0xC8)? 0xFFF10001L: 0xFFF20001L;
                                PostMessageA(hWnd, WM_CHAR, bCh, lParam);
                                bCh = *((LPSTR)lpCompStr + lpCompStr->dwResultStrOffset + ++j);
                            }
                            PostMessageA(hWnd, WM_CHAR, bCh, lParam);
                        } else {
                            chAnsi[0] = bCh;
                            chAnsi[1] = *((LPSTR)lpCompStr + lpCompStr->dwResultStrOffset + ++j);

                            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, chAnsi, 2, &wchUni, 1);

                            PostMessageW(hWnd, WM_CHAR, wchUni, lParam);
                        }
                    } else {    // !bAnsiIMC
                        bCh = *((LPSTR)lpCompStr + lpCompStr->dwResultStrOffset + j * sizeof(WCHAR));
                        wchUni = bCh | ( *((LPSTR)lpCompStr + lpCompStr->dwResultStrOffset +
                                           (j * sizeof(WCHAR) + 1)) << 8);

                        if (bAnsiWnd) {
                            WideCharToMultiByte(CP_ACP, 0, &wchUni, 1, chAnsi, 2, NULL, NULL);

                            bchLow = chAnsi[0];
                            bchHi  = chAnsi[0]; //(BYTE)chAnsi;

                            if (IsDBCSLeadByte(bchLow)) {
                                lParam = (bchLow >= 0xB0 && bchLow <= 0xC8) ? 0xFFF10001L: 0xFFF20001L;
                                PostMessageA(hWnd, WM_CHAR, bchLow, lParam);
                                bchHi = chAnsi[1];
                            }

                            PostMessageA(hWnd, WM_CHAR, bchHi, lParam);
                        } else {
                            PostMessageW(hWnd, WM_CHAR, wchUni, lParam);
                        }
                    }
                }

                fpPostMessage(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);

            } else {    // !(pTransMsg[i].lParam & GCS_RESULTSTR)

                if (pTransMsg[i].wParam) {

                    fpPostMessage(hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L);

                    bp1stInterim = HIBYTE(LOWORD(pTransMsg[i].wParam));
                    bp2ndInterim = LOBYTE(LOWORD(pTransMsg[i].wParam));

                    if (bAnsiIMC) {
                        if (bAnsiWnd) {
                            PostMessageA(hWnd, WM_INTERIM, bp1stInterim, 0x00F00001L);
                            PostMessageA(hWnd, WM_INTERIM, bp2ndInterim, 0x00F00001L);
                            PostMessageA(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                        } else {
                            chAnsi[0] = bp1stInterim;
                            chAnsi[1] = bp2ndInterim;

                            if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, chAnsi, 2, &wchUni, 1))
                                PostMessageW(hWnd, WM_INTERIM, wchUni, 0x00F00001L);
                            PostMessageW(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                        }

                    } else {
                        if (bAnsiWnd) {
                            wchUni = (bp1stInterim << 8) | bp2ndInterim;  //(WORD)lpdwTransKey[i*3 + 1];
                            WideCharToMultiByte(CP_ACP, 0, &wchUni, 1, chAnsi, 2, NULL, NULL);

                            bchLow = chAnsi[0];
                            bchHi  = chAnsi[1];

                            PostMessageA(hWnd, WM_INTERIM, bchLow, 0x00F00001L);
                            PostMessageA(hWnd, WM_INTERIM, bchHi,  0x00F00001L);
                            PostMessageA(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                        } else {
                            PostMessageW(hWnd, WM_INTERIM, pTransMsg[i].wParam, 0x00F00001L);
                            PostMessageW(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                        }
                    }
                    fpSendMessage(hDefIMEWnd, WM_IME_ENDCOMPOSITION, 0, 0L);

                } else {    // !pTransMsg[i].wParam

                    fpPostMessage(hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L);

                    if (bAnsiIMC) {
                        if (bAnsiWnd) {
                            PostMessageA(hWnd, WM_CHAR, bp1stInterim, 0xFFF10001L);
                            PostMessageA(hWnd, WM_CHAR, bp2ndInterim, 0xFFF10001L);
                            PostMessageA(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                            PostMessageA(hWnd, WM_KEYDOWN, VK_BACK, 0x000E0001L);
                        } else {
                            chAnsi[0] = bp1stInterim;
                            chAnsi[1] = bp2ndInterim;

                            if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, chAnsi, 2, &wchUni, 1))
                                PostMessageW(hWnd, WM_CHAR, wchUni, 0xFFF10001L);

                            PostMessageW(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                            PostMessageW(hWnd, WM_KEYDOWN, VK_BACK, 0x000E0001L);
                        }
                    } else {    // !bAnsiIMC
                        if (bAnsiWnd) {
                            wchUni = (bp1stInterim << 8 ) | bp2ndInterim;

                            WideCharToMultiByte(CP_ACP, 0, &wchUni, 1, chAnsi, 2, NULL, NULL);

                            bchLow = chAnsi[0];
                            bchHi  = chAnsi[1];

                            PostMessageA(hWnd, WM_CHAR, bchLow, 0xFFF10001L);
                            PostMessageA(hWnd, WM_CHAR, bchHi,  0xFFF10001L);
                            PostMessageA(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                            PostMessageA(hWnd, WM_KEYDOWN, VK_BACK, 0x000E0001L);
                        } else {
                            wchUni = bp1stInterim | (bp2ndInterim << 8);

                            PostMessageW(hWnd, WM_CHAR, wchUni, 0xFFF10001L);
                            PostMessageW(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                            PostMessageW(hWnd, WM_KEYDOWN, VK_BACK, 0x000E0001L);
                        }
                    }
                }
            }
            break;

        case WM_IME_STARTCOMPOSITION :
        case WM_IME_ENDCOMPOSITION :
            break;

        case WM_IME_KEYDOWN:
            fpPostMessage(hWnd, WM_KEYDOWN, LOWORD(pTransMsg[i].wParam),
                          pTransMsg[i].lParam);
            break;

        case WM_IME_KEYUP:
            fpPostMessage(hWnd, WM_KEYUP, LOWORD(pTransMsg[i].wParam),
                          pTransMsg[i].lParam);
            break;

        default :
            fpSendMessage(hDefIMEWnd, pTransMsg[i].message,
                          pTransMsg[i].wParam, pTransMsg[i].lParam);
            break;
        }
    }

    return 0;   // indicates all messages are post/sent within this function.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\makefile.inc ===
$(PRIVLIB) $(PRIVLIB:.lib=.exp): \
!if "$(BUILD_PASS)" != "PASS2"
    $(LIBRARY_OBJS) \
!endif    
    $(O)\$(TARGETNAMEP).def
   -$(LIB_NAME) -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\$(TARGETNAMEP).def
$(LIBRARY_OBJS)
<<NOKEEP


C_DEFINES=$(C_DEFINES) -DPRIVATE=
$(O)\$(TARGETNAMEP).def: $(DLLDEF)
    $(C_PREPROCESSOR) $(DLLDEF) > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrdll.h>
#include <ntcsrsrv.h>
#define NONTOSPINTERLOCK
#include <ntosp.h>

#include <stdarg.h>
#include <stdio.h>
#include <excpt.h>
#include <string.h>
#include <limits.h>
#include "immcli.h"
#include <ntsdexts.h>
#include <stdlib.h>
#include <windowsx.h>
#include <newres.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\misc.c ===
/**************************************************************************\
* Module Name: misc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef HIRO_DEBUG
#define D(x)    x
#else
#define D(x)
#endif


/**************************************************************************\
* ImmGetDefaultIMEWnd
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

HWND WINAPI ImmGetDefaultIMEWnd(
    HWND hWnd)
{
    if (!IS_IME_ENABLED()) {
        return NULL;
    }
    if (hWnd == NULL) {
        /*
         * Query default IME window of current thread.
         */
        return (HWND)NtUserGetThreadState(UserThreadStateDefaultImeWindow);
    }

    return (HWND)NtUserQueryWindow(hWnd, WindowDefaultImeWindow);
}


/**************************************************************************\
* ImmDisableIME
*
* 13-Sep-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmDisableIME(DWORD dwThreadId)
{
#ifdef LATER    // hiro
    if (dwThreadId == -1) {
        // Unload all IMEs
        RtlEnterCriticalSection(&gcsImeDpi);
        while (gpImeDpi) {
            PIMEDPI pImeDpi = gpImeDpi;
            gpImeDpi = gpImeDpi->pNext;
            UnloadIME(pImeDpi, TRUE);
            ImmLocalFree(pImeDpi);
        }
        RtlLeaveCriticalSection(&gcsImeDpi);
    }
#endif
    return (BOOL)NtUserDisableThreadIme(dwThreadId);
}

/**************************************************************************\
* ImmIsUIMessageA
*
* Filter messages needed for IME window.
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmIsUIMessageA(
    HWND   hIMEWnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    return ImmIsUIMessageWorker(hIMEWnd, message, wParam, lParam, TRUE);
}


/**************************************************************************\
* ImmIsUIMessageW
*
* Filter messages needed for IME window.
*
* 29-Feb-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmIsUIMessageW(
    HWND   hIMEWnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    return ImmIsUIMessageWorker(hIMEWnd, message, wParam, lParam, FALSE);
}


/**************************************************************************\
* ImmIsUIMessageWorker
*
* Worker function of ImmIsUIMessageA/ImmIsUIMessageW.
*
* Return: True if message is processed by IME UI.
*         False otherwise.
*
* 29-Feb-1996 wkwok       Created
\**************************************************************************/

BOOL ImmIsUIMessageWorker(
    HWND   hIMEWnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL   fAnsi)
{
    D(DbgPrint("ImmIsUIMessageWorker(wnd[%08X], msg[%04X], wp[%08X], lp[%08X], Ansi[%d]\n",
      hIMEWnd, message, wParam, lParam, fAnsi));

    switch (message) {
    case WM_IME_STARTCOMPOSITION:
    case WM_IME_ENDCOMPOSITION:
    case WM_IME_COMPOSITION:
    case WM_IME_SETCONTEXT:
    case WM_IME_COMPOSITIONFULL:
    case WM_IME_SELECT:
    case WM_IME_NOTIFY:
    case WM_IME_SYSTEM:

        if (!hIMEWnd)
            return TRUE;

#if DBG
        if (!IsWindow(hIMEWnd)) {
            RIPMSG1(RIP_WARNING,
                  "ImmIsUIMessage: Invalid window handle %x", hIMEWnd);
            return FALSE;
        }
#endif

        if (fAnsi) {
            SendMessageA(hIMEWnd, message, wParam, lParam);
        }
        else {
            SendMessageW(hIMEWnd, message, wParam, lParam);
        }

        return TRUE;

    default:
        break;
    }

    return FALSE;
}


/**************************************************************************\
* ImmGenerateMessage
*
* Sends message(s) that are stored in hMsgBuf of hImc to hWnd of hImc.
*
* 29-Feb-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmGenerateMessage(
    HIMC hImc)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    PTRANSMSG     pTransMsg;
    INT           iNum;
    INT           i;
    BOOL          fUnicodeImc;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmGenerateMessage: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL)
        return FALSE;

    fUnicodeImc = TestICF(pClientImc, IMCF_UNICODE);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGenerateMessage: Lock hImc %lx failed.", hImc);
        return FALSE;
    }

    iNum = (int)pInputContext->dwNumMsgBuf;

    if (iNum && (pTransMsg = (PTRANSMSG)ImmLockIMCC(pInputContext->hMsgBuf))) {
        PTRANSMSG pTransMsgBuf, pTransMsgTemp;

        pTransMsgBuf = (PTRANSMSG)ImmLocalAlloc(0, iNum * sizeof(TRANSMSG));

        if (pTransMsgBuf != NULL) {

            RtlCopyMemory(pTransMsgBuf, pTransMsg, iNum * sizeof(TRANSMSG));

            if (GetClientInfo()->dwExpWinVer < VER40) {
                /*
                 * translate messages for those applications that expect
                 * old style IME messages.
                 */
                DWORD dwLangId;
                dwLangId = PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID()));
                if ( (dwLangId == LANG_KOREAN && TransGetLevel(pInputContext->hWnd) == 3) ||
                     (dwLangId == LANG_JAPANESE) ) {
                    iNum = WINNLSTranslateMessage(iNum,
                                                  pTransMsgBuf,
                                                  hImc,
                                                  !fUnicodeImc,
                                                  dwLangId );
                }
            }

            pTransMsgTemp = pTransMsgBuf;

            for (i = 0; i < iNum; i++) {
                if (fUnicodeImc) {
                    SendMessageW( pInputContext->hWnd,
                                  pTransMsgTemp->message,
                                  pTransMsgTemp->wParam,
                                  pTransMsgTemp->lParam );
                } else {
                    SendMessageW( pInputContext->hWnd,
                                  pTransMsgTemp->message,
                                  pTransMsgTemp->wParam,
                                  pTransMsgTemp->lParam );
                }
                pTransMsgTemp++;
            }

            ImmLocalFree(pTransMsgBuf);
        }

        ImmUnlockIMCC(pInputContext->hMsgBuf);
    }

    /*
     * We should not reallocate the message buffer
     */
    pInputContext->dwNumMsgBuf = 0L;

    ImmUnlockIMC(hImc);

    return TRUE;
}


#ifdef CUAS_ENABLE
BOOL WINAPI CtfImmGenerateMessage(
    HIMC hImc,
    BOOL fSendMsg)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    PTRANSMSG     pTransMsg;
    INT           iNum;
    INT           i;
    BOOL          fUnicodeImc;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmGenerateMessage: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL)
        return FALSE;

    fUnicodeImc = TestICF(pClientImc, IMCF_UNICODE);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGenerateMessage: Lock hImc %lx failed.", hImc);
        return FALSE;
    }

    iNum = (int)pInputContext->dwNumMsgBuf;

    if (iNum && (pTransMsg = (PTRANSMSG)ImmLockIMCC(pInputContext->hMsgBuf))) {
        PTRANSMSG pTransMsgBuf, pTransMsgTemp;

        pTransMsgBuf = (PTRANSMSG)ImmLocalAlloc(0, iNum * sizeof(TRANSMSG));

        if (pTransMsgBuf != NULL) {

            RtlCopyMemory(pTransMsgBuf, pTransMsg, iNum * sizeof(TRANSMSG));

            pTransMsgTemp = pTransMsgBuf;

            for (i = 0; i < iNum; i++) {
                if (fSendMsg)
                {
                    if (fUnicodeImc) {
                        SendMessageW( pInputContext->hWnd,
                                      pTransMsgTemp->message,
                                      pTransMsgTemp->wParam,
                                      pTransMsgTemp->lParam );
                    } else {
                        SendMessageA( pInputContext->hWnd,
                                      pTransMsgTemp->message,
                                      pTransMsgTemp->wParam,
                                      pTransMsgTemp->lParam );
                    }
                }
                else
                {
                    if (fUnicodeImc) {
                        PostMessageW( pInputContext->hWnd,
                                      pTransMsgTemp->message,
                                      pTransMsgTemp->wParam,
                                      pTransMsgTemp->lParam );
                    } else {
                        PostMessageA( pInputContext->hWnd,
                                      pTransMsgTemp->message,
                                      pTransMsgTemp->wParam,
                                      pTransMsgTemp->lParam );
                    }
                }
                pTransMsgTemp++;
            }

            ImmLocalFree(pTransMsgBuf);
        }

        ImmUnlockIMCC(pInputContext->hMsgBuf);
    }

    /*
     * We should not reallocate the message buffer
     */
    pInputContext->dwNumMsgBuf = 0L;

    ImmUnlockIMC(hImc);

    return TRUE;
}
#endif // CUAS_ENABLE


/**************************************************************************\
* ImmGetVirtualKey
*
* Gets the actual virtual key which is preprocessed by an IME.
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

UINT WINAPI ImmGetVirtualKey(
    HWND hWnd)
{
    HIMC          hImc;
    PINPUTCONTEXT pInputContext;
    UINT          uVirtKey;

    hImc = ImmGetContext(hWnd);

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGetVirtualKey: lock IMC %x failure", hImc);
        return (VK_PROCESSKEY);
    }

    if (pInputContext->fChgMsg) {
        uVirtKey = pInputContext->uSavedVKey;
    } else {
        uVirtKey = VK_PROCESSKEY;
    }

    ImmUnlockIMC(hImc);
    return (uVirtKey);
}


/**************************************************************************\
* ImmLockIMC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

PINPUTCONTEXT WINAPI InternalImmLockIMC(
    HIMC hImc,
    BOOL fCanCallImeSelect)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    DWORD         dwImcThreadId;

    if ((pClientImc = ImmLockClientImc(hImc)) == NULL)
        return NULL;

    EnterImcCrit(pClientImc);

    if (pClientImc->hInputContext == NULL) {

#ifdef CUAS_ENABLE
        dwImcThreadId = (DWORD)NtUserQueryInputContext(hImc, InputContextThread);
#endif // CUAS_ENABLE

#ifdef CUAS_ENABLE

        if (dwImcThreadId == GetCurrentThreadId() &&
           IS_CICERO_ENABLED_AND_NOT16BIT()) {
            /*
             * Cicero IME. Activate Thread Input Manager.
             */
            PIMEDPI pImeDpi;
            LANGID  lg = LOWORD(HandleToUlong(GetKeyboardLayout(0)));
            DWORD   dwKL = MAKELONG(lg, lg);

            pImeDpi = FindOrLoadImeDpi(UlongToHandle(dwKL));
            if (pImeDpi == NULL) {
                RIPMSG0(RIP_WARNING, "InternalImmLockIMC: no pImeDpi entry.");
            }
            else
            {
                /*
                 * Activate TIM
                 *   For this call, CTFIME's tim->Activate retreive TfClientId value
                 *   when user32!LoadThreadLayout calls ImmTIMActivate with non-IME hKL.
                 *   Because tim->Activate calls keyboard layout change and it occurred
                 *   InternalImmLockIMC via IMS_ACTIVATETHREADLAYOUT.
                 *   Also this hIMC is used at first time.
                 *   In this case, this code block calls ImmTIMCreateInputContext and
                 *   create IC by dim->CreateContext(TfClientId).
                 *   If this code is disabled, TfClientId is not yet ready and
                 *   doesn't create IC.
                 */
                CtfImmTIMActivate(UlongToHandle(dwKL));
            }
        }
#endif // CUAS_ENABLE

        /*
         * If the owner thread of this hImc does not have
         * default IME window, don't bother to create the
         * INPUTCONTEXT. It could happen when some other
         * thread which call ImmGetContext() to retrieve
         * the associate hImc before the default IME window
         * is created.
         */
        if ((HWND)NtUserQueryInputContext(hImc,
                InputContextDefaultImeWindow) == NULL) {
            LeaveImcCrit(pClientImc);
            ImmUnlockClientImc(pClientImc);
            return NULL;
        }

        /*
         * This is a delay creation of INPUTCONTEXT structure. Create
         * it now for this hImc.
         */
        pClientImc->hInputContext = LocalAlloc(LHND, sizeof(INPUTCONTEXT));

        if (pClientImc->hInputContext == NULL) {
            LeaveImcCrit(pClientImc);
            ImmUnlockClientImc(pClientImc);
            return NULL;
        }

#ifndef CUAS_ENABLE
        dwImcThreadId = (DWORD)NtUserQueryInputContext(hImc, InputContextThread);
#endif // CUAS_ENABLE

        if (!CreateInputContext(hImc, GetKeyboardLayout(dwImcThreadId), fCanCallImeSelect)) {
            RIPMSG0(RIP_WARNING, "ImmLockIMC: CreateInputContext failed");
            LocalFree(pClientImc->hInputContext);
            pClientImc->hInputContext = NULL;
            LeaveImcCrit(pClientImc);
            ImmUnlockClientImc(pClientImc);
            return NULL;
        }
    }

#ifdef CUAS_ENABLE
    /*
     * Create Cicero Input Context.
     */
    CtfImmTIMCreateInputContext(hImc);
#endif // CUAS_ENABLE


    LeaveImcCrit(pClientImc);

    pInputContext = (PINPUTCONTEXT)LocalLock(pClientImc->hInputContext);

    /*
     * Increment lock count so that the ImmUnlockClientImc() won't
     * free up the pClientImc->hInputContext.
     */
    InterlockedIncrement(&pClientImc->cLockObj);


    ImmUnlockClientImc(pClientImc);

    return pInputContext;
}

PINPUTCONTEXT WINAPI ImmLockIMC(
    HIMC hImc)
{
    return InternalImmLockIMC(hImc, TRUE);
}

/**************************************************************************\
* ImmUnlockIMC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmUnlockIMC(
    HIMC hImc)
{
    PCLIENTIMC pClientImc;

    if ((pClientImc = ImmLockClientImc(hImc)) == NULL)
        return FALSE;

    if (pClientImc->hInputContext != NULL)
        LocalUnlock(pClientImc->hInputContext);

    /*
     * Decrement lock count so that the ImmUnlockClientImc() can
     * free up the pClientImc->hInputContext if required.
     */
    InterlockedDecrement(&pClientImc->cLockObj);

    ImmUnlockClientImc(pClientImc);

    return TRUE;
}


/**************************************************************************\
* ImmGetIMCLockCount
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

DWORD WINAPI ImmGetIMCLockCount(
    HIMC hImc)
{
    PCLIENTIMC pClientImc;
    DWORD      dwRet = 0;

    if ((pClientImc = ImmLockClientImc(hImc)) == NULL)
        return dwRet;

    if (pClientImc->hInputContext != NULL)
        dwRet = (DWORD)(LocalFlags(pClientImc->hInputContext) & LMEM_LOCKCOUNT);

    ImmUnlockClientImc(pClientImc);

    return dwRet;
}


/**************************************************************************\
* ImmCreateIMCC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

HIMCC WINAPI ImmCreateIMCC(
    DWORD dwSize)
{
    // At least size should be DWORD.
    if (dwSize < sizeof(DWORD)) {
        dwSize = sizeof(DWORD);
    }

    return (HIMCC)LocalAlloc(LHND, dwSize);
}


/**************************************************************************\
* ImmDestroyIMCC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

HIMCC WINAPI ImmDestroyIMCC(
    HIMCC hIMCC)
{
    if (hIMCC == NULL) {
        return NULL;
    }

    return (HIMCC)LocalFree(hIMCC);
}


/**************************************************************************\
* ImmLockIMCC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

LPVOID WINAPI ImmLockIMCC(
    HIMCC hIMCC)
{
    if (hIMCC == NULL) {
        return NULL;
    }

    return LocalLock(hIMCC);
}


/**************************************************************************\
* ImmUnlockIMCC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmUnlockIMCC(
    HIMCC hIMCC)
{
    if (hIMCC == NULL) {
        return FALSE;
    }

    return LocalUnlock(hIMCC);
}


/**************************************************************************\
* ImmGetIMCCLockCount
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

DWORD WINAPI ImmGetIMCCLockCount(
    HIMCC hIMCC)
{
    if (hIMCC == NULL) {
        return 0;
    }

    return (DWORD)(LocalFlags(hIMCC) & LMEM_LOCKCOUNT);
}


/**************************************************************************\
* ImmReSizeIMCC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

HIMCC WINAPI ImmReSizeIMCC(
    HIMCC hIMCC,
    DWORD dwSize)
{
    if (hIMCC == NULL) {
        return NULL;
    }

    return (HIMCC)LocalReAlloc(hIMCC, dwSize, LHND);
}


/**************************************************************************\
* ImmGetIMCCSize
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

DWORD WINAPI ImmGetIMCCSize(
    HIMCC hIMCC)
{
    if (hIMCC == NULL) {
        return 0;
    }

    return (DWORD)LocalSize(hIMCC);
}


/**************************************************************************\
* ImmLocalAlloc
*
* 18-Jun-1996 wkwok       Created
\**************************************************************************/

LPVOID ImmLocalAlloc(
    DWORD uFlag,
    DWORD uBytes)
{
    if (pImmHeap == NULL) {
        pImmHeap = RtlProcessHeap();
        if (pImmHeap == NULL) {
            RIPMSG0(RIP_WARNING, "ImmLocalAlloc: NULL pImmHeap!");
            return NULL;
        }
    }

    return HeapAlloc(pImmHeap, uFlag, uBytes);
}


/***************************************************************************\
* PtiCurrent
*
* Returns the THREADINFO structure for the current thread.
* LATER: Get DLL_THREAD_ATTACH initialization working right and we won't
*        need this connect code.
*
* History:
* 10-28-90 DavidPe      Created.
* 02-21-96 wkwok        Copied from USER32.DLL
\***************************************************************************/

PTHREADINFO PtiCurrent(VOID)
{
    ConnectIfNecessary(0);
    return (PTHREADINFO)NtCurrentTebShared()->Win32ThreadInfo;
}


/**************************************************************************\
* TestInputContextProcess
*
* 02-21-96 wkwok        Created
\**************************************************************************/

BOOL TestInputContextProcess(
    PIMC pImc)
{
    /*
     * If the threads are the same, don't bother going to the kernel
     * to get the input context's process id.
     */
    if (GETPTI(pImc) == PtiCurrent()) {
        return TRUE;
    }

    return (GetInputContextProcess(PtoH(pImc)) == GETPROCESSID());
}

/**************************************************************************\
* TestWindowProcess
*
* 11-14-94 JimA         Created.
* 02-29-96 wkwok        Copied from USER32.DLL
\**************************************************************************/

BOOL TestWindowProcess(
    PWND pwnd)
{
    /*
     * If the threads are the same, don't bother going to the kernel
     * to get the window's process id.
     */
    if (GETPTI(pwnd) == PtiCurrent()) {
        return TRUE;
    }

    return (GetWindowProcess(HW(pwnd)) == GETPROCESSID());
}


/**************************************************************************\
* GetKeyboardLayoutCP
*
* 12-Mar-1996 wkwok       Created
\**************************************************************************/

static LCID CachedLCID = 0;
static UINT CachedCP = CP_ACP;

UINT GetKeyboardLayoutCP(
    HKL hKL)
{
    #define LOCALE_CPDATA 7
    WCHAR wszCodePage[LOCALE_CPDATA];
    LCID  lcid;

    lcid = MAKELCID(LOWORD(HandleToUlong(hKL)), SORT_DEFAULT);

    if (lcid == CachedLCID)
        return CachedCP;

    if (!GetLocaleInfoW(lcid, LOCALE_IDEFAULTANSICODEPAGE,
                wszCodePage, LOCALE_CPDATA))
        return CP_ACP;

    CachedLCID = lcid;
    CachedCP = (UINT)wcstol(wszCodePage, NULL, 10);

    return CachedCP;
}


/**************************************************************************\
* GetKeyboardLayoutCP
*
* 12-Mar-1996 wkwok       Created
\**************************************************************************/

UINT GetThreadKeyboardLayoutCP(
    DWORD dwThreadId)
{
    HKL hKL;

    hKL = GetKeyboardLayout(dwThreadId);

    return GetKeyboardLayoutCP(hKL);
}


/**************************************************************************\
* ImmLockClientImc
*
* 13-Mar-1996 wkwok       Created
\**************************************************************************/

PCLIENTIMC WINAPI ImmLockClientImc(
    HIMC hImc)
{
    PIMC       pImc;
    PCLIENTIMC pClientImc;

    if (hImc == NULL_HIMC)
        return NULL;

    pImc = HMValidateHandle((HANDLE)hImc, TYPE_INPUTCONTEXT);

    /*
     * Cannot access input context from other process.
     */
    if (pImc == NULL || !TestInputContextProcess(pImc))
        return NULL;

    pClientImc = (PCLIENTIMC)pImc->dwClientImcData;

    if (pClientImc == NULL) {
        /*
         * We delay the creation of client side per-thread default Imc.
         * Now, this is the time to create it.
         */
        pClientImc = ImmLocalAlloc(HEAP_ZERO_MEMORY, sizeof(CLIENTIMC));
        if (pClientImc == NULL)
            return NULL;

        InitImcCrit(pClientImc);
        pClientImc->dwImeCompatFlags = (DWORD)NtUserGetThreadState(UserThreadStateImeCompatFlags);

        /*
         * Update the kernel side input context.
         */
        if (!NtUserUpdateInputContext(hImc,
                UpdateClientInputContext, (ULONG_PTR)pClientImc)) {
            ImmLocalFree(pClientImc);
            return NULL;
        }

        /*
         * Marks with default input context signature.
         */
        SetICF(pClientImc, IMCF_DEFAULTIMC);
    }
    else if (TestICF(pClientImc, IMCF_INDESTROY)) {
        /*
         * Cannot access destroyed input context.
         */
        return NULL;
    }

    InterlockedIncrement(&pClientImc->cLockObj);

    return pClientImc;
}


VOID WINAPI ImmUnlockClientImc(
    PCLIENTIMC pClientImc)
{
    if (InterlockedDecrement(&pClientImc->cLockObj) == 0) {
        if (TestICF(pClientImc, IMCF_INDESTROY)) {
            if (pClientImc->hInputContext != NULL)
                LocalFree(pClientImc->hInputContext);

            DeleteImcCrit(pClientImc);
            ImmLocalFree(pClientImc);
        }
    }

    return;
}

/**************************************************************************\
* ImmGetImeDpi
*
* 08-Jan-1996 wkwok       Created
\**************************************************************************/

PIMEDPI WINAPI ImmGetImeDpi(
    HKL hKL)
{
    PIMEDPI pImeDpi;

    RtlEnterCriticalSection(&gcsImeDpi);

    pImeDpi = gpImeDpi;

    while (pImeDpi != NULL && pImeDpi->hKL != hKL)
        pImeDpi = pImeDpi->pNext;

    RtlLeaveCriticalSection(&gcsImeDpi);

    return (PIMEDPI)pImeDpi;
}


/**************************************************************************\
* ImmLockImeDpi
*
* 08-Jan-1996 wkwok       Created
\**************************************************************************/

PIMEDPI WINAPI ImmLockImeDpi(
    HKL hKL)
{
    PIMEDPI pImeDpi;

    RtlEnterCriticalSection(&gcsImeDpi);

    pImeDpi = gpImeDpi;

    while (pImeDpi != NULL && pImeDpi->hKL != hKL)
        pImeDpi = pImeDpi->pNext;

    if (pImeDpi != NULL) {
        if (pImeDpi->dwFlag & IMEDPI_UNLOADED)
            pImeDpi = NULL;
        else
            pImeDpi->cLock++;
    }

    RtlLeaveCriticalSection(&gcsImeDpi);

    return (PIMEDPI)pImeDpi;
}


/**************************************************************************\
* ImmUnlockImeDpi
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

VOID WINAPI ImmUnlockImeDpi(
    PIMEDPI pImeDpi)
{
    PIMEDPI pImeDpiT;

    if (pImeDpi == NULL)
        return;

    RtlEnterCriticalSection(&gcsImeDpi);

    if (--pImeDpi->cLock == 0) {

        if ((pImeDpi->dwFlag & IMEDPI_UNLOADED) ||
            ((pImeDpi->dwFlag & IMEDPI_UNLOCKUNLOAD) &&
             (pImeDpi->ImeInfo.fdwProperty & IME_PROP_END_UNLOAD)))
        {
            /*
             * Unlink it.
             */
            if (gpImeDpi == pImeDpi) {
                gpImeDpi = pImeDpi->pNext;
            }
            else {
                pImeDpiT = gpImeDpi;

                while (pImeDpiT != NULL && pImeDpiT->pNext != pImeDpi)
                    pImeDpiT = pImeDpiT->pNext;

                if (pImeDpiT != NULL)
                    pImeDpiT->pNext = pImeDpi->pNext;
            }

            /*
             * Unload the IME DLL.
             */
            UnloadIME(pImeDpi, TRUE);
            ImmLocalFree(pImeDpi);
        }
    }

    RtlLeaveCriticalSection(&gcsImeDpi);

    return;
}


/**************************************************************************\
* ImmGetImeInfoEx
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmGetImeInfoEx(
    PIMEINFOEX piiex,
    IMEINFOEXCLASS SearchType,
    PVOID pvSearchKey)
{
#if defined(CUAS_ENABLE)
    BOOL fCUAS_OFF = FALSE;
#endif
    ImmAssert(piiex != NULL && pvSearchKey != NULL);

    switch (SearchType) {
#if defined(CUAS_ENABLE)
    case ImeInfoExKeyboardLayoutWithCUAS:
        fCUAS_OFF = CtfImmIsTextFrameServiceDisabled();
        SearchType = ImeInfoExKeyboardLayout;
#endif
    case ImeInfoExKeyboardLayout:
        piiex->hkl = *((HKL *)pvSearchKey);
        /*
         * Quick return for non-IME based keyboard layout
         */
#if !defined(CUAS_ENABLE)
        if (!IS_IME_KBDLAYOUT(piiex->hkl))
            return FALSE;
#else
        if (! IS_IME_KBDLAYOUT(piiex->hkl) &&
            (! IS_CICERO_ENABLED_AND_NOT16BIT() || fCUAS_OFF))
            return FALSE;
#endif
        break;

    case ImeInfoExImeFileName:

        wcsncpy(piiex->wszImeFile, (PWSTR)pvSearchKey, IM_FILE_SIZE-1);
        piiex->wszImeFile[IM_FILE_SIZE - 1] = L'\0';

        break;

    default:
        return FALSE;
    }

    return NtUserGetImeInfoEx(piiex, SearchType);
}

/**************************************************************************\
* ImmGetAppCompatFlags
*
* private function
* returns Win95 compatible IME Compatibility flags
*
* 02-July-1996 takaok       Created
\**************************************************************************/
DWORD ImmGetAppCompatFlags( HIMC hImc )
{
    PCLIENTIMC    pClientImc;
    DWORD         dwImeCompat = 0;

    pClientImc = ImmLockClientImc( hImc );
    if ( pClientImc != NULL ) {
        dwImeCompat = pClientImc->dwImeCompatFlags;
        ImmUnlockClientImc( pClientImc );
    }
#ifdef CUAS_ENABLE
    dwImeCompat |= g_aimm_compat_flags;
#endif // CUAS_ENABLE
    return dwImeCompat;
}

/**************************************************************************\
* ImmPtInRect
*
* private function
*
* 02-July-1997 hiroyama     Created
\**************************************************************************/

BOOL ImmPtInRect(
    int left,
    int top,
    int width,
    int height,
    LPPOINT lppt)
{
    return (lppt->x >= left && lppt->x < (left + width) &&
            lppt->y >= top  && lppt->y < (top + height));
}


/**************************************************************************\
* ImmSystemHandler
*
* private function
*
* IMM bulk helper to handle WM_IME_SYSTEM message
*
* 02-July-1997 hiroyama     Created
\**************************************************************************/

LRESULT ImmSystemHandler(
    HIMC hImc,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT lRet = 0;

    switch (wParam) {
    case IMS_SENDNOTIFICATION:
        ImmSendNotification((BOOL)lParam);
        break;
    case IMS_FINALIZE_COMPSTR:
        ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
        break;
#ifdef CUAS_ENABLE
    case IMS_SETLANGBAND:
    case IMS_RESETLANGBAND:
        lRet = CtfImmSetLangBand((HWND)lParam, wParam == IMS_SETLANGBAND ? TRUE : FALSE);
        break;
#endif // CUAS_ENABLE
    }

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\sftkbdc1.c ===
/**************************************************************************\
* Module Name: sftkbdc1.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Softkeyboard support for Simplified Chinese
*
* History:
* 03-Jan-1996 wkwok    Ported from Win95
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "softkbd.h"

// Virtual Key for Letter Buttons
CONST BYTE SKC1VirtKey[BUTTON_NUM_C1] = {
   VK_OEM_3, '1', '2', '3', '4', '5', '6','7', '8', '9', '0', VK_OEM_MINUS, VK_OEM_EQUAL,
   'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', VK_OEM_LBRACKET, VK_OEM_RBRACKET, VK_OEM_BSLASH,
   'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', VK_OEM_SEMICLN, VK_OEM_QUOTE,
   'Z', 'X', 'C', 'V', 'B', 'N', 'M', VK_OEM_COMMA, VK_OEM_PERIOD, VK_OEM_SLASH,
   VK_BACK, VK_TAB, VK_CAPITAL, VK_RETURN, VK_SHIFT, VK_INSERT, VK_DELETE, VK_SPACE,
   VK_ESCAPE
};

POINT gptButtonPos[BUTTON_NUM_C1]; // button point array, in the client area
BOOL  gfSoftKbdC1Init = FALSE;              // init flag

/**********************************************************************\
* InitSKC1ButtonPos -- init gptButtonPos
*
\**********************************************************************/
VOID InitSKC1ButtonPos()
{
    int  i, x, y;

    // init the first row
    y = 0;
    for (i=0, x=X_ROW_LETTER_C1; i < COL_LETTER_C1; i++, x += W_LETTER_BTN_C1) {
      gptButtonPos[i].x = x;
      gptButtonPos[i].y = y;
    }
    gptButtonPos[BACKSP_TYPE_C1].x = x;
    gptButtonPos[BACKSP_TYPE_C1].y = y;

    // init the second row
    y += H_LETTER_BTN_C1;
    x = 0;
    gptButtonPos[TAB_TYPE_C1].x = x;
    gptButtonPos[TAB_TYPE_C1].y = y;
    for (i=0, x=X_ROW2_LETTER_C1; i < COL2_LETTER_C1; i++, x += W_LETTER_BTN_C1) {
      gptButtonPos[i + COL_LETTER_C1].x = x;
      gptButtonPos[i + COL_LETTER_C1].y = y;
    }

    // init the third row
    y += H_LETTER_BTN_C1;
    x = 0;
    gptButtonPos[CAPS_TYPE_C1].x = x;
    gptButtonPos[CAPS_TYPE_C1].y = y;
    for (i=0, x=X_ROW3_LETTER_C1; i < COL3_LETTER_C1; i++, x += W_LETTER_BTN_C1) {
      gptButtonPos[i + COL_LETTER_C1 + COL2_LETTER_C1].x = x;
      gptButtonPos[i + COL_LETTER_C1 + COL2_LETTER_C1].y = y;
    }
    gptButtonPos[ENTER_TYPE_C1].x = x;
    gptButtonPos[ENTER_TYPE_C1].y = y;

    // init the forth row
    y += H_LETTER_BTN_C1;
    x = 0;
    gptButtonPos[SHIFT_TYPE_C1].x = x;
    gptButtonPos[SHIFT_TYPE_C1].y = y;
    for (i=0, x=X_ROW4_LETTER_C1; i < COL4_LETTER_C1; i++, x += W_LETTER_BTN_C1) {
      gptButtonPos[i + COL_LETTER_C1 + COL2_LETTER_C1 + COL3_LETTER_C1].x = x;
      gptButtonPos[i + COL_LETTER_C1 + COL2_LETTER_C1 + COL3_LETTER_C1].y = y;
    }

    // init the bottom row
    y += H_LETTER_BTN_C1;
    x = 0;
    gptButtonPos[INS_TYPE_C1].x = x;
    gptButtonPos[INS_TYPE_C1].y = y;
    x = X_DEL_C1;
    gptButtonPos[DEL_TYPE_C1].x = x;
    gptButtonPos[DEL_TYPE_C1].y = y;
    x += W_DEL_C1 + 2 * BORDER_C1;
    gptButtonPos[SPACE_TYPE_C1].x = x;
    gptButtonPos[SPACE_TYPE_C1].y = y;
    x = X_ESC_C1;
    gptButtonPos[ESC_TYPE_C1].x = x;
    gptButtonPos[ESC_TYPE_C1].y = y;

    return;
}


/**********************************************************************\
* SKC1DrawConvexRect --- draw button
*
*              (x1,y1)     x2-1
*               +----3------>^
*               |+----3-----||y1+1
*               ||          ||
*               33    1     42
*               ||          ||
*               |V          ||
*               |<----4-----+|
*         y2-1  ------2------+
*                             (x2,y2)
*
*  1 - light gray
*  2 - black
*  3 - white
*  4 - dark gray
*
\**********************************************************************/
VOID SKC1DrawConvexRect(
    HDC  hDC,
    int  x,
    int  y,
    int  nWidth,
    int  nHeight)
{
    // paint background
    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));
    SelectObject(hDC, GetStockObject(BLACK_PEN));
    Rectangle(hDC, x, y, x + nWidth, y + nHeight);

    // paint white border
    SelectObject(hDC, GetStockObject(WHITE_BRUSH));
    PatBlt(hDC, x, y + nHeight - 1, BORDER_C1, -nHeight + 1, PATCOPY);
    PatBlt(hDC, x, y, nWidth - 1 , BORDER_C1, PATCOPY);

    // paint dark gray border
    SelectObject(hDC, GetStockObject(GRAY_BRUSH));
    PatBlt(hDC, x + 1, y + nHeight -1, nWidth - BORDER_C1, -1, PATCOPY);
    PatBlt(hDC, x + nWidth - 1, y + nHeight - 1, -1, -nHeight + BORDER_C1, PATCOPY);

    return;
}


/**********************************************************************\
* SKC1InvertButton --- Invert Button
*
\**********************************************************************/
VOID SKC1InvertButton(
    HDC  hDC,
    int  uKeyIndex)
{
    int  nWidth, nHeight;

    if (uKeyIndex < 0) return;

    if (uKeyIndex < LETTER_NUM_C1) {
      nWidth = W_LETTER_BTN_C1;
      nHeight = H_LETTER_BTN_C1;
    } else {
      switch (uKeyIndex) {
        case BACKSP_TYPE_C1:
             nWidth = W_BACKSP_C1 + 2 * BORDER_C1;
             nHeight = H_LETTER_BTN_C1;
             break;
        case TAB_TYPE_C1:
             nWidth = W_TAB_C1 + 2 * BORDER_C1;
             nHeight = H_LETTER_BTN_C1;
             break;
        case CAPS_TYPE_C1:
             nWidth = W_CAPS_C1 + 2 * BORDER_C1;
             nHeight = H_LETTER_BTN_C1;
             break;
        case ENTER_TYPE_C1:
             nWidth = W_ENTER_C1 + 2 * BORDER_C1;
             nHeight = H_LETTER_BTN_C1;
             break;
        case SHIFT_TYPE_C1:
             nWidth = W_SHIFT_C1 + 2 * BORDER_C1;
             nHeight = H_LETTER_BTN_C1;
             break;
        case INS_TYPE_C1:
             nWidth = W_INS_C1 + 2 * BORDER_C1;
             nHeight = H_BOTTOM_BTN_C1;
             break;
        case DEL_TYPE_C1:
             nWidth = W_DEL_C1 + 2 * BORDER_C1;
             nHeight = H_BOTTOM_BTN_C1;
             break;
        case SPACE_TYPE_C1:
             nWidth = W_SPACE_C1 + 2 * BORDER_C1;
             nHeight = H_BOTTOM_BTN_C1;
             break;
        case ESC_TYPE_C1:
             nWidth = W_ESC_C1 + 2 * BORDER_C1;
             nHeight = H_BOTTOM_BTN_C1;
             break;
      }
    }

    BitBlt(hDC, gptButtonPos[uKeyIndex].x, gptButtonPos[uKeyIndex].y,
           nWidth, nHeight, hDC, gptButtonPos[uKeyIndex].x , gptButtonPos[uKeyIndex].y,
           DSTINVERT);

    return;
}


/**********************************************************************\
* SKC1DrawBitmap --- Draw bitmap within rectangle
*
\**********************************************************************/
VOID SKC1DrawBitmap(
    HDC hDC,
    int x,
    int y,
    int nWidth,
    int nHeight,
    LPWSTR lpszBitmap)
{
    HDC     hMemDC;
    HBITMAP hBitmap, hOldBmp;

    hBitmap = LoadBitmap(ghInst, lpszBitmap);
    hMemDC = CreateCompatibleDC(hDC);
    hOldBmp = SelectObject(hMemDC, hBitmap);

    BitBlt(hDC, x, y, nWidth, nHeight, hMemDC, 0 , 0, SRCCOPY);

    SelectObject(hMemDC, hOldBmp);
    DeleteDC(hMemDC);
    DeleteObject(hBitmap);

    return;
}


/**********************************************************************\
* SKC1DrawLabel -- Draw the label of button
*
\**********************************************************************/
VOID SKC1DrawLabel(
    HDC hDC,
    LPWSTR lpszLabel)
{
    HDC     hMemDC;
    HBITMAP hBitmap, hOldBmp;
    int     i, x;

    hBitmap = LoadBitmap(ghInst, lpszLabel);
    hMemDC = CreateCompatibleDC(hDC);
    hOldBmp = SelectObject(hMemDC, hBitmap);

    for (i=x=0; i < LETTER_NUM_C1; i++, x += SIZELABEL_C1){
     BitBlt(hDC, gptButtonPos[i].x + X_LABEL_C1, gptButtonPos[i].y + Y_LABEL_C1,
            SIZELABEL_C1, SIZELABEL_C1, hMemDC, x , 0, SRCCOPY);
    }

    SelectObject(hMemDC, hOldBmp);
    DeleteDC(hMemDC);
    DeleteObject(hBitmap);

    return;
}


/**********************************************************************\
* InitSKC1Bitmap -- init bitmap
*
\**********************************************************************/
VOID InitSKC1Bitmap(
    HDC  hDC,
    RECT rcClient)
{
    int  i;

    // draw softkbd rectangle
    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));
    SelectObject(hDC, GetStockObject(NULL_PEN));
    Rectangle(hDC, rcClient.left, rcClient.top, rcClient.right + 1, rcClient.bottom + 1);

    // draw letter buttons
    for (i = 0; i < LETTER_NUM_C1; i++) {
      SKC1DrawConvexRect(hDC, gptButtonPos[i].x, gptButtonPos[i].y,
                         W_LETTER_BTN_C1, H_LETTER_BTN_C1);
    }
    // draw letter label
    SKC1DrawLabel(hDC, MAKEINTRESOURCEW(LABEL_C1));

    // draw other buttons
    SKC1DrawConvexRect(hDC, gptButtonPos[BACKSP_TYPE_C1].x, gptButtonPos[BACKSP_TYPE_C1].y,
                       W_BACKSP_C1 + 2 * BORDER_C1, H_LETTER_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[BACKSP_TYPE_C1].x + BORDER_C1, gptButtonPos[BACKSP_TYPE_C1].y + BORDER_C1,
                   W_BACKSP_C1, H_BACKSP_C1, MAKEINTRESOURCEW(BACKSP_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[TAB_TYPE_C1].x, gptButtonPos[TAB_TYPE_C1].y,
                       W_TAB_C1 + 2 * BORDER_C1, H_LETTER_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[TAB_TYPE_C1].x + BORDER_C1, gptButtonPos[TAB_TYPE_C1].y + BORDER_C1,
                   W_TAB_C1, H_TAB_C1, MAKEINTRESOURCEW(TAB_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[CAPS_TYPE_C1].x, gptButtonPos[CAPS_TYPE_C1].y,
                       W_CAPS_C1 + 2 * BORDER_C1, H_LETTER_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[CAPS_TYPE_C1].x + BORDER_C1, gptButtonPos[CAPS_TYPE_C1].y + BORDER_C1,
                   W_CAPS_C1, H_CAPS_C1, MAKEINTRESOURCEW(CAPS_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[ENTER_TYPE_C1].x, gptButtonPos[ENTER_TYPE_C1].y,
                       W_ENTER_C1 + 2 * BORDER_C1, H_LETTER_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[ENTER_TYPE_C1].x + BORDER_C1, gptButtonPos[ENTER_TYPE_C1].y + BORDER_C1,
                   W_ENTER_C1, H_ENTER_C1, MAKEINTRESOURCEW(ENTER_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[SHIFT_TYPE_C1].x, gptButtonPos[SHIFT_TYPE_C1].y,
                       W_SHIFT_C1 + 2 * BORDER_C1, H_LETTER_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[SHIFT_TYPE_C1].x + BORDER_C1, gptButtonPos[SHIFT_TYPE_C1].y + BORDER_C1,
                   W_SHIFT_C1, H_SHIFT_C1, MAKEINTRESOURCEW(SHIFT_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[INS_TYPE_C1].x, gptButtonPos[INS_TYPE_C1].y,
                       W_INS_C1 + 2 * BORDER_C1, H_BOTTOM_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[INS_TYPE_C1].x + BORDER_C1, gptButtonPos[INS_TYPE_C1].y + BORDER_C1,
                   W_INS_C1, H_INS_C1, MAKEINTRESOURCEW(INS_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[DEL_TYPE_C1].x, gptButtonPos[DEL_TYPE_C1].y,
                       W_DEL_C1 + 2 * BORDER_C1, H_BOTTOM_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[DEL_TYPE_C1].x + BORDER_C1, gptButtonPos[DEL_TYPE_C1].y + BORDER_C1,
                   W_DEL_C1, H_DEL_C1, MAKEINTRESOURCEW(DEL_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[SPACE_TYPE_C1].x, gptButtonPos[SPACE_TYPE_C1].y,
                       W_SPACE_C1 + 2 * BORDER_C1, H_BOTTOM_BTN_C1);

    SKC1DrawConvexRect(hDC, gptButtonPos[ESC_TYPE_C1].x, gptButtonPos[ESC_TYPE_C1].y,
                       W_ESC_C1 + 2 * BORDER_C1, H_BOTTOM_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[ESC_TYPE_C1].x + BORDER_C1, gptButtonPos[ESC_TYPE_C1].y + BORDER_C1,
                   W_ESC_C1, H_ESC_C1, MAKEINTRESOURCEW(ESC_C1));

    return;
}


/**********************************************************************\
* CreateC1Window
*
* Init softkeyboard gloabl variabls, context and bitmap
*
\**********************************************************************/
LRESULT CreateC1Window(
    HWND hSKWnd)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;

    // alloc and lock hSKC1CTxt
    hSKC1Ctxt = GlobalAlloc(GHND, sizeof(SKC1CTXT));
    if (!hSKC1Ctxt) {
        return (-1L);
    }

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) {
        GlobalFree(hSKC1Ctxt);
        return (-1L);
    }

    // save handle in SKC1_CONTEXT
    SetWindowLongPtr(hSKWnd, SKC1_CONTEXT, (LONG_PTR)hSKC1Ctxt);

    // init global varialbles
    if (!gfSoftKbdC1Init){
      InitSKC1ButtonPos();
      gfSoftKbdC1Init = TRUE;
    }

    // no index and default char set
    pSKC1Ctxt->uKeyIndex = -1;
    pSKC1Ctxt->lfCharSet = GB2312_CHARSET;

    // init softkeyboard
    {
      HDC        hDC, hMemDC;
      HBITMAP    hBitmap, hOldBmp;
      RECT       rcClient;

      GetClientRect(hSKWnd, &rcClient);

      hDC = GetDC(hSKWnd);
      hMemDC = CreateCompatibleDC(hDC);
      hBitmap = CreateCompatibleBitmap(hDC, rcClient.right - rcClient.left,
                                       rcClient.bottom - rcClient.top);
      ReleaseDC(hSKWnd, hDC);

      hOldBmp = SelectObject(hMemDC, hBitmap);

      InitSKC1Bitmap(hMemDC, rcClient);

      SelectObject(hMemDC, hOldBmp);
      pSKC1Ctxt->hSoftkbd = hBitmap; // save hBitmap in SKC1CTXT

      DeleteDC(hMemDC);
    }

    // unlock hSKC1CTxt
    GlobalUnlock(hSKC1Ctxt);

    return (0L);
}


/**********************************************************************\
* DestroyC1Window
*
* Destroy softkeyboard context and bitmap
*
\**********************************************************************/
VOID DestroyC1Window(
    HWND hSKWnd)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;
    HWND      hUIWnd;

    // Get and Lock hSKC1Ctxt
    hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
    if (!hSKC1Ctxt) return;

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) return;

    if (pSKC1Ctxt->uState & FLAG_DRAG_C1) {
       SKC1DrawDragBorder(hSKWnd, &pSKC1Ctxt->ptSkCursor,
                          &pSKC1Ctxt->ptSkOffset);
    }

    DeleteObject(pSKC1Ctxt->hSoftkbd); // delete hBitmap

    // Unlock and Free hSKC1Ctxt
    GlobalUnlock(hSKC1Ctxt);
    GlobalFree(hSKC1Ctxt);

    // send message to parent window
    hUIWnd = GetWindow(hSKWnd, GW_OWNER);
    if (hUIWnd) {
      SendMessage(hUIWnd, WM_IME_NOTIFY, IMN_SOFTKBDDESTROYED, 0);\
    }

    return;
}


/**********************************************************************\
* ShowSKC1Window -- Show softkeyboard
*
\**********************************************************************/
VOID ShowSKC1Window(
    HDC  hDC,
    HWND hSKWnd)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;

    // Get and Lock hSKC1Ctxt
    hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
    if (!hSKC1Ctxt) return;

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) return;

    // create mem dc to show softkeyboard
    {
       HDC      hMemDC;
       HBITMAP  hOldBmp;
       RECT     rcClient;

       hMemDC = CreateCompatibleDC(hDC);
       hOldBmp = SelectObject(hMemDC, pSKC1Ctxt->hSoftkbd);
       GetClientRect(hSKWnd, &rcClient);
       BitBlt(hDC, 0, 0, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top,
              hMemDC, 0, 0, SRCCOPY);
       SelectObject(hMemDC, hOldBmp);
       DeleteDC(hMemDC);
    }

    // Unlock hSKC1Ctxt
    GlobalUnlock(hSKC1Ctxt);

    return;
}


/**********************************************************************\
* UpdateSKC1Window -- update softkeyboard
*
\**********************************************************************/
BOOL UpdateSKC1Window(
    HWND          hSKWnd,
    LPSOFTKBDDATA lpSoftKbdData)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;
    LOGFONT   lfFont;
    HFONT     hOldFont, hFont;
    HDC       hDC, hMemDC;
    HBITMAP   hOldBmp;
    int       i;

    // check the lpSoftKbdData
    if (lpSoftKbdData->uCount!=2) return FALSE;

    // Get and Lock hSKC1Ctxt
    hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
    if (!hSKC1Ctxt) return FALSE;

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) return FALSE;

    // create font
    hDC = GetDC(hSKWnd);
    hMemDC = CreateCompatibleDC(hDC);
    hOldBmp = SelectObject(hMemDC, pSKC1Ctxt->hSoftkbd);

    GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof(lfFont), &lfFont);
    lfFont.lfHeight = -SIZEFONT_C1;
    if (pSKC1Ctxt->lfCharSet != DEFAULT_CHARSET) {
        lfFont.lfCharSet = (BYTE)pSKC1Ctxt->lfCharSet;
    }

    hFont = CreateFontIndirect(&lfFont);
    hOldFont = SelectObject(hMemDC, hFont);


    // update shift/non-shift chars
    for (i=0; i < LETTER_NUM_C1; i++) {
        pSKC1Ctxt->wNonShiftCode[i] = lpSoftKbdData->wCode[0][SKC1VirtKey[i]];
        pSKC1Ctxt->wShiftCode[i] = lpSoftKbdData->wCode[1][SKC1VirtKey[i]];
    }

    SetBkColor(hMemDC, 0x00BFBFBF);  // set text bk color ??

    for (i=0; i < LETTER_NUM_C1; i++) {
        int  nchar;
        RECT rc;

        // draw shift char.
        rc.left = gptButtonPos[i].x + X_SHIFT_CHAR_C1;
        rc.top = gptButtonPos[i].y + Y_SHIFT_CHAR_C1;
        rc.right = rc.left + SIZEFONT_C1;
        rc.bottom = rc.top + SIZEFONT_C1;

        nchar = (pSKC1Ctxt->wShiftCode[i] == 0) ? 0 : 1;

#if (WINVER >= 0x0400)
        DrawTextEx(hMemDC, (LPWSTR)&pSKC1Ctxt->wShiftCode[i],
                   nchar, &rc, DT_CENTER, NULL);
#else
        ExtTextOut(hMemDC,
            rc.left,
            rc.top,
            ETO_OPAQUE, &rc,
            (LPWSTR)&pSKC1Ctxt->wShiftCode[i], nchar, NULL);
#endif

        // draw non-shift char.
        rc.left = gptButtonPos[i].x + X_NONSHIFT_CHAR_C1;
        rc.top = gptButtonPos[i].y + Y_NONSHIFT_CHAR_C1;
        rc.right = rc.left + SIZEFONT_C1;
        rc.bottom = rc.top + SIZEFONT_C1;

        nchar = (pSKC1Ctxt->wNonShiftCode[i] == 0) ? 0 : 1;

#if (WINVER >= 0x0400)
        DrawTextEx(hMemDC, (LPWSTR)&pSKC1Ctxt->wNonShiftCode[i],
                   nchar, &rc, DT_CENTER, NULL);
#else
        ExtTextOut(hMemDC,
            rc.left,
            rc.top,
            ETO_OPAQUE, &rc,
            (LPWSTR)&pSKC1Ctxt->wNonShiftCode[i], nchar, NULL);
#endif
    }

    // init states
    if (pSKC1Ctxt->uState & FLAG_SHIFT_C1){
       SKC1InvertButton(hMemDC, SHIFT_TYPE_C1);
    }
    pSKC1Ctxt->uState = 0;

    SelectObject(hMemDC, hOldBmp);
    SelectObject(hMemDC, hOldFont);
    DeleteDC(hMemDC);

    DeleteObject(hFont);
    ReleaseDC(hSKWnd,hDC);

    // Unlock hSKC1Ctxt
    GlobalUnlock(hSKC1Ctxt);

    return TRUE;
}


/**********************************************************************\
* SKC1DrawDragBorder() -- Draw Drag Border
*
\**********************************************************************/
VOID SKC1DrawDragBorder(
    HWND    hWnd,               // window is dragged
    LPPOINT lpptCursor,         // the cursor position
    LPPOINT lpptOffset)         // the offset form cursor to window org
{
    HDC     hDC;
    RECT    rcWnd, rcWorkArea;
    int     cxBorder, cyBorder;
    int     x, y;
    extern void GetAllMonitorSize(LPRECT lprc);

    // get rectangle of work area
    GetAllMonitorSize(&rcWorkArea);

    cxBorder = GetSystemMetrics(SM_CXBORDER);   // width of border
    cyBorder = GetSystemMetrics(SM_CYBORDER);   // height of border

    // create DISPLAY dc to draw track
    hDC = CreateDC(L"DISPLAY", NULL, NULL, NULL);
    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // start point (left,top)
    x = lpptCursor->x - lpptOffset->x;
    y = lpptCursor->y - lpptOffset->y;

    // check for the min boundary of the display
    if (x < rcWorkArea.left) {
        x = rcWorkArea.left;
    }

    if (y < rcWorkArea.top) {
        y = rcWorkArea.top;
    }

    // check for the max boundary of the display
    GetWindowRect(hWnd, &rcWnd);

    if (x + rcWnd.right - rcWnd.left > rcWorkArea.right) {
        x = rcWorkArea.right - (rcWnd.right - rcWnd.left);
    }

    if (y + rcWnd.bottom - rcWnd.top > rcWorkArea.bottom) {
        y = rcWorkArea.bottom - (rcWnd.bottom - rcWnd.top);
    }

    // adjust Offset
    lpptOffset->x = lpptCursor->x - x;
    lpptOffset->y = lpptCursor->y - y;

    // draw rectangle
    PatBlt(hDC, x, y, rcWnd.right - rcWnd.left - cxBorder, cyBorder, PATINVERT);
    PatBlt(hDC, x, y + cyBorder, cxBorder, rcWnd.bottom - rcWnd.top - cyBorder, PATINVERT);
    PatBlt(hDC, x + cxBorder, y + rcWnd.bottom - rcWnd.top, rcWnd.right -
           rcWnd.left - cxBorder, -cyBorder, PATINVERT);
    PatBlt(hDC, x + rcWnd.right - rcWnd.left, y, - cxBorder, rcWnd.bottom -
           rcWnd.top - cyBorder, PATINVERT);

    // delete DISPLAY DC
    DeleteDC(hDC);

    return;
}


/**********************************************************************\
* SKC1MousePosition() -- judge the cursor position
*
\**********************************************************************/

#define CHECK_RECT(name)  \
    if (ImmPtInRect(gptButtonPos[name ## _TYPE_C1].x,   \
            gptButtonPos[name ## _TYPE_C1].y,           \
            W_ ## name ## _C1 + 2 * BORDER_C1,          \
            H_ ## name ## _C1 + 2 * BORDER_C1,          \
            lpptCursor)) {                              \
        return name ## _TYPE_C1;                        \
    }

INT SKC1MousePosition(
    LPPOINT lpptCursor)
{
    int   i;

    // letter buttons
    for (i = 0; i < LETTER_NUM_C1; i++){

       if (ImmPtInRect(gptButtonPos[i].x,
                gptButtonPos[i].y,
                W_LETTER_BTN_C1,
                H_LETTER_BTN_C1,
                lpptCursor)) {
           return i;
       }
    }

    CHECK_RECT(BACKSP);
    CHECK_RECT(TAB);
    CHECK_RECT(CAPS);
    CHECK_RECT(ENTER);
    CHECK_RECT(SHIFT);
    CHECK_RECT(ESC);
    CHECK_RECT(SPACE);
    CHECK_RECT(INS);
    CHECK_RECT(DEL);

    return -1;
}

#undef CHECK_RECT


/**********************************************************************\
* SKC1ButtonDown
*
\**********************************************************************/
VOID SKC1ButtonDown(
    HWND      hSKWnd,
    PSKC1CTXT pSKC1Ctxt)
{
    // capture the mouse activity
    SetCapture(hSKWnd);

    // in drag area
    if (pSKC1Ctxt->uKeyIndex == -1) {
       pSKC1Ctxt->uState |= FLAG_DRAG_C1;

       SKC1DrawDragBorder(hSKWnd, &pSKC1Ctxt->ptSkCursor, &pSKC1Ctxt->ptSkOffset);
    } else {
       UINT uVirtKey = 0xff;
       BOOL bRet = FALSE;

       if (pSKC1Ctxt->uKeyIndex == SHIFT_TYPE_C1) {
          if (!(pSKC1Ctxt->uState & FLAG_SHIFT_C1)) {
             bRet = TRUE;
          }
       } else if (pSKC1Ctxt->uKeyIndex < LETTER_NUM_C1) {
          if (pSKC1Ctxt->uState & FLAG_SHIFT_C1) {
             uVirtKey = pSKC1Ctxt->wShiftCode[pSKC1Ctxt->uKeyIndex];
          }
          else {
             uVirtKey = pSKC1Ctxt->wNonShiftCode[pSKC1Ctxt->uKeyIndex];
          }

          if (uVirtKey) {
             bRet = TRUE;
          } else {
             MessageBeep(0xFFFFFFFF);
             pSKC1Ctxt->uKeyIndex = -1;
          }
       } else {
          bRet = TRUE;
       }

       if (bRet) {
          HDC      hDC, hMemDC;
          HBITMAP  hOldBmp;

          hDC = GetDC(hSKWnd);
          hMemDC = CreateCompatibleDC(hDC);
          hOldBmp = SelectObject(hMemDC, pSKC1Ctxt->hSoftkbd);

          SKC1InvertButton(hDC, pSKC1Ctxt->uKeyIndex);
          SKC1InvertButton(hMemDC, pSKC1Ctxt->uKeyIndex);

          SelectObject(hMemDC, hOldBmp);
          DeleteDC(hMemDC);
          ReleaseDC(hSKWnd,hDC);
       }

       if(uVirtKey) {
          pSKC1Ctxt->uState |= FLAG_FOCUS_C1;
       }
    }

    return;
}


/**********************************************************************\
* SKC1SetCursor
*
\**********************************************************************/
BOOL SKC1SetCursor(
   HWND   hSKWnd,
   LPARAM lParam)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;
    POINT     ptSkCursor, ptSkOffset;
    int       uKeyIndex;

    // Get and lock hSKC1Ctxt
    hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
    if (!hSKC1Ctxt) {
        return (FALSE);
    }

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) {
        return (FALSE);
    }

    if (pSKC1Ctxt->uState & FLAG_DRAG_C1){
        // in drag operation
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        GlobalUnlock(hSKC1Ctxt);
        return (TRUE);
    }

    GetCursorPos(&ptSkCursor);
    ptSkOffset = ptSkCursor;
    ScreenToClient(hSKWnd, &ptSkOffset);

    uKeyIndex = SKC1MousePosition(&ptSkOffset);

    if (uKeyIndex != -1) {
       SetCursor(LoadCursor(NULL, IDC_HAND));
    } else {
       SetCursor(LoadCursor(NULL, IDC_SIZEALL));
    }

    if (HIWORD(lParam) != WM_LBUTTONDOWN){
       // unlock hSKC1Ctxt
       GlobalUnlock(hSKC1Ctxt);
       return (TRUE);
    }

    pSKC1Ctxt->ptSkCursor = ptSkCursor;
    pSKC1Ctxt->ptSkOffset = ptSkOffset;
    pSKC1Ctxt->uKeyIndex = uKeyIndex;

    SKC1ButtonDown(hSKWnd, pSKC1Ctxt);

    // unlock hSKC1Ctxt
    GlobalUnlock(hSKC1Ctxt);
    return (TRUE);
}


/**********************************************************************\
* SKC1MouseMove
*
\**********************************************************************/
BOOL SKC1MouseMove(
    HWND   hSKWnd,
    WPARAM wParam,
    LPARAM lParam)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);

    // get and lock hSKC1Ctxt
    hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
    if (!hSKC1Ctxt) {
       return (FALSE);
    }

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) {
       return (FALSE);
    }

    if (pSKC1Ctxt->uState & FLAG_DRAG_C1) {
       SKC1DrawDragBorder(hSKWnd, &pSKC1Ctxt->ptSkCursor,
                          &pSKC1Ctxt->ptSkOffset);

       GetCursorPos(&pSKC1Ctxt->ptSkCursor);

       SKC1DrawDragBorder(hSKWnd, &pSKC1Ctxt->ptSkCursor,
                          &pSKC1Ctxt->ptSkOffset);
    } else if (pSKC1Ctxt->uKeyIndex != -1) {
       HDC      hDC, hMemDC;
       HBITMAP  hOldBmp;
       POINT    ptSkOffset;
       int      uKeyIndex;

       GetCursorPos(&ptSkOffset);
       ScreenToClient(hSKWnd, &ptSkOffset);
       uKeyIndex = SKC1MousePosition(&ptSkOffset);

       hDC = GetDC(hSKWnd);
       hMemDC = CreateCompatibleDC(hDC);
       hOldBmp = SelectObject(hMemDC, pSKC1Ctxt->hSoftkbd);

       if (((pSKC1Ctxt->uState & FLAG_FOCUS_C1) && (uKeyIndex != pSKC1Ctxt->uKeyIndex)) ||
           (!(pSKC1Ctxt->uState & FLAG_FOCUS_C1) && (uKeyIndex == pSKC1Ctxt->uKeyIndex))) {
          if ((pSKC1Ctxt->uKeyIndex != SHIFT_TYPE_C1) ||
              !(pSKC1Ctxt->uState & FLAG_SHIFT_C1)) {
             SKC1InvertButton(hDC, pSKC1Ctxt->uKeyIndex);
             SKC1InvertButton(hMemDC, pSKC1Ctxt->uKeyIndex);
          }
          pSKC1Ctxt->uState ^= FLAG_FOCUS_C1;
       }

       SelectObject(hMemDC, hOldBmp);
       DeleteDC(hMemDC);
       ReleaseDC(hSKWnd,hDC);
    }

    // unlock hSKC1Ctxt
    GlobalUnlock(hSKC1Ctxt);

    return (TRUE);
}


/**********************************************************************\
* SKC1ButtonUp
*
\**********************************************************************/
BOOL SKC1ButtonUp(
    HWND       hSKWnd,
    WPARAM     wParam,
    LPARAM     lParam)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;
    POINT     pt;
    UINT      uVirtKey;
    BOOL      bRet = FALSE;

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);

    // Get and lock hSKC1Ctxt
    hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
    if (!hSKC1Ctxt) {
        return (bRet);
    }

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) {
        return (bRet);
    }

    ReleaseCapture();

    if (pSKC1Ctxt->uState & FLAG_DRAG_C1) {
       pSKC1Ctxt->uState &= ~(FLAG_DRAG_C1);

       SKC1DrawDragBorder(hSKWnd, &pSKC1Ctxt->ptSkCursor, &pSKC1Ctxt->ptSkOffset);

       pt.x = pSKC1Ctxt->ptSkCursor.x - pSKC1Ctxt->ptSkOffset.x;
       pt.y = pSKC1Ctxt->ptSkCursor.y - pSKC1Ctxt->ptSkOffset.y;

       SetWindowPos(hSKWnd, (HWND)NULL, pt.x, pt.y,
                     0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

       // update IMC
       bRet = TRUE;
       {
          HWND          hUIWnd;
          HIMC          hImc;
          PINPUTCONTEXT pInputContext;

          hUIWnd = GetWindow(hSKWnd, GW_OWNER);
          hImc = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
          if (hImc) {
             pInputContext = ImmLockIMC(hImc);
             if (pInputContext) {
                pInputContext->ptSoftKbdPos = pt;
                pInputContext->fdwInit |= INIT_SOFTKBDPOS;
                ImmUnlockIMC(hImc);
             }
          }
       }
    } else if (pSKC1Ctxt->uKeyIndex != -1) {
       if (pSKC1Ctxt->uState & FLAG_FOCUS_C1) {
          if (pSKC1Ctxt->uKeyIndex == SHIFT_TYPE_C1) {
             if (pSKC1Ctxt->uState & FLAG_SHIFT_C1) {
                bRet = TRUE;
             } else {
                pSKC1Ctxt->uState |= FLAG_SHIFT_C1;
             }
          } else if ((pSKC1Ctxt->uKeyIndex < LETTER_NUM_C1) &&
                     (pSKC1Ctxt->uState & FLAG_SHIFT_C1)) {
                keybd_event((BYTE)VK_SHIFT, (BYTE)guScanCode[VK_SHIFT],
                            0, 0);
                uVirtKey = SKC1VirtKey[pSKC1Ctxt->uKeyIndex];
                keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
                           0, 0);
                keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
                           (DWORD)KEYEVENTF_KEYUP, 0);
                keybd_event((BYTE)VK_SHIFT, (BYTE)guScanCode[VK_SHIFT],
                            (DWORD)KEYEVENTF_KEYUP, 0);
                bRet = TRUE;
          } else {
                uVirtKey = SKC1VirtKey[pSKC1Ctxt->uKeyIndex];
                keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
                         0, 0);
                keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
                         (DWORD)KEYEVENTF_KEYUP, 0);
                bRet = TRUE;
          }

          if (bRet){
             HDC      hDC, hMemDC;
             HBITMAP  hOldBmp;

             hDC = GetDC(hSKWnd);
             hMemDC = CreateCompatibleDC(hDC);
             hOldBmp = SelectObject(hMemDC, pSKC1Ctxt->hSoftkbd);

             SKC1InvertButton(hDC, pSKC1Ctxt->uKeyIndex);
             SKC1InvertButton(hMemDC, pSKC1Ctxt->uKeyIndex);

             if ((pSKC1Ctxt->uKeyIndex != SHIFT_TYPE_C1) &&
                 (pSKC1Ctxt->uKeyIndex < LETTER_NUM_C1) &&
                 (pSKC1Ctxt->uState & FLAG_SHIFT_C1)) {
                SKC1InvertButton(hDC, SHIFT_TYPE_C1);
                SKC1InvertButton(hMemDC, SHIFT_TYPE_C1);
             }

             if ((pSKC1Ctxt->uKeyIndex < LETTER_NUM_C1) ||
                 (pSKC1Ctxt->uKeyIndex == SHIFT_TYPE_C1)) {
                pSKC1Ctxt->uState &= ~(FLAG_SHIFT_C1);
             }

             SelectObject(hMemDC, hOldBmp);
             DeleteDC(hMemDC);
             ReleaseDC(hSKWnd,hDC);
          }
          pSKC1Ctxt->uState &= ~ (FLAG_FOCUS_C1);
       }
       pSKC1Ctxt->uKeyIndex = -1;
    }

    // unlock hSKC1Ctxt
    GlobalUnlock(hSKC1Ctxt);

    return (bRet);
}


/**********************************************************************\
* SKWndProcC1 -- softkeyboard window procedure
*
\**********************************************************************/
LRESULT SKWndProcC1(
    HWND   hSKWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT    lRet = 0L;

    switch (uMsg) {
       case WM_CREATE:
            lRet = CreateC1Window(hSKWnd);
            break;

       case WM_DESTROY:
            DestroyC1Window(hSKWnd);
            break;

       case WM_PAINT:
            {
               HDC         hDC;
               PAINTSTRUCT ps;

               hDC = BeginPaint(hSKWnd, &ps);
               ShowSKC1Window(hDC, hSKWnd);
               EndPaint(hSKWnd, &ps);
            }
            break;

       case WM_MOUSEACTIVATE:
            lRet = MA_NOACTIVATE;
            break;

       case WM_SETCURSOR:
            if (!SKC1SetCursor(hSKWnd, lParam)) {
               lRet = DefWindowProc(hSKWnd, uMsg, wParam, lParam);
            }
            break;

       case WM_MOUSEMOVE:
            if (!SKC1MouseMove(hSKWnd, wParam, lParam)) {
               lRet = DefWindowProc(hSKWnd, uMsg, wParam, lParam);
            }
            break;

       case WM_LBUTTONUP:
            if (!SKC1ButtonUp(hSKWnd, wParam, lParam)) {
               lRet = DefWindowProc(hSKWnd, uMsg, wParam, lParam);
            }
            break;

       case WM_IME_CONTROL:
            switch (wParam) {
               case IMC_GETSOFTKBDFONT:
                    {
                       HDC        hDC;
                       LOGFONT    lfFont;

                       hDC = GetDC(hSKWnd);
                       GetObject(GetStockObject(DEFAULT_GUI_FONT),
                                 sizeof(lfFont), &lfFont);
                       ReleaseDC(hSKWnd, hDC);
                       *(LPLOGFONT)lParam = lfFont;
                    }
                    break;

               case IMC_SETSOFTKBDFONT:
                    {
                       LOGFONT lfFont;

                       GetObject(GetStockObject(DEFAULT_GUI_FONT),
                           sizeof(lfFont), &lfFont);

                       // in differet version of Windows
                       if (lfFont.lfCharSet != ((LPLOGFONT)lParam)->lfCharSet) {
                           HGLOBAL    hSKC1Ctxt;
                           LPSKC1CTXT lpSKC1Ctxt;

                           hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd,
                               SKC1_CONTEXT);
                           if (!hSKC1Ctxt) {
                               return 1;
                           }

                           lpSKC1Ctxt = (LPSKC1CTXT)GlobalLock(hSKC1Ctxt);
                           if (!lpSKC1Ctxt) {
                               return 1;
                           }

                           lpSKC1Ctxt->lfCharSet =
                               ((LPLOGFONT)lParam)->lfCharSet;

                           GlobalUnlock(hSKC1Ctxt);
                       }
                    }
                    break;

               case IMC_GETSOFTKBDPOS:
                    {
                       RECT rcWnd;

                       GetWindowRect(hSKWnd, &rcWnd);

                       return MAKELRESULT(rcWnd.left, rcWnd.top);
                    }
                    break;

               case IMC_SETSOFTKBDPOS:
                    {
                       SetWindowPos(hSKWnd, NULL,
                            ((LPPOINTS)lParam)->x, ((LPPOINTS)lParam)->y,
                            0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
                       return (0);
                    }
                    break;

               case IMC_SETSOFTKBDDATA:
                    if (UpdateSKC1Window(hSKWnd, (LPSOFTKBDDATA)lParam)) {
                       InvalidateRect(hSKWnd, NULL, FALSE);
                    } else lRet = -1L;
                    break;

               case IMC_GETSOFTKBDSUBTYPE:
               case IMC_SETSOFTKBDSUBTYPE:
                    {
                       HGLOBAL   hSKC1Ctxt;
                       PSKC1CTXT pSKC1Ctxt;

                       lRet = -1L;

                       hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
                       if (!hSKC1Ctxt) break;

                       pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
                       if (!pSKC1Ctxt) break;

                       if (wParam == IMC_GETSOFTKBDSUBTYPE) {
                          lRet = pSKC1Ctxt->uSubtype;
                       } else {
                          lRet = pSKC1Ctxt->uSubtype;
                          pSKC1Ctxt->uSubtype = (UINT)lParam;
                       }

                       GlobalUnlock(hSKC1Ctxt);
                    }
                    break;
            }
            break;

       default:
            lRet = DefWindowProc(hSKWnd, uMsg, wParam, lParam);
    }

    return (lRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\regword.c ===
/**************************************************************************\
* Module Name: regword.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Word registration into IME dictionary
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* ImmRegisterWordA
*
* Registers a string into the dictionary of the IME with the specified hKL.
*
* History:
* 01-Mar-1996   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmRegisterWordA(
    HKL    hKL,
    LPCSTR lpszReading,
    DWORD  dwStyle,
    LPCSTR lpszString)
{
    PIMEDPI pImeDpi;
    LPWSTR  lpwszReading;
    LPWSTR  lpwszString;
    INT     cchReading;
    INT     cchString;
    INT     i;
    BOOL    fRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmRegisterWordA: no pImeDpi entry.");
        return FALSE;
    }

    if (!(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * register the string.
         */
        fRet = (*pImeDpi->pfn.ImeRegisterWord.a)(lpszReading, dwStyle, lpszString);
        ImmUnlockImeDpi(pImeDpi);
        return fRet;
    }

    /*
     * ANSI caller, Unicode IME. Needs A/W conversion on
     * lpszReading and lpszString.
     */
    if (lpszReading != NULL) {
        cchReading = strlen(lpszReading) + sizeof(CHAR);
        lpwszReading = ImmLocalAlloc(0, cchReading * sizeof(WCHAR));
        if (lpwszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmRegisterWordA: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszReading,              // src
                                (INT)strlen(lpszReading),
                                (LPWSTR)lpwszReading,            // dest
                                cchReading);
        lpwszReading[i] = L'\0';
    }
    else {
        lpwszReading = NULL;
    }

    if (lpszString != NULL) {
        cchString  = strlen(lpszString)  + sizeof(CHAR);
        lpwszString = ImmLocalAlloc(0, cchString * sizeof(WCHAR));
        if (lpwszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmRegisterWordA: memory failure.");
            if (lpwszReading != NULL)
                ImmLocalFree(lpwszReading);
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszString,              // src
                                (INT)strlen(lpszString),
                                (LPWSTR)lpwszString,            // dest
                                cchString);
        lpwszString[i] = L'\0';
    }
    else {
        lpwszString = NULL;
    }

    fRet = ImmRegisterWordW(hKL, lpwszReading, dwStyle, lpwszString);

    if (lpwszReading != NULL)
        ImmLocalFree(lpwszReading);

    if (lpwszString != NULL)
        ImmLocalFree(lpwszString);

    ImmUnlockImeDpi(pImeDpi);
    return fRet;
}


BOOL WINAPI ImmRegisterWordW(
    HKL     hKL,
    LPCWSTR lpwszReading,
    DWORD   dwStyle,
    LPCWSTR lpwszString)
{
    PIMEDPI pImeDpi;
    LPSTR   lpszReading;
    LPSTR   lpszString;
    INT     cchReading;
    INT     cchString;
    INT     i;
    BOOL    fRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmRegisterWordW: no pImeDpi entry.");
        return FALSE;
    }

    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        /*
         * Doesn't need W/A conversion. Calls directly to IME to
         * register the string.
         */
        fRet = (*pImeDpi->pfn.ImeRegisterWord.w)(lpwszReading, dwStyle, lpwszString);
        ImmUnlockImeDpi(pImeDpi);
        return fRet;
    }

    /*
     * Unicode caller, ANSI IME. Needs W/A conversion on
     * lpwszReading and lpwszString.
     */
    if (lpwszReading != NULL) {
        cchReading = (wcslen(lpwszReading) + 1) * sizeof(WCHAR);
        lpszReading = ImmLocalAlloc(0, cchReading);
        if (lpszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmRegisterWordW: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                (DWORD)0,
                                (LPWSTR)lpwszReading,          // src
                                (INT)wcslen(lpwszReading),
                                (LPSTR)lpszReading,            // dest
                                cchReading,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszReading[i] = '\0';
    }
    else {
        lpszReading = NULL;
    }

    if (lpwszString != NULL) {
        cchString  = (wcslen(lpwszString) + 1) * sizeof(WCHAR);
        lpszString = ImmLocalAlloc(0, cchString);
        if (lpszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmRegisterWordW: memory failure.");
            if (lpszReading != NULL)
                ImmLocalFree(lpszReading);
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                (DWORD)0,
                                (LPWSTR)lpwszString,          // src
                                (INT)wcslen(lpwszString),
                                (LPSTR)lpszString,            // dest
                                cchString,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszString[i] = '\0';
    }
    else {
        lpszString = NULL;
    }

    fRet = ImmRegisterWordA(hKL, lpszReading, dwStyle, lpszString);

    if (lpszReading != NULL)
        ImmLocalFree(lpszReading);

    if (lpszString != NULL)
        ImmLocalFree(lpszString);

    ImmUnlockImeDpi(pImeDpi);
    return fRet;
}


BOOL WINAPI ImmUnregisterWordA(
    HKL    hKL,
    LPCSTR lpszReading,
    DWORD  dwStyle,
    LPCSTR lpszString)
{
    PIMEDPI pImeDpi;
    LPWSTR  lpwszReading;
    LPWSTR  lpwszString;
    INT     cchReading;
    INT     cchString;
    INT     i;
    BOOL    fRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmUnregisterWordA: no pImeDpi entry.");
        return FALSE;
    }

    if (!(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * un-register the string.
         */
        fRet = (*pImeDpi->pfn.ImeUnregisterWord.a)(lpszReading, dwStyle, lpszString);
        ImmUnlockImeDpi(pImeDpi);
        return fRet;
    }

    /*
     * ANSI caller, Unicode IME. Needs A/W conversion on
     * lpszReading and lpszString.
     */
    if (lpszReading != NULL) {
        cchReading = strlen(lpszReading) + sizeof(CHAR);
        lpwszReading = ImmLocalAlloc(0, cchReading * sizeof(WCHAR));
        if (lpwszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmUnregisterWordA: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszReading,              // src
                                (INT)strlen(lpszReading),
                                (LPWSTR)lpwszReading,            // dest
                                cchReading);
        lpwszReading[i] = L'\0';
    }
    else {
        lpwszReading = NULL;
    }

    if (lpszString != NULL) {
        cchString  = strlen(lpszString)  + sizeof(CHAR);
        lpwszString = ImmLocalAlloc(0, cchString * sizeof(WCHAR));
        if (lpwszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmUnregisterWordA: memory failure.");
            if (lpwszReading != NULL)
                ImmLocalFree(lpwszReading);
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszString,              // src
                                (INT)strlen(lpszString),
                                (LPWSTR)lpwszString,            // dest
                                cchString);
        lpwszString[i] = L'\0';
    }
    else {
        lpwszString = NULL;
    }

    fRet = ImmUnregisterWordW(hKL, lpwszReading, dwStyle, lpwszString);

    if (lpwszReading != NULL)
        ImmLocalFree(lpwszReading);

    if (lpwszString != NULL)
        ImmLocalFree(lpwszString);

    ImmUnlockImeDpi(pImeDpi);
    return fRet;
}


BOOL WINAPI ImmUnregisterWordW(
    HKL     hKL,
    LPCWSTR lpwszReading,
    DWORD   dwStyle,
    LPCWSTR lpwszString)
{
    PIMEDPI pImeDpi;
    LPSTR   lpszReading;
    LPSTR   lpszString;
    INT     cchReading;
    INT     cchString;
    INT     i;
    BOOL    fRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmUnregisterWordW: no pImeDpi entry.");
        return FALSE;
    }

    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        /*
         * Doesn't need W/A conversion. Calls directly to IME to
         * register the string.
         */
        fRet = (*pImeDpi->pfn.ImeUnregisterWord.w)(lpwszReading, dwStyle, lpwszString);
        ImmUnlockImeDpi(pImeDpi);
        return fRet;
    }

    /*
     * Unicode caller, ANSI IME. Needs W/A conversion on
     * lpwszReading and lpwszString.
     */
    if (lpwszReading != NULL) {
        cchReading = (wcslen(lpwszReading) + 1) * sizeof(WCHAR);
        lpszReading = ImmLocalAlloc(0, cchReading);
        if (lpszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmUnregisterWordW: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                (DWORD)0,
                                (LPWSTR)lpwszReading,          // src
                                (INT)wcslen(lpwszReading),
                                (LPSTR)lpszReading,            // dest
                                cchReading,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszReading[i] = '\0';
    }
    else {
        lpszReading = NULL;
    }

    if (lpwszString != NULL) {
        cchString  = (wcslen(lpwszString) + 1) * sizeof(WCHAR);
        lpszString = ImmLocalAlloc(0, cchString);
        if (lpszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmUnregisterWordW: memory failure.");
            if (lpszReading != NULL)
                ImmLocalFree(lpszReading);
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                (DWORD)0,
                                (LPWSTR)lpwszString,          // src
                                (INT)wcslen(lpwszString),
                                (LPSTR)lpszString,            // dest
                                cchString,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszString[i] = '\0';
    }
    else {
        lpszString = NULL;
    }

    fRet = ImmUnregisterWordA(hKL, lpszReading, dwStyle, lpszString);

    if (lpszReading != NULL)
        ImmLocalFree(lpszReading);

    if (lpszString != NULL)
        ImmLocalFree(lpszString);

    ImmUnlockImeDpi(pImeDpi);
    return fRet;
}


UINT WINAPI ImmGetRegisterWordStyleA(
    HKL         hKL,
    UINT        nItem,
    LPSTYLEBUFA lpStyleBufA)
{
    PIMEDPI     pImeDpi;
    LPSTYLEBUFW lpStyleBufW;
    UINT        uRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmGetRegisterWordStyleA: no pImeDpi entry.");
        return 0;
    }

    if (!(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * get the available style.
         */
        uRet = (*pImeDpi->pfn.ImeGetRegisterWordStyle.a)(nItem, lpStyleBufA);
        ImmUnlockImeDpi(pImeDpi);
        return uRet;
    }

    /*
     * ANSI caller, Unicode IME. Needs A/W conversion on
     * lpStyleBufA.
     */
    lpStyleBufW = NULL;

    if (nItem != 0) {
        lpStyleBufW = ImmLocalAlloc(0, nItem * sizeof(STYLEBUFW));
        if (lpStyleBufW == NULL) {
            RIPMSG0(RIP_WARNING, "ImmGetRegisterWordStyleA: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return 0;
        }
    }

    uRet = ImmGetRegisterWordStyleW(hKL, nItem, lpStyleBufW);

    if (nItem != 0) {
        LPSTYLEBUFW lpsbw;
        INT i, j;

        for (i = 0, lpsbw = lpStyleBufW; i < (INT)uRet; i++, lpsbw++) {

            lpStyleBufA->dwStyle = lpsbw->dwStyle;

            j = WideCharToMultiByte(IMECodePage(pImeDpi),
                                    (DWORD)0,
                                    (LPWSTR)lpsbw->szDescription,          // src
                                    (INT)wcslen(lpsbw->szDescription),
                                    (LPSTR)lpStyleBufA->szDescription,     // dest
                                    (INT)sizeof(lpStyleBufA->szDescription),
                                    (LPSTR)NULL,
                                    (LPBOOL)NULL);
            lpStyleBufA->szDescription[j] = '\0';
            lpStyleBufA++;
        }
    }

    if (lpStyleBufW != NULL)
        ImmLocalFree(lpStyleBufW);

    ImmUnlockImeDpi(pImeDpi);

    return uRet;
}


UINT WINAPI ImmGetRegisterWordStyleW(
    HKL         hKL,
    UINT        nItem,
    LPSTYLEBUFW lpStyleBufW)
{
    PIMEDPI     pImeDpi;
    LPSTYLEBUFA lpStyleBufA;
    UINT        uRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmGetRegisterWordStyleA: no pImeDpi entry.");
        return 0;
    }

    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        /*
         * Doesn't need W/A conversion. Calls directly to IME to
         * get the available style.
         */
        uRet = (*pImeDpi->pfn.ImeGetRegisterWordStyle.w)(nItem, lpStyleBufW);
        ImmUnlockImeDpi(pImeDpi);
        return uRet;
    }

    /*
     * Unicode caller, ANSI IME. Needs W/A conversion on
     * lpStyleBufW.
     */
    lpStyleBufA = NULL;

    if (nItem != 0) {
        lpStyleBufA = ImmLocalAlloc(0, nItem * sizeof(STYLEBUFA));
        if (lpStyleBufA == NULL) {
            RIPMSG0(RIP_WARNING, "ImmGetRegisterWordStyleW: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return 0;
        }
    }

    uRet = ImmGetRegisterWordStyleA(hKL, nItem, lpStyleBufA);

    if (nItem != 0) {
        LPSTYLEBUFA lpsba;
        INT i, j;

        for (i = 0, lpsba = lpStyleBufA; i < (INT)uRet; i++, lpsba++) {

            lpStyleBufW->dwStyle = lpsba->dwStyle;

            j = MultiByteToWideChar(IMECodePage(pImeDpi),
                        (DWORD)MB_PRECOMPOSED,
                        (LPSTR)lpsba->szDescription,             // src
                        (INT)strlen(lpsba->szDescription),
                        (LPWSTR)lpStyleBufW->szDescription,      // dest
                        (INT)(sizeof(lpStyleBufW->szDescription)/sizeof(WCHAR)));
            lpStyleBufW->szDescription[j] = L'\0';
            lpStyleBufW++;
        }
    }

    if (lpStyleBufA != NULL)
        ImmLocalFree(lpStyleBufA);

    ImmUnlockImeDpi(pImeDpi);

    return uRet;
}


UINT WINAPI ImmEnumRegisterWordA(
    HKL                   hKL,
    REGISTERWORDENUMPROCA lpfnRegisterWordEnumProcA,
    LPCSTR                lpszReading,
    DWORD                 dwStyle,
    LPCSTR                lpszString,
    LPVOID                lpData)
{
    PIMEDPI         pImeDpi;
    LPWSTR          lpwszReading;
    LPWSTR          lpwszString;
    INT             cchReading;
    INT             cchString;
    INT             i;
    ENUMREGWORDDATA erwData;
    UINT            uRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmEnumRegisterWordA: no pImeDpi entry.");
        return 0;
    }

    if (!(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * enumerate registered strings.
         */
        uRet = (*pImeDpi->pfn.ImeEnumRegisterWord.a)(lpfnRegisterWordEnumProcA,
                                                     lpszReading,
                                                     dwStyle,
                                                     lpszString,
                                                     lpData);
        ImmUnlockImeDpi(pImeDpi);
        return uRet;
    }

    /*
     * ANSI caller, Unicode IME. Needs A/W conversion on
     * lpszReading and lpszString.
     */
    if (lpszReading != NULL) {
        cchReading = strlen(lpszReading) + sizeof(CHAR);
        lpwszReading = ImmLocalAlloc(0, cchReading * sizeof(WCHAR));
        if (lpwszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmEnumRegisterWordA: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return 0;
        }

        i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszReading,              // src
                                (INT)strlen(lpszReading),
                                (LPWSTR)lpwszReading,            // dest
                                cchReading);
        lpwszReading[i] = L'\0';
    }
    else {
        lpwszReading = NULL;
    }

    if (lpszString != NULL) {
        cchString  = strlen(lpszString)  + sizeof(CHAR);
        lpwszString = ImmLocalAlloc(0, cchString * sizeof(WCHAR));
        if (lpwszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmEnumRegisterWordA: memory failure.");
            if (lpwszReading != NULL)
                ImmLocalFree(lpwszReading);
            ImmUnlockImeDpi(pImeDpi);
            return 0;
        }

        i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszString,              // src
                                (INT)strlen(lpszString),
                                (LPWSTR)lpwszString,            // dest
                                cchString);
        lpwszString[i] = L'\0';
    }
    else {
        lpwszString = NULL;
    }

    erwData.lpfn.a = lpfnRegisterWordEnumProcA;
    erwData.lpData = lpData;
    erwData.dwCodePage = IMECodePage(pImeDpi);

    uRet = ImmEnumRegisterWordW(hKL, EnumRegisterWordProcW,
                    lpwszReading, dwStyle, lpwszString, (LPVOID)&erwData);

    if (lpwszReading != NULL)
        ImmLocalFree(lpwszReading);

    if (lpwszString != NULL)
        ImmLocalFree(lpwszString);

    ImmUnlockImeDpi(pImeDpi);
    return uRet;
}


UINT WINAPI ImmEnumRegisterWordW(
    HKL                   hKL,
    REGISTERWORDENUMPROCW lpfnRegisterWordEnumProcW,
    LPCWSTR               lpwszReading,
    DWORD                 dwStyle,
    LPCWSTR               lpwszString,
    LPVOID                lpData)
{
    PIMEDPI         pImeDpi;
    LPSTR           lpszReading;
    LPSTR           lpszString;
    INT             cchReading;
    INT             cchString;
    INT             i;
    ENUMREGWORDDATA erwData;
    UINT            uRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmEnumRegisterWordW: no pImeDpi entry.");
        return FALSE;
    }

    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        /*
         * Doesn't need W/A conversion. Calls directly to IME to
         * enumerate registered strings.
         */
        uRet = (*pImeDpi->pfn.ImeEnumRegisterWord.w)(lpfnRegisterWordEnumProcW,
                                                     lpwszReading,
                                                     dwStyle,
                                                     lpwszString,
                                                     lpData);
        ImmUnlockImeDpi(pImeDpi);
        return uRet;
    }

    /*
     * Unicode caller, ANSI IME. Needs W/A conversion on
     * lpwszReading and lpwszString.
     */
    if (lpwszReading != NULL) {
        cchReading = (wcslen(lpwszReading) + 1) * sizeof(WCHAR);
        lpszReading = ImmLocalAlloc(0, cchReading);
        if (lpszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmEnumRegisterWordW: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return 0;
        }

        i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                (DWORD)0,
                                (LPWSTR)lpwszReading,          // src
                                (INT)wcslen(lpwszReading),
                                (LPSTR)lpszReading,            // dest
                                cchReading,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszReading[i] = '\0';
    }
    else {
        lpszReading = NULL;
    }

    if (lpwszString != NULL) {
        cchString  = (wcslen(lpwszString) + 1) * sizeof(WCHAR);
        lpszString = ImmLocalAlloc(0, cchString);
        if (lpszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmEnumRegisterWordW: memory failure.");
            if (lpszReading != NULL)
                ImmLocalFree(lpszReading);
            ImmUnlockImeDpi(pImeDpi);
            return 0;
        }

        i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                (DWORD)0,
                                (LPWSTR)lpwszString,          // src
                                (INT)wcslen(lpwszString),
                                (LPSTR)lpszString,            // dest
                                cchString,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszString[i] = '\0';
    }
    else {
        lpszString = NULL;
    }

    erwData.lpfn.w = lpfnRegisterWordEnumProcW;
    erwData.lpData = lpData;
    erwData.dwCodePage = IMECodePage(pImeDpi);

    uRet = ImmEnumRegisterWordA(hKL, EnumRegisterWordProcA,
                    lpszReading, dwStyle, lpszString, (LPVOID)&erwData);

    if (lpszReading != NULL)
        ImmLocalFree(lpszReading);

    if (lpszString != NULL)
        ImmLocalFree(lpszString);

    ImmUnlockImeDpi(pImeDpi);
    return uRet;
}


UINT CALLBACK EnumRegisterWordProcA(
    LPCSTR            lpszReading,
    DWORD             dwStyle,
    LPCSTR            lpszString,
    PENUMREGWORDDATA  pEnumRegWordData)
{
    LPWSTR lpwszReading;
    LPWSTR lpwszString;
    INT    cchReading;
    INT    cchString;
    INT    i;
    UINT   uRet;

    ImmAssert(pEnumRegWordData != NULL);

    if (lpszReading != NULL) {
        cchReading = strlen(lpszReading) + sizeof(CHAR);
        lpwszReading = ImmLocalAlloc(0, cchReading * sizeof(WCHAR));
        if (lpwszReading == NULL) {
            RIPMSG0(RIP_WARNING, "EnumRegisterWordProcA: memory failure.");
            return 0;
        }

        i = MultiByteToWideChar(pEnumRegWordData->dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszReading,              // src
                                (INT)strlen(lpszReading),
                                (LPWSTR)lpwszReading,            // dest
                                cchReading);
        lpwszReading[i] = L'\0';
    }
    else {
        lpwszReading = NULL;
    }

    if (lpszString != NULL) {
        cchString  = strlen(lpszString) + sizeof(CHAR);
        lpwszString = ImmLocalAlloc(0, cchString * sizeof(WCHAR));
        if (lpwszString == NULL) {
            RIPMSG0(RIP_WARNING, "EnumRegisterWordProcA: memory failure.");
            if (lpwszReading != NULL)
                ImmLocalFree(lpwszReading);
            return 0;
        }

        i = MultiByteToWideChar(pEnumRegWordData->dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszString,              // src
                                (INT)strlen(lpszString),
                                (LPWSTR)lpwszString,            // dest
                                cchString);
        lpwszString[i] = L'\0';
    }
    else {
        lpwszString = NULL;
    }

    uRet = (*pEnumRegWordData->lpfn.w)(lpwszReading, dwStyle,
                            lpwszString, pEnumRegWordData->lpData);

    if (lpwszReading != NULL)
        ImmLocalFree(lpwszReading);

    if (lpwszString != NULL)
        ImmLocalFree(lpwszString);

    return uRet;
}


UINT CALLBACK EnumRegisterWordProcW(
    LPCWSTR          lpwszReading,
    DWORD            dwStyle,
    LPCWSTR          lpwszString,
    PENUMREGWORDDATA pEnumRegWordData)
{
    LPSTR lpszReading;
    LPSTR lpszString;
    INT   cchReading;
    INT   cchString;
    INT   i;
    UINT  uRet;

    ImmAssert(pEnumRegWordData != NULL);

    if (lpwszReading != NULL) {
        cchReading = (wcslen(lpwszReading) + 1) * sizeof(WCHAR);
        lpszReading = ImmLocalAlloc(0, cchReading);
        if (lpszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmRegisterWordW: memory failure.");
            return 0;
        }

        i = WideCharToMultiByte(pEnumRegWordData->dwCodePage,
                                (DWORD)0,
                                (LPWSTR)lpwszReading,          // src
                                (INT)wcslen(lpwszReading),
                                (LPSTR)lpszReading,            // dest
                                cchReading,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszReading[i] = '\0';
    }
    else {
        lpszReading = NULL;
    }

    if (lpwszString != NULL) {
        cchString  = (wcslen(lpwszString) + 1) * sizeof(WCHAR);
        lpszString = ImmLocalAlloc(0, cchString);
        if (lpszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmRegisterWordW: memory failure.");
            if (lpszReading != NULL)
                ImmLocalFree(lpszReading);
            return 0;
        }

        i = WideCharToMultiByte(pEnumRegWordData->dwCodePage,
                                (DWORD)0,
                                (LPWSTR)lpwszString,          // src
                                (INT)wcslen(lpwszString),
                                (LPSTR)lpszString,            // dest
                                cchString,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszString[i] = '\0';
    }
    else {
        lpszString = NULL;
    }

    uRet = (*pEnumRegWordData->lpfn.a)(lpszReading, dwStyle,
                            lpszString, pEnumRegWordData->lpData);

    if (lpszReading != NULL)
        ImmLocalFree(lpszReading);

    if (lpszString != NULL)
        ImmLocalFree(lpszString);

    return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\sftkbdt1.c ===
/**************************************************************************\
* Module Name: sftkbdt1.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Soft keyboard support for Traditional Chinese
*
* History:
* 02-Jan-1996 wkwok    - ported from Win95
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "softkbd.h"


CONST BYTE bSKT1VirtKey[SKT1_TOTAL_KEY_NUM] = {     // Virtual Key for Letter Buttons
//  `          1    2    3    4    5    6    7    8    9    0
    VK_OEM_3, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
//  -             =             \\                line 1 letter above
    VK_OEM_MINUS, VK_OEM_EQUAL, VK_OEM_BSLASH,
//   q    w    e    r    t    y    u    i    o    p
    'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
//  [                ]                            line 2 letter above
    VK_OEM_LBRACKET, VK_OEM_RBRACKET,
//   a    s    d    f    g    h    j    k    l
    'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L',
//   ;               '                            line 3 letter above
    VK_OEM_SEMICLN, VK_OEM_QUOTE,
//   z    x    c    v    b    n    m
    'Z', 'X', 'C', 'V', 'B', 'N', 'M',
//  ,              .              /               line 4 letter above
    VK_OEM_COMMA,  VK_OEM_PERIOD, VK_OEM_SLASH,
//  <-       tab     caps        enter
    VK_BACK, VK_TAB, VK_CAPITAL, VK_RETURN,
//  shift1    shift2    ctrl1       ctrl2
    VK_SHIFT, VK_SHIFT, VK_CONTROL, VK_CONTROL,
//  alt1     alt2     esc        space            special key above
    VK_MENU, VK_MENU, VK_ESCAPE, VK_SPACE
};


LOGFONT lfSKT1Font;


/**********************************************************************/
/* GetSKT1TextMetric                                                  */
/**********************************************************************/

void GetSKT1TextMetric(
     LPTEXTMETRIC   lptm)
{
    HDC     hDC;
    HFONT   hOldFont;
    SIZE    szDbcs;
    const WCHAR wcDbcs = 0x4e11;

    hDC = GetDC((HWND)NULL);

    // get the 9 pixels font
    RtlZeroMemory(&lfSKT1Font, sizeof lfSKT1Font);
    lfSKT1Font.lfHeight = -12;
    lfSKT1Font.lfWeight = FW_NORMAL;

    lfSKT1Font.lfCharSet = CHINESEBIG5_CHARSET;

    lfSKT1Font.lfOutPrecision = OUT_TT_ONLY_PRECIS;
    lfSKT1Font.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lfSKT1Font.lfQuality = PROOF_QUALITY;
    lfSKT1Font.lfPitchAndFamily = FIXED_PITCH|FF_MODERN;

    hOldFont = (HFONT)SelectObject(hDC, CreateFontIndirect(&lfSKT1Font));

    GetTextMetrics(hDC, lptm);

    /*
     * NT5: Dirty hack for "Lucida Console" which was "font linked" on NT5, and
     * GetTextMetrics API does not return correct text metrics.
     */
    if (GetTextExtentPoint32(hDC, &wcDbcs, 1, &szDbcs) && lptm->tmMaxCharWidth < szDbcs.cx) {
        TAGMSG2(DBGTAG_IMM, "GetSKT1TextMetric: tmMaxCharWidth(%d) is smaller than real width(%d).",
                lptm->tmMaxCharWidth, szDbcs.cx);
        lptm->tmMaxCharWidth = szDbcs.cx;
    }

    DeleteObject(SelectObject(hDC, hOldFont));

    ReleaseDC((HWND)NULL, hDC);

    return;
}

/**********************************************************************/
/* InitSKT1ButtonPos                                                  */
/**********************************************************************/
void InitSKT1ButtonPos(
    LPSKT1CTXT lpSKT1Ctxt)
{
    TEXTMETRIC  tm;
    int         nButtonWidthUnit, nButtonHeightUnit;
    int         i, nLetterButtonStart, nLetterButtonEnd, xStartPos, yStartPos;

    GetSKT1TextMetric(&tm);

    nButtonWidthUnit = tm.tmMaxCharWidth + SKT1_LABEL_BMP_X - SKT1_XOVERLAP;

#define INIT_WIDTH(name, width) \
            lpSKT1Ctxt->nButtonWidth[SKT1_ ## name ## _TYPE] = (width)

    INIT_WIDTH(LETTER,      nButtonWidthUnit * SKT1_LETTER_WIDTH_TIMES / 2);
    INIT_WIDTH(BACKSPACE,   nButtonWidthUnit * SKT1_BACKSPACE_WIDTH_TIMES / 2 + 1);
    INIT_WIDTH(TAB,         nButtonWidthUnit * SKT1_TAB_WIDTH_TIMES / 2 + (SKT1_XIN + 1) / 2);
    INIT_WIDTH(CAPS,        nButtonWidthUnit * SKT1_CAPS_WIDTH_TIMES / 2 + SKT1_XIN);
    INIT_WIDTH(ENTER,       nButtonWidthUnit * SKT1_ENTER_WIDTH_TIMES / 2 + (SKT1_XIN + 1) / 2);
    INIT_WIDTH(SHIFT,       nButtonWidthUnit * SKT1_SHIFT_WIDTH_TIMES / 2 + SKT1_XIN + (SKT1_XIN + 1) / 2);
    INIT_WIDTH(CTRL,        nButtonWidthUnit * SKT1_CTRL_WIDTH_TIMES / 2 + (SKT1_XIN + 1) / 2);
    INIT_WIDTH(ALT,         nButtonWidthUnit * SKT1_ALT_WIDTH_TIMES / 2 + (SKT1_XIN + 1) / 2);
    INIT_WIDTH(ESC,         nButtonWidthUnit * SKT1_ESC_WIDTH_TIMES / 2 + SKT1_XIN / 2);
    INIT_WIDTH(SPACE,       nButtonWidthUnit * SKT1_SPACE_WIDTH_TIMES / 2 + SKT1_XIN * 5);

#undef INIT_WIDTH

    nButtonHeightUnit = tm.tmHeight + SKT1_LABEL_BMP_Y;
    lpSKT1Ctxt->nButtonHeight[0] = nButtonHeightUnit;
    lpSKT1Ctxt->nButtonHeight[1] = nButtonHeightUnit * 2 + SKT1_YIN; // enter

    // init first row attribute
    xStartPos = gptRaiseEdge.x + SKT1_XOUT + (SKT1_XIN + 1) / 2;
    yStartPos = gptRaiseEdge.y + SKT1_YOUT + (SKT1_YIN + 1) / 2;

    nLetterButtonStart = 0;
    nLetterButtonEnd = nLetterButtonStart + SKT1_ROW1_LETTER_NUM;

    for (i = nLetterButtonStart; i < nLetterButtonEnd; i++) {
        lpSKT1Ctxt->ptButtonPos[i].x = xStartPos;
        lpSKT1Ctxt->ptButtonPos[i].y = yStartPos;
        xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE] + SKT1_XIN);
    }
    // backspace
    lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].y = yStartPos;

    // init second row attribute
    xStartPos = gptRaiseEdge.x + SKT1_XOUT + (SKT1_XIN + 1) / 2;
    yStartPos += (nButtonHeightUnit + SKT1_YIN);
    // tab
    lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_TAB_TYPE] + SKT1_XIN);
    // letter
    nLetterButtonStart = nLetterButtonEnd;
    nLetterButtonEnd = nLetterButtonStart + SKT1_ROW2_LETTER_NUM;
    for (i = nLetterButtonStart; i < nLetterButtonEnd; i++) {
        lpSKT1Ctxt->ptButtonPos[i].x = xStartPos;
        lpSKT1Ctxt->ptButtonPos[i].y = yStartPos;
        xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE] + SKT1_XIN);
    }
    // enter
    lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].y = yStartPos;

    // init third row
    xStartPos = gptRaiseEdge.x + SKT1_XOUT + (SKT1_XIN + 1) / 2;
    yStartPos += (nButtonHeightUnit + SKT1_YIN);
    // caps
    lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_CAPS_TYPE] + SKT1_XIN);
    // letter
    nLetterButtonStart = nLetterButtonEnd;
    nLetterButtonEnd = nLetterButtonStart + SKT1_ROW3_LETTER_NUM;
    for (i = nLetterButtonStart; i < nLetterButtonEnd; i++) {
        lpSKT1Ctxt->ptButtonPos[i].x = xStartPos;
        lpSKT1Ctxt->ptButtonPos[i].y = yStartPos;
        xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE] + SKT1_XIN);
    }

    // init fourth row
    xStartPos = gptRaiseEdge.x + SKT1_XOUT + (SKT1_XIN + 1) / 2;
    yStartPos += (nButtonHeightUnit + SKT1_YIN);
    // shift 1
    lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE] + SKT1_XIN);
    // letter
    nLetterButtonStart = nLetterButtonEnd;
    nLetterButtonEnd = nLetterButtonStart + SKT1_ROW4_LETTER_NUM;
    for (i = nLetterButtonStart; i < nLetterButtonEnd; i++) {
        lpSKT1Ctxt->ptButtonPos[i].x = xStartPos;
        lpSKT1Ctxt->ptButtonPos[i].y = yStartPos;
        xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE] + SKT1_XIN);
    }
    // shift 2
    lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].y = yStartPos;

    // init fifth row
    xStartPos = gptRaiseEdge.x + SKT1_XOUT + (SKT1_XIN + 1) / 2;
    yStartPos += (nButtonHeightUnit + SKT1_YIN);
    // ctrl 1
    lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE] + SKT1_XIN);
    // esc
    lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_ESC_TYPE] + SKT1_XIN);
    // alt 1
    lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE] + SKT1_XIN);
    // space
    lpSKT1Ctxt->ptButtonPos[SKT1_SPACE_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_SPACE_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_SPACE_TYPE] + SKT1_XIN);
    // alt 2 .. skip blank
    lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE] + SKT1_XIN) +
        (lpSKT1Ctxt->nButtonWidth[SKT1_ESC_TYPE] + SKT1_XIN);
    // ctrl 2
    lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].y = yStartPos;

    return;
}

/**********************************************************************/
/* SKT1DrawConvexRect                                                 */
/*     draw a convex rectangle                                        */
/*              (x,y)     x+nWidth+1                                  */
/*               +-----1------+                                       */
/*               |+----2-----||                                       */
/*               ||          ||                                       */
/*               ||          3|                                       */
/*               ||          ||                                       */
/*               |V          || <---- Rectangle                       */
/*               |<----------+|                                       */
/*  y+nHeight+1  +------------+                                       */
/*  1 - black                                                         */
/*  2 - while                                                         */
/*  3 - dark gray                                                     */
/**********************************************************************/
void SKT1DrawConvexRect(
    HDC hDC,
    int x,
    int y,
    int nWidth,
    int nHeight)
{
    // extend the context rect size
    x -= (SKT1_XIN + 1) / 2;
    y -= (SKT1_YIN + 1) / 2;
    nWidth += (SKT1_XIN + 1);
    nHeight += (SKT1_XIN + 1);

    // 1
    SelectObject(hDC, GetStockObject(BLACK_PEN));
    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));
    Rectangle(hDC, x, y, x + nWidth, y + nHeight);
    PatBlt(hDC, x, y, 1, 1, PATCOPY);
    PatBlt(hDC, x + nWidth, y, -1, 1, PATCOPY);
    PatBlt(hDC, x, y + nHeight, 1, -1, PATCOPY);
    PatBlt(hDC, x + nWidth, y + nHeight, -1, -1, PATCOPY);

    x++;
    y++;
    nWidth -= 2;
    nHeight -= 2;

    // 2
    PatBlt(hDC, x, y + nHeight, 1, -nHeight, WHITENESS);
    PatBlt(hDC, x, y, nWidth , 1, WHITENESS);
    // 3
    SelectObject(hDC, GetStockObject(GRAY_BRUSH));
    PatBlt(hDC, x, y + nHeight, nWidth, -1, PATCOPY);
    PatBlt(hDC, x + nWidth, y + nHeight, -1, -nHeight, PATCOPY);

    return;
}

/**********************************************************************/
/* SKT1DrawBitmap                                                     */
/**********************************************************************/
void SKT1DrawBitmap(
    HDC hDC,
    int x,
    int y,
    int nWidth,
    int nHeight,
    LPCWSTR lpszBitmap)
{
    HDC     hMemDC;
    HBITMAP hBitmap, hOldBmp;

    hBitmap = (HBITMAP)LoadBitmap(ghInst, lpszBitmap);

    hMemDC = CreateCompatibleDC(hDC);

    hOldBmp = (HBITMAP)SelectObject(hMemDC, hBitmap);

    BitBlt(hDC, x, y, nWidth, nHeight, hMemDC, 0 , 0, SRCCOPY);

    SelectObject(hMemDC, hOldBmp);

    DeleteObject(hBitmap);

    DeleteDC(hMemDC);

    return;
}

/**********************************************************************/
/* SKT1DrawLabel                                                      */
/**********************************************************************/
void SKT1DrawLabel(
    HDC        hDC,
    LPSKT1CTXT lpSKT1Ctxt,
    LPCWSTR     lpszLabel)
{
    HDC     hMemDC;
    HBITMAP hBitmap, hOldBmp;
    int     i;

    hBitmap = LoadBitmap(ghInst, lpszLabel);
    hMemDC = CreateCompatibleDC(hDC);
    hOldBmp = (HBITMAP)SelectObject(hMemDC, hBitmap);

    for (i = 0; i < SKT1_LETTER_KEY_NUM; i++) {
        BitBlt(hDC,
            lpSKT1Ctxt->ptButtonPos[i].x, lpSKT1Ctxt->ptButtonPos[i].y,
            SKT1_LABEL_BMP_X, SKT1_LABEL_BMP_Y,
            hMemDC, i * SKT1_LABEL_BMP_X, 0, SRCCOPY);
    }

    SelectObject(hMemDC, hOldBmp);
    DeleteDC(hMemDC);
    DeleteObject(hBitmap);

    return;
}


/**********************************************************************/
/* InitSKT1Bitmap                                                     */
/**********************************************************************/
void InitSKT1Bitmap(
    HWND hSKWnd,
    LPSKT1CTXT lpSKT1Ctxt)
{
    HDC  hDC, hMemDC;
    RECT rcClient;
    int  i;

    hDC = GetDC(hSKWnd);
    hMemDC = CreateCompatibleDC(hDC);
    GetClientRect(hSKWnd, &rcClient);
    lpSKT1Ctxt->hSKBitmap = CreateCompatibleBitmap(hDC,
        rcClient.right - rcClient.left,
        rcClient.bottom - rcClient.top);
    ReleaseDC(hSKWnd, hDC);
    SelectObject(hMemDC, lpSKT1Ctxt->hSKBitmap);

    // draw SK rectangle
    SelectObject(hMemDC, GetStockObject(NULL_PEN));
    SelectObject(hMemDC, GetStockObject(LTGRAY_BRUSH));
    Rectangle(hMemDC, rcClient.left, rcClient.top,
        rcClient.right + 1, rcClient.bottom + 1);

    DrawEdge(hMemDC, &rcClient, BDR_RAISED, BF_RECT);

    // draw the button from the last line
    // ctrl 1   -> line 5 special key
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE] / 2 - SKT1_CTRL_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_CTRL_BMP_Y / 2,
        SKT1_CTRL_BMP_X,
        SKT1_CTRL_BMP_Y,
        MAKEINTRESOURCEW(CTRL_T1));

    // ctrl 2
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE] / 2 - SKT1_CTRL_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_CTRL_BMP_Y / 2,
        SKT1_CTRL_BMP_X, SKT1_CTRL_BMP_Y,
        MAKEINTRESOURCEW(CTRL_T1));

    // esc
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_ESC_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_ESC_TYPE] / 2 - SKT1_ESC_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_ESC_BMP_Y / 2,
        SKT1_ESC_BMP_X, SKT1_ESC_BMP_Y,
        MAKEINTRESOURCEW(ESC_T1));

    // alt 1
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE] / 2 - SKT1_ALT_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_ALT_BMP_Y / 2,
        SKT1_ALT_BMP_X, SKT1_ALT_BMP_Y,
        MAKEINTRESOURCEW(ALT_T1));

    // alt 2
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE] / 2 - SKT1_ALT_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_ALT_BMP_Y / 2,
        SKT1_ALT_BMP_X, SKT1_ALT_BMP_Y,
        MAKEINTRESOURCEW(ALT_T1));

    // space
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_SPACE_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_SPACE_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_SPACE_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);

    // line 4
    // shift 1
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE] / 2 - SKT1_SHIFT_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_SHIFT_BMP_Y / 2,
        SKT1_SHIFT_BMP_X, SKT1_SHIFT_BMP_Y,
        MAKEINTRESOURCEW(SHIFT_T1));

    // shift 2
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE] / 2 - SKT1_SHIFT_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_SHIFT_BMP_Y / 2,
        SKT1_SHIFT_BMP_X, SKT1_SHIFT_BMP_Y,
        MAKEINTRESOURCEW(SHIFT_T1));

    // line 3
    // caps
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_CAPS_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_CAPS_TYPE] / 2 - SKT1_CAPS_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_CAPS_BMP_Y / 2,
        SKT1_CAPS_BMP_X, SKT1_CAPS_BMP_Y,
        MAKEINTRESOURCEW(CAPS_T1));

    // line 2
    // tab
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_TAB_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_TAB_TYPE] / 2 - SKT1_TAB_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_TAB_BMP_Y / 2,
        SKT1_TAB_BMP_X, SKT1_TAB_BMP_Y,
        MAKEINTRESOURCEW(TAB_T1));

    // enter
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_ENTER_TYPE],
        lpSKT1Ctxt->nButtonHeight[1]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_ENTER_TYPE] / 2 - SKT1_ENTER_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[1] / 2 - SKT1_ENTER_BMP_Y / 2,
        SKT1_ENTER_BMP_X, SKT1_ENTER_BMP_Y,
        MAKEINTRESOURCEW(ENTER_T1));

    // line 1
    // backspace
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_BACKSPACE_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_BACKSPACE_TYPE] / 2 - SKT1_BACKSPACE_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_BACKSPACE_BMP_Y / 2,
        SKT1_BACKSPACE_BMP_X, SKT1_BACKSPACE_BMP_Y,
        MAKEINTRESOURCEW(BACK_T1));

    // draw letter buttons
    for (i = SKT1_LETTER_KEY_NUM - 1; i >= 0 ; i--) {
        SKT1DrawConvexRect(hMemDC,
            lpSKT1Ctxt->ptButtonPos[i].x,
            lpSKT1Ctxt->ptButtonPos[i].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE],
            lpSKT1Ctxt->nButtonHeight[0]);
    }

    // draw latter label
    SKT1DrawLabel(hMemDC, lpSKT1Ctxt, MAKEINTRESOURCEW(LABEL_T1));

    DeleteDC(hMemDC);

    return;
}


/**********************************************************************/
/* CreateT1Window                                                     */
/**********************************************************************/
LRESULT CreateT1Window(
    HWND hSKWnd)
{
    HGLOBAL    hSKT1Ctxt;
    LPSKT1CTXT lpSKT1Ctxt;

    hSKT1Ctxt = GlobalAlloc(GHND, sizeof(SKT1CTXT));
    if (!hSKT1Ctxt) {
        return (-1);
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        GlobalFree(hSKT1Ctxt);
        return (-1);
    }

    SetWindowLongPtr(hSKWnd, SKT1_CONTEXT, (LONG_PTR)hSKT1Ctxt);

    lpSKT1Ctxt->uKeyIndex = SKT1_TOTAL_INDEX;
    lpSKT1Ctxt->ptSkOffset.x = SKT1_NOT_DRAG;
    lpSKT1Ctxt->ptSkOffset.y = SKT1_NOT_DRAG;
    lpSKT1Ctxt->lfCharSet = CHINESEBIG5_CHARSET;

    InitSKT1ButtonPos(lpSKT1Ctxt);

    InitSKT1Bitmap(hSKWnd, lpSKT1Ctxt);

    GlobalUnlock(hSKT1Ctxt);

    return (0L);
}

/**********************************************************************/
/* SKT1DrawDragBorder()                                               */
/**********************************************************************/
void SKT1DrawDragBorder(
    HWND    hWnd,               // window of IME is dragged
    LPPOINT lpptCursor,         // the cursor position
    LPPOINT lpptOffset)         // the offset form cursor to window org
{
    HDC  hDC;
    int  cxBorder, cyBorder;
    int  x, y;
    RECT rcWnd;

    cxBorder = GetSystemMetrics(SM_CXBORDER);   // width of border
    cyBorder = GetSystemMetrics(SM_CYBORDER);   // height of border

    x = lpptCursor->x - lpptOffset->x;
    y = lpptCursor->y - lpptOffset->y;

    // check for the max boundary of the display
    GetWindowRect(hWnd, &rcWnd);

    // draw the moving track
    hDC = CreateDC(L"DISPLAY", NULL, NULL, NULL);
    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // ->
    PatBlt(hDC, x, y, rcWnd.right - rcWnd.left - cxBorder, cyBorder,
        PATINVERT);
    // v
    PatBlt(hDC, x, y + cyBorder, cxBorder, rcWnd.bottom - rcWnd.top -
        cyBorder, PATINVERT);
    // _>
    PatBlt(hDC, x + cxBorder, y + rcWnd.bottom - rcWnd.top,
        rcWnd.right - rcWnd.left - cxBorder, -cyBorder, PATINVERT);
    //  v
    PatBlt(hDC, x + rcWnd.right - rcWnd.left, y,
        - cxBorder, rcWnd.bottom - rcWnd.top - cyBorder, PATINVERT);

    DeleteDC(hDC);
    return;
}

/**********************************************************************/
/* DestroyT1Window                                                    */
/**********************************************************************/
void DestroyT1Window(
    HWND hSKWnd)
{
    HGLOBAL    hSKT1Ctxt;
    LPSKT1CTXT lpSKT1Ctxt;
    HWND       hUIWnd;

    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
    if (!hSKT1Ctxt) {
        return;
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        return;
    }

    if (lpSKT1Ctxt->ptSkOffset.x != SKT1_NOT_DRAG &&
            lpSKT1Ctxt->ptSkOffset.y != SKT1_NOT_DRAG) {
        SKT1DrawDragBorder(hSKWnd, &lpSKT1Ctxt->ptSkCursor,
            &lpSKT1Ctxt->ptSkOffset);
    }

    DeleteObject(lpSKT1Ctxt->hSKBitmap);

    GlobalUnlock(hSKT1Ctxt);
    GlobalFree(hSKT1Ctxt);

    hUIWnd = GetWindow(hSKWnd, GW_OWNER);
    if (!hUIWnd) {
        return;
    }

    SendMessage(hUIWnd, WM_IME_NOTIFY, IMN_SOFTKBDDESTROYED, 0);

    return;
}

/**********************************************************************/
/* SKT1InvertButton                                                   */
/**********************************************************************/
void SKT1InvertButton(
    HWND       hSKWnd,
    HDC        hPaintDC,
    LPSKT1CTXT lpSKT1Ctxt,
    UINT       uKeyIndex)
{
    HDC hDC;
    int nWidth, nHeight;

    if (uKeyIndex >= SKT1_TOTAL_INDEX) {
        return;
    }

    nWidth = 0;
    if (hPaintDC) {
        hDC = hPaintDC;
    } else {
        hDC = GetDC(hSKWnd);
    }

    if (uKeyIndex < SKT1_LETTER_KEY_NUM) {
        nWidth = lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE];
    } else {
        switch (uKeyIndex) {
        case SKT1_BACKSPACE_INDEX:
            nWidth = lpSKT1Ctxt->nButtonWidth[SKT1_BACKSPACE_TYPE];
            break;
        case SKT1_TAB_INDEX:
            nWidth = lpSKT1Ctxt->nButtonWidth[SKT1_TAB_TYPE];
            break;
        case SKT1_CAPS_INDEX:
            nWidth = 0;
            MessageBeep((UINT) -1);
            break;
        case SKT1_ENTER_INDEX:
            nWidth = lpSKT1Ctxt->nButtonWidth[SKT1_ENTER_TYPE];
            break;
        case SKT1_SHIFT_INDEX:
        case SKT1_SHIFT_INDEX + 1:
        case SKT1_CTRL_INDEX:
        case SKT1_CTRL_INDEX + 1:
        case SKT1_ALT_INDEX:
        case SKT1_ALT_INDEX + 1:
            nWidth = 0;
            MessageBeep((UINT) -1);
            break;
        case SKT1_ESC_INDEX:
            nWidth = lpSKT1Ctxt->nButtonWidth[SKT1_ESC_TYPE];
            break;
        case SKT1_SPACE_INDEX:
            nWidth = lpSKT1Ctxt->nButtonWidth[SKT1_SPACE_TYPE];
            break;
        default:
            break;
        }
    }

    if (uKeyIndex == SKT1_ENTER_INDEX) {
        nHeight = lpSKT1Ctxt->nButtonHeight[1];
    } else {
        nHeight = lpSKT1Ctxt->nButtonHeight[0];
    }

    if (nWidth) {
        // do not reverse border
        PatBlt(hDC, lpSKT1Ctxt->ptButtonPos[uKeyIndex].x - 1,
            lpSKT1Ctxt->ptButtonPos[uKeyIndex].y - 1,
            nWidth + 2, nHeight + 2, DSTINVERT);
    }

    if (!hPaintDC) {
        ReleaseDC(hSKWnd, hDC);
    }

    return;
}

/**********************************************************************/
/* UpdateSKT1Window                                                   */
/**********************************************************************/
void UpdateSKT1Window(
    HDC  hDC,
    HWND hSKWnd)
{
    HGLOBAL    hSKT1Ctxt;
    LPSKT1CTXT lpSKT1Ctxt;
    HDC        hMemDC;
    RECT       rcClient;

    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
    if (!hSKT1Ctxt) {
        return;
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        return;
    }

    hMemDC = CreateCompatibleDC(hDC);

    SelectObject(hMemDC, lpSKT1Ctxt->hSKBitmap);

    GetClientRect(hSKWnd, &rcClient);

    BitBlt(hDC, 0, 0, rcClient.right - rcClient.left,
        rcClient.bottom - rcClient.top,
        hMemDC, 0, 0, SRCCOPY);

    DeleteDC(hMemDC);

    if (lpSKT1Ctxt->uKeyIndex < SKT1_TOTAL_INDEX) {
        SKT1InvertButton(hSKWnd, hDC, lpSKT1Ctxt, lpSKT1Ctxt->uKeyIndex);
    }

    GlobalUnlock(hSKT1Ctxt);

    return;
}

/**********************************************************************/
/* SKT1MousePosition()                                                */
/**********************************************************************/
UINT SKT1MousePosition(
    LPSKT1CTXT lpSKT1Ctxt,
    LPPOINT    lpptCursor)
{
    int   i;

    // check letter button
    for (i = 0; i < SKT1_LETTER_KEY_NUM; i++) {
        if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[i].x,
                lpSKT1Ctxt->ptButtonPos[i].y,
                lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE],
                lpSKT1Ctxt->nButtonHeight[0],
                lpptCursor)) {
            return i;
        }
    }

    // backSapce
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_BACKSPACE_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_BACKSPACE_INDEX;
    }

    // tab
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_TAB_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_TAB_INDEX;
    }

    // caps
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_CAPS_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_CAPS_INDEX;
    }

    // enter
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_ENTER_TYPE],
            lpSKT1Ctxt->nButtonHeight[1],
            lpptCursor)) {
        return SKT1_ENTER_INDEX;
    }

    // shift 1
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_SHIFT_INDEX;
    }

    // shift 2
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_SHIFT_INDEX;
    }

    // ctrl 1
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_CTRL_INDEX;
    }

    // ctrl 2
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_CTRL_INDEX;
    }

    // alt 1
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_ALT_INDEX;
    }

    // alt 2
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_ALT_INDEX;
    }

    // esc
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_ESC_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_ESC_INDEX;
    }

    // space
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_SPACE_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_SPACE_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_SPACE_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_SPACE_INDEX;
    }

    return SKT1_TOTAL_INDEX;      // This means out of range
}

/**********************************************************************/
/* SKT1IsValidButton                                                  */
/**********************************************************************/
BOOL SKT1IsValidButton(
    UINT       uKeyIndex,
    LPSKT1CTXT lpSKT1Ctxt)
{
    BOOL fRet;

    if (uKeyIndex < SKT1_LETTER_KEY_NUM) {
        if (lpSKT1Ctxt->wCodeTable[uKeyIndex]) {
            return TRUE;
        } else {
            return FALSE;
        }
    }

    // special key
    switch (uKeyIndex) {
    case SKT1_BACKSPACE_INDEX:
    case SKT1_TAB_INDEX:
    case SKT1_ENTER_INDEX:
    case SKT1_ESC_INDEX:
    case SKT1_SPACE_INDEX:
        fRet = TRUE;
        break;
    default:
        fRet = FALSE;
        break;
    }

    return fRet;
}

/**********************************************************************/
/* SKT1SetCursor                                                      */
/**********************************************************************/
BOOL SKT1SetCursor(
    HWND   hSKWnd,
    LPARAM lParam)
{
    HGLOBAL    hSKT1Ctxt;
    LPSKT1CTXT lpSKT1Ctxt;
    UINT       uKeyIndex;
    RECT       rcWnd;
    RECT       rcWork;
    SIZE       szWork;
    extern     void GetAllMonitorSize(LPRECT lprc);

    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
    if (!hSKT1Ctxt) {
        return (FALSE);
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        return (FALSE);
    }

    if (lpSKT1Ctxt->ptSkOffset.x != SKT1_NOT_DRAG &&
            lpSKT1Ctxt->ptSkOffset.y != SKT1_NOT_DRAG) {
        // in drag operation
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        goto UnlockSKT1Ctxt;
    }

    GetCursorPos(&lpSKT1Ctxt->ptSkCursor);
    ScreenToClient(hSKWnd, &lpSKT1Ctxt->ptSkCursor);

    uKeyIndex = SKT1MousePosition(lpSKT1Ctxt, &lpSKT1Ctxt->ptSkCursor);

    if (uKeyIndex < SKT1_TOTAL_INDEX) {
        SetCursor(LoadCursor(NULL, IDC_HAND));
    } else {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
    }


    if (HIWORD(lParam) != WM_LBUTTONDOWN) {
        goto UnlockSKT1Ctxt;
    }

    SetCapture(hSKWnd);

    if (lpSKT1Ctxt->uKeyIndex < SKT1_TOTAL_INDEX) {
        UINT uVirtKey;

        uVirtKey = bSKT1VirtKey[lpSKT1Ctxt->uKeyIndex];
        keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
            (DWORD)KEYEVENTF_KEYUP, 0);
        SKT1InvertButton(hSKWnd, NULL, lpSKT1Ctxt, lpSKT1Ctxt->uKeyIndex);
        lpSKT1Ctxt->uKeyIndex = SKT1_TOTAL_INDEX;
    }

    if (uKeyIndex < SKT1_TOTAL_INDEX) {
        UINT uVirtKey;

        if (SKT1IsValidButton(uKeyIndex, lpSKT1Ctxt)) {
            uVirtKey = bSKT1VirtKey[uKeyIndex];
            keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
                0, 0);
            lpSKT1Ctxt->uKeyIndex = uKeyIndex;
            SKT1InvertButton(hSKWnd, NULL, lpSKT1Ctxt, lpSKT1Ctxt->uKeyIndex);
        } else {
            MessageBeep((UINT)-1);
        }
        goto UnlockSKT1Ctxt;
    }

    GetAllMonitorSize(&rcWork);
    szWork.cx = rcWork.right - rcWork.left;
    szWork.cy = rcWork.bottom - rcWork.top;

    GetCursorPos(&lpSKT1Ctxt->ptSkCursor);
    GetWindowRect(hSKWnd, &rcWnd);
    lpSKT1Ctxt->ptSkOffset.x = lpSKT1Ctxt->ptSkCursor.x - rcWnd.left;
    lpSKT1Ctxt->ptSkOffset.y = lpSKT1Ctxt->ptSkCursor.y - rcWnd.top;

    SKT1DrawDragBorder(hSKWnd, &lpSKT1Ctxt->ptSkCursor,
        &lpSKT1Ctxt->ptSkOffset);

UnlockSKT1Ctxt:
    GlobalUnlock(hSKT1Ctxt);

    return (TRUE);
}

/**********************************************************************/
/* SKT1MouseMove                                                      */
/**********************************************************************/
BOOL SKT1MouseMove(
    HWND hSKWnd)
{
    HGLOBAL    hSKT1Ctxt;
    LPSKT1CTXT lpSKT1Ctxt;

    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
    if (!hSKT1Ctxt) {
        return FALSE;
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        return FALSE;
    }

    if (lpSKT1Ctxt->ptSkOffset.x == SKT1_NOT_DRAG ||
            lpSKT1Ctxt->ptSkOffset.y == SKT1_NOT_DRAG) {
        GlobalUnlock(hSKT1Ctxt);
        return FALSE;
    }

    SKT1DrawDragBorder(hSKWnd, &lpSKT1Ctxt->ptSkCursor,
        &lpSKT1Ctxt->ptSkOffset);

    GetCursorPos(&lpSKT1Ctxt->ptSkCursor);

    SKT1DrawDragBorder(hSKWnd, &lpSKT1Ctxt->ptSkCursor,
        &lpSKT1Ctxt->ptSkOffset);

    GlobalUnlock(hSKT1Ctxt);

    return TRUE;
}

/**********************************************************************/
/* SKT1ButtonUp                                                       */
/**********************************************************************/
BOOL SKT1ButtonUp(
    HWND hSKWnd)
{
    HGLOBAL        hSKT1Ctxt;
    LPSKT1CTXT     lpSKT1Ctxt;
    BOOL           fRet;
    POINT          pt;
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    fRet = FALSE;

    if (IsWndEqual(GetCapture(), hSKWnd)) {
        ReleaseCapture();
    }

    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
    if (!hSKT1Ctxt) {
        return (fRet);
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        return (fRet);
    }

    if (lpSKT1Ctxt->uKeyIndex < SKT1_TOTAL_INDEX) {
        UINT uVirtKey;

        uVirtKey = bSKT1VirtKey[lpSKT1Ctxt->uKeyIndex];
        keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
            (DWORD)KEYEVENTF_KEYUP, 0);
        SKT1InvertButton(hSKWnd, NULL, lpSKT1Ctxt, lpSKT1Ctxt->uKeyIndex);
        lpSKT1Ctxt->uKeyIndex = SKT1_TOTAL_INDEX;
        fRet = TRUE;
        goto UnlockSKT1Context;
    }

    if (lpSKT1Ctxt->ptSkOffset.x == SKT1_NOT_DRAG ||
            lpSKT1Ctxt->ptSkOffset.y == SKT1_NOT_DRAG) {
        goto UnlockSKT1Context;
    }

    SKT1DrawDragBorder(hSKWnd, &lpSKT1Ctxt->ptSkCursor,
        &lpSKT1Ctxt->ptSkOffset);

    pt.x = lpSKT1Ctxt->ptSkCursor.x - lpSKT1Ctxt->ptSkOffset.x,
    pt.y = lpSKT1Ctxt->ptSkCursor.y - lpSKT1Ctxt->ptSkOffset.y,

    SetWindowPos(hSKWnd, (HWND)NULL, pt.x, pt.y,
        0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    lpSKT1Ctxt->ptSkOffset.x = SKT1_NOT_DRAG;
    lpSKT1Ctxt->ptSkOffset.y = SKT1_NOT_DRAG;

    lpSKT1Ctxt->uKeyIndex = SKT1_TOTAL_INDEX;

    fRet = TRUE;

    hUIWnd = GetWindow(hSKWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        goto UnlockSKT1Context;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        goto UnlockSKT1Context;
    }

    lpIMC->ptSoftKbdPos.x = pt.x;
    lpIMC->ptSoftKbdPos.y = pt.y;
    lpIMC->fdwInit |= INIT_SOFTKBDPOS;

    ImmUnlockIMC(hIMC);

UnlockSKT1Context:
    GlobalUnlock(hSKT1Ctxt);

    return (fRet);
}

/**********************************************************************/
/* SetSKT1Data                                                        */
/**********************************************************************/
LRESULT SetSKT1Data(
    HWND          hSKWnd,
    LPSOFTKBDDATA lpSoftKbdData)
{
    HGLOBAL    hSKT1Ctxt;
    LPSKT1CTXT lpSKT1Ctxt;
    HDC        hDC, hMemDC;
    HGDIOBJ    hOldFont;
    int        i;

    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
    if (!hSKT1Ctxt) {
        return (1);
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        return (1);
    }

    hDC = GetDC(hSKWnd);
    hMemDC = CreateCompatibleDC(hDC);
    ReleaseDC(hSKWnd, hDC);
    SelectObject(hMemDC, lpSKT1Ctxt->hSKBitmap);

    SetBkColor(hMemDC, RGB(0xC0, 0xC0, 0xC0));

    if (lpSKT1Ctxt->lfCharSet != DEFAULT_CHARSET) {
        LOGFONT lfFont;
        CopyMemory(&lfFont, &lfSKT1Font, sizeof (LOGFONT));
        lfFont.lfCharSet = (BYTE)lpSKT1Ctxt->lfCharSet;
        hOldFont = (HFONT)SelectObject(hMemDC, CreateFontIndirect(&lfFont));
    }
    else {
        hOldFont = (HFONT)SelectObject(hMemDC, CreateFontIndirect(&lfSKT1Font));
    }

    for (i = 0; i < SKT1_LETTER_KEY_NUM; i++) {
        int  cbCount;
        RECT rcOpaque;

        lpSKT1Ctxt->wCodeTable[i] = lpSoftKbdData->wCode[0][bSKT1VirtKey[i]];

        cbCount = (lpSKT1Ctxt->wCodeTable[i] == 0) ? 0 : 1;

        rcOpaque.left = lpSKT1Ctxt->ptButtonPos[i].x + SKT1_LABEL_BMP_X -
            SKT1_XOVERLAP;
        rcOpaque.top = lpSKT1Ctxt->ptButtonPos[i].y + SKT1_LABEL_BMP_Y;

        rcOpaque.right = rcOpaque.left +
            lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE] - SKT1_LABEL_BMP_X +
            SKT1_XOVERLAP;
        rcOpaque.bottom = rcOpaque.top + lpSKT1Ctxt->nButtonHeight[0] -
            SKT1_LABEL_BMP_Y;

        ExtTextOut(hMemDC, rcOpaque.left, rcOpaque.top,
            ETO_OPAQUE, &rcOpaque,
            (LPWSTR)&lpSKT1Ctxt->wCodeTable[i], cbCount, NULL);
    }

    DeleteObject(SelectObject(hMemDC, hOldFont));

    DeleteDC(hMemDC);

    GlobalUnlock(hSKT1Ctxt);

    return (0);
}

/**********************************************************************/
/* SKWndProcT1                                                        */
/**********************************************************************/
LRESULT CALLBACK SKWndProcT1(
    HWND   hSKWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_CREATE:
        return CreateT1Window(hSKWnd);
    case WM_DESTROY:
        DestroyT1Window(hSKWnd);
        break;
    case WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hSKWnd, &ps);
            UpdateSKT1Window(hDC, hSKWnd);
            EndPaint(hSKWnd, &ps);
        }
        break;
    case WM_SETCURSOR:
        if (!SKT1SetCursor(hSKWnd, lParam)) {
            return DefWindowProc(hSKWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_MOUSEMOVE:
        if (!SKT1MouseMove(hSKWnd)) {
            return DefWindowProc(hSKWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:
        if (!SKT1ButtonUp(hSKWnd)) {
            return DefWindowProc(hSKWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    case WM_SHOWWINDOW:
        if (lParam != 0) {
        } else if ((BOOL)wParam == TRUE) {
        } else {
            // we want to hide the soft keyboard on mouse button down
            SKT1ButtonUp(hSKWnd);
        }

        return DefWindowProc(hSKWnd, uMsg, wParam, lParam);

    case WM_IME_CONTROL:
        switch (wParam) {
        case IMC_GETSOFTKBDFONT:
            {
                HGLOBAL    hSKT1Ctxt;
                LPSKT1CTXT lpSKT1Ctxt;
                BYTE       lfCharSet;

                hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
                if (!hSKT1Ctxt) {
                    return (1);
                }

                lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
                if (!lpSKT1Ctxt) {
                    return (1);
                }

                lfCharSet = (BYTE)lpSKT1Ctxt->lfCharSet;

                GlobalUnlock(hSKT1Ctxt);

                *(LPLOGFONT)lParam = lfSKT1Font;

                if (lfCharSet != DEFAULT_CHARSET) {
                    ((LPLOGFONT)lParam)->lfCharSet = lfCharSet;
                }

                return (0);
            }
            break;
        case IMC_SETSOFTKBDFONT:
            {
                // in differet version of Windows
                if (lfSKT1Font.lfCharSet != ((LPLOGFONT)lParam)->lfCharSet) {
                    HGLOBAL    hSKT1Ctxt;
                    LPSKT1CTXT lpSKT1Ctxt;

                    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd,
                        SKT1_CONTEXT);
                    if (!hSKT1Ctxt) {
                        return 1;
                    }

                    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
                    if (!lpSKT1Ctxt) {
                        return 1;
                    }

                    lpSKT1Ctxt->lfCharSet = ((LPLOGFONT)lParam)->lfCharSet;

                    GlobalUnlock(hSKT1Ctxt);
                }
            }
            break;
        case IMC_GETSOFTKBDPOS:
            {
                RECT rcWnd;

                GetWindowRect(hSKWnd, &rcWnd);

                return MAKELRESULT(rcWnd.left, rcWnd.top);
            }
            break;
        case IMC_SETSOFTKBDPOS:
            {
                POINT          ptSoftKbdPos;
                HWND           hUIWnd;
                HIMC           hIMC;
                LPINPUTCONTEXT lpIMC;

                ptSoftKbdPos.x = ((LPPOINTS)lParam)->x;
                ptSoftKbdPos.y = ((LPPOINTS)lParam)->y;

                SetWindowPos(hSKWnd, NULL,
                    ptSoftKbdPos.x, ptSoftKbdPos.y,
                    0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

                // Here we want to get - the owner or parent window
                hUIWnd = GetParent(hSKWnd);

                if (!hUIWnd) {
                    return (1);
                }

                hIMC = (HIMC) GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

                if (!hIMC) {
                    return (1);
                }

                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);

                if (!lpIMC) {
                    return (1);
                }

                lpIMC->ptSoftKbdPos = ptSoftKbdPos;

                ImmUnlockIMC(hIMC);

                return (0);
            }
            break;
        case IMC_SETSOFTKBDDATA:
            {
                LRESULT lRet;

                lRet = SetSKT1Data(hSKWnd, (LPSOFTKBDDATA)lParam);
                if (!lRet) {
                    InvalidateRect(hSKWnd, NULL, FALSE);
                    PostMessage(hSKWnd, WM_PAINT, 0, 0);
                }
                return (lRet);
            }
            break;
        case IMC_GETSOFTKBDSUBTYPE:
        case IMC_SETSOFTKBDSUBTYPE:
            {
                HGLOBAL    hSKT1Ctxt;
                LPSKT1CTXT lpSKT1Ctxt;
                LRESULT    lRet;

                lRet = -1;

                hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
                if (!hSKT1Ctxt) {
                    return (lRet);
                }

                lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
                if (!lpSKT1Ctxt) {
                    return (lRet);
                }

                if (wParam == IMC_GETSOFTKBDSUBTYPE) {
                    lRet = lpSKT1Ctxt->uSubType;
                } else if (wParam == IMC_SETSOFTKBDSUBTYPE) {
                    lRet = lpSKT1Ctxt->uSubType;
                    lpSKT1Ctxt->uSubType = (UINT)lParam;
                } else {
                    lRet = -1;
                }

                GlobalUnlock(hSKT1Ctxt);
                return (lRet);
            }
            break;
        default:
            break;
        }
        break;
    default:
        return DefWindowProc(hSKWnd, uMsg, wParam, lParam);
    }

    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\softkbd.c ===
/**************************************************************************\
* Module Name: softkbd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Soft keyboard APIs
*
* History:
* 03-Jan-1996 wkwok    Ported from Win95
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "softkbd.h"


CONST LPCWSTR SoftKeyboardClassName[] = {
    L"",
    L"SoftKBDClsT1",
    L"SoftKBDClsC1"
};


BOOL RegisterSoftKeyboard(
    UINT uType)
{
    WNDCLASSEX wcWndCls;

    if (GetClassInfoEx(ghInst, SoftKeyboardClassName[uType], &wcWndCls)) {
        return (TRUE);
    }

    wcWndCls.cbSize        = sizeof(WNDCLASSEX);
    wcWndCls.style         = CS_IME;
    wcWndCls.cbClsExtra    = 0;
    wcWndCls.cbWndExtra    = sizeof(HGLOBAL);
    wcWndCls.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    wcWndCls.hInstance     = ghInst;
    wcWndCls.hCursor       = LoadCursor(NULL, IDC_SIZEALL);
    wcWndCls.lpszMenuName  = (LPWSTR)NULL;
    wcWndCls.lpszClassName = SoftKeyboardClassName[uType];
    wcWndCls.hIconSm       = NULL;

    switch (uType) {
    case SOFTKEYBOARD_TYPE_T1:
        wcWndCls.lpfnWndProc   = SKWndProcT1;
        wcWndCls.hbrBackground = GetStockObject(NULL_BRUSH);
        break;
    case SOFTKEYBOARD_TYPE_C1:
        wcWndCls.lpfnWndProc   = SKWndProcC1;
        wcWndCls.hbrBackground = GetStockObject(LTGRAY_BRUSH);
        break;
    default:
        return (TRUE);
    }

    if (RegisterClassEx(&wcWndCls)) {
        return (TRUE);
    } else {
        return (FALSE);
    }
}


VOID GetSoftKeyboardDimension(
    UINT  uType,
    LPINT lpnWidth,
    LPINT lpnHeight)
{
    switch (uType) {
    case SOFTKEYBOARD_TYPE_T1:
        {
            TEXTMETRIC  tm;

            GetSKT1TextMetric(&tm);

            *lpnWidth = 2 * SKT1_XOUT + 2 * gptRaiseEdge.x +
                (tm.tmMaxCharWidth + SKT1_LABEL_BMP_X - SKT1_XOVERLAP +
                SKT1_XIN) * SKT1_TOTAL_COLUMN_NUM + 1 + 1;

            *lpnHeight = 2 * SKT1_YOUT + 2 * gptRaiseEdge.y +
                (tm.tmHeight + SKT1_LABEL_BMP_Y + SKT1_YIN) *
                SKT1_TOTAL_ROW_NUM + 1;
        }
        break;
    case SOFTKEYBOARD_TYPE_C1:
        {
            *lpnWidth = WIDTH_SOFTKBD_C1 +
                2 * GetSystemMetrics(SM_CXBORDER) +
                2 * GetSystemMetrics(SM_CXEDGE);

            *lpnHeight = HEIGHT_SOFTKBD_C1 +
                2 * GetSystemMetrics(SM_CXBORDER) +
                2 * GetSystemMetrics(SM_CXEDGE);
        }
        break;
    default:
        return;
    }
}


void GetAllMonitorSize(LPRECT lprc)
{
    if (GetSystemMetrics(SM_CMONITORS) == 1) {
         SystemParametersInfo(SPI_GETWORKAREA, 0, lprc, 0);
     } else {
        // We have multi-monitor !
        lprc->left = GetSystemMetrics(SM_XVIRTUALSCREEN);
        lprc->top =  GetSystemMetrics(SM_YVIRTUALSCREEN);
        lprc->right = lprc->left + GetSystemMetrics(SM_CXVIRTUALSCREEN);
        lprc->bottom = lprc->top + GetSystemMetrics(SM_CYVIRTUALSCREEN);
    }
}

BOOL GetNearestMonitorSize(HWND hwndOwner, LPRECT lprc)
{
    if (GetSystemMetrics(SM_CMONITORS) == 1) {
        GetAllMonitorSize(lprc);
    }
    else {
        HMONITOR hmonitor = MonitorFromWindow(hwndOwner, MONITOR_DEFAULTTONEAREST);
        MONITORINFO mInfo = {
            sizeof(MONITORINFO),
        };

        if (hmonitor == NULL) {
            return FALSE;
        }
        GetMonitorInfoW(hmonitor, &mInfo);
        *lprc = mInfo.rcWork;
    }
    return TRUE;
}

HWND WINAPI
ImmCreateSoftKeyboard(
    UINT uType,
    HWND hOwner,
    int  x,
    int  y)
{
    static BOOL fFirstSoftKeyboard = TRUE;
    PIMEDPI     pImeDpi;
    DWORD       fdwUICaps;
    int         nWidth, nHeight;
    HKL         hCurrentKL;
    UINT        i;
    HWND        hSKWnd;
    RECT        rcWork;
    SIZE        szWork;

    if (!uType) {
        return (HWND)NULL;
    }

    if (uType >= sizeof(SoftKeyboardClassName) / sizeof(LPWSTR)) {
        return (HWND)NULL;
    }

    hCurrentKL = GetKeyboardLayout(0);

    pImeDpi = ImmLockImeDpi(hCurrentKL);
    if (pImeDpi == NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmCreateSoftKeyboard, pImeDpi = NULL (hkl = 0x%x).\n", hCurrentKL);
        return (HWND)NULL;
    }

    fdwUICaps = pImeDpi->ImeInfo.fdwUICaps;
    ImmUnlockImeDpi(pImeDpi);

    if (!(fdwUICaps & UI_CAP_SOFTKBD)) {
        return (HWND)NULL;
    }

    if (fFirstSoftKeyboard) {
        if (!GetNearestMonitorSize(hOwner, &rcWork)) {
            // failed
            return NULL;
        }

        for (i = 0; i < sizeof(guScanCode) / sizeof(UINT); i++) {
            guScanCode[i] = MapVirtualKey(i, 0);
        }


        // LATER: have to consider the dynamic resolution change

        szWork.cx = rcWork.right - rcWork.left;

        UserAssert(szWork.cx > UI_MARGIN * 2);
        szWork.cy = rcWork.bottom - rcWork.top;
        UserAssert(szWork.cy > UI_MARGIN * 2);

        gptRaiseEdge.x = GetSystemMetrics(SM_CXEDGE) +
            GetSystemMetrics(SM_CXBORDER);
        gptRaiseEdge.y = GetSystemMetrics(SM_CYEDGE) +
            GetSystemMetrics(SM_CYBORDER);

        fFirstSoftKeyboard = FALSE;
    }

    if (!RegisterSoftKeyboard(uType)) {
        return (HWND)NULL;
    }

    GetSoftKeyboardDimension(uType, &nWidth, &nHeight);

    // boundry check
    if (x < 0) {
        x = 0;
    } else if (x + nWidth > szWork.cx) {
        x = szWork.cx - nWidth;
    }

    if (y < 0) {
        y = 0;
    } else if (y + nHeight > szWork.cy) {
        y = szWork.cy - nHeight;
    }

    switch (uType) {
    case SOFTKEYBOARD_TYPE_T1:
        hSKWnd = CreateWindowEx(0,
                                SoftKeyboardClassName[uType],
                                (LPCWSTR)NULL,
                                WS_POPUP|WS_DISABLED,
                                x, y, nWidth, nHeight,
                                (HWND)hOwner, (HMENU)NULL, ghInst, NULL);
        break;
    case SOFTKEYBOARD_TYPE_C1:
        hSKWnd = CreateWindowEx(WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                                SoftKeyboardClassName[uType],
                                (LPCWSTR)NULL,
                                WS_POPUP|WS_DISABLED|WS_BORDER,
                                x, y, nWidth, nHeight,
                                (HWND)hOwner, (HMENU)NULL, ghInst, NULL);
        break;
    default:
        return (HWND)NULL;
    }

    ShowWindow(hSKWnd, SW_HIDE);
    UpdateWindow(hSKWnd);

    return (hSKWnd);
}


BOOL WINAPI
ImmDestroySoftKeyboard(
    HWND hSKWnd)
{
    return DestroyWindow(hSKWnd);
}


BOOL WINAPI
ImmShowSoftKeyboard(
    HWND hSKWnd,
    int  nCmdShow)
{
    if (!hSKWnd) {
        return (FALSE);
    }
    return ShowWindow(hSKWnd, nCmdShow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF
!include $(WINCORE_PATH)\core.inc

TARGETNAME=imm32
TARGETNAMEP=imm32p
TARGETTYPE=DYNLINK
DLLENTRY=ImmDllInitialize

TARGETPATH=$(_OBJ_DIR)
PASS1_PUBLISH=\
    {$(DYNLINK_LIB)=$(SDK_LIB_DEST)\$(DYNLINK_LIBDIR)}        \
    {$(DYNLINK_LIBP)=$(WINDOWS_LIB_DEST)\$(DYNLINK_LIBPDIR)}

TARGETLIBS=$(SDK_LIB_PATH)\kernl32p.lib                       \
           $(WINDOWS_LIB_PATH)\gdi32p.lib                     \
           $(SDK_LIB_PATH)\advapi32.lib                       \
           $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\user32p.lib


LINKLIBS = $(WUMODE_PATH)\$(ALT_PROJECT)\$(O)\w32umode.lib \
           $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\user32p.lib     \
           $(NTUSER_PATH)\rtl\client\$(ALT_PROJECT)\$(O)\userrtl.lib   \
           $(WINCORE_PATH)\rtl\client\$(O)\w32crtl.lib \
           $(SDK_LIB_PATH)\uuid.lib

PRIVLIB=$(O)\$(TARGETNAMEP).lib
NTTARGETFILE1=$(PRIVLIB)

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -DUNICODE

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..;..\..\inc;                \
         ..\..\inc\$(ALT_PROJECT);    \
         $(WINCORE_PATH)\w32inc;      \
         $(WINCORE_PATH)\w32inc\$(O); \
         $(ADVCORE_PATH)\ctf\inc;     \
         $(BASE_INC_PATH)
#
NTPROFILEINPUT=yes

NT_UP=0
USE_NTDLL=1
DLLDEF=..\$(TARGETNAME).def
DLLORDER=..\$(TARGETNAME).prf

SOURCES=..\res.rc     \
        ..\context.c  \
        ..\ctxtinfo.c \
        ..\globals.c  \
        ..\hotkey.c   \
        ..\immime.c   \
        ..\imminit.c  \
        ..\layime.c   \
        ..\layout.c   \
        ..\misc.c     \
        ..\regword.c  \
        ..\sftkbdc1.c \
        ..\sftkbdt1.c \
        ..\softkbd.c  \
        ..\input.c    \
        ..\clwinnls.c \
        ..\transsub.c \
        ..\kcodecnv.c \
        ..\jtranmsg.c \
        ..\ktranmsg.c \
        ..\conime.c \
        ..\imemenu.c \
        ..\com.c

UMTYPE=windows

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\transsub.c ===
/****************************** Module Header ******************************\
* Module Name: transsub.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the translation layer functions
* of the sub functions of SendImeMessageEx.
*
* History:
* 21-May-1996 takaok      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

LRESULT TransSetOpenK( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme );
LRESULT TransSetOpenJ( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme );
LRESULT TransGetOpenK( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi );
LRESULT TransGetOpenJ( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi );
LRESULT TransMoveImeWindow( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme);
LRESULT TransSetConversionWindow(  HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme );
LRESULT TransSetConversionMode( HIMC hImc, LPIMESTRUCT lpIme );
LRESULT TransGetMode( HIMC hImc );
LRESULT TransGetConversionMode( HIMC hImc );
LRESULT TransSetMode( HIMC hImc, LPIMESTRUCT lpIme );
LRESULT TransSendVKey( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi );
LRESULT TransEnterWordRegisterMode( HWND hWndApp, LPIMESTRUCT lpIme, BOOL fAnsi);
LRESULT TransSetConversionFontEx( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi);
LRESULT TransHanjaMode( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme);
UINT Get31ModeFrom40ModeJ( DWORD fdwConversion );
UINT Get31ModeFrom40ModeK( DWORD fdwConversion );
LRESULT TransVKDBEMode( HIMC hImc, WPARAM wVKDBE );

BOOL  SetFontForMCWVERTICAL( HWND hWndApp, HIMC hImc, LPINPUTCONTEXT pInputContext, BOOL fVert );
BOOL IsForegroundThread( HWND );
BOOL FixLogfont( LPLOGFONTW lplfW, BOOL fVert );

BOOL MySetCompFont( HWND, HIMC, LPLOGFONTW );
BOOL MySetCompWindow( HWND, HIMC, LPCOMPOSITIONFORM );
BOOL MySetCandidateWindow( HWND, HIMC, LPCANDIDATEFORM );
BOOL MyPostImsMessage( HWND hWndApp, WPARAM wParam, LPARAM lParam);

//===================================================================
// TranslateIMESubFunctions
//==========================
//
// KOREAN and JAPANESE common translate routine for the
// sub functions of SendImeMessageEx.
//
// History:
// 21-May-1996 takaok      Created.
//
//===================================================================
LRESULT TranslateIMESubFunctions(
    HWND hWndApp,
    LPIMESTRUCT lpIme,
    BOOL fAnsi)
{
    HIMC        hImc;
    LRESULT     lRet;
    DWORD       dwLangID;

    hImc = ImmGetSaveContext( hWndApp, IGSC_DEFIMCFALLBACK );
    if ( hImc == NULL_HIMC ) {
        return FALSE;
    }

    dwLangID = PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID()));

    switch (lpIme->fnc) {
    case 0x03:  // IME_QUERY, IME_GETIMECAPS: KOREAN & JAPANESE
        lRet = TRUE;
        break;

    case 0x04:  // IME_SETOPEN: KOREAN & JAPANESE
        if ( dwLangID == LANG_KOREAN )
            lRet = TransSetOpenK( hWndApp, hImc, lpIme );
        else
            lRet = TransSetOpenJ( hWndApp, hImc, lpIme );
        break;

    case 0x05:  // IME_GETOPEN: KOREAN & JAPANESE
        if ( dwLangID == LANG_KOREAN )
            lRet = TransGetOpenK( hWndApp, hImc, lpIme, fAnsi );
        else
            lRet = TransGetOpenJ( hWndApp, hImc, lpIme, fAnsi );
        break;

    case 0x06:  // IME_ENABLEDOSIME, IME_ENABLE
    // internal functions are not supported
        lRet = FALSE;
        break;

    case 0x07:  // IME_GETVERSION: KOREAN & JAPANESE
        lRet = IMEVER_31;
        break;

    case 0x08:  // IME_MOVEIMEWINDOW, IME_SETCONVERSIONWINDOW: KOREAN & JAPANESE

        if ( dwLangID == LANG_KOREAN ) {
            //
            // IME_MOVEIMEWINDOW for KOREAN
            //
            lRet = TransMoveImeWindow(hWndApp, hImc, lpIme);
        } else {
            //
            // IME_MOVECONVERTWINDOW or IME_SETCONVERSIONWINDOW for JAPANESE
            //
            lRet = TransSetConversionWindow( hWndApp, hImc, lpIme );
        }
        break;

//  case 0x09:  // undefined

    case 0x10:  // IME_SETCONVERSIONMODE: JAPANESE
        if ( dwLangID == LANG_JAPANESE ) {
            lRet = TransSetConversionMode( hImc, lpIme );
        } else {
            lRet = FALSE;
        }
        break;

    case 0x11:  // IME_GETCONVERSIONMODE, IME_GETMODE: // KOREAN & JAPANESE
        // Use hSaveIMC, If WINNSEnableIME(FALSE).
        if ( dwLangID == LANG_KOREAN ) {
        //
        // IME_GETMODE for KOREAN
        //
            lRet = TransGetMode( hImc );
        } else {
        //
        // IME_GETCONVERSIONMODE for JAPANESE
        //
            lRet = TransGetConversionMode( hImc );
        }
        break;

    case 0x12:  // IME_SET_MODE, IME_SETFONT, IME_SETCONVERSIONFONT: KOREAN & JAPANESE
        if ( dwLangID == LANG_KOREAN ) {
            //
            // IME_SET_MODE for KOREAN
            //
            lRet = TransSetMode( hImc, lpIme );
        } else {
            //
            // IME_SETCONVERSIONFONT for JAPANESE
            //
            lRet = FALSE;   // should not be called. use SETCONVERSIONFONTEX instead
        }
        break;

    case 0x13:  // IME_SENDVKEY, IME_SENDKEY: JAPANESE only
        if ( dwLangID == LANG_JAPANESE ) {
            lRet = TransSendVKey( hWndApp, hImc, lpIme, fAnsi );
        } else {
            lRet = FALSE;
        }
        break;

//
// internal sub functions are not supported
//
//  case 0x14: // IME_DESTROY, IME_DESTROYIME
//  case 0x15: // IME_PRIVATE
//  case 0x16: // IME_WINDOWUPDATE
//  case 0x17: // IME_SELECT

    case 0x18: // IME_ENTERWORDREGISTERMODE: JAPANESE only
        if ( dwLangID == LANG_JAPANESE ) {
            lRet = TransEnterWordRegisterMode( hWndApp, lpIme, fAnsi);
        } else {
            lRet = FALSE;
        }
        break;

    case 0x19:  // IME_SETCONVERSIONFONTEX: JAPANESE only
        if ( dwLangID == LANG_JAPANESE ) {
            lRet = TransSetConversionFontEx( hWndApp, hImc, lpIme, fAnsi);
        } else {
            lRet = FALSE;
        }
        break;

//
// internal sub functions are not supported
//
//  case 0x1A: // IME_DBCSNAME
//  case 0x1B: // IME_MAXKEY
//  case 0x1C: // IME_WINNLS_SK

    case 0x20:  // IME_CODECONVERT: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            if (TransCodeConvert( hImc, lpIme))
                lRet = lpIme->wParam;
            else
                lRet = 0;
        } else {
            lRet = 0;
        }
        break;

    case 0x21:  // IME_CONVERTLIST: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            lRet = TransConvertList( hImc, lpIme);
        } else {
            lRet = FALSE;
        }
        break;

//
// internal sub functions and undefined sub functions are not supported
//
//  case 0x22:  // IME_INPUTKEYTOSEQUENCE
//  case 0x23:  // IME_SEQUENCETOINTERNAL
//  case 0x24:  // IME_QUERYIMEINFO
//  case 0x25:  // IME_DIALOG
//  case 0x26 - 0x2f:   // undefined

    case 0x30:  // IME_AUTOMATA: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            lRet = ImmEscape(GetKeyboardLayout(0), hImc, IME_AUTOMATA, lpIme);
        } else {
            lRet = FALSE;
        }
        break;

    case 0x31:  // IME_HANJAMODE: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            lRet = TransHanjaMode( hWndApp,  hImc, lpIme);
        } else {
            lRet = FALSE;
        }
        break;
//
//  case 0x32 - 0x3f: // undefined
//
    case 0x40:  // IME_GETLEVEL: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            lRet = TransGetLevel( hWndApp );
        } else {
            lRet = FALSE;
        }
        break;

    case 0x41:  // IME_SETLEVEL: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            lRet = TransSetLevel( hWndApp, lpIme);
        } else {
            lRet = FALSE;
        }
        break;

    case 0x42:  // IME_GETMNTABLE: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            lRet = TransGetMNTable( hImc, lpIme);
        } else {
            lRet = FALSE;
        }
        break;

#if defined(PENAPI)
    case IME_SETUNDETERMINESTRING:
        lRet = FSetUndetermine( hImc, (HGLOBAL)lpIME->lParam1);
        break;

    case IME_SETCAPTURE:
        lRet = FEnablePenUi((HWND)lpIME->wParam, (lpIME->wParam != NULL));
        break;
#endif

#ifdef LATER // IME_NOTIFYWOWTASKEXIT
    case IME_NOTIFYWOWTASKEXIT:
      //
      // Destroy the default IME window of WOW 16bit
      // applications now. We should not wait for the
      // server wow thread clean up that will destroy the
      // IME window because usrsrv won't send WM_DESTROY
      // to non-server side window procedures. Some IMEs
      // must receive WM_DESTROY to free up 32 bit objects.
      //
      //  kksuzuka #7982:IME memory leak on WOW16 applications.
      //
      PIMMTHREADINFO piti = PitiCurrent();

      if ( piti != NULL && IsWindow( piti->hwndDefaultIme ) ) {
          DestroyWindow( piti->hwndDefaultIme );
      }
      return TRUE;
#endif
    default:
        //
        // private/internal/undefined functions are not supported
        //
        lRet = FALSE;
        break;
    }

    return (lRet);
}

//===================================================================
// TransSetOpenK
//===============
//
// KOREAN only
//
// History:
// xx-xx-1995     xxx      Created
//
//===================================================================
LRESULT TransSetOpenK( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme )
{
    // NOTE: We will use this function instead of ImmEscape().
    LRESULT lRet;

    lRet = ImmEscape(GetKeyboardLayout(0), hImc, IME_SETOPEN, lpIme);
    return (lRet);
    UNREFERENCED_PARAMETER(hWndApp);
}

//===================================================================
// TransSetOpenJ
//===============
//
// Japanese only
//
// History:
// 20-May-1996     takaok      Created
//
//===================================================================
LRESULT TransSetOpenJ( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme )
{
    LRESULT lRet;

    lRet = ImmGetOpenStatus( hImc );
    //
    // if the owner thread of hIMC doesn't have the input focus,
    // we won't call UI.
    //
    if ( !IsForegroundThread( NULL ) && !GetFocus() ) {
        //
        // this thread doesn't have focus.
        // let's update the input context and return without calling UI
        //
        PINPUTCONTEXT pInputContext;

        if ( (pInputContext = ImmLockIMC(hImc)) != NULL ) {
            if ( (pInputContext->fOpen && ! lpIme->wParam ) ||
                 (!pInputContext->fOpen &&  lpIme->wParam ) )
            {
                pInputContext->fOpen = (BOOL)lpIme->wParam;
                ImmNotifyIME( hImc, NI_CONTEXTUPDATED, 0, IMC_SETOPENSTATUS);
            }
            ImmUnlockIMC( hImc );
        }
    } else {
        ImmSetOpenStatus( hImc, (BOOL)lpIme->wParam );
    }
    return lRet;
    UNREFERENCED_PARAMETER(hWndApp);
}

//===================================================================
// TransGetOpenK
//===============
//
// KOREAN only
//
// History:
// xx-xx-1995     xxx      Created
//
//===================================================================
LRESULT TransGetOpenK( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi )
{
    // NOTE: We will use this function instead of ImmEscape().
    RECT    rc;
    LPARAM  lTemp;
    LRESULT lRet;

    lTemp = lpIme->lParam2;
    GetWindowRect(hWndApp, &rc);
    lpIme->lParam2 = MAKELONG(rc.top, rc.left);
    lRet = ImmEscape(GetKeyboardLayout(0), hImc, IME_GETOPEN, lpIme);
    lpIme->lParam2 = lTemp;
    return (lRet);
    UNREFERENCED_PARAMETER(fAnsi);
}

//===================================================================
// TransGetOpenJ
//===============
//
// Japanese only
//
// History:
// 20-May-1996     takaok      Created
//
//===================================================================
LRESULT TransGetOpenJ( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi )
{
    INT Count;
    LRESULT lRet;

    lRet = ImmGetOpenStatus( hImc );

    // lpIME->wCount is the length of the composition string.
    if ( fAnsi ) {
        Count= ImmGetCompositionStringA( hImc, GCS_COMPSTR, NULL, 0L );
    } else {
        Count= ImmGetCompositionStringW( hImc, GCS_COMPSTR, NULL, 0L );
    }
    lpIme->wCount = ( Count > 0 ) ? Count : 0;

    return lRet;
    UNREFERENCED_PARAMETER(hWndApp);
}

//===================================================================
// TransMoveImeWindow
//====================
//
// Korean only
//
//===================================================================
LRESULT TransMoveImeWindow( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme)
{
    // NOTE: We will use this function instead of ImmEscape().
    POINT   pt;
    LRESULT lRet;

    if (lpIme->wParam == MCW_WINDOW)
    {
        pt.x = GET_X_LPARAM(lpIme->lParam1);
        pt.y = GET_Y_LPARAM(lpIme->lParam1);
        ClientToScreen(hWndApp, &pt);
        lpIme->lParam1 = MAKELONG(pt.x, pt.y);
    }
    lRet = ImmEscape(GetKeyboardLayout(0), hImc, IME_MOVEIMEWINDOW, lpIme);
    return (lRet);
}


//===================================================================
// TransSetConversionWindow
//=========================
//
// Japanese only
//
//===================================================================
LRESULT TransSetConversionWindow(  HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme )
{
    LPINPUTCONTEXT pInputContext;
    COMPOSITIONFORM cof;
    CANDIDATEFORM   caf;
    POINT pt;
    RECT  rt;
    INT   i;

    if ( ! IsForegroundThread(NULL) && !GetFocus() ) {
        //
        // For win95 compatibility, we need to return TRUE though we
        // didn't really succeed. PP4 calls us when it doesn't have
        // the input focus to check if IME is capable to do the specfied
        // MCW_xxx. Returning TRUE here will make such application happy.
        //
        return ( TRUE );
    }

    pInputContext = ImmLockIMC( hImc );
    if ( pInputContext == NULL ) {
        return ( FALSE );
    }

    pt.x      = GET_X_LPARAM(lpIme->lParam1);
    pt.y      = GET_Y_LPARAM(lpIme->lParam1);
    rt.left   = GET_X_LPARAM(lpIme->lParam2);
    rt.top    = GET_Y_LPARAM(lpIme->lParam2);
    rt.right  = GET_X_LPARAM(lpIme->lParam3);
    rt.bottom = GET_Y_LPARAM(lpIme->lParam3);

    cof.dwStyle = CFS_DEFAULT;

    if ( lpIme->wParam & MCW_HIDDEN ) {
        pInputContext->fdw31Compat |= F31COMPAT_MCWHIDDEN;
        ScreenToClient( pInputContext->hWnd, &pt );
        MapWindowPoints( HWND_DESKTOP, pInputContext->hWnd, (LPPOINT)&rt, 2);
    } else {
        pInputContext->fdw31Compat &= ~F31COMPAT_MCWHIDDEN;
    }

    if ( lpIme->wParam & MCW_WINDOW) {
        if ( !IsWndEqual(hWndApp, pInputContext->hWnd)) {
            ClientToScreen(hWndApp, &pt);
            ScreenToClient(pInputContext->hWnd, &pt);
            if (lpIme->wParam & MCW_RECT) {
                cof.dwStyle = CFS_RECT;
                MapWindowPoints(hWndApp, HWND_DESKTOP, (LPPOINT)&rt, 2);
                MapWindowPoints(HWND_DESKTOP, pInputContext->hWnd, (LPPOINT)&rt, 2);
            } else {
                cof.dwStyle = CFS_POINT;
            }
        } else {
            if ( lpIme->wParam & MCW_RECT) {
                cof.dwStyle = CFS_RECT;
            } else {
                cof.dwStyle = CFS_POINT;
            }
        }
    }

    // Because Chicago IME can not handle CFS_SCREEN. The points should be
    // converted to client point.
    // If these points are out of Client, HOW SHOULD WE DO????

    if ( lpIme->wParam & MCW_SCREEN ) {
        ScreenToClient( pInputContext->hWnd, &pt );
        if ( lpIme->wParam & CFS_RECT ) {
            cof.dwStyle = CFS_RECT;
            MapWindowPoints( HWND_DESKTOP, pInputContext->hWnd, (LPPOINT)&rt, 2 );
        }
        else {
            cof.dwStyle = CFS_POINT;
        }
    }

    if ( lpIme->wParam & MCW_VERTICAL) {
        if ( !(pInputContext->fdw31Compat & F31COMPAT_MCWVERTICAL) ) {
            pInputContext->fdw31Compat |= F31COMPAT_MCWVERTICAL;
            SetFontForMCWVERTICAL( hWndApp, hImc, pInputContext, TRUE);
        }
    } else {
        if (pInputContext->fdw31Compat & F31COMPAT_MCWVERTICAL) {
            pInputContext->fdw31Compat &= ~F31COMPAT_MCWVERTICAL;
            SetFontForMCWVERTICAL( hWndApp, hImc, pInputContext, FALSE);
        }
    }
    cof.ptCurrentPos = pt;
    cof.rcArea       = rt;

#if defined(PENAPI)
    if ( !FSetPosPenUi(&cof) )
#endif
    if ( !(pInputContext->fdw31Compat & F31COMPAT_MCWHIDDEN) ) {
        MySetCompWindow( hWndApp, hImc, (LPCOMPOSITIONFORM)&cof );
    } else {
        // Hack for 3.1 Apps. We save the exlude area into IMC.
        pInputContext->cfCompForm.ptCurrentPos = cof.ptCurrentPos;
        pInputContext->cfCompForm.rcArea       = cof.rcArea;

        for ( i=0; i < 4; i++ ) {
            if ( pInputContext->cfCandForm[i].dwIndex != -1)
            {
                caf.dwIndex = i;
                caf.dwStyle = CFS_EXCLUDE;
                caf.ptCurrentPos = pt;
                caf.rcArea       = rt;
                MySetCandidateWindow( hWndApp, hImc, (LPCANDIDATEFORM)&caf );
            }
        }
    }
    ImmUnlockIMC( hImc );
    return ( TRUE );
}

//===================================================================
// TransSetConversionMode
//=======================
//
// Japanese only
//
// History:
// 31-May-1996 takaok      Created.
//
//===================================================================
LRESULT TransSetConversionMode( HIMC hImc, LPIMESTRUCT lpIme )
{
    DWORD fdwConversion = 0, fdwSentence, fdwNewConversion, fdwMask;
    UINT  uPrevMode;
    UINT  u31Mode;

    //
    // Get current conversion mode and translate it to
    // the 3.1 style conversion mode.
    //
    ImmGetConversionStatus( hImc, &fdwConversion, &fdwSentence);
    uPrevMode = Get31ModeFrom40ModeJ( fdwConversion );

    //
    // translate requested 3.1 conversion mode to 4.0 conversion mode
    //
    fdwNewConversion = 0;
    u31Mode = (UINT)lpIme->wParam;

    switch ( u31Mode & 0x07 ) {
    case IME_MODE_ALPHANUMERIC:
        fdwNewConversion &= ~IME_CMODE_LANGUAGE;
        break;
    case IME_MODE_KATAKANA:
        fdwNewConversion |= IME_CMODE_NATIVE|IME_CMODE_KATAKANA;
        break;
    case IME_MODE_HIRAGANA:
        fdwNewConversion |= IME_CMODE_NATIVE;
        break;
    }
    if ( !(u31Mode & JAPAN_IME_MODE_SBCSCHAR) )
        fdwNewConversion |= IME_CMODE_FULLSHAPE;

    if ( u31Mode & IME_MODE_ROMAN )
        fdwNewConversion |= IME_CMODE_ROMAN;

    if ( u31Mode & IME_MODE_CODEINPUT )
        fdwNewConversion |= IME_CMODE_CHARCODE;

    //
    // compute the mask bit. we need to compute this because
    // application may set only bit needed to be changed.
    //
    fdwMask = 0;
    if ( u31Mode & (IME_MODE_ROMAN | IME_MODE_NOROMAN) )
        fdwMask |= IME_CMODE_ROMAN;

    if ( u31Mode & (IME_MODE_CODEINPUT|IME_MODE_NOCODEINPUT) )
        fdwMask |= IME_CMODE_CHARCODE;

    if ( u31Mode & 0x07 )
        fdwMask |= IME_CMODE_LANGUAGE;

    if ( u31Mode & (IME_MODE_DBCSCHAR|JAPAN_IME_MODE_SBCSCHAR) )
        fdwMask |= IME_CMODE_FULLSHAPE;

    //
    // set the new mode
    //
    fdwNewConversion = (fdwNewConversion & fdwMask) | (fdwConversion & ~fdwMask);
    if ( ImmSetConversionStatus( hImc, fdwNewConversion, fdwSentence) ) {
        return (LRESULT)uPrevMode;
    } else {
        return (LRESULT)0;
    }
}

//===================================================================
// TransGetMode
//==============
//
// Korean only
//
// translate 4.0 conversion mode into 3.1 conversion mode
//
// History:
// 31-May-1996 takaok      Created.
//
//===================================================================
LRESULT TransGetMode( HIMC hImc )
{
    DWORD fdwConversion = 0, fdwSentence;
    UINT u31Mode = 0;

    ImmGetConversionStatus( hImc, &fdwConversion, &fdwSentence);
    u31Mode= Get31ModeFrom40ModeK( fdwConversion );
    // HACK: To prevent 0 result from treating FALSE, we always set MSB
    return ( u31Mode | 0x80000000 );
}

//===================================================================
// Get31ModeFrom40ModeK
//=====================
//
// Korean only
//
// translate 4.0 conversion mode into 3.1 conversion mode
//
// History:
// 31-May-1996 takaok      Created.
//
//===================================================================
UINT Get31ModeFrom40ModeK( DWORD fdwConversion )
{
    UINT u31Mode = 0;

    if ( !(fdwConversion & IME_CMODE_NATIVE) ) {

        u31Mode |= IME_MODE_ALPHANUMERIC;
    }

    if ( !(fdwConversion & IME_CMODE_FULLSHAPE) ) {

        u31Mode |= KOREA_IME_MODE_SBCSCHAR;
    }

    if ( fdwConversion & IME_CMODE_HANJACONVERT ) {
        u31Mode |= IME_MODE_HANJACONVERT;
    }

    return u31Mode;
}

//===================================================================
// TransGetConversionMode
//========================
//
// Japanese only
//
// 4.0 conversion mode => 3.1 conversion mode
//
// History:
// 31-May-1996 takaok      Created.
//
//===================================================================
LRESULT TransGetConversionMode( HIMC hImc )
{
    DWORD fdwConversion = 0, fdwSentence;
    UINT u31Mode = 0;

    //
    // get the 4.0 style conversion mode
    //
    ImmGetConversionStatus( hImc, &fdwConversion, &fdwSentence);
    return Get31ModeFrom40ModeJ( fdwConversion );
}

//===================================================================
// Get31ModeFrom40ModeJ
//======================
//
// Japanese only
//
// 4.0 conversion mode => 3.1 conversion mode
//
// History:
// 31-May-1996 takaok      Created.
//
//===================================================================
UINT Get31ModeFrom40ModeJ( DWORD fdwConversion )
{
    UINT u31Mode = 0;

    //
    // translate the 4.0 style mode to the 3.x style conversion mode
    //
    if (fdwConversion & IME_CMODE_NATIVE) {
        if (fdwConversion & IME_CMODE_KATAKANA) {
            u31Mode |= IME_MODE_KATAKANA;
        } else {
            u31Mode |= IME_MODE_HIRAGANA;
        }
    } else {
        u31Mode |= IME_MODE_ALPHANUMERIC;
    }

    if (fdwConversion & IME_CMODE_FULLSHAPE) {
        u31Mode |= IME_MODE_DBCSCHAR;
    } else {
        u31Mode |= JAPAN_IME_MODE_SBCSCHAR;
    }

    if (fdwConversion & IME_CMODE_ROMAN) {
        u31Mode |= IME_MODE_ROMAN;
    } else {
        u31Mode |= IME_MODE_NOROMAN;
    }

    if (fdwConversion & IME_CMODE_CHARCODE) {
        u31Mode |= IME_MODE_CODEINPUT;
    } else {
        u31Mode |= IME_MODE_NOCODEINPUT;
    }

    return (u31Mode);
}


//===================================================================
// TransSetMode
//==============
//
// KOREAN only
//
//===================================================================
LRESULT TransSetMode( HIMC hImc, LPIMESTRUCT lpIme )
{
    DWORD fdwConversion = 0, fdwSentence, fdwNewConversion, fdwMask;
    UINT  uPrevMode;
    UINT  u31Mode;

    //
    // Get current conversion mode and translate it to
    // the 3.1 style conversion mode.
    //
    ImmGetConversionStatus( hImc, &fdwConversion, &fdwSentence);
    uPrevMode = Get31ModeFrom40ModeK( fdwConversion );

    //
    // translate requested 3.1 conversion mode to 4.0 conversion mode
    //
    fdwNewConversion = 0;
    u31Mode = (UINT)lpIme->wParam;

    if ( !(u31Mode & IME_MODE_ALPHANUMERIC) )
        fdwNewConversion |= IME_CMODE_HANGEUL;
    if ( !(u31Mode & KOREA_IME_MODE_SBCSCHAR) )
        fdwConversion |= IME_CMODE_FULLSHAPE;

    //
    // In HWin3.1 there is no "not modification mode"
    //
    fdwMask = IME_CMODE_LANGUAGE|IME_CMODE_FULLSHAPE|IME_CMODE_HANJACONVERT;

    //
    // set the new mode
    //
    fdwNewConversion = (fdwNewConversion & fdwMask) | (fdwConversion & ~fdwMask);
    if ( ImmSetConversionStatus( hImc, fdwNewConversion, fdwSentence) ) {
        return (LRESULT)uPrevMode;
    } else {
        return (LRESULT)0;
    }
    return FALSE;
}

//===================================================================
// TransSendVKey
//===============
//
// Japanese only
//
//===================================================================
LRESULT TransSendVKey( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi )
{
    LRESULT lRet;

    switch (lpIme->wParam)
    {
        // VK_DBE_xxx Support Check.
        case (DWORD)(-1):
        case (DWORD)(0x0000ffff):   // from WOW16
            switch (lpIme->wCount)
            {
                case VK_DBE_ALPHANUMERIC:
                case VK_DBE_KATAKANA:
                case VK_DBE_HIRAGANA:
                case VK_DBE_SBCSCHAR:
                case VK_DBE_DBCSCHAR:
                case VK_DBE_ROMAN:
                case VK_DBE_NOROMAN:
                case VK_DBE_CODEINPUT:
                case VK_DBE_NOCODEINPUT:
                case VK_DBE_ENTERWORDREGISTERMODE:
                case VK_DBE_ENTERIMECONFIGMODE:
                case VK_DBE_ENTERDLGCONVERSIONMODE:
                case VK_DBE_DETERMINESTRING:
                case VK_DBE_FLUSHSTRING:
                case VK_CONVERT:
                    lRet = TRUE;
                    break;

                default:
                    lRet = FALSE;
                    break;
            }
            break;

        case VK_DBE_ALPHANUMERIC:
        case VK_DBE_KATAKANA:
        case VK_DBE_HIRAGANA:
        case VK_DBE_SBCSCHAR:
        case VK_DBE_DBCSCHAR:
        case VK_DBE_ROMAN:
        case VK_DBE_NOROMAN:
        case VK_DBE_CODEINPUT:
        case VK_DBE_NOCODEINPUT:
            lRet = TransVKDBEMode(hImc, lpIme->wParam);
            break;

        case VK_DBE_ENTERWORDREGISTERMODE:
            {
            HKL hkl = GetKeyboardLayout(0L);

            if ( fAnsi )
                lRet = ImmConfigureIMEA(hkl, hWndApp, IME_CONFIG_REGISTERWORD, NULL);
            else
                lRet = ImmConfigureIMEW(hkl, hWndApp, IME_CONFIG_REGISTERWORD, NULL);
            }
            break;

        case VK_DBE_ENTERIMECONFIGMODE:
            {
                HKL hkl = GetKeyboardLayout(0L);
                if (fAnsi)
                    lRet = ImmConfigureIMEA(hkl, hWndApp, IME_CONFIG_GENERAL, NULL);
                else
                    lRet = ImmConfigureIMEW(hkl, hWndApp, IME_CONFIG_GENERAL, NULL);
            }
            break;

        case VK_DBE_ENTERDLGCONVERSIONMODE:
#if defined(PENAPI)
            FInitPenUi(hIMC);
#endif
            lRet = FALSE;
            break;

        case VK_DBE_DETERMINESTRING:
            // Check there is the composition string or not.
            lRet = ImmNotifyIME( ImmGetContext(hWndApp),
                                 NI_COMPOSITIONSTR,
                                 CPS_COMPLETE,
                                 0L);
            break;

        case VK_DBE_FLUSHSTRING:
            lRet = ImmNotifyIME( hImc, NI_COMPOSITIONSTR,CPS_CANCEL,0L);
            break;

        case VK_CONVERT:
            lRet = ImmNotifyIME( hImc, NI_COMPOSITIONSTR, CPS_CONVERT, 0L);
            break;

        default:
            lRet = FALSE;
            break;
    }
    return lRet;
}

//===================================================================
// TransEnterWordRegisterMode
//===========================
//
// Japanese only
//
//===================================================================
LRESULT TransEnterWordRegisterMode( HWND hWndApp, LPIMESTRUCT lpIme, BOOL fAnsi)
{
    LRESULT lRet;
    HKL hkl = GetKeyboardLayout(0L);

    if ( ! ImmIsIME(hkl) ) {
        return FALSE;
    }

    if ( fAnsi ) {
    //
    // ANSI
    //
        REGISTERWORDA stReg = {NULL, NULL};
        LPSTR lpsz1, lpsz2;

        if (lpIme->lParam1&&(lpsz1=GlobalLock((HGLOBAL)lpIme->lParam1))) {
            stReg.lpWord = lpsz1;
        }
        if (lpIme->lParam2&&(lpsz2=GlobalLock((HGLOBAL)lpIme->lParam2))) {
            stReg.lpReading = lpsz2;
        }
        lRet = ImmConfigureIMEA(hkl,hWndApp,IME_CONFIG_REGISTERWORD, (LPVOID)&stReg);
        if (lpIme->lParam1 && lpsz1)
            GlobalUnlock((HGLOBAL)lpIme->lParam1);
        if (lpIme->lParam2 && lpsz2)
            GlobalUnlock((HGLOBAL)lpIme->lParam2);
    } else {
    //
    // UNICODE
    //
        REGISTERWORDW stReg = {NULL, NULL};
        LPWSTR lpsz1, lpsz2;

        if (lpIme->lParam1&&(lpsz1=GlobalLock((HGLOBAL)lpIme->lParam1))) {
            stReg.lpWord = lpsz1;
        }
        if (lpIme->lParam2&&(lpsz2=GlobalLock((HGLOBAL)lpIme->lParam2))) {
            stReg.lpReading = lpsz2;
        }
        lRet = ImmConfigureIMEW(hkl,hWndApp,IME_CONFIG_REGISTERWORD, (LPVOID)&stReg);
        if (lpIme->lParam1 && lpsz1)
            GlobalUnlock((HGLOBAL)lpIme->lParam1);
        if (lpIme->lParam2 && lpsz2)
            GlobalUnlock((HGLOBAL)lpIme->lParam2);
    }
    return lRet;
}


//===================================================================
// TransSetConversionFontEx
//==========================
//
// Japanese only
//
//===================================================================
LRESULT TransSetConversionFontEx( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi)
{
    LPINPUTCONTEXT pInputContext;
    LRESULT lRet;
    LPLOGFONTW lplf;
    LOGFONTW  lfw;

    pInputContext = ImmLockIMC( hImc );
    if ( pInputContext == NULL ) {
        return 0L;
    }

    lplf = (LPLOGFONTW)GlobalLock((HGLOBAL)lpIme->lParam1);
    if ( lplf == NULL )
    {
        ImmUnlockIMC( hImc );
        return 0L;
    }
    if ( fAnsi ) {
        memcpy( &lfw, lplf, sizeof(LOGFONTA) );
        MultiByteToWideChar( CP_ACP,
                             0,
                             (LPCSTR)lplf->lfFaceName,     // src
                             LF_FACESIZE,          // size of src
                             lfw.lfFaceName,       // destination buffer
                             LF_FACESIZE );        // size of destination buffer
    } else {
        memcpy( &lfw, lplf, sizeof(LOGFONTW));
    }
    GlobalUnlock((HGLOBAL)lpIme->lParam1);

    if (( pInputContext->fdw31Compat & F31COMPAT_MCWVERTICAL)) {
        lRet = FixLogfont( &lfw, TRUE);
    } else {
        lRet = FixLogfont( &lfw, FALSE);
    }
    ImmUnlockIMC( hImc );

    if (lRet == FALSE ) {
        return FALSE;
    }

    return MySetCompFont( hWndApp, hImc, &lfw );
}


//===================================================================
// TransHanjaMode
//================
//
// Korean only
//
//===================================================================
LRESULT TransHanjaMode( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme)
{
    // NOTE We will use this function instead of ImmEscape().
    LRESULT lRet;
    PIMEDPI pImeDpi;
    DWORD   dwThreadId = GetInputContextThread(hImc);

    if (dwThreadId == 0) {
        RIPMSG1(RIP_WARNING,
              "TransHanjaMode: GetInputContextThread(%lx) failed.", hImc);
        return FALSE;
    }

    pImeDpi = ImmLockImeDpi(GetKeyboardLayout(dwThreadId));
    if (pImeDpi == NULL)
        return FALSE;

    /*
     * Check if we need ANSI/Unicode conversion
     */
    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        WCHAR wUni;
        CHAR  chAnsi[2];
        UINT  i, dchSource;

        //The 4th word of imestruct32 contains dchSource
        dchSource = *((LPSTR)lpIme + 3 * sizeof(WORD));

        chAnsi[0] = *((LPSTR)lpIme + dchSource);
        chAnsi[1] = *((LPSTR)lpIme + dchSource + 1);

        i = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, chAnsi, 2, &wUni, 1);

        if (i)  {
           *((LPSTR)lpIme + dchSource)   = (CHAR)LOWORD(LOBYTE(wUni));
           *((LPSTR)lpIme + dchSource+1) = (CHAR)LOWORD(HIBYTE(wUni));
        }
        else {
           ImmUnlockImeDpi(pImeDpi);
           return FALSE;
        }
    }

    ImmUnlockImeDpi(pImeDpi);

    if (lRet = ImmEscape(GetKeyboardLayout(0), hImc, IME_HANJAMODE, lpIme))
        SendMessage(hWndApp, WM_IME_NOTIFY, IMN_OPENCANDIDATE, 1L);
    return (lRet);
}

//===================================================================
// TransGetLevel
//===============
//
// Korean only
//
//===================================================================
LRESULT TransGetLevel( HWND hWndApp )
{
    UINT lRet;

    if ( (lRet = NtUserGetAppImeLevel( hWndApp )) == 0 )
        lRet = 1;       // default level

    return lRet;
}

//===================================================================
// TransSetLevel
//===============
//
// Korean only
//
//===================================================================
LRESULT TransSetLevel( HWND hWndApp, LPIMESTRUCT lpIme)
{
    DWORD dwLevel;

    dwLevel = (DWORD)lpIme->wParam;
    if ( dwLevel >= 1 && dwLevel <= 5 ) {
        if ( NtUserSetAppImeLevel(hWndApp, dwLevel) ) {
            return TRUE;
        }
    }
    return FALSE;
}

//===================================================================
// TransVKDBEMode
//================
//
// Japanese only
//
//===================================================================
LRESULT TransVKDBEMode( HIMC hImc, WPARAM wVKDBE )
{
    DWORD fdwConversion,fdwSentence;

    if (!ImmGetConversionStatus(hImc, &fdwConversion, &fdwSentence)) {
        return FALSE;
    }

    switch (wVKDBE)
    {
        case VK_DBE_ALPHANUMERIC:
            fdwConversion &= ~IME_CMODE_LANGUAGE;
            break;

        case VK_DBE_KATAKANA:
            fdwConversion |= (IME_CMODE_JAPANESE | IME_CMODE_KATAKANA);
            break;

        case VK_DBE_HIRAGANA:
            fdwConversion &= ~IME_CMODE_KATAKANA;
            fdwConversion |= IME_CMODE_JAPANESE;
            break;

        case VK_DBE_SBCSCHAR:
            fdwConversion &= ~IME_CMODE_FULLSHAPE;
            break;

        case VK_DBE_DBCSCHAR:
            fdwConversion |= IME_CMODE_FULLSHAPE;
            break;

        case VK_DBE_ROMAN:
            fdwConversion |= IME_CMODE_ROMAN;
            break;

        case VK_DBE_NOROMAN:
            fdwConversion &= ~IME_CMODE_ROMAN;
            break;

        case VK_DBE_CODEINPUT:
            fdwConversion |= IME_CMODE_CHARCODE;
            break;

        case VK_DBE_NOCODEINPUT:
            fdwConversion &= ~IME_CMODE_CHARCODE;
            break;

        default:
            break;

    }

    return ImmSetConversionStatus(hImc, fdwConversion, fdwSentence);
}

//===================================================================
// IsForegroundThread
//===================
//
// Check if the caller thread has the foreground window.
// If hwnd is specified, the function checks if the creator
// thread of the specified window has the foreground window.
//
//===================================================================
BOOL    IsForegroundThread(HWND hwnd)
{
    HWND  hwndFG;
    DWORD dwThreadId;

    hwndFG = GetForegroundWindow();
    if ( IsWindow( hwnd ) ) {
        dwThreadId = GetWindowThreadProcessId( hwnd, NULL );
    } else {
        dwThreadId = GetCurrentThreadId();
    }
    return ( GetWindowThreadProcessId(hwndFG,NULL) == dwThreadId );
}


//===================================================================
// SetFontForMCWVERTICAL
//======================
//
// Japanese only
//
// set/reset vertical writing font
//
//===================================================================
BOOL  SetFontForMCWVERTICAL( HWND hWndApp, HIMC hImc, LPINPUTCONTEXT pInputContext, BOOL fVert )
{
    LOGFONTW lf;
    PCLIENTIMC pClientImc;

    if ( pInputContext->fdwInit & INIT_LOGFONT) {
    //
    // If a font has ever been set, use it
    //
        BOOL fAnsi;

        memcpy(&lf,&pInputContext->lfFont.W,sizeof(LOGFONTW));
        //
        // check if the input context is unicode
        //
        pClientImc = ImmLockClientImc( hImc );
        if (pClientImc == NULL) {
            return FALSE;
        }
        fAnsi = ! TestICF( pClientImc, IMCF_UNICODE );
        ImmUnlockClientImc( pClientImc );

        if ( fAnsi ) {
            CHAR FaceNameA[ LF_FACESIZE ];

            //
            // we need a temporary buffer because MultiByteToWideChar
            // doesn't allow us to specify src==dest.
            //
            memcpy( FaceNameA, &lf.lfFaceName, LF_FACESIZE );
            MultiByteToWideChar( CP_ACP,
                                 0,
                                 FaceNameA,     // src
                                 LF_FACESIZE,   // size of src
                                 lf.lfFaceName, // destination buffer
                                 LF_FACESIZE ); // size of destination buffer
        }
    } else {
    //
    // system font should be used as the default font
    //
        GetObjectW( GetStockObject(SYSTEM_FONT), sizeof(lf), (LPVOID)&lf );
    }

    //
    // put/remove '@' from the font facename.
    // "@facename" means vertical writing font
    //
    if ( FixLogfont( &lf, fVert ) == FALSE ) {
       return FALSE;
    }

    return MySetCompFont( hWndApp, hImc, &lf );
}

//===================================================================
// FixLogfont
//============
//
// Japanese only
//
// put/remove '@' from the font facename.
// "@facename" means vertical writing font
//
//===================================================================
BOOL FixLogfont(  LPLOGFONTW lplfW, BOOL fVert )
{
    int i;

    if ( fVert ) {
    //
    // convert the specified font to vertical writing font
    //
        lplfW->lfEscapement = 2700;
        lplfW->lfOrientation = 2700;
        if ((lplfW->lfCharSet == SHIFTJIS_CHARSET) && (lplfW->lfFaceName[0] != L'@')) {
            for(i=0;lplfW->lfFaceName[i];++i)    // Search NULL
            if (i > (LF_FACESIZE-2))         // if not remain 2 char
                return FALSE;                // then error
                                         // Because insert @ char

            for( ; i>=0 ; --i )                  // Copy facename from tail
                lplfW->lfFaceName[i+1] = lplfW->lfFaceName[i];

            lplfW->lfFaceName[0] = L'@';         // insert @ character
        }
    } else {
    //
    // convert the specified font to normal font
    //
        lplfW->lfEscapement = 0;
        lplfW->lfOrientation = 0;
        if ((lplfW->lfCharSet == SHIFTJIS_CHARSET) && (lplfW->lfFaceName[0] == L'@'))
            lstrcpynW(lplfW->lfFaceName,&(lplfW->lfFaceName[1]),LF_FACESIZE-1);
    }
    return TRUE;
}


//===================================================================
// MySetCompFont
//==============
//
// Japanese only
//
//===================================================================
BOOL MySetCompFont( HWND hWndApp, HIMC hImc, LPLOGFONTW lplf )
{
    BOOL lRet = FALSE;
    DWORD dwCompat;
    PINPUTCONTEXT pInputContext;
    PCLIENTIMC pClientImc;
    LOGFONTW lfw;
    LPLOGFONTW lplfw = &lfw;
    BOOL fUnicode;

    // BOGUS!!
    // Some application call SendIMEMessage(IME_SETCONVERSIONFONT)
    // when the apps is handling WM_PAINT.
    // New Win95 IME try to draw the UI during calling ImmSetCompositionFont,
    // and WM_PAINT will be sent in the API....
    // To avoid this thing, WINNLS makes the notification to IME and APPS later.
    // ........

    if ( (pInputContext = ImmLockIMC(hImc)) != NULL ) {
        dwCompat = ImmGetAppCompatFlags( hImc );
        pClientImc = ImmLockClientImc(hImc);
        if (pClientImc != NULL) {
            fUnicode = TestICF(pClientImc, IMCF_UNICODE);

            ImmUnlockClientImc(pClientImc);

            if ( fUnicode )
                lplfw = &(pInputContext->lfFont.W);
            else
                LFontAtoLFontW( &(pInputContext->lfFont.A), lplfw );

            if ( RtlEqualMemory(lplfw, lplf, sizeof(LOGFONTA)-LF_FACESIZE)
                 && !lstrcmp(lplfw->lfFaceName, lplf->lfFaceName) ) {

                /*
                 * Don't inform IME ahd UI when logfont is not changed.
                 */
                lRet = TRUE;

            } else if ( dwCompat & IMECOMPAT_UNSYNC31IMEMSG ) {

                memcpy( &(pInputContext->lfFont.W), lplf, sizeof(LOGFONT));
                if ( dwCompat & IMECOMPAT_UNSYNC31IMEMSG2 )
                    /*
                     * BOGUS!! for PageMaker5J
                     */
                    lRet = PostMessage( hWndApp, WM_IME_SYSTEM, IMS_SETCOMPOSITIONFONT, 0 );
                else
                    lRet = MyPostImsMessage( hWndApp, IMS_SETCOMPOSITIONFONT, 0);

            } else {

                lRet = ImmSetCompositionFont( hImc, lplf );

            }
        }
        ImmUnlockIMC( hImc );
    }
    return lRet;
}

//===================================================================
// MySetCompWindow
//================
//
// Japanese only
//
//===================================================================
BOOL MySetCompWindow(
    HWND              hWndApp,
    HIMC              hImc,
    LPCOMPOSITIONFORM lpcof
    )
{
    BOOL fRet = FALSE;
    DWORD dwCompat;
    PINPUTCONTEXT pInputContext;

    // BOGUS!!
    // Some application call SendIMEMessage(IME_SETCONVERSIONWINDOW)
    // when the apps is handling WM_PAINT.
    // New Win95 IME try to draw the UI during calling ImmSetCompositionWindow,
    // and WM_PAINT will be sent in the API....
    // To avoid this thing, WINNLS makes the notification to IME and APPS later.
    // ........
    if ( (pInputContext = ImmLockIMC(hImc)) != NULL ) {
        dwCompat = ImmGetAppCompatFlags( hImc );
        if ( dwCompat & IMECOMPAT_UNSYNC31IMEMSG ) {
            memcpy( &(pInputContext->cfCompForm), lpcof, sizeof(COMPOSITIONFORM));
            if ( dwCompat & IMECOMPAT_UNSYNC31IMEMSG2 ) {
                /*
                 * BOGUS!! for PageMaker5J
                 */
                fRet = PostMessage( hWndApp, WM_IME_SYSTEM, IMS_SETCOMPOSITIONWINDOW, 0 );
            } else {
                fRet = MyPostImsMessage( hWndApp, IMS_SETCOMPOSITIONWINDOW, 0 );
            }
        } else {
            pInputContext->fdw31Compat |= F31COMPAT_CALLFROMWINNLS;
            fRet = ImmSetCompositionWindow( hImc, lpcof );
        }
        ImmUnlockIMC( hImc );
    }
    return fRet;
}

//===================================================================
// MySetCandidateWindow
//=====================
//
// Japanese only
//
//===================================================================
BOOL MySetCandidateWindow( HWND hWndApp, HIMC hImc, LPCANDIDATEFORM lpcaf)
{
    BOOL fRet = FALSE;
    DWORD dwCompat;
    PINPUTCONTEXT pInputContext;

    // BOGUS!!
    // Some application call SendIMEMessage(IME_SETCONVERSIONWINDOW)
    // when the apps is handling WM_PAINT.
    // New Win95 IME try to draw the UI during calling ImmSetCandidateWindow,
    // and WM_PAINT will be sent in the API....
    // To avoid this thing, WINNLS makes the notification to IME and APPS later.
    // ........
    if ( (pInputContext = ImmLockIMC(hImc)) != NULL ) {
        dwCompat = ImmGetAppCompatFlags( hImc );
        if ( dwCompat & IMECOMPAT_UNSYNC31IMEMSG ) {
            memcpy( &(pInputContext->cfCandForm[lpcaf->dwIndex]), lpcaf, sizeof(CANDIDATEFORM));
            fRet = MyPostImsMessage( hWndApp, IMS_SETCANDIDATEPOS, lpcaf->dwIndex );
        } else {
            fRet = ImmSetCandidateWindow( hImc, lpcaf );
        }
        ImmUnlockIMC( hImc );
    }
    return fRet;
}

//===================================================================
// MyPostImsMessage
//==================
//
// Japanese only
//
// BOGUS!!
// Some application call SendIMEMessage(IME_SETCONVERSIONWINDOW)
// when the apps is handling WM_PAINT.
// New Win95 IME try to draw the UI during calling ImmSetCompositionWindow,
// and WM_PAINT will be sent in the API....
// To avoid this thing, WINNLS makes the notification to IME and APPS later.
// ........
//===================================================================
BOOL MyPostImsMessage( HWND hWndApp, WPARAM wParam, LPARAM lParam )
{
    HWND   hDefIMEWnd;
    BOOL   fRet = FALSE;

    hDefIMEWnd = ImmGetDefaultIMEWnd(hWndApp);
    if ( hDefIMEWnd != NULL ) {
        if ( PostMessage( hDefIMEWnd, WM_IME_SYSTEM, wParam, lParam) ) {
            fRet = TRUE;
        }
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\imm\softkbd.h ===
/**************************************************************************\
* Module Name: softkbd.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Declarations of soft keyboard related data structures and constants
*
* History:
* 02-Dec-1995 wkwok    Ported from Win95
\**************************************************************************/
#ifndef _SOFTKBD_
#define _SOFTKBD_


#define UI_MARGIN               4


// T1 part
#define SKT1_XIN                            3
#define SKT1_YIN                            3
#define SKT1_XOUT                           1
#define SKT1_YOUT                           1
#define SKT1_TOTAL_ROW_NUM                  5
#define SKT1_TOTAL_COLUMN_NUM               15
#define SKT1_ENTER_ROW_NUM                  2
#define SKT1_XOVERLAP                       2

#define SKT1_CONTEXT                        0

enum SKT1_BUTTON_TYPE {
    SKT1_LETTER_TYPE,
    SKT1_BACKSPACE_TYPE,
    SKT1_TAB_TYPE,
    SKT1_CAPS_TYPE,
    SKT1_ENTER_TYPE,
    SKT1_SHIFT_TYPE,
    SKT1_CTRL_TYPE,
    SKT1_ALT_TYPE,
    SKT1_ESC_TYPE,
    SKT1_SPACE_TYPE,
};

#define SKT1_TOTAL_TYPE                     (SKT1_SPACE_TYPE + 1)

#define SKT1_LETTER_WIDTH_TIMES             2
#define SKT1_BACKSPACE_WIDTH_TIMES          2
#define SKT1_TAB_WIDTH_TIMES                3
#define SKT1_CAPS_WIDTH_TIMES               4
#define SKT1_ENTER_WIDTH_TIMES              3
#define SKT1_SHIFT_WIDTH_TIMES              5
#define SKT1_CTRL_WIDTH_TIMES               3
#define SKT1_ALT_WIDTH_TIMES                3
#define SKT1_ESC_WIDTH_TIMES                3
#define SKT1_SPACE_WIDTH_TIMES              12

#define SKT1_LETTER_KEY_NUM                 47
#define SKT1_BACKSPACE_INDEX                (SKT1_LETTER_KEY_NUM)
#define SKT1_BACKSPACE_KEY_NUM              1
#define SKT1_TAB_INDEX                      (SKT1_BACKSPACE_INDEX + SKT1_BACKSPACE_KEY_NUM)
#define SKT1_TAB_KEY_NUM                    1
#define SKT1_CAPS_INDEX                     (SKT1_TAB_INDEX + SKT1_TAB_KEY_NUM)
#define SKT1_CAPS_KEY_NUM                   1
#define SKT1_ENTER_INDEX                    (SKT1_CAPS_INDEX + SKT1_CAPS_KEY_NUM)
#define SKT1_ENTER_KEY_NUM                  1
#define SKT1_SHIFT_INDEX                    (SKT1_ENTER_INDEX + SKT1_ENTER_KEY_NUM)
#define SKT1_SHIFT_KEY_NUM                  2
#define SKT1_CTRL_INDEX                     (SKT1_SHIFT_INDEX + SKT1_SHIFT_KEY_NUM)
#define SKT1_CTRL_KEY_NUM                   2
#define SKT1_ALT_INDEX                      (SKT1_CTRL_INDEX + SKT1_CTRL_KEY_NUM)
#define SKT1_ALT_KEY_NUM                    2
#define SKT1_ESC_INDEX                      (SKT1_ALT_INDEX + SKT1_ALT_KEY_NUM)
#define SKT1_ESC_KEY_NUM                    1
#define SKT1_SPACE_INDEX                    (SKT1_ESC_INDEX + SKT1_ESC_KEY_NUM)
#define SKT1_SPACE_KEY_NUM                  1
#define SKT1_TOTAL_INDEX                    (SKT1_SPACE_INDEX + SKT1_SPACE_KEY_NUM)
#define SKT1_TOTAL_KEY_NUM                  (SKT1_TOTAL_INDEX + 1)

#define SKT1_ROW1_LETTER_NUM                14
#define SKT1_ROW2_LETTER_NUM                12
#define SKT1_ROW3_LETTER_NUM                11
#define SKT1_ROW4_LETTER_NUM                10

#define SKT1_LABEL_BMP_X                    8
#define SKT1_LABEL_BMP_Y                    8

#define SKT1_BACKSPACE_BMP_X                16
#define SKT1_BACKSPACE_BMP_Y                9
#define SKT1_TAB_BMP_X                      16
#define SKT1_TAB_BMP_Y                      9
#define SKT1_CAPS_BMP_X                     22
#define SKT1_CAPS_BMP_Y                     9
#define SKT1_ENTER_BMP_X                    26
#define SKT1_ENTER_BMP_Y                    9
#define SKT1_SHIFT_BMP_X                    23
#define SKT1_SHIFT_BMP_Y                    9
#define SKT1_CTRL_BMP_X                     16
#define SKT1_CTRL_BMP_Y                     9
#define SKT1_ESC_BMP_X                      18
#define SKT1_ESC_BMP_Y                      9
#define SKT1_ALT_BMP_X                      16
#define SKT1_ALT_BMP_Y                      9

#if 0
#define VK_OEM_SEMICLN                  0xba    //  ;    :
#define VK_OEM_EQUAL                    0xbb    //  =    +
#define VK_OEM_COMMA                    0xbc    //  ,    <
#define VK_OEM_MINUS                    0xbd    //  -    _
#define VK_OEM_PERIOD                   0xbe    //  .    >
#define VK_OEM_SLASH                    0xbf    //  /    ?
#define VK_OEM_3                        0xc0    //  `    ~
#define VK_OEM_LBRACKET                 0xdb    //  [    {
#define VK_OEM_BSLASH                   0xdc    //  \    |
#define VK_OEM_RBRACKET                 0xdd    //  ]    }
#define VK_OEM_QUOTE                    0xde    //  '    "
#endif

#define SKT1_NOT_DRAG                   0xFFFFFFFF

typedef struct _tagSKT1CTXT {
    int     nButtonWidth[SKT1_TOTAL_TYPE];
    int     nButtonHeight[2];
    POINT   ptButtonPos[SKT1_TOTAL_KEY_NUM];
    WORD    wCodeTable[SKT1_LETTER_KEY_NUM];
    HBITMAP hSKBitmap;
    UINT    lfCharSet;
    UINT    uKeyIndex;
    POINT   ptSkCursor;
    POINT   ptSkOffset;
    UINT    uSubType;
} SKT1CTXT, *PSKT1CTXT, FAR *LPSKT1CTXT, NEAR *NPSKT1CTXT;

void GetSKT1TextMetric(LPTEXTMETRIC);

LRESULT SKWndProcT1(HWND, UINT, WPARAM, LPARAM);

// T2 part

// C1 part

// button constants
#define ROW_LETTER_C1              4    // number of rows of letter button
#define COL_LETTER_C1             13    // number of column of letter button in first row
#define COL2_LETTER_C1 COL_LETTER_C1    // number of column of letter button in second row
#define COL3_LETTER_C1 (COL2_LETTER_C1 - 2)  // number of column of letter button in third row
#define COL4_LETTER_C1 (COL3_LETTER_C1 - 1)  // number of column of letter button in forth row

#define W_LETTER_C1               20  // width of letter button face
#define H_LETTER_C1               24  // height of letter button face
#define BORDER_C1                  2  // the width/height of button border
#define W_LETTER_BTN_C1     (W_LETTER_C1 + 2 * BORDER_C1)
#define H_LETTER_BTN_C1     (H_LETTER_C1 + 2 * BORDER_C1)

#define H_BOTTOM_C1               20  // the height of bottom button face
#define H_BOTTOM_BTN_C1     (H_BOTTOM_C1 + 2 * BORDER_C1)


// bitmap have the same size
#define W_BACKSP_C1               32  // width of Backspace button face
#define H_BACKSP_C1      H_LETTER_C1  // height of Backspace button face
#define W_TAB_C1                  32  // width of Tab button face
#define H_TAB_C1         H_LETTER_C1  // height of Tab button face
#define W_CAPS_C1                 38  // width of Caps button face
#define H_CAPS_C1        H_LETTER_C1  // height of Caps button face
#define W_ENTER_C1                38  // width of Enter button face
#define H_ENTER_C1       H_LETTER_C1  // height of Enter button face
#define W_SHIFT_C1                56  // width of Shift button face
#define H_SHIFT_C1       H_LETTER_C1  // height of Shift button face
#define W_INS_C1                  34  // width of Ins button face
#define H_INS_C1         H_BOTTOM_C1  // height of Ins button face
#define W_DEL_C1                  34  // width of Del button face
#define H_DEL_C1         H_BOTTOM_C1  // height of Del button face
#define W_SPACE_C1               168  // width of Space button face
#define H_SPACE_C1       H_BOTTOM_C1  // height of Space button face
#define W_ESC_C1                  34  // width of Esc button face
#define H_ESC_C1         H_BOTTOM_C1  // height of Esc button face

#define X_ROW_LETTER_C1            0
#define X_ROW2_LETTER_C1           (W_TAB_C1 + 2 * BORDER_C1)
#define X_ROW3_LETTER_C1           (W_CAPS_C1 + 2 * BORDER_C1)
#define X_ROW4_LETTER_C1           (W_SHIFT_C1 + 2 * BORDER_C1)
#define X_DEL_C1                  58
#define X_ESC_C1                 310

#define LETTER_NUM_C1             47  // number of letter buttons
#define OTHER_NUM_C1               9  // number of other buttons
#define BUTTON_NUM_C1      (LETTER_NUM_C1 + OTHER_NUM_C1) // number of buttons

#define WIDTH_SOFTKBD_C1   (COL_LETTER_C1 * W_LETTER_BTN_C1 \
                            + W_BACKSP_C1 + 2 * BORDER_C1)
#define HEIGHT_SOFTKBD_C1  (ROW_LETTER_C1 * H_LETTER_BTN_C1 + H_BOTTOM_BTN_C1)

#define BACKSP_TYPE_C1     LETTER_NUM_C1
#define TAB_TYPE_C1        (BACKSP_TYPE_C1 + 1)
#define CAPS_TYPE_C1       (BACKSP_TYPE_C1 + 2)
#define ENTER_TYPE_C1      (BACKSP_TYPE_C1 + 3)
#define SHIFT_TYPE_C1      (BACKSP_TYPE_C1 + 4)
#define INS_TYPE_C1        (BACKSP_TYPE_C1 + 5)
#define DEL_TYPE_C1        (BACKSP_TYPE_C1 + 6)
#define SPACE_TYPE_C1      (BACKSP_TYPE_C1 + 7)
#define ESC_TYPE_C1        (BACKSP_TYPE_C1 + 8)

// font constants
#define SIZEFONT_C1               12  // 12 x 12 pixels font
#define SIZELABEL_C1               8  // 8 x 8 button label

#define X_LABEL_C1                 2  // from the button org
#define Y_LABEL_C1                 2
#define X_SHIFT_CHAR_C1           10
#define Y_SHIFT_CHAR_C1            2
#define X_NONSHIFT_CHAR_C1         2
#define Y_NONSHIFT_CHAR_C1        14


// SoftKbd context
#define SKC1_CONTEXT               0

#define FLAG_SHIFT_C1             0x01
#define FLAG_DRAG_C1              0x02
#define FLAG_FOCUS_C1             0x04

typedef struct _tagSKC1CTXT {
     WORD     wShiftCode[LETTER_NUM_C1];
     WORD     wNonShiftCode[LETTER_NUM_C1];
     UINT     uState;
     HBITMAP  hSoftkbd;
     UINT     uSubtype;
     int      uKeyIndex;
     POINT    ptSkCursor;
     POINT    ptSkOffset;
     UINT     lfCharSet;
} SKC1CTXT, *PSKC1CTXT, FAR *LPSKC1CTXT, NEAR *NPSKC1CTXT;

LRESULT SKWndProcC1(HWND, UINT, WPARAM, LPARAM);
VOID SKC1DrawDragBorder(HWND, LPPOINT, LPPOINT);

#endif // _SOFTKBD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\csrmsg.h ===
/***************************** Module Header ******************************\
* Module Name: csrmsg.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* User CSR messages
*
* 02-27-95 JimA         Created.
\**************************************************************************/

#ifndef _CSRMSG_H_
#define _CSRMSG_H_

#include <ntcsrmsg.h>

typedef enum _USER_API_NUMBER {
    UserpExitWindowsEx = USERSRV_FIRST_API_NUMBER,
    UserpEndTask,
    UserpLogon,
    UserpRegisterServicesProcess,
    UserpActivateDebugger,
    UserpGetThreadConsoleDesktop,
    UserpDeviceEvent,
    UserpRegisterLogonProcess,
    UserpCreateSystemThreads,
    UserpRecordShutdownReason,
#if DBG
    UserpWin32HeapFail,
    UserpWin32HeapStat,
#endif
    UserpMaxApiNumber
} USER_API_NUMBER, *PUSER_API_NUMBER;

typedef struct _EXITWINDOWSEXMSG {
    DWORD dwLastError;
    UINT uFlags;
    BOOL fSuccess;
} EXITWINDOWSEXMSG, *PEXITWINDOWSEXMSG;

typedef struct _ENDTASKMSG {
    DWORD dwLastError;
    HWND hwnd;
    BOOL fForce;
    BOOL fSuccess;
} ENDTASKMSG, *PENDTASKMSG;

typedef struct _LOGONMSG {
    BOOL fLogon;
} LOGONMSG, *PLOGONMSG;

typedef struct _ADDFONTMSG {
    PWCHAR pwchName;
    DWORD dwFlags;
} ADDFONTMSG, *PADDFONTMSG;

typedef struct _REGISTERSERVICESPROCESSMSG {
    DWORD dwLastError;
    DWORD dwProcessId;
    BOOL fSuccess;
} REGISTERSERVICESPROCESSMSG, *PREGISTERSERVICESPROCESSMSG;

typedef struct _ACTIVATEDEBUGGERMSG {
    CLIENT_ID ClientId;
} ACTIVATEDEBUGGERMSG, *PACTIVATEDEBUGGERMSG;

typedef struct _GETTHREADCONSOLEDESKTOPMSG {
    DWORD dwThreadId;
    HDESK hdeskConsole;
} GETTHREADCONSOLEDESKTOPMSG, *PGETTHREADCONSOLEDESKTOPMSG;

#if DBG
typedef struct _WIN32HEAPFAILMSG {
    DWORD dwFlags;
    BOOL  bFail;
} WIN32HEAPFAILMSG, *PWIN32HEAPFAILMSG;

typedef struct _WIN32HEAPSTATMSG {
    PVOID   phs;
    DWORD   dwLen;
    DWORD   dwMaxTag;
} WIN32HEAPSTATMSG, *PWIN32HEAPSTATMSG;
#endif

typedef struct _DEVICEEVENTMSG {
    HWND   hWnd;
    WPARAM wParam;
    LPARAM lParam;
    DWORD  dwFlags;
    ULONG_PTR dwResult;
} DEVICEEVENTMSG, *PDEVICEEVENTMSG;

typedef struct _CREATESYSTEMTHREADSMSG {
    BOOL bRemoteThread;
} CREATESYSTEMTHREADSMSG, *PCREATESYSTEMTHREADSMSG;

typedef struct _RECORDSHUTDOWNREASONMSG {
    struct _SHUTDOWN_REASON *psr;
    DWORD  dwEventID;
    DWORD  dwEventType;
    BOOL   fShutdownCancelled;
    DWORD  dwProcessNameLen;
    LPWSTR pwchProcessName;
    DWORD  dwShutdownTypeLen;
    LPWSTR pwchShutdownType;
    DWORD  dwCommentLen;
    LPWSTR pwchComment;
} RECORDSHUTDOWNREASONMSG, *PRECORDSHUTDOWNREASONMSG;

typedef struct _USER_API_MSG {
    PORT_MESSAGE h;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CSR_API_NUMBER ApiNumber;
    ULONG ReturnValue;
    ULONG Reserved;
    union {
        EXITWINDOWSEXMSG ExitWindowsEx;
        ENDTASKMSG EndTask;
        LOGONMSG Logon;
        REGISTERSERVICESPROCESSMSG RegisterServicesProcess;
        ACTIVATEDEBUGGERMSG ActivateDebugger;
        GETTHREADCONSOLEDESKTOPMSG GetThreadConsoleDesktop;
#if DBG
        WIN32HEAPFAILMSG Win32HeapFail;
        WIN32HEAPSTATMSG Win32HeapStat;
#endif
        DEVICEEVENTMSG DeviceEvent;
        CREATESYSTEMTHREADSMSG CreateSystemThreads;
        RECORDSHUTDOWNREASONMSG RecordShutdownReason;
        DWORD IdLogon;
    } u;
} USER_API_MSG, *PUSER_API_MSG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\csrhlpr.h ===
/****************************** Module Header ******************************\
* Module Name: csrhlpr.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains the prototypes for functions that marshel data
* for LPC from USER32 to CSR and are not found anywhere else.
*
* History:
* 10-21-98 mzoran     Created.
\***************************************************************************/

NTSTATUS
APIENTRY
CallUserpExitWindowsEx(
    IN UINT uFlags,
    OUT PBOOL pfSuccess);

NTSTATUS
APIENTRY
CallUserpRegisterLogonProcess(
    IN DWORD dwProcessId);

VOID
APIENTRY
Logon(
    IN BOOL fLogon);

VOID
APIENTRY
CsrWin32HeapFail(
    IN DWORD dwFlags,
    IN BOOL  bFail);

UINT
APIENTRY
CsrWin32HeapStat(
    PDBGHEAPSTAT    phs,
    DWORD   dwLen);

NTSTATUS
APIENTRY
UserConnectToServer(
    IN PWSTR ObjectDirectory,
    IN OUT PUSERCONNECT ConnectionInformation,
    IN OUT PULONG ConnectionInformationLength OPTIONAL,
    OUT PBOOLEAN CalledFromServer OPTIONAL
    );

#if !defined(BUILD_WOW6432) || defined(_WIN64)

_inline
NTSTATUS
UserConnectToServer(
    IN PWSTR ObjectDirectory,
    IN OUT PUSERCONNECT ConnectionInformation,
    IN OUT PULONG ConnectionInformationLength OPTIONAL,
    OUT PBOOLEAN CalledFromServer OPTIONAL
    ) {

    return CsrClientConnectToServer(ObjectDirectory,
                                    USERSRV_SERVERDLL_INDEX,
                                    ConnectionInformation,
                                    ConnectionInformationLength,
                                    CalledFromServer);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Inference rules to build generated header files
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
$(O)\cscall.h: ..\cscall.tpl $(O)\scf.lst
    listmung $(O)\scf.lst ..\cscall.tpl >$@

$(O)\callback.h: ..\callback.tpl $(O)\cb.lst
    listmung $(O)\cb.lst ..\callback.tpl >$@

$(O)\msgdef.h: ..\msgdef.tpl $(O)\msgdef.lst
    listmung $(O)\msgdef.lst ..\msgdef.tpl >$@

$(O)\scf.lst: ..\scf.lst
    @echo Creating $@ from $**
    $(C_PREPROCESSOR)  $** > $@

$(O)\cb.lst: ..\cb.lst
    @echo Creating $@ from $**
    $(C_PREPROCESSOR)  $** > $@

$(O)\msgdef.lst: ..\msgdef.lst
    @echo Creating $@ from $**
    $(C_PREPROCESSOR)  $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntuser\inc\ntcb.h ===
/****************************** Module Header ******************************\
* Module Name: ntcb.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Kernel mode sending stubs
*
* 07-06-91 ScottLu      Created.
\***************************************************************************/

/*
 * Reserved bit in the Drive Letter bit mask of a
 * WM_DEVICECHANGE message for the following wParam
 * (DBT_DEVICEREMOVECOMPLETE or DBT_DEVICEARRIVAL)
 * If this bit is set, then this message describes a change with
 * global drive letters and we should check if the drive letters
 * already exist in the receiver's LUID DosDevices.
 * If drive letter exists in the user's LUID DosDevices, then
 * un-set this drive letter in the msg's bitmask.
 */
#define DBV_FILTER_MSG 0x40000000

// If SERVER is UNICODE
//   Copy UNICODE -> UNICODE
//   or Copy ANSI -> UNICODE

// prototypes to client side functions only called by these stubs

// ddetrack.c

DWORD   _ClientCopyDDEIn1(HANDLE hClient, PINTDDEINFO pi);
VOID   _ClientCopyDDEIn2(PINTDDEINFO pi);
HANDLE _ClientCopyDDEOut1(PINTDDEINFO pi);
BOOL xxxClientCopyDDEIn2(PINTDDEINFO pi);
BOOL FixupDdeExecuteIfNecessary(HGLOBAL *phCommands, BOOL fNeedUnicode);
BOOL   _ClientCopyDDEOut2(PINTDDEINFO pi);
BOOL   _ClientFreeDDEHandle(HANDLE hDDE, DWORD flags);
DWORD  _ClientGetDDEFlags(HANDLE hDDE, DWORD flags);

/*
 * prototype for checking the drive letters used in the LUID DosDevice
 * map.  Does not check if the drive letters are used in the Global
 * DosDevices
 */
#ifdef RECVSIDE
DWORD  GetLUIDDosDrivesOnly();
#endif // RECVSIDE

typedef struct _GENERICHOOKHEADER {
    DWORD nCode;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} GENERICHOOKHEADER, * LPGENERICHOOKHEADER;

#ifdef RECVSIDE
ULONG_PTR CallHookWithSEH(GENERICHOOKHEADER *pmsg, LPVOID pData, LPDWORD pFlags, ULONG_PTR retval) {

    try {
        retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
                pmsg->nCode,
                pmsg->wParam,
                pData,
                pmsg->xParam);

    } except ((*pFlags & HF_GLOBAL) ? W32ExceptionHandler(FALSE, RIP_WARNING) : EXCEPTION_CONTINUE_SEARCH) {
        RIPMSG0(RIP_WARNING, "Hook Faulted");
        *pFlags |= HF_HOOKFAULTED;
    }

    return retval;
}
#endif // RECVSIDE

/**************************************************************************\
* fnOUTDWORDDWORD
*
* 14-Aug-1992 mikeke    created
\**************************************************************************/

typedef struct _FNOUTDWORDDWORDMSG {
    PWND pwnd;
    UINT msg;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNOUTDWORDDWORDMSG;

#ifdef SENDSIDE
SMESSAGECALL(OUTDWORDDWORD)
{
    SETUPPWND(FNOUTDWORDDWORD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOUTDWORDDWORD)

        LPDWORD lpdwW = (LPDWORD)wParam;
        LPDWORD lpdwL = (LPDWORD)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNOUTDWORDDWORD);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                *lpdwW = ProbeAndReadUlong((LPDWORD)pcbs->pOutput);
                *lpdwL = ProbeAndReadUlong((LPDWORD)pcbs->pOutput + 1);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOUTDWORDDWORD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOUTDWORDDWORD, FNOUTDWORDDWORDMSG)
{
    DWORD adwOut[2];
    BEGINRECV(0, adwOut, sizeof(adwOut));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            &adwOut[0],
            &adwOut[1],
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnOUTDWORDINDWORD
*
* 04-May-1993 IanJa     created (for MN_FINDMENUWINDOWFROMPOINT)
\**************************************************************************/

typedef struct _FNOUTDWORDINDWORDMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNOUTDWORDINDWORDMSG;

#ifdef SENDSIDE
SMESSAGECALL(OUTDWORDINDWORD)
{
    SETUPPWND(FNOUTDWORDINDWORD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOUTDWORDINDWORD)

        LPDWORD lpdwW = (LPDWORD)wParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNOUTDWORDINDWORD);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                *lpdwW = ProbeAndReadUlong((LPDWORD)pcbs->pOutput);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOUTDWORDINDWORD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOUTDWORDINDWORD, FNOUTDWORDINDWORDMSG)
{
    DWORD dwOut;
    BEGINRECV(0, &dwOut, sizeof(dwOut));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            &dwOut,
            CALLDATA(lParam),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnOPTOUTLPDWORDOPTOUTLPDWORD
*
* 25-Nov-1992 JonPa    created
\**************************************************************************/

typedef struct _FNOPTOUTLPDWORDOPTOUTLPDWORDMSG {
    PWND pwnd;
    UINT msg;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNOPTOUTLPDWORDOPTOUTLPDWORDMSG;

#ifdef SENDSIDE
SMESSAGECALL(OPTOUTLPDWORDOPTOUTLPDWORD)
{
    SETUPPWND(FNOPTOUTLPDWORDOPTOUTLPDWORD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOPTOUTLPDWORDOPTOUTLPDWORD)

        LPDWORD lpdwW = (LPDWORD)wParam;
        LPDWORD lpdwL = (LPDWORD)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNOPTOUTLPDWORDOPTOUTLPDWORD);
        UNLOCKPWND();
        CHECKR